<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>410b33aba7a9684e88952fd24b9fa416</guid>
<title>内部分享讲解DevOps后，我再组织成文</title>
<link>https://toutiao.io/k/asi9e5r</link>
<content:encoded>&lt;div&gt;&lt;body id=&quot;readabilityBody&quot; class=&quot;zh_CN wx_wap_page &amp;#10;&amp;#10;                                            wx_wap_desktop_fontsize_2    mm_appmsg&amp;#10; comment_feature&amp;#10; discuss_tab appmsg_skin_default appmsg_style_default&quot;&gt;
    





    






    






&lt;p class=&quot;wx_network_msg_wrp&quot; id=&quot;js_network_msg_wrp&quot;/&gt;

















&lt;div id=&quot;js_pc_weapp_code&quot; class=&quot;weui-desktop-popover weui-desktop-popover_pos-up-center weui-desktop-popover_img-text weapp_code_popover&quot;&gt;
  &lt;div class=&quot;weui-desktop-popover__inner&quot;&gt;
      &lt;div class=&quot;weui-desktop-popover__desc&quot;&gt;
          &lt;img id=&quot;js_pc_weapp_code_img&quot;/&gt;&lt;p&gt;
          微信扫一扫&lt;/p&gt;&lt;p&gt;使用小程序&lt;/p&gt;&lt;span id=&quot;js_pc_weapp_code_des&quot;/&gt;
      &lt;/div&gt;
  &lt;/div&gt;
&lt;/div&gt;





    
    

&lt;span aria-hidden=&quot;true&quot; class=&quot;weui-a11y_ref&quot; id=&quot;js_a11y_colon&quot;&gt;：&lt;/span&gt;
&lt;span aria-hidden=&quot;true&quot; class=&quot;weui-a11y_ref&quot; id=&quot;js_a11y_comma&quot;&gt;，&lt;/span&gt;
&lt;span aria-hidden=&quot;true&quot; class=&quot;weui-a11y_ref&quot; id=&quot;js_a11y_period&quot;&gt;。&lt;/span&gt;
&lt;span aria-hidden=&quot;true&quot; class=&quot;weui-a11y_ref&quot; id=&quot;js_a11y_space&quot;&gt; &lt;/span&gt;


&lt;span aria-hidden=&quot;true&quot; class=&quot;weui-a11y_ref&quot; id=&quot;js_a11y_type_video&quot;&gt;视频&lt;/span&gt;
&lt;span aria-hidden=&quot;true&quot; class=&quot;weui-a11y_ref&quot; id=&quot;js_a11y_type_weapp&quot;&gt;小程序&lt;/span&gt;


&lt;span aria-hidden=&quot;true&quot; class=&quot;weui-a11y_ref&quot; id=&quot;js_a11y_zan_btn_txt&quot;&gt;赞&lt;/span&gt;
&lt;span aria-hidden=&quot;true&quot; class=&quot;weui-a11y_ref&quot; id=&quot;js_a11y_zan_btn_tips&quot;&gt;，轻点两下取消赞&lt;/span&gt;
&lt;span aria-hidden=&quot;true&quot; class=&quot;weui-a11y_ref&quot; id=&quot;js_a11y_like_btn_txt&quot;&gt;在看&lt;/span&gt;
&lt;span aria-hidden=&quot;true&quot; class=&quot;weui-a11y_ref&quot; id=&quot;js_a11y_like_btn_tips&quot;&gt;，轻点两下取消在看&lt;/span&gt;

    
    
    













    






  &lt;/body&gt;
&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>aa809bc6771cd51a2849454b0297270b</guid>
<title>【深入浅出Spring原理及实战】「技术原理」Spring Security的核心功能和加载运行流程的原理分析_洛神灬殇的博客-CSDN博客</title>
<link>https://toutiao.io/k/69smrwo</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div id=&quot;content_views&quot; class=&quot;markdown_views prism-tomorrow-night&quot;&gt;
                    &lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot;&gt;
                        &lt;path stroke-linecap=&quot;round&quot; d=&quot;M5,0 0,2.5 5,5z&quot; id=&quot;raphael-marker-block&quot;/&gt;
                    &lt;/svg&gt;
                    &lt;h3&gt;&lt;a id=&quot;SpringSecurity_0&quot;/&gt;SpringSecurity的架构总览&lt;/h3&gt; 
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/img_convert/b1d24680d9f4fe071e264abed5a55e9c.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt; 
&lt;h3&gt;&lt;a id=&quot;Spring_Security_4&quot;/&gt;Spring Security的简介说明&lt;/h3&gt; 
&lt;p&gt;Spring Security对认证、授权和常见漏洞保护提供了全方位支持。使用的版本为：Spring Security 5.5.2。&lt;/p&gt; 
&lt;h4&gt;&lt;a id=&quot;_8&quot;/&gt;概念释义&lt;/h4&gt; 
 
&lt;h4&gt;&lt;a id=&quot;_17&quot;/&gt;技术原理&lt;/h4&gt; 
&lt;p&gt;Spring Security 在基于Servlet应用中，其底层是采用了Filter机制实现了对请求的认证、授权和漏洞防御等功能。&lt;/p&gt; 
&lt;p&gt;简单来说，可以理解为给Servlet设置一些Filters，这些Filters就构成了一个FilterChain。&lt;/p&gt; 
&lt;h5&gt;&lt;a id=&quot;_23&quot;/&gt;请求拦截处理&lt;/h5&gt; 
&lt;p&gt;每次当请求进来时，首先会被FilterChain中的Filters 依次捕获得到，每个Filter可以对请求进行一些预处理或对响应进行一些后置处理，最后才会到达Servlet。具体流程如下图所示：&lt;/p&gt; 
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/img_convert/5f95762f6542e2834bb763095a5d2980.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt; 
&lt;h5&gt;&lt;a id=&quot;FilterChain_29&quot;/&gt;FilterChain的实例对象&lt;/h5&gt; 
&lt;p&gt;FilterChain中的Filter主要有两方面作用：&lt;/p&gt; 
 
&lt;h5&gt;&lt;a id=&quot;DelegatingFilterProxy_37&quot;/&gt;DelegatingFilterProxy&lt;/h5&gt; 
&lt;ul&gt;&lt;li&gt; &lt;p&gt;基于Servlet规范，我们可以为 Servlet容器 注入一些自定义Filters，但是在 Spring 应用中，实现了Filter接口的Bean无法被 Servlet容器 感知到，没有调用ServletContext#addFilter方法注册到FilterChain中。&lt;/p&gt; &lt;/li&gt;&lt;li&gt; &lt;p&gt;Spring 提供了一个DelegatingFilterProxy代理类，DelegatingFilterProxy实现了Filter，因此它可以被注入到FilterChain中，同时，当请求到来时，它会把请求转发到Spring容器 中实现了Filter接口的 Bean 实体，所以DelegatingFilterProxy桥接了 Servlet容器 和 Spring容器。&lt;/p&gt; &lt;/li&gt;&lt;/ul&gt; 
&lt;p&gt;DelegatingFilterProxy作用示意图大致如下所示：&lt;/p&gt; 
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/img_convert/a94aad295230237c98435ebdda5180ea.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt; 
&lt;p&gt;当请求到来时，DelegatingFilterProxy会从ApplicationContext中获取FilterBean 实体，然后将请求转发给到它，伪代码如下所示：&lt;/p&gt; 
&lt;pre&gt;&lt;code class=&quot;prism language-java&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;doFilter&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token class-name&quot;&gt;ServletRequest&lt;/span&gt; request&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;ServletResponse&lt;/span&gt; response&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;FilterChain&lt;/span&gt; chain&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    
    
    &lt;span class=&quot;token class-name&quot;&gt;Filter&lt;/span&gt; delegate &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;getFilterBean&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;someBeanName&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
    
    delegate&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;doFilter&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;request&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; response&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt; 
&lt;h4&gt;&lt;a id=&quot;FilterChainProxy_59&quot;/&gt;FilterChainProxy&lt;/h4&gt; 
&lt;p&gt;Spring容器中的Filters Bean实体可以注入到Servlet容器中的FilterChain功能，基于此，Spring Security向Spring容器提供了一个FilterChainProxy Bean 实体，该FilterChainProxy实现了Filter接口，因此，请求就会被FilterChainProxy捕获到，这样 Spring Security 就可以开始工作了。&lt;/p&gt; 
&lt;p&gt;默认情况下，DelegatingFilterProxy从Spring容器中获取得到的就是FilterChainProxy实体，而FilterChainProxy也是一个代理类，它最终会将请求转发到 Spring Security 提供的SecurityFilterChain中，流程示意图如下所示：&lt;/p&gt; 
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/img_convert/64ebc3a442f53ae44191b02542101649.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt; 
&lt;blockquote&gt; 
 &lt;p&gt;注：FilterChainProxy就是 Spring Security 真正的入口起始点，调式代码时，将断点设置在FilterChainProxy#doFilter就可以追踪 Spring Security 完整调用流程。&lt;/p&gt; 
&lt;/blockquote&gt; 
&lt;h4&gt;&lt;a id=&quot;SecurityFilterChain_69&quot;/&gt;SecurityFilterChain&lt;/h4&gt; 
&lt;p&gt;SecurityFilterChain作用其实跟Servlet的FilterChain一样，同样维护了很多Filters，这些Filters 是由Spring Security提供的，每个 Security Filter 都有不同的职能，比如登录认证、CSRF防御…如下图所示：&lt;/p&gt; 
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/img_convert/76bfe46b8029d629c867fe838dae3d6c.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt; 
&lt;p&gt;同时，Spring Security 支持添加多个SecurityFilterChain，每个SecurityFilterChain负责不同的请求（比如依据请求地址进行区分），这样可以为不同的请求设置不同的认证规则。其源码如下所示：&lt;/p&gt; 
&lt;pre&gt;&lt;code class=&quot;prism language-java&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;interface&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;SecurityFilterChain&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    
    &lt;span class=&quot;token keyword&quot;&gt;boolean&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;matches&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token class-name&quot;&gt;HttpServletRequest&lt;/span&gt; request&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
    
    &lt;span class=&quot;token class-name&quot;&gt;List&lt;/span&gt;&lt;span class=&quot;token generics&quot;&gt;&lt;span class=&quot;token punctuation&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;token class-name&quot;&gt;Filter&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;getFilters&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt; 
&lt;p&gt;具体来说，当请求到达FilterChainProxy时，其内部会根据当前请求匹配得到对应的SecurityFilterChain，然后将请求依次转发给到该SecurityFilterChain中的所有 Security Filters。如下图所示：&lt;/p&gt; 
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/img_convert/b648173f4ecb8f49aa454ec953d17660.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt; 
&lt;h3&gt;&lt;a id=&quot;Security_Filters_90&quot;/&gt;Security Filters&lt;/h3&gt; 
&lt;p&gt;Spring Security 最终对请求进行处理的就是某个SecurityFilterChain中的 Security Filters，这些Filter都设置为 Bean 注入到 Spring容器中，且这些Filters 的先后顺序很重要。以下是 Spring Security 内置的完整 Security Filter 顺序列表：&lt;/p&gt; 
&lt;ul&gt;&lt;li&gt; &lt;p&gt;ChannelProcessingFilter：确保请求投递到要求渠道。最常见的使用场景就是指定哪些请求必须使用HTTPS 协议，哪些请求必须使用 HTTP 协议，哪些请求随便使用哪种协议均可。&lt;/p&gt; &lt;/li&gt;&lt;li&gt; &lt;p&gt;WebAsyncManagerIntegrationFilter：集成SecurityContext到 Spring Web 异步请求机制中的WebAsyncManager。&lt;/p&gt; 
  &lt;ul&gt;&lt;li&gt;注：SecurityContext就是 安全上下文，主要职能就是用于存储用户认证的一些信息。&lt;/li&gt;&lt;/ul&gt; &lt;/li&gt;&lt;li&gt; &lt;p&gt;SecurityContextPersistenceFilter：在每次请求处理之前，从 Session（默认使用HttpSessionSecurityContextRepository）中获取SecurityContext，然后将其设置给到SecurityContextHolder；在请求结束后，就会将SecurityContextHolder中存储的SecurityContext重新保存到 Session 中，并且清除SecurityContextHolder中的SecurityContext。&lt;/p&gt; 
  &lt;ul&gt;&lt;li&gt;SecurityContextPersistenceFilter可以通过HttpSecurity#securityContext()及相关方法引入其配置对象SecurityContextConfigurer来进行配置。&lt;/li&gt;&lt;/ul&gt; &lt;/li&gt;&lt;li&gt; &lt;p&gt;HeaderWriterFilter：该过滤器可为响应添加一些响应头，比如添加X-Frame-Options，X-XSS-Protection和X-Content-Type-Options等响应头，让浏览器开启保护功能。&lt;/p&gt; &lt;/li&gt;&lt;li&gt; &lt;p&gt;HeaderWriterFilter可以通过HttpSecurity#headers()来定制。&lt;/p&gt; &lt;/li&gt;&lt;li&gt; &lt;p&gt;CorsFilter：处理跨域资源共享（CORS）。&lt;/p&gt; 
  &lt;ul&gt;&lt;li&gt;CorsFilter可以通过HttpSecurity#cors()来定制。&lt;/li&gt;&lt;/ul&gt; &lt;/li&gt;&lt;li&gt; &lt;p&gt;CsrfFilter：处理跨站请求伪造(CSRF)。&lt;/p&gt; 
  &lt;ul&gt;&lt;li&gt;CsrfFilter可以通过HttpSecurity#csrf()来开启或关闭。在前后端分离项目中，不需要使用 CSRF。&lt;/li&gt;&lt;/ul&gt; &lt;/li&gt;&lt;li&gt; &lt;p&gt;LogoutFilter：处理退出登录请求。&lt;/p&gt; 
  &lt;ul&gt;&lt;li&gt;LogoutFilter可以通过HttpSecurity#logout()来定制退出逻辑。&lt;/li&gt;&lt;/ul&gt; &lt;/li&gt;&lt;li&gt; &lt;p&gt;OAuth2AuthorizationRequestRedirectFilter：用于构建 OAuth 2.0 认证请求，将用户请求重定向到该认证请求接口。&lt;/p&gt; 
  &lt;ul&gt;&lt;li&gt;注：该过滤器需要添加spring-security-oauth2等相关模块。&lt;/li&gt;&lt;/ul&gt; &lt;/li&gt;&lt;li&gt; &lt;p&gt;Saml2WebSsoAuthenticationRequestFilter：基于 SAML 的 SSO 单点登录认证请求过滤器。&lt;/p&gt; 
  &lt;ul&gt;&lt;li&gt;注：Saml2WebSsoAuthenticationRequestFilter需要添加 Spring Security SAML 模块。&lt;/li&gt;&lt;/ul&gt; &lt;/li&gt;&lt;li&gt; &lt;p&gt;X509AuthenticationFilter：X509 认证过滤器。&lt;/p&gt; 
  &lt;ul&gt;&lt;li&gt;X509AuthenticationFilter可以通过SecurityContext#X509()来启用和配置相关功能。&lt;/li&gt;&lt;/ul&gt; &lt;/li&gt;&lt;li&gt; &lt;p&gt;AbstractPreAuthenticatedProcessingFilter：认证预处理请求过滤器基类，其中认证主体已经由外部系统进行了身份验证。目的只是从传入请求中提取主体上的必要信息，而不是对它们进行身份验证。可以继承该类进行具体实现并通过HttpSecurity#addFilter方法来添加个性化的AbstractPreAuthenticatedProcessingFilter。&lt;/p&gt; &lt;/li&gt;&lt;li&gt; &lt;p&gt;CasAuthenticationFilter：用于处理 CAS 单点登录认证。&lt;/p&gt; 
  &lt;ul&gt;&lt;li&gt;注： CasAuthenticationFilter需要添加 Spring Security CAS 模块。&lt;/li&gt;&lt;/ul&gt; &lt;/li&gt;&lt;li&gt; &lt;p&gt;OAuth2LoginAuthenticationFilter：OAuth2.0 登录认证过滤器。&lt;/p&gt; 
  &lt;ul&gt;&lt;li&gt;注： OAuth2LoginAuthenticationFilter需要添加spring-security-oauth2等相关模块。&lt;/li&gt;&lt;/ul&gt; &lt;/li&gt;&lt;li&gt; &lt;p&gt;Saml2WebSsoAuthenticationFilter：基于 SAML 的 SSO 单点登录认证过滤器。&lt;/p&gt; 
  &lt;ul&gt;&lt;li&gt;注：Saml2WebSsoAuthenticationFilter需要添加 Spring Security SAML 模块。&lt;/li&gt;&lt;/ul&gt; &lt;/li&gt;&lt;li&gt; &lt;p&gt;UsernamePasswordAuthenticationFilter：用于处理表单登录认证。默认处理接口为/login，表单必须提供两个参数：用户名 和 密码，默认的参数名(key)为username和password，可以通过usernameParameter和passwordParameter方法进行修改。&lt;/p&gt; &lt;/li&gt;&lt;/ul&gt; 
&lt;p&gt;UsernamePasswordAuthenticationFilter可以通过HttpSecurity#formLogin()及相关方法引入其配置对象FormLoginConfigurer来进行配置。&lt;/p&gt; 
&lt;ul&gt;&lt;li&gt; &lt;p&gt;OpenIDAuthenticationFilter：基于 OpenID 认证协议的认证过滤器。&lt;/p&gt; &lt;/li&gt;&lt;li&gt; &lt;p&gt;DefaultLoginPageGeneratingFilter：如果没有配置登录页面，那么就会默认采用该过滤器生成一个登录表单页面。&lt;/p&gt; 
   &lt;/li&gt;&lt;li&gt; &lt;p&gt;DefaultLogoutPageGeneratingFilter：生成默认退出登录页面。&lt;/p&gt; 
   &lt;/li&gt;&lt;li&gt; &lt;p&gt;ConcurrentSessionFilter：主要用来判断 Session 是否过期以及更新最新访问时间。该过滤器可能会被多次执行。&lt;/p&gt; &lt;/li&gt;&lt;li&gt; &lt;p&gt;DigestAuthenticationFilter：用于处理 HTTP 头部显示的摘要式身份验证凭据。&lt;/p&gt; &lt;/li&gt;&lt;li&gt; &lt;p&gt;DigestAuthenticationFilter可以通过HttpSecurity#addFilter()来启用和配置相关功能。&lt;/p&gt; &lt;/li&gt;&lt;li&gt; &lt;p&gt;BearerTokenAuthenticationFilter：处理 Token 认证。&lt;/p&gt; &lt;/li&gt;&lt;li&gt; &lt;p&gt;BasicAuthenticationFilter：用于检测和处理 Http Baisc 认证。&lt;/p&gt; 
  &lt;ul&gt;&lt;li&gt;BasicAuthenticationFilter可以通过HttpSecurity#httpBasic()及相关方法引入其配置对象HttpBaiscConfigurer来进行配置。&lt;/li&gt;&lt;/ul&gt; &lt;/li&gt;&lt;li&gt; &lt;p&gt;RequestCacheAwareFilter：用于用户认证成功后，重新恢复因为登录被打断的请求。当匿名访问一个需要授权的资源时。会跳转到认证处理逻辑，此时请求被缓存。在认证逻辑处理完毕后，从缓存中获取最开始的资源请求进行再次请求。&lt;/p&gt; 
  &lt;ul&gt;&lt;li&gt;RequestCacheAwareFilter可以通过HttpSecurity#requestCache()及相关方法引入其配置对象RequestCacheConfigurer来进行配置。&lt;/li&gt;&lt;/ul&gt; &lt;/li&gt;&lt;li&gt; &lt;p&gt;SecurityContextHolderAwareRequestFilter：对请求对象进行包装，增加了一些安全相关方法。&lt;/p&gt; 
  &lt;ul&gt;&lt;li&gt;SecurityContextHolderAwareRequestFilter可以通过HttpSecurity#servletApi()及相关方法引入其配置对象ServletApiConfigurer来进行配置。&lt;/li&gt;&lt;/ul&gt; &lt;/li&gt;&lt;li&gt; &lt;p&gt;JaasApiIntegrationFilter：适用于 JAAS （Java 认证授权服务）。如果SecurityContextHolder中拥有的Authentication是一个JaasAuthenticationToken，那么该JaasApiIntegrationFilter将使用包含在JaasAuthenticationToken中的Subject继续执行FilterChain。&lt;/p&gt; &lt;/li&gt;&lt;li&gt; &lt;p&gt;RememberMeAuthenticationFilter：当用户没有登录而直接访问资源时，从 cookie 里找出用户的信息，如果 Spring Security 能够识别出用户提供的 remember me cookie，用户将不必填写用户名和密码，而是直接登录进入系统。它先分析 SecurityContext 里有没有Authentication对象，如果有，则不做任何操作，直接跳到下一个过滤器；如果没有，则检查请求里有没有包含 remember-me 的 cookie 信息。如果有，则解析出 cookie 里的验证信息，判断是否有权限。&lt;/p&gt; 
  &lt;ul&gt;&lt;li&gt;RememberMeAuthenticationFilter可以通过HttpSecurity#rememberMe()及相关方法引入其配置对象RememberMeConfigurer来进行配置。&lt;/li&gt;&lt;/ul&gt; &lt;/li&gt;&lt;li&gt; &lt;p&gt;AnonymousAuthenticationFilter：匿名认证过滤器，检测SecurityContextHolder中是否存在Authentication对象，如果不存在，就生成一个匿名Authentication对象。&lt;/p&gt; 
  &lt;ul&gt;&lt;li&gt;AnonymousAuthenticationFilter可以通过HttpSecurity#anonymous()及相关方法引入其配置对象AnonymousConfigurer来进行配置。&lt;/li&gt;&lt;/ul&gt; &lt;/li&gt;&lt;li&gt; &lt;p&gt;OAuth2AuthorizationCodeGrantFilter：OAuth 2.0 授权码模式，用于处理 OAuth 2.0 授权码响应。&lt;/p&gt; &lt;/li&gt;&lt;li&gt; &lt;p&gt;SessionManagementFilter：检测用户是否通过认证，如果已认证，就通过SessionAuthenticationStrategy进行 Session 相关管理操作。&lt;/p&gt; 
  &lt;ul&gt;&lt;li&gt;SessionManagementFilter可以通过HttpSecurity#sessionManagement()及相关方法引入其配置对象SessionManagementConfigurer来进行配置。&lt;/li&gt;&lt;/ul&gt; &lt;/li&gt;&lt;li&gt; &lt;p&gt;ExceptionTranslationFilter：可以用于捕获FilterChain上所有的异常，但只处理AccessDeniedException和AuthenticationException异常。&lt;/p&gt; &lt;/li&gt;&lt;li&gt; &lt;p&gt;FilterSecurityInterceptor：对 web资源 进行一些安全保护操作。&lt;/p&gt; &lt;/li&gt;&lt;li&gt; &lt;p&gt;SwitchUserFilter：主要用来作用户切换。&lt;/p&gt; &lt;/li&gt;&lt;/ul&gt; 
&lt;h3&gt;&lt;a id=&quot;_201&quot;/&gt;自动配置&lt;/h3&gt; 
&lt;p&gt;依据 Spring Boot 自动配置原理，其会自动加载spring-boot-autoconfigure.jar中/META-INF/spring.factories内键值org.springframework.boot.autoconfigure.EnableAutoConfiguration指定的自动配置类。查看该文件，可以看到，与 Spring Security 相关的自动配置类有如下几个：&lt;/p&gt; 
&lt;pre&gt;&lt;code&gt;org.springframework.boot.autoconfigure.security.servlet.SecurityAutoConfiguration,                                      \
org.springframework.boot.autoconfigure.security.servlet.UserDetailsServiceAutoConfiguration,                            \
org.springframework.boot.autoconfigure.security.servlet.SecurityFilterAutoConfiguration,                                \
org.springframework.boot.autoconfigure.security.reactive.ReactiveSecurityAutoConfiguration,                             \
org.springframework.boot.autoconfigure.security.reactive.ReactiveUserDetailsServiceAutoConfiguration,                   \
org.springframework.boot.autoconfigure.security.rsocket.RSocketSecurityAutoConfiguration,                               \
org.springframework.boot.autoconfigure.security.saml2.Saml2RelyingPartyAutoConfiguration,                               \
org.springframework.boot.autoconfigure.security.oauth2.client.servlet.OAuth2ClientAutoConfiguration,                    \
org.springframework.boot.autoconfigure.security.oauth2.client.reactive.ReactiveOAuth2ClientAutoConfiguration,           \
org.springframework.boot.autoconfigure.security.oauth2.resource.servlet.OAuth2ResourceServerAutoConfiguration,          \
org.springframework.boot.autoconfigure.security.oauth2.resource.reactive.ReactiveOAuth2ResourceServerAutoConfiguration, \
&lt;/code&gt;&lt;/pre&gt; 
&lt;p&gt;每个配置类都为 Spring Security 注入不同的 Bean 到 Spring容器中。这里我们着重介绍一下SecurityFilterAutoConfiguration和SecurityAutoConfiguration配置类，因为这两个配置类会自动装配DelegatingFilterProxy和FilterChain到 Spring容器 中。&lt;/p&gt; 
&lt;h4&gt;&lt;a id=&quot;FilterChainProxy_221&quot;/&gt;自动装配FilterChainProxy&lt;/h4&gt; 
&lt;p&gt;下面介绍下配置类SecurityAutoConfiguration，具体如下：&lt;/p&gt; 
&lt;pre&gt;&lt;code class=&quot;prism language-java&quot;&gt;&lt;span class=&quot;token annotation punctuation&quot;&gt;@Configuration&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;proxyBeanMethods &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token boolean&quot;&gt;false&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;token annotation punctuation&quot;&gt;@ConditionalOnClass&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token class-name&quot;&gt;DefaultAuthenticationEventPublisher&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token keyword&quot;&gt;class&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;token annotation punctuation&quot;&gt;@EnableConfigurationProperties&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token class-name&quot;&gt;SecurityProperties&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token keyword&quot;&gt;class&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;token annotation punctuation&quot;&gt;@Import&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;SpringBootWebSecurityConfiguration&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token keyword&quot;&gt;class&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;WebSecurityEnablerConfiguration&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token keyword&quot;&gt;class&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
        &lt;span class=&quot;token class-name&quot;&gt;SecurityDataConfiguration&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;SecurityAutoConfiguration&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;token annotation punctuation&quot;&gt;@Bean&lt;/span&gt;
    &lt;span class=&quot;token annotation punctuation&quot;&gt;@ConditionalOnMissingBean&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token class-name&quot;&gt;AuthenticationEventPublisher&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token keyword&quot;&gt;class&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;token keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;DefaultAuthenticationEventPublisher&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;authenticationEventPublisher&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token class-name&quot;&gt;ApplicationEventPublisher&lt;/span&gt; publisher&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;token keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;DefaultAuthenticationEventPublisher&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;publisher&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt; 
&lt;p&gt;SecurityAutoConfiguration导入了3个配置类，注重看WebSecurityEnablerConfiguration。&lt;br/&gt; 查看WebSecurityEnablerConfiguration配置类，其源码如下：&lt;/p&gt; 
&lt;pre&gt;&lt;code class=&quot;prism language-java&quot;&gt;&lt;span class=&quot;token annotation punctuation&quot;&gt;@Configuration&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;proxyBeanMethods &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token boolean&quot;&gt;false&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;token annotation punctuation&quot;&gt;@ConditionalOnMissingBean&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;name &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&quot;springSecurityFilterChain&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;token annotation punctuation&quot;&gt;@ConditionalOnClass&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token class-name&quot;&gt;EnableWebSecurity&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token keyword&quot;&gt;class&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;token annotation punctuation&quot;&gt;@ConditionalOnWebApplication&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;type &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;ConditionalOnWebApplication&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;Type&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token constant&quot;&gt;SERVLET&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;token annotation punctuation&quot;&gt;@EnableWebSecurity&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;WebSecurityEnablerConfiguration&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt; 
&lt;p&gt;当 Spring容器 中没有名称为springSecurityFilterChain的 Bean 等条件时，就会加载该配置类，此时@EnableWebSecurity注解生效：&lt;/p&gt; 
&lt;pre&gt;&lt;code class=&quot;prism language-java&quot;&gt;&lt;span class=&quot;token annotation punctuation&quot;&gt;@Retention&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token class-name&quot;&gt;RetentionPolicy&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token constant&quot;&gt;RUNTIME&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;token annotation punctuation&quot;&gt;@Target&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token class-name&quot;&gt;ElementType&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token constant&quot;&gt;TYPE&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;token annotation punctuation&quot;&gt;@Documented&lt;/span&gt;
&lt;span class=&quot;token annotation punctuation&quot;&gt;@Import&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;WebSecurityConfiguration&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token keyword&quot;&gt;class&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;SpringWebMvcImportSelector&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token keyword&quot;&gt;class&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;OAuth2ImportSelector&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token keyword&quot;&gt;class&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
        &lt;span class=&quot;token class-name&quot;&gt;HttpSecurityConfiguration&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;token annotation punctuation&quot;&gt;@EnableGlobalAuthentication&lt;/span&gt;
&lt;span class=&quot;token annotation punctuation&quot;&gt;@Configuration&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;token annotation punctuation&quot;&gt;@interface&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;EnableWebSecurity&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;token keyword&quot;&gt;boolean&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;debug&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;default&lt;/span&gt; &lt;span class=&quot;token boolean&quot;&gt;false&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt; 
&lt;p&gt;注解@EnableWebSecurity又导入了4个配置类，这里着重看下WebSecurityConfiguration：&lt;/p&gt; 
&lt;pre&gt;&lt;code class=&quot;prism language-java&quot;&gt;&lt;span class=&quot;token annotation punctuation&quot;&gt;@Configuration&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;proxyBeanMethods &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token boolean&quot;&gt;false&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;WebSecurityConfiguration&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;implements&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;ImportAware&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;BeanClassLoaderAware&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;
    
    &lt;span class=&quot;token annotation punctuation&quot;&gt;@Bean&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;name &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&quot;springSecurityFilterChain&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;token keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;Filter&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;springSecurityFilterChain&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;throws&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;Exception&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;
        &lt;span class=&quot;token keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;webSecurity&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;build&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt; 
&lt;p&gt;可以看到，WebSecurityConfiguration#springSecurityFilterChain()最终生成了一个名称为springSecurityFilterChain的 Bean 实体，该 Bean 的实际类型其实为FilterChainProxy，是由WebSecurity#build()方法创建的。&lt;/p&gt; 
&lt;p&gt;综上，SecurityAutoConfiguration配置类生成了很多 Bean 实体，其中最重要的一个是名称为springSecurityFilterChain的FilterChainProxy对象。&lt;/p&gt; 
&lt;h4&gt;&lt;a id=&quot;DelegatingFilterProxy_292&quot;/&gt;自动装配DelegatingFilterProxy&lt;/h4&gt; 
&lt;p&gt;下面介绍下配置类SecurityFilterAutoConfiguration，其源码如下所示：&lt;/p&gt; 
&lt;pre&gt;&lt;code class=&quot;prism language-java&quot;&gt;&lt;span class=&quot;token annotation punctuation&quot;&gt;@Configuration&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;proxyBeanMethods &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token boolean&quot;&gt;false&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;token annotation punctuation&quot;&gt;@ConditionalOnWebApplication&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;type &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;Type&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token constant&quot;&gt;SERVLET&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;token annotation punctuation&quot;&gt;@EnableConfigurationProperties&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token class-name&quot;&gt;SecurityProperties&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token keyword&quot;&gt;class&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;token annotation punctuation&quot;&gt;@ConditionalOnClass&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;AbstractSecurityWebApplicationInitializer&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token keyword&quot;&gt;class&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;SessionCreationPolicy&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;token annotation punctuation&quot;&gt;@AutoConfigureAfter&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token class-name&quot;&gt;SecurityAutoConfiguration&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token keyword&quot;&gt;class&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; 
&lt;span class=&quot;token keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;SecurityFilterAutoConfiguration&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;
    &lt;span class=&quot;token annotation punctuation&quot;&gt;@Bean&lt;/span&gt;
    &lt;span class=&quot;token annotation punctuation&quot;&gt;@ConditionalOnBean&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;name &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; “springSecurityFilterChain”&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;token keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;DelegatingFilterProxyRegistrationBean&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;securityFilterChainRegistration&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;
            &lt;span class=&quot;token class-name&quot;&gt;SecurityProperties&lt;/span&gt; securityProperties&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;
    &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt; 
&lt;p&gt;可以看到，要加载SecurityFilterAutoConfiguration前，必须先加载配置类SecurityAutoConfiguration，该配置类前面已经详细介绍了，主要功能就是注入了一个名称为springSecurityFilterChain的 Bean，因此，此时SecurityFilterAutoConfiguration#securityFilterChainRegistration就会生效，最终生成一个DelegatingFilterProxyRegistrationBean实体。DelegatingFilterProxyRegistrationBean实现了ServletContextInitializer接口，当系统执行ServletWebServerApplicationContext.selfInitialize()进行初始化时，会依次调用到：RegistrationBean.onStartup() --&amp;gt; DynamicRegistrationBean.register() --&amp;gt; AbstractFilterRegistrationBean.addRegistration()，其中，AbstractFilterRegistrationBean#addRegistration()源码如下：&lt;/p&gt; 
&lt;pre&gt;&lt;code class=&quot;prism language-java&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;protected&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;Dynamic&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;addRegistration&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token class-name&quot;&gt;String&lt;/span&gt; description&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;ServletContext&lt;/span&gt; servletContext&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;token class-name&quot;&gt;Filter&lt;/span&gt; filter &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;getFilter&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;token keyword&quot;&gt;return&lt;/span&gt; servletContext&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;addFilter&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token keyword&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;getOrDeduceName&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;filter&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; filter&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt; 
&lt;p&gt;this.getFilter()实际调用的是DelegatingFilterProxyRegistrationBean#getFilter()方法，其内部会创建一个DelegatingFilterProxy实例并返回，源码如下：&lt;/p&gt; 
&lt;pre&gt;&lt;code class=&quot;prism language-java&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;DelegatingFilterProxy&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;getFilter&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;token keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;DelegatingFilterProxy&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token keyword&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;targetBeanName&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;getWebApplicationContext&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;token keyword&quot;&gt;protected&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;initFilterBean&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;throws&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;ServletException&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt; 
&lt;p&gt;因此，AbstractFilterRegistrationBean#addRegistration()最终就是通过ServletContext#addFilter将一个DelegatingFilterProxy实例注入到 Servlet 的FilterChain中。&lt;/p&gt; 
&lt;p&gt;以上，就是 Spring Boot 中自动装配 Spring Security 相关配置源码分析，更加详细内容，可参考：&lt;/p&gt; 
&lt;h3&gt;&lt;a id=&quot;_337&quot;/&gt;总结&lt;/h3&gt; 
&lt;p&gt;Spring Security 作用机制大致如下：&lt;/p&gt; 
&lt;ol&gt;&lt;li&gt;注册标准Filter：首先，Spring 会自动注入一个DelegatingFilterProxy到 Servlet 的FilterChain中。&lt;/li&gt;&lt;li&gt;请求转发到 Spring Security：当请求到来时，DelegatingFilterProxy就会自动在 Spring容器 中搜索名称为springSecurityFilterChain的Filter实体，其实际类型为FilterChainProxy。DelegatingFilterProxy最终会将请求转发给到FilterChainProxy。&lt;/li&gt;&lt;li&gt;找到匹配请求处理的SecurityFilterChain：FilterChainProxy内部维护了一系列SecurityFilterChains，他会依据请求内容找到对应处理该请求的SecurityFilterChain。&lt;/li&gt;&lt;li&gt;请求处理：找到能处理请求的第一个SecurityFilterChain后，就会遍历该SecurityFilterChain内部维护的一系列Filters，依次让这些 Security Filter 处理该请求，完成认证、授权等功能。&lt;/li&gt;&lt;/ol&gt; 
&lt;h3&gt;&lt;a id=&quot;Spring_Security__347&quot;/&gt;Spring Security 架构简单示意图&lt;/h3&gt; 
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/img_convert/65312106d28bbccda30c6e41f3d25826.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
                &lt;/div&gt;
                
                
        &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>22435efb620166627d3c22a02c8011f7</guid>
<title>并发提升 10 倍，运算延时降低 70%，领健从 ClickHouse 和 Kudu 到 Apache Doris 数仓升级实践</title>
<link>https://toutiao.io/k/wx2ausy</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content js_underline_content             autoTypeSetting24psection&amp;#10;            &quot; id=&quot;js_content&quot;&gt;&lt;p data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.4255555555555556&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Uecg6b8kbSbFMFYjNSPkl5icLOQmTF0gtgtnfFcqXCM8rseMTv5WAh97v9jK9MR7FSN7cxlPu9FM7E1XpnyNbTw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;900&quot;/&gt;&lt;/p&gt;&lt;section data-mpa-template-id=&quot;1159112&quot; data-mpa-category=&quot;fav&quot;&gt;&lt;section&gt;&lt;section data-tools-id=&quot;21516&quot;&gt;&lt;section powered-by=&quot;KolEditor.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section powered-by=&quot;KolEditor.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;导读：&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;领健&lt;/span&gt;&lt;span&gt;最初使用 Apache Doris 替代了 ClickHouse，应用在为客户提供的增值报表服务中，解决了ClickHouse 并发宕机问题；在项目服务中发掘出 Doris 查询性能优异、简单易用、部署成本低等诸多优势，在 2021 年10月，领健决定将 Doris 引入到公司的数仓替代 Kudu，在 Doris 社区及 SelectDB 专业技术团队的支持下，业务逐步从 Kudu 迁移到 Doris，并在最近升级到 1.1.4 向量化版本。我们将通过本文为大家详细介绍领健基于 Doris 的演进实践及数仓构建的经验。&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;作者&lt;/span&gt;&lt;span&gt;｜&lt;/span&gt;&lt;/span&gt;&lt;span&gt;领健资深大数据开发工程师 &lt;span&gt;杨鷖&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;领健是健康科技行业 SaaS 软件的引领者，专注于消费医疗口腔和医美行业，为口腔诊所、医美机构、生美机构提供经营管理一体化系统，提供了覆盖单店管理、连锁管理、健康档案/电子病历、客户关系管理、智能营销、B2B交易平台、进销存、保险支付、影像集成、BI商业智能等覆盖机构业务全流程的一体化SaaS软件。同时通过开放平台连接产业上下游，与优质的第三方平台合作，为机构提供完整配套的一站式服务。截至当前，领健已经在全国设立了 20 余个分支机构，超过 30000 多家中高端以及连锁机构正在使用其服务。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-height=&quot;874&quot; data-ratio=&quot;0.8092592592592592&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Uecg6b8kbSZIPMgp5ELLpv6xWkzBS8aBe2XHPRwjPXZ17hOW8r4iayoVzMSsjlsT7mJbTbMcVt27SxDRKzRXCiag/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot; data-width=&quot;1080&quot;/&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p data-mid=&quot;&quot;&gt;Doris 在领健的演进历程&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;在进入正文之前，简单了解一下 Doris 在领健的发展历程。最初 Doris 替代 ClickHouse 被应用到数据服务项目中，该项目是领健为旗下客户提供的增值报表服务；&lt;/span&gt;&lt;span&gt;后在项目服务中发掘出 Doris 查询性能优异、简单易用、部署成本低等诸多优势，在 2021 年10月，我们决定扩大 Doris 应用范围，将 Doris 引入到公司的数仓中，在 Doris 社区及 SelectDB 专业技术团队的支持下，业务逐步从 Kudu 迁移到 Doris，并在最近升级到 1.1.4 向量化版本。我们将通过本文为大家详细介绍领健基于 Doris 的演进实践及数仓构建的经验。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-height=&quot;728&quot; data-ratio=&quot;0.4899057873485868&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Uecg6b8kbSZIPMgp5ELLpv6xWkzBS8aBHBQEqg4QXia8azGKGibU35Hffzjbuopbib7lPnZrSmiaCibwkma5s9gvuNQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1486&quot; data-width=&quot;1486&quot;/&gt;&lt;/section&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p data-mid=&quot;&quot;&gt;数据服务架构演进&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;h2/&gt;&lt;h4&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt; &lt;/span&gt;&lt;/strong&gt;&lt;/span&gt; &lt;/span&gt;&lt;span&gt;&lt;strong&gt;项目需求&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/h4&gt;&lt;section&gt;&lt;span&gt;领健致力于为医疗行业客户提供精细化门店运营平台，为客户提供了数据报表工具，该工具可实现自助式拖拽设计图表、支持多种自带函数自建、数据实时更新等功能，可以支持门店订单查询、客户管理、收入分析等，以推动门店数字化转型，辅助门店科学决策。为更好实现以上功能，数据报表工具需满足以下特点：&lt;/span&gt;&lt;/section&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;支持复杂查询&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;：客户进行自助拖拽设计图表时，将生成一段复杂的 SQL 查询语句直查数据库，且语句复杂度未知，这将对数据库带来不小的压力，从而影响查询性能。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;高并发低延时&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;：至少可以支撑 &lt;/span&gt;&lt;span&gt;&lt;strong&gt;100 &lt;/strong&gt;&lt;/span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;个&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;并发，并在 &lt;/span&gt;&lt;span&gt;&lt;strong&gt;1 秒&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;内得到查询结果；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;数据实时同步：&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;报表数据源自于 SaaS 系统，当客户对系统中的历史数据进行修改后，报表数据也要进行同步更改，保持一致，这就要求报表数据要与系统实现实时同步。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;低成本易部署：&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;SaaS 业务存在私有云客户，为降低私有化部署的人员及成本投入，这要求架构部署及运维要足够简单。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h4&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt; &lt;/span&gt;&lt;/strong&gt;&lt;/span&gt; &lt;/span&gt;&lt;span&gt;&lt;strong&gt;ClickHouse 遭遇并发宕机&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/h4&gt;&lt;h2&gt;&lt;span&gt;最初项目选用 ClickHouse 来提供数据查询服务，&lt;strong&gt;但在运行过程中 ClickHouse 遭遇了严重的并发问题，即 10 个并发就会导致 ClickHouse 宕机&lt;/strong&gt;，这使其无法正常为客户提供服务，这是迫使我们寻找可以替代 ClickHouse 产品的关键因素。&lt;/span&gt;&lt;br/&gt;&lt;/h2&gt;&lt;p&gt;&lt;span&gt;除此之外还有 2 个较为棘手的问题：&lt;/span&gt;&lt;/p&gt;&lt;h2&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt; &lt;/span&gt;&lt;/strong&gt;&lt;/span&gt; &lt;/span&gt;&lt;span&gt;&lt;strong&gt;技术选型&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;&lt;span&gt;针对存在的问题及需求，我们决定进行技术选型，分别对 Doris（0.14）、ClickHouse、Kudu 这 3 个产品展开的调研测试。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-height=&quot;698&quot; data-ratio=&quot;0.45265888456549935&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Uecg6b8kbSZIPMgp5ELLpv6xWkzBS8aB3pL4HRuox21XUUNyZNVWNJkrKEEPwkKmz9rUvibI24TeChIWPl6RPgg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1542&quot; data-width=&quot;1542&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;如上表所示，我们对这 3 个产品进行了横向比较，可以看出 &lt;/span&gt;&lt;span&gt;&lt;strong&gt;Doris 在多方面表现优异&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;：&lt;/span&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;高并发：&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;Doris 并发性好，可支持上百甚至上千并发，轻松解决 10 并发导致 ClickHouse 宕机问题。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;查询性能：&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;Doris 可实现毫秒级查询响应，在单表查询中，虽 Doris 与 ClickHouse 查询性能基本持平，但在多表查询中，Doris 远胜于 ClickHouse ，Doris 可以实现在较高的并发下，QPS 不下降。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;数据更新：&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;Doris 的数据模型可以满足我们对数据更新的需求，以保障系统数据和业务数据的一致性，下文将详细介绍。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;使用成本：&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;Doris 架构简单，整体部署简单快速，具有完备的导入功能，很好的弹性伸缩能力；同时， Doris 内部可以自动做副本平衡，运维成本极低。而 Clickouse 及 Kudu 对组件依赖较高，在使用上需要做许多准备工作，这就要求具备一支专业的运维支持团队来处理大量的日常运维工作。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;标准 SQ&lt;/span&gt;&lt;/strong&gt;&lt;strong&gt;&lt;span&gt;L：&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;Doris 兼容 MySQL 协议，使用标准 SQL，开发人员上手简单，不需要付出额外的学习成本。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;分布式 Join&lt;/span&gt;&lt;/strong&gt;&lt;span&gt; &lt;strong&gt;：&lt;/strong&gt;Doris 支持分布式 Join，而 ClickHouse 由于 Join 查询限制、函数局限性、以及可维护性较差等原因，不满足我们当前的业务需求。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;社区活跃：&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;Apache Doris 是国内自研数据库，开源社区相当活跃，同时 SelectDB 为 Doris 社区提供了专业且全职团队做技术支持，遇到问题可以直接与社区联系沟通，并能得到快速解决，这对于国外的项目，很大地降低与社区沟通的语言与时间成本。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;span&gt;从以上调研中可以发现，Doris 各方面能力优秀，十分符合我们对选型产品的需求，因此&lt;/span&gt;&lt;span&gt;&lt;strong&gt;我们使用 Doris 替代了 ClickHouse ，解决了ClickHouse 并发性能差、宕机等问题，很好的支撑了数据报表查询服务。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p data-mid=&quot;&quot;&gt;数仓架构演进&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;在数据报表的使用过程中，我们逐渐发掘出 Doris 诸多优势，因此决定扩大 Doris 应用范围，将 Doris 引入到公司的数仓中来。&lt;/span&gt;&lt;span&gt;&lt;strong&gt;接下来将为大家介绍公司数仓从 Kudu 到 Doris 的演进历程，以及在搭建过程中的优化实践分享&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/section&gt;&lt;h2&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt; &lt;/span&gt;&lt;/strong&gt;&lt;/span&gt; &lt;/span&gt;&lt;span&gt;&lt;strong&gt;早期数仓架构&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;&lt;section&gt;&lt;span&gt;早期的公司数仓架构使用 Kudu、Impala 来作为运算存储引擎，整体架构如下图所示。&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-height=&quot;720&quot; data-ratio=&quot;0.6060606060606061&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Uecg6b8kbSZIPMgp5ELLpv6xWkzBS8aBfeescauLzJ4Vfj36rKib8cYgUkOrkmNfuJKLS5pf040E9tmokIZiaLSQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1188&quot; data-width=&quot;1188&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;从上图可知，数据通过 Kafka Consumer 进入 ODS 层；通过 Kudu 层满足数据更新需要；运用 Impala 来执行数据运算和查询；通过自研平台 DMEP 进行任务调度。在 ETL 代码中会使用大量的 Upsert 对数据进行 Merge 操作，那么引入 Doris 的首要问题就是要如何实现 Merge 操作，支持业务数据更新，下文中将进行介绍。&lt;/span&gt;&lt;/p&gt;&lt;h2&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt; &lt;/span&gt;&lt;/strong&gt;&lt;/span&gt; &lt;/span&gt;&lt;span&gt;&lt;strong&gt;新数仓架构&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;&lt;h2&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-height=&quot;690&quot; data-ratio=&quot;0.5390625&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Uecg6b8kbSZIPMgp5ELLpv6xWkzBS8aBpDVdNlfLIQTqKpXfw2czBMbx0cazULwRrpty31FfdhM3XxJ92SPztQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot; data-width=&quot;1280&quot;/&gt;&lt;br/&gt;&lt;/h2&gt;&lt;p&gt;&lt;span&gt;如上图所示，在新架构设计中使用 &lt;/span&gt;&lt;span&gt;&lt;strong&gt;Apache Doris 负责数仓存储及数据运算&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;；实时数据、 ODS数据的同步从 Kafka Consumter 改为 Flink ；流计算平台使用团队自研的 Duckula；任务调度则引入最新 的 DolphinSchedular，Dolphin schedule 几乎涵盖了自研 DMEP 的大部分功能，同时可以很方便拓展 ETL 的方式，可调度很多不同的任务。&lt;/span&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p data-mid=&quot;&quot;&gt;优化实践&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;h2&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt; &lt;/span&gt;&lt;/strong&gt;&lt;/span&gt; &lt;/span&gt;&lt;span&gt;&lt;strong&gt;数据模型选择&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;&lt;section&gt;&lt;span&gt;上文中提到，当客户对系统中的历史数据修改后，报表数据也要进行同步更改，同时，客户有时只更改某一列的数值，这要求我们需要选择合适的 Doris 模型来满足这些需求。我们在测试中发现，通过 Aggregate 聚合模型+&lt;/span&gt;&lt;code&gt;Replace_if_not_null&lt;/code&gt;&lt;span&gt;方式进行数据更新时，可以实现单独更新一列，代码如下：&lt;/span&gt;&lt;/section&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;drop table test.expamle_tbl2&lt;br/&gt;&lt;br/&gt;&lt;br/&gt;CREATE TABLE IF NOT EXISTS test.expamle_tbl2&lt;br/&gt;(&lt;br/&gt;    `user_id` LARGEINT NOT &lt;span&gt;NULL&lt;/span&gt; COMMENT &lt;span&gt;&quot;用户id&quot;&lt;/span&gt;,&lt;br/&gt;    `date` DATE NOT &lt;span&gt;NULL&lt;/span&gt; COMMENT &lt;span&gt;&quot;数据灌入日期时间&quot;&lt;/span&gt;,&lt;br/&gt;    `city` VARCHAR(&lt;span&gt;20&lt;/span&gt;) COMMENT &lt;span&gt;&quot;用户所在城市&quot;&lt;/span&gt;,&lt;br/&gt;    `age` SMALLINT COMMENT &lt;span&gt;&quot;用户年龄&quot;&lt;/span&gt;,&lt;br/&gt;    `sex` TINYINT COMMENT &lt;span&gt;&quot;用户性别&quot;&lt;/span&gt;,&lt;br/&gt;    `last_visit_date` DATETIME &lt;span&gt;&lt;strong&gt;REPLACE_IF_NOT_NULL&lt;/strong&gt;&lt;/span&gt; COMMENT &lt;span&gt;&quot;用户最后一次访问时间&quot;&lt;/span&gt;,&lt;br/&gt;    `cost` BIGINT &lt;span&gt;REPLACE_IF_NOT_NULL&lt;/span&gt; COMMENT &lt;span&gt;&quot;用户总消费&quot;&lt;/span&gt;,&lt;br/&gt;    `max_dwell_time` INT &lt;span&gt;REPLACE_IF_NOT_NULL&lt;/span&gt; COMMENT &lt;span&gt;&quot;用户最大停留时间&quot;&lt;/span&gt;,&lt;br/&gt;    `min_dwell_time` INT &lt;span&gt;REPLACE_IF_NOT_NULL&lt;/span&gt; COMMENT &lt;span&gt;&quot;用户最小停留时间&quot;&lt;/span&gt;&lt;br/&gt;)&lt;br/&gt;&lt;span&gt;AGGREGATE &lt;span&gt;KEY&lt;/span&gt;&lt;span&gt;(`user_id`, `date`, `city`, `age`, `sex`)&lt;/span&gt;&lt;br/&gt;DISTRIBUTED BY &lt;span&gt;HASH&lt;/span&gt;&lt;span&gt;(`user_id`)&lt;/span&gt; BUCKETS 1&lt;br/&gt;&lt;span&gt;PROPERTIES&lt;/span&gt; &lt;span&gt;(&lt;br/&gt;&lt;span&gt;&quot;replication_allocation&quot;&lt;/span&gt; = &lt;span&gt;&quot;tag.location.default: 1&quot;&lt;/span&gt;&lt;br/&gt;)&lt;/span&gt;&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;&lt;br/&gt;&lt;br/&gt;insert into test.&lt;span&gt;expamle_tbl2 &lt;br/&gt;&lt;span&gt;values&lt;/span&gt;&lt;span&gt;(&lt;span&gt;10000&lt;/span&gt;,&lt;span&gt;&#x27;2017-10-01&#x27;&lt;/span&gt;,&lt;span&gt;&#x27;北京&#x27;&lt;/span&gt;,&lt;span&gt;20&lt;/span&gt;,&lt;span&gt;0&lt;/span&gt;,&lt;span&gt;&#x27;017-10-01 06:00:00&#x27;&lt;/span&gt;,&lt;span&gt;20&lt;/span&gt;,&lt;span&gt;10&lt;/span&gt;,&lt;span&gt;10&lt;/span&gt;)&lt;/span&gt;&lt;/span&gt;;&lt;br/&gt;select * from test.expamle_tbl ;&lt;br/&gt;&lt;br/&gt;insert into test.expamle_tbl2 (user_id,date,city,age,sex,cost)&lt;br/&gt;values(&lt;span&gt;10000&lt;/span&gt;,&lt;span&gt;&#x27;2017-10-01&#x27;&lt;/span&gt;,&lt;span&gt;&#x27;北京&#x27;&lt;/span&gt;,&lt;span&gt;20&lt;/span&gt;,&lt;span&gt;0&lt;/span&gt;,&lt;span&gt;50&lt;/span&gt;);&lt;br/&gt;select * from test.expamle_tbl ;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;如下图所示，当写 50 进去，可以实现只覆盖&lt;/span&gt;&lt;code&gt;Cost&lt;/code&gt;&lt;span&gt;列，其他列保持不变。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-height=&quot;252&quot; data-ratio=&quot;0.196875&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Uecg6b8kbSZIPMgp5ELLpv6xWkzBS8aBQJsU0GUUmanh6ozL2NicdBJGEUzEqfykXNIBLVv43sxzZT5gntE0h6g/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot; data-width=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-height=&quot;242&quot; data-ratio=&quot;0.1890625&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Uecg6b8kbSZIPMgp5ELLpv6xWkzBS8aBDosJZiblOQliaAYZkl0bD5xEbLF7mdxc2HTzQqpuPibaaq8R79Zc1LEPg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot; data-width=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;h2&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt; &lt;/span&gt;&lt;/strong&gt;&lt;/span&gt; &lt;/span&gt;&lt;span&gt;&lt;strong&gt;Doris Compaction 优化&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;&lt;span&gt;当 Flink 抽取业务库全量数据、持续不断高频写入 Doris 时，将产生了大量数据版本，&lt;strong&gt;Doris 的 Compaction 合并版本速度跟不上新版本生成速度，从而造成数据版本堆积&lt;/strong&gt;。从下图可看出，BE Compaction Score 分数很高，最高可以达到 400，而健康状态分数应在 100 以下。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-height=&quot;719&quot; data-ratio=&quot;0.56171875&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Uecg6b8kbSZIPMgp5ELLpv6xWkzBS8aB3V1eE0Pq4zia8jtWGG8y9MpAcBibcYKwIHS1dYLjBRADPoNZjG94ic95A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot; data-width=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;针对以上问题我们做了以下调整：&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;全量数据不&lt;strong&gt;使用实时写入的方式&lt;/strong&gt;，先导出到 CSV，再通过 Stream Load 写入 Doris；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;降低 Flink 写入频率，增大 Flink 单一批次数据量&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;；该调整会降低数据的实时性，需与业务侧进行沟通，根据业务方对实时性的要求调整相关数值，最大程度的降低写入压力。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;调节 Doris BE 参数&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;，使更多 CPU 资源参与到 Compaction 操作中；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;code&gt;compaction_task_num_per_disk&lt;/code&gt;&lt;span&gt;单磁盘 Compaction 任务线程数默认值 2，提升后会大量占用CPU资源，阿里云 16 核，提升 1 个线程多占用 6% 左右 CPU。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;code&gt;max_compaction_threads compaction&lt;/code&gt;&lt;span&gt;线程总数默认为10。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;max_cumulative_compaction_num_singleton_deltas&lt;/span&gt;&lt;span&gt; 参数控制一个 CC 任务最多合并 1000 个数据版本，适当改小后单个 Compaction 任务的执行时间变短，执行频率变高，集群整体版本数会更加稳定。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/ul&gt;&lt;p&gt;&lt;span&gt;通过调整集群， &lt;/span&gt;&lt;span&gt;&lt;strong&gt;Compaction Score 稳定在了 50-100，有效解决了版本堆积问题。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-height=&quot;467&quot; data-ratio=&quot;0.36484375&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Uecg6b8kbSZIPMgp5ELLpv6xWkzBS8aBK1pTxxtXmfm2Kbls9mwwkFxbBGDP2djAibiaqKP0KOicnVgscHKiaXbXnA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot; data-width=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;值得关注的是，在 &lt;/span&gt;&lt;span&gt;&lt;strong&gt;Doris 1.1 版本中对 Compaction 进行了一系列的优化&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;，在&lt;strong&gt;任务调度层面&lt;/strong&gt;，增加了主动触发式的 Compaction 任务调度，结合原有的被动式扫描，高效的感知数据版本的变化，主动触发Compaction。在&lt;strong&gt;任务执行层面&lt;/strong&gt;，对资源进行隔离，将重量级的 Base Compaction 和轻量级的Cumulative Compaction 进行了物理分离，防止任务的互相影响。同时，&lt;strong&gt;针对高频小文件的导入&lt;/strong&gt;，优化文件合并策略，采用梯度合并的方式，保证单次合并的文件都属于同一数量级，逐渐有层次的进行数据合并，减少单个文件参与合并的次数，大幅节省系统消耗。&lt;/span&gt;&lt;/section&gt;&lt;h2&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt; &lt;/span&gt;&lt;/strong&gt;&lt;/span&gt; &lt;/span&gt;&lt;span&gt;&lt;strong&gt;负载隔离&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;&lt;h2&gt;&lt;span&gt;最初我们只有 1 个 Doris 集群，Doris 集群要同时支持高频实时写、 高并发查询、ETL 处理以及Adhoc 查询等功能。其中高频实时写对 CPU 的占用很高，而 CPU 的上限决定高并发查询的能力，另外 Adhoc 查询无法预知 SQL 的复杂度，当复杂度过高时也会占用较高的内存资源，&lt;/span&gt;&lt;strong&gt;&lt;span&gt;这就导致了资源竞争，业务之间互相影响的问题&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;。为解决这些问题，我们进行了以下探索优化。&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-height=&quot;666&quot; data-ratio=&quot;0.5203125&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Uecg6b8kbSZIPMgp5ELLpv6xWkzBS8aB7Oiabtc7n8ibNn5p6ZZuvVRL8Pm7iaQiaibtjD6ENKOq4Yh3AE3lMiatRzHA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot; data-width=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;1. Doris 集群拆分&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;最初我们尝试对 Doris 集群进行拆分，我们把 1 个集群拆分为 3 个集群，分别为 ODS 集群、DW 集群、ADS 集群。我们将 CPU 负载最高的 ODS 层分离出去， ETL 时，通过 Doris 外表连接另一个 Doris 集群抽取数据；同时也将 BI 应用访问的集群分离出去，独立为业务提供数据查询。&lt;strong&gt;如下所示为各集群负责的任务&lt;/strong&gt;：&lt;/span&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;ODS 集群：数仓 ODS 层，Flink 写数据集中在此层进行。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;DW 集群：数仓 DW 层，DIM 层，主要负责 ETL 处理，Adhoc 查询任务。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;ADS 集群：数仓 ADS 层，主要支持 Web 应用的数据查询&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-height=&quot;359&quot; data-ratio=&quot;0.43833943833943834&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Uecg6b8kbSZIPMgp5ELLpv6xWkzBS8aBCTGFpvcaXpBYnvL75wib1DuSeXSmzNFOqr4gJibRET8o52w1yqlpwgiag/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;819&quot; data-width=&quot;819&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;通过集群拆分，有效降低各个资源间的相互影响，保证每个业务运转都有较充足的资源。但是&lt;strong&gt;集群的拆分也存在集群之间数据同步 ETL 时间较长、从 ADS 到 ODS 跨3个集群的数据校验复杂度较高等问题&lt;/strong&gt;。直到 Doris 0.15 发布后，这些问题也得到了相对有效的解决。&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;2. 资源隔离优化集群资源&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;Doris 0.15 版本&lt;strong&gt;新增了资源标签功能以及查询 Block 功能&lt;/strong&gt;，资源标签功能允许 Doris 集群实现资源隔离，该功能有效减少集群之间同步数据的时间，降低了跨集群数据校验复杂度。其次查询 Block 功能的上线，可以对 SQL 进行查询审计，阻塞简单/不合规的查询语句，降低资源占用率，提升查询性能。除此之外，通过资源隔离的方式，我们将 3 个集群合并成 1 个集群，被合并的 6 个入口节点 FE 被释放掉，将节省的资源加到核心的运算节点上来。&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;升级到 Doris 0.15 后，我们将 ODS 表的副本修改为&lt;/span&gt;&lt;code&gt;group_ods&lt;/code&gt;&lt;span&gt;3 &lt;/span&gt;&lt;span&gt;份，&lt;/span&gt;&lt;code&gt;default&lt;/code&gt;&lt;span&gt;3 份。&lt;/span&gt;&lt;span&gt;Flink 写入时只写&lt;/span&gt;&lt;code&gt;group_ods&lt;/code&gt;&lt;span&gt; 资源组的节点，数据写入后，得益于 D&lt;/span&gt;&lt;span&gt;oris 内部的副本同步机制，数据会自动实时同步到&lt;/span&gt;&lt;code&gt;default&lt;/code&gt;&lt;span&gt; 资源组。&lt;/span&gt;&lt;span&gt;ETL 则可以使用&lt;/span&gt;&lt;code&gt;default&lt;/code&gt;&lt;span&gt;资源组的节点资源取用 ODS 数据，进行查询和数据处理。&lt;/span&gt;&lt;span&gt;同理 ADS 也做了相同处理，原先需要通过外表进行数据抽取同步的表，均被做成了副本跨资源组的形式。&lt;/span&gt;&lt;span&gt;此方式有效缩短了跨集群数据同步的 ETL 时长 。&lt;/span&gt;&lt;span/&gt;&lt;span/&gt;&lt;span/&gt;&lt;/p&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-height=&quot;720&quot; data-ratio=&quot;0.7272727272727273&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Uecg6b8kbSZIPMgp5ELLpv6xWkzBS8aBia7HnQTypwvLx90SuDUOAGvC7jnPH0BdVqUdNwtsGr2N148c1JcXr7g/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;990&quot; data-width=&quot;990&quot;/&gt;&lt;/section&gt;&lt;h2&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt; &lt;/span&gt;&lt;/strong&gt;&lt;/span&gt; &lt;/span&gt;&lt;span&gt;&lt;strong&gt;离线 ETL 内存高&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;&lt;section&gt;&lt;span&gt;我们使用的是离线 ETL 方式直接在 Doris 上做 ETL 操作，在 Join 时，如果右表数据量比较大的情况下会消耗大量的内存，从而造成 OOM。在 1.0 版本之前内存跟踪能力较弱，容易造成 BE 节点超出 Linux 限制，导致进程被关闭 ，这时候会收到以下报错信息：&lt;/span&gt;&lt;code&gt;Host is down&lt;/code&gt;&lt;span&gt; 或者&lt;/span&gt;&lt;code&gt;Fail to initialize storage reader&lt;/code&gt;&lt;span&gt;。&lt;/span&gt;&lt;span&gt;在1.0 及更高版本中， Doris 由于优化了内存跟踪，则容易见到以下报错：&lt;/span&gt;&lt;span&gt;Memory exceed limit. Used: XXXX ,Limit XXXX.&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;针对内存受限问题，我们开始寻找优化方案，另外由于公司内部资源受限，&lt;/span&gt;&lt;span&gt;&lt;strong&gt;优化方案必须在不增加集群成本的情况下把超出集群负荷的任务跑通&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;。这里为大家介绍 2 个解决方法：&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;1. 优化调整 Join 的方式：&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;Doris 内部 Join 分为 4 种，其内存开销以及优先级如下图所示：&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-height=&quot;303&quot; data-ratio=&quot;0.23671875&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Uecg6b8kbSZIPMgp5ELLpv6xWkzBS8aBhky46Fj1F7abF9mnKK4S3fJs4CXBqlT3871pnPqh3XBwqibX3LCcoBQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot; data-width=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;从上图可知，Join 类型优先级从左往右依次变低，Shuffle 的优先级最低，排在 Broadcast 之后。&lt;/span&gt;&lt;span&gt;&lt;strong&gt;值得注意的是&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;， Broadcast 内存开销非常大，它将右表广播到所有 BE 节点，这相当于每个 BE 节点会消耗一个右表的内存，这将造成很大的内存开销。&lt;/span&gt;&lt;span&gt;&lt;strong&gt;针对 Broadcast 比较大的内存开销，我们通过 Hint 条件强制 Join 类型的方式，使 Join 语句跳过 Broadcast 到 Shuffle Join ，从而降低内存消耗&lt;/strong&gt;。&lt;/span&gt;&lt;/p&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;select&lt;/span&gt; * &lt;span&gt;from&lt;/span&gt; a &lt;span&gt;join&lt;/span&gt; [shuffle] b &lt;span&gt;on&lt;/span&gt; a.k1 = b.k1;&lt;span/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;2. 数据分批处理&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;我们尝试将数据按照时间分批，每批涵盖某一个或某几个时间段的数据，分批进行 ETL，有效降低内存消耗，避免 OOM 。&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;分批须知：&lt;/strong&gt;需要将分批的标记列放在主键中，最大程度提升搜索数据的效率；注意分桶和分区的设置方式，保证每个分区的数据量都比较均衡，避免个别分区内存占用较高的问题。&lt;/span&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p data-mid=&quot;&quot;&gt;总结&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;h2&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt; &lt;/span&gt;&lt;/strong&gt;&lt;/span&gt; &lt;/span&gt;&lt;span&gt;&lt;strong&gt;新架构收益&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;基于 Doris 的新数仓架构不再依赖 Hadoop 生态组件，运维简单，维护成本低。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;具有更高性能，使用更少的服务器资源，提供更强的数据处理能力。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;支持高并发，能直接支持 WebApp 的查询服务。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;支持外表，可以很方便的进行数据&lt;/span&gt;&lt;span&gt;发布，将数据推送其他数据库中。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;支持动态扩容，数据自动平衡。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;支持多种联邦查询方式，支持 Hive、ES、MySQL 等&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;section&gt;&lt;span&gt;得益于新架构的优异能力，我们所用集群从&lt;/span&gt;&lt;span&gt;&lt;strong&gt; 18 台&lt;/strong&gt;&lt;/span&gt;&lt;span&gt; 16C128G 减少到 &lt;/span&gt;&lt;span&gt;&lt;strong&gt;12 台&lt;/strong&gt;&lt;/span&gt;&lt;span&gt; 16C128G，集群资源较之前&lt;/span&gt;&lt;span&gt;&lt;strong&gt;节省了34%&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;，大大降低了投入成本；并且运算性能得到大幅提升，在 Kudu 上&lt;/span&gt;&lt;span&gt;&lt;strong&gt; 3 小时&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;即可完成的 ETL 任务， Doris 只需要 &lt;/span&gt;&lt;span&gt;&lt;strong&gt;1 小时&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;即可完成 。除此之外，高频更新的场景下，Kudu 内部数据碎片文件不能进行自动合并，表的性能会越来越差，需要定期重建；而 Doris 内部的 Compaction 机制可以有效避免此问题。&lt;/span&gt;&lt;/section&gt;&lt;h2&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt; &lt;/span&gt;&lt;/strong&gt;&lt;/span&gt; &lt;/span&gt;&lt;span&gt;&lt;strong&gt;社区寄语&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;&lt;section&gt;&lt;span&gt;首先，&lt;/span&gt;&lt;span&gt;&lt;strong&gt;Doris 的使用成本很低&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;，仅需要 3 台低配服务器、甚至是台式机，就能相对容易的部署一套基于 Doris 的数仓作为数据中台基础；我认为对于想要进行数字化，但介于资源投入有限而又不想落后于市场的企业来说，&lt;/span&gt;&lt;span&gt;&lt;strong&gt;非常建议尝试使用 Apache Doris ，Doris 可以助力企业低成本跑通整个数据中台&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;其次，Doris 是一款国人自研的的 MPP 架构分析型数据库，这令我感到很自豪，同时其社区十分活跃、便于沟通，&lt;/span&gt;&lt;span&gt;&lt;strong&gt;Doris 背后的商业化公司 SelectDB 为社区组建了一支专职技术团队，任何问题都能在 1 小时内得到响应，近 1 年社区更是在 SelectDB 的持续推动下，推出了一系列十分抗打的新特性&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;。另外社区在版本迭代时会认真考虑中国人的使用习惯，这些会为我们的使用带来很多便利。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;最后，感谢 Doris 社区和 SelectDB 团队的全力支持，也欢迎开发者以及各企业多多了解 Doris、使用 Doris，支持国产数据！&lt;/span&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p data-mid=&quot;&quot;&gt;Doris 1.2.0 传送门&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;Apache Doris 于 2022 年 12 月 7 日迎来 1.2.0 Release 版本的正式发布！新版本中实&lt;/span&gt;&lt;span&gt;&lt;strong&gt;现了全面的向量化&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;、实现多场景查询性能 &lt;/span&gt;&lt;span&gt;&lt;strong&gt;3-11 倍的提升&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;，在 Unique Key 模型上实现了 &lt;/span&gt;&lt;span&gt;&lt;strong&gt;Merge-on-Write &lt;/strong&gt;&lt;/span&gt;&lt;span&gt;的数据更新模式、数据高频更新时查询性能&lt;/span&gt;&lt;span&gt;&lt;strong&gt;提升达 3-6 倍&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;，增加了 Multi-Catalog 多源数据目录&lt;/span&gt;&lt;span&gt;&lt;strong&gt;、提供了无缝接入 Hive、ES、Hudi、Iceberg 等外部数据源的能力&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;，引入了&lt;/span&gt;&lt;span&gt;&lt;strong&gt; Light Schema Change &lt;/strong&gt;&lt;/span&gt;&lt;span&gt;轻量表结构变更、实现毫秒级的 Schema Change 操作并可以借助 Flink CDC &lt;/span&gt;&lt;span&gt;&lt;strong&gt;自动同步上游数据库的 DML 和 DDL 操作&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;，以 JDBC 外部表替换了过去的 ODBC 外部表，支持了 Java UDF 和 Romote UDF 以及 Array 数组类型和 JSONB 类型，修复了诸多之前版本的性能和稳定性问题，推荐大家下载和使用！&lt;/span&gt;&lt;/section&gt;&lt;h2&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;下载安装：&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;（复制到浏览器打开）&lt;/span&gt;&lt;span&gt;&lt;strong&gt;&lt;span/&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;&lt;span&gt;GitHub下载：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span/&gt;&lt;span&gt;https://github.com/apache/doris/releases&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;官网下载页：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span/&gt;&lt;span&gt;https://doris.apache.org/download&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;源码地址：&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;span/&gt;&lt;span&gt;https://github.com/apache/doris/releases/tag/1.2.0-rc04&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;— &lt;/span&gt;&lt;strong&gt;END&lt;/strong&gt;&lt;span&gt; —&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span data-docs-delta=&quot;[[20,{&amp;quot;gallery&amp;quot;:&amp;quot;https://uploader.shimo.im/f/s3aWTKah9u80nENw.png!thumbnail&amp;quot;},&amp;quot;29:0|30:0|3:\&amp;quot;281px\&amp;quot;|4:\&amp;quot;281px\&amp;quot;|crop:\&amp;quot;\&amp;quot;|frame:\&amp;quot;none\&amp;quot;|ori-height:\&amp;quot;700\&amp;quot;|ori-width:\&amp;quot;700\&amp;quot;&amp;quot;]]&quot; data-copy-origin=&quot;https://shimo.im&quot;&gt;&lt;p&gt;&lt;span&gt;最后，欢迎更多的开源技术爱好者加入 Apache Doris 社区，携手成长，共建社区生态。&lt;/span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;Apache Doris 社区当前已容纳了上万名开发者和使用者，承载了 30+ 交流社群&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;，如果你也是 Apache Doris 的爱好者，扫码加入 Apache Doris 社区用户交流群，在这里你可以获得：&lt;/span&gt;&lt;/p&gt;&lt;/span&gt;&lt;/section&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;专业全职团队技术支持&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;直接和社区专家交流，获取免费且专业回复&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;认识不同行业的开发者，收获知识以及合作机会&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;Apache Doris 最新版本优先体验权&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;获取一手干货和资讯以及活动优先参与权&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;section&gt;&lt;span data-docs-delta=&quot;[[20,{&amp;quot;gallery&amp;quot;:&amp;quot;https://uploader.shimo.im/f/s3aWTKah9u80nENw.png!thumbnail&amp;quot;},&amp;quot;29:0|30:0|3:\&amp;quot;281px\&amp;quot;|4:\&amp;quot;281px\&amp;quot;|crop:\&amp;quot;\&amp;quot;|frame:\&amp;quot;none\&amp;quot;|ori-height:\&amp;quot;700\&amp;quot;|ori-width:\&amp;quot;700\&amp;quot;&amp;quot;]]&quot; data-copy-origin=&quot;https://shimo.im&quot;&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.3333333333333333&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/Uecg6b8kbSZL3g8IxEf9VAjtemticsF1WyBwBN6z3icVk0MMQdU0zd2pHs7Q3essrpUiaibaCRnicapRxZYXfEP33gA/640?wx_fmt=gif&quot; data-type=&quot;gif&quot; data-w=&quot;900&quot;/&gt;&lt;/p&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span data-docs-delta=&quot;[[20,{&amp;quot;gallery&amp;quot;:&amp;quot;https://uploader.shimo.im/f/s3aWTKah9u80nENw.png!thumbnail&amp;quot;},&amp;quot;29:0|30:0|3:\&amp;quot;281px\&amp;quot;|4:\&amp;quot;281px\&amp;quot;|crop:\&amp;quot;\&amp;quot;|frame:\&amp;quot;none\&amp;quot;|ori-height:\&amp;quot;700\&amp;quot;|ori-width:\&amp;quot;700\&amp;quot;&amp;quot;]]&quot; data-copy-origin=&quot;https://shimo.im&quot;&gt;&lt;section&gt;&lt;strong&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.0027322&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Uecg6b8kbSYap6EMzpzneBwO7zZ5Ub2EX6IBBXldWaI0L3XmHO9kvcJwdWHJBI8LX7Ndr0OfOxMT61bjpVlD3Q/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;732&quot;/&gt;&lt;/strong&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;大家都在看&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;em&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt; &lt;strong&gt;&lt;sup&gt;&lt;span&gt;✦&lt;/span&gt;&lt;/sup&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/em&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;▶&lt;/span&gt;&lt;span&gt;   &lt;/span&gt;&lt;span&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=Mzg3Njc2NDAwOA==&amp;amp;mid=2247512119&amp;amp;idx=1&amp;amp;sn=289a2e465f9692e0fbe80055bba2dd14&amp;amp;chksm=cf2fbe30f8583726c879069cf2a0a9e544b5c539f9a2d7a5adaaaa9ada44b52d9035b900d5ab&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;全面进化！Apache Doris 1.2.0 Release 版本正式发布｜版本通告&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;全面进化！Apache Doris 1.2.0 Release 版本正式发布&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;▶&lt;/span&gt;&lt;span&gt;&lt;span&gt;  &lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=Mzg3Njc2NDAwOA==&amp;amp;mid=2247509133&amp;amp;idx=1&amp;amp;sn=a1c5a66404c0ceb0cd3015a4f2e13b9a&amp;amp;chksm=cf2faa8af858239c761a46e4f729191cce45cd8cd0e5e1dfd78e8a7263f32661814c590306af&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;DDL 毫秒级同步，Light Schema Change 的设计与实现｜新版本揭秘&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;DDL 毫秒级同步，Light Schema Change 的设计与实现&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;▶&lt;/span&gt;&lt;span&gt;  &lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=Mzg3Njc2NDAwOA==&amp;amp;mid=2247512201&amp;amp;idx=1&amp;amp;sn=13e743781165eb3b28cef0a98aa09902&amp;amp;chksm=cf2fbe8ef858379879dcb3769285759c74515b6a7d069cea8e445c5200e053e4da44e8ff4b17&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;10x 查询性能提升，全新 Unique Key 的设计与实现｜新特性解读&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;10x 查询性能提升，全新 Unique Key 的设计与实现&lt;/a&gt;&lt;/span&gt;&lt;/section&gt;&lt;/span&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.425&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Uecg6b8kbSalrjO7TiclL5OVBFxomNGLsiaZbfGlmh1zVQbNvzGHR2Bspb5rqZ52m9dhCVO3bY9p2dia1owD3595Q/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/section&gt;&lt;h4&gt;&lt;span&gt;▼   点击阅读原文，给 Doris 点个赞吧！&lt;/span&gt;&lt;/h4&gt;&lt;/section&gt;&lt;p&gt;&lt;mp-style-type data-value=&quot;3&quot;/&gt;&lt;/p&gt;&lt;/div&gt;

          
        &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>5d973719e0005ac1e3c6ca792f334f30</guid>
<title>有趣的 Go HttpClient 超时机制</title>
<link>https://toutiao.io/k/l30t274</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot; data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;我是既写 Java 又写 Go 的小楼，在写 Go 的过程中我经常对比这两种语言的特性，踩了不少坑，也发现了不少有意思的地方，今天就来聊聊 Go 自带的 HttpClient 的超时机制。&lt;/span&gt;&lt;/p&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;Java HttpClient 超时底层原理&lt;/span&gt;&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在介绍 Go 的 HttpClient 超时机制之前，我们先看看 Java 是如何实现超时的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;写一个 Java 原生的 HttpClient，设置连接超时、读取超时时间分别对应到底层的方法分别是：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.4959871589085072&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/xacdaKuBM0S4J5l00Jh0SzC1tk2AmuxTU3nYSO6mYGKgvR6iaUriaiblDicHrFt5iaiaKEzj5OwzlO7e4SiceiaZq83mVw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1246&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;再追溯到 JVM 源码，发现是对系统调用的封装，其实不光是 Java，大部分的编程语言都借助了操作系统提供的超时能力。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;然而 Go 的 HttpClient 却提供了另一种超时机制，挺有意思，我们来盘一盘。但在开始之前，我们先了解一下 Go 的 Context。&lt;/p&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;Go Context 简介&lt;/span&gt;&lt;/h1&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;Context 是什么？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;根据 Go 源码的注释：&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;// A Context carries a deadline, a cancellation signal, and other values across
// API boundaries.
// Context&#x27;s methods may be called by multiple goroutines simultaneously.&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Context 简单来说是一个可以携带超时时间、取消信号和其他数据的接口，Context 的方法会被多个协程同时调用。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Context 有点类似 Java 的ThreadLocal，可以在线程中传递数据，但又不完全相同，它是显示传递，ThreadLocal 是隐式传递，除了传递数据之外，Context 还能携带超时时间、取消信号。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Context 只是定义了接口，具体的实现在 Go 中提供了几个：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;Background ：空的实现，啥也没做&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;TODO：还不知道用什么 Context，先用 TODO 代替，也是啥也没做的空 Context&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;cancelCtx：可以取消的 Context&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;timerCtx：主动超时的 Context&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;针对 Context 的三个特性，可以通过 Go 提供的 Context 实现以及源码中的例子来进一步了解下。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;Context 三个特性例子&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这部分的例子来源于 Go 的源码，位于 &lt;code&gt;src/context/example_test.go&lt;/code&gt;&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;携带数据&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;使用 &lt;code&gt;context.WithValue&lt;/code&gt; 来携带，使用  &lt;code&gt;Value&lt;/code&gt; 来取值，源码中的例子如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;// 来自 src/context/example_test.go&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;ExampleWithValue&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; &lt;span&gt;type&lt;/span&gt; favContextKey &lt;span&gt;string&lt;/span&gt;&lt;br/&gt;&lt;br/&gt; f := &lt;span&gt;&lt;span&gt;func&lt;/span&gt;&lt;span&gt;(ctx context.Context, k favContextKey)&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;  &lt;span&gt;if&lt;/span&gt; v := ctx.Value(k); v != &lt;span&gt;nil&lt;/span&gt; {&lt;br/&gt;   fmt.Println(&lt;span&gt;&quot;found value:&quot;&lt;/span&gt;, v)&lt;br/&gt;   &lt;span&gt;return&lt;/span&gt;&lt;br/&gt;  }&lt;br/&gt;  fmt.Println(&lt;span&gt;&quot;key not found:&quot;&lt;/span&gt;, k)&lt;br/&gt; }&lt;br/&gt;&lt;br/&gt; k := favContextKey(&lt;span&gt;&quot;language&quot;&lt;/span&gt;)&lt;br/&gt; ctx := context.WithValue(context.Background(), k, &lt;span&gt;&quot;Go&quot;&lt;/span&gt;)&lt;br/&gt;&lt;br/&gt; f(ctx, k)&lt;br/&gt; f(ctx, favContextKey(&lt;span&gt;&quot;color&quot;&lt;/span&gt;))&lt;br/&gt;&lt;br/&gt; &lt;span&gt;// Output:&lt;/span&gt;&lt;br/&gt; &lt;span&gt;// found value: Go&lt;/span&gt;&lt;br/&gt; &lt;span&gt;// key not found: color&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;取消&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;先起一个协程执行一个死循环，不停地往 channel 中写数据，同时监听 &lt;code&gt;ctx.Done()&lt;/code&gt; 的事件&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;// 来自 src/context/example_test.go&lt;/span&gt;&lt;br/&gt;gen := &lt;span&gt;&lt;span&gt;func&lt;/span&gt;&lt;span&gt;(ctx context.Context)&lt;/span&gt; &amp;lt;-&lt;span&gt;chan&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;  dst := &lt;span&gt;make&lt;/span&gt;(&lt;span&gt;chan&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;)&lt;br/&gt;  n := &lt;span&gt;1&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;go&lt;/span&gt; &lt;span&gt;&lt;span&gt;func&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;   &lt;span&gt;for&lt;/span&gt; {&lt;br/&gt;    &lt;span&gt;select&lt;/span&gt; {&lt;br/&gt;    &lt;span&gt;case&lt;/span&gt; &amp;lt;-ctx.Done():&lt;br/&gt;     &lt;span&gt;return&lt;/span&gt; &lt;span&gt;// returning not to leak the goroutine&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;case&lt;/span&gt; dst &amp;lt;- n:&lt;br/&gt;     n++&lt;br/&gt;    }&lt;br/&gt;   }&lt;br/&gt;  }()&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; dst&lt;br/&gt; }&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;然后通过 &lt;code&gt;context.WithCancel&lt;/code&gt; 生成一个可取消的 Context，传入 &lt;code&gt;gen&lt;/code&gt; 方法，直到 &lt;code&gt;gen&lt;/code&gt; 返回 5 时，调用 &lt;code&gt;cancel&lt;/code&gt; 取消 &lt;code&gt;gen&lt;/code&gt; 方法的执行。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;// 来自 src/context/example_test.go&lt;/span&gt;&lt;br/&gt;ctx, cancel := context.WithCancel(context.Background())&lt;br/&gt;&lt;span&gt;defer&lt;/span&gt; cancel() &lt;span&gt;// cancel when we are finished consuming integers&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;for&lt;/span&gt; n := &lt;span&gt;range&lt;/span&gt; gen(ctx) {&lt;br/&gt; fmt.Println(n)&lt;br/&gt; &lt;span&gt;if&lt;/span&gt; n == &lt;span&gt;5&lt;/span&gt; {&lt;br/&gt;  &lt;span&gt;break&lt;/span&gt;&lt;br/&gt; }&lt;br/&gt;}&lt;br/&gt;&lt;span&gt;// Output:&lt;/span&gt;&lt;br/&gt;&lt;span&gt;// 1&lt;/span&gt;&lt;br/&gt;&lt;span&gt;// 2&lt;/span&gt;&lt;br/&gt;&lt;span&gt;// 3&lt;/span&gt;&lt;br/&gt;&lt;span&gt;// 4&lt;/span&gt;&lt;br/&gt;&lt;span&gt;// 5&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这么看起来，可以简单理解为在一个协程的循环中埋入结束标志，另一个协程去设置这个结束标志。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;超时&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;有了 cancel 的铺垫，超时就好理解了，cancel 是手动取消，超时是自动取消，只要起一个定时的协程，到时间后执行 cancel 即可。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;设置超时时间有2种方式：&lt;code&gt;context.WithTimeout&lt;/code&gt; 与 &lt;code&gt;context.WithDeadline&lt;/code&gt;，WithTimeout 是设置一段时间后，WithDeadline 是设置一个截止时间点，WithTimeout 最终也会转换为 WithDeadline。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;// 来自 src/context/example_test.go&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;ExampleWithTimeout&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; &lt;span&gt;// Pass a context with a timeout to tell a blocking function that it&lt;/span&gt;&lt;br/&gt; &lt;span&gt;// should abandon its work after the timeout elapses.&lt;/span&gt;&lt;br/&gt; ctx, cancel := context.WithTimeout(context.Background(), shortDuration)&lt;br/&gt; &lt;span&gt;defer&lt;/span&gt; cancel()&lt;br/&gt;&lt;br/&gt; &lt;span&gt;select&lt;/span&gt; {&lt;br/&gt; &lt;span&gt;case&lt;/span&gt; &amp;lt;-time.After(&lt;span&gt;1&lt;/span&gt; * time.Second):&lt;br/&gt;  fmt.Println(&lt;span&gt;&quot;overslept&quot;&lt;/span&gt;)&lt;br/&gt; &lt;span&gt;case&lt;/span&gt; &amp;lt;-ctx.Done():&lt;br/&gt;  fmt.Println(ctx.Err()) &lt;span&gt;// prints &quot;context deadline exceeded&quot;&lt;/span&gt;&lt;br/&gt; }&lt;br/&gt;&lt;br/&gt; &lt;span&gt;// Output:&lt;/span&gt;&lt;br/&gt; &lt;span&gt;// context deadline exceeded&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;Go HttpClient 的另一种超时机制&lt;/span&gt;&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;基于 Context 可以设置任意代码段执行的超时机制，就可以设计一种脱离操作系统能力的请求超时能力。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;超时机制简介&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;看一下 Go 的 HttpClient 超时配置说明：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt; client := http.Client{&lt;br/&gt;  Timeout: &lt;span&gt;10&lt;/span&gt; * time.Second,&lt;br/&gt; }&lt;br/&gt; &lt;br/&gt; &lt;span&gt;// 来自 src/net/http/client.go&lt;/span&gt;&lt;br/&gt; &lt;span&gt;type&lt;/span&gt; Client &lt;span&gt;struct&lt;/span&gt; {&lt;br/&gt; &lt;span&gt;// ... 省略其他字段&lt;/span&gt;&lt;br/&gt; &lt;span&gt;// Timeout specifies a time limit for requests made by this&lt;/span&gt;&lt;br/&gt; &lt;span&gt;// Client. The timeout includes connection time, any&lt;/span&gt;&lt;br/&gt; &lt;span&gt;// redirects, and reading the response body. The timer remains&lt;/span&gt;&lt;br/&gt; &lt;span&gt;// running after Get, Head, Post, or Do return and will&lt;/span&gt;&lt;br/&gt; &lt;span&gt;// interrupt reading of the Response.Body.&lt;/span&gt;&lt;br/&gt; &lt;span&gt;//&lt;/span&gt;&lt;br/&gt; &lt;span&gt;// A Timeout of zero means no timeout.&lt;/span&gt;&lt;br/&gt; &lt;span&gt;//&lt;/span&gt;&lt;br/&gt; &lt;span&gt;// The Client cancels requests to the underlying Transport&lt;/span&gt;&lt;br/&gt; &lt;span&gt;// as if the Request&#x27;s Context ended.&lt;/span&gt;&lt;br/&gt; &lt;span&gt;//&lt;/span&gt;&lt;br/&gt; &lt;span&gt;// For compatibility, the Client will also use the deprecated&lt;/span&gt;&lt;br/&gt; &lt;span&gt;// CancelRequest method on Transport if found. New&lt;/span&gt;&lt;br/&gt; &lt;span&gt;// RoundTripper implementations should use the Request&#x27;s Context&lt;/span&gt;&lt;br/&gt; &lt;span&gt;// for cancellation instead of implementing CancelRequest.&lt;/span&gt;&lt;br/&gt; Timeout time.Duration&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;翻译一下注释：&lt;code&gt;Timeout&lt;/code&gt; 包括了连接、redirect、读取数据的时间，定时器会在 Timeout 时间后打断数据的读取，设为0则没有超时限制。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;也就是说这个超时是一个请求的&lt;strong&gt;总体超时时间&lt;/strong&gt;，而不必再分别去设置连接超时、读取超时等等。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这对于使用者来说可能是一个更好的选择，大部分场景，使用者不必关心到底是哪部分导致的超时，而只是想这个 HTTP 请求整体什么时候能返回。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;超时机制底层原理&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;以一个最简单的例子来阐述超时机制的底层原理。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里我起了一个本地服务，用 Go HttpClient 去请求，超时时间设置为 10 分钟，建议使 Debug 时设置长一点，否则可能超时导致无法走完全流程。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt; client := http.Client{&lt;br/&gt;  Timeout: &lt;span&gt;10&lt;/span&gt; * time.Minute,&lt;br/&gt; }&lt;br/&gt; resp, err := client.Get(&lt;span&gt;&quot;http://127.0.0.1:81/hello&quot;&lt;/span&gt;)&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;1. 根据 timeout 计算出超时的时间点&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;// 来自 src/net/http/client.go&lt;/span&gt;&lt;br/&gt;deadline = c.deadline()&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;2. 设置请求的 cancel&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;// 来自 src/net/http/client.go&lt;/span&gt;&lt;br/&gt;stopTimer, didTimeout := setRequestCancel(req, rt, deadline)&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里返回的 stopTimer 就是可以手动 cancel 的方法，didTimeout 是判断是否超时的方法。这两个可以理解为回调方法，调用 stopTimer() 可以手动 cancel，调用 didTimeout() 可以返回是否超时。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;设置的主要代码其实就是将请求的 Context 替换为 cancelCtx，后续所有的操作都将携带这个 cancelCtx：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;// 来自 src/net/http/client.go&lt;/span&gt;&lt;br/&gt;&lt;span&gt;var&lt;/span&gt; cancelCtx &lt;span&gt;&lt;span&gt;func&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;if&lt;/span&gt; oldCtx := req.Context(); timeBeforeContextDeadline(deadline, oldCtx) {&lt;br/&gt; req.ctx, cancelCtx = context.WithDeadline(oldCtx, deadline)&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;同时，再起一个定时器，当超时时间到了之后，将 timedOut 设置为 true，再调用 doCancel()，doCancel() 是调用真正 RoundTripper （代表一个 HTTP 请求事务）的 CancelRequest，也就是取消请求，这个跟实现有关。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;// 来自 src/net/http/client.go&lt;/span&gt;&lt;br/&gt;timer := time.NewTimer(time.Until(deadline))&lt;br/&gt;&lt;span&gt;var&lt;/span&gt; timedOut atomicBool&lt;br/&gt;&lt;br/&gt;&lt;span&gt;go&lt;/span&gt; &lt;span&gt;&lt;span&gt;func&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; &lt;span&gt;select&lt;/span&gt; {&lt;br/&gt; &lt;span&gt;case&lt;/span&gt; &amp;lt;-initialReqCancel:&lt;br/&gt;  doCancel()&lt;br/&gt;  timer.Stop()&lt;br/&gt; &lt;span&gt;case&lt;/span&gt; &amp;lt;-timer.C:&lt;br/&gt;  timedOut.setTrue()&lt;br/&gt;  doCancel()&lt;br/&gt; &lt;span&gt;case&lt;/span&gt; &amp;lt;-stopTimerCh:&lt;br/&gt;  timer.Stop()&lt;br/&gt; }&lt;br/&gt;}()&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Go 默认 RoundTripper CancelRequest 实现是关闭这个连接&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;// 位于 src/net/http/transport.go&lt;/span&gt;&lt;br/&gt;&lt;span&gt;// CancelRequest cancels an in-flight request by closing its connection.&lt;/span&gt;&lt;br/&gt;&lt;span&gt;// CancelRequest should only be called after RoundTrip has returned.&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;(t *Transport)&lt;/span&gt; &lt;span&gt;CancelRequest&lt;/span&gt;&lt;span&gt;(req *Request)&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; t.cancelRequest(cancelKey{req}, errRequestCanceled)&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;3. 获取连接&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;// 位于 src/net/http/transport.go&lt;/span&gt;&lt;br/&gt;&lt;span&gt;for&lt;/span&gt; {&lt;br/&gt; &lt;span&gt;select&lt;/span&gt; {&lt;br/&gt; &lt;span&gt;case&lt;/span&gt; &amp;lt;-ctx.Done():&lt;br/&gt;  req.closeBody()&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; &lt;span&gt;nil&lt;/span&gt;, ctx.Err()&lt;br/&gt; &lt;span&gt;default&lt;/span&gt;:&lt;br/&gt; }&lt;br/&gt;&lt;br/&gt; &lt;span&gt;// ...&lt;/span&gt;&lt;br/&gt; pconn, err := t.getConn(treq, cm)&lt;br/&gt; &lt;span&gt;// ...&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;代码的开头监听 ctx.Done，如果超时则直接返回，使用 for 循环主要是为了请求的重试。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;后续的 getConn 是阻塞的，代码比较长，挑重点说，先看看有没有空闲连接，如果有则直接返回&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;// 位于 src/net/http/transport.go&lt;/span&gt;&lt;br/&gt;&lt;span&gt;// Queue for idle connection.&lt;/span&gt;&lt;br/&gt;&lt;span&gt;if&lt;/span&gt; delivered := t.queueForIdleConn(w); delivered {&lt;br/&gt; &lt;span&gt;// ...&lt;/span&gt;&lt;br/&gt; &lt;span&gt;return&lt;/span&gt; pc, &lt;span&gt;nil&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果没有空闲连接，起个协程去异步建立，建立成功再通知主协程&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;// 位于 src/net/http/transport.go&lt;/span&gt;&lt;br/&gt;&lt;span&gt;// Queue for permission to dial.&lt;/span&gt;&lt;br/&gt;t.queueForDial(w)&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;再接着是一个 select 等待连接建立成功、超时或者主动取消，这就实现了在连接过程中的超时&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;// 位于 src/net/http/transport.go&lt;/span&gt;&lt;br/&gt;&lt;span&gt;// Wait for completion or cancellation.&lt;/span&gt;&lt;br/&gt;&lt;span&gt;select&lt;/span&gt; {&lt;br/&gt;&lt;span&gt;case&lt;/span&gt; &amp;lt;-w.ready:&lt;br/&gt; &lt;span&gt;// ...&lt;/span&gt;&lt;br/&gt; &lt;span&gt;return&lt;/span&gt; w.pc, w.err&lt;br/&gt;&lt;span&gt;case&lt;/span&gt; &amp;lt;-req.Cancel:&lt;br/&gt; &lt;span&gt;return&lt;/span&gt; &lt;span&gt;nil&lt;/span&gt;, errRequestCanceledConn&lt;br/&gt;&lt;span&gt;case&lt;/span&gt; &amp;lt;-req.Context().Done():&lt;br/&gt; &lt;span&gt;return&lt;/span&gt; &lt;span&gt;nil&lt;/span&gt;, req.Context().Err()&lt;br/&gt;&lt;span&gt;case&lt;/span&gt; err := &amp;lt;-cancelc:&lt;br/&gt; &lt;span&gt;if&lt;/span&gt; err == errRequestCanceled {&lt;br/&gt;  err = errRequestCanceledConn&lt;br/&gt; }&lt;br/&gt; &lt;span&gt;return&lt;/span&gt; &lt;span&gt;nil&lt;/span&gt;, err&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;4. 读写数据&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在上一条连接建立的时候，每个链接还偷偷起了两个协程，一个负责往连接中写入数据，另一个负责读数据，他们都监听了相应的 channel。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;// 位于 src/net/http/transport.go&lt;/span&gt;&lt;br/&gt;&lt;span&gt;go&lt;/span&gt; pconn.readLoop()&lt;br/&gt;&lt;span&gt;go&lt;/span&gt; pconn.writeLoop()&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其中 wirteLoop 监听来自主协程的数据，并往连接中写入&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;// 位于 src/net/http/transport.go&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;(pc *persistConn)&lt;/span&gt; &lt;span&gt;writeLoop&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; &lt;span&gt;defer&lt;/span&gt; &lt;span&gt;close&lt;/span&gt;(pc.writeLoopDone)&lt;br/&gt; &lt;span&gt;for&lt;/span&gt; {&lt;br/&gt;  &lt;span&gt;select&lt;/span&gt; {&lt;br/&gt;  &lt;span&gt;case&lt;/span&gt; wr := &amp;lt;-pc.writech:&lt;br/&gt;   startBytesWritten := pc.nwrite&lt;br/&gt;   err := wr.req.Request.write(pc.bw, pc.isProxy, wr.req.extra, pc.waitForContinue(wr.continueCh))&lt;br/&gt;   &lt;span&gt;// ... &lt;/span&gt;&lt;br/&gt;   &lt;span&gt;if&lt;/span&gt; err != &lt;span&gt;nil&lt;/span&gt; {&lt;br/&gt;    pc.&lt;span&gt;close&lt;/span&gt;(err)&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt;&lt;br/&gt;   }&lt;br/&gt;  &lt;span&gt;case&lt;/span&gt; &amp;lt;-pc.closech:&lt;br/&gt;   &lt;span&gt;return&lt;/span&gt;&lt;br/&gt;  }&lt;br/&gt; }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;同理，readLoop 读取响应数据，并写回主协程。读与写的过程中如果超时了，连接将被关闭，报错退出。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;超时机制小结&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Go 的这种请求超时机制，可随时终止请求，可设置整个请求的超时时间。其实现主要依赖协程、channel、select 机制的配合。总结出套路是：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;主协程生成 cancelCtx，传递给子协程，主协程与子协程之间用 channel 通信&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;主协程 select channel 和 cancelCtx.Done，子协程完成或取消则 return&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;循环任务：子协程起一个循环处理，每次循环开始都 select cancelCtx.Done，如果完成或取消则退出&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;阻塞任务：子协程 select 阻塞任务与 cancelCtx.Done，阻塞任务处理完或取消则退出&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;以循环任务为例&lt;/p&gt;&lt;/blockquote&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1.1331747919143875&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/xacdaKuBM0S4J5l00Jh0SzC1tk2AmuxTzoeScE46RINHUASNk1EKNfbucMYT7752Ogyk26kHicEXLuKtVkHibgbA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;841&quot;/&gt;&lt;/figure&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;Java 能实现这种超时机制吗&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;直接说结论：暂时不行。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;首先 Java 的线程太重，像 Go 这样一次请求开了这么多协程，换成线程性能会大打折扣。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其次 Go 的 channel 虽然和 Java 的阻塞队列类似，但 Go 的 select 是多路复用机制，Java 暂时无法实现，即无法监听多个队列是否有数据到达。所以综合来看 Java 暂时无法实现类似机制。&lt;/p&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;总结&lt;/span&gt;&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;本文介绍了 Go 另类且有趣的 HTTP 超时机制，并且分析了底层实现原理，归纳出了这种机制的套路，如果我们写 Go 代码，也可以如此模仿，让代码更 Go。&lt;/p&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;hr/&gt;&lt;p&gt;&lt;strong&gt;推荐阅读&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-darkmode-bgcolor-15906318746582=&quot;rgb(36, 36, 36)&quot; data-darkmode-original-bgcolor-15906318746582=&quot;rgb(255, 255, 255)&quot; data-style=&quot;width: 30px; height: 30px; background-color: rgb(255, 255, 255); box-shadow: rgb(87, 187, 255) -7px -7px 0px; margin-left: 7px;&quot;&gt;&lt;span&gt;&lt;strong&gt;福利&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section data-darkmode-bgcolor-15906318746582=&quot;rgb(36, 36, 36)&quot; data-darkmode-original-bgcolor-15906318746582=&quot;rgb(255, 255, 255)&quot; data-style=&quot;width: 30px; height: 30px; background-color: rgb(255, 255, 255); box-shadow: rgb(87, 187, 255) -7px -7px 0px; margin-left: 7px;&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;section data-darkmode-bgcolor-15906318746582=&quot;rgb(36, 36, 36)&quot; data-darkmode-original-bgcolor-15906318746582=&quot;rgb(255, 255, 255)&quot; data-style=&quot;width: 30px; height: 30px; background-color: rgb(255, 255, 255); box-shadow: rgb(87, 187, 255) -7px -7px 0px; margin-left: 7px;&quot;&gt;&lt;span/&gt;&lt;span&gt;我为大家整理了一份&lt;/span&gt;&lt;span&gt;从入门到进阶的Go学习资料礼包&lt;/span&gt;&lt;span&gt;，包含学习建议：入门看什么，进阶看什么。&lt;/span&gt;&lt;span&gt;关注公众号 「polarisxu」，回复 &lt;/span&gt;&lt;strong&gt;&lt;span&gt;ebook&lt;/span&gt;&lt;/strong&gt;&lt;span&gt; 获取；还可以回复「&lt;strong&gt;进群&lt;/strong&gt;」，和数万 Gopher 交流学习。&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;1&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/UWba2ryLMqm8cgtrMXjG1BLGg46vQNmUompBL02uYYwic9RicPbCnlKdZiacBF5Wv6RLgmGIqnBnwuWyP82ibYusiag/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;258&quot;/&gt;&lt;/p&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>4de814265e5f6501881f3661f5293ef3</guid>
<title>分支路径图调度框架在 vivo 效果广告业务的落地实践</title>
<link>https://toutiao.io/k/iw73z1g</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content js_underline_content             autoTypeSetting24psection&amp;#10;            &quot; id=&quot;js_content&quot;&gt;&lt;section&gt;&lt;mp-common-profile class=&quot;custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mpprofile&quot; data-weuitheme=&quot;light&quot; data-id=&quot;MzI4NjY4MTU5Nw==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/4g5IMGibSxt45QXJZicZ9gaNU2mRSlvqhQd94MJ7oQh4QFj1ibPV66xnUiaKoicSatwaGXepL5sBDSDLEckicX1ttibHg/0?wx_fmt=png&quot; data-nickname=&quot;vivo互联网技术&quot; data-alias=&quot;vivoVMIC&quot; data-signature=&quot;分享 vivo 互联网技术干货与沙龙活动，推荐最新行业动态与热门会议。&quot; data-from=&quot;0&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;作者：&lt;/p&gt;&lt;p&gt;vivo 互联网AI团队- Liu Zuocheng、Zhou Baojian&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;&lt;span&gt;本文根据周保建老师在“2022 vivo开发者大会&quot;现场演讲内容整理而成。公众号回复【2022 VDC】获取互联网技术分会场议题相关资料。&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;使用基于有限有向图的调度框架，可以控制在线服务中异步调度的流程，但这对分支路径的管理不够友好，随着节点增多，调度流程会越来越复杂而难以控制。因此我们实现了支持分支路径的图调度框架，解决普通图调度框架可扩展性差的问题。&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;一、图调度框架简介&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;span&gt;1.1 vivo效果广告预估服务&lt;/span&gt;&lt;/p&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-croporisrc=&quot;https://mmbiz.qpic.cn/mmbiz_png/4g5IMGibSxt7wRzzngARjKz3H7Z0LnTkicCCm6SbEhBriau9IiaYrxuiaVUMUSoERqN0yFxjlqIvV7ULSD294Eibvf5A/0?wx_fmt=png&quot; data-cropx1=&quot;0&quot; data-cropx2=&quot;1280&quot; data-cropy1=&quot;95.2249134948097&quot; data-cropy2=&quot;719.7231833910035&quot; data-ratio=&quot;0.48828125&quot; data-s=&quot;300,640&quot; data-type=&quot;jpeg&quot; data-w=&quot;1280&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/4g5IMGibSxt7wRzzngARjKz3H7Z0LnTkic2XkWcn1EcAmEibBO3iaicia41uPcJxKAXafe5yQ88bwp5DsyCUt9dPw6Zg/640?wx_fmt=jpeg&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;vivo效果广告实时在线服务是提供实时AI算法推荐的服务。在广告投放场景，承载了一天百亿级别数量的请求，支持vivo广告收入。在可用性、可扩展性等方面具有非常高的要求。服务中起到调度作用的模块，上下游依赖特别多，比如特征服务、ABT实验平台、实时数据流、模型计算模块等等。调度模块在请求下游服务的方式都是采用异步的方式。那么我们是怎么管理这么多异步请求的呢？&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;异步调用已成为系统设计中的主流方法。虽然异步调度提升了系统性能，提升了资源的利用率，但却对系统的可扩展性和可维护性提出了挑战。回忆历史中用过的异步管理方法有以下三种。&lt;/p&gt;&lt;/section&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-croporisrc=&quot;https://mmbiz.qpic.cn/mmbiz_png/4g5IMGibSxt7wRzzngARjKz3H7Z0LnTkicicDVxBuPygiawZXibicVs5VN8w56DnpsqVqhZ5VZHhibfBHb6KPxJBpHyLw/0?wx_fmt=png&quot; data-cropx1=&quot;0&quot; data-cropx2=&quot;1280&quot; data-cropy1=&quot;97.43944636678202&quot; data-cropy2=&quot;719.7231833910035&quot; data-ratio=&quot;0.48671875&quot; data-s=&quot;300,640&quot; data-type=&quot;jpeg&quot; data-w=&quot;1280&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/4g5IMGibSxt7wRzzngARjKz3H7Z0LnTkicnHTBU9Pve9XjAQzKp606ltt0CCx7jSf3ib1QqBSXNVo0y1CRsBfD3icw/640?wx_fmt=jpeg&quot;/&gt;&lt;/p&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;单纯使用&lt;strong&gt;面向过程的方法&lt;/strong&gt;，简单却粗放，随着下游服务增多，代码逻辑中产生大量的callback函数和类使，得系统调度过程繁杂无序，可扩展性和可维护性变差。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;树调度方法&lt;/strong&gt;，使得异步调度进入框架调控的新阶段。可扩展性方面较面向过程的方法要好很多。但树结构不能准确描述复杂服务的调用流程。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;有限有向图&lt;/strong&gt;，是目前使用最为广泛的方法。扩展性较好，能管理复杂的调用流程。但这是否是一种完美的方法呢？不是的。有限有向图，对图中节点是全路径访问，对分支路径的管理不够友好。因此我们依然要探索新的方法。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;为了解释有限有向图在实时在线服务中的局限性，我们以vivo效果广告预估服务的调度流程为例，进行说明。把调度流程经过抽象后，调度流程如左图一样简洁明了，但这只是理想状态。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.5625&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/4g5IMGibSxt7wRzzngARjKz3H7Z0LnTkic1eSnH8JiciciaVUy7ibgZvzV333pNlm0nfnuaWwPLfFnADjRvia8JDpdx7w/640?wx_fmt=png&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.5625&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/4g5IMGibSxt7wRzzngARjKz3H7Z0LnTkic9iaNopmBPBjgtKXKEt6t60sicgoQsfaCo94ayCECicjIZCPK9JuHbfnmQ/640?wx_fmt=png&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;那么现实状况又是什么样子的呢？大家来看，和所有的实时在线服务一样，我们在系统设计时，为了系统健壮，总要和大量的异常和超时做斗争。并且除了异常和超时，系统还需要有兜底逻辑。上一个简洁明了的有限有向图已经不复存在。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;为了进一步说明，有限有向图不能完全把控在线服务中异步调度的流程。我们依据刚才展示的流程调度图，做了一个状态转换图。在这个图中，展示了系统中各个状态的流转路径，总数达到了7条之多。有限有向图是一种全路径图调度框架，已经难以适用复杂度不断增长的系统。&lt;/p&gt;&lt;/section&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;二、分支路径图调度框架的实现&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.5625&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/4g5IMGibSxt7wRzzngARjKz3H7Z0LnTkicF5oNbfjIDbRAw98QnzDhXeZAIWHyvL9Og4ouoPWMHpj309tnMmyOfA/640?wx_fmt=png&quot;/&gt;&lt;/p&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;全路径图调度框架具体有什么痛点，逼迫让我们去寻找新的方法。具体原因就在这里，有限有向图在落地实践中，使用skip状态变量约束路径。系统在处理一次任务的过程中，不经过的路径上的所有节点状态都会被设置为skip。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;全路径的图调度框架中，每增添一个节点，会导致：控制变量数量 +1，状态全集 x2， 复杂度成指数增长。在如此状态下，对复杂系统添加流程或调整流程，就会变成工程师的噩梦。设计开发时必须小心甚微，上线时则如履薄冰。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.5625&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/4g5IMGibSxt7wRzzngARjKz3H7Z0LnTkicFicvZ2wHI0nbAbG0AwYNgCCMbBxXC75VjDrMe9tjjW0TVKHGtAicEF1w/640?wx_fmt=png&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;为了安全开发和提升迭代效率，新的调度方法被迫切地创建出来，那就支持分支路径的图调度框架。它的原理，则是在原有的图调度框架中，添加两处功能，一是加入了分支节点，二是对于图中节点的触发和激活支持“与”激活和“或”激活。是不是像极了逻辑电路呢？&lt;/p&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.5625&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/4g5IMGibSxt7wRzzngARjKz3H7Z0LnTkic7xuwDM46jSV979k5mIQk4mCIviaJnv7c9NP8k2nkCkib4ib1BKKWy4MGQ/640?wx_fmt=png&quot;/&gt;&lt;/p&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;大家是否有疑问，添加两处修改就可以了吗？这样做真的有效吗？其实依据，就来自于我们的《编译原理》里的常见概念和常见规律。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;有限有向图，是一种NFA，即不确定的有限自动机。我们都知道，在实践中NFA实现难度很大，它不如DFA简洁和简单。所以结论呼之欲出，支持分支路径的图调度框架，则是把图变成DFA。我们还给它起了新名字，DDAG。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.5625&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/4g5IMGibSxt7wRzzngARjKz3H7Z0LnTkicqdhdz2ibMBONDQ5xqNE2lDcibqWKrIRgf7uPUOlx44UTjc5yEBtGd8QQ/640?wx_fmt=png&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;三、在vivo 效果广告推荐系统中的落地过程&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;实践是检验真理的唯一标准，我们再通过实际的落地过程看，分支路径调度框架是否满足我们的预期。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;我们回忆一下vivo效果广告预估服务的调度流程，那一个充满着异常、超时、兜底逻辑的调用图。为了便于说明，我们把它化简了一下，变成一个流程图，如左图，目前它还是一个全路径的调度图。使用分支路径调度框架改造后，变成右图，图中添加了判断节点，具体路径的走向则由判断逻辑来控制。大量Skip的状态控制变量依然不复存在。图中蓝、青、红分别代表了3条路径，让路径和流程一目了然。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.5625&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/4g5IMGibSxt7wRzzngARjKz3H7Z0LnTkicqEPE2T95JJJy5y2vJ8kkNibENlD2H9KdiaFK7taQ5LXEUCrficqQjFRMA/640?wx_fmt=png&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;当图与实时在线系统融合在一起的时候，我们发现了分支路径图调度框架更多的提升空间。比如，图的整体的超时、异常管理，图中节点的超时、异常管理，以及复杂图结构的自动化简，会成为我们以后进一步升级的空间。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;分支路径图调度框架在vivo效果广告预估服务中做了一次成功的实践。它帮助工程师降低在开发过程中的风险，提速在项目中的迭代效率。让算法预估服务的飞轮越转越快！&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.5625&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/4g5IMGibSxt7wRzzngARjKz3H7Z0LnTkic0YwccibE90FtrfOgjicLQWXQdfe2INFeRCHHIQaahZCBn97hKJxPnPAA/640?wx_fmt=png&quot;/&gt;&lt;/p&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;END&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;span title=&quot;&quot; opera-tn-ra-cell=&quot;_$.pages:0.layers:0.comps:38.title1&quot;&gt;&lt;p&gt;猜你喜欢&lt;/p&gt;&lt;/span&gt; &lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;mp-common-profile class=&quot;custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mpprofile&quot; data-weuitheme=&quot;light&quot; data-id=&quot;MzI4NjY4MTU5Nw==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/4g5IMGibSxt45QXJZicZ9gaNU2mRSlvqhQd94MJ7oQh4QFj1ibPV66xnUiaKoicSatwaGXepL5sBDSDLEckicX1ttibHg/0?wx_fmt=png&quot; data-nickname=&quot;vivo互联网技术&quot; data-alias=&quot;vivoVMIC&quot; data-signature=&quot;分享 vivo 互联网技术干货与沙龙活动，推荐最新行业动态与热门会议。&quot; data-from=&quot;0&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;mp-style-type data-value=&quot;3&quot;/&gt;&lt;/p&gt;&lt;/div&gt;

          
        &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>