<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>50af2cca8b140c815139b8d2b8bfb94e</guid>
<title>如何用 Vue + 免费的 WebDB 实现一个世界杯足球竞猜系统</title>
<link>https://toutiao.io/k/uvrxuq9</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;preview&quot;&gt;&lt;h1&gt;前言&lt;/h1&gt;

&lt;p&gt;最近世界杯在如火如荼的进行。我们都知道，中国也派出了我们的一支强大的队伍：中国建筑队，全程参与了世界杯的所有比赛。&lt;/p&gt;

&lt;p&gt;哈哈开个玩笑，不过说到世界杯，还真有不少朋友，不仅仅是看球，还切身参与了。比如足彩，世界杯竞猜等等活动。&lt;/p&gt;

&lt;p&gt;那么今天我们就通过kintone来自己实现一个世界杯竞猜系统吧！&lt;/p&gt;

&lt;h1&gt;视频学习&lt;/h1&gt;

&lt;p&gt;开始学习前，可以先来看看本文的视频“如何用vue+免费的web db，来实现一个世界杯足球竞猜系统”，可以帮助你更好的理解本文的思路，更能提高学习的效率。配合着视频我们快来学习吧！&lt;/p&gt;

&lt;h1&gt;功能梳理&lt;/h1&gt;

&lt;h2&gt;想要实现的功能如下：&lt;/h2&gt;

&lt;p&gt;用户竞猜前台：
1 每个人拥有自己独立的积分&lt;/p&gt;

&lt;p&gt;2 有比赛列表，赔付率信息。能实现各自投票。&lt;/p&gt;

&lt;p&gt;3 有个人信息界面，列出我的积分，往期竞猜信息及结果。&lt;/p&gt;

&lt;p&gt;竞猜系统后台：
1 可以录入比赛信息，赔付率信息。可以到期进行开奖。&lt;/p&gt;

&lt;p&gt;2 可以查询用户的竞猜信息。&lt;/p&gt;

&lt;p&gt;3 用户的积分变化有迹可查。&lt;/p&gt;

&lt;h1&gt;如何实现？&lt;/h1&gt;

&lt;p&gt;效果看完了，那这个世界杯竞猜系统是如何通过kintone实现的呢？&lt;/p&gt;

&lt;h2&gt;应用准备&lt;/h2&gt;

&lt;p&gt;这个世界杯竞猜系统可以简单通过以下应用进行搭建 &lt;/p&gt;

&lt;p&gt;1 球队信息应用：&lt;/p&gt;

&lt;p&gt;记录球队名，球队国旗等。&lt;/p&gt;

&lt;p&gt;2 比赛信息应用：&lt;/p&gt;

&lt;p&gt;记录比赛的两支球队，场次，该场比分，赔付率等。&lt;/p&gt;

&lt;p&gt;3 用户竞猜信息应用：&lt;/p&gt;

&lt;p&gt;记录用户id，他的竞猜的比赛场次，胜负，竞猜使用的积分等。&lt;/p&gt;

&lt;p&gt;4 积分变更履历应用：&lt;/p&gt;

&lt;p&gt;记录用户积分变化的履历，每个场次押注所获得或者付出的积分。&lt;/p&gt;

&lt;p&gt;5 轮播图应用&lt;/p&gt;

&lt;p&gt;记录一些比赛精彩图片，美化页面。&lt;/p&gt;

&lt;h2&gt;系统开发&lt;/h2&gt;

&lt;p&gt;接下来分享下这个系统是如何开发的。&lt;/p&gt;

&lt;p&gt;整个投注系统使用Vue3框架来实现。&lt;/p&gt;

&lt;p&gt;引入根节点
首先通过kintone的 JS API来获取门户上方的空白部分的元素 kintone.portal.getContentSpaceElement()，将其作为根节点。这样就能把Vue产生的页面挂载到这个根结点上。同时可以引入Pinia作为集中式状态管理，Element UI 作为我们的UI框架。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;import { createApp } from &quot;vue&quot;;
import App from &quot;./App.vue&quot;;
import installElementPlus from &quot;@/libs/element&quot;;
import { createPinia } from &quot;pinia&quot;;
/* eslint-disable */
kintone.events.on(&quot;portal.show&quot;, (event) =&amp;gt; {
    const myContainer = kintone.portal.getContentSpaceElement();
    const app = createApp(App);
    installElementPlus(app);
    app.use(createPinia());
    app.mount(myContainer);
    return event;
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;准备数据源，获取数据
然后通过kintone的REST API就能将kintone各个应用中的数据取出来，并在页面上进行展示。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;import { KintoneRestAPIClient } from &quot;@kintone/rest-api-client&quot;;
const client = new KintoneRestAPIClient();

//获取比赛列表
export const GetMatchList = async () =&amp;gt; {
    const app = appList.matchInfo;
    import {appList,matchInfoField,usersField,userChipInField,picField} from &quot;@/config&quot;;
    try {
        const params = {
            app,
        };
        const resp = await client.record.getRecords(params);
        if (resp.records.length &amp;gt; 0) {
        return resp.records.map((record) =&amp;gt; {
            return dataConvert(record);
        });
        } else {
            return null;
        }
    } catch (err) {
        console.log(err);
    }
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;多语言开发
同时通过kintone.getLoginUser()我们可以获取到当前登陆用户的信息。其中包含了他的语言信息。根据语言信息，我们可以配置I18N做多语言的开发。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;const { language } = kintone.getLoginUser();
//   &#x27;language&#x27;: &#x27;zh&#x27;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;集中式状态管理
可以将用户的剩余积分，比赛下注信息等写入集中式状态管理，因为他可能会在多页面进行响应式变化。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;import {
  GetLeftScore,
  GetChipInList,
  GetMatchList,
} from &quot;@/services/kintoneApi&quot;;
import { defineStore } from &quot;pinia&quot;;

export const useStore = defineStore(&quot;store&quot;, {
  state: () =&amp;gt; {
    return {
      myScore: 0,
      chipInList: [],
    };
  },

  getters: {
    chipListShow(state) {
      return state.chipInList.map((record) =&amp;gt; {
        if (record.Score_result == 0) {
          record.scoreWin = &quot;--&quot;;
          record.teamInfo.Score = &quot;--&quot;;
          record.type = &quot;chip in&quot;;
        } else if (record.Score_result &amp;lt; 0) {
          record.scoreWin = `--`;
          record.type = &quot;loss&quot;;
        } else {
          record.scoreWin = `+ ${record.Score_result}`;
          record.type = &quot;win&quot;;
        }
        return record;
      });
    },
  },

  actions: {
    async init() {
      const initLeftScorePromise = this.getLeftScore();
      const initChipInListPromise = this.getChipInList();
      return Promise.all([initLeftScorePromise, initChipInListPromise]);
    },

    async getLeftScore() {
      this.myScore = await GetLeftScore();
    },

    async getChipInList() {
      const chipInList = await GetChipInList();
      const matches = await GetMatchList();
      const matchMapping = {};
      for (const item of matches) {
        matchMapping[item.Match_id] = {
          FlagA: item.FlagA,
          FlagB: item.FlagB,
          TeamA_name: item.TeamA_name,
          TeamB_name: item.TeamB_name,
          Score: `${item.ScoreA}:${item.ScoreB}`,
        };
      }
      chipInList.map((chip) =&amp;gt; {
        chip.teamInfo = matchMapping[chip.Match_id];
        return chip;
      });
      this.chipInList = chipInList;
    },
  },
});
&lt;/code&gt;&lt;/pre&gt;

&lt;h1&gt;竞猜系统整体说明&lt;/h1&gt;

&lt;p&gt;首先是可以通过管理员给每个用户录入一些初始积分，用户有了积分可以进行比赛的胜负平的竞猜。比赛场次，胜负平赔付率可以通过取出后台数据后进行展示。&lt;/p&gt;

&lt;p&gt;当用户进行竞猜后，会将记录写入用户竞猜信息应用。同时还可以计算出用户的剩余积分，用户的竞猜列表等。&lt;/p&gt;

&lt;h1&gt;开奖系统整体说明&lt;/h1&gt;

&lt;p&gt;开奖系统可以直接对比赛信息应用进行自定义开发。&lt;/p&gt;

&lt;p&gt;当比赛结束出来结果后，管理员可以录入比分，自动计算出比赛结果。然后可以一键开奖，系统自动计算出哪些用户猜对了比赛，并且通过赔付率计算出他所获得的积分。并且写入到用户的积分履历中去。&lt;/p&gt;

&lt;h1&gt;开发上的注意点&lt;/h1&gt;

&lt;p&gt;因为这里没有后端系统，所以可能存在用户自行通过伪造请求等方式生成投票数据。这样就有可能出现：&lt;/p&gt;

&lt;p&gt;1 帮别人投票，让别人无分可投&lt;/p&gt;

&lt;p&gt;2 让自己的投票超出自己的积分&lt;/p&gt;

&lt;p&gt;3 比赛结束后进行投票&lt;/p&gt;

&lt;p&gt;等等一系列的问题。那这边如何一一化解呢？&lt;/p&gt;

&lt;p&gt;1 伪造别人投票：可以通过应用的创建者字段来实现。因为这个字段是系统后端自动生成，所以不再有这个困扰。&lt;/p&gt;

&lt;p&gt;2 让自己的投票超出自己的积分：为防止这种篡改积分的情况，这里将用户的竞猜列表和积分列表分开。竞猜列表用户有读写权限，但是积分列表用户只有读取权限。&lt;/p&gt;

&lt;p&gt;通过kintone的权限设置，普通登录用户都是只读权限，没有修改权限。然后通过管理员用户的开奖系统对用户的竞猜进行审核。过滤后，由管理员进行修改（当然这些都是代码自动实现的。）&lt;/p&gt;

&lt;p&gt;比如判断用户的投票时，会先计算出他当前没有开奖的投票总数是否大于他剩余的积分。这样就能防止他是否会进行伪造投票。&lt;/p&gt;

&lt;p&gt;3 超过时间的投票：通过kintone自带的更新时间字段（这是用户无法自行修改的特点），判断用户该条投票记录的更新时间是否超过该场比赛的投票截止时间，就能过滤掉用户的超时伪造投票。&lt;/p&gt;

&lt;p&gt;经过以上种种的判断，就能很好的避免了用户伪造的数据，让这次投票无需服务器，也能变得安全可靠了。&lt;/p&gt;

&lt;h1&gt;代码分享&lt;/h1&gt;

&lt;p&gt;参考：&lt;a href=&quot;https://cybozudev.kf5.com/hc/kb/article/1588162/&quot;&gt;https://cybozudev.kf5.com/hc/kb/article/1588162/&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;视频参考：&lt;a href=&quot;https://www.bilibili.com/video/BV1Q841157A3/&quot;&gt;https://www.bilibili.com/video/BV1Q841157A3/&lt;/a&gt;&lt;/p&gt;
&lt;/div&gt;
  &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>6496cf9d81da5a915808970c8fd205fe</guid>
<title>文盘 Rust：r2d2 实现 Redis 连接池</title>
<link>https://toutiao.io/k/ypaaai1</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;preview&quot;&gt;&lt;p&gt;&lt;strong&gt;作者：贾世闻&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;我们在开发应用后端系统的时候经常要和各种数据库、缓存等资源打交道。这一期，我们聊聊如何访问redis 并将资源池化。&lt;/p&gt;

&lt;p&gt;在一个应用后端程序访问redis主要要做的工作有两个，单例和池化。&lt;/p&gt;

&lt;p&gt;在后端应用集成redis，我们主要用到以下几个crate:​ ​once_cell​​​、​ ​redis-rs​​​、​ ​r2d2​​​.once_cell 实现单例；redis-rs 是 redis的 rust 驱动；r2d2 是一个池化连接的工具包。本期代码均出现在​ ​fullstack-rs​​​项目中。​ ​fullstack-rs​​​是我新开的一个实验性项目，目标是做一个类似​ ​gin-vue-admin​​的集成开发框架。&lt;/p&gt;

&lt;p&gt;redis资源的定义主要是在​ ​&lt;a href=&quot;https://github.com/jiashiwen/fullstack-rs/blob/main/backend/src/resources/redis_resource.rs%E2%80%8B%E2%80%8B%C2%A0%E4%B8%AD%E5%AE%9E%E7%8E%B0%E7%9A%84%E3%80%82&quot;&gt;https://github.com/jiashiwen/fullstack-rs/blob/main/backend/src/resources/redis_resource.rs​​ 中实现的。&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;一、redis-rs 封装&lt;/p&gt;

&lt;p&gt;在实际开发中，我们面对的redis资源可能是单实例也有可能是集群，在这里我们对redis-rs进行了简单封装，便于适应这两种情况。&lt;/p&gt;

&lt;pre lang=&quot;rust&quot;&gt;&lt;code&gt;#[derive(Debug, PartialEq, Eq, PartialOrd, Ord, Hash, Serialize, Deserialize, Clone)]
#[serde(rename_all = &quot;lowercase&quot;)]
pub struct RedisInstance {
    #[serde(default = &quot;RedisInstance::urls_default&quot;)]
    pub urls: Vec&amp;lt;String&amp;gt;,
    #[serde(default = &quot;RedisInstance::password_default&quot;)]
    pub password: String,
    #[serde(default = &quot;RedisInstance::instance_type_default&quot;)]
    pub instance_type: InstanceType,
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;RedisInstance,定义redis资源的描述，与配置文件相对应。详细的配置描述可以参考 ​ ​&lt;a href=&quot;https://github.com/jiashiwen/fullstack-rs/blob/main/backend/src/configure/config_global.rs%E2%80%8B%E2%80%8B%C2%A0%E6%96%87%E4%BB%B6%E4%B8%AD&quot;&gt;https://github.com/jiashiwen/fullstack-rs/blob/main/backend/src/configure/config_global.rs​​ 文件中&lt;/a&gt; RedisConfig 和 RedisPool 两个 struct 描述。&lt;/p&gt;

&lt;pre lang=&quot;rust&quot;&gt;&lt;code&gt;#[derive(Clone)]
pub enum RedisClient {
    Single(redis::Client),
    Cluster(redis::cluster::ClusterClient),
}


impl RedisClient {
    pub fn get_redis_connection(&amp;amp;self) -&amp;gt; RedisResult&amp;lt;RedisConnection&amp;gt; {
        return match self {
            RedisClient::Single(s) =&amp;gt; {
                let conn = s.get_connection()?;
                Ok(RedisConnection::Single(Box::new(conn)))
            }
            RedisClient::Cluster(c) =&amp;gt; {
                let conn = c.get_connection()?;
                Ok(RedisConnection::Cluster(Box::new(conn)))
            }
        };
    }
}


pub enum RedisConnection {
    Single(Box&amp;lt;redis::Connection&amp;gt;),
    Cluster(Box&amp;lt;redis::cluster::ClusterConnection&amp;gt;),
}


impl RedisConnection {
    pub fn is_open(&amp;amp;self) -&amp;gt; bool {
        return match self {
            RedisConnection::Single(sc) =&amp;gt; sc.is_open(),
            RedisConnection::Cluster(cc) =&amp;gt; cc.is_open(),
        };
    }


    pub fn query&amp;lt;T: FromRedisValue&amp;gt;(&amp;amp;mut self, cmd: &amp;amp;redis::Cmd) -&amp;gt; RedisResult&amp;lt;T&amp;gt; {
        return match self {
            RedisConnection::Single(sc) =&amp;gt; match sc.as_mut().req_command(cmd) {
                Ok(val) =&amp;gt; from_redis_value(&amp;amp;val),
                Err(e) =&amp;gt; Err(e),
            },
            RedisConnection::Cluster(cc) =&amp;gt; match cc.req_command(cmd) {
                Ok(val) =&amp;gt; from_redis_value(&amp;amp;val),
                Err(e) =&amp;gt; Err(e),
            },
        };
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;RedisClient 和 RedisConnection 对redis 的链接进行了封装，用来实现统一的调用接口。&lt;/p&gt;

&lt;p&gt;二、基于 r2d2 实现 redis 连接池&lt;/p&gt;

&lt;p&gt;以上，基本完成的reids资源的准备工作，下面来实现一个redis链接池。&lt;/p&gt;

&lt;pre lang=&quot;rust&quot;&gt;&lt;code&gt;#[derive(Clone)]
pub struct RedisConnectionManager {
    pub redis_client: RedisClient,
}


impl r2d2::ManageConnection for RedisConnectionManager {
    type Connection = RedisConnection;
    type Error = RedisError;


    fn connect(&amp;amp;self) -&amp;gt; Result&amp;lt;RedisConnection, Self::Error&amp;gt; {
        let conn = self.redis_client.get_redis_connection()?;
        Ok(conn)
    }


    fn is_valid(&amp;amp;self, conn: &amp;amp;mut RedisConnection) -&amp;gt; Result&amp;lt;(), Self::Error&amp;gt; {
        match conn {
            RedisConnection::Single(sc) =&amp;gt; {
                redis::cmd(&quot;PING&quot;).query(sc)?;
            }
            RedisConnection::Cluster(cc) =&amp;gt; {
                redis::cmd(&quot;PING&quot;).query(cc)?;
            }
        }
        Ok(())
    }


    fn has_broken(&amp;amp;self, conn: &amp;amp;mut RedisConnection) -&amp;gt; bool {
        !conn.is_open()
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;利用 r2d2 来实现连接池需要实现 r2d2::ManageConnection trait。connect 函数获取连接；is_valid 函数校验连通性；has_broken 判断连接是否崩溃不可用。&lt;/p&gt;

&lt;pre lang=&quot;Rust&quot;&gt;&lt;code&gt;pub fn gen_redis_conn_pool() -&amp;gt; Result&amp;lt;Pool&amp;lt;RedisConnectionManager&amp;gt;&amp;gt; {
    let config = get_config()?;
    let redis_client = config.redis.instance.to_redis_client()?;
    let manager = RedisConnectionManager { redis_client };
    let pool = r2d2::Pool::builder()
        .max_size(config.redis.pool.max_size as u32)
        .min_idle(Some(config.redis.pool.mini_idle as u32))
        .connection_timeout(Duration::from_secs(
            config.redis.pool.connection_timeout as u64,
        ))
        .build(manager)?;
    Ok(pool)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;gen_redis_conn_pool 函数用来生成一个 redis 的连接池，根据配置文件来指定连接池的最大连接数，最小闲置连接以及连接超时时长。&lt;/p&gt;

&lt;p&gt;三、连接池单例实现****&lt;/p&gt;

&lt;p&gt;在后端开发中，对于单一资源一般采取单例模式避免重复产生实例的开销。下面来聊一聊如果构建一个全局的 redis 资源。&lt;/p&gt;

&lt;p&gt;这一部分代码在​ ​&lt;a href=&quot;https://github.com/jiashiwen/fullstack-rs/blob/main/backend/src/resources/init_resources.rs%E2%80%8B%E2%80%8B%C2%A0%E6%96%87%E4%BB%B6%E4%B8%AD%E3%80%82&quot;&gt;https://github.com/jiashiwen/fullstack-rs/blob/main/backend/src/resources/init_resources.rs​​ 文件中。&lt;/a&gt;&lt;/p&gt;

&lt;pre lang=&quot;rust&quot;&gt;&lt;code&gt;pub static GLOBAL_REDIS_POOL: OnceCell&amp;lt;r2d2::Pool&amp;lt;RedisConnectionManager&amp;gt;&amp;gt; = OnceCell::new();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;利用 OnceCell 构建全局静态变量。&lt;/p&gt;

&lt;pre lang=&quot;rust&quot;&gt;&lt;code&gt;fn init_global_redis() {
    GLOBAL_REDIS_POOL.get_or_init(|| {
        let pool = match gen_redis_conn_pool() {
            Ok(it) =&amp;gt; it,
            Err(err) =&amp;gt; panic!(&quot;{}&quot;, err.to_string()),
        };
        pool
    });
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;init_global_redis 函数，用来初始化 GLOBAL_REDIS_POOL 全局静态变量。在一般的后端程序中，资源是强依赖，所以，初始化简单粗暴，要么成功要么 panic。&lt;/p&gt;

&lt;p&gt;四、资源调用&lt;/p&gt;

&lt;p&gt;准备好 redis 资源后，我们聊聊如何调用。&lt;/p&gt;

&lt;p&gt;调用例子在这里​ ​&lt;a href=&quot;https://github.com/jiashiwen/fullstack-rs/blob/main/backend/src/httpserver/service/service_redis.rs%E2%80%8B%E2%80%8B&quot;&gt;https://github.com/jiashiwen/fullstack-rs/blob/main/backend/src/httpserver/service/service_redis.rs​​&lt;/a&gt;&lt;/p&gt;

&lt;pre lang=&quot;rust&quot;&gt;&lt;code&gt;pub fn put(kv: KV) -&amp;gt; Result&amp;lt;()&amp;gt; {
    let conn = GLOBAL_REDIS_POOL.get();
    return match conn {
        Some(c) =&amp;gt; {
            c.get()?
                .query(redis::cmd(&quot;set&quot;).arg(kv.Key).arg(kv.Value))?;
            Ok(())
        }
        None =&amp;gt; Err(anyhow!(&quot;redis pool not init&quot;)),
    };
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;​ ​&lt;a href=&quot;https://github.com/jiashiwen/fullstack-rs/tree/main/backend%E2%80%8B%E2%80%8B%C2%A0%E8%BF%99%E4%B8%AA%E5%B7%A5%E7%A8%8B%E9%87%8C%E6%9C%89%E4%BB%8Ehttp%E5%85%A5%E5%8F%A3%E5%BC%80%E5%A7%8B%E5%88%B0%E5%86%99%E5%85%A5redis%E7%9A%84%E5%AE%8C%E6%95%B4%E6%B5%81%E7%A8%8B%EF%BC%8Chttp&quot;&gt;https://github.com/jiashiwen/fullstack-rs/tree/main/backend​​ 这个工程里有从http入口开始到写入redis的完整流程，http&lt;/a&gt; server 不在本文讨论之列，就不赘述了，有兴趣的同学可以去github看看。&lt;/p&gt;

&lt;p&gt;咱们下期见。&lt;/p&gt;
&lt;/div&gt;
  &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>191439000e7cbe4fe472ff6b3309ea68</guid>
<title>玩转 Go 链路追踪</title>
<link>https://toutiao.io/k/jdq1xz6</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;前言&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;链路追踪是每个微服务架构下必备的利器，go-zero 当然早已经为我们考虑好了，只需要在配置中添加配置即可使用。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;关于 go-zero 如何追踪的原理追溯，之前已经有同学分享，这里我就不再多说，如果有想了解的同学去 &lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=Mzg2ODU1MTI0OA==&amp;amp;mid=2247483946&amp;amp;idx=1&amp;amp;sn=ca51f2917c28b0c1f5454f49867d38fc&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;https://mp.weixin.qq.com/s/hJEWcWc3PnGfWfbPCHfM9g&lt;/a&gt; 这个链接看就好了。默认会在 api 的中间件与 rpc 的 interceptor 添加追踪，如果有不了解 go-zero 默认如何使用默认的链路追踪的，请移步我的开源项目 go-zero-looklook 文档 https://github.com/Mikaelemmmm/go-zero-looklook/blob/main/doc/chinese/12-%E9%93%BE%E8%B7%AF%E8%BF%BD%E8%B8%AA.md。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;今天我想讲的是，除了 go-zero 默认在 api 的 middleware 与 rpc 的 interceptor 中帮我们集成好的链路追踪，我们想自己在某些本地方法添加链路追踪代码或者我们想在 api 发送一个消息给 mq 服务时候想把整个链路包含 mq 的 producer、consumer 穿起来，在 go-zero 中该如何做。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;场景&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们先简单讲一下我们的小 demo 的场景，一个请求进来调用 api 的 &lt;code&gt;Login&lt;/code&gt; 方法，在 Login 方法中先调用 rpc 的 &lt;code&gt;GetUserByMobile&lt;/code&gt; 方法，之后在调用 api 本地的 &lt;code&gt;local&lt;/code&gt; 方法，紧接着调用 &lt;code&gt;rabbitmq&lt;/code&gt; 传递消息到 mq 服务。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;go-zero 默认集成了 jaeger、zinpink，这里我们就以 jaeger 为例&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们希望看到的链路是&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.4945717732207479&quot; data-type=&quot;png&quot; data-w=&quot;829&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/UyIojWicPOg3I9ajxZkfty80df7saufvGWvicXyiazH3awibnOpT2vOuLQ27UBVs25VebZDhK7A8pvc8qIuxBMsgDw/640?wx_fmt=png&quot;/&gt;&lt;figcaption&gt;api.Login -&amp;gt; rpc.GetUserByMobile&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;也就是 api 衍生出来三条子链路，&lt;code&gt;api.producerMq&lt;/code&gt; 有一条调用 &lt;code&gt;mq.Consumer&lt;/code&gt; 的子链路。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们想要将一个方法添加到链路中需要两个因素，一个 traceId，一个span，当我们在同一个 traceId 下开启 span 把相关的 span 都串联起来，如果想形成父子关系，就要把 span 之间相互串联起来，因为「&lt;strong&gt;微服务实践&lt;/strong&gt;」公众号中讲解原理太多，我这里就简单提一下不涉及过多，如果不是特别熟悉原理可以看文章开头推荐的文章，这里我们只需要知道 &lt;code&gt;traceId&lt;/code&gt; 与 &lt;code&gt;spanId&lt;/code&gt; 关系就好。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;核心业务代码&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;1、首先 API 中 &lt;code&gt;LoginLogic&lt;/code&gt; 代码&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;type&lt;/span&gt; LoginLogic &lt;span&gt;struct&lt;/span&gt; {&lt;br/&gt;  logx.Logger&lt;br/&gt;  ctx    context.Context&lt;br/&gt;  svcCtx *svc.ServiceContext&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;NewLoginLogic&lt;/span&gt;&lt;span&gt;(ctx context.Context, svcCtx *svc.ServiceContext)&lt;/span&gt; *&lt;span&gt;LoginLogic&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; &amp;amp;LoginLogic{&lt;br/&gt;    Logger: logx.WithContext(ctx),&lt;br/&gt;    ctx:    ctx,&lt;br/&gt;    svcCtx: svcCtx,&lt;br/&gt;  }&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;type&lt;/span&gt; MsgBody &lt;span&gt;struct&lt;/span&gt; {&lt;br/&gt;  Carrier *propagation.HeaderCarrier&lt;br/&gt;  Msg     &lt;span&gt;string&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;(l *LoginLogic)&lt;/span&gt; &lt;span&gt;Login&lt;/span&gt;&lt;span&gt;(req *types.RegisterReq)&lt;/span&gt; &lt;span&gt;(*types.AccessTokenResp, error)&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;  resp, err := l.svcCtx.UserRpc.GetUserByMobile(l.ctx, &amp;amp;usercenter.GetUserByMobileReq{&lt;br/&gt;    Mobile: req.Mobile,&lt;br/&gt;  })&lt;br/&gt;  &lt;span&gt;if&lt;/span&gt; err != &lt;span&gt;nil&lt;/span&gt; {&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; &amp;amp;types.AccessTokenResp{}, &lt;span&gt;nil&lt;/span&gt;&lt;br/&gt;  }&lt;br/&gt;&lt;br/&gt;  l.local()&lt;br/&gt;&lt;br/&gt;  tracer := otel.GetTracerProvider().Tracer(trace.TraceName)&lt;br/&gt;  spanCtx, span := tracer.Start(l.ctx, &lt;span&gt;&quot;send_msg_mq&quot;&lt;/span&gt;,  oteltrace.WithSpanKind(oteltrace.SpanKindProducer))&lt;br/&gt;  carrier := &amp;amp;propagation.HeaderCarrier{}&lt;br/&gt;  otel.GetTextMapPropagator().Inject(spanCtx, carrier)&lt;br/&gt;&lt;br/&gt;  producer := rabbit.NewRabbitmqPublisher(RabbitmqDNS)&lt;br/&gt;  msg :=  &amp;amp;MsgBody{&lt;br/&gt;    Carrier: carrier,&lt;br/&gt;    Msg:     req.Mobile,&lt;br/&gt;  }&lt;br/&gt;  b, err := json.Marshal(msg)&lt;br/&gt;  &lt;span&gt;if&lt;/span&gt; err != &lt;span&gt;nil&lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;panic&lt;/span&gt;(err)&lt;br/&gt;  }&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;if&lt;/span&gt; err := producer.Publish(spanCtx, ExchangeName, RoutineKeys, b); err != &lt;span&gt;nil&lt;/span&gt; {&lt;br/&gt;    logx.Errorf(&lt;span&gt;&quot;Publish Fail , msg :%s , err:%v&quot;&lt;/span&gt;, msg, err)&lt;br/&gt;  }&lt;br/&gt;  span.End()&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; &amp;amp;types.AccessTokenResp{&lt;br/&gt;    AccessExpire: resp.User.Id,&lt;br/&gt;  }, err&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;(l *LoginLogic)&lt;/span&gt; &lt;span&gt;local&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;  tracer := otel.GetTracerProvider().Tracer(trace.TraceName)&lt;br/&gt;  _ , span := tracer.Start(l.ctx, &lt;span&gt;&quot;local&quot;&lt;/span&gt;, oteltrace.WithSpanKind(oteltrace.SpanKindInternal))&lt;br/&gt;  &lt;span&gt;defer&lt;/span&gt; span.End()&lt;br/&gt;  &lt;br/&gt;  &lt;span&gt;// 执行你的代码 .....&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;2、rpc 中 &lt;code&gt;GetUserByMobile&lt;/code&gt; 的代码&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;(s *Logic)&lt;/span&gt; &lt;span&gt;GetUserByMobile&lt;/span&gt;&lt;span&gt;(context.Context, *usercenterPb.GetUserByMobileReq)&lt;/span&gt; &lt;span&gt;(*usercenterPb.GetUserByMobileResp, error)&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;  vo := &amp;amp;usercenterPb.UserVo{&lt;br/&gt;    Id: &lt;span&gt;1&lt;/span&gt;,&lt;br/&gt;  }&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; &amp;amp;usercenterPb.GetUserByMobileResp{&lt;br/&gt;    User: vo,&lt;br/&gt;  }, &lt;span&gt;nil&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;3、mq 中 &lt;code&gt;Consumer&lt;/code&gt; 的代码&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;type&lt;/span&gt; MsgBody &lt;span&gt;struct&lt;/span&gt; {&lt;br/&gt;  Carrier *propagation.HeaderCarrier&lt;br/&gt;  Msg     &lt;span&gt;string&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;(c *consumer)&lt;/span&gt; &lt;span&gt;Consumer&lt;/span&gt;&lt;span&gt;(ctx context.Context, data []&lt;span&gt;byte&lt;/span&gt;)&lt;/span&gt; &lt;span&gt;error&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;  &lt;span&gt;var&lt;/span&gt; msg MsgBody&lt;br/&gt;  &lt;span&gt;if&lt;/span&gt; err := json.Unmarshal(data, &amp;amp;msg); err != &lt;span&gt;nil&lt;/span&gt; {&lt;br/&gt;    logx.Errorf(&lt;span&gt;&quot; consumer err : %v&quot;&lt;/span&gt;, err)&lt;br/&gt;  } &lt;span&gt;else&lt;/span&gt; {&lt;br/&gt;    logx.Infof(&lt;span&gt;&quot;consumerOne Consumer  , msg:%+v&quot;&lt;/span&gt;, msg)&lt;br/&gt;&lt;br/&gt;    wireContext := otel.GetTextMapPropagator().Extract(ctx, msg.Carrier)&lt;br/&gt;    tracer := otel.GetTracerProvider().Tracer(trace.TraceName)&lt;br/&gt;    _, span := tracer.Start(wireContext, &lt;span&gt;&quot;mq_consumer_msg&quot;&lt;/span&gt;, oteltrace.WithSpanKind(oteltrace.SpanKindConsumer))&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;defer&lt;/span&gt; span.End()&lt;br/&gt;  }&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; &lt;span&gt;nil&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;代码详解&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;1、go-zero 默认集成&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当一个请求进入 api 后，我们可以在 go-zero 源码中查看到 https://github.com/zeromicro/go-zero/blob/master/rest/engine.go#L92。go-zero 已经在 api 的 middleware 中帮我们添加了第一层 trace，当进入 Login 方法内，我们调用了 rpc 的 &lt;code&gt;GetUserByMobile&lt;/code&gt; 方法，通过 go-zero 的源码 https://github.com/zeromicro/go-zero/blob/master/zrpc/internal/rpcserver.go#L55 可以看到在 rpc 的 interceptor 也默认帮我们添加好了，这两层都是 go-zero 默认帮我们做好的。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;2、本地方法&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当调用完 rpc 的 &lt;code&gt;GetUserByMobile&lt;/code&gt; 之后，api 调用了本地的 &lt;code&gt;local&lt;/code&gt;，如果我们想在整个链路上体现出来调用了本地 &lt;code&gt;local&lt;/code&gt; 方法，那默认的 go-zero 是没有帮我们做的，需要我们手动来添加。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;  tracer := otel.GetTracerProvider().Tracer(trace.TraceName)&lt;br/&gt;  _ , span := tracer.Start(l.ctx, &lt;span&gt;&quot;local&quot;&lt;/span&gt;,  oteltrace.WithSpanKind(oteltrace.SpanKindInternal))&lt;br/&gt;  &lt;span&gt;defer&lt;/span&gt; span.End()&lt;br/&gt; &lt;br/&gt;&lt;span&gt;// 执行你的代码 .....&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们通过上面代码拿到 tracer，ctx 之后开启一个 local 的 span，因为 start 时候会从 ctx 获取父 span 所以会将 local 方法与 Login 串联起父子调用关系，这样就将本次操作加入了这个链路&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;3、mq 的 producer 到 mq 的 consumer&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们在mq传递中如何串联起来这个链路呢？也就是形成 &lt;code&gt;api.Login-&amp;gt;api.producer-&amp;gt;mq.Consumer&lt;/code&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;想一下原理，虽然跨越了网络，api 可以通过 &lt;code&gt;header&lt;/code&gt; 传递，rpc 可以通过 &lt;code&gt;metadata&lt;/code&gt; 传递，那么 mq 是不是也可以通过 &lt;code&gt;header&lt;/code&gt;、&lt;code&gt;body&lt;/code&gt; 传递就可以了，按照这个想法来看下我门的代码。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;  tracer := otel.GetTracerProvider().Tracer(trace.TraceName)&lt;br/&gt;  spanCtx , span := tracer.Start(l.ctx, &lt;span&gt;&quot;send_msg_mq&quot;&lt;/span&gt;, oteltrace.WithSpanKind(oteltrace.SpanKindProducer))&lt;br/&gt;  carrier := &amp;amp;propagation.HeaderCarrier{}&lt;br/&gt;  otel.GetTextMapPropagator().Inject(spanCtx,carrier)&lt;br/&gt;&lt;br/&gt;  producer := rabbit.NewRabbitmqPublisher(RabbitmqDNS)&lt;br/&gt;  msg := &amp;amp;MsgBody{&lt;br/&gt;    Carrier: carrier,&lt;br/&gt;    Msg:     req.Mobile,&lt;br/&gt;  }&lt;br/&gt;  b , err := json.Marshal(msg)&lt;br/&gt;  &lt;span&gt;if&lt;/span&gt; err != &lt;span&gt;nil&lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;panic&lt;/span&gt;(err)&lt;br/&gt;  }&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;if&lt;/span&gt; err := producer.Publish(spanCtx, ExchangeName, RoutineKeys, b); err != &lt;span&gt;nil&lt;/span&gt; {&lt;br/&gt;    logx.Errorf(&lt;span&gt;&quot;Publish Fail, msg :%s, err:%v&quot;&lt;/span&gt;, msg, err)&lt;br/&gt;  }&lt;br/&gt;  span.End()&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;首先获取到了这个全局的 &lt;code&gt;tracer&lt;/code&gt;，然后开启一个 &lt;code&gt;producer&lt;/code&gt; 的 &lt;code&gt;span&lt;/code&gt;，跟 &lt;code&gt;local&lt;/code&gt; 方法一样，我们开启 &lt;code&gt;producer&lt;/code&gt; 的 &lt;code&gt;span&lt;/code&gt; 时候也是通过 &lt;code&gt;ctx&lt;/code&gt; 获取到上一级父级 &lt;code&gt;span&lt;/code&gt;，这样就可以将 &lt;code&gt;producer&lt;/code&gt; 的 &lt;code&gt;span&lt;/code&gt; 与 &lt;code&gt;Login&lt;/code&gt; 形成父子 &lt;code&gt;span&lt;/code&gt; 调用关系，那我们想将 &lt;code&gt;producer&lt;/code&gt; 的 &lt;code&gt;span&lt;/code&gt; 与 mq 的 &lt;code&gt;consumer&lt;/code&gt; 中的 &lt;code&gt;span&lt;/code&gt; 形成调用父子关系怎么做？我们将 &lt;code&gt;api.producer&lt;/code&gt; 的 &lt;code&gt;spanCtx&lt;/code&gt; 注入到 &lt;code&gt;carrier&lt;/code&gt; 中，这里我们通过 mq 的 &lt;code&gt;body&lt;/code&gt; 将 &lt;code&gt;carrier&lt;/code&gt; 发送给 &lt;code&gt;consumer&lt;/code&gt;，发送完成我们 &lt;code&gt;stop&lt;/code&gt; 我们的 &lt;code&gt;producer&lt;/code&gt;，那么 &lt;code&gt;producer&lt;/code&gt; 的这层链路完成了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;随后我们来看 &lt;code&gt;mq-consumer&lt;/code&gt; 在接收到 &lt;code&gt;body&lt;/code&gt; 消息之后怎么做的。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;type&lt;/span&gt; MsgBody &lt;span&gt;struct&lt;/span&gt; {&lt;br/&gt;  Carrier *propagation.HeaderCarrier&lt;br/&gt;  Msg     &lt;span&gt;string&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;(c *consumer)&lt;/span&gt; &lt;span&gt;Consumer&lt;/span&gt;&lt;span&gt;(ctx context.Context, data []&lt;span&gt;byte&lt;/span&gt;)&lt;/span&gt; &lt;span&gt;error&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;  &lt;span&gt;var&lt;/span&gt; msg MsgBody&lt;br/&gt;  &lt;span&gt;if&lt;/span&gt; err := json.Unmarshal(data, &amp;amp;msg); err != &lt;span&gt;nil&lt;/span&gt; {&lt;br/&gt;    logx.Errorf(&lt;span&gt;&quot; consumer err : %v&quot;&lt;/span&gt;, err)&lt;br/&gt;  } &lt;span&gt;else&lt;/span&gt; {&lt;br/&gt;    logx.Infof(&lt;span&gt;&quot;consumerOne Consumer  , msg:%+v&quot;&lt;/span&gt;, msg)&lt;br/&gt;&lt;br/&gt;    wireContext := otel.GetTextMapPropagator().Extract(ctx, msg.Carrier)&lt;br/&gt;    tracer := otel.GetTracerProvider().Tracer(trace.TraceName)&lt;br/&gt;    _, span := tracer.Start(wireContext, &lt;span&gt;&quot;mq_consumer_msg&quot;&lt;/span&gt;, oteltrace.WithSpanKind(oteltrace.SpanKindConsumer))&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;defer&lt;/span&gt; span.End()&lt;br/&gt;  }&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; &lt;span&gt;nil&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;consumer&lt;/code&gt; 接收到消息后反序列化出来 &lt;code&gt;Carrier *propagation.HeaderCarrier&lt;/code&gt;，然后通过 &lt;code&gt;otel.GetTextMapPropagator().Extract&lt;/code&gt; 取出来 &lt;code&gt;api.producer&lt;/code&gt; 注入的 &lt;code&gt;wireContext&lt;/code&gt;，在通过 &lt;code&gt;tracer.Start&lt;/code&gt;、&lt;code&gt;wireContext&lt;/code&gt; 创建 &lt;code&gt;consumer&lt;/code&gt; 的 &lt;code&gt;span&lt;/code&gt;，这样 &lt;code&gt;consumer&lt;/code&gt; 就是 &lt;code&gt;api.producer&lt;/code&gt; 的子 &lt;code&gt;span&lt;/code&gt;，就形成了调用链路关系，最终我们得到的关系就是&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.4945717732207479&quot; data-type=&quot;png&quot; data-w=&quot;829&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/UyIojWicPOg3I9ajxZkfty80df7saufvGWvicXyiazH3awibnOpT2vOuLQ27UBVs25VebZDhK7A8pvc8qIuxBMsgDw/640?wx_fmt=png&quot;/&gt;&lt;figcaption&gt;api.Login -&amp;gt; rpc.GetUserByMobile&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;让我们来调用一下 &lt;code&gt;Logic&lt;/code&gt; 方法，看下 jaeger 中的链路如果与我们预想的链路一致，so happy～&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.37383966244725736&quot; data-type=&quot;jpeg&quot; data-w=&quot;1185&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/UyIojWicPOg3I9ajxZkfty80df7saufvGicaNxwCvUythsS0gicjkUBHeWiaeCPHfI8QO4Sm6JzYuXVTMXdiciciaGQdA/640?wx_fmt=jpeg&quot;/&gt;&lt;/figure&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;项目地址&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;go-zero 微服务框架：https://github.com/zeromicro/go-zero&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;go-zero 微服务最佳实践项目：https://github.com/Mikaelemmmm/go-zero-looklook&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;欢迎使用 &lt;code&gt;go-zero&lt;/code&gt; 并 &lt;strong&gt;star&lt;/strong&gt; 支持我们！&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;微信交流群&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;关注『&lt;strong&gt;微服务实践&lt;/strong&gt;』公众号并点击 &lt;strong&gt;交流群&lt;/strong&gt; 获取社区群二维码。&lt;/p&gt;&lt;section&gt;&lt;mp-common-profile class=&quot;custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mpprofile&quot; data-weuitheme=&quot;light&quot; data-id=&quot;Mzg2ODU1MTI0OA==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/UyIojWicPOg0AVP4WUKYKGFYXampCduKtGgGQgTibaEGvORjtq7icd3EOiaSMb6LeZY2k77dJFOibf914CUs3JTwMLA/0?wx_fmt=png&quot; data-nickname=&quot;微服务实践&quot; data-alias=&quot;zeromicro&quot; data-signature=&quot;分享微服务的原理和最佳实践，讲透服务治理的底层原理，带你细读 go-zero 源码。go-zero 是一个集成了各种工程实践的 web 和 rpc 框架，旨在缩短从需求到上线的距离。公众号文章勘误在知乎号：万俊峰Kevin&quot; data-from=&quot;0&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>5a1887ab8ce13d3dc55a89fdc3d7193f</guid>
<title>得物云原生全链路追踪Trace2.0-采集篇</title>
<link>https://toutiao.io/k/42uyrlw</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content js_underline_content             autoTypeSetting24psection&amp;#10;            &quot; id=&quot;js_content&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;0&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;h1&gt;&lt;strong&gt;&lt;span&gt;0xcc 开篇&lt;/span&gt;&lt;/strong&gt;&lt;/h1&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;2020 年 3月，得物技术团队在三个月的时间内完成了整个交易体系的重构，交付了五彩石项目，业务系统也进入了微服务时代。系统服务拆分之后，虽然每个服务都会有不同的团队各司其职，但服务之间的依赖也变得复杂，对服务治理等相关的基础建设要求也更高。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;对服务进行监控是服务治理、稳定性建设中的一个重要的环节，它能帮助提早发现问题，预估系统水位，以及对故障进行分析等等。从 2019 年末到现在，得物的应用服务监控系统经历了三大演进阶段，如今，整个得物的应用微服务监控体系已经全面融入云原生可观测性技术 OpenTelemetry。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-height=&quot;416&quot; data-ratio=&quot;0.2803234501347709&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/AAQtmjCc74C7cwr1iam7XNocN4qr3TgVaibhleuxpZmic1ibwge8eaAreBRMxd5EotHmPZVftrqROrqlz843Wm0NJA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1484&quot; data-width=&quot;1484&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;回顾过去十年间，应用服务监控行业的竞争也很激烈，相关产品如雨后春笋般涌现，如推特在 2012 年开源的 Zipkin，韩国最大的搜索引擎和门户网站 Naver 开源的 Pinpoint，近几年 Uber 公司开源的 Jaeger，以及我们国内吴晟开源的 SkyWalking。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;有人说，这些其实都归功于 Google 在 2010 年基于其内部大规模分布式链路追踪系统 Dapper 实践而发表的论文，它的设计理念是一切分布式调用链追踪系统的始祖，但其实早在二十年前（2002年），当年世界上最大的电商平台 eBay 就已拥有了调用链追踪系统 CAL(Centralized Application Logging)。2011 年，原eBay的中国研发中心的资深架构师吴其敏跳槽至大众点评，并且深入吸收消化了 CAL 的设计思想，主导研发并开源了CAT(Centralized Application Tracking）。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-height=&quot;462&quot; data-ratio=&quot;0.2876712328767123&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/AAQtmjCc74C7cwr1iam7XNocN4qr3TgVawbOjOicfqpxomSzQA9BHSBj7D0jDLtic4HgYBoj5Fiboic6ticGJoaRgReQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1606&quot; data-width=&quot;1606&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;CAT 作为国人主导的开源系统，其本地化工作也是做得非常到位，而凭借着架构简单，开箱即用的特点，CAT 也是我们得物使用的第一个应用监控系统。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;1&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;h1&gt;&lt;strong&gt;&lt;span&gt; 0x01 第一阶段&lt;/span&gt;&lt;/strong&gt;&lt;/h1&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;h1&gt;&lt;strong&gt;&lt;span&gt;从0～1基于CAT的实时应用监控&lt;/span&gt;&lt;/strong&gt;&lt;/h1&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;在得物五彩石项目交付之前，系统仅有基础设施层面的监控，CAT 的引入，很好地弥补了应用监控盲区。它支持提供各个维度的性能监控报表，健康状况检测，异常统计，对故障问题排查起到了积极推动的作用，同时也提供简单的实时告警的能力。&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-height=&quot;1712&quot; data-ratio=&quot;0.5336658354114713&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/AAQtmjCc74C7cwr1iam7XNocN4qr3TgVa1mhCBQ1OHhvFqteBpfoUPgA6QsCZRVAkbia2NHaLkMnGnicg8abtWxibA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;3208&quot; data-width=&quot;3208&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;CAT 拥有指标分钟级别的聚合统计的能力，从 UI 上不难看出，它拥有丰富的报表统计能力和问题排障能力。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-height=&quot;1228&quot; data-ratio=&quot;0.35594202898550725&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/AAQtmjCc74C7cwr1iam7XNocN4qr3TgVaInibO2qx9WXficIcTWoRhicQnXUMOCCSW37VuV2kSVfIpt4tp3I669qow/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;3450&quot; data-width=&quot;3450&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;但随着公司业务规模逐步扩大，微服务粒度也不可避免地变小，我们发现，CAT 已经逐步无法满足我们的使用场景了：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;问题排障与日常性能分析的场景也越来越复杂，对于一个核心场景，其内部的调用链路通常复杂多变，站在流量角度上看，需要完整地知道它的来源，上下游链路，异步调用等等，这对于 CAT 来说可能略显超纲。&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;CAT 虽供多维度报表分析，但定制化能力非常有限，在当时，业内的图表组件定制化解决方案逐步向 Grafana + Prometheus 靠拢，但若使用 CAT，则无法享受强大的图表绘制能力。与此同时，随着云原生社区可观测性项目 OpenTracing 的崛起，大约不到半年时间我们逐步下线了 CAT，向 OpenTracing 生态演进。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;2&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;h1&gt;&lt;strong&gt;&lt;span&gt; 0x02 第二阶段&lt;/span&gt;&lt;/strong&gt;&lt;/h1&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;h1&gt;&lt;strong&gt;&lt;span&gt; 持续创造 基于OpenTracing全链路采样监控&lt;/span&gt;&lt;/strong&gt;&lt;/h1&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;OpenTracing 为全链路追踪 Trace 定制了完整的一套协议标准，本身并不提供实现细节。在 OpenTracing 协议中，Trace 被认为是 Span 的有向无环图（DAG）。官方也例举了以下 8 个 Span 的因果关系和他们组成的单 Trace示例图：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-height=&quot;602&quot; data-ratio=&quot;0.5574074074074075&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/AAQtmjCc74C7cwr1iam7XNocN4qr3TgValNQfgVvq8LFHo6KLzBztK4eyraOl6iauJCeNRPQRIOTDS3EWUCcCPkQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot; data-width=&quot;1080&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在当时， OpenTracing 相关的开源社区也是异常活跃，它使用 Jaeger 来解决数据的收集，调用链则使用了甘特图展示：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-height=&quot;1340&quot; data-ratio=&quot;0.38683602771362585&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/AAQtmjCc74C7cwr1iam7XNocN4qr3TgVaP5MBianGoYqFnL50rlqIibDh5GYOBlJ11fr8icvxXac8zNaMZ5c48aKbQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;3464&quot; data-width=&quot;3464&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在 OpenTracing 生态中，我们对链路的采样使用头部采样策略， 对于指标 Metrics，OpenTracing 并没有制定它的规范，但在 Google SRE Book 里，关于 Monitoring Distributed System 章节中提到了四类黄金指标：&lt;/span&gt;&lt;/p&gt;&lt;blockquote data-type=&quot;quote_container&quot;&gt;&lt;ol start=&quot;1&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;吞吐量：如每秒请求数，通常的实现方式是，设定一个计数器，每完成一次请求将自增。通过计算时间窗口内的变化率来计算出每秒的吞吐量。&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;ol start=&quot;2&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;延迟：处理请求的耗时。&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;ol start=&quot;3&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;错误率/错误数：如 HTTP 500 错误。当然，有些即便是 HTTP 200 状态也需要根据特定业务逻辑来区分当前请求是否属于“错误”请求。&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;ol start=&quot;4&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;饱和度：类似服务器硬件资源如CPU,内存,网络的使用率等等。&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;所以，我们决定使用 Micrometer 库来对各个组件进行吞吐量，延迟和错误率的埋点，从而对 DB 类，RPC类的组件做性能监控。因此也可以说，我们&lt;strong&gt;第二阶段的监控是以&lt;/strong&gt;&lt;strong&gt;指标&lt;/strong&gt;&lt;strong&gt;监控为主，调用链监控为辅的应用性能监控&lt;/strong&gt;。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;2.1 使用 Endpoint 贯穿指标埋点帮助性能分析&lt;/span&gt;&lt;/strong&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;在指标埋点过程中，我们在所有的指标中引入了“流量入口（Endpoint）”标签。这个标签的引入，实现了根据不同流量入口来区分关联 DB，缓存，消息队列，远程调用类的行为。通过流量入口，贯穿了一个实例的所有组件指标，基本满足了以下场景的监控：&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-height=&quot;1320&quot; data-ratio=&quot;0.38372093023255816&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/AAQtmjCc74C7cwr1iam7XNocN4qr3TgVagmicXiaqhfavRVScicHd9hkD1hfpweGhdibBxNOrHJxO6MrDN9oV5nn8yQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;3440&quot; data-width=&quot;3440&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-height=&quot;628&quot; data-ratio=&quot;0.18309037900874636&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/AAQtmjCc74C7cwr1iam7XNocN4qr3TgVaq3viaX2H2EnTS49aq76C5RajUVZQCyRpmmtWssasMm6UDYicHzojTjEw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;3430&quot; data-width=&quot;3430&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;2.2 关于选型的疑问&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;你可能会问，链路监控领域在业内有现成的 APM 产品，比如 Zipkin, Pinpoint, SkyWalking 等，为什么当时会选择 OpenTracing + Prometheus 自行埋点？主要有两大因素：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;第一&lt;/strong&gt;，在当时，CAT 无法满足全链路监控和一些定制化的报表分析，而得物交易链路五彩石项目交付也趋于尾声，贸然去集成外部一款庞大的 APM 产品在没有充分的验证下，会给服务带来稳定性风险，在极其有限的时间周期内不是个理智的选择。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;第二&lt;/strong&gt;，监控组件是随着统一的基础框架来发布，同时，由另一团队牵头开发的全链路影子库路由组件借助了 OpenTracing 随行数据透传机制，且与监控组件是强耦合关系，而基础框架将统筹监控，压测和其他模块，借助Spring Boot Starter 机制，一定程度上做到了功能的开箱即用，无缝集成。而使用字节码增强方式的 Pinpoint, SkyWalking，无法很好地做到与基础框架集成，若并行开发，也会多出基础框架与 Java Agent 两边的管理和维护成本，减缓迭代速度。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-height=&quot;854&quot; data-ratio=&quot;0.977116704805492&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/AAQtmjCc74C7cwr1iam7XNocN4qr3TgVaQRdzIQMu6Ihp1ckDQpIkfEjCUr1zzG4WcUey4gYaalWqic1MYNGy0nQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;874&quot; data-width=&quot;874&quot;/&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在之后将近两年的时间里，应用服务监控覆盖了得物技术部使用的将近 70% 的组件，为得物App在 2021 年实现全年 99.97% 的 SLA 提供了强有力的支持。现在看来，基于 OpenTracing + Prometheus 生态，很好地解决了分布式系统的调用链监控，借助 Grafana 图表工具，做到了灵活的指标监控，融合基础框架，让业务方开箱即用…然而，我们说第二阶段是基于 OpenTracing 全链路采样监控，随着业务的高速发展，这套架构的不足点也逐渐显露出来。&lt;/span&gt;&lt;/p&gt;&lt;h2&gt;&lt;strong&gt;&lt;span&gt;2.3 架构特点&lt;/span&gt;&lt;/strong&gt;&lt;/h2&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;链路&lt;/strong&gt;：1%的采样率使得业务服务基本不会因调用链发送量大而导致性能问题，但同时也往往无法从错误，高耗时的场景中找到正好采样的链路。期间，我们曾经考虑将头部采样策略改为尾部采样，但面临着非常高昂的 SDK 改造成本和复杂调用情况下（如异步）采样策略的回溯，且无法保证发生每个高耗时，错误操作时能还原整个完整的调用链路。&lt;br/&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;集成方式&lt;/strong&gt;：业务和基础框架均采用 Maven 来构建项目，使用 Spring Boot Starter &quot;all in one&quot;开箱即用方式集成，极大降低了集成成本的同时，也给依赖冲突问题埋下了隐患。&lt;br/&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/ul&gt;&lt;p&gt;&lt;span&gt;迭代周期分化矛盾，与基础框架的集成是当时快速推广落地全链路监控的不二选择，通过这种方式，Java 服务的接入率曾一度接近100%，但在业务高速发展的背景下，基础框架的迭代速度已经远远跟不上业务迭代速度了，这也间接制约了整个监控系统的迭代。&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;数据治理成本逐步偏高，由于基础框架和业务系统的迭代节奏天然的不一致，且每个业务系统也有自身的迭代节奏，放眼全网后端服务上看，基础框架版本参差不齐。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-height=&quot;1178&quot; data-ratio=&quot;1.6925287356321839&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/AAQtmjCc74C7cwr1iam7XNocN4qr3TgVaGtydK6mSC8H375ZtDTy4bRGbeZ2UqicjeDRvo5WpsaTZGs8Y60HvsibQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;696&quot; data-width=&quot;696&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;尽管监控系统在每一次迭代时都会尽可能保证最大的向后兼容，但将近两年的迭代周期里，不同版本造成的数据差异也极大制约了监控门户系统天眼的迭代，开发人员长时间奔波于数据上的妥协，在很多功能的实现上曲线救国。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;相关预案依托于 Spring 框架 Bean 的自动装配逻辑，业务方理解成本低，便于变更，但缺少细粒度的预案，比如运行时期间特定逻辑降级等等。&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-height=&quot;412&quot; data-ratio=&quot;0.1813380281690141&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/AAQtmjCc74C7cwr1iam7XNocN4qr3TgVaFqoia8XlSIOL1xdch8qjaDMGIXW1HQnSRlzhhIdWoWnZntiaU3J7CN1g/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2272&quot; data-width=&quot;2272&quot;/&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;3&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;h1&gt;&lt;span&gt;&lt;strong&gt; 0x03 第三阶段&lt;/strong&gt;&lt;/span&gt;&lt;/h1&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;h1&gt;&lt;span&gt;&lt;strong&gt;向前一步 基于OpenTelemetry全链路应用性能监控&lt;/strong&gt;&lt;/span&gt;&lt;/h1&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;OpenTelemetry 的定位在于可观测性领域中对遥测数据采集和语义规范的统一，有 CNCF (云原生计算基金会)的加持，近两年里随着越来越多的人关注和参与，整个体系也越发成熟稳定。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;其实，我们在2020年底就已开始关注 OpenTelemetry 项目，只不过当时该项目仍处于萌芽阶段， Trace, Metrics API 还在 Alpha 阶段，有很多不稳定因素，考虑到需尽快投入生产使用，笔者曾在 2021 年中到年末期间也或多或少参与了 OpenTelemetry 社区相关 issue 的讨论，遥测模块的开发，底层数据协议的一致和一些 BUG 的修复。在这半年期间，相关 API 和 SDK 随着越来越多的人参与也逐步趋于稳定。&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;&lt;em&gt;&lt;strong&gt;OpenTelemetry&lt;/strong&gt;&lt;/em&gt;&lt;em&gt;&lt;strong&gt;架构（图源自 opentelemetry.io）&lt;/strong&gt;&lt;/em&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-height=&quot;1267&quot; data-ratio=&quot;1.58375&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/AAQtmjCc74C7cwr1iam7XNocN4qr3TgVaLXib1tQib4CMKvgGR1yc0znR5PAY6fv3gLNJXpIn1XofeK9ePJ6fvXkA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;800&quot; data-width=&quot;800&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;3.1 迈入 Trace2.0 时代&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;OpenTelemetry 的定位致力于将可观测性三大要素 Metrics,Trace,Log 进行统一，在遥测 API 制定上，提供了统一的上下文以便 SDK 实现层去关联。如 Metrics 与 Trace 的关联，笔者认为体现在 OpenTelemetry 在 Metrics 的实现上包含了对 OpenMetrics 标准协议的支持，其中 Exemplar 格式的数据打通了 Trace 与 Metrics 的桥梁：&lt;/span&gt;&lt;/p&gt;&lt;blockquote data-type=&quot;quote_container&quot;/&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;在这之前，Metrics 指标类型的数据无法精确关联到具体某个或某些 Trace 链路，只能根据时间戳粗略关联特定范围内的链路。这个方案的缺陷源自指标采集器 vmagent 每隔 10s~30s 的 Pull 模式中，指标的时间戳取决于采集时刻，与 Trace 调用时间并不匹配。&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-height=&quot;590&quot; data-ratio=&quot;0.6614349775784754&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/AAQtmjCc74C7cwr1iam7XNocN4qr3TgVaWziclSfqic5fIj8k9ibbbyCNZgcm16LXAI2X8d68sts63Nfovz7ran0vw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;892&quot; data-width=&quot;892&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;Exemplar 数据在直方图度量格式末尾会追加当前上下文中的 Trace ID,Span ID 信息，如下：&lt;/span&gt;&lt;/section&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;objectivec&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;shadower_virtual_field_map_operation_seconds_bucket{holder=&quot;Filter:Factory&quot;,key=&quot;WebMvcMetricsFilter&quot;,operation=&quot;get&quot;,tcl=&quot;AppClassLoader&quot;,value=&quot;Servlet3FilterMappingResolverFactory&quot;,le=&quot;0.2&quot;} 3949.0 1654575981.216 # {span_id=&quot;48f29964fceff582&quot;,trace_id=&quot;c0a80355629ed36bcd8fb1c6c89dedfe&quot;} 1.0 1654575979.751&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;为了采集 Exemplar 格式指标，同时又需防止分桶标签“le”产生的高基数问题，我们二次开发了指标采集 vmagent，额外过滤携带 Exemplar 数据的指标，并将这类数据异步批量发送到了 Kafka，经过 Flink 消费后落入 Clickhouse 后，由天眼监控门户系统提供查询接口和UI。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-height=&quot;464&quot; data-ratio=&quot;0.24091381100726894&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/AAQtmjCc74C7cwr1iam7XNocN4qr3TgVa6yL0YlPuSWHyJNP0mdtzUIK46L5G4Qr0x9L6E6KPM1kShibSFMJ0sRQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1926&quot; data-width=&quot;1926&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;分位线统计与Exemplar 数据关联UI示意图&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-height=&quot;401&quot; data-ratio=&quot;0.31328125&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/AAQtmjCc74C7cwr1iam7XNocN4qr3TgVaKzbOKUTxZKicB2IicOybgKYZgUa3OIbQ3xKGjaJXCJnnwAvLs9rVHibdA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1280&quot; data-width=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在数据上报层，OpenTelemetry Java SDK 使用了比 JDK 原生的阻塞队列性能更好的 Mpsc (多生产单消费）队列，它使用大量的 long 类型字段来做内存区域填充，用空间换时间解决了伪共享问题，减少了并发情况下的写竞争来提高性能。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在流量高峰时期，链路数据的发送队列这一块的性能从火焰图上看 CPU 占比平均小于2%，日常服务CPU整体水位与0采样相比几乎没有明显差距，因此我们经过多方面压测对比后，决定在生产环境客户端侧开放链路数据的全量上报，实现了在得物技术史上的全链路 100% 采样，终结了一直以来因为低采样率导致问题排查困难的问题，至此，&lt;strong&gt;在第三阶段，得物的全链路追踪技术正式迈入 &lt;/strong&gt;&lt;strong&gt;Trace2.0&lt;/strong&gt;&lt;strong&gt; 时代。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;得益于 OpenTelemetry 整体的可插拔式 API 设计，我们二次开发了 OpenTelemetry Java Instrumentation 项目 Shadower Java，扩展了诸多功能特性：&lt;/span&gt;&lt;/p&gt;&lt;h2&gt;&lt;strong&gt;&lt;span&gt;3.2 引入控制平面管理客户端采集行&lt;/span&gt;&lt;/strong&gt;&lt;/h2&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-height=&quot;1198&quot; data-ratio=&quot;0.5475319926873857&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/AAQtmjCc74C7cwr1iam7XNocN4qr3TgVaPhNdQtozboXd6QNXraEYnE87a0GekXkMeBV1MKsrF1aZ343W2Xhrbg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2188&quot; data-width=&quot;2188&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;使用控制平面，通过客户端监听机制来确保配置项的下发动作，包括：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-height=&quot;1090&quot; data-ratio=&quot;0.44745484400656815&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/AAQtmjCc74C7cwr1iam7XNocN4qr3TgVadQxaplvgZ3DnwFhqibkwK1emeMiahQbiceQQf8JboQxNQ1ulYuAjgdoaw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2436&quot; data-width=&quot;2436&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;控制平面的引入，弥补了无降级预案的空白，也提供了更加灵活的配置，支持了不同流量场景下快速变更数据采集方案：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-height=&quot;438&quot; data-ratio=&quot;0.611731843575419&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/AAQtmjCc74C7cwr1iam7XNocN4qr3TgVaHbaCT6WgjEzhGKicR40G4icPlDLeqJEvEl60rJv0b1dVDnevSVI9YUGA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;716&quot; data-width=&quot;716&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-height=&quot;1502&quot; data-ratio=&quot;2.495016611295681&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/AAQtmjCc74C7cwr1iam7XNocN4qr3TgVaUIiahv1nYpMfBAZxprmAJKMos7AgBLmZ4uspbkZqBwZF1PegCT662rw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;602&quot; data-width=&quot;602&quot;/&gt;&lt;/p&gt;&lt;h2&gt;&lt;strong&gt;&lt;span&gt;3.3 独立的启动模块&lt;/span&gt;&lt;/strong&gt;&lt;/h2&gt;&lt;p&gt;&lt;span&gt;为了解决业务方因集成基础框架而长期面临的依赖冲突问题，以及多版本共存引起的数据格式分散与兼容问题，我们自研了无极探针工具箱 Promise, 它是个通用的 javaagent launcher, 结合远端存储，支持可配置化任意 javaagent 的下载，更新，安装和启动：&lt;/span&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;ini&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;[plugins]&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;enables = shadower,arthas,pyroscope,chaos-agent&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;[shadower]&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;artifact_key = /javaagent/shadower-%s-final.jar&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;boot_class = com.shizhuang.apm.javaagent.bootstrap.AgentBootStrap&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;classloader = system&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;default_version = 115.16&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;[arthas]&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;artifact_key = /tools/arthas-bin.zip&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;;boot_class = com.taobao.arthas.agent334.AgentBootstrap&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;boot_artifact = arthas-agent.jar&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;premain_args = .attachments/arthas/arthas-core.jar;;ip=127.0.0.1&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;[pyroscope]&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;artifact_key = /tools/pyroscope.jar&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;[chaos-agent]&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;artifact_key = /javaagent/chaos-agent.jar&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;boot_class = com.chaos.platform.agent.DewuChaosAgentBootstrap&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;classloader = system&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;apply_envs = dev,test,local,pre,xdw&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-height=&quot;324&quot; data-ratio=&quot;0.18969555035128804&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/AAQtmjCc74C7cwr1iam7XNocN4qr3TgVaR6bUcwPrSCzWs0oSL1jyk4kicasxBM0lwfGia8qLS8sbJ9rmq5ekxqMA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1708&quot; data-width=&quot;1708&quot;/&gt;&lt;/section&gt;&lt;h2&gt;&lt;strong&gt;&lt;span&gt;3.4 基于 Otel API 的扩展&lt;/span&gt;&lt;/strong&gt;&lt;/h2&gt;&lt;h2&gt;&lt;span&gt;&lt;strong&gt;3.4.1 丰富的组件度量&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;&lt;h2&gt;&lt;span&gt;在第二阶段 OpenTracing 时期，我们使用 Endpoint 贯穿了多个组件的指标埋点，这个优秀的特性也延续至第三阶段，我们基于底层 Prometheus SDK 设计了一套完善的指标埋点 SDK，并且借助字节码插桩的便捷，优化并丰富了更多了组件库。&lt;span&gt;（在此阶段，OpenTelemetry SDK 主版本是 1.3.x ，相关 Metrics SDK 还处于Alpha 阶段）&lt;/span&gt;&lt;/span&gt;&lt;/h2&gt;&lt;h2&gt;&lt;span&gt;Otel 的 Java Instrumnetation 主要使用 WeakCo&lt;span&gt;ncurrentMap 来做异步链路上下文数据传递和同线程上下文关联的容器，由于 Otel 对许多流行组件库做了增强，因此 WeakConcurrentMap 的使用频率也是非常高的，针对这个对象的 size 做监控，有助于排查因探针导致的内存泄露问题，且它的增长率一旦达到我们设定的阈值便会告警，提早进行人工干预，执行相关预案，防止线上故障发生。&lt;/span&gt;&lt;/span&gt;&lt;/h2&gt;&lt;h2&gt;&lt;em&gt;&lt;strong&gt;部分自&lt;/strong&gt;&lt;strong&gt;监控&lt;/strong&gt;&lt;strong&gt;面板&lt;/strong&gt;&lt;/em&gt;&lt;/h2&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-height=&quot;1710&quot; data-ratio=&quot;0.534375&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/AAQtmjCc74C7cwr1iam7XNocN4qr3TgVaZGPeOqNf56k0grguI92diafvibkNW1qr6vLbYbL4kQuIYCXVkat2Sw4g/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;3200&quot; data-width=&quot;3200&quot;/&gt;&lt;/p&gt;&lt;h2&gt;&lt;strong&gt;&lt;span&gt;3.4.2扩展链路透传协&lt;/span&gt;&lt;/strong&gt;&lt;/h2&gt;&lt;h2&gt;&lt;strong&gt;&lt;span&gt;1) 引入RPC ID&lt;/span&gt;&lt;/strong&gt;&lt;/h2&gt;&lt;h2&gt;&lt;span&gt;为了更好地关联上下游应用，让每个流量都有“身份”，我们扩展了 &lt;strong&gt;TextMapPropagator &lt;/strong&gt;&lt;span&gt;接口，让每个流量在链路上都知道请求的来源，这对跨区域，环境调用排障场景起到关键性作用。&lt;/span&gt;&lt;/span&gt;&lt;/h2&gt;&lt;h2&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-height=&quot;1136&quot; data-ratio=&quot;1.7694704049844237&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/AAQtmjCc74C7cwr1iam7XNocN4qr3TgVahHkYSJBWicrUjhufMze1b0ZLl51eAdJ0cicup1EqREkN8HgIkNTnYibkw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;642&quot; data-width=&quot;642&quot;/&gt;&lt;/h2&gt;&lt;h2&gt;&lt;span&gt;此外，对于跨端场景，我们参考了阿里鹰眼调用链RPCID模型，增加了RpcID字段，这个字段在每次发生跨端调用时末尾数值会自增，而对于下游应用，字段本身的层级自增：&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-height=&quot;1160&quot; data-ratio=&quot;1.277533039647577&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/AAQtmjCc74C7cwr1iam7XNocN4qr3TgVade5ibnFw98RqfzJM0PwmS5aibHlzt41f7CE6W4ZUcl671lXvuzsosFtA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;908&quot; data-width=&quot;908&quot;/&gt;&lt;/p&gt;&lt;h2&gt;&lt;span&gt;该字段拥有以下作用：&lt;/span&gt;&lt;/h2&gt;&lt;h2&gt;&lt;span&gt;支&lt;span&gt;持提供精简化的调用链路视图，查询臃肿链路（如那些涉及缓存，DB调用大于 2000 Span的链路）时只提供 RPC 调用节点和调用层次关系。&lt;/span&gt;&lt;/span&gt;&lt;/h2&gt;&lt;h2&gt;&lt;span&gt;链路保真，客户端链路数据上报队列并不是个无界限队列，当客户端自身调用频繁时，若上报队列堆积达到阈值即会丢弃，这会造成整个链路的不完整，当然这是预期内的现象，但若没有RpcID字段，链路视图将无法关联丢失的节点，从而导致整个链路层级混乱失真。&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-height=&quot;1408&quot; data-ratio=&quot;0.5491419656786272&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/AAQtmjCc74C7cwr1iam7XNocN4qr3TgVaaL4ZoRu0VmyI7HupfU8awWVzhricDfmglJDsMKbDGVmtT1VUibuBATibw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2564&quot; data-width=&quot;2564&quot;/&gt;&lt;span/&gt;&lt;/p&gt;&lt;h2&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;2) 自定义 Trace ID&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;&lt;h2&gt;&lt;span&gt;为了实现链路详情页高效的检索效率，我们扩展 TraceID 生成逻辑，ID的前8位使用实例IP，中8位使用当前时间戳，后16位采用随机数生成。&lt;/span&gt;&lt;/h2&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;properties&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;32位自定义traceId：c0a8006b62583a724327993efd1865d8&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;c0a8006b  62583a72   4327993efd1865d8&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;   |         |             |&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;高8位(IP) 中8位(Timestmap) 低16位(Random)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;h2&gt;&lt;span&gt;这样的好处有两点：&lt;/span&gt;&lt;/h2&gt;&lt;h2&gt;&lt;span&gt;通过 TraceID 反向解析时间戳，锁定时间范围，有助于提高存储库 Clickhouse 的检索效率，此外也能帮助决定当前的 Trace 应该查询热库还是冷库。&lt;br/&gt;&lt;br/&gt;&lt;/span&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-height=&quot;458&quot; data-ratio=&quot;0.44901960784313727&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/AAQtmjCc74C7cwr1iam7XNocN4qr3TgVaGOuibuet98xvByTzmpINHv6ywMWg9uicg3uzLIflGAP4okAwZzU3dueQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1020&quot; data-width=&quot;1020&quot;/&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;绑定实例 IP，有助于关联当前 Trace 流量入口所属的实例，在某些极端场景，当链路上的节点检索不到时，也能通过实例和时间两个要素来做溯源。&lt;/span&gt;&lt;/h2&gt;&lt;h2&gt;&lt;strong&gt;&lt;span&gt;3) 异步调用识别&lt;/span&gt;&lt;/strong&gt;&lt;/h2&gt;&lt;h2&gt;&lt;span&gt;业务系统为了提高服务吞吐量，充分运用硬件资源，异步调用场景可谓无处不在。&lt;span&gt;我们基于Otel实现的异步链路上下文传递的基础上，额外扩充了&quot;async_flag&quot;字段来标识当前节点相对于父节点的调用关系，从而在展示层上能迅速找出发生异步调用的场景&lt;/span&gt;&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-height=&quot;224&quot; data-ratio=&quot;0.36363636363636365&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/AAQtmjCc74C7cwr1iam7XNocN4qr3TgVan4068Czs589fpXf1c9ReIu1XSqxktzCJq3GtDve5l8bR1sNX4KCdtg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;616&quot; data-width=&quot;616&quot;/&gt;&lt;/p&gt;&lt;h2&gt;&lt;strong&gt;&lt;span&gt;3.4.3  更清晰的调用链结构&lt;/span&gt;&lt;/strong&gt;&lt;/h2&gt;&lt;p&gt;&lt;span&gt;在 Otel 支持的部分组件中，有些操作不涉及到网络调用，或者具有非常频繁的操作，如 MVC 过程，数据库连接获取等，通常来说这类节点在链路详情主视图中的意义不大，因此我们对这类节点的产生逻辑进行了优化调整，使得整个链路主体结构聚焦于“跨端”，同时，对部分核心组件关键内部方法细节做了增强，以“事件”的形式挂载于它们的父节点上，便于更细粒度的排查：&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;&lt;h2&gt;&lt;em&gt;&lt;span&gt;&lt;strong&gt;RPC&lt;/strong&gt;&lt;strong&gt; 调用关键内部事件&lt;/strong&gt;&lt;/span&gt;&lt;/em&gt;&lt;/h2&gt;&lt;h2&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-height=&quot;487&quot; data-ratio=&quot;1.058695652173913&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/AAQtmjCc74C7cwr1iam7XNocN4qr3TgVap23IJV82yIjAmGbcd4aMew4ul8pg6onHslTfaKIP07nEkW1H8qM1YQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;460&quot; data-width=&quot;460&quot;/&gt;&lt;/h2&gt;&lt;h2&gt;&lt;em&gt;&lt;span&gt;&lt;strong&gt;DB 调用连接获取事件&lt;/strong&gt;&lt;/span&gt;&lt;/em&gt;&lt;/h2&gt;&lt;h2&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-height=&quot;1102&quot; data-ratio=&quot;1.6158357771260996&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/AAQtmjCc74C7cwr1iam7XNocN4qr3TgVaI07W1dSL0JtVtfLS9NDtuYFcq2y507NvA2vDhN8ehFHFuJOL9ziaic2Q/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;682&quot; data-width=&quot;682&quot;/&gt;&lt;/h2&gt;&lt;h2&gt;&lt;strong&gt;&lt;span&gt;3.4.4 profiling 的支持&lt;/span&gt;&lt;/strong&gt;&lt;/h2&gt;&lt;h2&gt;&lt;span&gt;1）线程栈分析的集成。&lt;span&gt;通过集成 Arthas 这类工具，可以很方便地查看某个实例线程的实时堆栈信息，同时对采样间隔做控制，避免频繁抓取影响业务自身性能。&lt;/span&gt;&lt;/span&gt;&lt;/h2&gt;&lt;h2&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-height=&quot;1400&quot; data-ratio=&quot;0.48703703703703705&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/AAQtmjCc74C7cwr1iam7XNocN4qr3TgVaImyiceEoyvDn9MJJF1G6W2xGaQpNBbEVhlEWIcfeATBiaEw0ZicUCjEIA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot; data-width=&quot;2876&quot;/&gt;&lt;/h2&gt;&lt;h2&gt;&lt;span&gt;2）通过集成 pyroscope，打通高延迟性能排查最后一公里。&lt;span&gt;Pyroscope 对 async profiler 做了二次开发，同时也支持 Otel 去集成，但截至目前，官方并没有实现完整的 Profiling 行为的生命周期，而 Profiling 行为一定程度上会影响性能，于是我们对官方 Pyroscope 的生命周期做了扩展，实现“停止”行为的同时，采用时间轮算法来检测特定操作的耗时，当达到期望的阈值将触发开启 profiling, 待操作结束或超过最大阈值则停止。&lt;/span&gt;&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-height=&quot;218&quot; data-ratio=&quot;0.06315179606025492&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/AAQtmjCc74C7cwr1iam7XNocN4qr3TgVavbDoib4TwCKzWSLkhaYxHs1kancnGOySdKNhlDZzxe0zazbVEJu7OHw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;3452&quot; data-width=&quot;3452&quot;/&gt;&lt;/p&gt;&lt;h2&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-height=&quot;1708&quot; data-ratio=&quot;0.5659377070907886&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/AAQtmjCc74C7cwr1iam7XNocN4qr3TgVaicDm2bnMZnrfv2wdz17gcVLvETuxru9dEQmhUCZyPviaAJ9rUsYZCfQQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;3018&quot; data-width=&quot;3018&quot;/&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;关于性能诊断相关的运用，请期待后续诊断专题。&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;/h2&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;4&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;h1&gt;&lt;span&gt;&lt;strong&gt; 0xff 结语&lt;/strong&gt;&lt;/span&gt;&lt;/h1&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;纵观得物在应用监控采集领域的三大里程碑迭代，第一阶段的 CAT 则是 0~1 的过程，它提供了应用服务对自身观测的途径，让业务方第一次真实地了解了服务运行状况，而第二阶段开始，随着业务发展的飞速提升，业务方对监控系统的要求就不仅只是从无到有了，而是要精细，准确。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;因此，快速迭代的背景下，功能与架构演进层面的矛盾，加上外部云原生大背景下可观测领域的发展因素，促使我们进行了基于 OpenTelemetry 体系的第三阶段的演进。功能，产品层面均取得了优异的结果。如今，我们即将进行下一阶段的演进，深度结合调用链与相关诊断工具，以第三阶段为基础，让得物全链路追踪技术正式迈入性能分析诊断时代。&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;5&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;&lt;strong&gt;关于我们&lt;/strong&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;得物监控团队提供一站式的可观测性平台，负责链路追踪、时序数据库、日志系统，包括自定义大盘、应用大盘、业务监控、智能告警、AIOPS等排障分析。&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;&lt;h2&gt;&lt;strong&gt;&lt;span&gt;参考文章：&lt;/span&gt;&lt;/strong&gt;&lt;/h2&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;Dapper, a Large-Scale Distributed Systems Tracing Infrastructure&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;https://storage.googleapis.com/pub-tools-public-publication-data/pdf/36356.pdf&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;大众点评开源分布式监控平台 CAT 深度剖析-阿里云开发者社区&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;https://developer.aliyun.com/article/269295&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;h1 data-v-052ff562=&quot;&quot; data-v-b110a92e=&quot;&quot;&gt;&lt;span&gt;趣谈“分布式链路追踪“组件发展史&lt;/span&gt;&lt;/h1&gt;&lt;h1 data-v-052ff562=&quot;&quot; data-v-b110a92e=&quot;&quot;&gt;&lt;span&gt;https://xie.infoq.cn/article/8e06e8d9e43d1768e021225cb&lt;/span&gt;&lt;/h1&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;Jaeger Sampling&lt;/span&gt;&lt;br/&gt;&lt;span&gt;https://www.jaegertracing.io/docs/1.39/sampling/&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;A brief history of OpenTelemetry (So Far) | Cloud Native Computing Foundation&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;https://www.cncf.io/blog/2019/05/21/a-brief-history-of-opentelemetry-so-far/&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;The OpenMetrics project — Creating a standard for exposing metrics data&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;https://openmetrics.io/&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;Merging OpenTracing and OpenCensus: A Roadmap to Convergence&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;Monitoring Distributed Systems&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;p mp-original-font-size=&quot;17&quot; mp-original-line-height=&quot;27.200000762939453&quot;&gt;&lt;strong mp-original-font-size=&quot;11&quot; mp-original-line-height=&quot;17.600000381469727&quot;&gt;&lt;span mp-original-font-size=&quot;12&quot; mp-original-line-height=&quot;19.200000762939453&quot;&gt;*文&lt;/span&gt;&lt;/strong&gt;&lt;strong mp-original-font-size=&quot;11&quot; mp-original-line-height=&quot;17.600000381469727&quot;&gt;&lt;span mp-original-font-size=&quot;12&quot; mp-original-line-height=&quot;19.200000762939453&quot;&gt;/栉枫忻垣&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot; mp-original-font-size=&quot;14&quot; mp-original-line-height=&quot;22.399999618530273&quot;&gt;&lt;section mp-original-font-size=&quot;14&quot; mp-original-line-height=&quot;22.399999618530273&quot;&gt;&lt;section mp-original-font-size=&quot;14&quot; mp-original-line-height=&quot;22.399999618530273&quot;&gt;&lt;section powered-by=&quot;xiumi.us&quot; mp-original-font-size=&quot;14&quot; mp-original-line-height=&quot;22.399999618530273&quot;&gt;&lt;section mp-original-font-size=&quot;14&quot; mp-original-line-height=&quot;22.399999618530273&quot;&gt;&lt;span&gt; &lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;关注得物技术，每周一三五晚18:30更新技术干货&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;要是觉得文章对你有帮助的话，欢迎评论转发点赞～&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;mp-common-profile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mpprofile&quot; data-weui-theme=&quot;light&quot; data-id=&quot;MzkxNTE3ODU0NA==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/AAQtmjCc74AlsHDtoVyU8hqzNTGS26fV9PmHAcZ8uib1GWNJibIuBiavPdAXw9IOzjlEAYRJUNjOEme5geMNPoZ1Q/0?wx_fmt=png&quot; data-nickname=&quot;得物技术&quot; data-alias=&quot;&quot; data-signature=&quot;技术知识分享交流平台，与你一同走向技术的云端。&quot; data-from=&quot;0&quot; data-is_biz_ban=&quot;0&quot;/&gt;&lt;/section&gt;&lt;p&gt;&lt;mp-style-type data-value=&quot;3&quot;/&gt;&lt;/p&gt;&lt;/div&gt;

          
        &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>8aeca74ebcd39fd46be4f5056be66246</guid>
<title>关于 Vue 项目打包部署知识点总结</title>
<link>https://toutiao.io/k/45y2426</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content js_underline_content             autoTypeSetting24psection&amp;#10;            &quot; id=&quot;js_content&quot;&gt;&lt;section data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;mp-common-profile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mpprofile&quot; data-weui-theme=&quot;light&quot; data-id=&quot;MzkyOTE5NzQ2Nw==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/MDPRplBm9ZVicvbRDVk8icbaWUEAAx9CnmXUiaRLuNLTYSbfJQHeuJJ4uzmS0Ipy2IgK8He2AUSD4sUaGYk7kRFtw/0?wx_fmt=png&quot; data-nickname=&quot;前端界&quot; data-alias=&quot;&quot; data-signature=&quot;高质量文章分享、实践干货、技术前沿、学习资料， 你感兴趣的都在前端界&quot; data-from=&quot;0&quot; data-is_biz_ban=&quot;0&quot;/&gt;&lt;/section&gt;&lt;p&gt;&lt;span data-darkmode-bgcolor-16021670869911=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16021670869911=&quot;rgb(255, 255, 255)&quot; data-darkmode-color-16021670869911=&quot;rgb(136, 136, 136)&quot; data-darkmode-original-color-16021670869911=&quot;rgb(136, 136, 136)&quot; data-darkmode-bgcolor-16030289161394=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16030289161394=&quot;rgb(255, 255, 255)&quot; data-darkmode-color-16030289161394=&quot;rgb(136, 136, 136)&quot; data-darkmode-original-color-16030289161394=&quot;rgb(136, 136, 136)&quot; data-darkmode-bgcolor-16030315732716=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16030315732716=&quot;rgb(255, 255, 255)&quot; data-darkmode-color-16030315732716=&quot;rgb(136, 136, 136)&quot; data-darkmode-original-color-16030315732716=&quot;rgb(136, 136, 136)&quot;&gt;关&lt;/span&gt;&lt;span data-darkmode-bgcolor-16021670869911=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16021670869911=&quot;rgb(255, 255, 255)&quot; data-darkmode-color-16021670869911=&quot;rgb(136, 136, 136)&quot; data-darkmode-original-color-16021670869911=&quot;rgb(136, 136, 136)&quot; data-darkmode-bgcolor-16030289161394=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16030289161394=&quot;rgb(255, 255, 255)&quot; data-darkmode-color-16030289161394=&quot;rgb(136, 136, 136)&quot; data-darkmode-original-color-16030289161394=&quot;rgb(136, 136, 136)&quot; data-darkmode-bgcolor-16030315732716=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16030315732716=&quot;rgb(255, 255, 255)&quot; data-darkmode-color-16030315732716=&quot;rgb(136, 136, 136)&quot; data-darkmode-original-color-16030315732716=&quot;rgb(136, 136, 136)&quot;&gt;注公众号 &lt;/span&gt;&lt;span data-darkmode-bgcolor-16021670869911=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16021670869911=&quot;rgb(255, 255, 255)&quot; data-darkmode-color-16021670869911=&quot;rgb(136, 136, 136)&quot; data-darkmode-original-color-16021670869911=&quot;rgb(136, 136, 136)&quot; data-darkmode-bgcolor-16030289161394=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16030289161394=&quot;rgb(255, 255, 255)&quot; data-darkmode-color-16030289161394=&quot;rgb(136, 136, 136)&quot; data-darkmode-original-color-16030289161394=&quot;rgb(136, 136, 136)&quot; data-darkmode-bgcolor-16030315732716=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16030315732716=&quot;rgb(255, 255, 255)&quot; data-darkmode-color-16030315732716=&quot;rgb(136, 136, 136)&quot; data-darkmode-original-color-16030315732716=&quot;rgb(136, 136, 136)&quot;&gt;前端界&lt;/span&gt;&lt;span data-darkmode-bgcolor-16021670869911=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16021670869911=&quot;rgb(255, 255, 255)&quot; data-darkmode-color-16021670869911=&quot;rgb(136, 136, 136)&quot; data-darkmode-original-color-16021670869911=&quot;rgb(136, 136, 136)&quot; data-darkmode-bgcolor-16030289161394=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16030289161394=&quot;rgb(255, 255, 255)&quot; data-darkmode-color-16030289161394=&quot;rgb(136, 136, 136)&quot; data-darkmode-original-color-16030289161394=&quot;rgb(136, 136, 136)&quot; data-darkmode-bgcolor-16030315732716=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16030315732716=&quot;rgb(255, 255, 255)&quot; data-darkmode-color-16030315732716=&quot;rgb(136, 136, 136)&quot; data-darkmode-original-color-16030315732716=&quot;rgb(136, 136, 136)&quot;&gt;，回复“&lt;/span&gt;&lt;span data-style=&quot;color: rgb(255, 0, 0); letter-spacing: 0.544px; word-spacing: 2px; font-size: 14px; visibility: visible;&quot; data-darkmode-bgcolor-16021670869911=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16021670869911=&quot;rgb(255, 255, 255)&quot; data-darkmode-color-16021670869911=&quot;rgb(255, 23, 0)&quot; data-darkmode-original-color-16021670869911=&quot;rgb(255, 0, 0)&quot; data-darkmode-bgcolor-16030289161394=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16030289161394=&quot;rgb(255, 255, 255)&quot; data-darkmode-color-16030289161394=&quot;rgb(255, 23, 0)&quot; data-darkmode-original-color-16030289161394=&quot;rgb(255, 0, 0)&quot; data-darkmode-bgcolor-16030315732716=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16030315732716=&quot;rgb(255, 255, 255)&quot; data-darkmode-color-16030315732716=&quot;rgb(255, 23, 0)&quot; data-darkmode-original-color-16030315732716=&quot;rgb(255, 0, 0)&quot;&gt;加群&lt;/span&gt;&lt;span data-darkmode-bgcolor-16021670869911=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16021670869911=&quot;rgb(255, 255, 255)&quot; data-darkmode-color-16021670869911=&quot;rgb(136, 136, 136)&quot; data-darkmode-original-color-16021670869911=&quot;rgb(136, 136, 136)&quot; data-darkmode-bgcolor-16030289161394=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16030289161394=&quot;rgb(255, 255, 255)&quot; data-darkmode-color-16030289161394=&quot;rgb(136, 136, 136)&quot; data-darkmode-original-color-16030289161394=&quot;rgb(136, 136, 136)&quot; data-darkmode-bgcolor-16030315732716=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16030315732716=&quot;rgb(255, 255, 255)&quot; data-darkmode-color-16030315732716=&quot;rgb(136, 136, 136)&quot; data-darkmode-original-color-16030315732716=&quot;rgb(136, 136, 136)&quot;&gt;”&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;&lt;section&gt;&lt;span data-darkmode-bgcolor-16021670869911=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16021670869911=&quot;rgb(255, 255, 255)&quot; data-darkmode-color-16021670869911=&quot;rgb(136, 136, 136)&quot; data-darkmode-original-color-16021670869911=&quot;rgb(136, 136, 136)&quot; data-darkmode-bgcolor-16030289161394=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16030289161394=&quot;rgb(255, 255, 255)&quot; data-darkmode-color-16030289161394=&quot;rgb(136, 136, 136)&quot; data-darkmode-original-color-16030289161394=&quot;rgb(136, 136, 136)&quot; data-darkmode-bgcolor-16030315732716=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16030315732716=&quot;rgb(255, 255, 255)&quot; data-darkmode-color-16030315732716=&quot;rgb(136, 136, 136)&quot; data-darkmode-original-color-16030315732716=&quot;rgb(136, 136, 136)&quot;&gt;加入我们一起学习，天天进步&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;使用Vue做前后端分离项目时，通常前端是单独部署，用户访问的也是前端项目地址，因此前端开发人员很有必要熟悉一下项目部署的流程与各类问题的解决办法了。&lt;/span&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;Vue项目打包部署本身不复杂，不过一些前端同学可能对服务器接触不多，部署过程中还是会遇到这样那样的问题。本文介绍一下使用nginx服务器代理前端项目的方法以及项目部署的相关问题，内容概览：&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.426056338028169&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/eXCSRjyNYcbxNdEFUeg1j6DemDLNrAR5FnoPe9THbTygOw10NbPmRqnCRnhaWOIOLwCRF6vh5B10ZtLChy9wSA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;568&quot;/&gt;&lt;/p&gt;&lt;h2&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;一、准备工作——服务器和nginx使用&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;&lt;h4&gt;&lt;span&gt;&lt;strong&gt;1. 准备一台服务器&lt;/strong&gt;&lt;/span&gt;&lt;/h4&gt;&lt;section&gt;&lt;span&gt;我的是ubuntu系统，linux系统的操作都差不多。没有服务器怎么破？&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;如果你只是想体验一下，可以尝试各大厂的云服务器免费试用套餐，比如华为云免费试用，本文相关操作即是在华为云上完成的。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;不过如果想时常练练手，我觉得可以购买一台云服务器，比如上面的华为云或者阿里云都还挺可靠。&lt;/span&gt;&lt;/section&gt;&lt;h4&gt;&lt;span&gt;&lt;strong&gt;2. nginx安装和启动&lt;/strong&gt;&lt;/span&gt;&lt;/h4&gt;&lt;section&gt;&lt;span&gt;轻装简行，这部分不作过多赘述（毕竟网上相关教程一大堆），正常情况下仅需下面两个指令：&lt;/span&gt;&lt;/section&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;properties&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;# 安装，安装完成后使用nginx -v检查，如果输出nginx的版本信息表明安装成功&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;sudo apt-get install nginx&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;# 启动&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;sudo service nginx start&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;启动后，正常情况下，直接访问 http://服务器ip 或 http://域名 （本文测试用的服务器没有配置域名，所以用ip，就本文而言，域名和ip没有太大区别）应该就能看到nginx服务器的默认页面了——如果访问不到，有可能是你的云服务器默认的http服务端口（80端口）没有对外开放，在服务器安全组配置一下即可。&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.544921875&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/eXCSRjyNYcbxNdEFUeg1j6DemDLNrAR58LQKf4fyPAiajjH7yKt09k5Qb9kCPYfqtFQFsS3vOuvYePjO7dbZOCQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;512&quot;/&gt;&lt;/p&gt;&lt;h4&gt;&lt;strong&gt;3、 了解nginx: 修改nginx配置，让nginx服务器代理我们创建的文件&lt;/strong&gt;&lt;/h4&gt;&lt;p&gt;&lt;span&gt;查看nginx的配置，linux系统下的配置文件通常会存放在/etc目录下，nginx的配置文件就在/etc/nginx文件夹，打开文件/etc/nginx/sites-available/default（nginx可以有多个配置文件，通常我们配置nginx也是修改这个文件）：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;294&quot; data-backw=&quot;578&quot; data-ratio=&quot;0.5097159940209267&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/eXCSRjyNYcbxNdEFUeg1j6DemDLNrAR5JlBZxxDGORGnKiaD088TYJKHic7YD9takjQW631jdhRuNwx21LJL3uBA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;669&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;可以看到默认情况下，nginx代理的根目录是/var/www/html，输入 http://服务器ip会访问这个文件夹下的文件，会根据index的配置值来找默认访问的文件，比如index.html、index.htm之类。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;我们可以更改root的值来修改nginx服务代理的文件夹：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;1）、创建文件夹/www，并创建index.html，写入&quot;Hello world&quot;字符串&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;javascript&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;mkdir /www&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;echo &lt;span class=&quot;code-snippet__string&quot;&gt;&#x27;Hello world&#x27;&lt;/span&gt; &amp;gt; &lt;span class=&quot;code-snippet__regexp&quot;&gt;/www/i&lt;/span&gt;ndex.html&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;2）、修改root值为 /www&lt;/span&gt;&lt;/strong&gt;&lt;br/&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.4423963133640553&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/eXCSRjyNYcbxNdEFUeg1j6DemDLNrAR57o0R25dTaGfoXRd1p9YK5BozVicH9F0l8rLcFBDqh110eo5cMn5gKsg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;651&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;3）、sudo nginx -t 检查nginx配置是否正确&lt;/span&gt;&lt;/strong&gt;&lt;/section&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.12486187845303867&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/eXCSRjyNYcbxNdEFUeg1j6DemDLNrAR5xRSZibzvdFQCuhx9pwObuD8gol7OmjrmGn00uRmnPAicPicfiaAx6ZJ3XA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;905&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;4）、加载nginx配置：sudo nginx -s reload&lt;/span&gt;&lt;/strong&gt;&lt;span/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;再次访问页面，发现页面内容已经变成了我们创建的index.html:&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.24585635359116023&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/eXCSRjyNYcbxNdEFUeg1j6DemDLNrAR5iaN7PwGkXJgczrJ6fAtFmMwyT9TQ0C9vXCsrIy29A4R1VniaNnQOPjXQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;362&quot;/&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;h2&gt;&lt;strong&gt;&lt;span&gt;二、Vue项目打包同步文件到远程服务器&lt;/span&gt;&lt;/strong&gt;&lt;/h2&gt;&lt;h4&gt;&lt;strong&gt;1、 打包&lt;/strong&gt;&lt;/h4&gt;&lt;section&gt;&lt;span&gt;默认情况下，使用vue-cli创建的项目，package.json里的script应该已经配置了build指令，直接执行yarn build 或者 npm run build即可。&lt;/span&gt;&lt;/section&gt;&lt;h4&gt;&lt;strong&gt;2、 同步到远程服务器&lt;/strong&gt;&lt;/h4&gt;&lt;section&gt;&lt;span&gt;我们使用nginx部署Vue项目，实质上就是将Vue项目打包后的内容同步到nginx指向的文件夹。之前的步骤已经介绍了怎样配置nginx指向我们创建的文件夹，剩下的问题就是怎么把打包好的文件同步到服务器上指定的文件夹里，比如同步到之前步骤中创建的/www。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;同步文件可以在git-bash或者powershell使用scp指令，如果是linux环境开发，还可以使用rsync指令:&lt;/span&gt;&lt;/section&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;ruby&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;scp -r dist/* root@117.78.4.26:/www&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;或&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;rsync -avr --delete-after dist/* root@117.78.4.26:/www&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;注意这里以及后续步骤是root使用用户远程同步，应该根据你的具体情况替换root和ip(ip换为你自己的服务器IP)。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;为了方便，可以在package.json脚本中加一个push命令，以使用yarn为例（如果你使用npm，则push命令中yarn改成npm  run即可）：&lt;/span&gt;&lt;/section&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;perl&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&quot;scripts&quot;: {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &quot;build&quot;: &quot;vue-cli-service build&quot;,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &quot;push&quot;: &quot;yarn build &amp;amp;&amp;amp; scp -r dist/* root@117.78.4.26:/www&quot;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  },&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;这样就可以直接执行yarn push 或者npm run push直接发布了。不过还有一个小问题，就是命令执行的时候要求输入远程服务器的root密码（这里使用root来连接远程的，你可以用别的用户，毕竟root用户权限太高了）。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;为了避免每次执行都要输入root密码，我们可以将本机的ssh同步到远程服务器的authorized_keys文件中。&lt;/span&gt;&lt;/section&gt;&lt;h4&gt;&lt;strong&gt;3、 同步ssh key&lt;/strong&gt;&lt;span/&gt;&lt;/h4&gt;&lt;ol class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;生成ssh key：使用git bash或者powershell执行ssh-keygen可以生成ssh key。会询问生成的key存放地址，直接回车就行，如果已经存在，则会询问是否覆盖：&lt;/span&gt;&lt;br/&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.2065063649222065&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/eXCSRjyNYcbxNdEFUeg1j6DemDLNrAR5BxJka1gpUGmgTFJuuz2I9Mb3IyCvu1WEqyr1uysGM1W75ocg8Hqmzg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;707&quot;/&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;同步ssh key到远程服务器，使用ssh-copy-id指令同步&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;objectivec&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;ssh-copy-id -i ~/.ssh/id_rsa.pub root@117.78.4.26&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.34153005464480873&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/eXCSRjyNYcbxNdEFUeg1j6DemDLNrAR58iaMby0ZaCMyn10fIe9tTrBGvxjtSK0Oh3UaAhxvFILpRictvT8S3YMA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;732&quot;/&gt;&lt;br/&gt;输入密码后，之后再次同步就不需要输入密码了。其实ssh_key是同步到了服务器（此处是root用户家目录）~/.ssh/authorized_keys文件里：&lt;/section&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.42823529411764705&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/eXCSRjyNYcbxNdEFUeg1j6DemDLNrAR5OhLUEKps8ibQtf1kc32JmG9kWLZDkUOq4LaQpMibuXKCP7bL6OibibWgTQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;850&quot;/&gt;&lt;br/&gt;&lt;span&gt;当然你也可以手动复制本地~/.ssh/id_rsa.pub（注意是pub结尾的公钥）文件内容追加到服务器~/.ssh/authorized_keys的后面（从命名可以看出该文件可以存储多个ssh key）&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;注意：这里全程使用的是root用户，所以没有文件操作权限问题。如果你的文件夹创建用户不是远程登录用户，或许会存在同步文件失败的问题，此时需要远程服务器修改文件夹的读写权限（命令 chmod）。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;创建了一个测试项目（点击本链接可以在gihub查看）试一下，打包、文件上传一句指令搞定啦：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6897374701670644&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/eXCSRjyNYcbxNdEFUeg1j6DemDLNrAR5PHoXtHibxfhRDZsDI9bcRfRgClmib7cfJCk8mdsKaV8Njczygla8Y5YQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;838&quot;/&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;访问一下，果然看到了我们熟悉的界面：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6074766355140186&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/eXCSRjyNYcbxNdEFUeg1j6DemDLNrAR55hV7BvibjFbicg002tLqYnwuia6tPqH5tweZH0KR6rN3ibxBnSVTGhX8GA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;535&quot;/&gt;&lt;/p&gt;&lt;p&gt;至此，常规情况下发布Vue项目就介绍完了，接下来介绍非域名根路径下发布以及history路由模式发布方法。&lt;/p&gt;&lt;h2&gt;&lt;strong&gt;&lt;span&gt;三、非域名根路径发布&lt;/span&gt;&lt;/strong&gt;&lt;/h2&gt;&lt;p&gt;有时候同一台服务器同一端口下可能会根据目录划分出多个不同的项目，比如我们希望项目部署到http://a.com/test下，这样访问http://a.com/test访问到的是项目的首页，而非test前缀的地址会访问到其它项目。此时需要修改nginx配置以及Vue打包配置。&lt;/p&gt;&lt;h4&gt;&lt;strong&gt;1、 nginx配置&lt;/strong&gt;&lt;/h4&gt;&lt;p&gt;只需要添加一条location规则，分配访问路径和指定访问文件夹。我们可以把/test指向之前创建的/www文件夹，这里因为文件夹名称和访问路径不一致，需要用到alias这个配置：&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.3425499231950845&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/eXCSRjyNYcbxNdEFUeg1j6DemDLNrAR5OGANMicpcXyeeaCvJibRf8fZYA3ia3TxK1pZEupXc6xun8jPkEBicX3g9A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;651&quot;/&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;如果文件夹名称与访问路径一致都为test，那这里可以用root来配置：&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.35130970724191063&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/eXCSRjyNYcbxNdEFUeg1j6DemDLNrAR5F5IQiaysknyFpN4DicBmv6QlZsU7beeeyibuqaxehNHdgeR7WyDn3jtbw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;649&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;这里要将/test配置放到/之前，意味着在路由进入的时候，会优先匹配/test。如果根路径/下的项目有子路由/test，那http://xxxx/test只会访问到/www里的项目，而不会访问该子路由。&lt;/span&gt;&lt;/section&gt;&lt;h4&gt;&lt;strong&gt;2、项目配置&lt;/strong&gt;&lt;/h4&gt;&lt;section&gt;&lt;span&gt;为了解决打包后资源路径不对的问题，需要在vue.config.js中配置publicPath，这里有两种配置方式，分别将publicPath配置为./和/test：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.2352168199737188&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/eXCSRjyNYcbxNdEFUeg1j6DemDLNrAR5HoK2JWiaSiaCtvht7JsibcsKnKWIKzoJCFGtzOKl8MQc2Cia3Zlic62SZUw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;761&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;更新nginx配置，发布后即可正常访问啦。这里的两种配置方式是有区别的，接下来会看一下它们的区别。&lt;br/&gt;如果不进行项目配置，直接发布访问会出现JS、CSS等资源找不到导致页面空白的问题：&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5349264705882353&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/eXCSRjyNYcbxNdEFUeg1j6DemDLNrAR5JrwbufmuUHRPPEibMfhzD83OJ7Q0iaqnqziazRDlmZIbPJyJx0vwEF6eg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;544&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;该问题原因是资源引用路径不对，页面审查元素可以看到，页面引用的js都是从根路径下引用的：&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5308411214953271&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/eXCSRjyNYcbxNdEFUeg1j6DemDLNrAR5ia3PciaLTDeQdbsviaDX61Z6THow1y3YSV6otpzeVRpPX1sB6ag4TvTuQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;535&quot;/&gt;&lt;/p&gt;&lt;section&gt;查看打包后的文件结构，可以看到js/css/img/static等资源文件是与index.html处于同级别的：&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.4780361757105943&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/eXCSRjyNYcbxNdEFUeg1j6DemDLNrAR55iczPyc8fBsr4kBpBwMuJnvp91dk0zY0eK3YpglWPDGw8rHaic8GWZXw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;387&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;对于两种配置方式，看看都是怎么生效的：&lt;/span&gt;&lt;/section&gt;&lt;ol class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;publicPath配置为./， 打包后资源引用路径为相对路径：&lt;/span&gt;&lt;br/&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.42441054091539526&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/eXCSRjyNYcbxNdEFUeg1j6DemDLNrAR5yqaVnEPT2MKnS1fC9hr0uNuRTv31yVLPQudvvD6BfCtJd5hiciaeosibA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;721&quot;/&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;publicPath配置为/test，打包后资源相对路径为从域名根目录开始的绝对路径：&lt;/span&gt;&lt;br/&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.4465753424657534&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/eXCSRjyNYcbxNdEFUeg1j6DemDLNrAR5ibOzzQxrPsM2bkeGyReiasu8gzlicl8ibGAIoiawzZ7uErUfibNNuUZuNgAg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;730&quot;/&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;section&gt;&lt;span&gt;两种配置都可以正确地找到JS、CSS等资源。不过还有个问题，那就是static中的静态资源依旧会找不到。&lt;/span&gt;&lt;/section&gt;&lt;h4&gt;&lt;strong&gt;3、绝对路径引用的静态资源找不到的问题&lt;/strong&gt;&lt;/h4&gt;&lt;section&gt;&lt;span&gt;因为在打包过程中，public下的静态资源都不会被webpack处理，我们需要通过绝对路径来引用它们。当项目部署到非域名根路径上时，这点非常头疼，你需要在每个引用的URL前面加上process.env.BASE_URL（该值即对应上文配置的publicPath），以使得资源能被正常访问到。我们可以在main.js把这个变量值绑定到Vue.prototype，这样每个Vue组件都可以使用它：&lt;/span&gt;&lt;/section&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;bash&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;Vue.prototype.&lt;span class=&quot;code-snippet__variable&quot;&gt;$pb&lt;/span&gt; = process.env.BASE_URL&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;在模板中使用：&lt;/span&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;perl&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&amp;lt;img :src=&quot;`${$pb}static/logo.png`&quot;&amp;gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;然而，更加头疼并且没有良好解决方案的问题是在组件style部分使用public文件夹下的静态资源：&lt;/span&gt;&lt;/section&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;如果需要使用图片等作为背景图片等，尽量使用内联方式使用吧，像在模板中使用一样。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;如果需要引入样式文件，则在index.html中使用插值方式引入吧。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;section&gt;&lt;span&gt;关于静态资源的问题，vue-cli的推荐是尽量将资源作为你的模块依赖图的一部分导入（即放到assets中，使用相对路径引用），避免该问题的同时也带来其它好处：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.20680628272251309&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/eXCSRjyNYcbxNdEFUeg1j6DemDLNrAR5guhWkRCrXkRN5F7yO74vNyoGmuHMNe9LiaDkKCRyYvttoHLVpangiavA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;764&quot;/&gt;&lt;/span&gt;&lt;/section&gt;&lt;h2&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;四、history模式部署&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;&lt;section&gt;&lt;span&gt;默认情况下，Vue项目使用的是hash路由模式，就是URL中会包含一个#号的这种形式。#号以及之后的内容是路由地址的hash部分。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;正常情况下，当浏览器地址栏地址改变，浏览器会重新加载页面，而如果是hash部分修改的话，则不会，这就是前端路由的原理，允许根据不同的路由页面局部更新而不刷新整个页面。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;H5新增了history的pushState接口，也允许前端操作改变路由地址但是不触发页面刷新，history模式即利用这一接口来实现。因此使用history模式可以去掉路由中的#号。&lt;/span&gt;&lt;/section&gt;&lt;h4&gt;&lt;strong&gt;1、项目配置&lt;/strong&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p&gt;&lt;span&gt;在vue-router路由选项中配置mode选项和base选项，mode配置为&#x27;history&#x27;；&lt;/span&gt;&lt;span&gt;如果部署到非域名根目录，还需要配置base选项为前文配置的publicPath值（注意：&lt;/span&gt;&lt;span&gt;此情况下，publicPath必须使用绝对路径/test的配置形式，而不能用相对路径./）&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.37267080745341613&quot; data-type=&quot;png&quot; data-w=&quot;322&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/eXCSRjyNYcbxNdEFUeg1j6DemDLNrAR5vsT9kpBbrxeYouuHSJYvCEAW1W1wiaUccYjoWkImayIPLsWvaSmIZtg/640?wx_fmt=png&quot;/&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;h4&gt;&lt;strong&gt;2、 nginx配置&lt;/strong&gt;&lt;/h4&gt;&lt;section&gt;对于history模式，假设项目部署到域名下的/test目录，访问http://xxx/test/about的时候，服务器会去找/test指向的目录下的about子目录或文件，很显然因为是单页面应用，并不会存在a这个目录或者文件，就会导致404错误：&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.43556701030927836&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/eXCSRjyNYcbxNdEFUeg1j6DemDLNrAR5U6Jicbn2KgJAPVvU8jWUTkaT2I5suicib28CTbOdqVGxDlsw970WfHvjg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;388&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section&gt;我们要配置nginx让这种情况下，服务器能够返回单页应用的index.html，然后剩下的路由解析的事情就交给前端来完成即可。&lt;/section&gt;&lt;p&gt;&lt;span&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.21568627450980393&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/eXCSRjyNYcbxNdEFUeg1j6DemDLNrAR5e02qNfDPiaAuwMwksic5IYAj5r2kgfq0L0Le6KZeCnCt8zwuv4T29JcQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;459&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;这句配置的意思就是，拿到一个地址，先根据地址尝试找对应文件，找不到再试探地址对应的文件夹，再找不到就返回/test/index.html。再次打开刚才的about地址，刷新页面也不会404啦：&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5202702702702703&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/eXCSRjyNYcbxNdEFUeg1j6DemDLNrAR5bvEusZibMtF8Q0Kfd7u7IWw237wCIA5ePibvSfW9MPEqaSAHmW8F8LBQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;444&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;h4&gt;&lt;span&gt;&lt;strong&gt;3、history模式部署到非域名根路径下&lt;/strong&gt;&lt;/span&gt;&lt;/h4&gt;&lt;section&gt;&lt;span&gt;非域名根目录下部署，首先肯定要配置publicPath。需要注意的点前面其实已经提过了，就是这种情况下不能使用相对路径./或者空串配置publicPath。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;为什么呢？&lt;br/&gt;原因是它会导致router-link等的表现错乱，使用测试项目分别使用两种配置打包发布，审查元素就能看出区别。在页面上有两个router-link，Home和About：&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.2869198312236287&quot; data-type=&quot;png&quot; data-w=&quot;474&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/eXCSRjyNYcbxNdEFUeg1j6DemDLNrAR5jArUlfINXjqDlydlx2eDicWJBOUmSnjRVzmgvK2sOxIGnQKJwVsjcKQ/640?wx_fmt=png&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;两种配置打包后的结果如下。&lt;/span&gt;&lt;/section&gt;&lt;ol class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;publicPath配置为./或者空串：&lt;/span&gt;&lt;span&gt;&lt;br/&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.35377358490566035&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/eXCSRjyNYcbxNdEFUeg1j6DemDLNrAR54h5ZEGbkogJBXhxqILobzgapWGI6pU2P8UibXMBAGrWvEibh9oicnb4iaQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;424&quot;/&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;publicPath配置为/test：&lt;br/&gt;&lt;/span&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.23270440251572327&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/eXCSRjyNYcbxNdEFUeg1j6DemDLNrAR5Z16qDd7nFNZ3U4tpf1TgTOF96BiaoFvqefaMlhFycJiaTBicfgRoD1CQQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;636&quot;/&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;publicPath配置为相对路径的router-link打包后地址变成了相对根域名下地址，很明显是错误的，所以非域名根路径部署应该将publicPath配置为完整的前缀路径。&lt;/span&gt;&lt;/section&gt;&lt;h2&gt;&lt;strong&gt;&lt;span&gt;五、结语&lt;/span&gt;&lt;/strong&gt;&lt;/h2&gt;&lt;section&gt;&lt;span&gt;关于Vue项目发布的相关问题就先总结这么多，几乎在每一步都踩过坑才有所体会，有问题欢迎各位同学一起探讨。&lt;/span&gt;&lt;/section&gt;&lt;blockquote class=&quot;js_blockquote_wrap&quot; data-type=&quot;2&quot; data-url=&quot;&quot; data-author-name=&quot;&quot; data-content-utf8-length=&quot;32&quot; data-source-title=&quot;&quot;&gt;&lt;section class=&quot;js_blockquote_digest&quot;&gt;&lt;section&gt;来源：https://wintc.top/article/29&lt;/section&gt;&lt;/section&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;/p&gt;&lt;p data-darkmode-color-16057140139831=&quot;rgb(162, 162, 162)&quot; data-darkmode-original-color-16057140139831=&quot;rgb(68, 68, 68)&quot; data-style=&quot;padding-top: 7px; padding-bottom: 7px; color: rgb(68, 68, 68); font-size: 14px; line-height: 1.8; font-family: &amp;quot;Helvetica Neue&amp;quot;, Helvetica, &amp;quot;Lucida Grande&amp;quot;, Arial, &amp;quot;Hiragino Sans GB&amp;quot;, 微软雅黑, &amp;quot;WenQuanYi Micro Hei&amp;quot;, STHeiti, SimSun, sans-serif; text-align: center;&quot;&gt;&lt;span&gt;加我微信，拉你进前端进阶、面试交流群，互相监督学习进步等！&lt;/span&gt;&lt;span data-darkmode-color-16057140139831=&quot;rgb(163, 163, 163)&quot; data-darkmode-original-color-16057140139831=&quot;rgb(63, 63, 63)&quot; data-style=&quot;color: rgb(63, 63, 63); font-family: monospace; font-size: 20px; letter-spacing: 0.544px; white-space: pre-wrap; widows: 1; caret-color: rgb(51, 51, 51);&quot;/&gt;&lt;/p&gt;&lt;pre&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;1.2842304060434373&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/MDPRplBm9ZWibjvKriapPYw7494Tah6ESd6hXNqYLibwXYc1dJy9myWia0wImNM8RaGu8pkibaywtKMXOVGu8pfOOQg/640?wx_fmt=jpeg&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; data-type=&quot;jpeg&quot; data-w=&quot;1059&quot;/&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;推荐链接&lt;/span&gt;&lt;/h3&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzkyOTE5NzQ2Nw==&amp;amp;mid=2247485013&amp;amp;idx=1&amp;amp;sn=9324e663eb2d6ed02a2f167e12b56692&amp;amp;chksm=c20c7aa1f57bf3b7f7e00ecc07d753a201ea08da5ad083dc5f70adc8553ef731f9e295afe8a2&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;TypeScript中 interface 和 type 的区别，你真的懂了吗&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot; wah-hotarea=&quot;click&quot; hasload=&quot;1&quot;&gt;TypeScript中 interface 和 type 的区别，你真的懂了吗&lt;/a&gt;？&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzkyOTE5NzQ2Nw==&amp;amp;mid=2247485101&amp;amp;idx=1&amp;amp;sn=09322752bb7e63dea5286f9a0c51164a&amp;amp;chksm=c20c7a59f57bf34f2142aef77367ec01e1cd2471637920f48f53552eafcca8b35f93625eaec9&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;2022年，前端er们都在看哪些网站？&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot; wah-hotarea=&quot;click&quot; hasload=&quot;1&quot;&gt;2022年，前端er们都在看哪些网站？&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;&lt;li/&gt;&lt;/ol&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;&lt;mp-common-profile data-index=&quot;1&quot; data-id=&quot;MzkyOTE5NzQ2Nw==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/MDPRplBm9ZVicvbRDVk8icbaWUEAAx9CnmXUiaRLuNLTYSbfJQHeuJJ4uzmS0Ipy2IgK8He2AUSD4sUaGYk7kRFtw/0?wx_fmt=png&quot; data-nickname=&quot;前端界&quot; data-alias=&quot;&quot; data-signature=&quot;高质量文章分享、实践干货、技术前沿、学习资料， 你感兴趣的都在前端界&quot; data-origin_num=&quot;10&quot; data-is_biz_ban=&quot;0&quot; data-isban=&quot;0&quot; class=&quot;js_wx_tap_highlight&quot; data-from=&quot;2&quot; has-insert-preloading=&quot;1&quot; data-weui-theme=&quot;light&quot;/&gt;&lt;/section&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;创作不易，&lt;/span&gt;&lt;strong&gt;加个&lt;/strong&gt;&lt;strong&gt;点赞、在看&lt;/strong&gt;&lt;strong&gt; &lt;/strong&gt;&lt;span&gt;支持一下&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;/pre&gt;&lt;p&gt;&lt;mp-style-type data-value=&quot;3&quot;/&gt;&lt;/p&gt;&lt;/div&gt;

          
        &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>