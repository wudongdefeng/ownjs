<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>7ea4225a65b6c2ce167feb0143eea9c5</guid>
<title>全局视角看技术-Java多线程演进史</title>
<link>https://toutiao.io/k/zpdpuex</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;preview&quot;&gt;&lt;p&gt;作者：京东科技 文涛&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;全文较长共6468字，语言通俗易懂，是一篇具有大纲性质的关于多线程的梳理，作者从历史演进的角度讲了多线程相关知识体系，让你知其然知其所以然。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h1&gt;前言&lt;/h1&gt;

&lt;p&gt;2022年09月22日，JDK19发布了，此版本最大的亮点就是支持虚拟线程，从此轻量级线程家族再添一员大将。虚拟线程使JVM摆脱了通过操作系统调度线程的束缚，由JVM自身调度线程。其实早期sun在Solaris操作系统的虚拟机中实现过JVM调度线程，基于其复杂性，和可维护性考虑，最终都回归到了由操作系统调度线程的模式。&lt;/p&gt;

&lt;p&gt;长安归来锦衣客，昨日城南起新宅。回想这一路走来，关于多线程的概念令人烟花缭乱，网上相关讲解也不胜枚举，但总感觉缺少一个全局性的视角。为此笔者系统性的梳理了Java关于多线程的演进史，希望对你掌握多线程知识有帮助。&lt;/p&gt;

&lt;p&gt;本文不讲什么：&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;1 不讲某些技术点的详细实现原理，不拆解源码，不画图，如果从本文找到了你感兴趣的概念和技术可以自行搜索 2 不讲支持并发性的库和框架，如Quasar、Akka、Guava等&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;本文讲什么&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;1 讲JDK多线程的演进历史 2 讲演进中某些技术点的功能原理及背景，以及解决了什么问题 3 讲针对某些技术点笔者的看法，欢迎有不同看法的人在评论区讨论&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h1&gt;里程碑&lt;/h1&gt;

&lt;p&gt;老规矩，先上个统计表格。其中梳理了历代JDK中关于线程相关的核心概念。在这里，做一个可能不太恰当的比喻，可以将多线程的演进映射到汽车上，多线程的演进分别经历了手动档时代(JDK1.4及以下)，自动档时代（JDK5-JDK18），自动驾驶时代(JDK19及以后)。这个比喻只为了告诉读者JDK5以后可以有更舒服姿势的驾驭多线程，JDK19以后更是突破了单纯的舒服，它给IO密集型服务的性能带来了质的飞跃。&lt;/p&gt;

&lt;table&gt;&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;时代&lt;/th&gt;
&lt;th&gt;版本&lt;/th&gt;
&lt;th&gt;发布时间&lt;/th&gt;
&lt;th&gt;核心概念&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;手动档&lt;/td&gt;
&lt;td&gt;JDK1.0&lt;/td&gt;
&lt;td&gt;1996-01-23&lt;/td&gt;
&lt;td&gt;Thread和Runnable&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;手动档&lt;/td&gt;
&lt;td&gt;JDK1.2&lt;/td&gt;
&lt;td&gt;1998-12-04&lt;/td&gt;
&lt;td&gt;ThreadLocal、Collections&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;自动档&lt;/td&gt;
&lt;td&gt;JDK1.5/5.0&lt;/td&gt;
&lt;td&gt;2004-09-30&lt;/td&gt;
&lt;td&gt;明确Java内存模型、引入并发包&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;自动档&lt;/td&gt;
&lt;td&gt;JDK1.6/6.0&lt;/td&gt;
&lt;td&gt;2006-12-11&lt;/td&gt;
&lt;td&gt;synchronized优化&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;自动档&lt;/td&gt;
&lt;td&gt;JDK1.7/7.0&lt;/td&gt;
&lt;td&gt;2011-07-28&lt;/td&gt;
&lt;td&gt;Fork/Join框架&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;自动档&lt;/td&gt;
&lt;td&gt;JDK1.8/8.0&lt;/td&gt;
&lt;td&gt;2014-03-18&lt;/td&gt;
&lt;td&gt;CompletableFuture、Stream&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;自动档&lt;/td&gt;
&lt;td&gt;JDK1.9/9.0&lt;/td&gt;
&lt;td&gt;2014-09-08&lt;/td&gt;
&lt;td&gt;改善锁争用机制&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;自动档&lt;/td&gt;
&lt;td&gt;JDK10&lt;/td&gt;
&lt;td&gt;2018-03-21&lt;/td&gt;
&lt;td&gt;线程-局部管控&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;自动档&lt;/td&gt;
&lt;td&gt;JDK15&lt;/td&gt;
&lt;td&gt;2020-09-15&lt;/td&gt;
&lt;td&gt;禁用和废弃偏向锁&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;自动驾驶&lt;/td&gt;
&lt;td&gt;JDK19&lt;/td&gt;
&lt;td&gt;2022-09-22&lt;/td&gt;
&lt;td&gt;虚拟线程&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;

&lt;p&gt;&lt;img src=&quot;https://s3.cn-north-1.jdcloud-oss.com/shendengbucket1/2023-02-12-23-15aqQxE11X6ebN9CSQ.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h1&gt;手动档时代&lt;/h1&gt;

&lt;p&gt;JDK1.4及以下笔者称之为多线程“手动档”的时代，也叫原生多线程时代。线程的操作还相对原生，没有线程池可用。研发人员必须手写工具避免频繁创建线程造成资源浪费，手动对共享资源加锁。也正是这个时代酝酿了许多优秀的多线程框架，最有名的被JDK5.0采纳了。&lt;/p&gt;

&lt;h2&gt;JDK 1.0 Thread和Runnable&lt;/h2&gt;

&lt;p&gt;1996年1月的JDK1.0版本，从一开始就确立了Java最基础的线程模型，并且，这样的线程模型再后续的修修补补中，并未发生实质性的变更，可以说是一个具有传承性的良好设计。抢占式和协作式是两种常见的进程/线程调度方式，操作系统非常适合使用抢占式方式来调度它的进程，它给不同的进程分配时间片，对于长期无响应的进程，它有能力剥夺它的资源，甚至将其强行停止。采用协作式的方式，需要进程自觉、主动地释放资源，在这种调度方式下,可能一个执行时间很长的线程使得其他所有需要CPU的线程”饿死”。Java hotspot虚拟机的调度方式为抢占式调用，因此Java语言一开始就采用抢占式线程调度的方式。JDK 1.0中创建线程的方式主要是继承Thread类或实现Runnable接口，通过对象实例的start方法启动线程，需要并行处理的代码放在run方法中，线程间的协作通信采用简单粗暴的stop/resume/suspend这样的方法。&lt;/p&gt;

&lt;p&gt;如何解释stop/resume/suspend的概念呢？就是主线程可以直接调用子线程的终止，暂停，继续方法。如果你小时候用过随身听，上面有三个按键，终止，暂停，继续。想象一下你正在同时听3个随身听，三个随身听就是三个子线程，你就是主线程，你可以随意控制这三个设备的启停。&lt;/p&gt;

&lt;p&gt;这一套机制有个致命的问题，就是容易发生死锁，原因在于当线程A锁定了某个资源，还未释放时，被主线程暂停了(suspend方法并不会释放锁)，此时线程B如果想占有这个资源，只能等待线程A执行继续操作（resume）后释放资源，否则将永远得不到，发生死锁。&lt;/p&gt;

&lt;h2&gt;JDK 1.2&lt;/h2&gt;

&lt;p&gt;粗暴的stop/resume/suspend机制在这个版本被禁止使用了，转而采用wait/notify/sleep这样的多条线程配合行动的方式。值得一提的是，在这个版本中，原子对象AtomicityXXX已经设计好了，主要是解决i++非原子性的问题。ThreadLocal和Collections的加入增加了多线程使用的姿势，因为这两项技术，笔者称它为Java的涡轮增压时代。&lt;/p&gt;

&lt;h3&gt;ThreadLocal&lt;/h3&gt;

&lt;p&gt;ThreadLocal是一种采用无锁的方式实现多线程共享线程不安全对象的方案。它并不能解决“银行账户或库存增加、扣减”这类问题，它擅长将具有“工具”属性的类，通过复本的方式安全的执行“工具”方法。典型的如SimpleDateFormat、库连接等。值得一提的是它的设计非常巧妙，想像一下如果让你设计，一般的简单思路是：在ThreadLocal里维护一个全局线程安全的Map，key为线程，value为共享对象。这样设计有个弊端就是内存泄露问题，因为该Map会随着越来越多的线程加入而无限膨胀，如果要解决内容泄露，必须在线程结束时清理该Map，这又得强化GC能力了，显然投入产出比不合适。于是，ThreadLocal就被设计成Map不由ThreadLocal持有，而是由Thread本身持有。key为ThreadLocal变量，value为值。每个Thread将所用到的ThreadLoacl都放于其中（当然此设计还有其它衍生问题在此不表，感兴趣的同学可以自行搜索）。&lt;/p&gt;

&lt;h3&gt;Collections&lt;/h3&gt;

&lt;p&gt;Collections工具类在这个版本被设计出来了，它包装了一些线程安全集合如SynchronizedList。在那个只有Hashtable、Vector、Stack等线程安全集合的年代，它的出现也是具有时代意义的。Collections工具的基本思想是我帮你将线程不安全的集合包装成线程安全的，这样你原有代码升级改造不必花很多时间，只需要在集合创建的时候用我提供方法初始化集合即可。比较像汽车的涡轮增压技术，在发动机排量不变的情况下，增加发动机的功率和扭矩。Java的涡轮增压时代到来了^_^&lt;/p&gt;

&lt;h1&gt;自动档时代&lt;/h1&gt;

&lt;h2&gt;JDK 5.0&lt;/h2&gt;

&lt;h3&gt;引入并发包&lt;/h3&gt;

&lt;p&gt;Doug Lea，中文名为道格·利。是美国的一个大学教师，大神级的人物，J.U.C就是出自他之手。JDK1.5之前，我们控制程序并发访问同步代码只能使用synchronized，那个时候synchronized的性能还没优化好，性能并不好，控制线程也只能使用Object的wait和notify方法。这个时候Doug Lea给JCP提交了JSR-166的提案，在提交JSR-166之前，Doug Lea已经使用了类似J.U.C包功能的代码已经三年多了，这些代码就是J.U.C的原型。&lt;/p&gt;

&lt;p&gt;J.U.C提供了原子化对象、锁及工具套装、线程池、线程安全容器等几大类工具。研发人员可灵活的使用任意能力搭建自己的产品，进可使用ReentrantLock搭建底层框架，退可直接使用现成的工具或容器进行业务代码编写。站在历史的角度去看，J.U.C在2004年毫无争议可以称为“尖端科技产品”。为Java的推广立下了悍马功劳。Java的自动档时代到来了，就好比自动档的汽车降低司机的门槛一样，J.U.C大大降低了程序员使用多线程的门槛。这是个开创了一个时代的产品。&lt;/p&gt;

&lt;p&gt;当然J.U.C同样存在一结瑕疵：&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;CPU开销大&lt;/strong&gt;：如果自旋CAS长时间地不成功，则会给CPU带来非常大的开销。&lt;/p&gt;

&lt;p&gt;解决方案：在JUC中有些地方就限制了CAS自旋的次数，例如BlockingQueue的SynchronousQueue。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;ABA问题&lt;/strong&gt;：如果一个值原来是A，变成了B，然后又变成了A，在CAS检查时会发现没有改变，但实际它已经改变，这就是ABA问题。大部分情况下ABA问题不会影响程序并发的正确性。&lt;/p&gt;

&lt;p&gt;解决方案：每个变量都加上一个版本号，每次改变时加1，即A —&amp;gt; B —&amp;gt; A，变成1A —&amp;gt; 2B —&amp;gt; 3A。Java提供了AtomicStampedReference来解决。AtomicStampedReference通过包装[E,Integer]的元组来对对象标记版本戳（stamp），从而避免ABA问题。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;只能保证一个共享变量原子操作&lt;/strong&gt;：CAS机制所保证的只是一个变量的原子性操作，而不能保证整个代码块的原子性。&lt;/p&gt;

&lt;p&gt;解决方案：比如需要保证3个变量共同进行原子性的更新，就不得不使用Synchronized了。还可以考虑使用AtomicReference来包装多个变量，通过这种方式来处理多个共享变量的情况。&lt;/p&gt;

&lt;h3&gt;明确Java内存模型&lt;/h3&gt;

&lt;p&gt;此版本的JDK重新明确了Java内存模型，在这之前，常见的内存模型包括连续一致性内存模型和先行发生模型。 对于连续一致性模型来说，程序执行的顺序和代码上显示的顺序是完全一致的。这对于现代多核，并且指令执行优化的CPU来说，是很难保证的。而且，顺序一致性的保证将JVM对代码的运行期优化严重限制住了。&lt;/p&gt;

&lt;p&gt;但是此版本JSR 133规范指定的先行发生（Happens-before）使得执行指令的顺序变得灵活：&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;在同一个线程里面，按照代码执行的顺序（也就是代码语义的顺序），前一个操作先于后面一个操作发生 对一个monitor对象的解锁操作先于后续对同一个monitor对象的锁操作 对volatile字段的写操作先于后面的对此字段的读操作 对线程的start操作（调用线程对象的start()方法）先于这个线程的其他任何操作 一个线程中所有的操作先于其他任何线程在此线程上调用 join()方法 如果A操作优先于B，B操作优先于C，那么A操作优先于C&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;而在内存分配上，将每个线程各自的工作内存从主存中独立出来，更是给JVM大量的空间来优化线程内指令的执行。主存中的变量可以被拷贝到线程的工作内存中去单独执行，在执行结束后，结果可以在某个时间刷回主存： 但是，怎样来保证各个线程之间数据的一致性？JLS（Java Language Specification）给的办法就是，默认情况下，不能保证任意时刻的数据一致性，但是通过对synchronized、volatile和final这几个语义被增强的关键字的使用，可以做到数据一致性。&lt;/p&gt;

&lt;h2&gt;JDK 6.0 synchronized优化&lt;/h2&gt;

&lt;p&gt;作为“共和国长子”synchronized关键字，在5.0版本被ReentrantLock压过了风头。这个版本必须要扳回一局，因此JDK 6.0对锁做了一些优化，比如锁自旋、锁消除、锁合并、轻量级锁、所偏向等。本次优化是对“精细化管理”这个理念的一次诠释。没优化之前被synchronized加锁的对象只有两个状态：无锁，有锁（重量级锁）。优化后锁一共存在4种状态，级别从低到高依次是：无锁、偏向锁、轻量级锁、重量级锁。这几个状态随着竞争的情况逐渐升级，但是不能降级，目的是为了提高获取锁和释放锁的效率（笔者认为其实是太复杂了，JVM研发人员望而却步了）。&lt;/p&gt;

&lt;p&gt;这一次优化让synchronized扬眉吐气，自此再也不允许别人说它的性能比ReentrantLock差了。但好戏还在后头，偏向锁在JDK 15被废弃了（─.─||）。笔者认为synchronized吃亏在了它只是个关键字，JVM负责它底层的动作，到底应用程序加锁的时候什么样的姿势舒服，得靠JVM“猜”。ReentrantLock就不同了，它将这件事直接交给程序员去处理了，你希望公平那就用公平锁，你希望你的不公平，那你就用非公平锁。设计层面算是一种偷懒，但同时也是一种灵活。&lt;/p&gt;

&lt;h2&gt;JDK 7.0 Fork/Join框架&lt;/h2&gt;

&lt;p&gt;Fork/Join的诞生也是一个比较先进的产品，它的核心竞争力在于，支持递归式的任务拆解，同时将各任务结果进行合并。但它是一个既熟悉又陌生的技术，熟悉在于它被应用到各种地方，比如接下来JDK8.0要讲的CompletableFuture和Stream；陌生在于我们似乎很少在业务研发过程中使用到它。&lt;/p&gt;

&lt;p&gt;甚至有人甚至觉得它鸡肋。笔者的观点是，你如果是业务需求相关的研发，它是鸡肋的，因为基本用不到，大批数据量的场景有数仓那套工具，其它场景可以用线程池代替；如果你是中间件框架编写相关的研发，它不鸡肋，兴许会用到。中文互联网上很少有人质疑这项技术，但国外已经有人在讨论，感兴趣的可以直接跳转查阅 &lt;a href=&quot;https://softwareengineering.stackexchange.com/questions/343402/is-the-fork-join-framework-in-java-broken&quot;&gt;Is the Fork-Join framework in Java broken?&lt;/a&gt;&lt;/p&gt;

&lt;h2&gt;JDK 8.0&lt;/h2&gt;

&lt;p&gt;此版本的发布对于Java来说是划时代的，以至于现在全世界在运行的Java程序里此版本占据了一半以上。但多线程相关的更新不如JDK5.0那么具有颠覆性。此版本除了增加了一些原子对象之外 ，最亮眼的便是以下两项更新。&lt;/p&gt;

&lt;h3&gt;CompletableFuture&lt;/h3&gt;

&lt;p&gt;网上关于CompletableFuture相关介绍很多，大多是讲它原理及怎么用。但是笔者始终不明白一个问题：为什么在有那么多线程池工具的情况下，还会有CompletableFuture的出现，它解决了什么痛点？它的核心竞争力到底是什么？相信你如果进行过思考也会提出这个问题，没关系，笔者已经帮你找到了答案。&lt;/p&gt;

&lt;p&gt;结论：CompletableFuture的核心竞争力是&lt;strong&gt;任务编排&lt;/strong&gt;。CompletableFuture继承Future接口特性，可以进行并发执行任务等特性这些能力都是有可替代性的。但它的任务编排能力无可替代，它的核心API中包括了构造任务链，合并任务结果等都是为了任务编排而设计的。所以JDK之所以在此版本引入此框架，主要是解决业务开发中越来越痛的任务编排需求。&lt;/p&gt;

&lt;p&gt;最后多说一句，CompletableFuture底层使用了Fork/Join框架实现。&lt;/p&gt;

&lt;h3&gt;Stream&lt;/h3&gt;

&lt;p&gt;《架构整洁之道》里曾提到有三种编程范式，结构化编程（面向过程编程）、面向对象编程、函数式编程。Stream是函数式编程在Java语言中的一种体现，笔者认为，初级程序员向中级进阶的必经之路就是攻克Stream，初次接触Stream肯定特别不适应，但如果熟悉以后你将打开一个编程方式的新思路。作为研发人员经常混淆三个概念，函数式编程、Stream、Lambda表达式，总以为他们三个说的是一回事。以下是笔者的理解：&lt;/p&gt;

&lt;p&gt;•函数式编程是一种编程思想，各种编程语言中都有该思想的实践&lt;/p&gt;

&lt;p&gt;•Stream是JDK8.0的一个新特性，也可以理解新造了个概念，目的就是迎合函数式编程这种思想，通过Stream的形式可以在集合类上实现函数式编程&lt;/p&gt;

&lt;p&gt;•Lambda 表达式（lambda expression）是一个匿名函数，通过它可以更简洁高效的表达函数式编程&lt;/p&gt;

&lt;p&gt;那么说了这么多，Stream和多线程什么关系？Stream中的相关并行方法底层是使用了Fork/Join框架实现的。《Effective Java》中有一条相关建议“谨慎使用Stream并行”，理由就是因为所有的并行都是在一个通用的Fork/Join池中运行的，一个pipeline运行异常，可能损害其他不相关部分性能。&lt;/p&gt;

&lt;h2&gt;JDK 9.0&lt;/h2&gt;

&lt;h3&gt;改善锁争用机制&lt;/h3&gt;

&lt;p&gt;锁争用限制了许多Java多线程应用性能，新的锁争用机制改善了Java对象监视器的性能，并得到了多种基准测试的验证（如Volano）,这类测试可以估算JVM的极限吞吐量。实际中, 新的锁争用机制在22种不同的基准测试中都得到了出色的成绩。如果新的机制能在Java 9中得到应用的话, 应用程序的性能将会大大提升。简单的解释就是当多个线程发生锁争用时，优化之前：晚到的线程统一采用相同的标准流程进行锁等待。优化后：JVM识别出一些可优化的场景时直接让晚到的线程进行“VIP通道”式的锁抢占。&lt;/p&gt;

&lt;p&gt;详细解释请参考： &lt;a href=&quot;https://ionutbalosin.com/2018/06/contended-locks-explained-a-performance-approach/&quot;&gt;Contended locks explained – a performance approach&lt;/a&gt;&lt;/p&gt;

&lt;h3&gt;响应式流&lt;/h3&gt;

&lt;p&gt;响应式流(Reactive Streams)是一种以非阻塞背压方式处理异步数据流的标准，提供一组最小化的接口，方法和协议来描述必要的操作和实体。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;什么叫非阻塞背压？ 背压是back pressure的缩写，简单讲，生产者给消费者推送数据，当消费者处理不动了，告知生产者，此时生产者降低生产速率，此机制使用阻塞的方式实现最简单，即推送时直接返回压力数据。非阻塞方式实现增加了设计的复杂度，同时提高了性能。 PS:感觉背压这个词翻译的不好，不能望文生义。反压是不是更好^_^&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;为了解决消费者承受巨大的资源压力(pressure)而有可能崩溃的问题，数据流的速度需要被控制，即流量控制(flow control)，以防止快速的数据流不会压垮目标。因此需要反压即背压(back pressure)，生产者和消费者之间需要通过实现一种背压机制来互操作。实现这种背压机制要求是异步非阻塞的，如果是同步阻塞的，消费者在处理数据时生产者必须等待，会产生性能问题。&lt;/p&gt;

&lt;p&gt;响应式流(Reactive Streams)通过定义一组实体，接口和互操作方法，给出了实现非阻塞背压的标准。第三方遵循这个标准来实现具体的解决方案，常见的有Reactor，RxJava，Akka Streams，Ratpack等。&lt;/p&gt;

&lt;h2&gt;JDK 10 线程-局部管控&lt;/h2&gt;

&lt;p&gt;Safepoint及其不足：&lt;/p&gt;

&lt;p&gt;Safepoint是Hotspot JVM中一种让所有应用程序停止的一种机制。JVM为了做一些底层的工作，必须要Stop The World，让应用线程都停下来。但不能粗暴的直接停止，而是会给应用线程发送个指令信号告诉他，你该停下了。此时应用线程执行到一个Safepoint点时就会听从指令并响应。这也是为什么叫Safepoint。之所以加safe，是强调JVM要做一些全局的安全的事情了，所以给这个点加了个safe。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;全局的安全的事情包括以下： 1、垃圾清理暂停 2、代码去优化（Code deoptimization）。 3、flush code cache。 4、类文件重新定义时（Class redefinition，比如热更新 or instrumentation)。 5、偏向锁的取消（Biased lock revocation）。 6、各种debug操作(比如： 死锁检查或者stacktrace dump等)。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;然而，让所有线程都到就近的safepoint停下来本身就需要较长的时间。而且让所有线程都停下来是不是显得太过鲁莽和专断了呢。为此Java10就引入了一种可以不用stop all threads的方式，就是线程-局部管控（Thread Local Handshake）。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;比如以下是不需要stop所有线程就可以搞定的场景： 1、偏向锁撤销。这个事情只需要停止单个线程就可以撤销偏向锁，而不需要停止所有的线程。 2、减少不同类型的可服务性查询的总体VM延迟影响，例如获取具有大量Java线程的VM上的所有线程的stack trace可能是一个缓慢的操作。 3、通过减少对信号（signals）的依赖来执行更安全的stack trace采样。 4、使用所谓的非对称Dekker同步技术，通过与Java线程握手来消除一些内存障碍。 例如，G1和CMS里使用的“条件卡标记码”（conditional card mark code），将不再需要“内存屏障”这个东东。这样的话，G1发送的“写屏障（write barrier）”就可以被优化， 并且那些尝试要规避“内存屏障”的分支也可以被删除了。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2&gt;JDK 15 禁用和废弃偏向锁&lt;/h2&gt;

&lt;p&gt;为什么要废弃偏向锁？偏向锁在过去带来的的性能提升，在现在看来已经不那么明显了。受益于偏向锁的应用程序，往往是使用了早期 Java 集合 API的程序（JDK 1.1），这些 API（Hashtable 和 Vector） 每次访问时都进行同步。JDK 1.2 引入了针对单线程场景的非同步集合（HashMap 和 ArrayList），JDK 1.5 针对多线程场景推出了性能更高的并发数据结构。这意味着如果代码更新为使用较新的类，由于不必要同步而受益于偏向锁的应用程序，可能会看到很大的性能提高。此外，围绕线程池队列和工作线程构建的应用程序，性能通常在禁用偏向锁的情况下变得更好。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;以下以使用了Hashtable 和 Vector的API实现： &lt;em&gt;java.lang.Classloader&lt;/em&gt; &lt;em&gt;uses Vector&lt;/em&gt; &lt;em&gt;java.util.Properties&lt;/em&gt; &lt;em&gt;extends Hashtable&lt;/em&gt; &lt;em&gt;java.security.Provider&lt;/em&gt; &lt;em&gt;extends Properties&lt;/em&gt; &lt;em&gt;java.net.URL&lt;/em&gt; &lt;em&gt;uses Hashtable&lt;/em&gt; &lt;em&gt;java.net.URConnection&lt;/em&gt; &lt;em&gt;uses Hashtable&lt;/em&gt; &lt;em&gt;java.util.ZipOutputStream&lt;/em&gt; &lt;em&gt;uses Vector&lt;/em&gt; &lt;em&gt;javax.management.timer.TimerMBean&lt;/em&gt; &lt;em&gt;has Vector on the interface&lt;/em&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h1&gt;自动驾驶时代&lt;/h1&gt;

&lt;p&gt;虚拟线程使Java进入了自动驾驶时代。很多语言都有类似于“虚拟线程”的技术，比如Go、C#、Erlang、Lua等，他们称之为“协程”。这次java没有新增任何关键字，甚至没有新增新的概念，虚拟线程比起goroutine，协程，要好理解得多，看这名字就大概知道它在做啥了。&lt;/p&gt;

&lt;h2&gt;JDK 19 虚拟线程&lt;/h2&gt;

&lt;p&gt;传统Java中的线程模型与操作系统是 1:1 对应的，创建和切换线程代价很大，受限于操作系统，只能创建有限的数量。当并发量很大时，无法为每个请求都创建一个线程。使用线程池可以缓解问题，线程池减少了线程创建的消耗，但是也无法提升线程的数量。假如并发量是2000，线程池只有1000个线程，那么同一时刻只能处理1000个请求，还有1000个请求是无法处理的，可以拒绝掉，也可以使其等待，直到有线程让出。&lt;/p&gt;

&lt;p&gt;虚拟线程的之前的方案是采用异步风格。已经有很多框架实现了异步风格的并发编程（如Spring5的Reactor），通过线程共享来实现更高的可用性。原理是通过线程共享减少了线程的切换，降低了消耗，同时也避免阻塞，只在程序执行时使用线程，当程序需要等待时则不占用线程。异步风格确实有不少提升，但是也有缺点。大部分异步框架都使用链式写法，将程序分为很多个步骤，每个步骤可能会在不同的线程中执行。你不能再使用熟悉的 ThreadLocal 等并发编程相关的API，否则可能会有错误。编程风格上也有很大的变化，比传统模式的编程风格要复杂很多，学习成本高，可能还要改造项目中的很多已有模块使其适配异步模式。&lt;/p&gt;

&lt;p&gt;虚拟线程的实现原理和一些异步框架差不多，也是线程共享，当然也就不需要池化。在使用时你可以认为虚拟线程是无限充裕的，你想创建多少就创建多少，不必担心会有问题。不仅如此，虚拟线程支持 debug，并且能被 Java 相关的监控工具所支持，这很重要。虚拟线程会使你程序的内存占用大幅降低，所有IO密集型应用，比如Web Servers，都可以在同等硬件条件下，大幅提升IO的吞吐量。原来1G内存，同时可以host 1000个访问，使用虚拟线程后，按照官方的说法，能轻松处理100万的并发，具体到业务场景上能否支撑还要看压力测试，但是我们打个折扣，10万应该能够轻松实现，而你不需要为此付出任何的代价，可能连代码都不用改。因为虚拟线程可以使得你保持传统的编程风格，也就是一个请求一个线程的模式，像使用线程一样使用虚拟线程，程序只需要做很少的改动。虚拟线程也没有引入新的语法，可以说学习和迁移成本极低。&lt;/p&gt;

&lt;p&gt;值得一提的是虚拟线程底层依然使用了Fork/Join框架。&lt;/p&gt;
&lt;/div&gt;
  &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>04a7de60ee051bff3d963f5a8ddc35a5</guid>
<title>程序员 “火柴棍式” 的烧脑面试题</title>
<link>https://toutiao.io/k/4a28i1d</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content js_underline_content             autoTypeSetting24psection&amp;#10;            &quot; id=&quot;js_content&quot;&gt;&lt;section&gt;&lt;mp-common-profile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mpprofile&quot; data-weui-theme=&quot;light&quot; data-id=&quot;MzI0MzA2OTc4MQ==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/Bfv9smoHwth5nBzNr9kZshQ25yhLz08JicGiaeuWY5k8z6JHS4KYxQ2zp2lU9mjSC6PsvBlib658u3CnrSQsuCzAg/0?wx_fmt=png&quot; data-nickname=&quot;码农UP2U&quot; data-alias=&quot;&quot; data-signature=&quot;努力成为一个初级程序员！&quot; data-from=&quot;0&quot; data-is_biz_ban=&quot;0&quot;/&gt;&lt;strong&gt;&lt;span/&gt;&lt;/strong&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;早期文章&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;0x01 - 从耗子叔博客看到的题目&lt;/strong&gt;&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;“火柴棍式” 的面试是在看耗子叔的博客时看到的，引入耗子叔的内容如下：&lt;/span&gt;&lt;/p&gt;&lt;blockquote class=&quot;js_blockquote_wrap&quot; data-type=&quot;2&quot; data-url=&quot;&quot; data-author-name=&quot;&quot; data-content-utf8-length=&quot;213&quot; data-source-title=&quot;https://coolshell.cn/articles/3961.html&quot;&gt;&lt;section class=&quot;js_blockquote_digest&quot;&gt;&lt;p&gt;有时候，有些面试题是很是无厘头，这不，又有一个，还记得小时候玩的的“火柴棍游戏”吗，就是移动一根火柴棍改变一个图或字的游戏。程序面试居然也可以这么玩，看看下面这个火柴棍式的程序面试题吧。 &lt;/p&gt;&lt;p&gt;下面是一个C程序，其想要输出20个减号，不过，粗心的程序员把代码写错了，你需要把下面的代码修改正确，不过，你只能增加或是修改其中的一个字符，请你给出三种答案。&lt;/p&gt;&lt;p&gt;&lt;br/&gt;int n = 20; &lt;/p&gt;&lt;p&gt;for(int i = 0; i &amp;lt; n; i--) {&lt;/p&gt;&lt;p&gt;    printf(&quot;-&quot;);&lt;/p&gt;&lt;p&gt;}&lt;/p&gt;&lt;/section&gt;&lt;section class=&quot;blockquote_info js_blockquote_source&quot; data-json=&quot;%7B%22type%22%3A%22out%22%2C%22source%22%3A%22url%22%2C%22digest%22%3A%22%3Cp%3E%E6%9C%89%E6%97%B6%E5%80%99%EF%BC%8C%E6%9C%89%E4%BA%9B%E9%9D%A2%E8%AF%95%E9%A2%98%E6%98%AF%E5%BE%88%E6%98%AF%E6%97%A0%E5%8E%98%E5%A4%B4%EF%BC%8C%E8%BF%99%E4%B8%8D%EF%BC%8C%E5%8F%88%E6%9C%89%E4%B8%80%E4%B8%AA%EF%BC%8C%E8%BF%98%E8%AE%B0%E5%BE%97%E5%B0%8F%E6%97%B6%E5%80%99%E7%8E%A9%E7%9A%84%E7%9A%84%E2%80%9C%E7%81%AB%E6%9F%B4%E6%A3%8D%E6%B8%B8%E6%88%8F%E2%80%9D%E5%90%97%EF%BC%8C%E5%B0%B1%E6%98%AF%E7%A7%BB%E5%8A%A8%E4%B8%80%E6%A0%B9%E7%81%AB%E6%9F%B4%E6%A3%8D%E6%94%B9%E5%8F%98%E4%B8%80%E4%B8%AA%E5%9B%BE%E6%88%96%E5%AD%97%E7%9A%84%E6%B8%B8%E6%88%8F%E3%80%82%E7%A8%8B%E5%BA%8F%E9%9D%A2%E8%AF%95%E5%B1%85%E7%84%B6%E4%B9%9F%E5%8F%AF%E4%BB%A5%E8%BF%99%E4%B9%88%E7%8E%A9%EF%BC%8C%E7%9C%8B%E7%9C%8B%E4%B8%8B%E9%9D%A2%E8%BF%99%E4%B8%AA%E7%81%AB%E6%9F%B4%E6%A3%8D%E5%BC%8F%E7%9A%84%E7%A8%8B%E5%BA%8F%E9%9D%A2%E8%AF%95%E9%A2%98%E5%90%A7%E3%80%82%5Cn%5Cn%E4%B8%8B%E9%9D%A2%E6%98%AF%E4%B8%80%E4%B8%AAC%E7%A8%8B%E5%BA%8F%EF%BC%8C%E5%85%B6%E6%83%B3%E8%A6%81%E8%BE%93%E5%87%BA20%E4%B8%AA%E5%87%8F%E5%8F%B7%EF%BC%8C%E4%B8%8D%E8%BF%87%EF%BC%8C%E7%B2%97%E5%BF%83%E7%9A%84%E7%A8%8B%E5%BA%8F%E5%91%98%E6%8A%8A%E4%BB%A3%E7%A0%81%E5%86%99%E9%94%99%E4%BA%86%EF%BC%8C%E4%BD%A0%E9%9C%80%E8%A6%81%E6%8A%8A%E4%B8%8B%E9%9D%A2%E7%9A%84%E4%BB%A3%E7%A0%81%E4%BF%AE%E6%94%B9%E6%AD%A3%E7%A1%AE%EF%BC%8C%E4%B8%8D%E8%BF%87%EF%BC%8C%E4%BD%A0%E5%8F%AA%E8%83%BD%E5%A2%9E%E5%8A%A0%E6%88%96%E6%98%AF%E4%BF%AE%E6%94%B9%E5%85%B6%E4%B8%AD%E7%9A%84%E4%B8%80%E4%B8%AA%E5%AD%97%E7%AC%A6%EF%BC%8C%E8%AF%B7%E4%BD%A0%E7%BB%99%E5%87%BA%E4%B8%89%E7%A7%8D%E7%AD%94%E6%A1%88%E3%80%82%5Cn%5Cnint%26nbsp%3Bn%26nbsp%3B%3D%26nbsp%3B20%3B%5Cnfor(int%26nbsp%3Bi%26nbsp%3B%3D%26nbsp%3B0%3B%26nbsp%3Bi%26nbsp%3B%26lt%3B%26nbsp%3Bn%3B%26nbsp%3Bi--)%7B%5Cn%26nbsp%3B%26nbsp%3B%26nbsp%3B%26nbsp%3Bprintf(%26quot%3B-%26quot%3B)%3B%5Cn%7D%3C%2Fp%3E%22%2C%22digestLen%22%3A234%2C%22text%22%3A%22%22%2C%22article%22%3A%7B%7D%2C%22hasReportOverSize%22%3Afalse%2C%22editorReportData%22%3A%5B%7B%22id%22%3A%22122333%22%2C%22key%22%3A%2276%22%2C%22len%22%3A1%7D%5D%2C%22from%22%3A%22https%3A%2F%2Fcoolshell.cn%2Farticles%2F3961.html%22%7D&quot;&gt;&lt;span class=&quot;blockquote_other&quot;&gt;https://coolshell.cn/articles/3961.html&lt;/span&gt;&lt;/section&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;span&gt;开始以为是一些比较以前见过的一些变态题目，比如考察编译选项、数组越界之类的题目，结果没想到竟然是“脑筋急转弯”。在看答案之前，真的是花了点时间，才想出一种方法。看完答案以后恍然大悟，竟然可以这样，哈哈！晒一下耗子叔给出的答案。&lt;/span&gt;&lt;/p&gt;&lt;blockquote class=&quot;js_blockquote_wrap&quot; data-type=&quot;2&quot; data-url=&quot;&quot; data-author-name=&quot;&quot; data-content-utf8-length=&quot;112&quot; data-source-title=&quot;https://coolshell.cn/articles/3961.html&quot;&gt;&lt;section class=&quot;js_blockquote_digest&quot;&gt;&lt;p&gt;//第一种解法：在for循环中给n加一个负号 &lt;/p&gt;&lt;p&gt;for(int i = 0; i &amp;lt; -n; i--) &lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;//第二种解法：把 n 初始化成 -20 &lt;/p&gt;&lt;p&gt;int n = -20; &lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;//第三种解法：把for循环中的 i 初始化成40 &lt;/p&gt;&lt;p&gt;for(int i = 40; i &amp;lt; n; i--)&lt;/p&gt;&lt;/section&gt;&lt;section class=&quot;blockquote_info js_blockquote_source&quot; data-json=&quot;%7B%22type%22%3A%22out%22%2C%22source%22%3A%22url%22%2C%22digest%22%3A%22%3Cp%3E%2F%2F%E7%AC%AC%E4%B8%80%E7%A7%8D%E8%A7%A3%E6%B3%95%EF%BC%9A%E5%9C%A8for%E5%BE%AA%E7%8E%AF%E4%B8%AD%E7%BB%99n%E5%8A%A0%E4%B8%80%E4%B8%AA%E8%B4%9F%E5%8F%B7%5Cnfor(int%26nbsp%3Bi%26nbsp%3B%3D%26nbsp%3B0%3B%26nbsp%3Bi%26nbsp%3B%26lt%3B%26nbsp%3B-n%3B%26nbsp%3Bi--)%5Cn%2F%2F%E7%AC%AC%E4%BA%8C%E7%A7%8D%E8%A7%A3%E6%B3%95%EF%BC%9A%E6%8A%8A%26nbsp%3Bn%26nbsp%3B%E5%88%9D%E5%A7%8B%E5%8C%96%E6%88%90%26nbsp%3B-20%5Cnint%26nbsp%3Bn%26nbsp%3B%3D%26nbsp%3B-20%3B%5Cn%2F%2F%E7%AC%AC%E4%B8%89%E7%A7%8D%E8%A7%A3%E6%B3%95%EF%BC%9A%E6%8A%8Afor%E5%BE%AA%E7%8E%AF%E4%B8%AD%E7%9A%84%26nbsp%3Bi%26nbsp%3B%E5%88%9D%E5%A7%8B%E5%8C%96%E6%88%9040%5Cnfor(int%26nbsp%3Bi%26nbsp%3B%3D%26nbsp%3B40%3B%26nbsp%3Bi%26nbsp%3B%26lt%3B%26nbsp%3Bn%3B%26nbsp%3Bi--)%3C%2Fp%3E%22%2C%22digestLen%22%3A138%2C%22text%22%3A%22%22%2C%22article%22%3A%7B%7D%2C%22hasReportOverSize%22%3Afalse%2C%22editorReportData%22%3A%5B%7B%22id%22%3A%22122333%22%2C%22key%22%3A%2276%22%2C%22len%22%3A1%7D%5D%2C%22from%22%3A%22https%3A%2F%2Fcoolshell.cn%2Farticles%2F3961.html%22%7D&quot;&gt;&lt;span class=&quot;blockquote_other&quot;&gt;https://coolshell.cn/articles/3961.html&lt;/span&gt;&lt;/section&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;0x02 - 对这种题目的看法&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;于是我把这个题目发到一个微信群里，给群友们看看，但是直接得到下面的答复。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;1.1199510403916768&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/Bfv9smoHwtjkfIlWvF3iauBI4jdX3mndaBSXxYLbkgpXNy3Ym8ED2GgmOYnUa4DbD8POfZJv3p4zUNQPNxvvOHQ/640?wx_fmt=jpeg&quot; data-type=&quot;png&quot; data-w=&quot;817&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;发出去之后，唯一一个接话的竟然这样说。其他的群友对这个问题直接无视。不知道他们为什么对这种搞怪的“脑筋急转弯”没兴趣！&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;感觉看到这样的答复也不奇怪吧，毕竟没啥用，第一没人这么写，第二也没有实际的意义。但是这竟然是面试题。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;想起以前学习 C 语言的时候，一个老师说过这么四句话，这几句话我印象深刻（尤其是第四句话，希望大家先收藏再观看，……&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1&quot; data-src=&quot;https://res.wx.qq.com/t/wx_fed/we-emoji/res/v1.3.10/assets/Expression/Expression_45@2x.png&quot; data-w=&quot;20&quot;/&gt;）。&lt;/span&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;熟练掌握 C 语言各种语法&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;深入了解编译器对 C 语言编译的处理&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;写出不受编译器限制的 C 代码&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;其他牛角尖问题一概无视&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;span&gt;上面的四句话，都不是原话，即使印象深刻也不知道到底是不是这四句话，但是大概就是这么个意思。从第四句话来看，这算不算牛角尖问题呢？不知道啊！&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;以前见过有的公司面试，就面试类似 ++/-- ，这种自增的题，有的学校考试也考这种题吧。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;比如 i ++ + ++ i 这样的。反正这样的题我是不会，而且更重要的是不同的编译器竟然结果不同。对这种运行结果依赖编译器的情况，我们称之为“编译器相关”。就是你别让我猜，你自己在编译器上跑吧！其实，C 语言标准里对于有些语法给出的说明就是，实现方自行处理，就是没有给出具体标准。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;0x03 - 剩下问题的答案&lt;/strong&gt;&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;其实上面虽然这么说，但是我很无聊的看了看，类似“脑筋急转弯”题目的变形题，这些变形方式也是在耗子叔的博客上看的，题目如下：&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;blockquote class=&quot;js_blockquote_wrap&quot; data-type=&quot;2&quot; data-url=&quot;&quot; data-author-name=&quot;&quot; data-content-utf8-length=&quot;73&quot; data-source-title=&quot;https://coolshell.cn/articles/3961.html&quot;&gt;&lt;section class=&quot;js_blockquote_digest&quot;&gt;&lt;p&gt;其它相关的变种题如下： &lt;/p&gt;&lt;p&gt;通过修改、增加一个字符，让其输出21个减号 &lt;/p&gt;&lt;p&gt;通过修改、增加一个字符，让其只输出1个减号 &lt;/p&gt;&lt;p&gt;通过修改、增加一个字符，让其不输出减号&lt;/p&gt;&lt;/section&gt;&lt;section class=&quot;blockquote_info js_blockquote_source&quot; data-json=&quot;%7B%22type%22%3A%22out%22%2C%22source%22%3A%22url%22%2C%22digest%22%3A%22%3Cp%3E%E5%85%B6%E5%AE%83%E7%9B%B8%E5%85%B3%E7%9A%84%E5%8F%98%E7%A7%8D%E9%A2%98%E5%A6%82%E4%B8%8B%EF%BC%9A%5Cn%5Cn%E9%80%9A%E8%BF%87%E4%BF%AE%E6%94%B9%E3%80%81%E5%A2%9E%E5%8A%A0%E4%B8%80%E4%B8%AA%E5%AD%97%E7%AC%A6%EF%BC%8C%E8%AE%A9%E5%85%B6%E8%BE%93%E5%87%BA21%E4%B8%AA%E5%87%8F%E5%8F%B7%5Cn%E9%80%9A%E8%BF%87%E4%BF%AE%E6%94%B9%E3%80%81%E5%A2%9E%E5%8A%A0%E4%B8%80%E4%B8%AA%E5%AD%97%E7%AC%A6%EF%BC%8C%E8%AE%A9%E5%85%B6%E5%8F%AA%E8%BE%93%E5%87%BA1%E4%B8%AA%E5%87%8F%E5%8F%B7%5Cn%E9%80%9A%E8%BF%87%E4%BF%AE%E6%94%B9%E3%80%81%E5%A2%9E%E5%8A%A0%E4%B8%80%E4%B8%AA%E5%AD%97%E7%AC%A6%EF%BC%8C%E8%AE%A9%E5%85%B6%E4%B8%8D%E8%BE%93%E5%87%BA%E5%87%8F%E5%8F%B7%3C%2Fp%3E%22%2C%22digestLen%22%3A76%2C%22text%22%3A%22%22%2C%22article%22%3A%7B%7D%2C%22hasReportOverSize%22%3Afalse%2C%22editorReportData%22%3A%5B%7B%22id%22%3A%22122333%22%2C%22key%22%3A%2276%22%2C%22len%22%3A1%7D%5D%2C%22from%22%3A%22https%3A%2F%2Fcoolshell.cn%2Farticles%2F3961.html%22%7D&quot;&gt;&lt;span class=&quot;blockquote_other&quot;&gt;https://coolshell.cn/articles/3961.html&lt;/span&gt;&lt;/section&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;span&gt;花了点时间试了试，还是搞出来了。不过时间也花得不短，超过十五分钟了。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;这里给一下我的答案：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;1.添加一个字符输出 21 个减号，代码如下：&lt;/span&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;cpp&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;int&lt;/span&gt; n = &lt;span class=&quot;code-snippet__number&quot;&gt;20&lt;/span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;code-snippet__keyword&quot;&gt;int&lt;/span&gt; i = &lt;span class=&quot;code-snippet__number&quot;&gt;0&lt;/span&gt;; ~i &amp;lt; n; i --) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__built_in&quot;&gt;printf&lt;/span&gt;(&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;-&quot;&lt;/span&gt;);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;这里，对变量 i 进行了取反操作。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;2.添加一个字符输出 1 个减号，代码如下：&lt;/span&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;cpp&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;int&lt;/span&gt; n = &lt;span class=&quot;code-snippet__number&quot;&gt;20&lt;/span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;code-snippet__keyword&quot;&gt;int&lt;/span&gt; i = &lt;span class=&quot;code-snippet__number&quot;&gt;0&lt;/span&gt;; i &amp;lt; &amp;amp;n; i --) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__built_in&quot;&gt;printf&lt;/span&gt;(&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;-&quot;&lt;/span&gt;);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;这里，对 n 进行了取地址运算。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;3.修改一个字符，让其不输出减号，代码如下：&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;cpp&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;int&lt;/span&gt; n = &lt;span class=&quot;code-snippet__number&quot;&gt;-20&lt;/span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;code-snippet__keyword&quot;&gt;int&lt;/span&gt; i = &lt;span class=&quot;code-snippet__number&quot;&gt;0&lt;/span&gt;; i &amp;lt; n; i --) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__built_in&quot;&gt;printf&lt;/span&gt;(&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;-&quot;&lt;/span&gt;);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;这里，将变量 n 初始化为了 -20。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;上面的问题中，不输出减号的方式还是&lt;/span&gt;&lt;span&gt;很容易找到多种方法的，&lt;/span&gt;&lt;span&gt;但是输出 1 &lt;/span&gt;&lt;span&gt;个减号和输出&lt;/span&gt;&lt;span&gt; 21 个减号，要找到多种方法&lt;/span&gt;&lt;span&gt;感觉比较复杂。而且，&lt;/span&gt;不同的语言解决起来方法不太一样，就比如输出 1 个减号，在 C 语言中我使用的是取地址运算，而其他语言就不行了，比如 Java、PHP 和 Python 就没有这个运算符了吧。我用 PHP 实现了下只输出一个 1 个减号，代码如下：&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;bash&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__variable&quot;&gt;$n&lt;/span&gt; = 2&amp;gt;0;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;code-snippet__variable&quot;&gt;$i&lt;/span&gt; = 0; &lt;span class=&quot;code-snippet__variable&quot;&gt;$i&lt;/span&gt; &amp;lt; &lt;span class=&quot;code-snippet__variable&quot;&gt;$n&lt;/span&gt;; &lt;span class=&quot;code-snippet__variable&quot;&gt;$i&lt;/span&gt; --) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__built_in&quot;&gt;print&lt;/span&gt; &lt;span class=&quot;code-snippet__string&quot;&gt;&#x27;-&#x27;&lt;/span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;上面的代码中，我将 20 改成了 2&amp;gt;0 ，添加了一个符号。我真是觉得自己小时候的脑筋急转弯没白玩啊。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;0x04 - 最后……&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;中规中矩的写代码挺好的，本来就很难写出优雅的代码，要是每天就想着写这种代码，也真的就是没谁了。好好写代码，面试、工作不是参加代码混乱大赛！！&lt;img data-src=&quot;https://res.wx.qq.com/t/wx_fed/we-emoji/res/v1.3.10/assets/Expression/Expression_14@2x.png&quot; data-ratio=&quot;1&quot; data-w=&quot;20&quot;/&gt;&lt;img data-src=&quot;https://res.wx.qq.com/t/wx_fed/we-emoji/res/v1.3.10/assets/Expression/Expression_14@2x.png&quot; data-ratio=&quot;1&quot; data-w=&quot;20&quot;/&gt;&lt;img data-src=&quot;https://res.wx.qq.com/t/wx_fed/we-emoji/res/v1.3.10/assets/Expression/Expression_14@2x.png&quot; data-ratio=&quot;1&quot; data-w=&quot;20&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.0712962962962963&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Bfv9smoHwthBDooApBDUM9yqM6BWHMOaJyrXzMxqibI7B90xNgZswWSVSatF56vMAicAA56UmJkc2rQlDUARycYQ/640?wx_fmt=png&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;mpcps class=&quot;js_editor_new_cps&quot; data-templateid=&quot;list&quot; data-traceid=&quot;2af7abf0-032e-41b0-a0b2-f1bbb5c92a20&quot; data-goodssouce=&quot;1&quot; data-pid=&quot;101_10060770213143&quot; data-appuin=&quot;3243069781&quot; data-buffer=&quot;{&amp;quot;category_id&amp;quot;:10,&amp;quot;pid&amp;quot;:&amp;quot;101_10060770213143&amp;quot;,&amp;quot;biz_uin&amp;quot;:&amp;quot;3243069781&amp;quot;,&amp;quot;trace_id&amp;quot;:&amp;quot;2af7abf0-032e-41b0-a0b2-f1bbb5c92a20&amp;quot;,&amp;quot;sku_id&amp;quot;:&amp;quot;101_10060770213143&amp;quot;,&amp;quot;source_id&amp;quot;:2,&amp;quot;source_name&amp;quot;:&amp;quot;京东&amp;quot;,&amp;quot;audit_state&amp;quot;:1,&amp;quot;main_img&amp;quot;:&amp;quot;https://pcm-img.zhls.qq.com/productcenter-6fa174af--1018824-7975090560325406147/23105240921122022/b7eff0a3125954d219c32e31f2511988.jpg&amp;quot;,&amp;quot;product_name&amp;quot;:&amp;quot;逆向分析实战冀云人民邮电出版社9787115590701 计算机与互联网书籍&amp;quot;,&amp;quot;current_price&amp;quot;:7390,&amp;quot;first_category_id&amp;quot;:&amp;quot;10&amp;quot;,&amp;quot;product_label_name_list&amp;quot;:[],&amp;quot;select_tag_name_list&amp;quot;:[],&amp;quot;templateId&amp;quot;:&amp;quot;card&amp;quot;,&amp;quot;appuin&amp;quot;:&amp;quot;3243069781&amp;quot;,&amp;quot;isNewCpsKOL&amp;quot;:1}&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;公众号内回复 【mongo】 下载 SpringBoot 整合操作 MongoDB 的文档。&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;公众号内回复 【&lt;/strong&gt;&lt;strong&gt;cisp知识整理&lt;/strong&gt;&lt;strong&gt;】 下载 CISP 读书笔记。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;公众号内&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;回复【java开发手册】获取《Java开发手册》黄山版。&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;mp-common-profile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mpprofile&quot; data-weui-theme=&quot;light&quot; data-id=&quot;MzI0MzA2OTc4MQ==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/Bfv9smoHwth5nBzNr9kZshQ25yhLz08JicGiaeuWY5k8z6JHS4KYxQ2zp2lU9mjSC6PsvBlib658u3CnrSQsuCzAg/0?wx_fmt=png&quot; data-nickname=&quot;码农UP2U&quot; data-alias=&quot;&quot; data-signature=&quot;努力成为一个初级程序员！&quot; data-from=&quot;0&quot; data-is_biz_ban=&quot;0&quot;/&gt;&lt;/section&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.36484375&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Bfv9smoHwth5nBzNr9kZshQ25yhLz08JHWsQdz8yVn3MVh22hia7NFoPyNJz4ZI7XUnMa9xM50TJRqPkWf7BRibQ/640?wx_fmt=jpeg&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; data-type=&quot;jpeg&quot; data-w=&quot;1280&quot;/&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;mp-style-type data-value=&quot;3&quot;/&gt;&lt;/p&gt;&lt;/div&gt;

          
        &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>df157de938993c651cf64cd3a9f17ce4</guid>
<title>golang 面试题：能说说 uintptr 和 unsafe.Pointer 的区别吗？</title>
<link>https://toutiao.io/k/5ywnrru</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;span class=&quot;RichText ztext CopyrightRichText-richText css-1g0fqss&quot; options=&quot;[object Object]&quot; itemprop=&quot;text&quot;&gt;&lt;p data-first-child=&quot;&quot; data-pid=&quot;Ampg_362&quot;&gt;uintptr和unsafe.Pointer都是Go语言中处理底层指针的类型。&lt;/p&gt;&lt;p class=&quot;ztext-empty-paragraph&quot;&gt;&lt;/p&gt;&lt;p data-pid=&quot;9FHtXjOR&quot;&gt;uintptr是一个整数类型，用于存储指针类型的数值，它的大小和指针大小相同，通常是32位或64位。uintptr可以存储指向任何类型的指针，但它不能直接解引用，也不能用于进行指针运算。&lt;/p&gt;&lt;p class=&quot;ztext-empty-paragraph&quot;&gt;&lt;/p&gt;&lt;p data-pid=&quot;8iEASxsQ&quot;&gt;unsafe.Pointer是一个指针类型，用于存储任意类型的指针。unsafe.Pointer可以转换为任何指针类型，包括uintptr，这意味着它可以用于进行指针运算。但是，unsafe.Pointer不能直接解引用，因为它不知道指向的类型，需要使用类型转换将其转换为指向正确类型的指针。&lt;/p&gt;&lt;p class=&quot;ztext-empty-paragraph&quot;&gt;&lt;/p&gt;&lt;p data-pid=&quot;dx0fr_1d&quot;&gt;总之，uintptr是一个无类型的整数类型，不能直接解引用或进行指针运算，只能用于存储指针类型的数值。而unsafe.Pointer是一个指针类型，可以转换为任何指针类型，包括uintptr，可以进行指针运算，但需要小心使用，因为它可以绕过Go语言的类型安全检查。&lt;/p&gt;&lt;/span&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>dfa7fa2c8edd2db190df8f64363cdc51</guid>
<title>面试官：手写一个必然死锁的例子？一顿操作猛如虎</title>
<link>https://toutiao.io/k/sg37106</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content js_underline_content             autoTypeSetting24psection&amp;#10;            &quot; id=&quot;js_content&quot;&gt;&lt;pre&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-paragraph-type=&quot;ignored&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-paragraph-type=&quot;ignored&quot;&gt;&lt;section&gt;&lt;span&gt;点击上方 &lt;/span&gt;&lt;span&gt;&lt;strong mpa-from-tpl=&quot;t&quot;&gt;&lt;span&gt;java那些事 &lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;，选择 &lt;/span&gt;&lt;span&gt;&lt;strong mpa-from-tpl=&quot;t&quot;&gt;&lt;span&gt;星标 &lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;公众号&lt;/span&gt;&lt;span/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;h4&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;pre&gt;&lt;pre&gt;&lt;section&gt;&lt;span&gt;重磅资讯，干货，第一时间送达&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;---&lt;/span&gt;&lt;/section&gt;&lt;/pre&gt;&lt;/pre&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/h4&gt;&lt;/section&gt;&lt;/pre&gt;&lt;pre&gt;&lt;p&gt;&lt;span&gt;&lt;span/&gt;&lt;/span&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;前言&lt;/h2&gt;&lt;p&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;只对死锁代码感兴趣的可以直接跳到第三小节 必然死锁示例，如果对死锁还不太了解的，我们可以一起来讨论以下几个议题&lt;/p&gt;&lt;/pre&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;什么是死锁？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;死锁有什么危害和特点？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;代码实现一个必然死锁的示例&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;分析死锁的过程&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;1.什么是死锁？&lt;/h2&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;关键词：并发场景，多线程&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;首先我们需要知道，死锁一定发生在并发场景中。我们为了保证线程安全，有时会给程序使用各种能保证并发安全的工具，尤其是锁，但是如果在使用过程中处理不得当，就有可能会导致发生死锁的情况。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;关键词：互不相让&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;死锁是一种状态，当两个（或多个）线程（或进程）相互持有对方所需要的资源，却又都不主动释放自己手中所持有的资源，导致大家都获取不到自己想要的资源，所有相关的线程（或进程）都无法继续往下执行，在未改变这种状态之前都不能向前推进，我们就把这种状态称为死锁状态，认为它们发生了死锁。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;简而言之，死锁就是两个或多个线程（或进程）被无限期地阻塞，相互等待对方手中资源的一种状态。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;两个线程死锁的情况&lt;/strong&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-fileid=&quot;502675203&quot; data-ratio=&quot;0.7577937649880095&quot; data-type=&quot;png&quot; data-w=&quot;417&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/A0bYOQcma0MEWhZCbGRb0bGlRMXxCd5DwuXOUYZU28iaOwk5d9Bgsr8aBTpzzSBUnZBH40F8xWuAYQEwlBa1GPA/640?wx_fmt=png&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如图所示，线程1 已经持有了 锁1，同时 线程2 也已经持有了锁2，然后 线程1 尝试获取 锁2，但是 线程2 并没有释放 锁2，所以 线程1 处于阻塞状态，同理可知，图中的 线程2 获取 锁1也会被阻塞。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这样一来，线程1 和 线程2 就发生了死锁，因为它们都相互持有对方想要的资源，却又不释放自己手中的资源，形成相互等待，而且会一直等待下去。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;2.死锁的影响和危害&lt;/h2&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;2.1 死锁的影响&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzA3MjMwMzg2Nw==&amp;amp;mid=2247498404&amp;amp;idx=2&amp;amp;sn=d501b955843386d69b41aef6684d5a1a&amp;amp;chksm=9f22ef30a8556626207b2710e8b57761d725ea054871cad589e945d5359623600c923e9378af&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;死锁的影响在不同系统中是不一样的，影响的大小一部分取决于当前这个系统或者环境对死锁的处理能力。2.1.1 数据库中例如，在数据库系统软件的设计中，考虑了监测死锁以及从死锁中恢复的情况。在执行一个事务的时候可能需要获取多把锁，并一直持有这些锁直到事务完成。在某个事务中持有的锁可能在其他事务中也需要，因此在两个事务之间有可能发生死锁的情况，一旦发生了死锁，如果没有外部干涉，那么两个事务就会永远的等待下去。但数据库系统不会放任这种情况发生，当数据库检测到这一组事务发生了死锁时，根据策略的不同，可能会选择放弃某一个事务，被放弃的事务就会释放掉它所持有的锁，从而使其他的事务继续顺利进行。此时程序可以重新执行被强行终止的事务，而这个事务现在就可以顺利执行了，因为所有跟它竞争资源的事务都已经在刚才执行完毕，并且释放资源了。2.1.2 JVM 中在 JVM 中，对于死锁的处理能力就不如数据库那么强大了。如果在 JVM 中发生了死锁，JVM 并不会自动进行处理，所以一旦死锁发生，就会陷入无穷的等待。&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot; wah-hotarea=&quot;click&quot; hasload=&quot;1&quot;&gt;&lt;span&gt;死锁的影响在不同系统中是不一样的，影响的大小一部分取决于当前这个系统或者环境对死锁的处理能力。&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzA3MjMwMzg2Nw==&amp;amp;mid=2247498404&amp;amp;idx=2&amp;amp;sn=d501b955843386d69b41aef6684d5a1a&amp;amp;chksm=9f22ef30a8556626207b2710e8b57761d725ea054871cad589e945d5359623600c923e9378af&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;死锁的影响在不同系统中是不一样的，影响的大小一部分取决于当前这个系统或者环境对死锁的处理能力。2.1.1 数据库中例如，在数据库系统软件的设计中，考虑了监测死锁以及从死锁中恢复的情况。在执行一个事务的时候可能需要获取多把锁，并一直持有这些锁直到事务完成。在某个事务中持有的锁可能在其他事务中也需要，因此在两个事务之间有可能发生死锁的情况，一旦发生了死锁，如果没有外部干涉，那么两个事务就会永远的等待下去。但数据库系统不会放任这种情况发生，当数据库检测到这一组事务发生了死锁时，根据策略的不同，可能会选择放弃某一个事务，被放弃的事务就会释放掉它所持有的锁，从而使其他的事务继续顺利进行。此时程序可以重新执行被强行终止的事务，而这个事务现在就可以顺利执行了，因为所有跟它竞争资源的事务都已经在刚才执行完毕，并且释放资源了。2.1.2 JVM 中在 JVM 中，对于死锁的处理能力就不如数据库那么强大了。如果在 JVM 中发生了死锁，JVM 并不会自动进行处理，所以一旦死锁发生，就会陷入无穷的等待。&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot; wah-hotarea=&quot;click&quot; hasload=&quot;1&quot;&gt;&lt;span&gt;例如，在数据库系统软件的设计中，考虑了监测死锁以及从死锁中恢复的情况。在执行一个事务的时候可能需要获取多把锁，并一直持有这些锁直到事务完成。在某个事务中持有的锁可能在其他事务中也需要，因此在两个事务之间有可能发生死锁的情况，一旦发生了死锁，如果没有外部干涉，那么两个事务就会永远的等待下去。&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzA3MjMwMzg2Nw==&amp;amp;mid=2247498404&amp;amp;idx=2&amp;amp;sn=d501b955843386d69b41aef6684d5a1a&amp;amp;chksm=9f22ef30a8556626207b2710e8b57761d725ea054871cad589e945d5359623600c923e9378af&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;死锁的影响在不同系统中是不一样的，影响的大小一部分取决于当前这个系统或者环境对死锁的处理能力。2.1.1 数据库中例如，在数据库系统软件的设计中，考虑了监测死锁以及从死锁中恢复的情况。在执行一个事务的时候可能需要获取多把锁，并一直持有这些锁直到事务完成。在某个事务中持有的锁可能在其他事务中也需要，因此在两个事务之间有可能发生死锁的情况，一旦发生了死锁，如果没有外部干涉，那么两个事务就会永远的等待下去。但数据库系统不会放任这种情况发生，当数据库检测到这一组事务发生了死锁时，根据策略的不同，可能会选择放弃某一个事务，被放弃的事务就会释放掉它所持有的锁，从而使其他的事务继续顺利进行。此时程序可以重新执行被强行终止的事务，而这个事务现在就可以顺利执行了，因为所有跟它竞争资源的事务都已经在刚才执行完毕，并且释放资源了。2.1.2 JVM 中在 JVM 中，对于死锁的处理能力就不如数据库那么强大了。如果在 JVM 中发生了死锁，JVM 并不会自动进行处理，所以一旦死锁发生，就会陷入无穷的等待。&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot; wah-hotarea=&quot;click&quot; hasload=&quot;1&quot;&gt;&lt;span&gt;但数据库系统不会放任这种情况发生，当数据库检测到这一组事务发生了死锁时，根据策略的不同，可能会选择放弃某一个事务，被放弃的事务就会释放掉它所持有的锁，从而使其他的事务继续顺利进行。&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzA3MjMwMzg2Nw==&amp;amp;mid=2247498404&amp;amp;idx=2&amp;amp;sn=d501b955843386d69b41aef6684d5a1a&amp;amp;chksm=9f22ef30a8556626207b2710e8b57761d725ea054871cad589e945d5359623600c923e9378af&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;死锁的影响在不同系统中是不一样的，影响的大小一部分取决于当前这个系统或者环境对死锁的处理能力。2.1.1 数据库中例如，在数据库系统软件的设计中，考虑了监测死锁以及从死锁中恢复的情况。在执行一个事务的时候可能需要获取多把锁，并一直持有这些锁直到事务完成。在某个事务中持有的锁可能在其他事务中也需要，因此在两个事务之间有可能发生死锁的情况，一旦发生了死锁，如果没有外部干涉，那么两个事务就会永远的等待下去。但数据库系统不会放任这种情况发生，当数据库检测到这一组事务发生了死锁时，根据策略的不同，可能会选择放弃某一个事务，被放弃的事务就会释放掉它所持有的锁，从而使其他的事务继续顺利进行。此时程序可以重新执行被强行终止的事务，而这个事务现在就可以顺利执行了，因为所有跟它竞争资源的事务都已经在刚才执行完毕，并且释放资源了。2.1.2 JVM 中在 JVM 中，对于死锁的处理能力就不如数据库那么强大了。如果在 JVM 中发生了死锁，JVM 并不会自动进行处理，所以一旦死锁发生，就会陷入无穷的等待。&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot; wah-hotarea=&quot;click&quot; hasload=&quot;1&quot;&gt;&lt;span&gt;此时程序可以重新执行被强行终止的事务，而这个事务现在就可以顺利执行了，因为所有跟它竞争资源的事务都已经在刚才执行完毕，并且释放资源了。&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzA3MjMwMzg2Nw==&amp;amp;mid=2247498404&amp;amp;idx=2&amp;amp;sn=d501b955843386d69b41aef6684d5a1a&amp;amp;chksm=9f22ef30a8556626207b2710e8b57761d725ea054871cad589e945d5359623600c923e9378af&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;死锁的影响在不同系统中是不一样的，影响的大小一部分取决于当前这个系统或者环境对死锁的处理能力。2.1.1 数据库中例如，在数据库系统软件的设计中，考虑了监测死锁以及从死锁中恢复的情况。在执行一个事务的时候可能需要获取多把锁，并一直持有这些锁直到事务完成。在某个事务中持有的锁可能在其他事务中也需要，因此在两个事务之间有可能发生死锁的情况，一旦发生了死锁，如果没有外部干涉，那么两个事务就会永远的等待下去。但数据库系统不会放任这种情况发生，当数据库检测到这一组事务发生了死锁时，根据策略的不同，可能会选择放弃某一个事务，被放弃的事务就会释放掉它所持有的锁，从而使其他的事务继续顺利进行。此时程序可以重新执行被强行终止的事务，而这个事务现在就可以顺利执行了，因为所有跟它竞争资源的事务都已经在刚才执行完毕，并且释放资源了。2.1.2 JVM 中在 JVM 中，对于死锁的处理能力就不如数据库那么强大了。如果在 JVM 中发生了死锁，JVM 并不会自动进行处理，所以一旦死锁发生，就会陷入无穷的等待。&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot; wah-hotarea=&quot;click&quot; hasload=&quot;1&quot;&gt;&lt;span&gt;在 JVM 中，对于死锁的处理能力就不如数据库那么强大了。如果在 JVM 中发生了死锁，JVM 并不会自动进行处理，所以一旦死锁发生，就会陷入无穷的等待。&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;2.2 死锁的危害以及特点&lt;/h3&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;关键词：概率性事件&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzA3MjMwMzg2Nw==&amp;amp;mid=2247498404&amp;amp;idx=2&amp;amp;sn=d501b955843386d69b41aef6684d5a1a&amp;amp;chksm=9f22ef30a8556626207b2710e8b57761d725ea054871cad589e945d5359623600c923e9378af&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;死锁的问题和其他的并发安全问题一样，是概率性的，也就是说，即使存在发生死锁的可能性，也并不是 100% 会发生的。如果每个锁的持有时间很短，那么发生冲突的概率就很低，所以死锁发生的概率也很低。但是在线上系统里，可能每天有几千万次的“获取锁”、“释放锁”操作，在巨量的次数面前，整个系统发生问题的几率就会被放大，只要有某几次操作是有风险的，就可能会导致死锁的发生。也正是因为死锁“不一定会发生”的特点，导致提前找出死锁成为了一个难题。压力测试虽然可以检测出一部分可能发生死锁的情况，但是并不足以完全模拟真实、长期运行的场景，因此没有办法把所有潜在可能发生死锁的代码都找出来。关键词：危害大，发生几率不高一旦发生了死锁，根据发生死锁的线程的职责不同，就可能会造成 子系统崩溃、性能降低 甚至 整个系统崩溃 等各种不良后果。而且死锁往往发生在高并发、高负载的情况下，因为可能会直接影响到很多用户，造成一系列的问题。以上就是死锁发生几率不高但是危害大的特点。&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot; wah-hotarea=&quot;click&quot; hasload=&quot;1&quot;&gt;&lt;span&gt;死锁的问题和其他的并发安全问题一样，是概率性的，也就是说，即使存在发生死锁的可能性，也并不是 100% 会发生的。如果每个锁的持有时间很短，那么发生冲突的概率就很低，所以死锁发生的概率也很低。但是在线上系统里，可能每天有几千万次的“获取锁”、“释放锁”操作，在巨量的次数面前，整个系统发生问题的几率就会被放大，只要有某几次操作是有风险的，就可能会导致死锁的发生。&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzA3MjMwMzg2Nw==&amp;amp;mid=2247498404&amp;amp;idx=2&amp;amp;sn=d501b955843386d69b41aef6684d5a1a&amp;amp;chksm=9f22ef30a8556626207b2710e8b57761d725ea054871cad589e945d5359623600c923e9378af&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;死锁的问题和其他的并发安全问题一样，是概率性的，也就是说，即使存在发生死锁的可能性，也并不是 100% 会发生的。如果每个锁的持有时间很短，那么发生冲突的概率就很低，所以死锁发生的概率也很低。但是在线上系统里，可能每天有几千万次的“获取锁”、“释放锁”操作，在巨量的次数面前，整个系统发生问题的几率就会被放大，只要有某几次操作是有风险的，就可能会导致死锁的发生。也正是因为死锁“不一定会发生”的特点，导致提前找出死锁成为了一个难题。压力测试虽然可以检测出一部分可能发生死锁的情况，但是并不足以完全模拟真实、长期运行的场景，因此没有办法把所有潜在可能发生死锁的代码都找出来。关键词：危害大，发生几率不高一旦发生了死锁，根据发生死锁的线程的职责不同，就可能会造成 子系统崩溃、性能降低 甚至 整个系统崩溃 等各种不良后果。而且死锁往往发生在高并发、高负载的情况下，因为可能会直接影响到很多用户，造成一系列的问题。以上就是死锁发生几率不高但是危害大的特点。&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot; wah-hotarea=&quot;click&quot; hasload=&quot;1&quot;&gt;&lt;span&gt;也正是因为死锁“不一定会发生”的特点，导致提前找出死锁成为了一个难题。压力测试虽然可以检测出一部分可能发生死锁的情况，但是并不足以完全模拟真实、长期运行的场景，因此没有办法把所有潜在可能发生死锁的代码都找出来。&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzA3MjMwMzg2Nw==&amp;amp;mid=2247498404&amp;amp;idx=2&amp;amp;sn=d501b955843386d69b41aef6684d5a1a&amp;amp;chksm=9f22ef30a8556626207b2710e8b57761d725ea054871cad589e945d5359623600c923e9378af&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;死锁的问题和其他的并发安全问题一样，是概率性的，也就是说，即使存在发生死锁的可能性，也并不是 100% 会发生的。如果每个锁的持有时间很短，那么发生冲突的概率就很低，所以死锁发生的概率也很低。但是在线上系统里，可能每天有几千万次的“获取锁”、“释放锁”操作，在巨量的次数面前，整个系统发生问题的几率就会被放大，只要有某几次操作是有风险的，就可能会导致死锁的发生。也正是因为死锁“不一定会发生”的特点，导致提前找出死锁成为了一个难题。压力测试虽然可以检测出一部分可能发生死锁的情况，但是并不足以完全模拟真实、长期运行的场景，因此没有办法把所有潜在可能发生死锁的代码都找出来。关键词：危害大，发生几率不高一旦发生了死锁，根据发生死锁的线程的职责不同，就可能会造成 子系统崩溃、性能降低 甚至 整个系统崩溃 等各种不良后果。而且死锁往往发生在高并发、高负载的情况下，因为可能会直接影响到很多用户，造成一系列的问题。以上就是死锁发生几率不高但是危害大的特点。&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot; wah-hotarea=&quot;click&quot; hasload=&quot;1&quot;&gt;&lt;span&gt;关键词：危害大，发生几率不高&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzA3MjMwMzg2Nw==&amp;amp;mid=2247498404&amp;amp;idx=2&amp;amp;sn=d501b955843386d69b41aef6684d5a1a&amp;amp;chksm=9f22ef30a8556626207b2710e8b57761d725ea054871cad589e945d5359623600c923e9378af&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;死锁的问题和其他的并发安全问题一样，是概率性的，也就是说，即使存在发生死锁的可能性，也并不是 100% 会发生的。如果每个锁的持有时间很短，那么发生冲突的概率就很低，所以死锁发生的概率也很低。但是在线上系统里，可能每天有几千万次的“获取锁”、“释放锁”操作，在巨量的次数面前，整个系统发生问题的几率就会被放大，只要有某几次操作是有风险的，就可能会导致死锁的发生。也正是因为死锁“不一定会发生”的特点，导致提前找出死锁成为了一个难题。压力测试虽然可以检测出一部分可能发生死锁的情况，但是并不足以完全模拟真实、长期运行的场景，因此没有办法把所有潜在可能发生死锁的代码都找出来。关键词：危害大，发生几率不高一旦发生了死锁，根据发生死锁的线程的职责不同，就可能会造成 子系统崩溃、性能降低 甚至 整个系统崩溃 等各种不良后果。而且死锁往往发生在高并发、高负载的情况下，因为可能会直接影响到很多用户，造成一系列的问题。以上就是死锁发生几率不高但是危害大的特点。&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot; wah-hotarea=&quot;click&quot; hasload=&quot;1&quot;&gt;&lt;span&gt;一旦发生了死锁，根据发生死锁的线程的职责不同，就可能会造成 子系统崩溃、性能降低 甚至 整个系统崩溃 等各种不良后果。而且死锁往往发生在高并发、高负载的情况下，因为可能会直接影响到很多用户，造成一系列的问题。以上就是死锁发生几率不高但是危害大的特点。&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;3.必然死锁示例&lt;/h2&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;public class MustDeadLockDemo {&lt;br/&gt;&lt;br/&gt;    public static void main(String[] args) {&lt;br/&gt;        Object lock1 = new Object();&lt;br/&gt;        Object lock2 = new Object();&lt;br/&gt;        new Thread(new DeadLockTask(lock1, lock2, &lt;span&gt;true&lt;/span&gt;), &lt;span&gt;&quot;线程1&quot;&lt;/span&gt;).start();&lt;br/&gt;        new Thread(new DeadLockTask(lock1, lock2, &lt;span&gt;false&lt;/span&gt;), &lt;span&gt;&quot;线程2&quot;&lt;/span&gt;).start();&lt;br/&gt;&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    static class DeadLockTask implements Runnable {&lt;br/&gt;&lt;br/&gt;        private boolean flag;&lt;br/&gt;        private Object lock1;&lt;br/&gt;        private Object lock2;&lt;br/&gt;&lt;br/&gt;        public DeadLockTask(Object lock1, Object lock2, boolean flag) {&lt;br/&gt;            this.lock1 = lock1;&lt;br/&gt;            this.lock2 = lock2;&lt;br/&gt;            this.flag = flag;&lt;br/&gt;        }&lt;br/&gt;&lt;br/&gt;        @Override&lt;br/&gt;        public void &lt;span&gt;run&lt;/span&gt;() {&lt;br/&gt;            &lt;span&gt;if&lt;/span&gt; (flag) {&lt;br/&gt;                synchronized (lock1) {&lt;br/&gt;                    System.out.println(Thread.currentThread().getName() + &lt;span&gt;&quot;-&amp;gt;拿到锁1&quot;&lt;/span&gt;);&lt;br/&gt;                    try {&lt;br/&gt;                        Thread.sleep(1000);&lt;br/&gt;                    } catch (InterruptedException e) {&lt;br/&gt;                        e.printStackTrace();&lt;br/&gt;                    }&lt;br/&gt;                    System.out.println(Thread.currentThread().getName() + &lt;span&gt;&quot;-&amp;gt;等待锁2释放...&quot;&lt;/span&gt;);&lt;br/&gt;                    synchronized (lock2) {&lt;br/&gt;                        System.out.println(Thread.currentThread().getName() + &lt;span&gt;&quot;-&amp;gt;拿到锁2&quot;&lt;/span&gt;);&lt;br/&gt;                    }&lt;br/&gt;                }&lt;br/&gt;            }&lt;br/&gt;            &lt;span&gt;if&lt;/span&gt; (!flag) {&lt;br/&gt;                synchronized (lock2) {&lt;br/&gt;                    System.out.println(Thread.currentThread().getName() + &lt;span&gt;&quot;-&amp;gt;拿到锁2&quot;&lt;/span&gt;);&lt;br/&gt;                    try {&lt;br/&gt;                        Thread.sleep(1000);&lt;br/&gt;                    } catch (InterruptedException e) {&lt;br/&gt;                        e.printStackTrace();&lt;br/&gt;                    }&lt;br/&gt;                    System.out.println(Thread.currentThread().getName() + &lt;span&gt;&quot;-&amp;gt;等待锁1释放...&quot;&lt;/span&gt;);&lt;br/&gt;                    synchronized (lock1) {&lt;br/&gt;                        System.out.println(Thread.currentThread().getName() + &lt;span&gt;&quot;-&amp;gt;拿到锁1&quot;&lt;/span&gt;);&lt;br/&gt;                    }&lt;br/&gt;                }&lt;br/&gt;            }&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;}&lt;span&gt;点击&lt;/span&gt;&lt;a class=&quot;weapp_text_link&quot; data-miniprogram-appid=&quot;wxe57fd7ba3fb24ae8&quot; data-miniprogram-path=&quot;pages/index/list&quot; data-miniprogram-nickname=&quot;Java面试库&quot; data-miniprogram-type=&quot;text&quot; data-miniprogram-servicetype=&quot;&quot; wah-hotarea=&quot;click&quot; href=&quot;&quot;&gt;Java面试库&lt;/a&gt;&lt;span&gt;小程序在线刷题。&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;执行结果：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-fileid=&quot;502675205&quot; data-ratio=&quot;0.2858990944372574&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/A0bYOQcma0MEWhZCbGRb0bGlRMXxCd5DictbfLibFdlW5MIdicNZZIWRP7CvRSY8L1LEKpbdnP3uuh1ZFdQZlrLTw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;773&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可以看到程序一直处于阻塞状态。&lt;/p&gt;&lt;p&gt;&lt;span&gt;关注Java核心技术，推送更多 Java 干货！&lt;/span&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-fileid=&quot;502675202&quot; data-ratio=&quot;1&quot; data-type=&quot;png&quot; data-w=&quot;64&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/b96CibCt70iaajvl7fD4ZCicMcjhXMp1v6UibM134tIsO1j5yqHyNhh9arj090oAL7zGhRJRq6cFqFOlDZMleLl4pw/640?wx_fmt=png&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;4.过程分析&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其实上面的代码示例发生死锁的过程就是第一小节中 两个线程发生死锁 的情况，这里我们把图拿过来，方便分析。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-fileid=&quot;502675206&quot; data-ratio=&quot;0.7577937649880095&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/A0bYOQcma0MEWhZCbGRb0bGlRMXxCd5DwuXOUYZU28iaOwk5d9Bgsr8aBTpzzSBUnZBH40F8xWuAYQEwlBa1GPA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;417&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;本文使用 IDEA 进行调试，将断点打在 33 行，run方法的第一行，选择 Thread 模式。&lt;span&gt;最新面试题整理好了，点击&lt;a class=&quot;weapp_text_link&quot; data-miniprogram-appid=&quot;wxe57fd7ba3fb24ae8&quot; data-miniprogram-path=&quot;pages/index/list&quot; data-miniprogram-nickname=&quot;Java面试库&quot; data-miniprogram-type=&quot;text&quot; data-miniprogram-servicetype=&quot;&quot; wah-hotarea=&quot;click&quot; href=&quot;&quot;&gt;Java面试库&lt;/a&gt;小程序在线刷题。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;注意：调试过程，因为有人为的等待时间，所以并不会发生死锁，这里只是演示线程执行的顺序和状态。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-fileid=&quot;502675204&quot; data-ratio=&quot;0.48212226066897346&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/A0bYOQcma0MEWhZCbGRb0bGlRMXxCd5DVjjGr0XLkO9VibSgRL2Rr9abaMMs8lTDlLDAwX81GFL82420pwTnIDw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;867&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;第一步，线程1进入，flag = true，进入第一个 synchronized 同步块，拿到 lock1(锁1)&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-fileid=&quot;502675207&quot; data-ratio=&quot;0.5935185185185186&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/A0bYOQcma0MEWhZCbGRb0bGlRMXxCd5D9zNhkrAQWicYMdic81rfJDp4bXUxbdic8VTIeZ7L367J8o1ianUXz4jY7A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;第二步，直接点击 Resume Program（F9），进入线程2，此时 flag = false，进入第二个 synchronized 同步块&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-fileid=&quot;502675208&quot; data-ratio=&quot;0.4287037037037037&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/A0bYOQcma0MEWhZCbGRb0bGlRMXxCd5DKVMONxmIvgKYmW4L4eOkDEmrYiabtGibQT8hvp8vy2ibk5XFDyD4Y53vw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当然如果 Thread.sleep 的时间够长，或者操作速度够快的话，也能发生死锁。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;5.总结&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzA3MjMwMzg2Nw==&amp;amp;mid=2247498404&amp;amp;idx=2&amp;amp;sn=d501b955843386d69b41aef6684d5a1a&amp;amp;chksm=9f22ef30a8556626207b2710e8b57761d725ea054871cad589e945d5359623600c923e9378af&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;本章我们讨论了什么是死锁，以及死锁的影响和危害，演示了一个必然死锁的例子，然后使用 IDEA 工具调试了两个线程发生死锁的步骤。在 JVM 中如果发生死锁，可能会导致程序部分甚至全部无法继续向下执行的情况，所以死锁在 JVM 中所带来的危害和影响是比较大的，我们需要尽量避免。最后如果在面试中碰到这一题，希望大家都能顺利通过。&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot; wah-hotarea=&quot;click&quot; hasload=&quot;1&quot;&gt;&lt;span&gt;本章我们讨论了什么是死锁，以及死锁的影响和危害，演示了一个必然死锁的例子，然后使用 IDEA 工具调试了两个线程发生死锁的步骤。&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzA3MjMwMzg2Nw==&amp;amp;mid=2247498404&amp;amp;idx=2&amp;amp;sn=d501b955843386d69b41aef6684d5a1a&amp;amp;chksm=9f22ef30a8556626207b2710e8b57761d725ea054871cad589e945d5359623600c923e9378af&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;本章我们讨论了什么是死锁，以及死锁的影响和危害，演示了一个必然死锁的例子，然后使用 IDEA 工具调试了两个线程发生死锁的步骤。在 JVM 中如果发生死锁，可能会导致程序部分甚至全部无法继续向下执行的情况，所以死锁在 JVM 中所带来的危害和影响是比较大的，我们需要尽量避免。最后如果在面试中碰到这一题，希望大家都能顺利通过。&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot; wah-hotarea=&quot;click&quot; hasload=&quot;1&quot;&gt;&lt;span&gt;在 JVM 中如果发生死锁，可能会导致程序部分甚至全部无法继续向下执行的情况，所以死锁在 JVM 中所带来的危害和影响是比较大的，我们需要尽量避免。&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;最后如果在面试中碰到这一题，希望大家都能顺利通过。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;更多精彩内容，&lt;strong&gt;关注我们&lt;/strong&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;▼▼&lt;/strong&gt;&lt;/p&gt;&lt;section&gt;&lt;mp-common-profile data-weui-theme=&quot;light&quot; class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-id=&quot;MjM5MTM0NjQ2MQ==&quot; data-pluginname=&quot;mpprofile&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/jNmCBexQlC5YGTbia3dRd6YFXWAlPsJK3gZQap6oK8Vk7BLiaBbsvq3BwicyEKwJiaIfeAYXzucAvXP00PKQKVLzJQ/0?wx_fmt=png&quot; data-nickname=&quot;java那些事&quot; data-alias=&quot;csh624366188&quot; data-signature=&quot;分享java开发中常用的技术，分享软件开发中各种新技术的应用方法。每天推送java技术相关或者互联网相关文章。关注“java那些事”，让自己做一个潮流的java技术人！《java程序员由笨鸟到菜鸟》系列文章火热更新中。&quot; data-from=&quot;0&quot; data-is_biz_ban=&quot;0&quot;/&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;如果看到这里，说明你喜欢这篇文章，&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;标星（置顶）&lt;/span&gt;&lt;span&gt;本公众号可以第一时间接受到博文推送。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;  &lt;/span&gt;&lt;strong&gt;&lt;span&gt; “分享、点赞&lt;/span&gt;&lt;span&gt;、&lt;/span&gt;&lt;span&gt;在看” 支持一波&lt;/span&gt;&lt;/strong&gt;&lt;span&gt; &lt;img data-type=&quot;png&quot; data-ratio=&quot;1&quot; data-w=&quot;64&quot; data-fileid=&quot;502675186&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/lolOWBY1tkwzw3lDgVHOcuEv7IVq2gCXN5rPlfruYGicNRAP8M5fbZZk7VHjtM8Yv1XVjLFxXnrCQKicmser8veQ/640?wx_fmt=png&quot;/&gt; &lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;mp-style-type data-value=&quot;3&quot;/&gt;&lt;/p&gt;&lt;/div&gt;

          
        &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>72bd49a31d0bd14272e9553e0fe87132</guid>
<title>Android 获取手机已安装的应用列表（适配）</title>
<link>https://toutiao.io/k/j1tdkig</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content js_underline_content             autoTypeSetting24psection&amp;#10;            &quot; id=&quot;js_content&quot;&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;权限&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;/section&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;xml&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__tag&quot;&gt;&amp;lt;&lt;span class=&quot;code-snippet__name&quot;&gt;uses-permission&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__attr&quot;&gt;android:name&lt;/span&gt;=&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;android.permission.QUERY_ALL_PACKAGES&quot;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__attr&quot;&gt;tools:ignore&lt;/span&gt;=&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;QueryAllPackagesPermission&quot;&lt;/span&gt; /&amp;gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;加上权限&lt;span&gt;才能获取到所有的应用&lt;/span&gt;&lt;/p&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;获取代码&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;/section&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;cpp&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt; &lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;static&lt;/span&gt; boolean &lt;span class=&quot;code-snippet__title&quot;&gt;hasApplication&lt;/span&gt;&lt;span class=&quot;code-snippet__params&quot;&gt;(Context context, String packageName)&lt;/span&gt; &lt;/span&gt;{&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        PackageManager packageManager = context.getPackageManager();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__keyword&quot;&gt;if&lt;/span&gt; (android.os.Build.VERSION.SDK_INT &amp;gt;= android.os.Build.VERSION_CODES.M) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            Intent intent = &lt;span class=&quot;code-snippet__keyword&quot;&gt;new&lt;/span&gt; Intent(Intent.ACTION_MAIN).addCategory(Intent.CATEGORY_LAUNCHER);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            List&amp;lt;ResolveInfo&amp;gt; &lt;span class=&quot;code-snippet__built_in&quot;&gt;list&lt;/span&gt; = packageManager.queryIntentActivities(intent, PackageManager.MATCH_ALL);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            &lt;span class=&quot;code-snippet__keyword&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;code-snippet__keyword&quot;&gt;int&lt;/span&gt; i = &lt;span class=&quot;code-snippet__number&quot;&gt;0&lt;/span&gt;,count=&lt;span class=&quot;code-snippet__built_in&quot;&gt;list&lt;/span&gt;.size(); i &amp;lt;count ; i++) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                &lt;span class=&quot;code-snippet__keyword&quot;&gt;if&lt;/span&gt;(&lt;span class=&quot;code-snippet__built_in&quot;&gt;list&lt;/span&gt;.get(i).activityInfo.applicationInfo.packageName.equalsIgnoreCase(packageName)) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                    &lt;span class=&quot;code-snippet__keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;code-snippet__literal&quot;&gt;true&lt;/span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        }&lt;span class=&quot;code-snippet__keyword&quot;&gt;else&lt;/span&gt;{&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            List&amp;lt;PackageInfo&amp;gt; listPackageInfo = packageManager.getInstalledPackages(&lt;span class=&quot;code-snippet__number&quot;&gt;0&lt;/span&gt;);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            &lt;span class=&quot;code-snippet__keyword&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;code-snippet__keyword&quot;&gt;int&lt;/span&gt; i = &lt;span class=&quot;code-snippet__number&quot;&gt;0&lt;/span&gt;; i &amp;lt; listPackageInfo.size(); i++) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                &lt;span class=&quot;code-snippet__keyword&quot;&gt;if&lt;/span&gt; (listPackageInfo.get(i).packageName.equalsIgnoreCase(packageName)) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                    &lt;span class=&quot;code-snippet__keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;code-snippet__literal&quot;&gt;true&lt;/span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;code-snippet__literal&quot;&gt;false&lt;/span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;低版本的手机 可以用else里边的方法 也可以用&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;css&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__selector-tag&quot;&gt;Intent&lt;/span&gt; &lt;span class=&quot;code-snippet__selector-tag&quot;&gt;intent&lt;/span&gt; = &lt;span class=&quot;code-snippet__selector-tag&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;code-snippet__selector-tag&quot;&gt;Intent&lt;/span&gt;(&lt;span class=&quot;code-snippet__selector-tag&quot;&gt;Intent&lt;/span&gt;&lt;span class=&quot;code-snippet__selector-class&quot;&gt;.ACTION_MAIN&lt;/span&gt;)&lt;span class=&quot;code-snippet__selector-class&quot;&gt;.addCategory&lt;/span&gt;(&lt;span class=&quot;code-snippet__selector-tag&quot;&gt;Intent&lt;/span&gt;&lt;span class=&quot;code-snippet__selector-class&quot;&gt;.CATEGORY_LAUNCHER&lt;/span&gt;);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__selector-tag&quot;&gt;packageManager&lt;/span&gt;&lt;span class=&quot;code-snippet__selector-class&quot;&gt;.queryIntentActivities&lt;/span&gt;(&lt;span class=&quot;code-snippet__selector-tag&quot;&gt;intent&lt;/span&gt;,0)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;Intent的action 是：Intent.ACTION_MAIN 这个不要传错。&lt;/span&gt;&lt;/p&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;通过包名获取对应应用的启动页的全类名&lt;/span&gt;&lt;/h2&gt;&lt;/section&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;kotlin&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__comment&quot;&gt;     * &lt;span class=&quot;code-snippet__doctag&quot;&gt;@param&lt;/span&gt; packageName&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__comment&quot;&gt;     * &lt;span class=&quot;code-snippet__doctag&quot;&gt;@return&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__comment&quot;&gt;     */&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    String getAppStartClass(Context context, String packageName) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        PackageManager packageManager = context.getPackageManager();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__keyword&quot;&gt;try&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            Intent intent = new Intent(Intent.ACTION_MAIN).addCategory(Intent.CATEGORY_LAUNCHER);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            List&amp;lt;ResolveInfo&amp;gt; list = packageManager.queryIntentActivities(intent, PackageManager.GET_ACTIVITIES);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            &lt;span class=&quot;code-snippet__keyword&quot;&gt;for&lt;/span&gt; (int i = &lt;span class=&quot;code-snippet__number&quot;&gt;0&lt;/span&gt;,count=list.size(); i &amp;lt;count ; i++) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                &lt;span class=&quot;code-snippet__keyword&quot;&gt;if&lt;/span&gt; (TextUtils.equals(list.&lt;span class=&quot;code-snippet__keyword&quot;&gt;get&lt;/span&gt;(i).activityInfo.packageName, packageName)) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                    &lt;span class=&quot;code-snippet__keyword&quot;&gt;return&lt;/span&gt; list.&lt;span class=&quot;code-snippet__keyword&quot;&gt;get&lt;/span&gt;(i).activityInfo.name;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        } &lt;span class=&quot;code-snippet__keyword&quot;&gt;catch&lt;/span&gt; (Exception e) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            e.printStackTrace();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        } &lt;span class=&quot;code-snippet__keyword&quot;&gt;finally&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            &lt;span class=&quot;code-snippet__keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;&quot;&lt;/span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;code&gt;水平有限，如有问题欢迎评论区留言指正。&lt;/code&gt;&lt;/p&gt;&lt;p&gt;&lt;code&gt;如果在高版本上有问题的话建议将&lt;/code&gt;&lt;span&gt;targetSdkVersion设置成26试试。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;code&gt;&lt;br/&gt;&lt;/code&gt;&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span aria-hidden=&quot;true&quot;/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;span&gt;关注我获取更多知识或者投稿&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg wxw-img&quot; data-ratio=&quot;1&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/yyLvy204xW9Uibw4qQxibOBKL1DicLX10o3w57n09uKDowd4ZDjRIgSMUn9cqY6ia77Ys3VfZjG8LUviacGSr0DFIvw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;258&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg wxw-img&quot; data-ratio=&quot;0.20555555555555555&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/yyLvy204xW9Uibw4qQxibOBKL1DicLX10o3gibpbVwAGtDUV15FZianjGs1whAZ2gg71IV6J7zQpQhtQRcSyHrGJbxg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;180&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;mp-style-type data-value=&quot;3&quot;/&gt;&lt;/p&gt;&lt;/div&gt;

          
        &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>