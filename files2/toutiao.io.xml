<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>37193f0834ac8e3e7b447da5c444c7e2</guid>
<title>Linux内存管理机制</title>
<link>https://toutiao.io/k/5e8o3ht</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content                           autoTypeSetting24psection&amp;#10;                          &quot; id=&quot;js_content&quot;&gt;&lt;p data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;span&gt;&lt;strong&gt;从硬件看内存&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;从内核看内存&lt;/span&gt;&lt;/strong&gt;&lt;span/&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;为什么区分内核空间和用户空间&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;什么是用户态和内核态&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;如何从用户空间进入内核空间&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;进程上下文和中断上下文&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/ul&gt;&lt;hr/&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;&lt;strong/&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;一、从硬件看内存&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-backh=&quot;302&quot; data-backw=&quot;578&quot; data-ratio=&quot;0.5221169036334913&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/Z33JZWhn1uP2Sd2jw3Bkt6LIY5nJjjzZc5MGLp11ic40Ta1oq9UeI0egJYaDsFVjyDCm1lAGrOzsMhqHSVtA3JA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1266&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;1、纸带上&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;计算机读取一张纸带就运行一条指令，从外部存储介质上直接运行指令的方法很低效&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;2、内存存储器&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;程序存在内存存储器上，首先要加载程序到内存，然后执行。开启了存储程序的新大陆，也开启了操作系统的新大陆。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;3、动态分区法&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;操作系统将内存分成一段一段的，只要有程序来就有合适的内存大小就优先安排上，若内存大小不够时易产生程序的换入换出过程（内存地址交换），同时还产生内存碎片。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;缺陷：进程地址空间保护问题、内存使用率底、程序运行地址重定位问题&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;4、分段机制&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;增加了虚拟内存。将程序所需内存空间的虚拟地址映射到某个物理地址空间。它解决了地址空间保护问题。进程运行时看到的地址是虚拟地址，需要CPU提供的地址映射方法才能找到实际的物理地址。因此每个进程的虚拟内存空间都是相互隔离的。需要操作系统维护映射关系。&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;分段机制将程序分成若干段，一个进程可以分成（代码段、数据段、堆段）等。有点类似动态分区法。它们在物理地址可以是不连续的，这样可以解决内存碎片问题，但是会产生外部碎片。&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;缺陷：分段机制对虚拟内存到物理内存的映射仍旧是以进程为单位，若某块物理内存不足时，会把进程的所有段都换出到磁盘。因此，会产生大量的磁盘访问，从而影响性能。按照局部性原理可以优化一下，&lt;span&gt;不用&lt;/span&gt;将不常用的程序段换出到磁盘，只换出那些一直在使用的程序段即可。这样会少一些磁盘和系统带宽。&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;5、分页机制&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;解决分段地址映射&lt;/span&gt;&lt;span&gt;粒度大&lt;/span&gt;&lt;span&gt;的问题，将进程地址空间细分为固定大小的页面，进程的虚拟地址空间也按页面分割，这样常用的数据和代码就可以以页的方式存储在内存中，而不常用的页面可以交换到磁盘中，从而节省物理内存。&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;物理内存也是以页为单位来管理，简称“物理页面”或“页帧”。进程的虚拟地址空间中的页面称“虚拟页面”。操作系统为了管理这些页帧按物理地址给每个页帧编号，简称&lt;/span&gt;&lt;span&gt;页帧号&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;Intel的处理器支持以2MB和1GB为单位的大页面。分页机制离不开硬件支持，CPU内部有个硬件单元来负责虚拟页到物理页面的转换，称&lt;/span&gt;&lt;span&gt;&lt;span&gt;MMU&lt;/span&gt;&lt;span&gt;的硬件单元&lt;/span&gt;&lt;/span&gt;&lt;span&gt;。ARM处理器的MMU包括&lt;/span&gt;&lt;span&gt;TLB&lt;/span&gt;&lt;span&gt;和&lt;/span&gt;&lt;span&gt;页表遍历&lt;/span&gt;&lt;span&gt;单元两个部件。&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-backh=&quot;179&quot; data-backw=&quot;578&quot; data-ratio=&quot;0.31043956043956045&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Z33JZWhn1uPro2sNUj3bvYwlxGoKtuwzb20yGibJazvpUMpCgCk6DHHJSSjHUvOA2SIsicVRdjVW2h4miaKicUt0UA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;728&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;TLB是一个高速缓存&lt;/span&gt;&lt;span&gt;，用于缓存页表转换的结果，从而减少页表查询的时间。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;一个完整的页表翻译和查找的过程叫作&lt;/span&gt;&lt;span&gt;页表查询&lt;/span&gt;&lt;span&gt;，页表的查询是由硬件自动完成的，但是页表的维护需要软件来完成。当TLB没有命中时，MMU才会查询页表(例如AArch64页表分成4级页表，遍历就比较耗时)，从而得到翻译后的物理地址。而页表通常存储在主存储器中，得到物理地址后，首先需要查询该物理地址的内容是否在高速缓存中有最新的副本，如果没有，则说明高速缓存未命中，需要访问主存储器。&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;&lt;span data-mpa-emphasize-underline=&quot;t&quot;&gt;&lt;span&gt;总结&lt;/span&gt;&lt;span data-mpa-emphasize-underline-bg-line=&quot;t&quot;/&gt;&lt;/span&gt;：对于多任务操作系统，每个进程都拥有独立的进程地址空间。这些进程地址空间在虚拟地址空间内是相互隔离的，但是在物理地址空间可能映射同一个物理页面。它们的映射关系主要是靠处理器的MMU提供页表映射和管理的功能&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;进程地址空间&lt;/span&gt;&lt;span&gt;又分为&lt;/span&gt;&lt;span&gt;内核空间&lt;/span&gt;&lt;span&gt;和&lt;/span&gt;&lt;span&gt;用户空间&lt;/span&gt;&lt;span&gt;。它们都可以通过处理器提供的页表机制映射到实际的物理地址。&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-backh=&quot;513&quot; data-backw=&quot;538&quot; data-ratio=&quot;0.9535315985130112&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Z33JZWhn1uPro2sNUj3bvYwlxGoKtuwzvalakR45NBmljLBJ9OMMKcicnxjVeOYVL5ia4GOUlUiasZT3cyFhBKMtw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;538&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;二、从内核看内存&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;内存管理是一个非常复杂的系统，如果用分层来描述，内存空间可以分成为三个层次，分别是&lt;/span&gt;&lt;span&gt;用户空间&lt;/span&gt;&lt;span&gt;、&lt;/span&gt;&lt;span&gt;内核空间&lt;/span&gt;&lt;span&gt;、&lt;/span&gt;&lt;span&gt;硬件层&lt;/span&gt;&lt;span&gt;。&lt;span&gt;其中&lt;/span&gt;&lt;span&gt;操作系统和驱动程序运行在内核空间&lt;/span&gt;&lt;span&gt;，而&lt;/span&gt;&lt;span&gt;应用程序运行在用户空间&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-backh=&quot;396&quot; data-backw=&quot;578&quot; data-ratio=&quot;0.6845827439886846&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Z33JZWhn1uPro2sNUj3bvYwlxGoKtuwzEeuvyqiaCzNQRzjvbVWo7xgQoR94QSnI0zwWiakjJXJnjz1LyAW51o8Q/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;707&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;底位的虚拟地址空间&lt;/span&gt;&lt;span&gt;位于&lt;span&gt;0x0000 0000 0000 0000 ~ 0x0000 FFFF FFFF FFFF 如果虚拟地址的&lt;/span&gt;&lt;/span&gt;&lt;span&gt;最高位等于0&lt;/span&gt;&lt;span&gt;，就使用这个虚拟地址空间，并&lt;/span&gt;&lt;span&gt;使用TTBR0_BLx来存放页表的基地址&lt;/span&gt;&lt;span&gt;。&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;高位的虚拟地址空间&lt;/span&gt;&lt;span&gt;位于&lt;span&gt;0xFFFF 0000 0000 0000 ~ 0xFFFF FFFF FFFF FFFF 如果虚拟地址的&lt;/span&gt;&lt;/span&gt;&lt;span&gt;最高位等于1&lt;/span&gt;&lt;span&gt;，就使用这个虚拟地址空间，并且&lt;/span&gt;&lt;span&gt;使用TTBR1_ELx来存放页表的基地址&lt;/span&gt;&lt;span&gt;。&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;例如在AArch64架构中，因为地址总线位宽最多支持48位，所以虚拟地址（VA）被划分为两个空间（用户空间、内核空间），每个空间最多支持256TB。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;AArch64架构中的MMU支持单一阶段的页表转换也支持虚拟化扩展中两阶段的页表转换。&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-backh=&quot;301&quot; data-backw=&quot;578&quot; data-ratio=&quot;0.5206703910614525&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Z33JZWhn1uPro2sNUj3bvYwlxGoKtuwziasRSPFbO8RPRKWwe3XvZ6wT4m5x4Wick44rIwrmQwbBFWibTqCo6nAyw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;895&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;在32位的linux系统中，一共能使用的虚拟地址空间是4GB。空间划分0-3GB为用户空间，3-4GB为内核空间。通常是按照3:1来划分的，当然也可以2:2来划分。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;1、为什么区分内核空间和用户空间&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;在CPU的所有指令中，有些指令比较危险容易导致系统崩溃，譬如清理内存、设置时钟等。对于那些危险的指令只允许操作系统内核自己有权限操作，普通的应用程序只能使用那些不会造成灾难的指令。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;例如Intel的CPU将特权等级划分为四个级别Ring0-Ring3。其实linux系统只使用了Ring0 和 Ring3两个运行级别。&lt;/span&gt;&lt;span&gt;当运行&lt;/span&gt;&lt;span&gt;Ring3级别&lt;/span&gt;&lt;span&gt;&lt;span&gt;时被称为运行在&lt;/span&gt;&lt;span&gt;用户态&lt;/span&gt;&lt;span&gt;，运行在&lt;/span&gt;&lt;/span&gt;&lt;span&gt;Ring0级别&lt;/span&gt;&lt;span&gt;时称之为运行在&lt;/span&gt;&lt;span&gt;内核态&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-backh=&quot;327&quot; data-backw=&quot;326&quot; data-ratio=&quot;1.0030674846625767&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Z33JZWhn1uPro2sNUj3bvYwlxGoKtuwzUmTceAVG3aPr8FV4YYIqfBGia5UdXf85SK5rcNUcaeyJEs3BNbjebZA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;326&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;2、什么是用户态和内核态&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;当一个进程发起系统调用时，进程在内核代码中执行时，称进程处于&lt;/span&gt;&lt;span&gt;内核态&lt;/span&gt;&lt;span&gt;。此时处理器处于特权最高的&lt;/span&gt;&lt;span&gt;（Ring0级）&lt;/span&gt;&lt;span&gt;。当进程处于内核态时，执行的内核代码会使用当前进程的&lt;/span&gt;&lt;span&gt;内核栈&lt;/span&gt;&lt;span&gt;，&lt;/span&gt;&lt;span&gt;&lt;span&gt;每个进程都有自己的&lt;/span&gt;&lt;span&gt;内核栈&lt;/span&gt;&lt;/span&gt;&lt;span&gt;。&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;当一个进程在用户空间执行时，称进程处于&lt;/span&gt;&lt;span&gt;用户态&lt;/span&gt;&lt;span&gt;。此时处理器在特权级最低的&lt;/span&gt;&lt;span&gt;（Ring3级）&lt;/span&gt;&lt;span&gt;。当进程处于用户态时，执行的程序代码都会使用当前进程的用户空间的&lt;/span&gt;&lt;span&gt;用户栈&lt;/span&gt;&lt;span&gt;，&lt;/span&gt;&lt;span&gt;&lt;span&gt;每个进程都有自己的&lt;/span&gt;&lt;span&gt;用户栈&lt;/span&gt;&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span data-mpa-emphasize-underline=&quot;t&quot;&gt;&lt;span&gt;注意&lt;/span&gt;&lt;span data-mpa-emphasize-underline-bg-line=&quot;t&quot;/&gt;&lt;/span&gt;：当正在执行的用户程序突然被&lt;/span&gt;&lt;span&gt;中断程序中断&lt;/span&gt;&lt;span&gt;时，此时用户程序也可以象征地被称为处于进程的内核态。因为中断处理程序将使用当前进程的内核栈。&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span data-mpa-emphasize-underline=&quot;t&quot;&gt;&lt;span&gt;注意&lt;/span&gt;&lt;span data-mpa-emphasize-underline-bg-line=&quot;t&quot;/&gt;&lt;/span&gt;：对于以前的DOS操作系统而言是没有内核空间、用户空间、内核态、用户态这些概念的，统一认为代码都是运行在内核态下的，所以操作系统很容易崩溃掉。而对于Linux来说，通过区分内核空间和用户空间设计，隔离了操作系统代码与应用程序代码，使得操作系统更健壮、更具有稳定性和可用性以及安全性。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;3、如何从用户空间进入内核空间&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;用户空间进入内核空间触发的三种场景分别是&lt;/span&gt;&lt;span&gt;系统调用&lt;/span&gt;&lt;span&gt;（软中断）、&lt;/span&gt;&lt;span&gt;异常&lt;/span&gt;&lt;span&gt;、&lt;/span&gt;&lt;span&gt;硬件中断&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;进程在被创建的时候都会产生两个栈，分别是&lt;/span&gt;&lt;span&gt;用户栈，内核栈&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;span&gt;用户栈位于用&lt;/span&gt;&lt;span&gt;户地址空&lt;/span&gt;&lt;span&gt;间&lt;/span&gt;&lt;span&gt;，内&lt;/span&gt;&lt;span&gt;核栈&lt;/span&gt;&lt;span&gt;位于内核地址空间。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;1）系统调用案例&lt;/span&gt;&lt;/strong&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;当一个进程需要读取磁盘上某一资源，它会向操作系统发起一个系统调用指令，例如（Open()、Read()、Write()、Close()）&lt;span&gt;开放&lt;/span&gt;&lt;span&gt;接口&lt;/span&gt;等。此时会发生一些CPU上下文切换动作。&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;保存当前CPU寄存器里原来用户态的指令位&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;为了执行内核态代码，CPU寄存器需要更新为内核态指令的新位置&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;跳转到内核态运行内核任务，例如从调用磁盘IO，读取资源存储到内核态内核缓存区中&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;待磁盘IO结束后，再从&lt;/span&gt;&lt;span&gt;内核空间&lt;/span&gt;&lt;span&gt;的&lt;/span&gt;&lt;span&gt;内核缓存区&lt;/span&gt;&lt;span&gt;拷贝数据到&lt;/span&gt;&lt;span&gt;用户空间&lt;/span&gt;&lt;span&gt;的&lt;/span&gt;&lt;span&gt;用户缓存区&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;当系统调用结束，CPU寄存器恢复到原来的用户态指令位&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;最后切换到用户空间，继续运行进程&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span data-mpa-emphasize-underline=&quot;t&quot;&gt;&lt;span&gt;总的来说&lt;/span&gt;&lt;span data-mpa-emphasize-underline-bg-line=&quot;t&quot;/&gt;&lt;/span&gt;，在内核空间中代码控制了硬件层资源的使用权，在用户空间中的代码它只能通过内核对外开放的系统调用接口来调用系统中的硬件资源。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;4、进程上下文和中断上下文&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;处理器总处于以下三种状态之一&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;用户空间的应用程序，通过系统调用，进入内核空间。这个时候用户空间的进程要传递很多变量、参数的值给内核，内核态运行的时候也要保存用户进程的一些寄存器值、变量等。所谓的&lt;/span&gt;&lt;span&gt;“进程上下文”&lt;/span&gt;&lt;span&gt;，可以看作是用户进程传递给内核的这些参数以及内核要保存的那一整套的变量和寄存器值和当时的环境等。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;硬件通过触发信号，导致内核调用&lt;/span&gt;&lt;span&gt;中断&lt;/span&gt;&lt;span&gt;处理程序，进入内核空间。这个过程中，硬件的 一些变量和参数也要传递给内核，内核通过这些参数进行中断处理。所谓的&lt;/span&gt;&lt;span&gt;“中断上下文”&lt;/span&gt;&lt;span&gt;，其实也可以看作是硬件传递过来的这些参数和内核需要保存的一些其他环境（主要是当前被打断执行的进程环境）。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;三、参考来源&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;《奔跑吧linux内核》&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;https://zhuanlan.zhihu.com/p/52845869&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;https://www.cnblogs.com/hustcat/articles/1505618.html&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;https://www.cnblogs.com/sparkdev/p/8410350.html&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;578&quot; data-backw=&quot;578&quot; data-ratio=&quot;1&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/Z33JZWhn1uNE2jbQicbpwrWbzt4yCuXsolw0UEM7wZRXB1Rl8vvAJzbNsaQc7llGM2RQmT0TEJD94GARMRFUQvQ/640?wx_fmt=gif&quot; data-type=&quot;gif&quot; data-w=&quot;600&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.271585557299843&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/Z33JZWhn1uOnC8YBW9UGogSXeaGKoIibSDV6rg2FnuL671lPX6ibOEBOcNuvPqxyhqxlWicyf8dcraK579G8FWzrg/640?wx_fmt=gif&quot; data-type=&quot;gif&quot; data-w=&quot;637&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;/div&gt;

          
        &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>1dbba75f02f0b9d64ad60fc0e918ec19</guid>
<title>最快的内存数据库横空出世，比 Redis 快 25 倍，Star 数飙升，杀疯了！</title>
<link>https://toutiao.io/k/gqbvxkn</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content                           autoTypeSetting24psection&amp;#10;                          &quot; id=&quot;js_content&quot;&gt;&lt;blockquote class=&quot;js_blockquote_wrap&quot; data-type=&quot;2&quot; data-url=&quot;&quot; data-author-name=&quot;&quot; data-content-utf8-length=&quot;21&quot; data-source-title=&quot;&quot; data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;section class=&quot;js_blockquote_digest&quot;&gt;&lt;section&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;来自公众号：InfoQ&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;section&gt;&lt;span&gt;整理 | 钰莹、Tina&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/blockquote&gt;&lt;section&gt;
&lt;span&gt;回击就代表输了？！&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;今年年中，一位前谷歌、前亚马逊的工程师推出了他创作的开&lt;strong&gt;源内存数据缓存系统 Dragonfly，用 C/C++ 编写，基于 BSL 许可（Business Source License）分发。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;根据过往的基准测试结果来看， Dragonfly 可能是世界上最快的内存存储系统，它提供了对 Memcached 和 Redis 协议的支持，但能够以更高的性能进行查询，运行时内存消耗也更少。与 Redis 相比，Dragonfly 在典型工作负载下实现了 25 倍的性能提升；单个 Dragonfly 服务器每秒可以处理数百万个请求；在 5GB 存储测试中，Dragonfly 所需的内存比 Redis 少 30%。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;作为一个开源软件，Dragonfly 在短短两个月获得了 9.2K GitHub 星，177 个 fork 分支。虽然这些年，涌现了不少类似的 Redis 兼容型内存数据存储系统，例如 KeyDB、Skytable，但是都没能像这次这么“轰动”。毕竟 Redis 诞生了十多年，这时从头开始设计一个缓存系统，可以抛弃历史包袱，更好地利用资源。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.3543307086614173&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/YriaiaJPb26VOstSIlpg3Yb46r2n938yrYANmunm5cZrvA6odwtUuRrVyfET0eWkcbzviaag2XR40sGD4icfUe1ic5Q/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;762&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;为回击新冒头的 Dragonfly，Redis 的联合创始人兼 CTO Yiftach Shoolman 和 Redis Labs 的首席架构师 Yossi Gottlieb、Redis Labs 的性能工程师 Filipe Oliveira 联合发布了一篇名为《13 年后，Redis 是否需要新的架构》的文章。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在文章中，他们特地给出了自认更加公平的 Redis 7.0 vs. Dragonfly 基准测试结果：Redis 的吞吐量比 Dragonfly 高 18% - 40%，以及一些有关 Redis 架构的观点和思考，以证明 “为什么 Redis 的架构仍然是内存实时数据存储（缓存、数据库，以及介于两者之间的所有内容）的最佳架构”。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;虽然他们强调 Redis 架构仍然是同类最佳，但也没法忽视 Dragonfly 这些新软件提供的一些新鲜、有趣的想法和技术，Redis 表示其中的一些甚至有可能在未来进入 Redis（比如已经开始研究的 io_uring 、更现代的 dictionaries、更有策略地使用线程等）。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;另外，Redis 指出 Dragonfly 基准测试的比较方法 “不能代表 Redis 在现实世界中的运行方式” 。对此，Reddit 上有网友反驳称：&lt;/span&gt;&lt;/p&gt;&lt;blockquote class=&quot;js_blockquote_wrap&quot; data-type=&quot;2&quot; data-url=&quot;&quot; data-author-name=&quot;&quot; data-content-utf8-length=&quot;124&quot; data-source-title=&quot;&quot; data-text=&quot;它绝对代表了现实世界中普通用户运行 Redis 的方式。“在单台机器上运行集群，只是为了能够使用超过 1 个 core&amp;quot; 是额外的复杂性，人们只有在别无选择的情况下才会这样做，如果竞争者无论有多少个 core 都能 “just works&amp;quot;，那么最好能有更容易的设置。&quot; data-editid=&quot;s7ia5ldjruo0000000&quot;&gt;&lt;section class=&quot;js_blockquote_digest&quot;&gt;&lt;p&gt;&lt;span&gt;它绝对代表了现实世界中普通用户运行 Redis 的方式。“在单台机器上运行集群，只是为了能够使用超过 1 个 core&quot; 是额外的复杂性，人们只有在别无选择的情况下才会这样做，如果竞争者无论有多少个 core 都能 “just works&quot;，那么最好能有更容易的设置。&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;span&gt;还有人表示，这篇文章是 Redis 团队在有礼貌地否认“Dragonfly 是最快的缓存系统”，但更多网友表示，Redis 发文章进行“回击”，就已经代表他们的营销部门输了：&lt;/span&gt;&lt;/p&gt;&lt;blockquote class=&quot;js_blockquote_wrap&quot; data-type=&quot;2&quot; data-url=&quot;&quot; data-author-name=&quot;&quot; data-content-utf8-length=&quot;115&quot; data-source-title=&quot;&quot; data-text=&quot;“Redis 投入如此多的工程精力来写这么一篇文章，还对 Reids/Dragonfly 进行了基准测试，这是对 Dragonfly 的极大赞美。”“我很高兴 Redis 发了这篇文章，因此我必须要去了解一下 Dragonfly，它看起来很棒。”&quot; data-editid=&quot;2n4gdw7o34o00000000&quot;&gt;&lt;section class=&quot;js_blockquote_digest&quot;&gt;&lt;p&gt;&lt;span&gt;“Redis 投入如此多的工程精力来写这么一篇文章，还对 Reids/Dragonfly 进行了基准测试，这是对 Dragonfly 的极大赞美。”“我很高兴 Redis 发了这篇文章，因此我必须要去了解一下 Dragonfly，它看起来很棒。”&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/blockquote&gt;&lt;section&gt;
&lt;span&gt;Redis 博客文章翻译：&lt;/span&gt;
&lt;/section&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;作为一项基础性技术，每隔段时间总有人跳出来，想要替 Redis 换套新架构。&lt;/strong&gt;几年之前，KeyDB 就提出了这类方案，而最近亮相的 Dragonfly 则声称是速度最快的 Redis 兼容型内存数据存储系统。没错，这类方案的涌现当然带来了不少值得关注和讨论的有趣技术 / 思路。在 Redis，我们也喜欢迎接挑战，重新审视 Redis 最初的架构设计原则。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;我们当然一直在寻求为 Redis 提升性能、扩充功能的创新方向，但这里我们想聊聊自己的观点和思考，阐释 Redis 时至今日为何仍是最出色的实时内存数据存储（包括缓存、数据库以及介于二者之间的一切）方案之一。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;接下来，我们将重点介绍 Redis 对于速度和架构差异的观点，再以此为基础做出比较。在文章的最后，我们还会提供基准测试结果、与 Dragonfly 项目的详尽性能比较信息，欢迎大家自行对比参考。&lt;/span&gt;&lt;/p&gt;&lt;section&gt;
&lt;span&gt;速度问题&lt;/span&gt;
&lt;/section&gt;&lt;p&gt;&lt;span&gt;Dragonfly 基准测试其实是将独立单进程 Redis 实例（只能使用单一核心）与多线程 Dragonfly 实例（可以使用虚拟机 / 服务器上的全部可用核心）进行比较。很明显，这样的粗暴比较并不能代表 Redis 在现实场景下的运行状态。作为技术构建者，我们希望更确切地把握自有技术同其他方案间的差异，所以这里我们做了一点公平性调整：将具有 40 个分片的 Redis 7.0 集群（可使用其中的大部分实例核心）与 Dragonfly 团队在基准测试中使用的最大实例类型（AWS c4gn.16xlarge）进行性能比较。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在这轮测试中，我们看到 Redis 的吞吐量比 Dragonfly 要高出 18% 至 40%，而这还仅仅只用到全部 64 个 vCore 中的 40 个。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6025390625&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/YriaiaJPb26VOstSIlpg3Yb46r2n938yrYeAXzOQlG5U9jL4MlfDYVgmBJLvMD3F0r8EIUOnzlHC2CpCKSYRuxNw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1024&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.2158203125&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/YriaiaJPb26VOstSIlpg3Yb46r2n938yrYOibdXLicl1ZL49onUic2e9WalDsxlT7noU3wvfCuE9tfIZ7Q8tAX7epKw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1024&quot;/&gt;&lt;/p&gt;&lt;section&gt;
&lt;span&gt;架构差异&lt;/span&gt;
&lt;/section&gt;&lt;section&gt;
&lt;span&gt;背景信息&lt;/span&gt;
&lt;/section&gt;&lt;p&gt;&lt;span&gt;在我们看来，每一位多线程项目的开发者在立项之前，都会根据以往工作中经历过的痛点来指导架构决策。我们也承认，在多核设备上运行单一 Redis 进程（这类设备往往提供几十个核心和数百 GB 内存）确实存在资源无法充分利用的问题。但 Redis 在设计之初也确实没有考虑到这一点，而且众多 Redis 服务商已经拿出了相应的解决方案，借此在市场上占得一席之地。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Redis 通过运行多个进程（使用 Redis 集群）实现横向扩展，包括在单一云实例背景下也是如此。在 Redis 公司，我们进一步拓展这个概念并建立起 Redis Enterprise。Redis Enterprise 提供管理层，允许用户大规模运行 Redis，并默认启用高可用性、即时故障转移、数据持久与备份等功能。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;下面，我们打算分享幕后使用的一些原则，向大家介绍我们如何为 Redis 的生产应用设计良好的工程实践。&lt;/span&gt;&lt;/p&gt;&lt;section&gt;
&lt;span&gt;架构设计原则&lt;/span&gt;
&lt;/section&gt;&lt;section&gt;
&lt;span&gt;&lt;span&gt; &lt;/span&gt;在每个虚拟机上运行多个 Redis 实例&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;通过在每个虚拟机上运行多个 Redis 实例，我们可以：&lt;/span&gt;&lt;/p&gt;&lt;ol class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;使用一套完全无共享的架构实现纵向与横向线性扩展。与纯纵向扩展的多线程架构相比，这套方案能始终提供更好的架构灵活性。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;提高复制速度，因为复制操作是跨多个进程并发完成的。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;从虚拟机故障中快速恢复。因为新虚拟机的 Redis 实例将同时填充来自多个外部 Redis 实例的数据。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;section&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;将每个 Redis 进程限制为合理的大小&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;我们不允许单一 Redis 进程的大小超过 25 GB（运行 Redis on Flash 时上限为 50 GB）。如此一来，我们就能：&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;横向扩展才是最重要的&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;以横向扩展的方式灵活运行内存数据存储，是 Redis 获得成功的关键。下面来看具体原因：&lt;/span&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;更佳弹性——我们在集群中使用的节点越多，整个集群的健壮性就越强。例如，如果您在三节点集群上运行数据集，且其中一个节点发生降级，则代表有三分之一的集群无法运行；但如果是在九节点集群上运行数据集，同样是其中一个节点发生降级，则只有九分之一的集群无法运行。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;易于扩展——在横向扩展系统当中，向集群添加一个额外节点、并将数据集的一部分迁移到其中要容易得多。与之对应，在纵向扩展系统中，我们只能直接引入一个更大的节点并复制整个数据集……这是个漫长的过程，而且期间随时有可能闹出麻烦。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;逐步扩展更具成本效益——纵向扩展，尤其是云环境下的纵向扩展，往往对应高昂的成本。在多数情况下，即使只需要向数据集内添加几 GB 内容，也需要将实例大小翻倍。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;高吞吐——在 Redis，我们看到很多客户会在小型数据集上运行高吞吐量工作负载，即具有极高的网络带宽及 / 或每秒数据包（PPS）需求。我们以每秒操作数 100 万 + 的 1 GB 大小数据集为例，相较于使用单节点 c6gn.16xlarge 集群（128 GB 内存、64 个 CPU 加 100 Gbps 传输带宽，每小时使用成本 2.7684 美元），三个 c6gb.xlarge 节点（8 GB 内存、4 个 CPU 外加最高 25 Gbps 传输带宽，每小时 0.1786 美元）构成的集群能够将运行成本拉低 20%，而且健壮性反而更高。既然成本效益出色、弹性更强且吞吐量反超，那横向扩展无疑就是比纵向扩展更好的选择。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;贴近 NUMA 架构——纵向扩展还要求使用能容纳更多核心和大容量 DRAM 的双插槽服务器；相比之下，Redis 这样的多处理架构其实更适应 NUMA 架构，因为其行为特征就接近一种由多个较小节点组成的网络。但必须承认，NUMA 跟多线程架构之间也有天然冲突。根据我们在其他多线程项目中的经验，NUMA 可能令内存数据存储的性能降低达 80%。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;存储吞吐量限制——AWS EBS 等外部磁盘的扩展速度，显然不及内存和 CPU。事实上，云服务商会根据所使用设备的类型添加存储吞吐量限制。因此，避免吞吐量限制、满足数据高持久性要求的唯一办法，就是使用横向扩展——即添加更多节点和更多的配套网络附加磁盘。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;临时磁盘——临时磁盘是一种将 Redis 运行在 SSD 上的绝佳方式（其中 SSD 用于替代 DRAM，而非充当持久存储介质），能够在保持 Redis 极高速度的同时将数据库成本保持在磁盘级水平。但临时磁盘也有其上限，一旦逼近这一上限，我们还需要进一步扩展容量——这时候，更好的办法仍然是添加更多节点、引入更多临时磁盘。所以，横向扩展继续胜出。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;商品硬件——最后，我们的很多客户会在本地数据中心、私有云甚至是小型边缘数据中心内运行 Redis。在这类环境中，绝大多数设备内存不超过 64 GB、CPU 不超过 8 个，所以唯一可行的扩展方式就只有横向扩展。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;section&gt;
&lt;span&gt;总    结&lt;/span&gt;
&lt;/section&gt;&lt;p&gt;&lt;span&gt;我们仍然欣赏由社区提出的种种有趣思路和技术方案。其中一部分有望在未来进入 Redis（我们已经开始研究 io_uring、更现代的字典、更丰富的线程使用策略等）。但在可预见的未来，我们不会放弃 Redis 所坚守的无共享、多进程等基本架构原则。这种设计不仅具备最佳性能、可扩展性和弹性，同时也能够支持内存内实时数据平台所需要的各类部署架构。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;附录：Redis 7.0 对 Draonfly 基准测试细节&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;section&gt;
&lt;span&gt;&lt;span&gt; &lt;/span&gt;结果概述&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;版本：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;目标：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;客户端配置：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;资源利用与配置优化：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;OSS Redis 集群在 40 个主分片的配置下性能表现最佳，对应的就是虚拟机上有 24 个备用 vCPU。虽然设备资源仍未得到全部利用，但我们发现继续增加分片数量已经没有意义，反而会拉低整体性能。我们仍在调查具体原因。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;另一方面，Dragonfly 解决方案彻底耗尽了虚拟机性能，所有 64 上 vCPU 均达到了 100% 利用率。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;在两种解决方案中，我们调整了客户端配置以实现最佳结果。如下所示，我们成功重现了大部分 Dragonfly 基准数据，甚至在 30 通道条件下得出了比项目方更高的测试成绩。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;本次测试强调与 Dragonfly 测试环境保持一致，如果调整测试环境，Redis 的成绩还有望进一步提升。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;span&gt;最后，我们还发现 Redis 和 Dragonfly 都不受网络每秒数据包或传输带宽的限制。我们已经确认在 2 个虚拟机间（分别作为客户端和服务器，且均使用 c6gn.16xlarge 实例）使用 TCP 传递约 300 B 大小的数据包负载时，可以让每秒数据包传输量达到 1000 万以上、传输带宽超过 30 Gbps。&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;分析结果&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6025390625&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/YriaiaJPb26VOstSIlpg3Yb46r2n938yrYeAXzOQlG5U9jL4MlfDYVgmBJLvMD3F0r8EIUOnzlHC2CpCKSYRuxNw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1024&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.2158203125&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/YriaiaJPb26VOstSIlpg3Yb46r2n938yrYOibdXLicl1ZL49onUic2e9WalDsxlT7noU3wvfCuE9tfIZ7Q8tAX7epKw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1024&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;单 GET 通道延迟低于 1 毫秒：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;30 条 GET 通道：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;OSS Redis：每秒 2290 万次操作，客户端平均延迟为 2.239 毫秒&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;Dragonfly 声称每秒可达 1500 万次操作：&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;Redis 对 Dragonfly——与 Dragonfly 的重现结果和声称结果相比，Redis 分别胜出 43% 和 52%&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;单 SET 通道延迟低于 1 毫秒：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;30 条 SET 通道:&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;OSS Redis：每秒 1985 万次操作，客户端平均延迟为 2.879 毫秒&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;Dragonfly 声称每秒 1000 万次操作：&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;Redis 对 Dragonfly——与 Dragonfly 的重现结果和声称结果相比，Redis 分别胜出 42% 和 99%&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;span&gt;用于各变体的 memtier_benchmark 命令：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;单 GET 通道延迟低于 1 毫秒&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;Redis:2X: memtier_benchmark –ratio 0:1 -t 24 -c 1 –test-time 180 –distinct-client-seed -d 256 –cluster-mode -s 10.3.1.88 –port 30001 –key-maximum 1000000 –hide-histogram&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;Dragonfly:memtier_benchmark –ratio 0:1 -t 55 -c 30 -n 200000 –distinct-client-seed -d 256 -s 10.3.1.6 –key-maximum 1000000 –hide-histogram&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;30 条 GET 通道&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;Redis:2X: memtier_benchmark –ratio 0:1 -t 24 -c 1 –test-time 180 –distinct-client-seed -d 256 –cluster-mode -s 10.3.1.88 –port 30001 –key-maximum 1000000 –hide-histogram –pipeline 30&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;Dragonfly:memtier_benchmark –ratio 0:1 -t 55 -c 30 -n 200000 –distinct-client-seed -d 256 -s 10.3.1.6 –key-maximum 1000000 –hide-histogram –pipeline 30&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;单 SET 通道延迟低于 1 毫秒&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;Redis:2X: memtier_benchmark –ratio 1:0 -t 24 -c 1 –test-time 180 –distinct-client-seed -d 256 –cluster-mode -s 10.3.1.88 –port 30001 –key-maximum 1000000 –hide-histogram&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;Dragonfly:memtier_benchmark –ratio 1:0 -t 55 -c 30 -n 200000 –distinct-client-seed -d 256 -s 10.3.1.6 –key-maximum 1000000 –hide-histogram&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;30 条 SET 通道&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;Redis:2X: memtier_benchmark –ratio 1:0 -t 24 -c 1 –test-time 180 –distinct-client-seed -d 256 –cluster-mode -s 10.3.1.88 –port 30001 –key-maximum 1000000 –hide-histogram –pipeline 30&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;Dragonfly:memtier_benchmark –ratio 1:0 -t 55 -c 30 -n 200000 –distinct-client-seed -d 256 -s 10.3.1.6 –key-maximum 1000000 –hide-histogram –pipeline 30&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;section&gt;
&lt;span&gt;测试设施细节&lt;/span&gt;
&lt;/section&gt;&lt;p&gt;&lt;span&gt;在本次比较测试中，我们在客户端（用于运行 memtier_benchmark）和服务器（用于运行 Redis 和 Dragonfly）使用了相同的虚拟机类型，具体规格为：&lt;/span&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;虚拟机：AWS c6gn.16xlarge&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;aarch64&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;ARM Neoverse-N1&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;每插槽核心数: 64&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;每核心线程数: 1&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;NUMA 节点数: 1&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;核心版本: Arm64 Kernel 5.10&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;安装内存: 126 GB&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;参考链接：&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;https://redis.com/blog/redis-architecture-13-years-later/&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;https://www.reddit.com/r/programming/comments/wiztpx/redis_hits_back_at_dragonfly/&lt;/span&gt;&lt;/p&gt;&lt;figure&gt;&lt;span&gt;--- EOF ---&lt;/span&gt;&lt;br/&gt;&lt;/figure&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;span&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;推荐↓↓↓&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section class=&quot;mp_profile_iframe_wrp&quot;&gt;&lt;mp-common-profile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mpprofile&quot; data-id=&quot;MjM5NzA1MTcyMA==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/NVvB3l3e9aGpkg0JIy2j4fOL2ZgG8tibedy2Ie2U2tozJleDeGibdNVJiaS5snul6FoYXfTFp9uh8OLxBAn0HIy6A/0?wx_fmt=png&quot; data-nickname=&quot;程序猿&quot; data-alias=&quot;imkuqin&quot; data-signature=&quot;传播编程经验，挖掘程序员优秀的学习资源。&quot; data-from=&quot;0&quot; data-is_biz_ban=&quot;0&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/div&gt;

          
        &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>ed758f9c2cb89ba573429f0327e0ba01</guid>
<title>如何用Go实现一个异步网络库？</title>
<link>https://toutiao.io/k/83sqkd1</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content                           autoTypeSetting24psection&amp;#10;                          &quot; id=&quot;js_content&quot;&gt;&lt;p data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;导语 | &lt;/span&gt;&lt;span&gt;在需要高性能、节省资源的场景下，比如海量的连接、很高的并发，我们发现Go开始变得吃力，不但内存开销大，而且还会有频繁的goroutine调度。GC时间也变得越来越长，甚至还会把系统搞挂。这时，我们就可以考虑用Go构建经典的Reactor网络模型，来应对这种场景。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;p data-lines=&quot;1&quot; data-type=&quot;p&quot; data-sign=&quot;8c2011fe7977c79c57258f08c7c970ac1&quot;&gt;&lt;/p&gt;&lt;section mpa-from-tpl=&quot;t&quot; data-mpa-template=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;span&gt;&lt;strong mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;一、常见的服务端网络编程模型&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p data-lines=&quot;1&quot; data-type=&quot;p&quot; data-sign=&quot;8c2011fe7977c79c57258f08c7c970ac1&quot;&gt;&lt;/p&gt;&lt;p cid=&quot;n6&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;在具体讲Reactor网络库的实现前，我们先快速回顾下常见的服务端网络编程模型。&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n7&quot; mdtype=&quot;paragraph&quot;&gt;&lt;/p&gt;&lt;p cid=&quot;n7&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;服务端网络编程主要解决两个问题，一个&lt;/span&gt;&lt;span&gt;是&lt;/span&gt;&lt;span&gt;服务端如何管理连接，特别是海量连接、高并发连接（经典的c10k/c100k问题）&lt;/span&gt;&lt;span&gt;，二是&lt;/span&gt;&lt;span&gt;服务端如何处理请求（高并发时正常响应）&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n8&quot; mdtype=&quot;paragraph&quot;&gt;&lt;/p&gt;&lt;p cid=&quot;n8&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;针对这两个问题，有三种解决方案，分别对应三种模型：&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n11&quot; mdtype=&quot;paragraph&quot;&gt;&lt;/p&gt;&lt;p cid=&quot;n13&quot; mdtype=&quot;paragraph&quot;&gt;&lt;/p&gt;&lt;p cid=&quot;n15&quot; mdtype=&quot;paragraph&quot;&gt;&lt;/p&gt;&lt;p cid=&quot;n16&quot; mdtype=&quot;paragraph&quot;&gt;&lt;/p&gt;&lt;p cid=&quot;n17&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;下面两图分别是传统IO阻塞模型和Reactor模型，传统IO阻塞模型的特点是每条连接都是由单独的线/进程管理，业务逻辑（crud）跟数据处理（网络连接上的read和write）都在该线/进程完成。&lt;/span&gt;&lt;span&gt;缺点很明显，并发大时，需要创建大量的线/进程，系统资源开销大；连接建立后，如果当前线/进程暂时还没数据可读，会阻塞在Read调用上，浪费系统资源&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-croporisrc=&quot;https://mmbiz.qpic.cn/mmbiz_png/VY8SELNGe95VxoqjGm1IfuicBMt3YLNVk4WowveJPeDkKlwMKmsZ45KC0g5AKJNBghDfRBOL53icFkFWPkJlAQNw/0?wx_fmt=png&quot; data-cropx1=&quot;0&quot; data-cropx2=&quot;545.3373702422145&quot; data-cropy1=&quot;0&quot; data-cropy2=&quot;663.6159169550173&quot; data-ratio=&quot;1.218348623853211&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/VY8SELNGe95VxoqjGm1IfuicBMt3YLNVk4h3K8cBtfPoVLp3tLGN1U7JXgpbaBVt7Zz4nBVUiaYZIyT7EiaqS8CIw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;545&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p cid=&quot;n19&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;Reactor模型就是传统IO阻塞模型的改进，Reactor会起单独的线/进程去监听和分发事件，分发给其他EventHandlers处理数据读写和业务逻辑。这样，与传统IO阻塞模型不同的是，Reactor的连接都先到一个EventDispatcher上，一个核心的事件分发器，同时&lt;/span&gt;&lt;span&gt;Reactor会使用IO多路复用在事件分发器上非阻塞地处理多个连接&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n20&quot; mdtype=&quot;paragraph&quot;&gt;&lt;/p&gt;&lt;p cid=&quot;n20&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;这个EventDispatcher跟后面的EventHandlers可以都在一个线/进程，也可以分开，下文会有区分。整体来看，Reactor就是一种事件分发机制，所以Reactor也被称为事件驱动模型。&lt;/span&gt;&lt;span&gt;简而言之，Reactor=IO多路复用（I/O multiplexing）+非阻塞IO（non-blocking I/O）&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n21&quot; mdtype=&quot;paragraph&quot;&gt;&lt;/p&gt;&lt;h3 cid=&quot;n22&quot; mdtype=&quot;heading&quot;&gt;&lt;span&gt;（一）Reactor模型的三种实现&lt;/span&gt;&lt;/h3&gt;&lt;p cid=&quot;n23&quot; mdtype=&quot;paragraph&quot;&gt;&lt;/p&gt;&lt;p cid=&quot;n23&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;根据Reactor的数量和业务线程的工作安排有3种典型实现：&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n26&quot; mdtype=&quot;paragraph&quot;&gt;&lt;/p&gt;&lt;p cid=&quot;n28&quot; mdtype=&quot;paragraph&quot;&gt;&lt;/p&gt;&lt;p cid=&quot;n30&quot; mdtype=&quot;paragraph&quot;&gt;&lt;/p&gt;&lt;p cid=&quot;n31&quot; mdtype=&quot;paragraph&quot;&gt;&lt;/p&gt;&lt;p cid=&quot;n31&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;先看两个单Reactor：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;1.6091476091476091&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/VY8SELNGe95VxoqjGm1IfuicBMt3YLNVkVtet5ribZIxZ0YyDfias2oeWuztK2ibMEaZK3cCYZdoUPiauIm4uvsSm3g/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;481&quot;/&gt;&lt;/p&gt;&lt;p cid=&quot;n33&quot; mdtype=&quot;paragraph&quot;&gt;&lt;/p&gt;&lt;p cid=&quot;n33&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;一个Reactor接管所有的事件安排&lt;/span&gt;&lt;span&gt;，如果是建立连接事件，就交给Acceptor处理，接着创建对应的Handler处理该连接后续的读写事件。如果不是建立连接事件，就调用连接对应的Event Handler来响应。单Reator1和2的区别是2带了个线程池，一定程度上解放Event Handler线程，让Handler专注数据读写处理，特别是在遇到一些笨重、高耗时的业务逻辑时。&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n34&quot; mdtype=&quot;paragraph&quot;&gt;&lt;/p&gt;&lt;p cid=&quot;n35&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;再来看多Reactor，这个是本文的主角，第三节内容就是怎么实现它。多Reactor就是主从多Reactor，它的特点是&lt;/span&gt;&lt;span&gt;多个Reactor在多个单独的线/进程中运行，MainReactor负责处理建立连接事件，交给它的Acceptor处理，处理完了，它再分配连接给SubReactor；SubReactor则处理这个连接后续的读写事件，SubReactor自己调用EventHandlers做事情&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n36&quot; mdtype=&quot;paragraph&quot;&gt;&lt;/p&gt;&lt;p cid=&quot;n36&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;这种实现看起来职责就很明确，可以方便通过增加SubReactor数量来充分利用CPU资源，也是当前主流的服务端网络编程模型。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.915282392026578&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/VY8SELNGe95VxoqjGm1IfuicBMt3YLNVkdvG5jWdiafh6tU1Gic9bfatibjuic7DcYrJHGIbQU0ibLoLjSRxroca0lXA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;602&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;h3 cid=&quot;n38&quot; mdtype=&quot;heading&quot;&gt;&lt;span&gt;（二）Proactor模型自带主角光环&lt;/span&gt;&lt;/h3&gt;&lt;p cid=&quot;n39&quot; mdtype=&quot;paragraph&quot;&gt;&lt;/p&gt;&lt;p cid=&quot;n39&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;尽管本文的主角是主从多Reactor，但如果Proactor要当主角，就没Reactor什么事。&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n40&quot; mdtype=&quot;paragraph&quot;&gt;&lt;/p&gt;&lt;p cid=&quot;n40&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;Proactor模型跟Reactor模型的&lt;/span&gt;&lt;span&gt;本质区别是&lt;/span&gt;&lt;span&gt;异步I/O和同步I/O的区别，即底层I/O实现&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;1.7044917257683214&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/VY8SELNGe95VxoqjGm1IfuicBMt3YLNVkUvoJeeMZJFYf7GeTHFCTKca9V5ChyQjY79rvrCIV7icV2fbu3wEwIPw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;423&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p cid=&quot;n42&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;从上面两张图可以看出，Reactor模型依赖的同步I/O需要不断检查事件发生，然后拷贝数据处理，而Proactor模型使用的异步I/O只需等待系统通知，直接处理内核拷贝过来的数据，孰优孰劣，一言便知。&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n43&quot; mdtype=&quot;paragraph&quot;&gt;&lt;/p&gt;&lt;p cid=&quot;n43&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;基于异步I/O的Proactor模型实现如下图：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.4642409033877039&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/VY8SELNGe95VxoqjGm1IfuicBMt3YLNVkSTvTFzzv19iaGxoQ0Yly8T5b0vS8Mb6tmZkYL4FXKiaqc925oQ8dNWicw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;797&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p cid=&quot;n46&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;那为什么主角光环如此明显的Proactor不是当前主流的服务端网络编程模型呢？&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n47&quot; mdtype=&quot;paragraph&quot;&gt;&lt;/p&gt;&lt;p cid=&quot;n47&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;原因是在Linux下的AIO API--&lt;/span&gt;&lt;span&gt;io_uring&lt;/span&gt;&lt;span&gt;还没有像同步I/O那样能够覆盖和支持很多场景，即还没成熟到被广泛使用。&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n48&quot; mdtype=&quot;paragraph&quot;&gt;&lt;/p&gt;&lt;p cid=&quot;n48&quot; mdtype=&quot;paragraph&quot;&gt;&lt;/p&gt;&lt;section mpa-from-tpl=&quot;t&quot; data-mpa-template=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;span&gt;&lt;strong mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;二、Go原生网络模型简介&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p cid=&quot;n50&quot; mdtype=&quot;paragraph&quot;&gt;&lt;/p&gt;&lt;p cid=&quot;n50&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;关于Go原生网络模型的实现，网上已经有很多文章，这里就不过多展开，读者可以结合下图追踪整个代码流程：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.515&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/VY8SELNGe95VxoqjGm1IfuicBMt3YLNVk4TrxViazXiacl4RCDnChNgg4r59rMStAGuvpajbib0KbuplF1nj8GfboA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;800&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p cid=&quot;n52&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;总结来说，&lt;/span&gt;&lt;span&gt;Go所有的网络操作围绕网络描述符netFD展开，netFD与底层pollDesc结构绑定，当在一个netFD上读写遇到EAGAIN错误时，就将当前goroutine存储到绑定的pollDesc中，同时将goroutine给park住，直到这个netFD上的数据准备好，再唤醒goroutine完成数据读写&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n53&quot; mdtype=&quot;paragraph&quot;&gt;&lt;/p&gt;&lt;p cid=&quot;n53&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;再总结来说，&lt;/span&gt;&lt;span&gt;Go原生网络模型就是个单Reactor多协程模型&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n54&quot; mdtype=&quot;paragraph&quot;&gt;&lt;/p&gt;&lt;p cid=&quot;n54&quot; mdtype=&quot;paragraph&quot;&gt;&lt;/p&gt;&lt;section mpa-from-tpl=&quot;t&quot; data-mpa-template=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;span&gt;&lt;strong mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;三、如何从0到1实现异步网络库&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p data-lines=&quot;1&quot; data-type=&quot;p&quot; data-sign=&quot;8c2011fe7977c79c57258f08c7c970ac1&quot;&gt;&lt;/p&gt;&lt;p cid=&quot;n56&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;我们现在回顾了常见的服务端网络编程模型，也知道Go处理连接的方式是一个连接给分配一个协程处理，即goroutine-per-conn模式。&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n57&quot; mdtype=&quot;paragraph&quot;&gt;&lt;/p&gt;&lt;p cid=&quot;n57&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;那本节就到了我们的重点，怎么去实现一个异步网络库（因为Reactor模型的实现，一般是主线程accept一个连接后，分给其他的线/进程异步处理后续的业务逻辑和数据读写，所以一般Reactor模型的网络库被称为异步网络库，并不是使用异步I/O的API）。&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n58&quot; mdtype=&quot;paragraph&quot;&gt;&lt;/p&gt;&lt;p cid=&quot;n58&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;在具体实现之前，笔者先介绍下需求背景。&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n59&quot; mdtype=&quot;paragraph&quot;&gt;&lt;/p&gt;&lt;h3 cid=&quot;n60&quot; mdtype=&quot;heading&quot;&gt;&lt;span&gt;（一）需求背景&lt;/span&gt;&lt;/h3&gt;&lt;p cid=&quot;n61&quot; mdtype=&quot;paragraph&quot;&gt;&lt;/p&gt;&lt;p cid=&quot;n61&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;Go的协程非常轻量，大部分场景下，基于Go原生网络库构建的应用都不会有什么性能瓶颈，资源占用也很可观。&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n62&quot; mdtype=&quot;paragraph&quot;&gt;&lt;/p&gt;&lt;p cid=&quot;n62&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;我们现在使用的网关是基于C++自研的一款网关，我们想统一技术栈，换成Go的，我们现在峰值会在百万连接上下，大概用了几十台机器，单机能稳定支撑几十万的连接。如果换成Go的话，我们一直疑惑，基于Go实现的网关单机能撑多少，内存跟CPU怎么样？能不能省点机器？&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n63&quot; mdtype=&quot;paragraph&quot;&gt;&lt;/p&gt;&lt;p cid=&quot;n64&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;于是，笔者开始针对这种有大量连接的场景对Go做了一波压测，得出的结论也显而易见：&lt;/span&gt;&lt;span&gt;随着连接数上升，Go的协程数也随之线性上升，内存开销增大，GC时间占比增加。当连接数到达一定数值时，Go的强制GC还会把进程搞挂，服务不可用&lt;/span&gt;&lt;span&gt;。（下文会有网络库的对比压测数据）&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n65&quot; mdtype=&quot;paragraph&quot;&gt;&lt;/p&gt;&lt;p cid=&quot;n65&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;接着，笔者翻阅内外网有同样场景的解决方案，基本都是往经典Reactor模型实现上做文章。比如最早的&lt;/span&gt;&lt;span&gt;A Million WebSockets and Go&lt;/span&gt;&lt;span&gt;，作者Sergey Kamardin使用epoll的方式代替goroutine-per-conn模式，百万连接场景下用少量的goroutine去代替一百万的goroutine。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;A Million WebSockets and Go：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;https://www.freecodecamp.org/news/million-websockets-and-go-cc58418460bb/&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n67&quot; mdtype=&quot;paragraph&quot;&gt;&lt;/p&gt;&lt;p cid=&quot;n67&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;Sergey Kamardin的方案总结：&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n68&quot; mdtype=&quot;paragraph&quot;&gt;&lt;/p&gt;&lt;p cid=&quot;n68&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;Let’s structure the optimizations I told you about.&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n71&quot; mdtype=&quot;paragraph&quot;&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p cid=&quot;n71&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;A read goroutine with a buffer inside is expensive. Solution: netpoll (epoll, kqueue); reuse the buffers.&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n71&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span/&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p cid=&quot;n73&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;A write goroutine with a buffer inside is expensive. Solution: start the goroutine when necessary; reuse the buffers.&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n73&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span/&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p cid=&quot;n75&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;With a storm of connections, netpoll won’t work. Solution: reuse the goroutines with the limit on their number.&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n75&quot; mdtype=&quot;paragraph&quot;&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p cid=&quot;n77&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;net/http is not the fastest way to handle Upgrade to WebSocket. Solution: use the zero-copy upgrade on bare TCP connection.&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;/p&gt;&lt;p cid=&quot;n78&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;又比如字节基于Reactor网络库&lt;/span&gt;&lt;span&gt;netpoll&lt;/span&gt;&lt;span&gt;开发了RPC框架&lt;/span&gt;&lt;span&gt;Kitex&lt;/span&gt;&lt;span&gt;来应对高并发场景。&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n79&quot; mdtype=&quot;paragraph&quot;&gt;&lt;/p&gt;&lt;p cid=&quot;n79&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;笔者简单用Go实现了一个网关，使用这些Reactor网络库再进行了一波压测，结果符合预期：连接数上去后的Go网关确实比之前的稳定，内存占用也很可观。但最终都没有选用这些开源Reactor库，原因是&lt;/span&gt;&lt;span&gt;这些开源库都不是开箱即用，都没有实现HTTP/1.x、TLS等常见协议；API设计不够灵活且专注的场景并不适合网关，比如netpoll目前主要专注于RPC场景&lt;/span&gt;&lt;span&gt;（字节上周才正式对外开源HTTP框架&lt;/span&gt;&lt;span&gt;Hertz&lt;/span&gt;&lt;span&gt;）；&lt;/span&gt;&lt;span&gt;整体改造成本高，难以适配运用到Go网关中&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p cid=&quot;n81&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;Netpoll的场景说明：&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n82&quot; mdtype=&quot;paragraph&quot;&gt;&lt;/p&gt;&lt;p cid=&quot;n82&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;另一方面，开源社区目前缺少专注于RPC方案的Go网络库。类似的项目如：&lt;/span&gt;&lt;span&gt;evio，&lt;/span&gt;&lt;span&gt;gnet&lt;/span&gt;&lt;span&gt;等，均面向&lt;/span&gt;&lt;span&gt;Redis，&lt;/span&gt;&lt;span&gt;HAProxy&lt;/span&gt;&lt;span&gt;这样的场景。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;h3 cid=&quot;n84&quot; mdtype=&quot;heading&quot;&gt;&lt;span&gt;（二）总体分层设计&lt;/span&gt;&lt;/h3&gt;&lt;p cid=&quot;n85&quot; mdtype=&quot;paragraph&quot;&gt;&lt;/p&gt;&lt;p cid=&quot;n85&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;终于到了实现部分，我们先看一个Reactor库的总体分层设计，总体分为三层：应用层、连接层和基础层。&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n86&quot; mdtype=&quot;paragraph&quot;&gt;&lt;/p&gt;&lt;p cid=&quot;n86&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;应用层就是常见的EchoServer、HTTPServer、TLSServer和GRPCServer等等，主要负责协议解析、执行业务逻辑，对应Reactor模型里边的EventHandler。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.8713592233009708&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/VY8SELNGe95VxoqjGm1IfuicBMt3YLNVklaicib2fx64QxxIAdACXpPxObAGPNxiasnanGzgVlRoUKux462Unibb6pA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;412&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在Reactor模型中，应用层会实现事件处理的接口，等待连接层调用。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;sql&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;// &lt;span class=&quot;code-snippet__keyword&quot;&gt;Handler&lt;/span&gt; Core 注册接口&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;type&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;Handler&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;interface&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  OnOpen(c *&lt;span class=&quot;code-snippet__keyword&quot;&gt;Conn&lt;/span&gt;)              // happen &lt;span class=&quot;code-snippet__keyword&quot;&gt;on&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;accept&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;conn&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  OnClose(c *&lt;span class=&quot;code-snippet__keyword&quot;&gt;Conn&lt;/span&gt;, err &lt;span class=&quot;code-snippet__keyword&quot;&gt;error&lt;/span&gt;)  // happen ob &lt;span class=&quot;code-snippet__keyword&quot;&gt;delete&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;conn&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  OnData(c *&lt;span class=&quot;code-snippet__keyword&quot;&gt;Conn&lt;/span&gt;, &lt;span class=&quot;code-snippet__keyword&quot;&gt;data&lt;/span&gt; []&lt;span class=&quot;code-snippet__keyword&quot;&gt;byte&lt;/span&gt;) // happen &lt;span class=&quot;code-snippet__keyword&quot;&gt;on&lt;/span&gt; epoll &lt;span class=&quot;code-snippet__keyword&quot;&gt;wait&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  OnStop()&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p cid=&quot;n90&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;比如当连接建立后，可以调用OnOpen函数做些初始化逻辑，当连接上有新数据到来，可以调用OnData函数完成具体的协议解析和业务逻辑。&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n91&quot; mdtype=&quot;paragraph&quot;&gt;&lt;/p&gt;&lt;p cid=&quot;n91&quot; mdtype=&quot;paragraph&quot;&gt;&lt;/p&gt;&lt;h3 cid=&quot;n92&quot; mdtype=&quot;heading&quot;&gt;&lt;span&gt;（三）连接层设计&lt;/span&gt;&lt;/h3&gt;&lt;p cid=&quot;n93&quot; mdtype=&quot;paragraph&quot;&gt;&lt;/p&gt;&lt;p cid=&quot;n93&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;连接层就是整个Reactor模型的核心，根据上文的主从Reactor多线程模型，连接层主要有两种Reactor，一主（Main Reactor）多从（Sub Reactor），也可以多主多从。&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n94&quot; mdtype=&quot;paragraph&quot;&gt;&lt;/p&gt;&lt;p cid=&quot;n94&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;Main Reactor主要负责监听和接收连接，接着分配连接，它里边有个for循环，不断去accept新连接，这里的方法可以叫做acceptorLoop；Sub Reactor拿到Main Reactor分配的连接，它也是个for循环，一直等待着读写事件到来，然后干活，即回调应用层执行具体业务逻辑，它的方法可以叫做readWriteLoop。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-croporisrc=&quot;https://mmbiz.qpic.cn/mmbiz_png/VY8SELNGe95VxoqjGm1IfuicBMt3YLNVkdy1HIXVmJaJOOW81uErKViaCc7ibYRVBxJRDqrguTjWfbZjPF0Hm4EIg/0?wx_fmt=png&quot; data-cropx1=&quot;0&quot; data-cropx2=&quot;459&quot; data-cropy1=&quot;0&quot; data-cropy2=&quot;343&quot; data-ratio=&quot;0.7450980392156863&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/VY8SELNGe95VxoqjGm1IfuicBMt3YLNVk16Re7kEH8xyX7AjKIaS2ib8YVSiaZ8DLwiax869kPvZCaD1Fn0D4w8yDA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;459&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p cid=&quot;n96&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;根据连接层的工作安排，可以发现我们需要以下三个数据结构：&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n99&quot; mdtype=&quot;paragraph&quot;&gt;&lt;/p&gt;&lt;p cid=&quot;n101&quot; mdtype=&quot;paragraph&quot;&gt;&lt;/p&gt;&lt;p cid=&quot;n103&quot; mdtype=&quot;paragraph&quot;&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.7011070110701108&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/VY8SELNGe95VxoqjGm1IfuicBMt3YLNVkof2K8yvYWufBvFJZLF9AmkgaLjwXq4t6WV98jJCUdM2icm1RKBIgr5w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;542&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p cid=&quot;n107&quot; mdtype=&quot;paragraph&quot;&gt;&lt;/p&gt;&lt;p cid=&quot;n107&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;每个连接都会与一个fd绑定，当某个连接关闭后，它会释放掉fd，供新连接绑定，这也叫&lt;/span&gt;&lt;span&gt;fd的复用&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n108&quot; mdtype=&quot;paragraph&quot;&gt;&lt;/p&gt;&lt;p cid=&quot;n108&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;通常我们的应用层会在一个协程池中执行它的业务逻辑，在连接层有个Sub Reactor在处理这个连接上的读写事件。&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n109&quot; mdtype=&quot;paragraph&quot;&gt;&lt;/p&gt;&lt;p cid=&quot;n109&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;如果在应用层那边关闭了连接，而在Sub Reactor那边刚好在准备读这个连接上的数据，即操作这个fd。&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n110&quot; mdtype=&quot;paragraph&quot;&gt;&lt;/p&gt;&lt;p cid=&quot;n110&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;当Sub Reactor还没来得及读，但被应用层关闭释放掉的fd，已经给到了一个新连接，这时Sub Reactor继续读这个fd上的数据，就会把新连接的数据读走。&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n111&quot; mdtype=&quot;paragraph&quot;&gt;&lt;/p&gt;&lt;p cid=&quot;n111&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;因此，我们需要&lt;/span&gt;&lt;span&gt;针对fd的操作前后加个锁，即在关闭连接跟在连接上读写前先上锁，关闭后才释放掉锁，并且在连接上读写前判断连接是否关闭&lt;/span&gt;&lt;span&gt;，这样才会避免脏数据。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.5161290322580645&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/VY8SELNGe95VxoqjGm1IfuicBMt3YLNVkdM75PtfgXF1mp9IHcUZuKZPdzGicmOLHMdibqnUF2jic4njckNKAYU6iaA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;434&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.35233160621761656&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/VY8SELNGe95VxoqjGm1IfuicBMt3YLNVkg8j3Kte9fFPQgrTfkibf0xlCLkARz5cTdA5GDDzrRicXcruJrlsEuic6A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;579&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p cid=&quot;n115&quot; mdtype=&quot;paragraph&quot;&gt;&lt;/p&gt;&lt;p cid=&quot;n115&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;除了注意fd复用带来的竞态，还有一个不可忽略的负载均衡，在Main Reactor分配连接到Sub Reactor这个环节。&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n116&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n116&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;未来避免某个Sub Reactor过载，我们可以参考Nginx的负载均衡策略，大概有以下三种方式：&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n119&quot; mdtype=&quot;paragraph&quot;&gt;&lt;/p&gt;&lt;p cid=&quot;n121&quot; mdtype=&quot;paragraph&quot;&gt;&lt;/p&gt;&lt;p cid=&quot;n123&quot; mdtype=&quot;paragraph&quot;&gt;&lt;/p&gt;&lt;p cid=&quot;n124&quot; mdtype=&quot;paragraph&quot;&gt;&lt;/p&gt;&lt;p cid=&quot;n124&quot; mdtype=&quot;paragraph&quot;&gt;&lt;/p&gt;&lt;h3 cid=&quot;n125&quot; mdtype=&quot;heading&quot;&gt;&lt;span&gt;（四）基础层设计&lt;/span&gt;&lt;/h3&gt;&lt;p cid=&quot;n126&quot; mdtype=&quot;paragraph&quot;&gt;&lt;/p&gt;&lt;p cid=&quot;n126&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;Reactor的核心的活都在连接层干完了，&lt;/span&gt;&lt;span&gt;基础层的作用是提供底层系统调用支持及做好内存管理&lt;/span&gt;&lt;span&gt;。&lt;span/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n127&quot; mdtype=&quot;paragraph&quot;&gt;&lt;/p&gt;&lt;p cid=&quot;n127&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;系统调用就是常见的&lt;/span&gt;&lt;span&gt;listen/accept/read/write/epoll_create/epoll_ctl/epoll_wait&lt;/span&gt;&lt;span&gt;等，这里不展开。但内存管理的方式会极大地影响网络库的性能。&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n128&quot; mdtype=&quot;paragraph&quot;&gt;&lt;/p&gt;&lt;p cid=&quot;n128&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;笔者曾经在处理连接上读事件的时候，先是用动态内存池的方式提供临时Buffer承接，对比使用固定Buffer去承接，前者需要一借一还，在某个简单Echo场景下压测，后者较前者提升了12wQPS，恐怖如斯。&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n128&quot; mdtype=&quot;paragraph&quot;&gt;&lt;/p&gt;&lt;p cid=&quot;n128&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;以下是常见的内存管理方案，针对连接上读写处理时的内存使用优劣对比：&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n132&quot; mdtype=&quot;paragraph&quot;&gt;&lt;/p&gt;&lt;p cid=&quot;n133&quot; mdtype=&quot;paragraph&quot;&gt;&lt;/p&gt;&lt;p cid=&quot;n133&quot; mdtype=&quot;paragraph&quot;&gt;&lt;/p&gt;&lt;p cid=&quot;n135&quot; mdtype=&quot;paragraph&quot;&gt;&lt;/p&gt;&lt;p cid=&quot;n135&quot; mdtype=&quot;paragraph&quot;&gt;&lt;/p&gt;&lt;p cid=&quot;n135&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n135&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;读写分离，节省内存，但频繁扩容有性能损耗（扩容时需要搬迁老数据到新RingBuffer上）&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n137&quot; mdtype=&quot;paragraph&quot;&gt;&lt;/p&gt;&lt;p cid=&quot;n137&quot; mdtype=&quot;paragraph&quot;&gt;&lt;/p&gt;&lt;p cid=&quot;n138&quot; mdtype=&quot;paragraph&quot;&gt;&lt;/p&gt;&lt;p cid=&quot;n138&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n138&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n139&quot; mdtype=&quot;paragraph&quot;&gt;&lt;/p&gt;&lt;p cid=&quot;n140&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;这里最理想的是第三种内存管理方案，字节的netpoll有实现。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.47651006711409394&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/VY8SELNGe95VxoqjGm1IfuicBMt3YLNVkJteDhzuYhnPkVLqFbahww6gib69D1DlpU91uWNjL15qIcdk6cusf60g/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;596&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;这里引用某个项目的实现说明，&lt;/span&gt;&lt;span&gt;NoCopy体现在连接层读到的数据，可以不用拷贝给应用层使用，而是让应用层引用LinkBuffer使用&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p cid=&quot;n144&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;首先来讲零拷贝读取接口，我们将读取操作分成了「引用读」「释放」两个步骤，「引用读」会把 Linked Buffer 中一定长度的字节数组以指针的形式取出，用户使用完这些数据后，主动执行「释放」告知 Linked Buffer 刚刚「引用读」的数据空间不会再被使用，可以释放掉，被「释放」了的数据不能再被读取和修改。&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n145&quot; mdtype=&quot;paragraph&quot;&gt;&lt;/p&gt;&lt;p cid=&quot;n145&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;零拷贝写入接口则是将用户传入的字节数组构造成一个个节点，每个节点里包含了字节数组的指针，再将这些节点添加到Linked Buffer中，自始至终都是对字节数组的指针进行操作，没有任何的拷贝行为。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;h3 cid=&quot;n148&quot; mdtype=&quot;heading&quot;&gt;&lt;span&gt;（五）性能测试&lt;/span&gt;&lt;/h3&gt;&lt;p cid=&quot;n149&quot; mdtype=&quot;paragraph&quot;&gt;&lt;/p&gt;&lt;p cid=&quot;n149&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;以上3小节就是一个Reactor网络库的框架和实现设计，流程并不复杂，笔者认为&lt;/span&gt;&lt;span&gt;真正考验的是基于Reactor库去实现常见的HTTP/1.x协议、TLS协议甚至HTTP/2.0协议等等&lt;/span&gt;&lt;span&gt;，笔者在实现HTTP/1.x的时候就试了很多开源解析器，很多性能都不尽人意；在尝试直接使用Go官方自带的TLS协议解析器，发现TLS四次握手并不是连续的包，第三次握手时，客户端发送的信息可以等一会...大部分问题都比较棘手，这估计也是很多开源库没有实现这些协议的原因吧~&lt;/span&gt;&lt;/p&gt;&lt;h4 cid=&quot;n150&quot; mdtype=&quot;heading&quot;&gt;&lt;br/&gt;&lt;/h4&gt;&lt;p cid=&quot;n151&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n151&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;在开发完Reactor网络库及在这个库的基础上实现常见的应用层协议后，我们需要一波压测检验网络库的性能。&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n152&quot; mdtype=&quot;paragraph&quot;&gt;&lt;/p&gt;&lt;p cid=&quot;n152&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;区别于网上大部分开源库只做简单的Echo压测，笔者这里构建了两种场景压测：&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n155&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n157&quot; mdtype=&quot;paragraph&quot;&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;properties&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__attr&quot;&gt;sum&lt;/span&gt; :&lt;span class=&quot;code-snippet__string&quot;&gt;= 0&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__attr&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;code-snippet__string&quot;&gt;i := 0; i &amp;lt; 100000; i++ {&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__attr&quot;&gt;sum&lt;/span&gt; &lt;span class=&quot;code-snippet__string&quot;&gt;+= i&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__attr&quot;&gt;}&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p cid=&quot;n160&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;最终的结果如下4张图，可以忽略字节netpoll的数据，大概是因为这两种场景并不是netpoll的目标场景，即RPC场景，所以压测的姿势大概率不对。&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n161&quot; mdtype=&quot;paragraph&quot;&gt;&lt;/p&gt;&lt;p cid=&quot;n161&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;Echo场景下是4核机器跑的EchoServer，HTTP场景下是8核跑的HTTPServer&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n162&quot; mdtype=&quot;paragraph&quot;&gt;&lt;/p&gt;&lt;p cid=&quot;n162&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;图1：Echo场景下，固定1KB数据包，不断增加连接数。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.2582697201017812&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/VY8SELNGe95VxoqjGm1IfuicBMt3YLNVkBp1dHE4vic8pYZ0Uv75RyTz91LdcpPQQBMIfh1nIFmYvdzKtRDX45Kw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;786&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;图2：Echo场景下，固定1K连接数，不断增加数据包大小。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.24634146341463414&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/VY8SELNGe95VxoqjGm1IfuicBMt3YLNVkowZVReT8SO9fFBNdUUjVJPJ214y9VibOa7alSIv03vYySQA5ias6FvrA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;820&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;图3和图4：HTTP场景下，固定1KB数据包，不断增加连接数，QPS和内存占用情况。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;1.1347248576850095&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/VY8SELNGe95VxoqjGm1IfuicBMt3YLNVkic5sN89dfBMgecskMW3agWLkuQpOzIf5xIDfbyUpB7ty0kxn2WZIlmQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;527&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p cid=&quot;n170&quot; mdtype=&quot;paragraph&quot;&gt;&lt;/p&gt;&lt;p cid=&quot;n170&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;通过压测结果，可以看出大部分压测，Go原生网络库都没有什么拉胯表现，&lt;/span&gt;&lt;span&gt;只有在连接数上去了之后，或者需要处理的数据包越来越大的情况下，Go原生网络库才逐渐显示出颓势&lt;/span&gt;&lt;span&gt;。尤其是当连接上到30w到50w之后，Go原生网络库的内存开销增大的同时，伴随的GC时间也变长，到50w连接的时候，一波强制GC服务就down了。&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n171&quot; mdtype=&quot;paragraph&quot;&gt;&lt;/p&gt;&lt;p cid=&quot;n171&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;这是Go原生网络库在50w连接时，强制GC后Down掉时的详情：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;properties&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__attr&quot;&gt;GC&lt;/span&gt; &lt;span class=&quot;code-snippet__string&quot;&gt;forced&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__attr&quot;&gt;gc&lt;/span&gt; &lt;span class=&quot;code-snippet__string&quot;&gt;13 @146.006s 0%: 0.12+105+0.004 ms clock, 0.99+0/207/620+0.033 ms cpu, 5877-&amp;gt;5877-&amp;gt;4197 MB, 7006 MB goal, 8 P&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__attr&quot;&gt;gc&lt;/span&gt; &lt;span class=&quot;code-snippet__string&quot;&gt;14 @197.643s 1%: 0.084+1084+0.061 ms clock, 0.67+5299/2139/1.8+0.49 ms cpu, 8187-&amp;gt;8218-&amp;gt;4825 MB, 8394 MB goal, 8 P&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__attr&quot;&gt;gc&lt;/span&gt; &lt;span class=&quot;code-snippet__string&quot;&gt;15 @220.972s 1%: 4.1+1057+0.039 ms clock, 33+5215/2087/0+0.31 ms cpu, 9412-&amp;gt;9442-&amp;gt;4794 MB, 9651 MB goal, 8 P&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__attr&quot;&gt;GC&lt;/span&gt; &lt;span class=&quot;code-snippet__string&quot;&gt;forced&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;这是Reactor网络库(wnet) 100w连接时，依然坚挺的GC详情：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;properties&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__attr&quot;&gt;gc&lt;/span&gt; &lt;span class=&quot;code-snippet__string&quot;&gt;23 @208.600s 1%: 0.20+374+0.090 ms clock, 1.6+233/723/0+0.72 ms cpu, 873-&amp;gt;891-&amp;gt;450MB, 896 MB goal, 8 P&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__attr&quot;&gt;gc&lt;/span&gt; &lt;span class=&quot;code-snippet__string&quot;&gt;24 @213.872s 1%: 0.18+419+0.051 ms clock, 1.5+4.8/830/0+0.41 ms cpu, 878-&amp;gt;899-&amp;gt;453MB, 900 MB goal, 8 P&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__attr&quot;&gt;gc&lt;/span&gt; &lt;span class=&quot;code-snippet__string&quot;&gt;25 @219.270s 1%: 1.2+403+0.071 ms clock, 10+160/790/0+0.57 ms cpu, 884-&amp;gt;907-&amp;gt;454 MB,907 MB goal, 8 P&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__attr&quot;&gt;gc&lt;/span&gt; &lt;span class=&quot;code-snippet__string&quot;&gt;26 @224.601s 1%: 0.12+425+0.056 ms clock, 1.0+112/849/0+0.44 ms cpu, 885-&amp;gt;906-&amp;gt;452MB, 908 MB goal, 8 P&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__attr&quot;&gt;gc&lt;/span&gt; &lt;span class=&quot;code-snippet__string&quot;&gt;27 @229.851s 1%: 0.20+424+0.079 ms clock, 1.6+107/836/0+0.63 ms cpu, 881-&amp;gt;903-&amp;gt;453MB, 904 MB goal, 8 P&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__attr&quot;&gt;gc&lt;/span&gt; &lt;span class=&quot;code-snippet__string&quot;&gt;28 @235.256s 1%: 0.17+431+0.038 ms clock, 1.4+77/863/0+0.30 ms cpu, 884-&amp;gt;907-&amp;gt;454MB, 907 MB goal, 8 P&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__attr&quot;&gt;gc&lt;/span&gt; &lt;span class=&quot;code-snippet__string&quot;&gt;29 @240.622s 1%: 0.15+402+0.039 ms clock, 1.2+117/804/0+0.31 ms cpu, 885-&amp;gt;907-&amp;gt;452MB, 908 MB goal, 8 P&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__attr&quot;&gt;GC&lt;/span&gt; &lt;span class=&quot;code-snippet__string&quot;&gt;forced&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p cid=&quot;n176&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;因此，综合来看，大部分应用场景，Go原生网络库就可以满足。相比Reactor网络库而言，&lt;/span&gt;&lt;span&gt;Go原生网络库可以看作是以空间（内存、runtime）来换取时间（高吞吐量和低延时）。当空间紧张时，也就是连接数上来后，巨大的内存开销和相应的GC会导致服务不可用，而这种海量连接场景才是Reactor网络库的优势所在&lt;/span&gt;&lt;span&gt;。比如电商大促等活动型场景，有预期的流量高峰，在高峰期会有海量的连接，海量的请求；还有一种直播弹幕、消息推送等长连接场景，也是有大量的长连接。&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n177&quot; mdtype=&quot;paragraph&quot;&gt;&lt;/p&gt;&lt;p cid=&quot;n177&quot; mdtype=&quot;paragraph&quot;&gt;&lt;/p&gt;&lt;section mpa-from-tpl=&quot;t&quot; data-mpa-template=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;span&gt;&lt;strong mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;四、后记&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p data-lines=&quot;1&quot; data-type=&quot;p&quot; data-sign=&quot;8c2011fe7977c79c57258f08c7c970ac1&quot;&gt;&lt;/p&gt;&lt;p cid=&quot;n179&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;本文的最终实现项目并未开源，读者朋友可以结合上述流程翻阅类似的开源实现，比如&lt;/span&gt;&lt;span&gt;gnet&lt;/span&gt;&lt;span&gt;、&lt;/span&gt;&lt;span&gt;gev&lt;/span&gt;&lt;span&gt;等项目理解Reactor网络库的设计，并基于第三部分的设计内容重构这些开源项目，相信读者朋友会做出更好的网络库。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section mpa-from-tpl=&quot;t&quot; data-mpa-template=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;span&gt;&lt;strong mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt; 作者简介&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;105&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;105&quot; data-fileid=&quot;100044396&quot; data-ratio=&quot;1&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/VY8SELNGe95VxoqjGm1IfuicBMt3YLNVkNMEBFSZ6WrTyDpr5Aulty8sCr0PdPALqptUjyHr1vdotXaWTZz5vQQ/640?wx_fmt=png&quot; data-type=&quot;jpeg&quot; data-w=&quot;224&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;strong&gt;刘祥裕&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;span&gt;&lt;span/&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;腾讯后台开发工程师&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span/&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot; viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;span&gt;腾讯后台工程师，目前主要负责电竞赛事相关服务开发。&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;hr/&gt;&lt;p&gt;&lt;strong&gt;推荐阅读&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-darkmode-bgcolor-15906318746582=&quot;rgb(36, 36, 36)&quot; data-darkmode-original-bgcolor-15906318746582=&quot;rgb(255, 255, 255)&quot; data-style=&quot;width: 30px; height: 30px; background-color: rgb(255, 255, 255); box-shadow: rgb(87, 187, 255) -7px -7px 0px; margin-left: 7px;&quot;&gt;&lt;span&gt;&lt;strong&gt;福利&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section data-darkmode-bgcolor-15906318746582=&quot;rgb(36, 36, 36)&quot; data-darkmode-original-bgcolor-15906318746582=&quot;rgb(255, 255, 255)&quot; data-style=&quot;width: 30px; height: 30px; background-color: rgb(255, 255, 255); box-shadow: rgb(87, 187, 255) -7px -7px 0px; margin-left: 7px;&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;section data-darkmode-bgcolor-15906318746582=&quot;rgb(36, 36, 36)&quot; data-darkmode-original-bgcolor-15906318746582=&quot;rgb(255, 255, 255)&quot; data-style=&quot;width: 30px; height: 30px; background-color: rgb(255, 255, 255); box-shadow: rgb(87, 187, 255) -7px -7px 0px; margin-left: 7px;&quot;&gt;&lt;span/&gt;&lt;span&gt;我为大家整理了一份&lt;/span&gt;&lt;span&gt;从入门到进阶的Go学习资料礼包&lt;/span&gt;&lt;span&gt;，包含学习建议：入门看什么，进阶看什么。&lt;/span&gt;&lt;span&gt;关注公众号 「polarisxu」，回复 &lt;/span&gt;&lt;strong&gt;&lt;span&gt;ebook&lt;/span&gt;&lt;/strong&gt;&lt;span&gt; 获取；还可以回复「&lt;strong&gt;进群&lt;/strong&gt;」，和数万 Gopher 交流学习。&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-galleryid=&quot;&quot; data-ratio=&quot;1&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/UWba2ryLMqm8cgtrMXjG1BLGg46vQNmUompBL02uYYwic9RicPbCnlKdZiacBF5Wv6RLgmGIqnBnwuWyP82ibYusiag/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;258&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span/&gt;&lt;/span&gt;&lt;/p&gt;&lt;/div&gt;

          
        &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>416b059808602e666c7159a17f8cc7cf</guid>
<title>架构师劝退指南</title>
<link>https://toutiao.io/k/w4olo9z</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;大家好，我是互联网架构师！&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;span&gt;今天是国庆节，祝大家国庆节快乐！&lt;/span&gt;&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;今天我们聊聊如何成为架构师，架构师从入门到放弃&lt;/span&gt;&lt;strong&gt;&lt;span/&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;如果你的未来职业目标是架构师，&lt;/span&gt;&lt;span&gt;强烈建议仔细阅读并收藏。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section yne-bulb-block=&quot;paragraph&quot;&gt;&lt;section yne-bulb-block=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;“&lt;/span&gt;&lt;span&gt;&lt;strong&gt;我怎么才能成为一个软件架构师&lt;/strong&gt;？&lt;/span&gt;&lt;span&gt;”&lt;/span&gt;&lt;/strong&gt;&lt;span/&gt;&lt;/p&gt;&lt;/section&gt;&lt;section yne-bulb-block=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;这是很多小伙伴问我的一个问题，最近看到&lt;/span&gt;&lt;span&gt;Kai Niklas讲架构师的一篇文章，其中的真知灼见引起了我的强烈共鸣，尤其是&lt;span&gt;后面的非技术部分&lt;/span&gt;。翻译过来（略有删减），分享给大家。英文文章请点击”阅读原文“。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;我事先给一位同学看了一下，他说：当个架构师太难了吧，又要精通技术，还得会沟通，平衡，营销..... 我还是争取做个技术专家吧！&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;扪心自问，我这个架构师在很多方面也做得远远不够，继续学习吧！&lt;/span&gt;&lt;span/&gt;&lt;span&gt;如果你的未来职业目标是架构师，&lt;/span&gt;&lt;span&gt;强烈建议仔细阅读并收藏。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section yne-bulb-block=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section yne-bulb-block=&quot;heading&quot; yne-bulb-level=&quot;2&quot;&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;98318&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;0&lt;span data-original-title=&quot;&quot; title=&quot;&quot;&gt;1&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-brushtype=&quot;text&quot; hm_fix=&quot;293:204&quot;&gt;什么是软件架构师&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section yne-bulb-block=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在我们一头扎入细节之前，我们先得知道软件架构和架构师到底是什么：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section yne-bulb-block=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;span&gt;软件架构师&lt;/span&gt;&lt;span&gt;是一个软件专家，他可以做出高层的设计决定，规定技术标准，包括编码标准，工具和平台 -- Wikipedia&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section yne-bulb-block=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;span&gt;软件架构&lt;/span&gt;&lt;span&gt;是一个系统最基本的组织方式，由其组件，组件之间的关系，组件和环境的关系表达出来。也包括决定设计和系统演化的原则。--Handbook of Software Architecture&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section yne-bulb-block=&quot;heading&quot; yne-bulb-level=&quot;2&quot;&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;98318&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;0&lt;span data-original-title=&quot;&quot; title=&quot;&quot; data-num=&quot;2&quot;&gt;2&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-brushtype=&quot;text&quot; hm_fix=&quot;232:200&quot;&gt;架构的级别&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section yne-bulb-block=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;架构可以在不同的抽象级别上完成， 不同的级别要求不同技能，有很多分类标准，我最喜欢的是这三个级别：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section yne-bulb-block=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;Application Level （应用级别）&lt;/span&gt;：架构的最低级别，专注于单个应用，有非常具体的设计，沟通通常局限在开发团队&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section yne-bulb-block=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;Solution Level （解决方案级别）&lt;/span&gt; ：架构的中间层，需要关注几个应用来实现一个商业的需求，有部分高层的设计，但大多数还是具体的设计，沟通需要跨越多个开发团队。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section yne-bulb-block=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;Enterprise Level (企业级别)&lt;/span&gt;：架构的最高级， 关注多个解决方案，这一层的设计比较抽象，需要解决方案架构师和应用架构师去细化。沟通跨越整个企业组织。&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;section yne-bulb-block=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;有时候，架构师被看作不同利益相关者之间的粘合剂，比如：&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;section yne-bulb-block=&quot;paragraph&quot;&gt;&lt;section&gt;&lt;span&gt;水平方向：在业务人员和开发人员建立沟通的桥梁&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;section yne-bulb-block=&quot;paragraph&quot;&gt;&lt;section&gt;&lt;span&gt;垂直方向：在开发人员和经理之间建立沟通桥梁&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;section yne-bulb-block=&quot;paragraph&quot;&gt;&lt;section&gt;&lt;span&gt;技术领域：集成不同的技术和应用。&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section yne-bulb-block=&quot;heading&quot; yne-bulb-level=&quot;2&quot;&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;98318&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;0&lt;span data-original-title=&quot;&quot; title=&quot;&quot; data-num=&quot;3&quot;&gt;3&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-brushtype=&quot;text&quot; hm_fix=&quot;294:212&quot;&gt;软件架构师的日常活动&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section yne-bulb-block=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;为了理解软件架构师需要哪些技能，我们得先来看看架构师的日常活动&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section yne-bulb-block=&quot;paragraph&quot; data-role=&quot;list&quot;/&gt;&lt;section yne-bulb-block=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;注: 架构设计是一个持续的活动，所以这些活动会一遍一遍地完成。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section yne-bulb-block=&quot;heading&quot; yne-bulb-level=&quot;2&quot;&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;软件架构师所需的重要技能&lt;/span&gt;&lt;/strong&gt;&lt;span/&gt;&lt;/p&gt;&lt;/section&gt;&lt;section yne-bulb-block=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;根据我的经验，阅读的书籍，以及参与的讨论，我可以列出这10个技能，每个架构师都必须具备：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;设计, 决策，简化, 编码, 文档, 沟通, 估算, 平衡, 咨询, 营销&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;section yne-bulb-block=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;我们一个个来说，对每个技能我都会列出一些我的见解，你应该采取的行动，以便在这个技能领域持续提高。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section yne-bulb-block=&quot;heading&quot; yne-bulb-level=&quot;2&quot;&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;98318&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;0&lt;span data-original-title=&quot;&quot; title=&quot;&quot;&gt;4&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-brushtype=&quot;text&quot; hm_fix=&quot;294:208&quot;&gt;设计&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section yne-bulb-block=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;是什么造就了好的设计？这可能是最重要，并且最具挑战性的问题，让我们先从理论开始。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section yne-bulb-block=&quot;paragraph&quot;&gt;&lt;section yne-bulb-block=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;理解基本的设计模式&lt;/span&gt;：为了开发一个可维护的系统，模式绝对是架构师最重要的工具之一，使用模式，你可以复用设计来决定那些通用的问题。“四人帮”的《设计模式：可复用的面向对象软件基础》是每个开发人员的必读书籍。尽管过去20多年了，模式依然是软件架构的基本单元。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section yne-bulb-block=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;span&gt;比如书中描述的MVC模式被应用在很多领域，也是很多新模式如MVVM的基础。&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;section yne-bulb-block=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;深入挖掘模式和反模式：&lt;/span&gt;理解了基本的“四人帮”模式以后，你需要把你知识扩展到更多的软件设计模式中，或者根据自己的兴趣，深入研究，例如Java并发模式。&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;section yne-bulb-block=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在应用程序的集成领域， 我最喜欢的是《企业集成模式》，这本书适用于各种领域，只要两个应用需要交换数据，不管是很古老的基于文件的交换还是现代的微服务架构，都可以参考本书。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1.2807881773399015&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/KyXfCrME6UK14aBIUnRLgwFh137pOCdBrBcDxQSAYiaMzKBNvgY54YWWxDmGGLDAXNW3u98sMkoSd8jo3vzMbXw/640?wx_fmt=png&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; data-type=&quot;png&quot; data-w=&quot;203&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section yne-bulb-block=&quot;image&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section yne-bulb-block=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;了解软件质量的度量方式&lt;/span&gt;：我们希望我们的系统是可以维护的、可靠的、安全的、可以测试的、可以扩展的、可用的...... 为了达成这些目标，必须要把系统架构设计好。你可以参考这个：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.9882352941176471&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/KyXfCrME6UK14aBIUnRLgwFh137pOCdBOBgSOM7xgZPXJY5j15VWibowoGibHs2gKcWR1UeqCyDAl7ZDXjgvVUvQ/640?wx_fmt=png&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; data-w=&quot;340&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;理论很重要，实践更加重要，否则你就会变成一个象牙塔架构师。&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;section yne-bulb-block=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section yne-bulb-block=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;不断尝试和理解不同的技术栈 ：&lt;/span&gt; 我认为这是成为架构师非常重要的事情， 你很难从抽象的PPT中学到真东西，你得尝试不同的、新的技术栈，亲自感受一下它带来的好处和引发的“疼痛”。另外也可以尝试不属于你所在领域的技术，例如你对SAP R/3 非常擅长，那你应该也试试JavaScript。&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;section yne-bulb-block=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;分析、理解那些应用良好的模式&lt;/span&gt;：看看你当前使用的框架，例如Angular， 你可以研究很多以及付诸实践的模式，如观察者。看看它是怎么在框架中使用的，为什么要这么使用。如果你愿意投入更多的精力，那就深入源代码看看它是如何实现的。&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;section yne-bulb-block=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;保持好奇心，参加一些公司之外的社团活动&lt;/span&gt;：比如Java User Group会讨论很多主题，从最底层的编码到高层的架构，我很喜欢这样的活动，因为它会让我跳出工作来思考，并且加强个人社交网络。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section yne-bulb-block=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section yne-bulb-block=&quot;heading&quot; yne-bulb-level=&quot;2&quot;&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;98318&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;strong&gt;0&lt;span data-original-title=&quot;&quot; title=&quot;&quot; data-num=&quot;2&quot;&gt;5&lt;/span&gt;&lt;/strong&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-brushtype=&quot;text&quot; hm_fix=&quot;381:206&quot;&gt;&lt;strong&gt;决策&lt;/strong&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section yne-bulb-block=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;span&gt;架构师需要能够做出架构决定，引导项目和组织走在正确的方向。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section yne-bulb-block=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;span&gt;确定优先级&lt;/span&gt;&lt;span&gt;：有些决策非常关键，如果没有在早期确定下来，就会出现一些变通的临时措施，导致后续难以移除，变成维护的噩梦。更差的情况是，程序员需要停止工作，等你做出决策。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section yne-bulb-block=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;span&gt;为了避免这种情况，必须要把这些决策按优先级排序，我建议看一看敏捷软件开发中非常流行的Weighted Shortest Job First (WSJF) 模型。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section yne-bulb-block=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;了解你的能力&lt;/span&gt;：不要在你的能力之外做决定，这非常关键，如果你不遵循的话可能会毁掉你架构师的岗位。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;所以一定要和你的同伴明确你承担的职责和你的角色。作为低级别的架构师，你可以提出对高层架构的建议，但是不要擅自做主。我建议要经常和同伴审视那些关键的架构决定。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section yne-bulb-block=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;评估多个选项&lt;/span&gt;：涉及到决策时，要列出多个选项。在我参与的大多数决策中，都有不止一个可能（好的）选择。仅仅提供一个选项说明你没有完成自己的工作，没法完成决策。各种选项要通过可以度量的事实（如许可证费用，成熟度）而不是个人感情来比较，这样才能真正完成决策。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section yne-bulb-block=&quot;heading&quot; yne-bulb-level=&quot;2&quot;&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;98318&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;0&lt;span data-original-title=&quot;&quot; title=&quot;&quot; data-num=&quot;3&quot;&gt;6&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-brushtype=&quot;text&quot; hm_fix=&quot;365:214&quot;&gt;简洁&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section yne-bulb-block=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;要谨记解决问题的奥卡姆剃刀原则：&lt;strong&gt;如无必要，勿增实体。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section yne-bulb-block=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;span&gt;对于一个问题，如果你有太多的假设，很可能会走向一个错误的方向，导致不必要的、复杂的解决方案。一定要精简假设来生成好的解决方案。（可见架构工作也是一门艺术）&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section yne-bulb-block=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;“摇动”你的架构设计&lt;/span&gt;：为了让架构设计更加简单，可以从多个角度去审视解决方案，不但要以自顶向下的方式思考，还要自底向上的方式再来一遍， 如果你有数据流或者业务流程，先从左向右看，然后再从右往左看。&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;section yne-bulb-block=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;经常问自己：“在一个理想的环境中，架构设计会是怎么样呢？”   “如果是那些大公司，它们会怎么做呢？” 这些问题会促使你减少假设。&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;section yne-bulb-block=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;退后一步&lt;/span&gt;：经常长时间的密集讨论，通常会得到一个高度复杂的设计，你绝对不能把它们当作最终结果，退后一步，从抽象的级别看看全局的图景，这设计还是有意义的吗？  &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;有时候停止讨论，第二天再继续会有帮助，至少我的大脑需要时间来处理这些信息，然后提出更好的，更优雅的，更简单的方案。&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;section yne-bulb-block=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;分而治之&lt;/span&gt;：将大问题分成小块儿，逐个解决，然后看看小块儿解决方案能不能匹配起来。&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;section yne-bulb-block=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;&lt;span&gt;重构并不邪恶&lt;/span&gt;：如果找不到更好的设计，从一个复杂的解决方案开始也是可以的。如果后面遇到了问题，你需要回过头来再想一想，重构并不是邪恶的，但是再开始重构之前要确保 ：&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;section yne-bulb-block=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;span&gt;(1）足够的自动化的测试用例，保证系统的功能不被破坏&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;section yne-bulb-block=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;span&gt;(2)  获取利益相关者的认可。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section yne-bulb-block=&quot;heading&quot; yne-bulb-level=&quot;2&quot;&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;98318&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;07&lt;/section&gt;&lt;/section&gt;&lt;section data-brushtype=&quot;text&quot; hm_fix=&quot;297:206&quot;&gt;代码&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section yne-bulb-block=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;即使是贵为企业级架构师，也就是抽象级别最高的架构师，你也得知道程序员日常工作在做些什么。否则你会遇到两个问题：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section yne-bulb-block=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;span&gt;(1)  开发人员不会接受你的想法、说辞&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;section yne-bulb-block=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;span&gt;(2)  你不会理解开发人员面临的真正挑战和真正的需要。&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;section yne-bulb-block=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;做一个副业项目&lt;/span&gt;：目的是尝试新的技术和工具，以了解当前和将来的开发方式。阅读一些教程确实不错，但仅仅是“书本”知识。只有自己亲自尝试一遍，体验一遍，你才能获得真正的经验：它为什么好？为什么差？你和一门技术呆的时间越长，你的体验就会越多，就越能帮助你做出好的决策。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section yne-bulb-block=&quot;paragraph&quot;&gt;&lt;section&gt;&lt;span&gt;&lt;span&gt;找到正确的技术来尝试&lt;/span&gt;：你不可能尝试所有的东西，我最近发现了ThoughtWorks的技术雷达，它们把技术，工具，平台，语言和框架分为四类：采用，尝试、评估和保留。&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;section yne-bulb-block=&quot;paragraph&quot;&gt;&lt;section&gt;&lt;span&gt;&lt;span&gt;采用&lt;/span&gt;的意思是“适合企业采用”。&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;section yne-bulb-block=&quot;paragraph&quot;&gt;&lt;section&gt;&lt;span&gt;&lt;span&gt;实验&lt;/span&gt;指的是“企业可以在一个风险可控的项目中尝试”&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;section yne-bulb-block=&quot;paragraph&quot;&gt;&lt;section&gt;&lt;span&gt;&lt;span&gt;评估&lt;/span&gt;的意思是“研究下如果对企业产生影响”&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;section yne-bulb-block=&quot;paragraph&quot;&gt;&lt;section&gt;&lt;span&gt;&lt;span&gt;暂缓&lt;/span&gt;意思是“谨慎推行”&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;section yne-bulb-block=&quot;image&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6461661341853036&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/KyXfCrME6UK14aBIUnRLgwFh137pOCdBEtlDL3alpxke8s2rk1vdc4n7xuYpcric7N6qe4GA8WqH4g9prEd1QoA/640?wx_fmt=jpeg&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; data-type=&quot;jpeg&quot; data-w=&quot;1252&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section yne-bulb-block=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;span&gt;通过这种分类，你就可以找到你想尝试的新技术了。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section yne-bulb-block=&quot;heading&quot; yne-bulb-level=&quot;2&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;98318&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;08&lt;/section&gt;&lt;/section&gt;&lt;section data-brushtype=&quot;text&quot; hm_fix=&quot;316:205&quot;&gt;文档&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section yne-bulb-block=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;Clean Code &lt;/span&gt;：简洁优雅的代码是最好的文档，架构师一定得能区分开什么是好代码，什么是坏代码。有一本很好的书来介绍好代码和坏代码：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/KyXfCrME6UK14aBIUnRLgwFh137pOCdBZiceumnRbDOib6FIbGbNEwf1xR7zQps9u8aiaSpVGtVcud3X7YeaibgiavQ/640?wx_fmt=png&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1.2564814814814815&quot; data-w=&quot;1080&quot; data-backw=&quot;558&quot; data-backh=&quot;701&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;/section&gt;&lt;section yne-bulb-block=&quot;image&quot;&gt;&lt;p&gt;&lt;span class=&quot;js_img_placeholder&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/KyXfCrME6UK14aBIUnRLgwFh137pOCdB1F53RQEvLPnRR2b4uEs6GKPx9RX0kc9iawyFCropxsn964oqg3waydg/640?wx_fmt=gif&quot; data-index=&quot;5&quot;&gt;&lt;span/&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;section yne-bulb-block=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;在可能的时候尽量自动生成文档：&lt;/span&gt;对于一些较为详细的文档，由于系统变化迅速，很难及时更新，所以尽可能自动生成文档：如果你是Model Driven的话可以从定义文件中自动生成文档，SWagger 和RAML都是很好的起点。&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;section yne-bulb-block=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;该多就多，该少就少：&lt;/span&gt;无论是什么文档，在同一时刻只应该把注意力放在一件事情上，只包含这件事情的必要信息，额外的信息应该保留在附录中，因为大量的文字是很难阅读和理解的。 仔细看看你的文档，问问自己：“为了理解整个东西，是不是所有的信息都在其中了？” ,“哪些信息是必须的，哪些是可以忽略的？”&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;section yne-bulb-block=&quot;heading&quot; yne-bulb-level=&quot;2&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;98318&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;09&lt;/section&gt;&lt;/section&gt;&lt;section data-brushtype=&quot;text&quot; hm_fix=&quot;306:198&quot;&gt;沟通&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section yne-bulb-block=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;根据我的观察，这是&lt;span&gt;最被低估技能&lt;/span&gt;，如果你在设计方面特别出色，但是却无法和别人沟通，你的想法就没啥影响力，很可能失败。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section yne-bulb-block=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;演讲&lt;/span&gt;：向一个小组或大组做演讲是一个架构师常见的工作，如果你刚开始觉得不舒服，可以从你的最好的朋友开始，慢慢扩大的更多的人，这件事只能通过不断地实践来学习， 是个需要花费时间的过程，还需要离开舒适区，所以要保持耐心。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section yne-bulb-block=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;找到正确的沟通级别&lt;/span&gt;：不同的人看待事物的角度是不同的，所以你需要在他们的级别和他们交流。比如开发人员对技术细节感兴趣，经理更倾向于知道哪个选项更加省钱。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section yne-bulb-block=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;span&gt;所以在沟通之前，你要看看你想交流的东西是不是在合适的级别，包括抽象度，内容，目标，动机等&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;section yne-bulb-block=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;经常沟通：&lt;/span&gt; 如果无人知晓，一个出色的架构毫无意义，要经常沟通你的架构设计以及背后的想法，定期在每个组织级别（小组，部门，公司）进行沟通，安排和开发人员，架构师，管理人员的会议，展示你的架构思路。&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;section yne-bulb-block=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;保持透明&lt;/span&gt;：定期沟通只能部分缓解缺少的透明度，你还得确保决策背后的原因透明化，特别是对那些不参加决策的过程的人，他们很难理解为什么要这么做，有什么理由。&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;section yne-bulb-block=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;随时准备好做一个演讲&lt;/span&gt;：总会有人问架构师问题，你也想快速地给出正确答案，这该怎么办呢？你可以把最重要的PPT挑出来，放在一起，随时展示并且给他们做展示，避免在一堆资料中找来找去，那样会浪费太多时间。&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;section yne-bulb-block=&quot;heading&quot; yne-bulb-level=&quot;2&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;98318&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;span data-original-title=&quot;&quot; title=&quot;&quot; data-num=&quot;7&quot;&gt;10&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-brushtype=&quot;text&quot; hm_fix=&quot;253:191&quot;&gt;估算和评估&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section yne-bulb-block=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;理解基本的项目管理原则：&lt;/span&gt;作为架构师或者首席开发，你经常会被要求对你的设计进行估算：多长时间能完成？需要多少人？需要什么技能？&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;刚开始，你可以提供粗略的估算：几天，几个月。请记住估算的时间可不仅仅是编码实现，要有需求分析，测试，改正Bug。因此你需要知道软件开发过程中的各个步骤。获得更好估算的一个方法是基于历史数据给出预测。如果你没有历史数据，可以试试COCOMO方法，如果你在做一个敏捷项目，这本书非常有帮助：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1.3722222222222222&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/KyXfCrME6UK14aBIUnRLgwFh137pOCdBBGkxQ4A5bFue048S7aT1SkudKVxRv9ibbS8xlQY9j1QOm8IiabA3ibeibQ/640?wx_fmt=png&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; data-w=&quot;1080&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;/section&gt;&lt;section yne-bulb-block=&quot;image&quot;&gt;&lt;p&gt;&lt;span class=&quot;js_img_placeholder&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/KyXfCrME6UK14aBIUnRLgwFh137pOCdB1F53RQEvLPnRR2b4uEs6GKPx9RX0kc9iawyFCropxsn964oqg3waydg/640?wx_fmt=gif&quot; data-index=&quot;7&quot;&gt;&lt;span/&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;section yne-bulb-block=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;评估架构&lt;/span&gt;：作为一个架构师，你应该能够架构设计在当前和未来上下文中的适应性，这件事不容易，你可以准备一组问题来对架构设计进行“质询”，例如：&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;section yne-bulb-block=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;span&gt;(1) 设计实践: 架构遵循了哪些模式？是否正确地被使用了?是否有清晰的设计和关注点分离?&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;section yne-bulb-block=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;span&gt;(2) 开发实践: 制定代码规范了吗？被遵循了吗？代码有版本控制吗&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;section yne-bulb-block=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;span&gt;(3) 质量保证: 自动化测试的覆盖率如何? 有静态代码分析到位了吗? Peer review做到位了吗?&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;section yne-bulb-block=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;span&gt;(4) 安全: 架构设计中有哪些安全概念? 内置安全性如何? 渗透测试和自动化安全分析是否做到位？是否定期使用？&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;98318&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;11&lt;/section&gt;&lt;/section&gt;&lt;section data-brushtype=&quot;text&quot; hm_fix=&quot;340:186&quot;&gt;平衡&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section yne-bulb-block=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;质量是有代价的&lt;/span&gt;：前面聊过系统质量和非功能性需求，如果你在架构设计上做得过度，就会增加开销，降低开发的速度。你需要平衡架构设计和功能需求，过度设计应该被避免。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section yne-bulb-block=&quot;paragraph&quot;&gt;&lt;section&gt;&lt;span&gt;&lt;span&gt;解决相互矛盾的目标&lt;/span&gt;：一个经典的例子就是短期目标 vs 长期目标。项目通常倾向于构建最简单的方案，而架构师脑海中有长期的愿景。通常，简单的方案不适合长期的目标，并且有可能被丢弃（沉没成本）。为了避免走向错误的方向，应该注意两件事情：&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;section yne-bulb-block=&quot;paragraph&quot;&gt;&lt;section&gt;&lt;span&gt;(1) 开发人员和业务人员都需要理解长期的愿景及其收益。&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;section yne-bulb-block=&quot;paragraph&quot;&gt;&lt;section&gt;&lt;span&gt;(2) 负责预算的经理也需要参与其中，了解财务影响。&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;section yne-bulb-block=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;冲突管理&lt;/span&gt;：由于团队有着不同背景，冲突难免发生，为了找到一个相互能接受的、平衡的解决方案，架构师需要充当粘合剂，来解决这些冲突。关于沟通的理论，我是从Schulze von Thun的Four-Ears Model开始的：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6500437445319335&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/KyXfCrME6UK14aBIUnRLgwFh137pOCdBV4uNmHbFZ1OlvKgegoicUJs4iaWKvJReKSB2tgYuibxTcYZZF78VTp4LA/640?wx_fmt=jpeg&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; data-type=&quot;jpeg&quot; data-w=&quot;1143&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span class=&quot;js_img_placeholder&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/KyXfCrME6UK14aBIUnRLgwFh137pOCdB1F53RQEvLPnRR2b4uEs6GKPx9RX0kc9iawyFCropxsn964oqg3waydg/640?wx_fmt=gif&quot; data-index=&quot;9&quot;&gt;&lt;span/&gt;&lt;/span&gt;&lt;br/&gt;&lt;span/&gt;&lt;/p&gt;&lt;/section&gt;&lt;section yne-bulb-block=&quot;heading&quot; yne-bulb-level=&quot;2&quot;&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;98318&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;12&lt;/section&gt;&lt;/section&gt;&lt;section data-brushtype=&quot;text&quot; hm_fix=&quot;342:211&quot;&gt;咨询和指导&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section yne-bulb-block=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;拥有愿景 ：&lt;/span&gt;不管你是在一个什么样的项目中，不管是传统的瀑布模型还是敏捷模型，你必须需要有一个愿景，也就是你想获得的短期和长期目标，并且清晰地传递给团队成员。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section yne-bulb-block=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;span&gt;由于不可能一下子达成所有的目标，我通常倾向于建立成熟度模型，让团队清楚地得知我们当前处于哪一级别。开发有很多方面，得使用不同的成熟度模型，例如开发实践成熟度模型，持续交付成熟度模型。这些模型的每个级别都有清晰的定义，团队可以轻松地度量自己在什么级别。&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;section yne-bulb-block=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;span&gt;对于持续交付，我个人倾向于这个模型&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6842105263157895&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/KyXfCrME6UK14aBIUnRLgwFh137pOCdBL2zX4lrqwWoia9jFcLZesqpErOH3tNmr7bic2pLCCyQEpefrKqNWONcw/640?wx_fmt=png&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; data-type=&quot;png&quot; data-w=&quot;1083&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img data-ratio=&quot;1&quot; data-type=&quot;gif&quot; data-w=&quot;1&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/KyXfCrME6UK14aBIUnRLgwFh137pOCdB1F53RQEvLPnRR2b4uEs6GKPx9RX0kc9iawyFCropxsn964oqg3waydg/640?wx_fmt=jpeg&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot;/&gt;&lt;br/&gt;&lt;span/&gt;&lt;/p&gt;&lt;/section&gt;&lt;section yne-bulb-block=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;建立社区&lt;/span&gt;：例如，把JavaScript程序员和架构师组织起来，每个月讨论一次，主题可以是如何解决过去和现在的技术挑战，新的技术和方法。架构师可以分享、讨论他们的愿景，程序员可以分享他们的经验，这样的会议能帮助建立一个更强大的团伙，对企业和个人都极具价值。&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;section yne-bulb-block=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;进行开诚布公的讨论&lt;/span&gt;：误解和模棱两可的根源是缺乏沟通，所以你可以安排一个固定的时间段，如每周30分钟，和同伴交换一些热门的话题，什么都可以讨论，不用刻意安排讨论的议程。可以当场解决一些小事，对于复杂的主题，安排后续的跟进。&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;section yne-bulb-block=&quot;heading&quot; yne-bulb-level=&quot;2&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;98318&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;span data-original-title=&quot;&quot; title=&quot;&quot; data-num=&quot;10&quot;&gt;13&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-brushtype=&quot;text&quot; hm_fix=&quot;336:201&quot;&gt;营销&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section yne-bulb-block=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;你的想法很棒，并且和大家做了很好的沟通，但是没人愿意去做，那可能是缺乏了营销的技巧。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section yne-bulb-block=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;激励并说服&lt;/span&gt;：公司是怎么说服你购买他们产品的？他们肯定展示了价值和好处，但不仅如此，他们还做了漂亮的包装，使其尽可能地容易消化&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section yne-bulb-block=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;span&gt;(1) &lt;strong&gt;原型&lt;/strong&gt;：带界面的原型非常直观，会很吸引人。有很多创建软件原型的工具，如果你喜欢SAP的话可以事实build.me ，使用它可以轻松快速地创建漂亮的UI5应用。&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;section yne-bulb-block=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;(2) &lt;strong&gt;视频&lt;/strong&gt;:  除了无聊的PPT之外，用一个视频可以更好地展示你的想法。但是请不要过度营销，从长期看，内容为王，如果你满嘴跑火车，损伤的是你的声誉。&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;section yne-bulb-block=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;捍卫你的想法并且坚持不懈&lt;/span&gt;：如果你真的对自己的想法深信不疑，你应该捍卫它，为之战斗，这是非常必要的，因为具备长期目标的架构决策是不容易被人接受的：开发人员不喜欢它因为开发起来太难， 经理不喜欢它因为短期来看代价太高。所以坚持不懈地去说服是你的本职工作。&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;section yne-bulb-block=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;找到同盟军&lt;/span&gt;：独自去建立并且执行你的想法几乎是不可能的，你需要盟友的支持来说服别人。这时候需要使用你的社交网络，如果你还没有的话，马上去建吧！&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;section yne-bulb-block=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;你可以先去和那些具备开放心态的同事去谈你的想法， 如果他们喜欢（或者部分喜欢），当别人问起的时候，他们很有可能会支持你：X的想法很有趣。  如果他们不喜欢你的想法，问问为什么，你是不是漏掉了什么东西？你的故事不够吸引人？&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;section yne-bulb-block=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;下一步就是找到具备决策权力的盟友，请求他进行一个开放的讨论，如果你害怕这种讨论，你需要反思一下，是不是应该离开舒适区了。&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;section yne-bulb-block=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;重复它，相信它：&lt;/span&gt;研究显示重复的展示一个观点会使人们相信这是一个普遍的观点，即使该观点仅仅来自一个人。如果你经常发过某个消息，更容易说服别人。但是要当心：应该明智地使用这种策略，因为它可能适得其反。&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;br/&gt;&lt;/figure&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>5fb7acf1ce6ff8cb56947d9664c949c0</guid>
<title>性能优化的 10 个技巧！</title>
<link>https://toutiao.io/k/9jopsda</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot; data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;大家好，我是Tom哥。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;提升系统性能，榨干计算机资源是程序员的极致追求。今天跟大家聊聊&lt;span&gt;性能优化。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;分为上中下三篇，由浅及深的写了关于性能优化的方方面面，并不仅仅局限于代码层面，&lt;/span&gt;&lt;span&gt;希望小伙伴们能有所收获。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;上篇&lt;/span&gt;&lt;br/&gt;&lt;/h2&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;/&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;引言：取与舍&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;软件设计开发某种意义上是“取”与“舍”的艺术。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;关于性能方面，就像建筑设计成抗震9度需要额外的成本一样，高性能软件系统也意味着更高的实现成本，有时候与其他质量属性甚至会冲突，比如安全性、可扩展性、可观测性等等。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;大部分时候我们需要的是：在业务遇到瓶颈之前，利用常见的技术手段将系统优化到预期水平。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;那么，性能优化有哪些技术方向和手段呢？&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;性能优化通常是“时间”与“空间”的互换与取舍。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;本篇分两个部分，在上篇，讲解六种通用的“时间”与“空间”互换取舍的手段：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在下篇，介绍四种进阶性的内容，&lt;strong&gt;大多与提升并行能力有关&lt;/strong&gt;：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;八门遁甲 —— 榨干计算资源&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;影分身术 —— 水平扩容&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;奥义 —— 分片术&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;秘术 —— 无锁术&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;每种性能优化的技术手段，&lt;strong&gt;我都找了一张应景的《火影忍者》中人物或忍术的配图&lt;/strong&gt;，评论区答出任意人物或忍术送一颗小星星。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;（注：所有配图来自动漫《火影忍者》，部分图片添加了文字方便理解，仅作技术交流用途）&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;索引术&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.7157001414427157&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ELQw2WCMgt3ExLniatY9Rx4qKZs8ggQ0kWfKFQKGCK68DZmNSd5OzH8K7WoEc10Bv51UwDyRTPzzw8zRGHCvLnA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;707&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;10ms之后。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.7241379310344828&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ELQw2WCMgt3ExLniatY9Rx4qKZs8ggQ0k1yJkks2YgPOWQWFyZTlTBNgQR7BPZ1GdlOLSib9r1S93lydHmkx5Ogg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;580&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;索引的原理是拿额外的存储空间换取查询时间，增加了写入数据的开销，但使读取数据的时间复杂度一般从O(n)降低到O(logn)甚至O(1)。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;索引不仅在数据库中广泛使用，前后端的开发中也在不知不觉运用。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在数据集比较大时，不用索引就像从一本没有目录而且内容乱序的新华字典查一个字，得一页一页全翻一遍才能找到；&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;用索引之后，就像用拼音先在目录中先找到要查到字在哪一页，直接翻过去就行了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;书籍的目录是典型的树状结构，那么软件世界常见的索引有哪些数据结构，分别在什么场景使用呢？&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;哈希表&lt;/strong&gt;（Hash Table）：哈希表的原理可以类比银行办业务取号，给每个人一个号（计算出的Hash值），叫某个号直接对应了某个人，索引效率是最高的O(1)，消耗的存储空间也相对更大。K-V存储组件以及各种编程语言提供的Map/Dict等数据结构，多数底层实现是用的哈希表。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;二叉搜索树&lt;/strong&gt;（Binary Search Tree）：有序存储的二叉树结构，在编程语言中广泛使用的红黑树属于二叉搜索树，确切的说是“不完全平衡的”二叉搜索树。从C++、Java的TreeSet、TreeMap，到Linux的CPU调度，都能看到红黑树的影子。Java的HashMap在发现某个Hash槽的链表长度大于8时也会将链表升级为红黑树，而相比于红黑树“更加平衡”的AVL树反而实际用的更少。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;平衡多路搜索树&lt;/strong&gt;（B-Tree）：这里的B指的是Balance而不是Binary，二叉树在大量数据场景会导致查找深度很深，解决办法就是变成多叉树，MongoDB的索引用的就是B-Tree。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;叶节点相连的平衡多路搜索树&lt;/strong&gt;（B+ Tree）：B+ Tree是B-Tree的变体，只有叶子节点存数据，叶子与相邻叶子相连，MySQL的索引用的就是B+树，Linux的一些文件系统也使用的B+树索引inode。其实B+树还有一种在枝桠上再加链表的变体：B*树，暂时没想到实际应用。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;日志结构合并树&lt;/strong&gt;（LSM Tree）：Log Structured Merge Tree，简单理解就是像日志一样顺序写下去，多层多块的结构，上层写满压缩合并到下层。LSM Tree其实本身是为了优化写性能牺牲读性能的数据结构，并不能算是索引，但在大数据存储和一些NoSQL数据库中用的很广泛，因此这里也列进去了。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;字典树&lt;/strong&gt;（Trie Tree）：又叫前缀树，从树根串到树叶就是数据本身，因此树根到枝桠就是前缀，枝桠下面的所有数据都是匹配该前缀的。这种结构能非常方便的做前缀查找或词频统计，典型的应用有：自动补全、URL路由。其变体基数树（Radix Tree）在Nginx的Geo模块处理子网掩码前缀用了；Redis的Stream、Cluster等功能的实现也用到了基数树（Redis中叫Rax）。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;跳表&lt;/strong&gt;（Skip List）：是一种多层结构的有序链表，插入一个值时有一定概率“晋升”到上层形成间接的索引。跳表更适合大量并发写的场景，不存在红黑树的再平衡问题，Redis强大的ZSet底层数据结构就是哈希加跳表。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;倒排索引&lt;/strong&gt;（Inverted index）：这样翻译不太直观，可以叫“关键词索引”，比如书籍末页列出的术语表就是倒排索引，标识出了每个术语出现在哪些页，这样我们要查某个术语在哪用的，从术语表一查，翻到所在的页数即可。倒排索引在全文索引存储中经常用到，比如ElasticSearch非常核心的机制就是倒排索引；Prometheus的时序数据库按标签查询也是在用倒排索引。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;数据库主键之争&lt;/strong&gt;：自增长 vs UUID。主键是很多数据库非常重要的索引，尤其是MySQL这样的RDBMS会经常面临这个难题：是用自增长的ID还是随机的UUID做主键？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;自增长ID的性能最高，但不好做分库分表后的全局唯一ID，自增长的规律可能泄露业务信息；而UUID不具有可读性且太占存储空间。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;争执的结果就是找一个兼具二者的优点的折衷方案：&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;用雪花算法生成分布式环境全局唯一的ID作为业务表主键，性能尚可、不那么占存储、又能保证全局单调递增，但引入了额外的复杂性，再次体现了取舍之道。&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;再回到数据库中的索引，建索引要注意哪些点呢？&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;定义好主键并尽量使用主键，多数数据库中，主键是效率最高的聚簇索引；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;在Where或Group By、Order By、Join On条件中用到的字段也要按需建索引或联合索引，MySQL中搭配explain命令可以查询DML是否利用了索引；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;类似枚举值这样重复度太高的字段不适合建索引（如果有位图索引可以建），频繁更新的列不太适合建索引；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;单列索引可以根据实际查询的字段升级为联合索引，通过部分冗余达到索引覆盖，以避免回表的开销；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;尽量减少索引冗余，比如建A、B、C三个字段的联合索引，Where条件查询A、A and B、A and B and C&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;都可以利用该联合索引，就无需再给A单独建索引了；根据数据库特有的索引特性选择适合的方案，比如像MongoDB，还可以建自动删除数据的TTL索引、不索引空值的稀疏索引、地理位置信息的Geo索引等等。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;数据库之外，在代码中也能应用索引的思维，比如对于集合中大量数据的查找，使用Set、Map、Tree这样的数据结构，其实也是在用哈希索引或树状索引，比直接遍历列表或数组查找的性能高很多。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;缓存术&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5381165919282511&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ELQw2WCMgt3ExLniatY9Rx4qKZs8ggQ0kZjvNuTaQpdIKZKDFUJwsIuUebicjic3YXYQWG30dI9YSVJYxzyeR8Xibg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;669&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;缓存优化性能的原理和索引一样，是拿额外的存储空间换取查询时间。缓存无处不在，设想一下我们在浏览器打开这篇文章，会有多少层缓存呢？&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;首先解析DNS时，浏览器一层DNS缓存、操作系统一层DNS缓存、DNS服务器链上层层缓存；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;发送一个GET请求这篇文章，服务端很可能早已将其缓存在KV存储组件中了；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;即使没有击中缓存，数据库服务器内存中也缓存了最近查询的数据；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;即使没有击中数据库服务器的缓存，数据库从索引文件中读取，操作系统已经把热点文件的内容放置在Page Cache中了；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;即使没有击中操作系统的文件缓存，直接读取文件，大部分固态硬盘或者磁盘本身也自带缓存；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;数据取到之后服务器用模板引擎渲染出HTML，模板引擎早已解析好缓存在服务端内存中了；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;历经数十毫秒之后，终于服务器返回了一个渲染后的HTML，浏览器端解析DOM树，发送请求来加载静态资源；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;需要加载的静态资源可能因Cache-Control在浏览器本地磁盘和内存中已经缓存了；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;即使本地缓存到期，也可能因Etag没变服务器告诉浏览器304 Not Modified继续缓存；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;即使Etag变了，静态资源服务器也因其他用户访问过早已将文件缓存在内存中了；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;加载的JS文件会丢到JS引擎执行，其中可能涉及的种种缓存就不再展开了；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;整个过程中链条上涉及的&lt;strong&gt;所有的计算机和网络设备&lt;/strong&gt;，执行的热点代码和数据很可能会载入CPU的多级高速缓存。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里列举的&lt;strong&gt;仅仅是一部分&lt;/strong&gt;常见的缓存，就有多种多样的形式：从廉价的磁盘到昂贵的CPU高速缓存，最终目的都是用来换取宝贵的时间。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;既然缓存那么好，那么问题就来了：缓存是“银弹”吗？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;不，Phil Karlton 曾说过：&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;There are only two hard things in Computer Science: cache invalidation and naming things.&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;计算机科学中只有两件困难的事情：缓存失效和命名规范。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;缓存的使用除了带来额外的复杂度以外，还面临如何处理缓存失效的问题。&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;多线程并发编程需要用各种手段（比如Java中的synchronized volatile）防止并发更新数据，一部分原因就是防止线程本地缓存的不一致；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;缓存失效衍生的问题还有：缓存穿透、缓存击穿、缓存雪崩。解决用不存在的Key来穿透攻击，需要用空值缓存或布隆过滤器；解决单个缓存过期后，瞬间被大量恶意查询击穿的问题需要做查询互斥；解决某个时间点大量缓存同时过期的雪崩问题需要添加随机TTL；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;热点数据如果是多级缓存，在发生修改时需要清除或修改各级缓存，这些操作往往不是原子操作，又会涉及各种不一致问题。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;除了通常意义上的缓存外，对象重用的池化技术，也可以看作是一种缓存的变体。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;常见的诸如JVM，V8这类运行时的常量池、数据库连接池、HTTP连接池、线程池、Golang的sync.Pool对象池等等。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在需要某个资源时从现有的池子里直接拿一个，稍作修改或直接用于另外的用途，池化重用也是性能优化常见手段。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;压缩术&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.5297418630751964&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ELQw2WCMgt3ExLniatY9Rx4qKZs8ggQ0kL6HLyiaA0PsFdmcPR6hibE1aJlLZPwMXqdrQicZKt0ib2ibZPSratJibtwaQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;891&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;说完了两个“空间换时间”的，我们再看一个“时间换空间”的办法——压缩。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;压缩的原理消耗计算的时间，换一种更紧凑的编码方式来表示数据。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;为什么要拿时间换空间？时间不是最宝贵的资源吗？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;举一个视频网站的例子，如果不对视频做任何压缩编码，因为带宽有限，巨大的数据量在网络传输的耗时会比编码压缩的耗时多得多。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;对数据的压缩虽然消耗了时间来换取更小的空间存储，但更小的存储空间会在另一个维度带来更大的时间收益。&lt;a target=&quot;_blank&quot; href=&quot;https://mp.weixin.qq.com/s?__biz=Mzg2NzYyNjQzNg==&amp;amp;mid=2247502324&amp;amp;idx=1&amp;amp;sn=d50366d73cbb6af01d04989e430d60f7&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;大厂裁员，我们该怎么办？&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;大厂&lt;/span&gt;&lt;span&gt;裁员，我们该怎么办？&lt;/span&gt;&lt;/a&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个例子本质上是：“&lt;strong&gt;操作系统内核与网络设备处理负担 vs 压缩解压的CPU/GPU负担&lt;/strong&gt;”的权衡和取舍。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们在代码中通常用的是无损压缩，比如下面这些场景:&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;HTTP协议中Accept-Encoding添加Gzip/deflate，服务端对接受压缩的文本（JS/CSS/HTML）请求做压缩，大部分图片格式本身已经是压缩的无需压缩；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;HTTP2协议的头部HPACK压缩；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;JS/CSS文件的混淆和压缩（Uglify/Minify）；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;一些RPC协议和消息队列传输的消息中，采用二进制编码和压缩（Gzip、Snappy、LZ4等等）；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;缓存服务存过大的数据，通常也会事先压缩一下再存，取的时候解压；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;一些大文件的存储，或者不常用的历史数据存储，采用更高压缩比的算法存储；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;JVM的对象指针压缩，JVM在32G以下的堆内存情况下默认开启“UseCompressedOops”，用4个byte就可以表示一个对象的指针，这也是JVM尽量不要把堆内存设置到32G以上的原因；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;MongoDB的二进制存储的BSON相对于纯文本的JSON也是一种压缩，或者说更紧凑的编码。但更紧凑的编码也意味着更差的可读性，这一点也是需要取舍的。纯文本的JSON比二进制编码要更占存储空间但却是REST API的主流，因为数据交换的场景下的可读性是非常重要的。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;信息论告诉我们，无损压缩的极限是信息熵。进一步减小体积只能以损失部分信息为代价，也就是有损压缩。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.23484848484848486&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ELQw2WCMgt3ExLniatY9Rx4qKZs8ggQ0kJmO0sgLuSe9j2CU4vdF6xu5Q2w8QZtEvf15mc4Liap119aAGUGkOO6w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;264&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那么，有损压缩有哪些应用呢？&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;预览和缩略图，低速网络下视频降帧、降清晰度，都是对信息的有损压缩；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;音视频等多媒体数据的采样和编码大多是有损的，比如MP3是利用傅里叶变换，有损地存储音频文件；jpeg等图片编码也是有损的。虽然有像WAV/PCM这类无损的音频编码方式，但多媒体数据的采样本身就是有损的，相当于只截取了真实世界的极小一部分数据；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;散列化，比如K-V存储时Key过长，先对Key执行一次“傻”系列（SHA-1、SHA-256）哈希算法变成固定长度的短Key。另外，散列化在文件和数据验证（MD5、CRC、HMAC）场景用的也非常多，无需耗费大量算力对比完整的数据。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;除了有损/无损压缩，但还有一个办法，就是压缩的极端——从根本上减少数据或彻底删除。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;能减少的就减少：&lt;/strong&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;JS打包过程“摇树”，去掉没有使用的文件、函数、变量；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;开启HTTP/2和高版本的TLS，减少了Round Trip，节省了TCP连接，自带大量性能优化；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;减少不必要的信息，比如Cookie的数量，去掉不必要的HTTP请求头；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;更新采用增量更新，比如HTTP的PATCH，只传输变化的属性而不是整条数据；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;缩短单行日志的长度、缩短URL、在具有可读性情况下用短的属性名等等；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;使用位图和位操作，用风骚的位操作最小化存取的数据。典型的例子有：用Redis的位图来记录统计海量用户登录状态；布隆过滤器用位图排除不可能存在的数据；大量开关型的设置的存储等等。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;能删除的就删除：&lt;/strong&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;删掉不用的数据；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;删掉不用的索引；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;删掉不该打的日志；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;删掉不必要的通信代码，不去发不必要的HTTP、RPC请求或调用，轮询改发布订阅；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;终极方案：砍掉整个功能。&lt;/strong&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;毕竟有位叫做 Kelsey Hightower 的大佬曾经说过：&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;No code is the best way to write secure and reliable applications. Write nothing; deploy nowhere&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;不写代码，是编写安全可靠的应用程序的最佳方式。什么都不写；哪里都不部署。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;预取术&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;预取通常搭配缓存一起用，其原理是在缓存空间换时间基础上更进一步，再加上一次“时间换时间”，也就是：用事先预取的耗时，换取第一次加载的时间。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当可以猜测出以后的某个时间很有可能会用到某种数据时，把数据预先取到需要用的地方，能大幅度提升用户体验或服务端响应速度。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.6365461847389559&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ELQw2WCMgt3ExLniatY9Rx4qKZs8ggQ0kMDB08dA3NogfkHbSiavzdb0zNJlJfRDQv38icL8nhC7c293kiagiaic3Hmg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;996&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;是否用预取模式就像自助餐餐厅与厨师现做的区别，在自助餐餐厅可以直接拿做好的菜品，一般餐厅需要坐下来等菜品现做。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那么，预取在哪些实际场景会用呢？&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;视频或直播类网站，在播放前先缓冲一小段时间，就是预取数据。有的在播放时不仅预取这一条数据，甚至还会预测下一个要看的其他内容，提前把数据取到本地；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;HTTP/2 Server Push，在浏览器请求某个资源时，服务器顺带把其他相关的资源一起推回去，HTML/JS/CSS几乎同时到达浏览器端，相当于浏览器被动预取了资源；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;一些客户端软件会用常驻进程的形式，提前预取数据或执行一些代码，这样可以极大提高第一次使用的打开速度；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;服务端同样也会用一些预热机制，一方面热点数据预取到内存提前形成多级缓存；另一方面也是对运行环境的预热，载入CPU高速缓存、热点函数JIT编译成机器码等等；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;热点资源提前预分配到各个实例，比如：秒杀、售票的库存性质的数据；分布式唯一ID等等&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;天上不会掉馅饼，&lt;strong&gt;预取也是有副作用的&lt;/strong&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;正如烤箱预热需要消耗时间和额外的电费，在软件代码中做预取/预热的副作用通常是启动慢一些、占用一些闲时的计算资源、可能取到的不一定是后面需要的。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;削峰填谷术&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.6816143497757847&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ELQw2WCMgt3ExLniatY9Rx4qKZs8ggQ0kgaASddBH03micDFXicMxCS6gNibP8dT9pgOtiaN9x5ia37WSu64M5tMqqQQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;892&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;削峰填谷的原理也是“时间换时间”，谷时换峰时。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;削峰填谷与预取是反过来的：预取是事先花时间做，削峰填谷是事后花时间做。就像三峡大坝可以抗住短期巨量洪水，事后雨停再慢慢开闸防水。软件世界的“削峰填谷”是类似的，只是不是用三峡大坝实现，而是用消息队列、异步化等方式。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;常见的有这几类问题，我们分别来看每种对应的解决方案：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;针对前端、客户端的启动优化或首屏优化&lt;/strong&gt;：代码和数据等资源的延时加载、分批加载、后台异步加载、或按需懒加载等等。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;背压控制 - 限流、节流、去抖等等&lt;/strong&gt;。一夫当关，万夫莫开，从入口处削峰，防止一些恶意重复请求以及请求过于频繁的爬虫，甚至是一些DDoS攻击。简单做法有网关层根据单个IP或用户用漏桶控制请求速率和上限；前端做按钮的节流去抖防止重复点击；网络层开启TCP SYN Cookie防止恶意的SYN洪水攻击等等。彻底杜绝爬虫、黑客手段的恶意洪水攻击是很难的，DDoS这类属于网络安全范畴了。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;针对正常的业务请求洪峰，用消息队列暂存再异步化处理&lt;/strong&gt;：常见的后端消息队列Kafka、RocketMQ甚至Redis等等都可以做缓冲层，第一层业务处理直接校验后丢到消息队列中，在洪峰过去后慢慢消费消息队列中的消息，执行具体的业务。另外执行过程中的耗时和耗计算资源的操作，也可以丢到消息队列或数据库中，等到谷时处理。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;捋平毛刺&lt;/strong&gt;：有时候洪峰不一定来自外界，如果系统内部大量定时任务在同一时间执行，或与业务高峰期重合，很容易在监控中看到“毛刺”——短时间负载极高。一般解决方案就是错峰执行定时任务，或者分配到其他非核心业务系统中，把“毛刺”摊平。比如很多数据分析型任务都放在业务低谷期去执行，大量定时任务在创建时尽量加一些随机性来分散执行时间。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;避免错误风暴带来的次生洪峰&lt;/strong&gt;：有时候网络抖动或短暂宕机，业务会出现各种异常或错误。这时处理不好很容易带来次生灾害，比如：很多代码都会做错误重试，不加控制的大量重试甚至会导致网络抖动恢复后的瞬间，积压的大量请求再次冲垮整个系统；还有一些代码没有做超时、降级等处理，可能导致大量的等待耗尽TCP连接，进而导致整个系统被冲垮。解决之道就是做限定次数、间隔指数级增长的Back-Off重试，设定超时、降级策略。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;批量处理术&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.6982055464926591&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ELQw2WCMgt3ExLniatY9Rx4qKZs8ggQ0kry17vXN2luHssC7Va9KDtIGDWCo5jE9hZXbF5z23Z0QCjq5mPURf8A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;613&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;批量处理同样可以看成“时间换时间”，其原理是减少了重复的事情，是一种对执行流程的压缩。以个别批量操作更长的耗时为代价，在整体上换取了更多的时间。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;批量处理的应用也非常广泛，我们还是从前端开始讲：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;打包合并的JS文件、雪碧图等等，&lt;strong&gt;将一批资源集中到一起，一次性传输&lt;/strong&gt;；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;前端动画使用requestAnimationFrame在UI渲染时批量处理积压的变化，而不是有变化立刻更新，在游戏开发中也有类似的应用；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;前后端中使用&lt;strong&gt;队列暂存临时产生的数据&lt;/strong&gt;，积压到一定数量再批量处理；在不影响可扩展性情况下，&lt;strong&gt;一个接口传输多种需要的数据&lt;/strong&gt;，减少大量ajax调用（GraphQL在这一点就做到了极致）；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;系统间通信尽量发送整批数据&lt;/strong&gt;，比如消息队列的发布订阅、存取缓存服务的数据、RPC调用、插入或更新数据库等等，能批量做尽可能批量做，因为这些系统间通信的I/O时间开销已经很昂贵了；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;数据积压到一定程度再落盘&lt;/strong&gt;，操作系统本身的写文件就是这么做的，Linux的fwrite只是写入缓冲区暂存，积压到一定程度再fsync刷盘。在应用层，很多高性能的数据库和K-V存储的实现都体现了这一点：一些NoSQL的LSM Tree的第一层就是在内存中先积压到一定大小再往下层合并；Redis的RDB结合AOF的落盘机制；Linux系统调用也提供了批量读写多个缓冲区文件的系统调用：readv/writev；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;延迟地批量回收资源&lt;/strong&gt;，比如JVM的Survivor Space的S0和S1区互换、Redis的Key过期的清除策略。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;批量处理如此好用，那么问题来了，每一批放多大最合适呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个问题其实没有定论，有一些个人经验可以分享。&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;前端把所有文件打包成单个JS，大部分时候并不是最优解。Webpack提供了很多分块的机制，CSS和JS分开、JS按业务分更小的Chunk结合懒加载、一些体积大又不用在首屏用的第三方库设置external或单独分块，可能整体性能更高。不一定要一批搞定所有事情，分几个小批次反而用户体验的性能更好。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Redis的MGET、MSET来批量存取数据时，每批大小不宜过大，因为Redis主线程只有一个，如果一批太大执行期间会让其他命令无法响应。经验上一批50-100个Key性能是不错的，但最好在真实环境下用真实大小的数据量化度量一下，做Benchmark测试才能确定一批大小的最优值。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;MySQL、Oracle这类RDBMS，最优的批量Insert的大小也视数据行的特性而定。我之前在2U8G的Oracle上用一些普遍的业务数据做过测试，批量插入时每批5000-10000条数据性能是最高的，每批过大会导致DML的解析耗时过长，甚至单个SQL语句体积超限，单批太多反而得不偿失。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;消息队列的发布订阅，每批的消息长度尽量控制在1MB以内，有些云服务商提供的消息队列限制了最大长度，那这个长度可能就是性能拐点，比如AWS的SQS服务对单条消息的限制是256KB。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;总之，多大一批可以确保单批响应时间不太长的同时让整体性能最高，是需要在实际情况下做基准测试的，不能一概而论。而批量处理的副作用在于：处理逻辑会更加复杂，尤其是一些涉及事务、并发的问题；需要用数组或队列用来存放缓冲一批数据，消耗了额外的存储空间。&lt;/p&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;中篇&lt;/h1&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;引言&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;前面我们总结了六种普适的性能优化方法，包括 &lt;strong&gt;索引、压缩、缓存、预取、削峰填谷、批量处理&lt;/strong&gt;，简单讲解了每种技术手段的原理和实际应用。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在开启最后一篇前，我们先需要搞清楚：&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;在程序运行期间，时间和空间都耗在哪里了？&lt;/p&gt;&lt;/blockquote&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;时间都去哪儿了？&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;人眨一次眼大约100毫秒，而现代1核CPU在一眨眼的功夫就可以执行数亿条指令。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;现代的CPU已经非常厉害了，频率已经达到了GHz级别，也就是每秒数十亿个指令周期。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;即使一些CPU指令需要多个时钟周期，但由于有流水线机制的存在，平均下来大约每个时钟周期能执行1条指令，比如一个3GHz频率的CPU核心，每秒大概可以执行20亿到40亿左右的指令数量。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;程序运行还需要RAM，也可能用到持久化存储，网络等等。随着新的技术和工艺的出现，这些硬件也越来越厉害，比如CPU高速缓存的提升、NVMe固态硬盘相对SATA盘读写速率和延迟的飞跃等等。这些硬件具体有多强呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;有一个非常棒的网站“Latency Numbers Every Programmer Should Know”，可以直观地查看从1990年到现在，高速缓存、内存、硬盘、网络时间开销的具体数值。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;https://colin-scott.github.io/personal_website/research/interactive_latency.html&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;下图是2020年的截图，的确是“每个开发者应该知道的数字”。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.4951560818083961&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ELQw2WCMgt3ExLniatY9Rx4qKZs8ggQ0kTLofJrnXAXULC2eS9uFOibANKJBibiaEp3ZFg3r1aiaRJuib3ujNSqPdWzw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;929&quot;/&gt;&lt;/figure&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5026737967914439&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ELQw2WCMgt3ExLniatY9Rx4qKZs8ggQ0kSfSqm8VmI0NBWicoicCicaJKMibic1YGOhEdlJm7FFvKjW1TttHPQ6Bapjw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;935&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里有几个非常关键的数据：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;存取一次CPU多级高速缓存的时间大约1-10纳秒级别；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;存取一次主存(RAM)的时间大概在100纳秒级别；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;固态硬盘的一次随机读写大约在10微秒到1毫秒这个数量级；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;网络包在局域网传输一个来回大约是0.5毫秒。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;看到不同硬件之间数量级的差距，就很容易理解性能优化的一些技术手段了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;比如一次网络传输的时间，是主存访问的5000倍，明白这点就不难理解写for循环发HTTP请求，为什么会被扣工资了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;放大到我们容易感知的时间范围，来理解5000倍的差距：如果一次主存访问是1天的话，一趟局域网数据传输就要13.7年。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果要传输更多网络数据，每两个网络帧之间还有固定的间隔（Interpacket Gap），在间隔期间传输Idle信号，数据链路层以此来区分两个数据包，具体数值在链接Wiki中有，这里截取几个我们熟悉的网络来感受一下：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;百兆以太网: 0.96 µs&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;千兆以太网：96 ns&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;万兆以太网：9.6 ns&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;不过，单纯看硬件的上限意义不大，从代码到机器指令中间有许多层抽象，仅仅是在TCP连接上发一个字节的数据包，从操作系统内核到网线，涉及到的基础设施级别的软硬件不计其数。到了应用层，单次操作耗时虽然没有非常精确的数字，但经验上的范围也值得参考：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;用Memcached/Redis存取缓存数据：1-5 ms&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;执行一条简单的数据库查询或更新操作：5-50ms&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;在局域网中的TCP连接上收发一趟数据包：1-10ms；广域网中大约10-200ms，视传输距离和网络节点的设备而定&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;从用户态切换到内核态，完成一次系统调用：100ns - 1 μs，视不同的系统调用函数和硬件水平而定，少数系统调用可能远超此范围。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;空间都去哪儿了？&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在计算机历史上，非易失存储技术的发展速度超过了摩尔定律。除了嵌入式设备、数据库系统等等，&lt;a target=&quot;_blank&quot; href=&quot;https://mp.weixin.qq.com/s?__biz=Mzg2NzYyNjQzNg==&amp;amp;mid=2247502324&amp;amp;idx=1&amp;amp;sn=d50366d73cbb6af01d04989e430d60f7&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;大厂裁员，我们该怎么办？&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;大厂&lt;/span&gt;&lt;span&gt;裁员，我们该怎么办？&lt;/span&gt;&lt;/a&gt;，现在大部分场景已经不太需要优化持久化存储的空间占用了，这里主要讲的是另一个相对稀缺的存储形式 —— RAM，或者说主存/内存。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;以JVM为例，在堆里面有很多我们创建的对象（Object）。&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;每个Object都有一个包含Mark和类型指针的Header，占12个字节&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;每个成员变量，根据数据类型的不同占不同的字节数，如果是另一个对象，其对象指针占4个字节&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;数组会根据声明的大小，占用N倍于其类型Size的字节数&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;成员变量之间需要对齐到4字节，每个对象之间需要对齐到8字节&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果在32G以上内存的机器上，禁用了对象指针压缩，对象指针会变成8字节，包括Header中的Klass指针，这也就不难理解为什么堆内存超过32G，JVM的性能直线下降了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;举个例子，一个有8个int类型成员的对象，需要占用48个字节（12+32+4），如果有十万个这样的Object，就需要占用4.58MB的内存了。这个数字似乎看起来不大，而实际上一个Java服务的堆内存里面，各种各样的对象占用的内存通常比这个数字多得多，大部分内存耗在char[]这类数组或集合型数据类型上。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;举个例子，一个有8个int类型成员的对象，需要占用48个字节（12+32+4），如果有十万个这样的Object，就需要占用4.58MB的内存了。这个数字似乎看起来不大，而实际上一个Java服务的堆内存里面，各种各样的对象占用的内存通常比这个数字多得多，大部分内存耗在char[]这类数组或集合型数据类型上。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;堆内存之外，又是另一个世界了。&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;从操作系统进程的角度去看，也有不少耗内存的大户，不管什么Runtime都逃不开这些空间开销：每个线程需要分配MB级别的线程栈，运行的程序和数据会缓存下来，用到的输入输出设备需要缓冲区……&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;代码“写出来”的内存占用，仅仅是冰山之上的部分，真正的内存占用比“写出来”的要更多，到处都存在空间利用率的问题。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;比如，即使我们在Java代码中只是写了 response.getWriter().print(“OK”)，给浏览器返回2字节，网络协议栈的层层封装，协议头部不断增加的额外数据，让最终返回给浏览器的字节数远超原始的2字节，像IP协议的报头部就至少有20个字节，而数据链路层的一个以太网帧头部至少有18字节。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果传输的数据过大，各层协议还有最大传输单元MTU的限制，IPv4一个报文最大只能有64K比特，超过此值需要分拆发送并在接收端组合，更多额外的报头导致空间利用率降低（IPv6则提供了Jumbogram机制，最大单包4G比特，“浪费”就减少了）。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这部分的“浪费”有多大呢？下面的链接有个表格，传输1460个字节的载荷，经过有线到无线网络的转换，至少再添120个字节，**空间利用率&amp;lt;92.4%**。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;https://en.wikipedia.org/wiki/Jumbo_frame&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这种现象非常普遍，使用抽象层级越高的技术平台，平台提供高级能力的同时，其底层实现的“信息密度”通常越低。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;像Java的Object Header就是使用JVM的代价，而更进一步使用动态类型语言，要为灵活性付出空间的代价则更大。哈希表的自动扩容，强大的反射能力等等，背后也付出了空间的代价。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;再比如，二进制数据交换协议通常比纯文本协议更加节约空间。但多数厂家我们仍然用JSON、XML等纯文本协议，用信息的冗余来换取可读性。即便是二进制的数据交互格式，也会存在信息冗余，只能通过更好的协议和压缩算法，尽量去逼近压缩的极限 —— 信息熵。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;小结&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;理解了时间和空间的消耗在哪后，还不能完全解释软件为何倾向于耗尽硬件资源。有一条定律可以解释，正是它锤爆了摩尔定律。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;它就是安迪-比尔定律。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;“安迪给什么，比尔拿走什么”。&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;安迪指的是Intel前CEO安迪·葛洛夫，比尔指的是比尔·盖茨。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这句话的意思就是：&lt;strong&gt;软件发展比硬件还快，总能吃得下硬件&lt;/strong&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;20年前，在最强的计算机也不见得可以玩赛车游戏；&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;10年前，个人电脑已经可以玩画质还可以的3D赛车游戏了；&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;现在，自动驾驶+5G云驾驶已经快成为现实。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在这背后，是无数的硬件技术飞跃，以及吃掉了这些硬件的各类软件。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这也是我们每隔两三年都要换手机的原因：&lt;strong&gt;不是机器老化变卡了，是嗜血的软件在作怪。&lt;/strong&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.3531073446327684&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ELQw2WCMgt3ExLniatY9Rx4qKZs8ggQ0kCia5jzTm3eibpKVovQJ9kP8uHd9bib88PApfzCbTLBV5oLGI5qbMSLYsA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;708&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;因此，即使现代的硬件水平已经强悍到如此境地，性能优化仍然是有必要的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;软件日益复杂，抽象层级越来越高，就越需要底层基础设施被充分优化。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;对于大部分开发者而言，高层代码逐步走向低代码化、可视化，“一行代码”能产生的影响也越来越大，写出低效代码则会吃掉更多的硬件资源。&lt;/p&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;下篇&lt;/h1&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;引言&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;本篇也是本系列最硬核的一篇，本人技术水平有限，可能存在疏漏或错误之处，望斧正。仍然选取了《火影忍者》的配图和命名方式帮助理解：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;八门遁甲 —— 榨干计算资源&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;影分身术 —— 水平扩容&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;奥义 —— 分片术&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;秘术 —— 无锁术&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;（注：这些“中二”的前缀仅是用《火影》中的一些术语，形象地描述技术方案）&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;八门遁甲 —— 榨干计算资源&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5628517823639775&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ELQw2WCMgt3ExLniatY9Rx4qKZs8ggQ0k2xstR5eZMNviaennGfBtk3rNA3Bib7a7wKhX1peCYu5kzLKpghp46yvg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;533&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;让硬件资源都在处理真正有用的逻辑计算，而不是做无关的事情或空转。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;从晶体管到集成电路、驱动程序、操作系统、直到高级编程语言的层层抽象，每一层抽象带来的更强的通用性、更高的开发效率，多是以损失运行效率为代价的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但我们可以在用高级编程语言写代码的时候，在保障可读性、可维护性基础上用运行效率更高、更适合运行时环境的方式去写，减少额外的性能损耗《Effective XXX》、《More Effective XXX》、《高性能XXX》这类书籍所传递的知识和思想。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;落到技术细节，下面用四个小节来说明如何减少“无用功”、避免空转、榨干硬件。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;聚焦&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;减少系统调用与上下文切换，让CPU聚焦。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可以看看两个 stackoverflow 上的帖子：&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;https://stackoverflow .com/questions/21887797/what-is-the-overhead-of-a-context-switch&lt;br/&gt;https://stackoverflow.com/questions/23599074/system-calls-overhead&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;大部分互联网应用服务，耗时的部分不是计算，而是I/O。&lt;a target=&quot;_blank&quot; href=&quot;https://mp.weixin.qq.com/s?__biz=Mzg2NzYyNjQzNg==&amp;amp;mid=2247502324&amp;amp;idx=1&amp;amp;sn=d50366d73cbb6af01d04989e430d60f7&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;大厂裁员，我们该怎么办？&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;大厂&lt;/span&gt;&lt;span&gt;裁员，我们该怎么办？&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;减少I/O wait， 各司其职，专心干I/O，专心干计算，epoll批量捞任务，（refer: event driven）&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;利用DMA减少CPU负担 - 零拷贝 NewI/O Redis SingleThread (even 6.0), Node.js&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;避免不必要的调度 - Context Switch&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;CPU亲和性，让CPU更加聚焦&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;蜕变&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;用更高效的数据结构、算法、第三方组件，让程序本身蜕变。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;从逻辑短路、Map代替List遍历、减少锁范围、这样的编码技巧，到应用FisherYates、Dijkstra这些经典算法，注意每一行代码细节，量变会发生质变。更何况某个算法就足以让系统性能产生一两个数量级的提升。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;适应&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;因地制宜，适应特定的运行环境&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在浏览器中主要是优化方向是I/O、UI渲染引擎、JS执行引擎三个方面。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;I/O越少越好，能用WebSocket的地方就不用Ajax，能用Ajax的地方就不要刷整个页面；&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;UI渲染方面，减少重排和重绘，比如Vue、React等MVVM框架的虚拟DOM用额外的计算换取最精简的DOM操作；&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;JS执行引擎方面，少用动态性极高的写法，比如eval、随意修改对象或对象原型的属性。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;前端的优化有个神器：Light House，在新版本Chrome已经嵌到开发者工具中了，可以一键生成性能优化报告，按照优化建议改就完了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;与浏览器环境颇为相似的Node.js环境：&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;https://segmentfault.com/a/1190000007621011#articleHeader11&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Java&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Linux&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;各种参数优化&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;内存分配和GC策略&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Linux内核参数 Brendan Gregg&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;内存区块配置（DB，JVM，V8，etc.）&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;利用语言特性和运行时环境 - 比如写出利于JIT的代码&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;多静态少动态 - 舍弃动态特性的灵活性 - hardcode/if-else，强类型，弱类型语言避免类型转换 AOT/JIT vs 解释器， 汇编，机器码 GraalVM&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;减少内存的分配和回收，少对列表做增加或删除&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;对于RAM有限的嵌入式环境，有时候时间不是问题，反而要拿时间换空间，以节约RAM的使用。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;运筹&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;把眼界放宽，跳出程序和运行环境本身，从整体上进行系统性分析最高性价比的优化方案，分析潜在的优化切入点，以及能够调配的资源和技术，运筹帷幄。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其中最简单易行的几个办法，就是花钱，买更好或更多的硬件基础设施，这往往是开发人员容易忽视的，这里提供一些妙招：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;服务器方面，云服务厂商提供各种类型的实例，每种类型有不同的属性侧重，带宽、CP、磁盘的I/O能力，选适合的而不是更贵的&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;舍弃虚拟机 - Bare Mental，比如神龙服务器&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;用ARM架构CPU的服务器，同等价格可以买到更多的服务器，对于多数可以跨平台运行的服务端系统来说与x86区别并不大，ARM服务器的数据中心也是技术发展趋势使然&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;如果必须用x86系列的服务器，AMD也Intel的性价比更高。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;第一点非常重要，软件性能遵循木桶原理，一定要找到瓶颈在哪个硬件资源，把钱花在刀刃上。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果是服务端带宽瓶颈导致的性能问题，升级再多核CPU也是没有用的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我有一次性能优化案例：把一个跑复杂业务的Node.js服务器从AWS的m4类型换成c4类型，内存只有原来的一半，但CPU使用率反而下降了20%，同时价格还比之前更便宜，一石二鸟。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这是因为Node.js主线程的计算任务只有一个CPU核心在干，通过CPU Profile的火焰图，可以定位到该业务的瓶颈在主线程的计算任务上，因此提高单核频率的作用是立竿见影的。而该业务对内存的消耗并不多，套用一些定制v8引擎内存参数的方案，起不了任何作用。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;毕竟这样的例子不多，大部分时候还是要多花钱买更高配的服务器的，除了这条花钱能直接解决问题的办法，剩下的办法难度就大了：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;利用更底层的特性实现功能，比如FFI WebAssembly调用其他语言，Java Agent Instrument，字节码生成（BeanCopier, Json Lib），甚至汇编等等&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;使用硬件提供的更高效的指令&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;各种提升TLB命中率的机制，减少内存的大页表&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;魔改Runtime，Facebook的PHP，阿里腾讯定制的JDK&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;网络设备参数，MTU&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;专用硬件：GPU加速（cuda）、AES硬件卡和高级指令加速加解密过程，比如TLS&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;可编程硬件：地狱级难度，FPGA硬件设备加速特定业务&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;NUMA&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;更宏观的调度，VM层面的共享vCPU，K8S集群调度，总体上的优化&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;小结&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;有些手段，是凭空换出来更多的空间和时间了吗？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;天下没有免费的午餐，即使那些看起来空手套白狼的优化技术，也需要额外的人力成本来做，副作用可能就是专家级的发际线吧。还好很多复杂的性能优化技术我也不会，所以我本人发际线还可以。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这一小节总结了一些方向，有些技术细节非常深，这里也无力展开。不过，即使榨干了单机性能，也可能不足以支撑业务，这时候就需要分布式集群出场了，因此后面介绍的3个技术方向，&lt;strong&gt;都与并行化有关&lt;/strong&gt;。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;影分身术 —— 水平扩容&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;本节的水平扩容以及下面一节的分片，可以算整体的性能提升而不是单点的性能优化，会因为引入额外组件反而降低了处理单个请求的性能。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但当业务规模大到一定程度时，再好的单机硬件也无法承受流量的洪峰，就得水平扩容了，毕竟”众人拾柴火焰高”。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在这背后的理论基础是，硅基半导体已经接近物理极限，随着摩尔定律的减弱，阿姆达尔定律的作用显现出来：&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;https://en.wikipedia.org/wiki/Amdahl%27s_law&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;水平扩容必然引入负载均衡&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.5261044176706827&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ELQw2WCMgt3ExLniatY9Rx4qKZs8ggQ0kZozicsLNXsKeicdsSydPUic9vypWWNQIVOKgygWmwAFGH9KZjC8R2rvuA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;747&quot;/&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;多副本&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;水平扩容的前提是无状态&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;读&amp;gt;&amp;gt;写， 多个读实例副本 （CDN）&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;自动扩缩容，根据常用的或自定义的metrics，判定扩缩容的条件，或根据CRON&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;负载均衡策略的选择&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;奥义 —— 分片术&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;水平扩容针对无状态组件，分片针对有状态组件。二者原理都是提升并行度，但分片的难度更大。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;负载均衡也不再是简单的加权轮询了，而是进化成了各个分片的协调器&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.7104377104377104&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ELQw2WCMgt3ExLniatY9Rx4qKZs8ggQ0kxOEW2L6nqsbt95OzIxjsJSxokiaPJJT5Atevc55QgvGXsVqicKhFdnYg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;594&quot;/&gt;&lt;/figure&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;Java1.7的及之前的 ConcurrentHashMap分段锁&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;有状态数据的分片&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;如何选择Partition/Sharding Key&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;负载均衡难题&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;热点数据，增强缓存等级，解决分散的缓存带来的一致性难题&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;数据冷热分离，SSD - HDD&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;分开容易合并难&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;区块链的优化，分区域&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;秘术 —— 无锁术&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.5261044176706827&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ELQw2WCMgt3ExLniatY9Rx4qKZs8ggQ0kZozicsLNXsKeicdsSydPUic9vypWWNQIVOKgygWmwAFGH9KZjC8R2rvuA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;747&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;有些业务场景，比如库存业务，按照正常的逻辑去实现，水平扩容带来的提升非常有限，因为需要锁住库存，扣减，再解锁库存。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;票务系统也类似，为了避免超卖，需要有一把锁禁锢了横向扩展的能力。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;不管是单机还是分布式微服务，锁都是制约并行度的一大因素。比如上篇提到的秒杀场景，库存就那么多，系统超卖了可能导致非常大的经济损失，但用分布式锁会导致即使服务扩容了成千上万个实例，最终无数请求仍然阻塞在分布式锁这个串行组件上了，再多水平扩展的实例也无用武之地。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;避免竞争Race Condition 是最完美的解决办法。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上篇说的应对秒杀场景，预取库存就是减轻竞态条件的例子，虽然取到服务器内存之后仍然有多线程的锁，但锁的粒度更细了，并发度也就提高了。&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;线程同步锁&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;分布式锁&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;数据库锁 update select子句&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;事务锁&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;顺序与乱序&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;乐观锁/无锁 CAS Java 1.8之后的ConcurrentHashMap&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;pipeline技术 - CPU流水线 Redis Pipeline 大数据分析 并行计算&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;TCP的缓冲区排头阻塞 QUIC HTTP3.0&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;总结&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;以ROI的视角看软件开发，初期人力成本的投入，后期的维护成本，计算资源的费用等等，选一个合适的方案而不是一个性能最高的方案。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;本篇结合个人经验总结了常见的性能优化手段，这些手段只是冰山一角。在初期就设计实现出一个完美的高性能系统是不可能的，随着软件的迭代和体量的增大，利用压测，各种工具（profiling，vmstat，iostat，netstat），以及监控手段，逐步找到系统的瓶颈，因地制宜地选择优化手段才是正道。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;有利必有弊，得到一些必然会失去一些，有一些手段要慎用。Linux性能优化大师Brendan Gregg一再强调的就是：切忌过早优化、过度优化。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;持续观测，做80%高投入产出比的优化。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;除了这些设计和实现时可能用到的手段，在技术选型时选择高性能的框架和组件也非常重要。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;另外，部署基础设施的硬件性能也同样，合适的服务器和网络等基础设施往往会事半功倍，比如云服务厂商提供的各种字母开头的instance，网络设备带宽的速度和稳定性，磁盘的I/O能力等等。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;多数时候我们应当使用更高性能的方案，但有时候甚至要故意去违背它们。最后，以《Effective Java》第一章的一句话结束本文吧。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;首先要学会基本的规则，&lt;/span&gt;&lt;span&gt;然后&lt;/span&gt;&lt;span&gt;才能知道什么时候可以打破规则。&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;blockquote data-type=&quot;2&quot; data-url=&quot;&quot; data-author-name=&quot;&quot; data-content-utf8-length=&quot;53&quot; data-source-title=&quot;&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;span&gt;来源：&lt;span&gt;https://code2life.top/2020/08/15/0055-performance/&lt;/span&gt;&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;/blockquote&gt;&lt;pre&gt;&lt;hr/&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;关于我：Tom哥，前阿里P7技术专家，offer收割机，参加多次淘宝双11大促活动。欢迎关注，我会持续输出更多经典原创文章，为你晋级大厂助力&lt;/span&gt;&lt;/p&gt;&lt;pre&gt;&lt;p&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;微信8.0将好友放开到了一万，小伙伴可以加我大号了，先到先得，再满就真没了。&lt;/span&gt;&lt;span&gt;扫描下方二维码即可加我微信啦，&lt;code&gt;2022，抱团取暖，一起牛逼。&lt;/code&gt;&lt;/span&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot; mp-original-font-size=&quot;17&quot; mp-original-line-height=&quot;27&quot;&gt;&lt;h1 accuse=&quot;qTitle&quot;&gt;&lt;span&gt;&lt;span&gt;「长按2秒」↓↓&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;↓ 二维码，拉你进群，一线大厂技术交流&lt;/span&gt;&lt;/span&gt;&lt;/h1&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;1.2021660649819494&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/3Ohm6WHibeXLL4AVYEUeBKzcTZJd7mrk9XicnYiccg6n8YjsA4ibpRk6hkog7Qqx6cJNIF1rhicl992vID1IFUKWYuw/640?wx_fmt=png&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; data-type=&quot;png&quot; data-w=&quot;554&quot;/&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section mp-original-font-size=&quot;17&quot; mp-original-line-height=&quot;27&quot;&gt;&lt;span/&gt;&lt;/section&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;推荐阅读：&lt;/span&gt;&lt;/h2&gt;&lt;/pre&gt;&lt;/pre&gt;&lt;/pre&gt;&lt;/section&gt;&lt;section&gt;&lt;span/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>