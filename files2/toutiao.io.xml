<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>42fcc8890f89a4eb5eed3318851bcc8d</guid>
<title>ChatGPT 的隐私安全问题及隐私保护技术</title>
<link>https://toutiao.io/k/43iyjx9</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;preview&quot;&gt;&lt;p&gt;&lt;strong&gt;作者:京东科技 杨博&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;ChatGPT 才出现两个月，就已经引起了学术界的关注。微软成为ChatGPT母公司OpenAI的合作伙伴，并确认投资百亿美元。同时，微软正计划将 OpenAI 的技术整合到其产品中，包括Bing搜索引擎和其他软件，以增强它们的能力。然而，据Insider报道，微软却警告其员工不要与人工智能 (AI) 聊天机器人（ChatGPT）共享敏感数据：“请不要将敏感数据发送到 OpenAI 端点，因为他们可能会用它来训练未来的模型”。类似的，亚马逊最近也发出警告其员工提防 ChatGPT，一位亚马逊律师已敦促员工不要通过内部沟通形式与 ChatGPT 共享代码：“这很重要，因为您的输入可能会用作 ChatGPT 进一步迭代的训练数据，我们不希望它的输出包含或类似于我们的机密信息（目前我已经看到它的输出与现有机密材料非常匹配的实例）”&lt;/p&gt;

&lt;p&gt;随着大公司对数据隐私的担忧日益增加，OpenAI 已将有关公司数据和隐私政策的问题转至ChatGPT 的常见问题解答页面。OpenAI 的服务条款授予了该公司使用 ChatGPT 用户生成的所有输入和输出的权利，并规定从使用的数据中删除个人身份信息 (PII)。&lt;/p&gt;

&lt;p&gt;然而，在华盛顿大学教授计算语言学的 Emily Bender 表示，OpenAI 几乎不可能从提供给 ChatGPT 的数据中识别并删除所有个人信息。&lt;/p&gt;

&lt;p&gt;其实，ChatGPT背后的LLM（大型语言模型）技术中的数据隐私保护问题早已受到关注。其中一个风险是如果公开使用含有隐私敏感数据训练的模型，则有可能通过模型提取出训练数据中的隐私敏感信息。这是因为这些训练数据集可能很大（数百 GB）并且来源广泛，即使是基于公共数据集上的训练，它们有时也可能包含敏感数据，包括个人身份信息 (PII)如：姓名、电话号码、地址等，这增加了使用此类数据训练的模型可能会在其输出中反映其中一些私人敏感信息的可能性。因此，重要的是要识别并最大程度地降低此类泄漏的风险，并制定解决未来模型问题的策略。&lt;/p&gt;

&lt;p&gt;﻿&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8f9bdf67a1d84a099ccb5a114d691d57%7Etplv-k3u1fbpfcp-zoom-1.image&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;﻿﻿  &lt;/p&gt;

&lt;p&gt;如果使用前缀“East Stroudsburg Stroudsburg...”提示GPT-2语言模型，它将自动完成一长串文本，其中包含特定人员的全名、电话号码、电子邮件地址和物理地址，其信息被包含在 GPT-2 的训练数据中。&lt;/p&gt;

&lt;p&gt;在一个由谷歌、OpenAI、Apple、斯坦福、伯克利和东北大学的联合研究项目 “ Extracting Training Data from Large Language Models ”中，研究人员已经证明，只要能够查询预训练的语言模型，就可以提取特定的片段模型记忆的训练数据。该研究展示了他们对 GPT-2 的攻击，GPT-2 是一种在公共互联网的碎片上训练的语言模型，并且能够从模型的训练数据中提取数百个逐字的文本序列。这些提取的示例包括（公共）个人身份信息（姓名、电话号码和电子邮件地址）、IRC 对话、代码和 128 位 UUID。即使上述每个序列仅包含在训练数据的一个文档中，这种攻击也是有效的。令人担忧的是，该研究发现较大的模型比较小的模型更容易受到攻击。语言模型越大，就越容易记住训练数据。例如，在一项实验中研究人员发现，15 亿参数的 GPT-2 XL 模型比 1.24 亿参数的 GPT-2 Small 模型多记忆了10倍的信息。因此，训练数据提取攻击是对最先进的大型语言模型的现实威胁。&lt;/p&gt;

&lt;p&gt;GPT-3 使用了 1750 亿个参数，这是迄今为止用于训练模型的最大参数数量（据现有资料显示ChatGPT使用了15 亿参数）。由于模型庞大，OpenAI社区决定不发布包含 1750 亿个参数的整个模型，而以 API 的方式公开其高级语言模型，允许用户以训练提示的形式向 GPT-3提供训练数据，模型使用该提示得出适当的结果。对于个人用户，语言模型通常将训练数据作为其在线学习功能的一部分进行存储，以使模型在运行中变得更好，这在涉及高度机密数据的用例中使用 GPT-3 时遇到了障碍。数据隐私一直是世界各地企业希望使用 GPT-3 创建特定领域应用最关心的问题。企业的担心围绕着公开的 GPT-3 API 端点不应保留或保存作为模型微调/训练过程的任何训练数据；以及通过向公开的 API 端点提供任何类型的输入，任何第三方都不应能够提取或访问作为训练提示的任何数据。&lt;/p&gt;

&lt;p&gt;面对这些担忧，OpenAI 针对企业用户，允许企业与 OpenAI 签署特殊的谅解备忘录 (MoU) 和数据隐私协议 (DPA)以克服围绕数据泄露和数据隐私的担忧。幸运的是，除了制度保障，有一些技术方法可以安全地处理此类敏感数据。这正是隐私保护计算技术（简称隐私计算）的使命——用“你看不到的数据”回答问题，该技术栈包括联邦学习、安全多方计算、差分隐私、同态加密、可信执行环境等。&lt;/p&gt;

&lt;p&gt;在2022年隐私联盟工作的年终总结上，中国信通院对其主导的《隐私计算白皮书（2022年）》、《隐私计算应用研究报告（2022年）》、《可信隐私计算研究报告（2022）》、《隐私计算通信应用研究报告（2022年）》、《多方数据联合风控应用能力评估要求》标准、《隐私计算应用 面向互联网场景的应用要求》标准、《隐私计算 面向金融场景的应用规范》标准等多项隐私保护计算成果进行发布、解读与进展介绍。作为国内隐私计算行业领军者，京东科技全程深度参与了「4大报告+3大标准」的编写研制工作，取得丰硕成果。&lt;/p&gt;

&lt;h4&gt;&lt;strong&gt;成果一：《隐私计算白皮书（2022年）》&lt;/strong&gt;&lt;/h4&gt;

&lt;p&gt;﻿&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzkwNjE4ODkxNg==&amp;amp;mid=2247488564&amp;amp;idx=1&amp;amp;sn=f12b323e4cff41b22550c5f1b3557f1d&amp;amp;scene=21#wechat_redirect&quot;&gt;《隐私计算白皮书（2022年）》&lt;/a&gt;由隐私计算联盟联合行业多家单位共同编制，京东科技作为主要牵头编写单位深度参与。《白皮书》涉及隐私计算概况、技术分析、应用分析、行业分析、热点问题分析以及总结展望等多方面，全面展现了行业成就及发展新态势，旨在为产业界应用隐私计算技术提供参考指导，推动隐私计算行业健康发展，在数据要素市场建设中发挥更大的价值。&lt;/p&gt;

&lt;p&gt;﻿&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/45d85bee9b5245959763726a0ecaee98%7Etplv-k3u1fbpfcp-zoom-1.image&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;﻿﻿  &lt;/p&gt;

&lt;p&gt;《隐私计算白皮书（2022年）》封面及编写单位&lt;/p&gt;

&lt;p&gt;《白皮书》认为，根据隐私计算技术、应用的不同发展特点，隐私计算当前正处于产业快速增长期，即将迈入前景广阔的稳定期。未来，随着我国数据要素市场的加速建设，作为数据流通的重要创新前沿技术，以隐私计算为代表的数据安全流通技术正在成为筑牢数字安全屏障的基础设施，以促进数据要素的可信安全流通。&lt;/p&gt;

&lt;h4&gt;&lt;strong&gt;成果二：《隐私计算应用研究报告（2022年）》&lt;/strong&gt;&lt;/h4&gt;

&lt;p&gt;近两年来，在政策驱动和市场需求同时作用下，隐私计算技术、产业、应用迅速发展，成为商业和资本竞争的热门赛道。随着隐私计算技术可用性的快速提升，市场由观望正在转向落地，金融、政务、通信、医疗、互联网等行业率先开展隐私计算应用，能源、车联网等行业也开始探索性应用。&lt;/p&gt;

&lt;p&gt;在此背景下，隐私计算联盟组织京东科技等成员单位共同编写了&lt;a href=&quot;https://mp.weixin.qq.com/s/B-z_z_LqvHsj9Xg9irknaQ&quot;&gt;《隐私计算应用研究报告（2022年）》&lt;/a&gt;。主要涉及隐私计算应用背景、应用现状、项目应用部署难点及解决方案、应用展望等多个方面。&lt;/p&gt;

&lt;p&gt;﻿&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/87ce55f057b444e9b5bc94ea074ffcdc%7Etplv-k3u1fbpfcp-zoom-1.image&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;﻿﻿  &lt;/p&gt;

&lt;p&gt;《隐私计算应用研究报告（2022年）》封面及编写单位&lt;/p&gt;

&lt;h4&gt;&lt;strong&gt;成果三：《可信隐私计算研究报告（2022年）》&lt;/strong&gt;&lt;/h4&gt;

&lt;p&gt;近年来，数据成为国家基础性战略资源，在政策和市场的同时作用下，隐私计算技术、产业、应用迅速发展。但是，在技术应用过程中，隐私计算因为涉及需求方、供给方、监管方等多方的参与，仍然面临着安全性、合规性、可用性等方面的挑战，由此隐私计算技术如何“可信”应用引发业界思考。&lt;/p&gt;

&lt;p&gt;经过广泛调研征集和深入讨论，由京东科技等多家隐私计算联盟成员单位共同编写了&lt;a href=&quot;https://mp.weixin.qq.com/s/ItTFfLP3h8mTYZoCytyvYg&quot;&gt;《可信隐私计算研究报告（2022年）》&lt;/a&gt;，主要包括可信隐私计算的发展背景、框架、核心要素、实践路径及未来展望等内容。&lt;/p&gt;

&lt;p&gt;﻿&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5d0b933f1d7645abb1f4d0e2e76aa672%7Etplv-k3u1fbpfcp-zoom-1.image&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;﻿﻿  &lt;/p&gt;

&lt;p&gt;《可信隐私计算研究报告（2022年）》封面及编写单位&lt;/p&gt;

&lt;h4&gt;&lt;strong&gt;成果四：《隐私计算通信应用研究报告（2022年）》&lt;/strong&gt;&lt;/h4&gt;

&lt;p&gt;随着隐私计算技术应用逐渐落地，其对通信行业在保证数据安全的前提下充分发挥自身数据应用价值的意义巨大。京东科技参与编写的&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzkwNjE4ODkxNg==&amp;amp;mid=2247488748&amp;amp;idx=1&amp;amp;sn=c077759ea95a60067ec32346953bbf2b&amp;amp;scene=21#wechat_redirect&quot;&gt;《隐私计算通信应用研究报告（2022年）》&lt;/a&gt;便对隐私计算在通信行业的应用特性及典型场景进行了全面梳理，深入挖掘了潜在创新应用场景，为行业发展提供参考指引。&lt;/p&gt;

&lt;p&gt;﻿&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/187b237d85b94e6c993aee255327aa47%7Etplv-k3u1fbpfcp-zoom-1.image&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;﻿﻿  &lt;/p&gt;

&lt;p&gt;《隐私计算通信应用研究报告》封面及编写单位&lt;/p&gt;

&lt;p&gt;《报告》指出，在通信行业，通信数据具有覆盖全面、特征丰富、真实性高、数据连续性高等独特优势和应用价值。以隐私计算技术为依托，可以推动通信行业数据与金融、政务、汽车、医疗等行业共享赋能，并在风险管控、营销分析、态势洞察等多个应用场景中提供数据安全共享计算的服务，能够在保证数据安全的前提下充分发挥通信数据应用价值，助力各行业数字化发展实践，对充分释放数据要素价值和推动社会经济发展具有重大意义。&lt;/p&gt;

&lt;h4&gt;&lt;strong&gt;成果五：《多方数据联合风控应用能力评估要求》标准&lt;/strong&gt;&lt;/h4&gt;

&lt;p&gt;随着国家法律政策的重视、监管逐渐完善以及企业自身的经营需求，风控对于企业的重要性进一步提高。目前，风控已经从传统业务单线风控的1.0阶段、企业级单方风控体系的2.0阶段，正迈入多方数据联合风控体系的3.0阶段，其完整性、全面性、及时性都进一步提高。&lt;/p&gt;

&lt;p&gt;﻿&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4570a3484e74448383957dee44e609f7%7Etplv-k3u1fbpfcp-zoom-1.image&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;﻿﻿  &lt;/p&gt;

&lt;p&gt;风控业务发展的三个阶段&lt;/p&gt;

&lt;p&gt;为解决行业需求，中国信通院依托中国通信标准化协会大数据技术标准推进委员会、隐私计算联盟，京东科技在内的多家银行、运营商、互联网企业及技术服务商共同编制&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzkwNjE4ODkxNg==&amp;amp;mid=2247488673&amp;amp;idx=1&amp;amp;sn=03f7bd79360ca1f2339bec98f8893e25&amp;amp;scene=21#wechat_redirect&quot;&gt;《多方数据联合风控应用能力评估要求》&lt;/a&gt;标准。&lt;/p&gt;

&lt;p&gt;﻿&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b29b030cbfda44768706fad22a7e07c1%7Etplv-k3u1fbpfcp-zoom-1.image&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;﻿﻿  &lt;/p&gt;

&lt;p&gt;《多方数据联合风控应用能力评估要求》标准参编单位&lt;/p&gt;

&lt;h4&gt;&lt;strong&gt;成果六：《隐私计算应用 面向互联网场景的应用要求》标准&lt;/strong&gt;&lt;/h4&gt;

&lt;p&gt;随着政策和市场需求双重驱动，隐私计算在互联网应用场景的需求强烈，其中主要集中在联合营销场景中，具体包括洞察分析、策略制定、营销投放、效果分析等细分场景。为了更好适配，隐私计算产品应在易用性、场景支持能力、算法能力与安全性上满足相应要求。&lt;/p&gt;

&lt;p&gt;﻿&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a218dcaf95374d36bcd5dc2517d7df35%7Etplv-k3u1fbpfcp-zoom-1.image&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;﻿﻿  &lt;/p&gt;

&lt;p&gt;隐私计算技术在互联网行业中的应用场景&lt;/p&gt;

&lt;p&gt;为此，中国信通院、隐私计算联盟与京东科技等单位共同起草&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzkwNjE4ODkxNg==&amp;amp;mid=2247488791&amp;amp;idx=1&amp;amp;sn=6e874d1c8c4f1054b81091b227341700&amp;amp;scene=21#wechat_redirect&quot;&gt;《隐私计算应用 面向互联网场景的应用要求》&lt;/a&gt;标准。该标准梳理了互联网应用场景，并对适配互联网应用的隐私计算产品能力进行了规范。本标准自2022年8月启动以来，经历了框架总体设计和材料征集、场景研讨和梳理，以及标准主体讨论，目前已完成主体内容编制。&lt;/p&gt;

&lt;p&gt;﻿&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/33b6200e6f4b4359bbb4791262ecb983%7Etplv-k3u1fbpfcp-zoom-1.image&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;﻿﻿  &lt;/p&gt;

&lt;p&gt;《隐私计算应用 面向互联网场景的应用要求》标准起草单位&lt;/p&gt;

&lt;h4&gt;&lt;strong&gt;成果七：《隐私计算 面向金融场景的应用规范》标准&lt;/strong&gt;&lt;/h4&gt;

&lt;p&gt;近年来隐私计算应用加速落地，其中金融场景应用最为广泛。为解决供需双方诉求，发挥桥梁作用，隐私联盟联合京东科技等几十家企业召开了多次标准讨论会，共同编制了&lt;a href=&quot;https://mp.weixin.qq.com/s/SefxBNjIv-L0QX0w7jYsmQ&quot;&gt;《隐私计算 面向金融场景的应用规范》&lt;/a&gt;。该标准旨在提升隐私计算产品在金融场景应用中的易用性、场景支持能力。&lt;/p&gt;

&lt;p&gt;﻿&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/422e92f9e7884434b546402983810fc5%7Etplv-k3u1fbpfcp-zoom-1.image&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;﻿﻿  &lt;/p&gt;

&lt;p&gt;隐私计算技术在互联网行业中的应用场景&lt;/p&gt;

&lt;p&gt;该标准主要包含四个能力域：第一个是算法实现与安全性，该能力域为场景应用奠定安全技术底座；第二个是金融场景支持能力，该能力域为完善产品已具备的基础能力项对金融场景应用的支持能力；第三个是易用性，该能力域为在已有的基础能力评测项之外进行扩展，增强隐私计算产品在实际金融应用中的易用性；第四个能力域是金融场景应用能力，该能力域为通过算法组合安全有效地完成常用金融场景的解决方案。&lt;/p&gt;

&lt;p&gt;﻿&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a0d3f8a183d3472bb89d07da03fa133d%7Etplv-k3u1fbpfcp-zoom-1.image&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;﻿﻿  &lt;/p&gt;

&lt;p&gt;《隐私计算 面向金融场景的应用规范》标准起草单位&lt;/p&gt;

&lt;h3&gt;&lt;strong&gt;结语&lt;/strong&gt;&lt;/h3&gt;

&lt;p&gt;大型语言模型已持续展示出其巨大的实用性和灵活性——然而，像所有创新一样，它们也可能带来风险。负责任地开发和使用它们意味着主动识别这些风险并提供降低风险的方法。作为国内隐私计算领军者，京东科技基于自身领先的技术研发实力、优质的数据生态资源、丰富的平台建设与场景运营落地经验，始终高度重视数据流通中隐私数据的保护。&lt;/p&gt;

&lt;p&gt;此次京东科技深度参编的隐私计算技术系列成果的集中发布，秉持客户利益为先的商业准则，致力于通过技术持续改进数据要素流通效率与价值，为实现数据要素在数据安全和隐私保护基础上的有序流通提供了重要参考、指引和规范。未来，京东科技将积极凝聚行业共识，共同探索隐私计算的高质量发展方向和应用路径，充分发挥隐私计算作为数字经济持续健康发展的基础设施作用。&lt;/p&gt;
&lt;/div&gt;
  &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>3cd92eca72d2fce785fdb5656c9ef73b</guid>
<title>DPDK：无锁环形队列介绍</title>
<link>https://toutiao.io/k/dpbwmsz</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;RichText ztext Post-RichText css-1g0fqss&quot; options=&quot;[object Object]&quot;&gt;&lt;h2 data-first-child=&quot;&quot; id=&quot;h_608143587_0&quot; data-into-catalog-status=&quot;&quot;&gt;1.前言&lt;/h2&gt;&lt;p data-pid=&quot;fZg57lA9&quot;&gt;最近打算实现去年立下的Flag，出一个DPDK基础原理系列，所以这篇作为第一篇吧，后续鄙人打算把DPDK中的一些经典设计和原理以分散篇章陆续介绍给大家，版本选择的是DPDK稳定版本21.11.1，如果有发现什么错误及时提醒木木修正，这里木木先提前谢过路过的小哥哥或者小姐姐了。本系列适合已经对DPDK有一定了解的同学进阶，我们深入探讨接口以及设计实现的精巧地方，帮助大家理解和梳理DPDK中的经典设计，这个系列也会会涉及在面试转发面研发时我们经常问的问题，我会总结在每个篇章的后面，帮助大家找到心仪的工作和开心的学习工作。&lt;/p&gt;&lt;h2 id=&quot;h_608143587_1&quot; data-into-catalog-status=&quot;&quot;&gt;2.无锁环形队列&lt;/h2&gt;&lt;p data-pid=&quot;xMuwsV1R&quot;&gt;从字面上无锁环形队列就能理解这是一种环形队列，它没有锁。队列是一种我们常见的数据结构，保证了元素的先进先出，环形队列则是头尾相连，它是一个环形，通常呢是一个固定大小的闭环队列。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-4e728d9db229f79af56da6826fdd65b3_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1556&quot; data-rawheight=&quot;992&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic4.zhimg.com/v2-4e728d9db229f79af56da6826fdd65b3_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1556&quot; data-rawheight=&quot;992&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic4.zhimg.com/v2-4e728d9db229f79af56da6826fdd65b3_r.jpg&quot; data-actualsrc=&quot;https://pic4.zhimg.com/v2-4e728d9db229f79af56da6826fdd65b3_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p data-pid=&quot;SFGIJA7P&quot;&gt;如上面的设计我们不难理解它经常应用在生产者消费者的经典模式了，它类似于一个环形的缓冲地带，所以它的特点也很明显：&lt;/p&gt;&lt;ul&gt;&lt;li data-pid=&quot;0xR6oW_d&quot;&gt;它能够保证数据是先进先出的，这部分是由队列来保证的。&lt;/li&gt;&lt;li data-pid=&quot;UGAQfI5Q&quot;&gt;由于是固定的的一个闭环，一开始我们可以规定好队列的元素个数大小，同时当生产者把队列放满时会选择丢弃掉，当然我们也可以设计放在另一个缓冲区处理。&lt;/li&gt;&lt;li data-pid=&quot;d0Yj2Ma6&quot;&gt;内存空间可以重复利用，避免内存分配和释放的开销。&lt;/li&gt;&lt;/ul&gt;&lt;h2 id=&quot;h_608143587_2&quot; data-into-catalog-status=&quot;&quot;&gt;3.DPDK的rte_ring结构&lt;/h2&gt;&lt;p data-pid=&quot;D0v0BjIn&quot;&gt;先来看DPDK源码中关于环形队列的数据结构：&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;&lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;rte_ring&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;RTE_RING_NAMESIZE&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;__rte_cache_aligned&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;cm&quot;&gt;/**&amp;lt; Name of the ring. */&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;flags&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;               &lt;span class=&quot;cm&quot;&gt;/**&amp;lt; Flags supplied at creation. */&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;rte_memzone&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;memzone&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;cm&quot;&gt;/**&amp;lt; Memzone, if any, containing the rte_ring */&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;uint32_t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;size&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;           &lt;span class=&quot;cm&quot;&gt;/**&amp;lt; Size of ring. */&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;uint32_t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;mask&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;           &lt;span class=&quot;cm&quot;&gt;/**&amp;lt; Mask (size-1) of ring. */&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;uint32_t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;capacity&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;       &lt;span class=&quot;cm&quot;&gt;/**&amp;lt; Usable size of ring */&lt;/span&gt;

&lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pad0&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;__rte_cache_aligned&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;cm&quot;&gt;/**&amp;lt; empty cache line */&lt;/span&gt;

&lt;span class=&quot;cm&quot;&gt;/** Ring producer status. */&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;RTE_STD_C11&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;union&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;rte_ring_headtail&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;prod&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;rte_ring_hts_headtail&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;hts_prod&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;rte_ring_rts_headtail&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;rts_prod&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;  &lt;span class=&quot;n&quot;&gt;__rte_cache_aligned&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pad1&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;__rte_cache_aligned&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;cm&quot;&gt;/**&amp;lt; empty cache line */&lt;/span&gt;

&lt;span class=&quot;cm&quot;&gt;/** Ring consumer status. */&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;RTE_STD_C11&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;union&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;rte_ring_headtail&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cons&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;rte_ring_hts_headtail&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;hts_cons&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;rte_ring_rts_headtail&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;rts_cons&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;  &lt;span class=&quot;n&quot;&gt;__rte_cache_aligned&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pad2&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;__rte_cache_aligned&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;cm&quot;&gt;/**&amp;lt; empty cache line */&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p data-pid=&quot;0kFJ1POv&quot;&gt;每个环形队列都包含两对指针，一对用于生产者（prod）,一对用于消费者（cons）。&lt;/p&gt;&lt;p data-pid=&quot;P5pkm68X&quot;&gt;该结构定义如下：&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;&lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;rte_ring_headtail&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;volatile&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;uint32_t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;head&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;      &lt;span class=&quot;cm&quot;&gt;/**&amp;lt; prod/consumer head. */&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;volatile&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;uint32_t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;tail&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;      &lt;span class=&quot;cm&quot;&gt;/**&amp;lt; prod/consumer tail. */&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;RTE_STD_C11&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;union&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
&lt;span class=&quot;cm&quot;&gt;/** sync type of prod/cons */&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;enum&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;rte_ring_sync_type&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;sync_type&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;cm&quot;&gt;/** deprecated -  True if single prod/cons */&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;uint32_t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;single&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p data-pid=&quot;lgyPw6Ss&quot;&gt;比较有意思的是这个版本增加了一个sync_type，默认为线程安全模式，其他几种模式我们稍后介绍。&lt;/p&gt;&lt;p data-pid=&quot;meoxgicT&quot;&gt;后面我们用prod_head, prod_tail, cons_head,cond_tail来分别表示生产者的头尾指针，和消费者的头尾指针。&lt;/p&gt;&lt;h2 id=&quot;h_608143587_3&quot; data-into-catalog-status=&quot;&quot;&gt;4.rte_ring的注册&lt;/h2&gt;&lt;p data-pid=&quot;GMdB5I_z&quot;&gt;这个函数使用了memzone_reserve()分配内存。然后调用rte_ring_init去初始化空队列，因为count 会被要求必需是2的次幂个数，实际上队列最大使用元素个数是count-1，然后把ring 加到RTE_TAILQ_RING 的里，后面我会介绍DPDK的内存管理，对于这个部分会详细描述，这里我们知道是一个固定的存储区即可。&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;&lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;rte_ring&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;rte_ring_create&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;count&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
 &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;socket_id&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;flags&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p data-pid=&quot;lD5sg0wZ&quot;&gt;来看这几个参数:&lt;/p&gt;&lt;ul&gt;&lt;li data-pid=&quot;Vwz5ZvY6&quot;&gt;name:不同的环形队列使用不同的名字作为唯一标识。&lt;/li&gt;&lt;li data-pid=&quot;tTaRAai_&quot;&gt;count: 队列的大小，也就是容纳元素的个数，限定要求求必需2的多少次幂个个数。&lt;/li&gt;&lt;li data-pid=&quot;-JElqXq9&quot;&gt;socket_id:熟悉DPDK编程的应该知道这是NUMA的socket_id标识。&lt;/li&gt;&lt;li data-pid=&quot;W39sCPCt&quot;&gt;flag:这个就是与sync_type 相关的集中模式使用的flag标志，默认多消费者模式。&lt;/li&gt;&lt;/ul&gt;&lt;blockquote data-pid=&quot;YrqENaN2&quot;&gt;RING_F_SP_END: 这个标志如被设置，默认使用rte_ring_enqueue或者rte_ring_enqueue_bulk，单生产者模式，否者是多生产者模式。&lt;br/&gt;RING_F_SC_DEQ：这个标志如被设置，默认使用te_ring_dequeue或者rte_ring_dequeue_bulk，单消费者模式，否者为多消费者模式。&lt;br/&gt;RING_F_EXACT_SZ：如果这个标识被设置，参数count则被认为是确切可用的队列大小，比如不必要求必需是2的次幂个数。底层的ring内存必须是2的次幂并且比counter大。懒人可以把这个设上，就不用去 算自己的count是否合法了，反正下面会给对齐。&lt;/blockquote&gt;&lt;h2 id=&quot;h_608143587_4&quot; data-into-catalog-status=&quot;&quot;&gt;5.单生产者/单消费者模式&lt;/h2&gt;&lt;h3 id=&quot;h_608143587_5&quot; data-into-catalog-status=&quot;&quot;&gt;5.1 必要的介绍&lt;/h3&gt;&lt;p data-pid=&quot;cIULjU5r&quot;&gt;先来介绍典型的单生产者单消费者模式，分别描述入队和出队操作，ring都做了哪些变化，对外提供的接口是rte_ring_enqueue，调用的是rte_ring_queue_bulk_elem，后面的模式介绍我就直接介绍最终的接口了。&lt;/p&gt;&lt;p data-pid=&quot;rXoDC9VB&quot;&gt;所以rte_ring接口中的prod.sysc_type在这里用来区分模式。先来看sysc_type怎么设置的&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;&lt;span class=&quot;k&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;
&lt;span class=&quot;nf&quot;&gt;get_sync_type&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;uint32_t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;flags&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;enum&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;rte_ring_sync_type&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;prod_st&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;enum&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;rte_ring_sync_type&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cons_st&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;uint32_t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;prod_st_flags&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;RING_F_SP_ENQ&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;RING_F_MP_RTS_ENQ&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;RING_F_MP_HTS_ENQ&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;uint32_t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cons_st_flags&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;RING_F_SC_DEQ&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;RING_F_MC_RTS_DEQ&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;RING_F_MC_HTS_DEQ&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;switch&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;flags&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;prod_st_flags&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;case&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;prod_st&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;RTE_RING_SYNC_MT&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;break&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;case&lt;/span&gt; &lt;span class=&quot;nl&quot;&gt;RING_F_SP_ENQ&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;prod_st&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;RTE_RING_SYNC_ST&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;break&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;case&lt;/span&gt; &lt;span class=&quot;nl&quot;&gt;RING_F_MP_RTS_ENQ&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;prod_st&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;RTE_RING_SYNC_MT_RTS&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;break&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;case&lt;/span&gt; &lt;span class=&quot;nl&quot;&gt;RING_F_MP_HTS_ENQ&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;prod_st&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;RTE_RING_SYNC_MT_HTS&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;break&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;default&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;EINVAL&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;switch&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;flags&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cons_st_flags&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;case&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cons_st&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;RTE_RING_SYNC_MT&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;break&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;case&lt;/span&gt; &lt;span class=&quot;nl&quot;&gt;RING_F_SC_DEQ&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cons_st&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;RTE_RING_SYNC_ST&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;break&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;case&lt;/span&gt; &lt;span class=&quot;nl&quot;&gt;RING_F_MC_RTS_DEQ&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cons_st&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;RTE_RING_SYNC_MT_RTS&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;break&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;case&lt;/span&gt; &lt;span class=&quot;nl&quot;&gt;RING_F_MC_HTS_DEQ&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cons_st&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;RTE_RING_SYNC_MT_HTS&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;break&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;default&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;EINVAL&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p data-pid=&quot;UV50L9lV&quot;&gt;&lt;br/&gt;默认生产者模式：RTE_RING_SYNC_MT&lt;br/&gt;默认消费者模式：RTE_RING_SYNC_MT&lt;br/&gt;&lt;br/&gt;由于我们是单生产单消费，所以flag会被设置为RING_F_SP_ENQ&amp;amp;RING_F_SC_DEQ所以对应的prod.sync_type为&lt;br/&gt;RTE_RING_SYNC_ST 和cons.sync_type为RTE_RING_SYNC_ST，如下，也就是单线程模式，也就是所谓的一个线程负责生产，一个线程负责消费。&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;&lt;span class=&quot;cm&quot;&gt;/** prod/cons sync types */&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;enum&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;rte_ring_sync_type&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;RTE_RING_SYNC_MT&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;     &lt;span class=&quot;cm&quot;&gt;/**&amp;lt; multi-thread safe (default mode) */&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;RTE_RING_SYNC_ST&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;     &lt;span class=&quot;cm&quot;&gt;/**&amp;lt; single thread only */&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;RTE_RING_SYNC_MT_RTS&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;cm&quot;&gt;/**&amp;lt; multi-thread relaxed tail sync */&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;RTE_RING_SYNC_MT_HTS&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;cm&quot;&gt;/**&amp;lt; multi-thread head/tail sync */&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;__rte_always_inline&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;
&lt;span class=&quot;nf&quot;&gt;rte_ring_enqueue_bulk_elem&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;rte_ring&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;r&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;obj_table&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;esize&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;free_space&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;switch&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;r&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;prod&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;sync_type&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;case&lt;/span&gt; &lt;span class=&quot;nl&quot;&gt;RTE_RING_SYNC_MT&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;rte_ring_mp_enqueue_bulk_elem&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;r&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;obj_table&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;esize&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;free_space&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;case&lt;/span&gt; &lt;span class=&quot;nl&quot;&gt;RTE_RING_SYNC_ST&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;rte_ring_sp_enqueue_bulk_elem&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;r&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;obj_table&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;esize&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;free_space&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;case&lt;/span&gt; &lt;span class=&quot;nl&quot;&gt;RTE_RING_SYNC_MT_RTS&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;rte_ring_mp_rts_enqueue_bulk_elem&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;r&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;obj_table&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;esize&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;free_space&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;case&lt;/span&gt; &lt;span class=&quot;nl&quot;&gt;RTE_RING_SYNC_MT_HTS&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;rte_ring_mp_hts_enqueue_bulk_elem&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;r&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;obj_table&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;esize&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;free_space&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;cm&quot;&gt;/* valid ring should never reach this point */&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;RTE_ASSERT&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;free_space&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;NULL&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;free_space&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p data-pid=&quot;NF3aPKDx&quot;&gt;那么入队对应的底层调用就是：&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;&lt;span class=&quot;n&quot;&gt;__rte_ring_do_enqueue_elem&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;r&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;obj_table&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;esize&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;RTE_RING_QUEUE_FIXED&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;RTE_RING_SYNC_ST&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;free_space&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p data-pid=&quot;o80gcyqX&quot;&gt;为了方便大家理解，我们把指针简写规定一下：&lt;/p&gt;&lt;table data-draft-node=&quot;block&quot; data-draft-type=&quot;table&quot; data-size=&quot;normal&quot; data-row-style=&quot;normal&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;th&gt;变量名称&lt;/th&gt;&lt;th&gt;含义&lt;/th&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;g_prod_head&lt;/td&gt;&lt;td&gt;环形队列生产者head&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;g_prod_tail&lt;/td&gt;&lt;td&gt;环形队列生产者tail&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;g_cons_head&lt;/td&gt;&lt;td&gt;环形队列消费者head&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;g_cons_tail&lt;/td&gt;&lt;td&gt;环形队列消费者tail&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;l_prod_head&lt;/td&gt;&lt;td&gt;临时队列生产者head位置&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;l_prod_tail&lt;/td&gt;&lt;td&gt;临时队列生产者tail位置&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;l_cons_head&lt;/td&gt;&lt;td&gt;临时队列消费者head位置&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;l_cons_tail&lt;/td&gt;&lt;td&gt;临时队列消费者tail位置&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;l_prod_head_next&lt;/td&gt;&lt;td&gt;临时存放生产者需要移动到的位置。&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;l_cons_tail_next&lt;/td&gt;&lt;td&gt;临时存放生产者需要移动到的位置&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;blockquote data-pid=&quot;LBVp9ehG&quot;&gt;为什么会有临时变量的存在，因为每个CPU都独占一份内存，这些临时变量存储在本地cache中尚未更新到全局的环形队列上的值。环境队里中的变量则是存储共享的环形队列值。&lt;/blockquote&gt;&lt;h3 id=&quot;h_608143587_6&quot; data-into-catalog-status=&quot;&quot;&gt;5.2 入队&lt;/h3&gt;&lt;p data-pid=&quot;L6vWcpZM&quot;&gt;参考_rte_ring_do_enqueue_elem及其更底层函数的实现步骤我们来说明入队操作。&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;&lt;span class=&quot;k&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;__rte_always_inline&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;__rte_ring_do_enqueue_elem&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;rte_ring&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;r&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;obj_table&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;esize&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;enum&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;rte_ring_queue_behavior&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;behavior&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;is_sp&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;free_space&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p data-pid=&quot;DOIhB5AS&quot;&gt;初始时，prod_head和prod_tail都会指向相同的存储空间。&lt;/p&gt;&lt;p data-pid=&quot;waIidguK&quot;&gt;第一步：拿到全局g_prod_head的值和放在临时变量l_prod_head_old中记录位置。根据插入个数移动相应的位置，如果足够存储移动后的l_prod_head_new位置，这里不贴代码了，防止大家混淆，底层接口包含了多种模式的逻辑处理，有兴趣可以怼着代码研究步骤。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-9b5d3b9d0955cdb3c565849e1b052319_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1002&quot; data-rawheight=&quot;784&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic2.zhimg.com/v2-9b5d3b9d0955cdb3c565849e1b052319_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1002&quot; data-rawheight=&quot;784&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic2.zhimg.com/v2-9b5d3b9d0955cdb3c565849e1b052319_r.jpg&quot; data-actualsrc=&quot;https://pic2.zhimg.com/v2-9b5d3b9d0955cdb3c565849e1b052319_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p data-pid=&quot;4lCmCvmg&quot;&gt;这里起到一个提前占位置的作用，我提前预定了我要插入元素后的移动位置。&lt;/p&gt;&lt;p data-pid=&quot;d90CcaQV&quot;&gt;第二步：把prod_head移动到新位置prod_next，把需要入队的元素obj4 添加到队列中。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-c08cd0c6cfda5bc50ee12b045eb68293_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;982&quot; data-rawheight=&quot;794&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic4.zhimg.com/v2-c08cd0c6cfda5bc50ee12b045eb68293_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;982&quot; data-rawheight=&quot;794&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic4.zhimg.com/v2-c08cd0c6cfda5bc50ee12b045eb68293_r.jpg&quot; data-actualsrc=&quot;https://pic4.zhimg.com/v2-c08cd0c6cfda5bc50ee12b045eb68293_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p data-pid=&quot;kNkQ1uE2&quot;&gt;第三部：更新全局位置g_prod_tail到g_prod_head相同的位置&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-c0c3bbd716d1faf546839495dbde2ff8_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;996&quot; data-rawheight=&quot;790&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic1.zhimg.com/v2-c0c3bbd716d1faf546839495dbde2ff8_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;996&quot; data-rawheight=&quot;790&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic1.zhimg.com/v2-c0c3bbd716d1faf546839495dbde2ff8_r.jpg&quot; data-actualsrc=&quot;https://pic1.zhimg.com/v2-c0c3bbd716d1faf546839495dbde2ff8_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p data-pid=&quot;zCseSMv8&quot;&gt;看代码实现其实就三部分：&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;&lt;span class=&quot;k&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;__rte_always_inline&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;
&lt;span class=&quot;nf&quot;&gt;__rte_ring_do_enqueue_elem&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;rte_ring&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;r&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;obj_table&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;esize&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;enum&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;rte_ring_queue_behavior&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;behavior&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;is_sp&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;free_space&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;uint32_t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;prod_head&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;prod_next&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;uint32_t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;free_entries&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;n&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;__rte_ring_move_prod_head&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;r&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;is_sp&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;behavior&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;prod_head&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;prod_next&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;free_entries&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;n&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;goto&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;end&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;__rte_ring_enqueue_elems&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;r&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;prod_head&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;obj_table&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;esize&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;__rte_ring_update_tail&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;r&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;prod&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;prod_head&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;prod_next&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;is_sp&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;nl&quot;&gt;end&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;free_space&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;NULL&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;free_space&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;free_entries&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p data-pid=&quot;YwGfrKgY&quot;&gt;先找好入队后的l_prod_head_next位置，元素入队，更新全局g_prod_head。用到了内存写屏障，保证我写操作的正确性。这么一看还是挺简单的吧，入队就完事了呢，o(*￣︶￣*)o。&lt;/p&gt;&lt;h3 id=&quot;h_608143587_7&quot; data-into-catalog-status=&quot;&quot;&gt;5.3 出队&lt;/h3&gt;&lt;p data-pid=&quot;SNs8pMCz&quot;&gt;参考__rte_ring_do_dequeue_elem以及更底层的实现我们来看出队列操作如何实现的，初始状态时，cons_head和cons_tail都指向相同的内存空间。&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;&lt;span class=&quot;k&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;__rte_always_inline&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;
&lt;span class=&quot;nf&quot;&gt;rte_ring_sc_dequeue_bulk_elem&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;rte_ring&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;r&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;obj_table&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;esize&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;available&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;__rte_ring_do_dequeue_elem&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;r&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;obj_table&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;esize&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;RTE_RING_QUEUE_FIXED&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;RTE_RING_SYNC_ST&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;available&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p data-pid=&quot;XM5Ej1Fq&quot;&gt;第一步：我们记录g_cons_head到本地变量l_cons_head，临时变量l_cons_head_next根据出队个数移动相应的位置，同理都是占位预定步骤。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-b61956245a0e637b5d854f5ae0384185_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1014&quot; data-rawheight=&quot;778&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic2.zhimg.com/v2-b61956245a0e637b5d854f5ae0384185_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1014&quot; data-rawheight=&quot;778&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic2.zhimg.com/v2-b61956245a0e637b5d854f5ae0384185_r.jpg&quot; data-actualsrc=&quot;https://pic2.zhimg.com/v2-b61956245a0e637b5d854f5ae0384185_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p data-pid=&quot;dFk_5jjl&quot;&gt;第二步：修改全局cons_head位置到l_cons_head_next相同的位置，消费队列中的元素，完成出队列操作。&lt;/p&gt;&lt;p data-pid=&quot;NUMGtxV1&quot;&gt;第三部：更新全局位置g_cons_tail位置与g_cons_head相同，用了内存读屏障来保证读操作正确性。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-c6ba38ba2a84bdf0b9201f7dd0a64024_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;992&quot; data-rawheight=&quot;802&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic1.zhimg.com/v2-c6ba38ba2a84bdf0b9201f7dd0a64024_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;992&quot; data-rawheight=&quot;802&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic1.zhimg.com/v2-c6ba38ba2a84bdf0b9201f7dd0a64024_r.jpg&quot; data-actualsrc=&quot;https://pic1.zhimg.com/v2-c6ba38ba2a84bdf0b9201f7dd0a64024_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p data-pid=&quot;64wlfKKE&quot;&gt;再来看代码，当当当，是不是咔咔咔的三步骤，So Easy了吧.&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;&lt;span class=&quot;k&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;__rte_always_inline&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;
&lt;span class=&quot;nf&quot;&gt;__rte_ring_do_dequeue_elem&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;rte_ring&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;r&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;obj_table&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;esize&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;enum&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;rte_ring_queue_behavior&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;behavior&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;is_sc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;available&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;uint32_t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cons_head&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cons_next&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;uint32_t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;entries&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;n&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;__rte_ring_move_cons_head&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;r&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;is_sc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;behavior&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cons_head&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cons_next&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;entries&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;n&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;goto&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;end&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;__rte_ring_dequeue_elems&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;r&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cons_head&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;obj_table&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;esize&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;__rte_ring_update_tail&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;r&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cons&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cons_head&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cons_next&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;is_sc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

&lt;span class=&quot;nl&quot;&gt;end&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;available&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;NULL&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;available&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;entries&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&quot;h_608143587_8&quot; data-into-catalog-status=&quot;&quot;&gt;6.多生产者/多消费者&lt;/h2&gt;&lt;p data-pid=&quot;wiFydO6H&quot;&gt;刚才说的是单生产单消费模式，现在我们来介绍一下多生产者多消费者模式&lt;/p&gt;&lt;h3 id=&quot;h_608143587_9&quot; data-into-catalog-status=&quot;&quot;&gt;6.1 入队&lt;/h3&gt;&lt;p data-pid=&quot;lv6lbzR1&quot;&gt;这里我们拿两个生产者和两个消费者的例子来说明，只有生产者的prod_head 和prod_tail会被修改。初始化状态prod_head和prod_tail指向相同位置。&lt;/p&gt;&lt;p data-pid=&quot;mmUPOgEV&quot;&gt;第一步，两个核都会拷贝全局g_prod_head到本地变量prod_head，拿到需要入队的位置prod_next的位置，如果没足够的空间，则会返回错误。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-cd3353c50eb1c2a12495857659e7c5f5_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1038&quot; data-rawheight=&quot;774&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic2.zhimg.com/v2-cd3353c50eb1c2a12495857659e7c5f5_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1038&quot; data-rawheight=&quot;774&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic2.zhimg.com/v2-cd3353c50eb1c2a12495857659e7c5f5_r.jpg&quot; data-actualsrc=&quot;https://pic2.zhimg.com/v2-cd3353c50eb1c2a12495857659e7c5f5_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p data-pid=&quot;FRyky2cU&quot;&gt;第二步，修改指向相同位置的prod_next，这一步用到了CAS也就是对比交换操作，原子的执行以下动作：&lt;/p&gt;&lt;ul&gt;&lt;li data-pid=&quot;147CiBai&quot;&gt;如果g_prod_head和本地变量不通，CAS操作失败，core 1则就返回失败，重新开始第一步操作。&lt;/li&gt;&lt;li data-pid=&quot;dhpRSdVf&quot;&gt;否则，全局的g_prod_head会被设置到l_prod_next的位置，CAS操作就成功了，程序继续执行。&lt;/li&gt;&lt;/ul&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-6db000b7224229c9caa5817351d60fa7_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1138&quot; data-rawheight=&quot;870&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic4.zhimg.com/v2-6db000b7224229c9caa5817351d60fa7_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1138&quot; data-rawheight=&quot;870&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic4.zhimg.com/v2-6db000b7224229c9caa5817351d60fa7_r.jpg&quot; data-actualsrc=&quot;https://pic4.zhimg.com/v2-6db000b7224229c9caa5817351d60fa7_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p data-pid=&quot;rXJGWH9h&quot;&gt;第三步：CAS操作在core2上返回成功，core 1入队obj4这个元素，core2更新另外一个obj5。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-fb6bb7f038dc162c05aa38a537244391_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1032&quot; data-rawheight=&quot;832&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic2.zhimg.com/v2-fb6bb7f038dc162c05aa38a537244391_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1032&quot; data-rawheight=&quot;832&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic2.zhimg.com/v2-fb6bb7f038dc162c05aa38a537244391_r.jpg&quot; data-actualsrc=&quot;https://pic2.zhimg.com/v2-fb6bb7f038dc162c05aa38a537244391_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p data-pid=&quot;iq3QZ82U&quot;&gt;第四步：每个core上试图更新全局的prod_tail位置。但是只有一个core能够更新全局的prod_tail和本地的prod_head到相同位置。这个在core1上完成。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-1cde60f5aae4ad971690f19c629ed371_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;994&quot; data-rawheight=&quot;824&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic2.zhimg.com/v2-1cde60f5aae4ad971690f19c629ed371_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;994&quot; data-rawheight=&quot;824&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic2.zhimg.com/v2-1cde60f5aae4ad971690f19c629ed371_r.jpg&quot; data-actualsrc=&quot;https://pic2.zhimg.com/v2-1cde60f5aae4ad971690f19c629ed371_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p data-pid=&quot;zDHDu8Op&quot;&gt;第五步：一旦g_prod_tail被core1更新完成后，core2才允许更新它，然后同样的操作在core2中完成。&lt;/p&gt;&lt;p data-pid=&quot;wIa_eliI&quot;&gt;现在来贴代码：&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;&lt;span class=&quot;k&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;__rte_always_inline&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;
&lt;span class=&quot;nf&quot;&gt;__rte_ring_move_prod_head&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;rte_ring&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;r&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;is_sp&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;enum&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;rte_ring_queue_behavior&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;behavior&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;uint32_t&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;old_head&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;uint32_t&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;new_head&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;uint32_t&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;free_entries&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;uint32_t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;capacity&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;r&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;capacity&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;max&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;success&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;do&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
&lt;span class=&quot;cm&quot;&gt;/* Reset n to the initial burst count */&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;n&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;max&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;old_head&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;r&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;prod&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;head&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;cm&quot;&gt;/* add rmb barrier to avoid load/load reorder in weak
&lt;/span&gt;&lt;span class=&quot;cm&quot;&gt; * memory model. It is noop on x86
&lt;/span&gt;&lt;span class=&quot;cm&quot;&gt; */&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;rte_smp_rmb&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;

&lt;span class=&quot;cm&quot;&gt;/*
&lt;/span&gt;&lt;span class=&quot;cm&quot;&gt; *  The subtraction is done between two unsigned 32bits value
&lt;/span&gt;&lt;span class=&quot;cm&quot;&gt; * (the result is always modulo 32 bits even if we have
&lt;/span&gt;&lt;span class=&quot;cm&quot;&gt; * *old_head &amp;gt; cons_tail). So &#x27;free_entries&#x27; is always between 0
&lt;/span&gt;&lt;span class=&quot;cm&quot;&gt; * and capacity (which is &amp;lt; size).
&lt;/span&gt;&lt;span class=&quot;cm&quot;&gt; */&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;free_entries&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;capacity&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;r&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cons&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;tail&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;old_head&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

&lt;span class=&quot;cm&quot;&gt;/* check that we have enough room in ring */&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;unlikely&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;n&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;free_entries&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;n&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;behavior&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;RTE_RING_QUEUE_FIXED&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;?&lt;/span&gt;
&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;free_entries&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;n&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;new_head&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;old_head&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;is_sp&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;r&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;prod&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;head&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;new_head&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;success&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;else&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;success&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;rte_atomic32_cmpset&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;r&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;prod&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;head&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;old_head&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;new_head&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;while&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;unlikely&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;success&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;));&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p data-pid=&quot;d7mdKfLW&quot;&gt;多余多线程的消费者生产者来说 占位成功在这里保证，success =rte_atomic32_cmpset(&amp;amp;r-&amp;gt;prod.head,*old_head,*new_head);单生产者则直接占位成功。&lt;/p&gt;&lt;p data-pid=&quot;Fk8gwuMx&quot;&gt;元素入队如下代码，随后我会介绍环形队列的32索引。&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;&lt;span class=&quot;k&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;__rte_always_inline&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt;
&lt;span class=&quot;nf&quot;&gt;__rte_ring_dequeue_elems&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;rte_ring&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;r&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;uint32_t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cons_head&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;obj_table&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;uint32_t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;esize&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;uint32_t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;num&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
&lt;span class=&quot;cm&quot;&gt;/* 8B and 16B copies implemented individually to retain
&lt;/span&gt;&lt;span class=&quot;cm&quot;&gt; * the current performance.
&lt;/span&gt;&lt;span class=&quot;cm&quot;&gt; */&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;esize&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;8&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;__rte_ring_dequeue_elems_64&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;r&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cons_head&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;obj_table&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;num&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;esize&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;16&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;__rte_ring_dequeue_elems_128&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;r&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cons_head&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;obj_table&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;num&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;uint32_t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;idx&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;scale&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;nr_idx&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;nr_num&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;nr_size&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;cm&quot;&gt;/* Normalize to uint32_t */&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;scale&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;esize&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;/&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;sizeof&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;uint32_t&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;nr_num&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;num&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;scale&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;idx&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cons_head&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;r&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;mask&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;nr_idx&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;idx&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;scale&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;nr_size&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;r&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;size&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;scale&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;__rte_ring_dequeue_elems_32&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;r&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;nr_size&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;nr_idx&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;obj_table&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;nr_num&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p data-pid=&quot;uN-CyDjr&quot;&gt;再来看最后更新tail的代码, 对于非单线程的生产者在这一步保证操作原子性，rte_wait_until_equal_32(&amp;amp;ht-&amp;gt;tail, old_val, __ATOMIC_RELAXED);同时使用了内存屏障。&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;&lt;span class=&quot;k&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;__rte_always_inline&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt;
&lt;span class=&quot;nf&quot;&gt;__rte_ring_update_tail&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;rte_ring_headtail&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ht&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;uint32_t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;old_val&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;uint32_t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;new_val&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;uint32_t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;single&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;uint32_t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;enqueue&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;enqueue&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;rte_smp_wmb&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;else&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;rte_smp_rmb&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
&lt;span class=&quot;cm&quot;&gt;/*
&lt;/span&gt;&lt;span class=&quot;cm&quot;&gt; * If there are other enqueues/dequeues in progress that preceded us,
&lt;/span&gt;&lt;span class=&quot;cm&quot;&gt; * we need to wait for them to complete
&lt;/span&gt;&lt;span class=&quot;cm&quot;&gt; */&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;!&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;single&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;rte_wait_until_equal_32&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ht&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;tail&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;old_val&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;__ATOMIC_RELAXED&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;ht&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;tail&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;new_val&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&quot;h_608143587_10&quot; data-into-catalog-status=&quot;&quot;&gt;6.2 出队&lt;/h3&gt;&lt;p data-pid=&quot;Eoj7jcxC&quot;&gt;出队的操作参考入队留给小伙伴们自己思考过程，其实就是cond的位置修改了，这里我们先省略画图过程，看总体的过程代码：&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;&lt;span class=&quot;k&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;__rte_always_inline&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;
&lt;span class=&quot;nf&quot;&gt;__rte_ring_do_dequeue_elem&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;rte_ring&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;r&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;obj_table&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;esize&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;enum&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;rte_ring_queue_behavior&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;behavior&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;is_sc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;available&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;uint32_t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cons_head&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cons_next&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;uint32_t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;entries&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;n&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;__rte_ring_move_cons_head&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;r&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;is_sc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;behavior&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cons_head&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cons_next&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;entries&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;n&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;goto&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;end&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;__rte_ring_dequeue_elems&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;r&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cons_head&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;obj_table&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;esize&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;__rte_ring_update_tail&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;r&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cons&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cons_head&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cons_next&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;is_sc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

&lt;span class=&quot;nl&quot;&gt;end&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;available&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;NULL&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;available&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;entries&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p data-pid=&quot;sTtWqkB8&quot;&gt;有兴趣的可以自己怼着代码把多生产多消费者的出队过程图画一下，代码写的很简单，考点还蛮多，想象一下如果让你自己实现一个无锁环形队列，你的思维过程有时如呢？&lt;/p&gt;&lt;h3 id=&quot;h_608143587_11&quot; data-into-catalog-status=&quot;&quot;&gt;6.3 32-bit 索引&lt;/h3&gt;&lt;p data-pid=&quot;FEq7PnHX&quot;&gt;上一节途中的prod_head、prod_tail、cons_head 和 cons_tail 索引用箭头表示。在实际实现中，这些值并不像假设的那样介于 0 和 size(ring)-1 之间。索引介于 0 和 2^32 -1 之间，我们在访问对象表（环本身）时屏蔽它们的值。 32 位模还意味着如果结果溢出 32 位数字范围，对索引的操作（例如，加/减）将自动执行 2^32 模。&lt;br/&gt;&lt;br/&gt;下面是两个示例，有助于解释如何在环中使用索引。&lt;/p&gt;&lt;p data-pid=&quot;yrW1Lkkl&quot;&gt;为了简化说明，使用模 16 位运算而不是模 32 位运算。此外，四个索引被定义为无符号 16 位整数，而不是更实际情况下的无符号 32 位整数。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-b1b4f9e2bf2bcae0e2bdf9b23c285d91_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1204&quot; data-rawheight=&quot;332&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic2.zhimg.com/v2-b1b4f9e2bf2bcae0e2bdf9b23c285d91_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1204&quot; data-rawheight=&quot;332&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic2.zhimg.com/v2-b1b4f9e2bf2bcae0e2bdf9b23c285d91_r.jpg&quot; data-actualsrc=&quot;https://pic2.zhimg.com/v2-b1b4f9e2bf2bcae0e2bdf9b23c285d91_b.jpg&quot;/&gt;&lt;figcaption&gt;第一个例子&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-pid=&quot;5OyS2B3C&quot;&gt;这个队列包含11000个对象。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-8a4386183c12c9cf6b6b48dfd290c47d_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1198&quot; data-rawheight=&quot;328&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic2.zhimg.com/v2-8a4386183c12c9cf6b6b48dfd290c47d_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1198&quot; data-rawheight=&quot;328&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic2.zhimg.com/v2-8a4386183c12c9cf6b6b48dfd290c47d_r.jpg&quot; data-actualsrc=&quot;https://pic2.zhimg.com/v2-8a4386183c12c9cf6b6b48dfd290c47d_b.jpg&quot;/&gt;&lt;figcaption&gt;第二个例子&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-pid=&quot;gH78mq4h&quot;&gt;这个队列包含了12536个对象。&lt;/p&gt;&lt;p data-pid=&quot;aMRA6CKA&quot;&gt;为了便于理解，我们在上面的例子中使用了模65536运算。在实际执行情况下，这是多余的，效率低下，但在结果溢出时自动完成&lt;/p&gt;&lt;p data-pid=&quot;g41armd4&quot;&gt;代码始终保持生产者和消费者之间的距离在 0 和 size(ring)-1 之间。由于这个属性，我们可以在模 32 位基数中对 2 个索引值进行减法：这就是索引溢出不是问题的原因。&lt;br/&gt;&lt;br/&gt;在任何时候，entries 和 free_entries 都在 0 和 size(ring)-1 之间，即使只有第一个减法项溢出了：&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;&lt;span class=&quot;n&quot;&gt;uint32_t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;entries&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;prod_tail&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cons_head&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;uint32_t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;free_entries&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;mask&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cons_tail&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;prod_head&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&quot;h_608143587_12&quot; data-into-catalog-status=&quot;&quot;&gt;7.生产者消费者模式的介绍&lt;/h2&gt;&lt;p data-pid=&quot;bB8e7g-o&quot;&gt;5.1我们提到了rte_ring 支持生产者和消费者的不同同步模式。这些模式可以在环创建/初始化时通过标志参数指定。那应该可以帮助用户以最适合其特定使用场景的方式配置环。&lt;/p&gt;&lt;ol&gt;&lt;li data-pid=&quot;EGcR6ljY&quot;&gt;MP/MC (默认模式)&lt;/li&gt;&lt;/ol&gt;&lt;p data-pid=&quot;vXcs_sFP&quot;&gt;多生产者（/多消费者）模式。这是环的默认入队（/出队）模式。在这种模式下，多个线程可以将对象入队（/出队）到（/从）环中。对于“经典”DPDK 部署（每个内核一个线程），这通常是最合适和最快的同步模式。作为一个众所周知的限制 - 它可以在一些过度使用的场景中表现得非常纯粹的呢。&lt;/p&gt;&lt;p data-pid=&quot;-DhyHVbM&quot;&gt;2. SP/SC&lt;/p&gt;&lt;p data-pid=&quot;zHooUpXw&quot;&gt;单一生产者（/单一消费者）模式。在这种模式下，一次只允许一个线程将对象入队（/出队）到（/从）环中。&lt;/p&gt;&lt;p data-pid=&quot;-d7S6kRf&quot;&gt;3.  MP_RTS/MC_RTS&lt;/p&gt;&lt;p data-pid=&quot;a3OJIF3j&quot;&gt;具有 Relaxed Tail Sync (RTS) 模式的多生产者（/多消费者）。与原始 MP/MC 算法的主要区别在于，tail 值不是由每个完成入队/出队的线程增加的，而是由最后一个线程增加的。这允许线程避免在环尾值上自旋，将实际尾值更改留给给定实例的最后一个线程。该技术有助于避免尾部更新时的 Lock-Waiter-Preemption (LWP) 问题，并改善过度使用系统的平均入队/出队时间。为实现这一点，RTS 需要 2 个 64 位 CAS 用于每个入队（/出队）操作：一个用于头部更新，第二个用于尾部更新。相比之下，原始 MP/MC 算法需要一个 32 位 CAS 来更新头部和等待/自旋尾部值。&lt;/p&gt;&lt;p data-pid=&quot;RpflEXp4&quot;&gt;4. MP_HTS/MC_HTS&lt;/p&gt;&lt;p data-pid=&quot;Fi8SD5eZ&quot;&gt;具有头/尾同步 (HTS) 模式的多生产者（/多消费者）。在那种模式下，入队/出队操作是完全序列化的：在任何给定时刻，只有一个入队/出队操作可以进行。这是通过仅当 head.value == tail.value 时允许线程继续更改 head.value 来实现的。 head 和 tail 值都自动更新（作为一个 64 位值）。为了实现 64 位 CAS，head 更新例程使用了它。该技术还避免了尾部更新时的 Lock-Waiter-Preemption (LWP) 问题，并有助于改善过度使用场景中的环入队/出队行为。完全序列化的生产者/消费者的另一个优势 - 它提供了为 rte_ring 实现 MT 安全查看 API 的能力。&lt;/p&gt;&lt;h2 id=&quot;h_608143587_13&quot; data-into-catalog-status=&quot;&quot;&gt;8.我来提问啦&lt;/h2&gt;&lt;p data-pid=&quot;kQ48Yb9i&quot;&gt;我在每篇的技术介绍都会涉及提问环节，这部分也是面试官最常问的关于此章节的一些题目，至于答案，看了木木的文章再发散一下自己的思维应该都可以，后面就不啰嗦直接问啦。&lt;/p&gt;&lt;p data-pid=&quot;_tIvIYNo&quot;&gt;1 请用你熟悉的代码实现一个无锁环形队列&lt;/p&gt;&lt;p data-pid=&quot;ThFMaCYM&quot;&gt;2 Ring Buffer是怎么保证无锁的呢，请阐述原理？&lt;/p&gt;&lt;p data-pid=&quot;P_QsFmwa&quot;&gt;3 怎么保证Ring Buffer不会被写满，如果写满了我们有什么补救措施么？&lt;/p&gt;&lt;p data-pid=&quot;ur730Klg&quot;&gt;4 DPDK的Ring Buffer一般被用来处理哪些场景和任务呢？&lt;/p&gt;&lt;h2 id=&quot;h_608143587_14&quot; data-into-catalog-status=&quot;&quot;&gt;9.参考文档&lt;/h2&gt;&lt;p data-pid=&quot;3haxxWBi&quot;&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//doc.dpdk.org/guides-21.11/prog_guide/ring_lib.html&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;https://doc.dpdk.org/guides-21.11/prog_guide/ring_lib.html7. Ring Library - Data Plane Development Kit 21.11.3 documentationhttps://doc.dpdk.org/guides-21.11/prog_guide/ring_lib.html&lt;/a&gt;&lt;/p&gt;&lt;p/&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>3aeca1a0885587ceab59686e32f636a4</guid>
<title>写 Rust，有三大内伤</title>
<link>https://toutiao.io/k/dm1bulk</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content js_underline_content             autoTypeSetting24psection&amp;#10;            &quot; id=&quot;js_content&quot;&gt;&lt;p data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.1175925925925926&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/MOwlO0INfQorLT4hmMibiaMIuR4ic1Og7NvFicj4baSvkEhCOSHFgrs2fyhrpTiaiaeIYwBFRAuX3rpwJLXOvUwd5luQ/640?wx_fmt=gif&quot; data-type=&quot;gif&quot; data-w=&quot;1080&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.42777777777777776&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/MOwlO0INfQpPyq7oFrCYh96jSYamGq7e7iav3FdicVZoibgsSdMWV5QnCictm1x6Jrtnxsx76KLcQAP2wJBtiaSiadLw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1800&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;作者 | Roman Kashitsyn&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;编译 | 言征&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;Rust是语言设计领域的一个热点。它允许我们用简洁、可移植、有时甚至是漂亮的代码构建高效、内存安全的程序。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;然而，凡事都有两面，不会到处都是玫瑰和阳光。内存管理的细节通常会让开发工作陷入抓狂，并使代码比“高级”编程语言（如Haskell或OCaml）中的，更丑陋、更重复。最让人恼怒的是，在几乎所有情况下，这些问题都不是编译器的缺陷，而是Rust团队设计选择的直接后果。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;《编程元素》一书中，作者Alexander Stepanov写到：“函数式编程处理值；命令式编程处理对象。”本文通过丰富的案例详细介绍了如果你以函数式编程思维来处理Rust，它会有多令开发者沮丧，以及Rust也别无选择的原因。建议收藏。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.1259259259259259&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/MOwlO0INfQoOJQQprmIGVMDdTdhZl4ib6SlG4gLUichgR8iaYjPK3ZttOJch09cCxSSgq7E1eLAlSa4af2VQFice2g/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;对象和引用：万恶之源&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;值和对象起着互补的作用。值是不变的，并且与计算机中的任何特定实现无关。对象是可变的，并且具有特定于计算机的实现。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;——Alexander Stepanov,&quot;Elements of Programming&quot;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;在深入研究Rust之前，了解对象、值和引用之间的差异很有帮助。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;在本文的上下文中，值是具有不同身份的实体，例如数字和字符串。对象是计算机内存中值的表示。引用是我们可以用来访问对象或其部分的对象的地址。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.2902467685076381&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/MOwlO0INfQpPyq7oFrCYh96jSYamGq7ewBzicUJnGia5JEI7dczLnC0DGb0g1SYcicJfBSx3yIELHEJTbxSMITusQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;851&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;系统编程语言，如C++和Rust，迫使程序员处理对象和引用之间的区别。这种区别使我们能够编写出惊人的快速代码，但代价很高：这是一个永无止境的bug来源。如果程序的其他部分引用对象，那么修改对象的内容几乎总是一个错误。有多种方法可以解决此问题：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;忽略掉问题，相信程序员的操作。大多数传统的系统编程语言，如C++，都走了这条路。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;使所有对象不可变。该选项是Haskell和Clojure中纯函数编程技术的基础。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;完全禁止引用。Val语言探索了这种编程风格。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;采用防止修改引用对象的类型系统。ATS和Rust等语言选择了这条路。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;对象和引用之间的区别也是意外复杂性和选择爆炸的根源。一种具有不可变对象和自动内存管理的语言包容开发者对这种区别的盲区，并将一切视为一个值（至少在纯代码中）。统一的存储模型解放了程序员的思考精力，使其能够编写更具表达力和优雅的代码。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;然而，我们在便利性上获得的东西，却在效率上失去了：纯功能程序通常需要更多的内存，可能会变得无响应，并且更难优化，这意味着项目的进度会很赶。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.1259259259259259&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/MOwlO0INfQoOJQQprmIGVMDdTdhZl4ib6ojD8pHUQOsKpMfyhXp67maIRcFLyAdv0lgYYV3OI2g2zwpRHL6ljYg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;内伤1：漏洞百出的抽象&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;手动内存管理和所有权感知类型系统会干扰我们将代码抽象为更小的部分的能力。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.05555555555555555&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/MOwlO0INfQoOJQQprmIGVMDdTdhZl4ib6JkYWGCk2JF9nQdIF7cT1aXTCP3vYb9we91tAhMU02XkqjsicVwKuEWg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;公共表达式消除&lt;/span&gt;&lt;/strong&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;将公共表达式提取到变量中可能会带来意想不到的挑战。让我们从以下代码片段开始。&lt;/span&gt;&lt;/section&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;let&lt;/span&gt; x = f(&lt;span&gt;&quot;a very long string&quot;&lt;/span&gt;.to_string());&lt;br/&gt;&lt;span&gt;let&lt;/span&gt; y = g(&lt;span&gt;&quot;a very long string&quot;&lt;/span&gt;.to_string());&lt;br/&gt;// …&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;左右滑动查看完整代码&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;如上, &quot;a very long string&quot;.to_string() ，我们的第一直觉是为表达式指定一个名称并使用两次：&lt;/span&gt;&lt;/section&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;let&lt;/span&gt; s = &lt;span&gt;&quot;a very long string&quot;&lt;/span&gt;.to_string();&lt;br/&gt;&lt;span&gt;let&lt;/span&gt; x = f(s);&lt;br/&gt;&lt;span&gt;let&lt;/span&gt; y = g(s);&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;左右滑动查看完整代码&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;然而，我们的第一个雏形版本不会通过编译，因为String类型没有实现Copy特性。我们必须改用以下表达式：&lt;/span&gt;&lt;/section&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;let&lt;/span&gt; s = &lt;span&gt;&quot;a very long string&quot;&lt;/span&gt;.to_string();&lt;br/&gt;f(s.clone());&lt;br/&gt;g(s);&lt;span/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;左右滑动查看完整代码&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;如果我们关心额外的内存分配，因为复制内存变得显式，我们可以从积极的角度看到额外的冗长。但在实践中，这可能会很烦人，特别是当你在两个月后添加&lt;/span&gt;&lt;/section&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;h(s) 。&lt;br/&gt;&lt;span&gt;let&lt;/span&gt; s = &lt;span&gt;&quot;a very long string&quot;&lt;/span&gt;.to_string();&lt;br/&gt;f(s.clone());&lt;br/&gt;g(s);&lt;br/&gt;&lt;br/&gt;// fifty lines of code...&lt;br/&gt;&lt;br/&gt;h(s); // ← won’t compile, you need scroll up and update g(s).&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;左右滑动查看完整代码&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.05555555555555555&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/MOwlO0INfQoOJQQprmIGVMDdTdhZl4ib6cugSvic8czqkVRmoRXljmS1qPjicIMu1iaHkaNzsBpxUTq9HsXhsfXZibg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;同态限制&lt;/span&gt;&lt;/strong&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;Rust中, let x = y; 并不意味着t x和y是同一个。一个自然中断的例子是，当y是一个重载函数时，这个自然属性就会中断。例如，让我们为重载函数定义一个短名称。&lt;/span&gt;&lt;/section&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;// Do we have to &lt;span&gt;type&lt;/span&gt; &lt;span&gt;&quot;MyType::from&quot;&lt;/span&gt; every time?&lt;br/&gt;// How about introducing an &lt;span&gt;alias&lt;/span&gt;?&lt;br/&gt;&lt;span&gt;let&lt;/span&gt; x = MyType::from(b&lt;span&gt;&quot;bytes&quot;&lt;/span&gt;);&lt;br/&gt;&lt;span&gt;let&lt;/span&gt; y = MyType::from(&lt;span&gt;&quot;string&quot;&lt;/span&gt;);&lt;br/&gt;&lt;br/&gt;// Nope, Rust won&lt;span&gt;&#x27;t let us.&lt;br/&gt;let f = MyType::from;&lt;br/&gt;let x = f(b&quot;bytes&quot;);&lt;br/&gt;let y = f(&quot;string&quot;);&lt;br/&gt;//      - ^^^^^^^^ expected slice `[u8]`, found `str`&lt;br/&gt;//      |&lt;br/&gt;//      arguments to this function are incorrect&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;左右滑动查看完整代码&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;该代码段未编译，因为编译器将f绑定到MyType:：from的特定实例，而不是多态函数。我们必须显式地使f多态。&lt;/span&gt;&lt;/section&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;// Compiles fine, but is longer than the original.&lt;br/&gt;fn f&amp;lt;T: Into&amp;lt;MyType&amp;gt;&amp;gt;(t: T) -&amp;gt; MyType { t.into() }&lt;br/&gt;&lt;br/&gt;&lt;span&gt;let&lt;/span&gt; x = f(b&lt;span&gt;&quot;bytes&quot;&lt;/span&gt;);&lt;br/&gt;&lt;span&gt;let&lt;/span&gt; y = f(&lt;span&gt;&quot;string&quot;&lt;/span&gt;);&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;左右滑动查看完整代码&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;Haskell程序员可能会发现这个问题很熟悉：它看起来可疑地类似于可怕的单态限制！不幸的是，rustc没有NoMonomorphismRestriction字段。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.05555555555555555&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/MOwlO0INfQoOJQQprmIGVMDdTdhZl4ib6HABjibjR50siaqjSytk5OFkEoauCGQD6N2CaoeuxzRoHCIZmo4VQsFAQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;函数abstraction&lt;/span&gt;&lt;/strong&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;将代码分解为函数可能比预期的要困难，因为编译器无法解释跨函数边界的混叠。假设我们有以下代码。&lt;/span&gt;&lt;/section&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;impl State {&lt;br/&gt;fn tick(&amp;amp;mut self) {&lt;br/&gt;self.state = match self.state {&lt;br/&gt;Ping(s) =&amp;gt; { self.x += 1; Pong(s) }&lt;br/&gt;Pong(s) =&amp;gt; { self.x += 1; Ping(s) }&lt;br/&gt;}&lt;br/&gt;}&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;section&gt;&lt;span/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;左右滑动查看完整代码&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;self.x+=1语句出现多次。为什么不把它抽取成一个方法…&lt;/span&gt;&lt;/section&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;impl State {&lt;br/&gt;fn tick(&amp;amp;mut self) {&lt;br/&gt;self.state = match self.state {&lt;br/&gt;Ping(s) =&amp;gt; { self.inc(); Pong(s) } // ← compile error&lt;br/&gt;Pong(s) =&amp;gt; { self.inc(); Ping(s) } // ← compile error&lt;br/&gt;}&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;fn inc(&amp;amp;mut self) {&lt;br/&gt;self.x += 1;&lt;br/&gt;}&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;section&gt;&lt;span/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;左右滑动查看完整代码&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;Rust会对我们咆哮，因为该方法试图以独占方式重新借用self.state，而周围的上下文仍然保持对self.state的可变引用。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;Rust 2021版实现了不相交捕获，以解决闭包的类似问题。在Rust 2021之前，类似于x.f.m（||x.y）的代码可能无法编译，但可以手动内联m，闭包可以解决该错误。例如，假设我们有一个结构，它拥有一个映射和映射条目的默认值。&lt;/span&gt;&lt;/section&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;struct S { map: HashMap&amp;lt;i64, String&amp;gt;, def: String }&lt;br/&gt;&lt;br/&gt;impl S {&lt;br/&gt;fn ensure_has_entry(&amp;amp;mut self, key: i64) {&lt;br/&gt;// Doesn&lt;span&gt;&#x27;t compile with Rust 2018:&lt;br/&gt;self.map.entry(key).or_insert_with(|| self.def.clone());&lt;br/&gt;// |         ------            -------------- ^^ ---- second borrow occurs...&lt;br/&gt;// |         |                 |              |&lt;br/&gt;// |         |                 |              immutable borrow occurs here&lt;br/&gt;// |         |                 mutable borrow later used by call&lt;br/&gt;// |         mutable borrow occurs here&lt;br/&gt;}&lt;br/&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;左右滑动查看完整代码&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;然而，如果我们内联or_insert_with的定义和lambda函数，编译器最终可以看到借用规则成立&lt;/span&gt;&lt;/section&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;struct S { map: HashMap&amp;lt;i64, String&amp;gt;, def: String }&lt;br/&gt;&lt;br/&gt;impl S {&lt;br/&gt;fn ensure_has_entry(&amp;amp;mut self, key: i64) {&lt;br/&gt;use std::collections::hash_map::Entry::*;&lt;br/&gt;// This version is more verbose, but it works with Rust 2018.&lt;br/&gt;match self.map.entry(key) {&lt;br/&gt;Occupied(mut e) =&amp;gt; e.get_mut(),&lt;br/&gt;Vacant(mut e) =&amp;gt; e.insert(self.def.clone()),&lt;br/&gt;};&lt;br/&gt;}&lt;br/&gt;}&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;左右滑动查看完整代码&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;当有人问你，“Rust闭包可以做哪些命名函数不能做的事情？”你会知道答案：它们只能捕获它们使用的字段。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.05555555555555555&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/MOwlO0INfQoOJQQprmIGVMDdTdhZl4ib6Q1FNFHSRqQnlDZKglxuHpu0b3iap4QrDrcjic5QmMRLE1fJvH0x7QyeA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;Newtype&lt;/span&gt;&lt;span&gt;抽象&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;Rust中的新类型习惯用法允许程序员为现有类型赋予新的标识。该习语的名称来自Haskell的newtype关键字。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;这个习惯用法的一个常见用法是处理孤立规则，并为别名类型定义特征实现。例如，下面的代码定义了一种以十六进制显示字节向量的新类型。&lt;/span&gt;&lt;/section&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;struct Hex(Vec&amp;lt;u8&amp;gt;);&lt;br/&gt;&lt;br/&gt;impl std::fmt::Display &lt;span&gt;for&lt;/span&gt; Hex {&lt;br/&gt;fn fmt(&amp;amp;self, f: &amp;amp;mut std::fmt::Formatter&amp;lt;&lt;span&gt;&#x27;_&amp;gt;) -&amp;gt; std::fmt::Result {&lt;br/&gt;self.0.iter().try_for_each(|b| write!(f, &quot;{:02x}&quot;, b))&lt;br/&gt;}&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;println!(&quot;{}&quot;, Hex((0..32).collect()));&lt;br/&gt;// =&amp;gt; 000102030405060708090a0b0c0d0e0f101112131415161718191a1b1c1d1e1f&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;左右滑动查看完整代码&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;新的类型习惯用法是有效的：机器内存中十六进制类型的表示与Vec＜u8＞的表示相同。然而，尽管表示形式相同，编译器并没有将我们的新类型视为Vec＜u8＞的强别名。例如，如果不重新分配外向量，我们就不能安全地将Vec&amp;lt;Hex&amp;gt;转换为Vec&amp;lt;Vec&amp;lt;u8&amp;gt;&amp;gt;并返回。此外，如果不复制字节，我们无法安全地将&amp;amp;Vec＜u8＞强制为&amp;amp;Hex。&lt;/span&gt;&lt;/section&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;fn complex_function(bytes: &amp;amp;Vec&amp;lt;u8&amp;gt;) {&lt;br/&gt;// … a lot of code …&lt;br/&gt;&lt;br/&gt;println!(&lt;span&gt;&quot;{}&quot;&lt;/span&gt;, &amp;amp;Hex(bytes));        // That does not work.&lt;br/&gt;println!(&lt;span&gt;&quot;{}&quot;&lt;/span&gt;, Hex(bytes.clone())); // That works but is slow.&lt;br/&gt;&lt;br/&gt;// … a lot of code …&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;左右滑动查看完整代码&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;总之，newtype习语是一种漏洞百出的抽象，因为它是一种惯例，而不是一种一流的语言特性。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.05555555555555555&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/MOwlO0INfQoOJQQprmIGVMDdTdhZl4ib6ATaaNrWKZRnv7GGoYkPZShMlkSY0Bv58h30dicmJB5TKmb59rU3fdiaA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;视图和捆绑包&lt;/span&gt;&lt;/strong&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;每当程序员描述结构字段或向函数传递参数时，她必须决定字段/参数是对象还是引用。或者最好的选择是在运行时决定？这是很多决策！不幸的是，有时没有最佳选择。在这种情况下，我们会咬紧牙关，用稍微不同的字段类型定义同一类型的几个版本。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;Rust中的大多数函数通过引用获取参数，并将结果作为自包含的对象返回。这种模式非常常见，因此定义新术语可能会有所帮助。我用生存期参数视图调用输入类型，因为它们最适合检查数据。我称常规输出类型为bundle，因为它们是独立的。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;以下代码段来自Lucet WebAssembly运行时。&lt;/span&gt;&lt;/section&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;/// A WebAssembly global along with its &lt;span&gt;export&lt;/span&gt; specification.&lt;br/&gt;/// The lifetime parameter exists to support zero-copy deserialization&lt;br/&gt;/// &lt;span&gt;for&lt;/span&gt; the `&amp;amp;str` fields at the leaves of the structure.&lt;br/&gt;/// For a variant with owned types at the leaves, see `OwnedGlobalSpec`.&lt;br/&gt;pub struct GlobalSpec&amp;lt;&lt;span&gt;&#x27;a&amp;gt; {&lt;br/&gt;global: Global&amp;lt;&#x27;&lt;/span&gt;a&amp;gt;,&lt;br/&gt;export_names: Vec&amp;lt;&amp;amp;&lt;span&gt;&#x27;a str&amp;gt;,&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;…&lt;br/&gt;&lt;br/&gt;/// A variant of `GlobalSpec` with owned strings throughout.&lt;br/&gt;/// This type is useful when directly building up a value to be serialized.&lt;br/&gt;pub struct OwnedGlobalSpec {&lt;br/&gt;global: OwnedGlobal,&lt;br/&gt;export_names: Vec&amp;lt;String&amp;gt;,&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;左右滑动查看完整代码&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;作者复制了GlobalSpec数据结构，以支持两种用例：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;在具有自动内存管理的语言中，我们可以在单个类型声明中将GlobalSpec＜a＞的效率与OwnedGlobalSpec的多功能性结合起来。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.1259259259259259&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/MOwlO0INfQoOJQQprmIGVMDdTdhZl4ib6O3T8iahkmTbcEjAuV6rXuzmq4SSibXZ8Tqk3TfvrIP54wMx2PtEYzraw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;内伤2：组合便成了“苦修”&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;在Rust中，从较小的部分组合程序，简直会令人沮丧。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.05555555555555555&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/MOwlO0INfQoOJQQprmIGVMDdTdhZl4ib6JkYWGCk2JF9nQdIF7cT1aXTCP3vYb9we91tAhMU02XkqjsicVwKuEWg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;对象组合&lt;/span&gt;&lt;/strong&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;当开发者有两个不同的对象时，他们通常希望将它们组合成一个结构。听起来很简单？Rust中可不容易。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;假设我们有一个对象Db，它有一个方法为您提供另一个对象Snapshot＜a＞。快照的生存期取决于数据库的生存期。&lt;/span&gt;&lt;/section&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;struct Db { /* … */ }&lt;br/&gt;&lt;br/&gt;struct Snapshot&amp;lt;&lt;span&gt;&#x27;a&amp;gt; { /* … */ }&lt;br/&gt;&lt;br/&gt;impl Db { fn snapshot&amp;lt;&#x27;&lt;/span&gt;a&amp;gt;(&amp;amp;&lt;span&gt;&#x27;a self) -&amp;gt; Snapshot&amp;lt;&#x27;&lt;/span&gt;a&amp;gt;; }&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;左右滑动查看完整代码&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;我们可能希望将数据库与其快照捆绑在一起，但Rust不允许。&lt;/span&gt;&lt;/section&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;// There is no way to define the following struct without&lt;br/&gt;// contaminating it with lifetimes.&lt;br/&gt;struct DbSnapshot {&lt;br/&gt;snapshot: Snapshot&amp;lt;&lt;span&gt;&#x27;a&amp;gt;, // what should &#x27;&lt;/span&gt;a be?&lt;br/&gt;db: Arc&amp;lt;Db&amp;gt;,&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;左右滑动查看完整代码&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;Rust拥趸者称这种安排为“兄弟指针”。Rust禁止安全代码中的兄弟指针，因为它们破坏了Rust的安全模型。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;正如在对象、值和引用部分中所讨论的，修改被引用的对象通常是一个bug。在我们的例子中，快照对象可能取决于db对象的物理位置。如果我们将DbSnapshot作为一个整体移动，则db字段的物理位置将发生变化，从而损坏快照对象中的引用。我们知道移动Arc&amp;lt;Db&amp;gt;不会改变Db对象的位置，但无法将此信息传递给rustc。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;DbSnapshot的另一个问题是它的字段销毁顺序很重要。如果Rust允许同级指针，更改字段顺序可能会引入未定义的行为：快照的析构函数可能会尝试访问已破坏的db对象的字段。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.05555555555555555&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/MOwlO0INfQoOJQQprmIGVMDdTdhZl4ib6cugSvic8czqkVRmoRXljmS1qPjicIMu1iaHkaNzsBpxUTq9HsXhsfXZibg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;无法对boxes进行模式匹配&lt;/span&gt;&lt;/strong&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;在Rust中，我们无法对Box、Arc、String和Vec等装箱类型进行模式匹配。这种限制通常会破坏交易，因为我们在定义递归数据类型时无法避免装箱。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;For example, let us try to match a vector of strings.例如，我们试图对字符串Vector做一个匹配。&lt;/span&gt;&lt;/section&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;let&lt;/span&gt; x = vec![&lt;span&gt;&quot;a&quot;&lt;/span&gt;.to_string(), &lt;span&gt;&quot;b&quot;&lt;/span&gt;.to_string()];&lt;br/&gt;match x {&lt;br/&gt;//    - &lt;span&gt;help&lt;/span&gt;: consider slicing here: `x[..]`&lt;br/&gt;[&lt;span&gt;&quot;a&quot;&lt;/span&gt;, &lt;span&gt;&quot;b&quot;&lt;/span&gt;] =&amp;gt; println!(&lt;span&gt;&quot;OK&quot;&lt;/span&gt;),&lt;br/&gt;//  ^^^^^^^^^^ pattern cannot match with input &lt;span&gt;type&lt;/span&gt; `Vec&amp;lt;String&amp;gt;`&lt;br/&gt;_ =&amp;gt; (),&lt;br/&gt;}&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;左右滑动查看完整代码&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;首先，我们不能匹配一个向量，只能匹配一个切片。幸运的是，编译器建议了一个简单的解决方案：我们必须用匹配表达式中的x[..]替换x。让我们试一试。&lt;/span&gt;&lt;/section&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;let&lt;/span&gt; x = vec![&lt;span&gt;&quot;a&quot;&lt;/span&gt;.to_string(), &lt;span&gt;&quot;b&quot;&lt;/span&gt;.to_string()];&lt;br/&gt;match x[..] {&lt;br/&gt;//    ----- this expression has &lt;span&gt;type&lt;/span&gt; `[String]`&lt;br/&gt;[&lt;span&gt;&quot;a&quot;&lt;/span&gt;, &lt;span&gt;&quot;b&quot;&lt;/span&gt;] =&amp;gt; println!(&lt;span&gt;&quot;OK&quot;&lt;/span&gt;),&lt;br/&gt;//   ^^^ expected struct `String`, found `&amp;amp;str`&lt;br/&gt;_ =&amp;gt; (),&lt;br/&gt;}&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;左右滑动查看完整代码&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;正如大家所看到的，删除一层框不足以让编译器满意。我们还需要在向量内取消字符串的框，这在不分配新向量的情况下是不可能的：&lt;/span&gt;&lt;/section&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;let&lt;/span&gt; x = vec![&lt;span&gt;&quot;a&quot;&lt;/span&gt;.to_string(), &lt;span&gt;&quot;b&quot;&lt;/span&gt;.to_string()];&lt;br/&gt;// We have to allocate new storage.&lt;br/&gt;&lt;span&gt;let&lt;/span&gt; x_for_match: Vec&amp;lt;_&amp;gt; = x.iter().map(|s| s.as_str()).collect();&lt;br/&gt;match &amp;amp;x_for_match[..] {&lt;br/&gt;[&lt;span&gt;&quot;a&quot;&lt;/span&gt;, &lt;span&gt;&quot;b&quot;&lt;/span&gt;] =&amp;gt; println!(&lt;span&gt;&quot;OK&quot;&lt;/span&gt;), // this compiles&lt;br/&gt;_ =&amp;gt; (),&lt;br/&gt;}&lt;br/&gt;Forget about balancing Red-Black trees &lt;span&gt;in&lt;/span&gt; five lines of code &lt;span&gt;in&lt;/span&gt; Rust&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;左右滑动查看完整代码&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;Forget about balancing Red-Black trees in five lines of code in Rust.&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;老实话，放弃在Rust用五行代码搞定平衡红黑树吧！&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.05555555555555555&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/MOwlO0INfQoOJQQprmIGVMDdTdhZl4ib6HABjibjR50siaqjSytk5OFkEoauCGQD6N2CaoeuxzRoHCIZmo4VQsFAQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;孤立规则&lt;/span&gt;&lt;/strong&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;Rust使用孤立（Orphan）规则来决定类型是否可以实现特征。对于非泛型类型，这些规则禁止在定义特征或类型的板条箱之外为类型实现特征。换句话说，定义特征的包必须依赖于定义类型的包，反之亦然。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.29088913282107576&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/MOwlO0INfQpPyq7oFrCYh96jSYamGq7eV0I1NRU9QTTKiapbqJCpNtnTO7YicdBic9UGty4GBTvGbzhAGXOdrcmPw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;911&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;这些规则使编译器很容易保证一致性，这是一种聪明的方式，可以说程序的所有部分都看到特定类型的相同特性实现。作为交换，这一规则使整合无关库中的特征和类型变得非常复杂。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;一个例子是我们只想在测试中使用的特性，例如proptest包中的任意特性。如果编译器从我们的包中派生类型的实现，我们可以节省很多类型，但我们希望我们的生产代码独立于proptest包。在完美的设置中，所有的任意实现都将进入一个单独的仅测试包。不幸的是，孤儿规则反对这种安排，迫使我们咬紧牙关，手动编写proptest策略。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;在孤立规则下，类型转换特性（如From和Into）也存在问题。我经常看到xxx类型的包开始很小，但最终成为编译链中的瓶颈。将这样的包拆分成更小的部分通常是令人畏惧的，因为复杂的类型转换网络将遥远的类型连接在一起。孤立规则不允许我们在模块边界上切割这些包，并将所有转换移动到一个单独的包中，而不需要做大量乏味的工作。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;不要误会：孤立规则是一个默认原则。Haskell允许您定义孤立实例，但程序员不赞成这种做法。让我难过的是无法逃脱孤儿规则。在大型代码库中，将大型包分解为较小的部分并维护浅依赖关系图是获得可接受编译速度的唯一途径。孤立规则通常会妨碍修剪依赖关系图。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.1259259259259259&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/MOwlO0INfQoOJQQprmIGVMDdTdhZl4ib6hstzqmSo5zAnrjSfHCLrHJscT0p587IuvAq9TqRlESXsnuhOSenJVQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;内伤3&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;Fearless Concurrency是一个谎言&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;Rust团队创造了术语Fearless Concurrency，以表明Rust可以帮助您避免与并行和并发编程相关的常见陷阱。尽管有这些说法，每次笔者在Rust程序中引入并发时，皮质醇水平都会升高。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.05555555555555555&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/MOwlO0INfQoOJQQprmIGVMDdTdhZl4ib6JkYWGCk2JF9nQdIF7cT1aXTCP3vYb9we91tAhMU02XkqjsicVwKuEWg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;Deadlocks&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;因此，对于Safe Rust程序来说，如果同步不正确而导致死锁或做一些无意义的事情，这是完全“好的”。很明显，这样的程序不是很好，但Rust只能握着你的手&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;——The Rustonomicon,Data Races and Race Conditions&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;Safe Rust可防止称为数据竞争的特定类型的并发错误。并发Rust程序还有很多其他方式可以不正确地运行。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;笔者亲身经历的一类并发错误是死锁。这类错误的典型解释包括两个锁和两个进程试图以相反的顺序获取锁。但是，如果您使用的锁不是可重入的（Rust的锁不是），那么只有一个锁就足以导致死锁。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;例如，下面的代码是错误的，因为它两次尝试获取相同的锁。如果do_something和helper_function很大，并且在源文件中相隔很远，或者如果我们在一个罕见的执行路径上调用helper_function，那么可能很难发现这个bug。&lt;/span&gt;&lt;/section&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;impl Service {&lt;br/&gt;pub fn do_something(&amp;amp;self) {&lt;br/&gt;&lt;span&gt;let&lt;/span&gt; guard = self.lock.read();&lt;br/&gt;// …&lt;br/&gt;self.helper_function(); // BUG: will panic or deadlock&lt;br/&gt;// …&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;fn helper_function(&amp;amp;self) {&lt;br/&gt;&lt;span&gt;let&lt;/span&gt; guard = self.lock.read();&lt;br/&gt;// …&lt;br/&gt;}&lt;br/&gt;}&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;左右滑动查看完整代码&lt;/span&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;RwLock:：read的文档提到，如果当前线程已经持有锁，则函数可能会死机。我得到的只是一个挂起的程序。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;一些语言试图在其并发工具包中提供解决此问题的方法。Clang编译器具有线程安全注释，支持一种可以检测竞争条件和死锁的静态分析形式。然而，避免死锁的最佳方法是不使用锁。从根本上解决这个问题的两种技术是软件事务内存（在Haskell、Clojure和Scala中实现）和actor模型（Erlang是第一种完全采用它的语言）。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.05555555555555555&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/MOwlO0INfQoOJQQprmIGVMDdTdhZl4ib6cugSvic8czqkVRmoRXljmS1qPjicIMu1iaHkaNzsBpxUTq9HsXhsfXZibg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;文件系统是共享资源&lt;/span&gt;&lt;/strong&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;Rust为我们提供了处理共享内存的强大工具。然而，一旦我们的程序需要与外部世界进行交互（例如，使用网络接口或文件系统），我们就只能靠自己了。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;span&gt;Rust在这方面与大多数现代语言相似。然而，它会给你一种虚假的安全感。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;千万要注意&lt;/strong&gt;，即使在Rust中，&lt;strong&gt;路径也是原始指针&lt;/strong&gt;。大多数文件操作本质上是不安全的，如果不正确同步文件访问，可能会导致数据竞争（广义上）。例如，截至2023年2月，我仍然在rustup(https://rustup.rs/)中遇到了一个长达六年的并发错误(https://github.com/rust-lang/rustup/issues/988)。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.05555555555555555&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/MOwlO0INfQoOJQQprmIGVMDdTdhZl4ib6HABjibjR50siaqjSytk5OFkEoauCGQD6N2CaoeuxzRoHCIZmo4VQsFAQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;隐式异步运行时&lt;/span&gt;&lt;/strong&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;我不能认真地相信量子理论,因为,物理学应该描写存在于时空之中，而没有“不可思议的超距作用”的实在。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;——爱因斯坦&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;笔者最喜欢Rust的一点是，它专注于本地推理。查看函数的类型签名通常会让自己对函数的功能有一个透彻的理解。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;然而，Rust中的异步编程是不同的。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;Rust支持async/.await语法来定义和组合异步函数，但运行时支持有限。几个库（称为异步运行时）定义了与操作系统交互的异步函数。tokio包是最流行的库。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;运行时的一个常见问题是它们依赖于隐式传递参数。例如，tokio运行时允许在程序中的任意点生成并发任务。为了使该函数工作，程序员必须预先构造一个运行时对象。&lt;/span&gt;&lt;/section&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;fn &lt;span&gt;innocently_looking_function&lt;/span&gt;() {&lt;br/&gt;tokio::spawn(some_async_func());&lt;br/&gt;// ^&lt;br/&gt;// |&lt;br/&gt;// This code will panic &lt;span&gt;if&lt;/span&gt; we remove this line. Spukhafte Fernwirkung!&lt;br/&gt;} //                                     |&lt;br/&gt;//                                     |&lt;br/&gt;fn &lt;span&gt;main&lt;/span&gt;() { //                           v&lt;br/&gt;&lt;span&gt;let&lt;/span&gt; _rt = tokio::runtime::Runtime::new().unwrap();&lt;br/&gt;innocently_looking_function();&lt;br/&gt;}&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;左右滑动查看完整代码&lt;/span&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;这些隐式参数将编译时错误转化为运行时错误。本来应该是编译错误的事情变成了“调试冒险”：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;有些人可能会认为，在整个调用堆栈中使用无处不在的参数是不符合逻辑的。显式传递所有参数是唯一可以很好扩展的方法。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.05555555555555555&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/MOwlO0INfQoOJQQprmIGVMDdTdhZl4ib6Q1FNFHSRqQnlDZKglxuHpu0b3iap4QrDrcjic5QmMRLE1fJvH0x7QyeA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;函数是有颜色的&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;2015年，Bob Nystrom在博客《你的函数是什么颜色》中说道：理性的人可能会认为语言讨厌我们。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;Rust的 async/.await语法简化了异步算法的封装，但同时也带来了相当多的复杂性问题：将每个函数涂成蓝色（同步）或红色（异步）。有新的规则需要遵循：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;同步函数可以调用其他同步函数并获得结果。异步函数可以调用和.await其他异步函数以获得结果。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;我们不能直接从sync函数调用和等待异步函数。我们需要一个异步运行时，它将为我们执行一个异步函数。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;我们可以从异步函数调用同步函数。但要小心！并非所有同步功能都是相同的蓝色。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;没错，有些sync函数非常神奇地变成了紫色：它们可以读取文件、连接线程或在couch上睡眠thread::sleep。我们不想从红色（异步）函数调用这些紫色（阻塞）函数，因为它们会阻塞运行时，并扼杀促使我们陷入异步混乱的性能优势。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;不幸的是，紫色函数非常吊轨：如果不检查函数的主体和调用图中所有其他函数的主体，就无法判断函数是否为紫色。这些主体还在进化，所以我们最好关注它们。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;真正的乐趣来自于拥有共享所有权的代码库，其中多个团队将同步和异步代码夹在一起。这样的软件包往往是bug筒仓，等待足够的系统负载来显示三明治中的另一个紫色缺陷，使系统无响应。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;具有围绕绿色线程构建的运行时的语言，如Haskell和Go，消除了函数颜色的泛滥。在这种语言中，从独立组件构建并发程序更容易、更安全。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.1259259259259259&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/MOwlO0INfQoOJQQprmIGVMDdTdhZl4ib65QFgOcKJzaCVbBqDotEJPTERiagyywB6MJ1Um666liay6EjnZ1SnecCA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;写在最后&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;C++之父Bjarne Stroustrup曾说，世界上只有两种语言：一种是人们总是抱怨的，另一种是没人用的。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;Rust是一种有“纪律型”的语言，它让许多重要的决策都得到了正确的处理，例如对安全的毫不妥协的关注、特质系统设计、缺乏隐式转换以及错误处理的整体方法。它允许我们相对快速地开发健壮且内存安全的程序，而不会影响执行速度。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;然而，笔者经常发现自己被意外的复杂性所淹没，特别是当我不太关心性能，并且想要快速完成一些工作时（例如，在测试代码中）。Rust会将程序解构成更小的部分，并将其由更小的部分来组合程序。此外，Rust仅部分消除了并发问题。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;最后，笔者只想说，没有哪种语言是万金油。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;原文链接：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;https://mmapped.blog/posts/15-when-rust-hurts.html#filesystem-shared-resource&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.43529411764705883&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/MOwlO0INfQorLT4hmMibiaMIuR4ic1Og7NvXM0ughK1ZXZV7CDCwy3r65IyibJVdPSOVgZSgDlfR06HWTmaavGDj6Q/640?wx_fmt=gif&quot; data-type=&quot;gif&quot; data-w=&quot;1020&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img __bg_gif&quot; data-ratio=&quot;0.125&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/p6Wl2LDMQlHC6pDXyQRaWjlWR5PIhukIUGV1nfK6H9qtHZoxnXtVdeztoFexkaevudmZ1MbV9qWNZTXiaopLyoQ/640?wx_fmt=gif&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&quot; data-w=&quot;720&quot; data-width=&quot;80%&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;●&lt;/span&gt;&lt;span&gt;&lt;a target=&quot;_blank&quot; href=&quot;https://mp.weixin.qq.com/s?__biz=MjM5ODI5Njc2MA==&amp;amp;mid=2655893653&amp;amp;idx=1&amp;amp;sn=ad6118dcf74a8052f68af06b523f74f5&amp;amp;chksm=bd75f5428a027c54827ef43b5a97566f6fada6f0f5737dc8a986b8ad1e63417574678836a7aa&amp;amp;token=306999611&amp;amp;lang=zh_CN&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;30岁的Ruby：单挑Java后，为何再难出头？‍&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;30岁的Ruby：单挑Java后，为何再难出头？&lt;/a&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;●&lt;/span&gt;&lt;a target=&quot;_blank&quot; href=&quot;https://mp.weixin.qq.com/s?__biz=MjM5ODI5Njc2MA==&amp;amp;mid=2655893647&amp;amp;idx=1&amp;amp;sn=0837f10caca47fa103c8f58f0acb18b1&amp;amp;chksm=bd75f5588a027c4e5df465feeeb6b9431f20dc572f3567611a60333b94edf7a30a1395691b82&amp;amp;token=306999611&amp;amp;lang=zh_CN&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;数十亿下载项目面临维护困境！负责人抱怨：开源被破坏到无人买单！‍&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;数十亿下载项目面临维护困境！负责人抱怨：开源被破坏到无人买单！&lt;/a&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;●&lt;/span&gt;&lt;span&gt;&lt;a target=&quot;_blank&quot; href=&quot;https://mp.weixin.qq.com/s?__biz=MjM5ODI5Njc2MA==&amp;amp;mid=2655893557&amp;amp;idx=1&amp;amp;sn=e7bb262c4f01a2ab67aafce2b0e53400&amp;amp;chksm=bd75f5e28a027cf4c6aa2418c9af59db56c765e2c81de2fa91418b13bd796937b7a43b428c47&amp;amp;token=2000459199&amp;amp;lang=zh_CN&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;3场PK，暴露了ChatGPT的层次！‍&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;/&gt;&lt;a target=&quot;_blank&quot; href=&quot;https://mp.weixin.qq.com/s?__biz=MjM5ODI5Njc2MA==&amp;amp;mid=2655893590&amp;amp;idx=1&amp;amp;sn=4f98eb52fb723ea19eed4ff79a543f1c&amp;amp;chksm=bd75f5818a027c97d59da07967b38b5bc347955b44da8a39847d60f1e85a8ebc5c9b49f2195e&amp;amp;token=306999611&amp;amp;lang=zh_CN&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;踩一踩ChatGPT！‍&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;踩一踩ChatGPT！&lt;/a&gt;&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;span&gt;&lt;strong data-brushtype=&quot;text&quot;&gt;三连给小编加鸡腿！&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;img class=&quot;__bg_gif rich_pages wxw-img&quot; data-ratio=&quot;0.8792270531400966&quot; data-type=&quot;gif&quot; data-w=&quot;207&quot; data-width=&quot;100%&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/MOwlO0INfQquLtXHaQicvGRPgAibGjW0vaaVUibQIQX0txR1SZDC4Sprjc3KyavQTRa6SWMtnTV42v52rCAkbia3gQ/640?wx_fmt=gif&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;mp-style-type data-value=&quot;3&quot;/&gt;&lt;/p&gt;&lt;/div&gt;

          
        &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>f7194ffe547e04d399908788637a54f3</guid>
<title>百亿数据，如何毫秒级返回？</title>
<link>https://toutiao.io/k/xu9mtab</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;blockquote&gt;&lt;p&gt;&lt;span&gt;大家好，我是苏三，今天我想和大家聊一聊实时索引的构建之道，来自我司 PB 级索引数据的实战经验，相信对大家肯定有帮助。&lt;/span&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;section&gt;&lt;mp-common-profile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mpprofile&quot; data-weui-theme=&quot;light&quot; data-id=&quot;Mzg4NjYyODc4OA==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/J4jTHmo8Xh6qM32ASOtVbXNoiaegrI26qLRw6r6FTI7dZw6TMT7vecvnjd1O8xSsM5MiajIuQZicxSC6KFK8TMpbg/0?wx_fmt=png&quot; data-nickname=&quot;java突击队&quot; data-alias=&quot;&quot; data-signature=&quot;技术经验分享&quot; data-from=&quot;0&quot; data-is_biz_ban=&quot;0&quot;/&gt;&lt;/section&gt;&lt;p&gt;近年来公司业务迅猛发展，数据量爆炸式增长，随之而来的的是海量数据查询等带来的挑战，我们需要数据量在十亿，甚至百亿级别的规模时依然能以秒级甚至毫秒级的速度返回，这样的话显然离不开搜索引擎的帮助，在搜索引擎中，ES（ElasticSearch）毫无疑问是其中的佼佼者，连续多年在 DBRanking 的搜索引擎中评测中排名第一，也是绝大多数大公司的首选，那么它与传统的 DB 如 MySQL 相比有啥优势呢，ES 的数据又是如何生成的，数据达到 PB 时又是如何保证 ES 索引数据的实时性以更好地满足业务的需求的呢。&lt;/p&gt;&lt;p&gt;本文会结合我司在 ES 上的实践经验与大家谈谈如何构建准实时索引的一些思路，希望对大家有所启发。本文目录如下&lt;/p&gt;&lt;ol class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;为什么要用搜索引擎，传统 DB 如 MySQL 不香吗&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;ES 索引数据构建&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;PB 级的 ES 准实时索引数据构建之道&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;h3&gt;&lt;span&gt;为什么要用搜索引擎，传统 DB 如 MySQL 不香吗&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h3&gt;&lt;h4&gt;&lt;span&gt;MySQL 的不足&lt;/span&gt;&lt;/h4&gt;&lt;p&gt;MySQL 架构天生不适合海量数据查询，它只适合海量数据存储，但无法应对海量数据下各种复杂条件的查询，有人说加索引不是可以避免全表扫描，提升查询速度吗，为啥说它不适合海量数据查询呢，有两个原因：&lt;/p&gt;&lt;p&gt;&lt;em&gt;1、&lt;/em&gt;加索引确实可以提升查询速度，但在 MySQL 中加多个索引最终在执行 SQL 的时候它只会选择成本最低的那个索引，如果没有索引满足搜索条件，就会触发全表扫描，而且即便你使用了组合索引，也要符合最左前缀原则才能命中索引，但在海量数据多种查询条件下很有可能不符合最左前缀原则而导致索引失效，而且我们知道存储都是需要成本的，如果你针对每一种情况都加索引，以 innoDB 为例，每加一个索引，就会创建一颗 B+ 树，如果是海量数据，将会增加很大的存储成本，之前就有人反馈说他们公司的某个表实际内容的大小才 10G, 而索引大小却有 30G！这是多么巨大的成本！所以千万不要觉得索引建得越多越好。&lt;/p&gt;&lt;p&gt;&lt;em&gt;2、&lt;/em&gt;有些查询条件是 MySQL 加索引都解决不了的，比如我要查询商品中所有 title 带有「格力空调」的关键词，如果你用 MySQL 写，会写出如下代码&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;SELECT&lt;/span&gt; * &lt;span&gt;FROM&lt;/span&gt; product &lt;span&gt;WHERE&lt;/span&gt; title &lt;span&gt;like&lt;/span&gt; &lt;span&gt;&#x27;%格力空调%&#x27;&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这样的话无法命中任何索引，会触发全表扫描，而且你不能指望所有人都能输对他想要的商品，是人就会犯错误，我们经常会犯类似把「格力空调」记成「格空间」的错误，那么 SQL 语句就会变成：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;SELECT&lt;/span&gt; * &lt;span&gt;FROM&lt;/span&gt; product &lt;span&gt;WHERE&lt;/span&gt; title &lt;span&gt;like&lt;/span&gt; &lt;span&gt;&#x27;%格空调%&#x27;&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这种情况下就算你触发了全表扫描也无法查询到任何商品，综上所述，MySQL 的查询确实能力有限。&lt;/p&gt;&lt;h4&gt;&lt;span&gt;ES 简介&lt;/span&gt;&lt;/h4&gt;&lt;p&gt;与其说上面列的这些点是 MySQL 的不足，倒不如说 MySQL 本身就不是为海量数据查询而设计的，术业有专攻，海量数据查询还得用专门的搜索引擎，这其中 ES 是其中当之无愧的王者，它是基于 Lucene 引擎构建的开源分布式搜索分析引擎，可以提供针对 PB 数据的近实时查询，广泛用在全文检索、日志分析、监控分析等场景。&lt;/p&gt;&lt;p&gt;它主要有以下三个特点:&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;code&gt;轻松支持各种复杂的查询条件&lt;/code&gt;: 它是分布式实时文件存储，会把&lt;strong&gt;每一个字段&lt;/strong&gt;都编入索引（倒排索引），利用高效的倒排索引，以及自定义打分、排序能力与丰富的分词插件等，能实现任意复杂查询条件下的全文检索需求&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;code&gt;可扩展性强&lt;/code&gt;：天然支持分布式存储，通过极其简单的配置实现几百上千台服务器的分布式横向扩容，轻松处理 PB 级别的结构化或非结构化数据。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;code&gt;高可用，容灾性能好&lt;/code&gt;：通过使用主备节点，以及故障的自动探测与恢复，有力地保障了高可用&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;我们先用与 MySQL 类比的形式来理解 ES 的一些重要概念&lt;/p&gt;&lt;figure&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.64&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/OyweysCSeLWdu3sLGq2x6hvRqLot2ajIOtgQRJNdIAIPfdSV1VYz3lFpibhSFU34mkRWC2R1HIDfibXp9bVYYXeg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;450&quot; title=&quot;&quot;/&gt;&lt;/figure&gt;&lt;p&gt;通过类比的形式不难看出 ES 的以下几个概念&lt;br/&gt;&lt;em&gt;1、&lt;/em&gt; MySQL 的数据库（DataBase）相当于 Index（索引），数据的逻辑集合，ES 的工作主要也是创建索引，查询索引。&lt;br/&gt;&lt;em&gt;2、&lt;/em&gt; 一个数据库里会有多个表，同样的一个 Index 也会有多个 type&lt;br/&gt;&lt;em&gt;3、&lt;/em&gt; 一个表会有多行（Row），同样的一个 Type 也会有多个 Document。&lt;br/&gt;&lt;em&gt;4、&lt;/em&gt; Schema 指定表名，表字段，是否建立索引等，同样的 Mapping 也指定了 Type 字段的处理规则，即索引如何建立，是否分词，分词规则等&lt;br/&gt;&lt;em&gt;5、&lt;/em&gt; 在 MySQL 中索引是需要手动创建的，而在 ES 一切字段皆可被索引，只要在 Mapping 在指定即可&lt;/p&gt;&lt;p&gt;那么 ES 中的索引为何如此高效，能在海量数据下达到秒级的效果呢？它采用了多种优化手段，最主要的原因是它采用了一种叫做&lt;strong&gt;倒排索引&lt;/strong&gt;的方式来生成索引，避免了全文档扫描，那么什么是倒排索引呢，通过文档来查找关键词等数据的我们称为正排索引，返之，通过关键词来查找文档的形式我们称之为倒排索引，假设有以下三个文档（Document）&lt;/p&gt;&lt;figure&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6424116424116424&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/OyweysCSeLWdu3sLGq2x6hvRqLot2ajIHPicKc8zvj2ciaUhDavzlF8JnBNJ5uaGibROpTgKCmfDba6XiaM1TTQDWA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;481&quot; title=&quot;&quot;/&gt;&lt;/figure&gt;&lt;p&gt;要在其中找到含有 comming 的文档，如果要正排索引，那么要把每个文档的内容拿出来查找是否有此单词，毫无疑问这样的话会导致全表扫描，那么用倒排索引会怎么查找呢，它首先会将每个文档内容进行分词，小写化等，然后建立每个分词与包含有此分词的文档之前的映射关系，如果有多个文档包含此分词，那么就会按重要程度即文档的权重（通常是用 TF-IDF 给文档打分）将文档进行排序，于是我们可以得到如下关系&lt;/p&gt;&lt;figure&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.9377777777777778&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/OyweysCSeLWdu3sLGq2x6hvRqLot2ajIsQ3ON3TGMh0LfYib2sslUSpjwAufyvic6YhQX1PPhzEcu0fzetfmTSAg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;450&quot; title=&quot;&quot;/&gt;&lt;/figure&gt;&lt;p&gt;这样的话我们我要查找所有带有 comming 的文档，就只需查一次，而且这种情况下查询多个单词性能也是很好的，只要查询多个条件对应的文档列表，再取交集即可，极大地提升了查询效率。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;画外音&lt;/strong&gt;：这里简化了一些流程，实际上还要先根据单词表来定位单词等，不过这些流程都很快，可以忽略，有兴趣的读者可以查阅相关资料了解。&lt;/p&gt;&lt;p&gt;除了倒排索引外，ES 的分布式架构也天然适合海量数据查询，来看下 ES 的架构&lt;/p&gt;&lt;figure&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.4643765903307888&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/OyweysCSeLWdu3sLGq2x6hvRqLot2ajI4A90Cujyd2EtOwn9LLHDVMHls99SvKCebM4hVfE0UYUabmcrGq9mVw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;786&quot; title=&quot;&quot;/&gt;&lt;/figure&gt;&lt;p&gt;一个 ES 集群由多个 node 节点组成，每个 index 是以分片（Shard，index 子集）的数据存在于多个 node 节点上的，这样的话当一个查询请求进来，分别在各个 node 查询相应的结果并整合后即可，将查询压力分散到多个节点，避免了单个节点 CPU，磁盘，内存等处理能力的不足。&lt;/p&gt;&lt;p&gt;另外当新节点加入后，会&lt;strong&gt;自动&lt;/strong&gt;迁移部分分片至新节点，实现负载均衡，这个功能是 ES &lt;strong&gt;自动&lt;/strong&gt;完成的，对比一个下 MySQL 的分库分表需要开发人员引入 Mycat 等中间件并指定分库分表规则等繁琐的流程是不是一个巨大的进步？这也就意味着 ES 有非常强大的水平扩展的能力，集群可轻松扩展致几百上千个节点，轻松支持 PB 级的数据查询。&lt;/p&gt;&lt;p&gt;当然 ES 的强大不止于此，它还采用了比如主备分片提升搜索吞率，使用节点故障探测，Raft 选主机制等提升了容灾能力等等，这些不是本文重点，读者可自行查阅，总之经过上面的简单总结大家只需要明白一点：&lt;strong&gt;ES 的分布式架构设计天生支持海量数据查询&lt;/strong&gt;。&lt;/p&gt;&lt;p&gt;那么 ES 的索引数据（index）如何生成的呢，接下来我们一起来看看本文的重点&lt;/p&gt;&lt;h3&gt;&lt;span&gt;如何构建 ES 索引&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h3&gt;&lt;p&gt;要构建 ES 索引数据，首先得有数据源，一般我们会使用 MySQL 作为数据源，你可以直接从 MySQL 中取数据然后再写入 ES，但这种方式由于直接调用了线上的数据库查询，可能会对线上业务造成影响，比如考虑这样的一个场景：&lt;/p&gt;&lt;p&gt;在电商 APP 里用的最多的业务场景想必是用户输入关键词来查询相对应的商品了，那么商品会有哪些信息呢，一个商品会有多个 sku（sku 即同一个商品下不同规格的品类，比如苹果手机有 iPhone 6, iPhone 6s等）,会有其基本属性如价格，标题等，商品会有分类（居家，服饰等），品牌，库存等，为了保证表设计的合理性，我们会设计几张表来存储这些属性，假设有 product_sku（sku 表）, product_property（基本属性表）,sku_stock（库存表），product_category（分类表）这几张表，那么为了在商品展示列表中展示所有这些信息，就必须把这些表进行 join，然后再写入 ES，这样查询的时候就会在 ES 中获取所有的商品信息了。&lt;/p&gt;&lt;figure&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1.3733333333333333&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/OyweysCSeLWdu3sLGq2x6hvRqLot2ajIiccmBnyRm83ebeoXjBM5XmWZiaU0ibMgQCTicBnRlesQPBnrUicPchTV4lA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;375&quot; title=&quot;&quot;/&gt;&lt;/figure&gt;&lt;p&gt;这种方案由于直接在 MySQL 中执行 join 操作，在商品达到千万级时会对线上的 DB 服务产生极大的性能影响，所以显然不可行，那该怎么生成中间表呢，既然直接在 MySQL 中操作不可行，能否把 MySQL 中的数据同步到另一个地方再做生成中间表的操作呢，也就是加一个中间层进行处理，这样就避免了对线上 DB 的直接操作，说到这相信大家又会对计算机界的名言有进一步的体会：没有什么是加一个中间层不能解决的，如果有，那就再加一层。&lt;/p&gt;&lt;p&gt;这个中间层就是 hive&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;什么是 hive&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;hive 是基于 Hadoop 的一个数据仓库工具，用来进行数据提取、转化、加载，这是一种可以存储、查询和分析存储在 Hadoop 中的&lt;strong&gt;大规模数据&lt;/strong&gt;的机制，它的意义就是把好写的 hive 的 sql 转换为复杂难写的 map-reduce 程序（map-reduce 是专门用于用于大规模数据集（大于1TB）的并行运算编程模型），也就是说&lt;strong&gt;如果数据量大&lt;/strong&gt;的话通过把 MySQL 的数据同步到 hive，再由 hive 来生成上述的 product_tmp 中间表，能极大的提升性能。hive 生成临时表存储在 hbase（一个分布式的、面向列的开源数据库） 中，生成后会定时触发 dump task 调用索引程序，然后索引程序主要从 hbase 中读入全量数据，进行业务数据处理，并刷新到 es 索引中，整个流程如下&lt;/p&gt;&lt;figure&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.9038718291054739&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/OyweysCSeLWdu3sLGq2x6hvRqLot2ajIS8FFpvtgbibhXP5SickzyDoWtiaI3tPtXoTWg3YBia0kIq3YJoXVIgbnpQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;749&quot; title=&quot;&quot;/&gt;&lt;/figure&gt;&lt;p&gt;这样构建索引看似很美好，但我们需要知道的是首先 hive 执行 join 任务是非常耗时的，在我们的生产场景上，由于数据量高达几千万，执行 join 任务通常需要几十分钟，从执行 join 任务到最终更新至 ES 整个流程常常需要至少半小时以上，如果这期间商品的价格，库存，上线状态（如被下架）等重要字段发生了变更，索引是无法更新的，这样会对用户体验产生极大影响，优化前我们经常会看到通过 ES 搜索出的中有状态是上线但实际是下架的产品，严重影响用户体验，那么怎么解决呢，有一种可行的方案：&lt;strong&gt;建立宽表&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;既然我们发现 hive join 是性能的主要瓶颈，那么能否规避掉这个流程呢，能否在 MySQL 中将 product_sku，product_property，sku_stock 等表组合成一个大表（我们称其为宽表）&lt;/p&gt;&lt;figure&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.2980392156862745&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/OyweysCSeLWdu3sLGq2x6hvRqLot2ajI22lxjo36xfphZic8jEwrAFaPpIjXvB0pA8KU1w47ymcpDbOkibumVIibQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;510&quot; title=&quot;&quot;/&gt;&lt;/figure&gt;&lt;p&gt;这样在每一行中商品涉及到的的数据都有了，所以将 MySQL 同步到 hive 后，hive 就不需要再执行耗时的 join 操作了，极大的提升了整体的处理时间，从 hive 同步 MySQL 再到 dump 到 ES 索引中从原来的半小时以上降低到了几分钟以内，看起来确实不错，但几分钟的索引延迟依然是无法接受的。&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;为什么 hive 无法做到实时导入索引&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;因为 hive 构建在基于静态批处理的Hadoop 之上，Hadoop 通常都有较高的延迟并且在作业提交和调度的时候需要大量的开销。因此，hive 并不能够在大规模数据集上实现低延迟快速的查询等操作，再且千万级别的数据全量从索引程序导入到 ES 集群至少也是分钟级。&lt;/p&gt;&lt;p&gt;另外引入了宽表，它的维护也成了一个新问题，设想 sku 库存变了，产品下架了，价格调整了，那么除了修改原表（sku_stock,product_categry 等表）记录之外，还要将所有原表变更到的记录对应到宽表中的所有记录也都更新一遍，这对代码的维护是个噩梦，因为你需要在所有商品相关的表变更的地方紧接着着变更宽表的逻辑，与宽表的变更逻辑变更紧藕合！&lt;/p&gt;&lt;h3&gt;&lt;span&gt;PB 级的 ES 准实时索引构建之道&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h3&gt;&lt;p&gt;该如何解决呢？仔细观察上面两个问题，其实都是同一个问题，如果我们能实时监听到 db 的字段变更，再将变更的内容实时同步到 ES 和宽表中不就解决了我们的问题了。&lt;/p&gt;&lt;p&gt;怎么才能实时监听到表字段的变更呢？&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;答案：binlog&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;来一起复习下 MySQL 的主从同步原理&lt;/p&gt;&lt;figure&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6699604743083004&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/OyweysCSeLWdu3sLGq2x6hvRqLot2ajI2BUZtQviaf64qt8JyFWlp32pkW1fnDL49rDIScQ7cWu6DFOg7oQdhPA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;506&quot; title=&quot;&quot;/&gt;&lt;/figure&gt;&lt;ol class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;MySQL master 将数据变更写入二进制日志( binary log, 其中记录叫做二进制日志事件binary log events，可以通过 show binlog events 进行查看)&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;MySQL slave 将 master 的 binary log events 拷贝到它的中继日志(relay log)&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;MySQL slave 重放 relay log 中事件，将数据变更反映它自己的数据&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;可以看到主从复制的原理关键是 Master 和 Slave 遵循了一套协议才能实时监听 binlog 日志来更新  slave 的表数据，那我们能不能也开发一个遵循这套协议的组件，当组件作为 Slave 来获取 binlog 日志进而实时监听表字段变更呢？阿里的开源项目 Canal 就是这个干的，它的工作原理如下:&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;canal 模拟 MySQL slave 的交互协议，伪装自己为 MySQL slave ，向 MySQL master 发送dump 协议&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;MySQL master 收到 dump 请求，开始推送 binary log 给 slave (即 canal )&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;canal 解析 binary log 对象(原始为 byte 流)&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;figure&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.45414847161572053&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/OyweysCSeLWdu3sLGq2x6hvRqLot2ajInMK8ia157vOCZMzCI9S5XKt6lRmhLFwliaicSg0TYG47jZoLNDM95jrjw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;458&quot; title=&quot;&quot;/&gt;&lt;/figure&gt;&lt;p&gt;这样的话通过 canal 就能获取 binlog 日志了，当然 canal 只是获取接收了 master 过来的 binlog，还要对 binlog 进行解析过滤处理等，另外如果我们只对某些表的字段感兴趣，该如何配置，获取到 binlog 后要传给谁? 这些都需要一个统一的管理组件，阿里的 otter 就是干这件事的。&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;什么是 otter&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;Otter 是由阿里提供的基于数据库增量日志解析，准实时同步到本机房或异地机房 MySQL 数据库的一个分布式数据库同步系统，它的整体架构如下：&lt;/p&gt;&lt;figure&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6343669250645995&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/OyweysCSeLWdu3sLGq2x6hvRqLot2ajIGyexNdiblcFhKKLaeeicTrBiaUSERtlDL55JHOOOmeFD2yhP82aAJB4wg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;774&quot; title=&quot;&quot;/&gt;&lt;/figure&gt;&lt;br/&gt;&lt;strong&gt;注：以上是我司根据 otter 改造后的业务架构，与原版 otter 稍有不同，不过大同小异&lt;/strong&gt;&lt;p&gt;主要工作流程如下&lt;/p&gt;&lt;ol class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;在 Manager 配置好 zk，要监听的表 ，负责监听表的节点，然后将配置同步到 Nodes 中&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;node 启动后则其 canal 会监听 binlog，然后经过 S（select），E（extract），T(transform)，L(load) 四个阶段后数据发送到 MQ&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;然后业务就可以订阅 MQ 消息来做相关的逻辑处理了&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;&lt;strong&gt;画外音：zookeeper 主要协调节点间的工作，如在跨机房数据同步时，可能要从 A 机房的节点将数据同步到 B 机房的节点，要用 zookeeper 来协调，&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;大家应该注意到了node 中有 S，E，T，L 四个阶段，它们的主要作用如下&lt;/p&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.2961730449251248&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/OyweysCSeLWdu3sLGq2x6hvRqLot2ajIA3pmeq3HBjMh9RPYbZYoRA9BdrdsesRaRBB7ItodRJXsoKlumBicaQQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;601&quot; title=&quot;&quot;/&gt;&lt;/figure&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;code&gt;Select 阶段&lt;/code&gt;: 为解决数据来源的差异性，比如接入 canal 获取增量数据，也可以接入其他系统获取其他数据等。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;code&gt;Extract阶段&lt;/code&gt;: 组装数据,针对多种数据来源，mysql,oracle,store,file等,进行数据组装和过滤。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;code&gt;Transform 阶段&lt;/code&gt;: 数据提取转换过程，把数据转换成目标数据源要求的类型&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;code&gt;Load 阶段&lt;/code&gt;: 数据载入,把数据载入到目标端，如写入迁移后的数据库， MQ，ES 等&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;以上这套基于阿里 otter 改造后的数据服务我们将它称为 DTS（Data Transfer Service），即数据传输服务。&lt;/p&gt;&lt;p&gt;搭建这套服务后我们就可以通过订阅 MQ 来实时写入 ES 让索引实时更新了，而且也可以通过订阅 MQ 来实现宽表字段的更新，解决了上文中所说的宽表字段更新与原表紧藕合的问题，基于 DTS 服务的索引改进架构如下:&lt;/p&gt;&lt;figure&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5281329923273658&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/OyweysCSeLWdu3sLGq2x6hvRqLot2ajIlIBMZtohB9H2hanBwjbPYTr6Y6JBWkZcjXJFIJkgNmT8pcM62ViarrA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;782&quot; title=&quot;&quot;/&gt;&lt;/figure&gt;&lt;p&gt;注意：「&lt;strong&gt;build 数据&lt;/strong&gt;」这一模块对实时索引更新是透明的，这个模块主要用在更新或插入 MySQL 宽表，因为对于宽表来说，它是几个表数据的并集，所以并不是监听到哪个字段变更就更新哪个，它要把所有商品涉及到的所有表数据拉回来再更新到宽表中。&lt;/p&gt;&lt;p&gt;于是，通过 MySQL 宽表全量更新+基于 DTS 的实时索引更新我们很好地解决了索引延迟的问题，能达到秒级的 ES 索引更新！&lt;/p&gt;&lt;p&gt;这里有几个问题可能大家比较关心，我简单列一下&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;需要订阅哪些字段&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;对于 MySQL 宽表来说由于它要保存商品的完整信息，所以它需要订阅所有字段，但是对于红框中的实时索引更新而言，它只需要订阅库存，价格等字段，因为这些字段如果不及时更新，会对销量产生极大的影响，所以我们实时索引只关注这些敏感字段即可。&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;有了实时索引更新，还需要全量索引更新吗&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;strong&gt;需要&lt;/strong&gt;，主要有两个原因：&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;全量索引更新的数据会覆盖实时索引吗&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;会，设想这样一种场景，你在某一时刻触发了实时索引，然后此时全量索引还在执行中，还未执行到实时索引更新的那条记录，这样在的话当全量索引执行完之后就会把之前实时索引更新的数据给覆盖掉，针对这种情况一种可行的处理方式是如果全量索引是在构建中，实时索引更新消息可以延迟处理，等全量更新结束后再消费。也正因为这个原因，全量索引我们一般会在凌晨执行，由于是业务低峰期，最大可能规避了此类问题。&lt;/p&gt;&lt;h3&gt;&lt;span&gt;总结&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h3&gt;&lt;p&gt;本文简单总结了我司在 PB 级数据下构建实时 ES 索引的一些思路，希望对大家有所帮助，文章只是简单提到了 ES，canal，otter 等阿里中间件的应用，但未对这些中间件的详细配置，原理等未作过多介绍，这些中间件的设计非常值得我们好好研究下，比如 ES 为了提高搜索效率、优化存储空间做了很多工作，再比如 canal 如何做高可用，otter 实现异地跨机房同步的原理等，建议感兴趣的读者可以之后好好研究一番，相信你会受益匪浅。&lt;/p&gt;&lt;p&gt;巨人的肩膀&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;Elasticsearch简介及与MySQL查询原理对比：https://www.jianshu.com/p/116cdf5836f2&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;https://www.cnblogs.com/zhjh256/p/9261725.html&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;otter安装之otter-node安装（单机多节点安装）：https://blog.csdn.net/u014642915/article/details/96500957&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;MySQL和Lucene索引对比分析: https://developer.aliyun.com/article/50481&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;10 分钟快速入门海量数据搜索分析引擎 Elasticearch: https://www.modb.pro/db/29806&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;ElasticSearch和Mysql查询原理分析与对比:https://www.pianshen.com/article/4254917942/&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;带你走进神一样的Elasticsearch索引机制:https://zhuanlan.zhihu.com/p/137574234&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;/p&gt;&lt;pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;最近苏三的知识星球&lt;span&gt;【&lt;/span&gt;&lt;strong&gt;Java突击队&lt;/strong&gt;&lt;span&gt;】&lt;/span&gt;，每天都会更新很多干货内容。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;很多独家的干货内容，比如：Java后端学习路线，分享实战demo项目，源码分析，百万级系统设计，系统上线的一些坑，MQ专题，真实面试题，每天都会回答大家提出的问题。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这几天星球开通了3个优质专栏：痛点问题、高频面试题 和 性能优化。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;每一个专栏都是大家非常关心，和非常有价值的话题，我相信在专栏中你会学到很多东西，值回票价。&lt;/p&gt;&lt;p&gt;&lt;span&gt;3月1号就会涨价！&lt;span&gt;3月1号就会涨价&lt;/span&gt;&lt;span&gt;！&lt;span&gt;3月1号就会涨价&lt;/span&gt;&lt;span&gt;！&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;1.215625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ibJZVicC7nz5gN92EGIv3mqouxKLAUkLWFYqgbeOwjBtqkv3CbvoFGDOeybMlRw31dtcprWichxTGUu6CoaSwjmvw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;640&quot;/&gt;&lt;/p&gt;&lt;p&gt;目前25元优惠券所剩不多了，要上车&lt;span&gt;的小伙伴抓紧时间。&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;&lt;/pre&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>8f3f2ad79b411c695e2649cb86c5e371</guid>
<title>Java 并发，夺命 60 问，抗住</title>
<link>https://toutiao.io/k/epvkoxy</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot; data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&lt;strong&gt;您好，我是路人，更多优质文章见个人博客：http://itsoku.com&lt;/strong&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这节我们来盘一盘另一个面试必问知识点——Java并发。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这篇文章有点长，四万字，图文详解六十道Java并发面试题。人已经肝麻了，大家可以&lt;strong&gt;点赞&lt;/strong&gt;、&lt;strong&gt;收藏&lt;/strong&gt;慢慢看！扶我起来，我还能肝！&lt;/p&gt;&lt;section&gt;&lt;mp-common-profile class=&quot;custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mpprofile&quot; data-weuitheme=&quot;light&quot; data-id=&quot;MzkwOTAyMTY2NA==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/RkqIyCg0bs5RxSfSeAUVCFlYkTgwFzSTian35nERyNxV5th5VQ64LCrrQ0HQeSCXErDw9rEKIy2JAJ00Wex8ZlQ/0?wx_fmt=png&quot; data-nickname=&quot;Java充电社&quot; data-alias=&quot;nihaojava8&quot; data-signature=&quot;Java充电社，专注分享Java技术干货，包括多线程、JVM、SpringBoot、SpringCloud、Dubbo、Zookeeper、Redis、架构设计、微服务、消息队列、Git、面试题、程序员攻略、最新动态等。&quot; data-from=&quot;0&quot; data-weui-theme=&quot;light&quot;/&gt;&lt;/section&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;基础&lt;/span&gt;&lt;/h1&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;1.并行跟并发有什么区别？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;从操作系统的角度来看，线程是CPU分配的最小单位。&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;并行就是同一时刻，两个线程都在执行。这就要求有两个CPU去分别执行两个线程。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;并发就是同一时刻，只有一个执行，但是一个时间段内，两个线程都执行了。并发的实现依赖于CPU切换线程，因为切换的时间特别短，所以基本对于用户是无感知的。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6039603960396039&quot; data-type=&quot;png&quot; data-w=&quot;707&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWcMxSzU05DWGIZ1b1icvRXTS2ibNTT0qBy2tDgPX9pG1xvI8EG1JXpZ4t60qd5cTeLfaX2ph3gdT38g/640?wx_fmt=png&quot;/&gt;&lt;figcaption&gt;并行和并发&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;就好像我们去食堂打饭，并行就是我们在多个窗口排队，几个阿姨同时打菜；并发就是我们挤在一个窗口，阿姨给这个打一勺，又手忙脚乱地给那个打一勺。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.33755274261603374&quot; data-type=&quot;png&quot; data-w=&quot;948&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWcMxSzU05DWGIZ1b1icvRXTSQXibcUjkj72rFyjaHicpxaO7O7QibQGTvC5ZLnuSXwlxBxkuWjQ3cJiaRg/640?wx_fmt=png&quot;/&gt;&lt;figcaption&gt;并行并发和食堂打饭&lt;/figcaption&gt;&lt;/figure&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;2.说说什么是进程和线程？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;要说线程，必须得先说说进程。&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;进程：进程是代码在数据集合上的一次运行活动，是系统进行资源分配和调度的基本单位。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;线程：线程是进程的一个执行路径，一个进程中至少有一个线程，进程中的多个线程共享进程的资源。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;操作系统在分配资源时是把资源分配给进程的， 但是 CPU 资源比较特殊，它是被分配到线程的，因为真正要占用CPU运行的是线程，所以也说线程是 CPU分配的基本单位。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;比如在Java中，当我们启动 main 函数其实就启动了一个JVM进程，而 main 函数在的线程就是这个进程中的一个线程，也称主线程。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6102150537634409&quot; data-type=&quot;png&quot; data-w=&quot;744&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWcMxSzU05DWGIZ1b1icvRXTS74wN2kmXIicVic1QlXH54kkRECFvyjNtTwyvRzHBA35cqcysVibTA2fYw/640?wx_fmt=png&quot;/&gt;&lt;figcaption&gt;程序进程线程关系&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;一个进程中有多个线程，多个线程共用进程的堆和方法区资源，但是每个线程有自己的程序计数器和栈。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;3.说说线程有几种创建方式？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Java中创建线程主要有三种方式，分别为继承Thread类、实现Runnable接口、实现Callable接口。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.4672489082969432&quot; data-type=&quot;png&quot; data-w=&quot;687&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWcMxSzU05DWGIZ1b1icvRXTS6LVYDqPoWWNxm2p8ibPTjwxiaSDaaLxcHvMg0ib7oWQaxUE5g95CRdjwA/640?wx_fmt=png&quot;/&gt;&lt;figcaption&gt;线程创建三种方式&lt;/figcaption&gt;&lt;/figure&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;继承Thread类，重写run()方法，调用start()方法启动线程&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;ThreadTest&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;/**&lt;br/&gt;     * 继承Thread类&lt;br/&gt;     */&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;MyThread&lt;/span&gt; &lt;span&gt;extends&lt;/span&gt; &lt;span&gt;Thread&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;run&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;            System.out.println(&lt;span&gt;&quot;This is child thread&quot;&lt;/span&gt;);&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;(String[] args)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        MyThread thread = &lt;span&gt;new&lt;/span&gt; MyThread();&lt;br/&gt;        thread.start();&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;RunnableTask&lt;/span&gt; &lt;span&gt;implements&lt;/span&gt; &lt;span&gt;Runnable&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;run&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        System.out.println(&lt;span&gt;&quot;Runnable!&quot;&lt;/span&gt;);&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;(String[] args)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        RunnableTask task = &lt;span&gt;new&lt;/span&gt; RunnableTask();&lt;br/&gt;        &lt;span&gt;new&lt;/span&gt; Thread(task).start();&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上面两种都是没有返回值的，但是如果我们需要获取线程的执行结果，该怎么办呢？&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;实现Callable接口，重写call()方法，这种方式可以通过FutureTask获取任务执行的返回值&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;CallerTask&lt;/span&gt; &lt;span&gt;implements&lt;/span&gt; &lt;span&gt;Callable&lt;/span&gt;&amp;lt;&lt;span&gt;String&lt;/span&gt;&amp;gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; String &lt;span&gt;call&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;span&gt;throws&lt;/span&gt; Exception &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;&quot;Hello,i am running!&quot;&lt;/span&gt;;&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;(String[] args)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;//创建异步任务&lt;/span&gt;&lt;br/&gt;        FutureTask&amp;lt;String&amp;gt; task=&lt;span&gt;new&lt;/span&gt; FutureTask&amp;lt;String&amp;gt;(&lt;span&gt;new&lt;/span&gt; CallerTask());&lt;br/&gt;        &lt;span&gt;//启动线程&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;new&lt;/span&gt; Thread(task).start();&lt;br/&gt;        &lt;span&gt;try&lt;/span&gt; {&lt;br/&gt;            &lt;span&gt;//等待执行完成，并获取返回结果&lt;/span&gt;&lt;br/&gt;            String result=task.get();&lt;br/&gt;            System.out.println(result);&lt;br/&gt;        } &lt;span&gt;catch&lt;/span&gt; (InterruptedException e) {&lt;br/&gt;            e.printStackTrace();&lt;br/&gt;        } &lt;span&gt;catch&lt;/span&gt; (ExecutionException e) {&lt;br/&gt;            e.printStackTrace();&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;4.为什么调用start()方法时会执行run()方法，那怎么不直接调用run()方法？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;JVM执行start方法，会先创建一条线程，由创建出来的新线程去执行thread的run方法，这才起到多线程的效果。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.7549194991055456&quot; data-type=&quot;png&quot; data-w=&quot;559&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWcMxSzU05DWGIZ1b1icvRXTSdTd8PGSRoibhE9aky2sXmFyX8CTfkMoXvhBF74VbAlWmkL6cfaGxnnA/640?wx_fmt=png&quot;/&gt;&lt;figcaption&gt;start方法&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;**为什么我们不能直接调用run()方法？**也很清楚， 如果直接调用Thread的run()方法，那么run方法还是运行在主线程中，相当于顺序执行，就起不到多线程的效果。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;5.线程有哪些常用的调度方法？&lt;/span&gt;&lt;/h2&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.8622366288492707&quot; data-type=&quot;png&quot; data-w=&quot;617&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWcMxSzU05DWGIZ1b1icvRXTSsK0UianSHEombkRSia1P63NxI4kicIwfTEZDFiciaOZiaWvckeAdIrl0v2Lw/640?wx_fmt=png&quot;/&gt;&lt;figcaption&gt;线程常用调度方法&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;线程等待与通知&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在Object类中有一些函数可以用于线程的等待与通知。&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;wait()：当一个线程A调用一个共享变量的 wait()方法时， 线程A会被阻塞挂起， 发生下面几种情况才会返回 ：&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;（1） 线程A调用了共享对象 notify()或者 notifyAll()方法；&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;（2）其他线程调用了线程A的 interrupt() 方法，线程A抛出InterruptedException异常返回。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;wait(long timeout) ：这个方法相比 wait() 方法多了一个超时参数，它的不同之处在于，如果线程A调用共享对象的wait(long timeout)方法后，没有在指定的 timeout ms时间内被其它线程唤醒，那么这个方法还是会因为超时而返回。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;wait(long timeout, int nanos)，其内部调用的是 wait(long timout）函数。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上面是线程等待的方法，而唤醒线程主要是下面两个方法：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;notify() : 一个线程A调用共享对象的 notify() 方法后，会唤醒一个在这个共享变量上调用 wait 系列方法后被挂起的线程。一个共享变量上可能会有多个线程在等待，具体唤醒哪个等待的线程是随机的。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;notifyAll() ：不同于在共享变量上调用 notify() 函数会唤醒被阻塞到该共享变量上的一个线程，notifyAll()方法则会唤醒所有在该共享变量上由于调用 wait 系列方法而被挂起的线程。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Thread类也提供了一个方法用于等待的方法：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;join()：如果一个线程A执行了thread.join()语句，其含义是：当前线程A等待thread线程终止之后才&lt;/p&gt;&lt;p&gt;从thread.join()返回。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;线程休眠&lt;/strong&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;sleep(long millis)  :Thread类中的静态方法，当一个执行中的线程A调用了Thread 的sleep方法后，线程A会暂时让出指定时间的执行权，但是线程A所拥有的监视器资源，比如锁还是持有不让出的。指定的睡眠时间到了后该函数会正常返回，接着参与 CPU 的调度，获取到 CPU 资源后就可以继续运行。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;让出优先权&lt;/strong&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;yield() ：Thread类中的静态方法，当一个线程调用 yield 方法时，实际就是在暗示线程调度器当前线程请求让出自己的CPU ，但是线程调度器可以无条件忽略这个暗示。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;线程中断&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Java 中的线程中断是一种线程间的协作模式，通过设置线程的中断标志并不能直接终止该线程的执行，而是被中断的线程根据中断状态自行处理。&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;void interrupt() ：中断线程，例如，当线程A运行时，线程B可以调用钱程interrupt() 方法来设置线程的中断标志为true 并立即返回。设置标志仅仅是设置标志, 线程A实际并没有被中断， 会继续往下执行。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;boolean isInterrupted() 方法：检测当前线程是否被中断。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;boolean interrupted() 方法：检测当前线程是否被中断，与 isInterrupted 不同的是，该方法如果发现当前线程被中断，则会清除中断标志。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;6.线程有几种状态？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在Java中，线程共有六种状态：&lt;/p&gt;&lt;section data-tool=&quot;mdnice编辑器&quot;&gt;&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;状态&lt;/th&gt;&lt;th&gt;说明&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;NEW&lt;/td&gt;&lt;td&gt;初始状态：线程被创建，但还没有调用start()方法&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;RUNNABLE&lt;/td&gt;&lt;td&gt;运行状态：Java线程将操作系统中的就绪和运行两种状态笼统的称作“运行”&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;BLOCKED&lt;/td&gt;&lt;td&gt;阻塞状态：表示线程阻塞于锁&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;WAITING&lt;/td&gt;&lt;td&gt;等待状态：表示线程进入等待状态，进入该状态表示当前线程需要等待其他线程做出一些特定动作（通知或中断）&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;TIME_WAITING&lt;/td&gt;&lt;td&gt;超时等待状态：该状态不同于 WAITIND，它是可以在指定的时间自行返回的&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;TERMINATED&lt;/td&gt;&lt;td&gt;终止状态：表示当前线程已经执行完毕&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;线程在自身的生命周期中， 并不是固定地处于某个状态，而是随着代码的执行在不同的状态之间进行切换，Java线程状态变化如图示：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.682738669238187&quot; data-type=&quot;png&quot; data-w=&quot;1037&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWcMxSzU05DWGIZ1b1icvRXTShQkou2XzC8FIN6UXecNN3FTb0MvGugyl0oJ1rUn9WOONtU8iaPt3XJw/640?wx_fmt=png&quot;/&gt;&lt;figcaption&gt;Java线程状态变化&lt;/figcaption&gt;&lt;/figure&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;7.什么是线程上下文切换？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;使用多线程的目的是为了充分利用CPU，但是我们知道，并发其实是一个CPU来应付多个线程。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5864106351550961&quot; data-type=&quot;png&quot; data-w=&quot;677&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWcMxSzU05DWGIZ1b1icvRXTSZzAS4QOe2F12nI4saOBr2lZibrR6zHlhxnEWHIY08LyZhQGibU6ckO9Q/640?wx_fmt=png&quot;/&gt;&lt;figcaption&gt;线程切换-2020-12-16-2107&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;为了让用户感觉多个线程是在同时执行的， CPU 资源的分配采用了时间片轮转也就是给每个线程分配一个时间片，线程在时间片内占用 CPU 执行任务。当线程使用完时间片后，就会处于就绪状态并让出 CPU 让其他线程占用，这就是上下文切换。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5602649006622517&quot; data-type=&quot;png&quot; data-w=&quot;755&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWcMxSzU05DWGIZ1b1icvRXTSbEVPLNk4QgvXZick5kIvibH5uf2L1gbDQZhbG7ibzgHefDQ0UyqlGGAgA/640?wx_fmt=png&quot;/&gt;&lt;figcaption&gt;上下文切换时机&lt;/figcaption&gt;&lt;/figure&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;8.守护线程了解吗？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Java中的线程分为两类，分别为 daemon 线程（守护线程）和 user 线程（用户线程）。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在JVM 启动时会调用 main 函数，main函数所在的钱程就是一个用户线程。其实在 JVM 内部同时还启动了很多守护线程， 比如垃圾回收线程。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那么守护线程和用户线程有什么区别呢？区别之一是当最后一个非守护线程束时， JVM会正常退出，而不管当前是否存在守护线程，也就是说守护线程是否结束并不影响 JVM退出。换而言之，只要有一个用户线程还没结束，正常情况下JVM就不会退出。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;9.线程间有哪些通信方式？&lt;/span&gt;&lt;/h2&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6792207792207792&quot; data-type=&quot;png&quot; data-w=&quot;770&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWcMxSzU05DWGIZ1b1icvRXTSdnNJ9qArkNSUFrBzego4UowztBD355hQYrOjML8icFREsxT0jkLZ2UQ/640?wx_fmt=png&quot;/&gt;&lt;figcaption&gt;线程间通信方式&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;关键字volatile可以用来修饰字段（成员变量），就是告知程序任何对该变量的访问均需要从共享内存中获取，而对它的改变必须同步刷新回共享内存，它能保证所有线程对变量访问的可见性。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;关键字synchronized可以修饰方法或者以同步块的形式来进行使用，它主要确保多个线程在同一个时刻，只能有一个线程处于方法或者同步块中，它保证了线程对变量访问的可见性和排他性。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可以通过Java内置的等待/通知机制（wait()/notify()）实现一个线程修改一个对象的值，而另一个线程感知到了变化，然后进行相应的操作。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;管道输入/输出流和普通的文件输入/输出流或者网络输入/输出流不同之处在于，它主要用于线程之间的数据传输，而传输的媒介为内存。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;管道输入/输出流主要包括了如下4种具体实现：PipedOutputStream、PipedInputStream、 PipedReader和PipedWriter，前两种面向字节，而后两种面向字符。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果一个线程A执行了thread.join()语句，其含义是：当前线程A等待thread线程终止之后才从thread.join()返回。。线程Thread除了提供join()方法之外，还提供了join(long millis)和join(long millis,int nanos)两个具备超时特性的方法。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;ThreadLocal，即线程变量，是一个以ThreadLocal对象为键、任意对象为值的存储结构。这个结构被附带在线程上，也就是说一个线程可以根据一个ThreadLocal对象查询到绑定在这个线程上的一个值。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可以通过set(T)方法来设置一个值，在当前线程下再通过get()方法获取到原先设置的值。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;关于多线程，其实很大概率还会出一些笔试题，比如交替打印、银行转账、生产消费模型等等，后面老三会单独出一期来盘点一下常见的多线程笔试题。&lt;/p&gt;&lt;/blockquote&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;ThreadLocal&lt;/span&gt;&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;ThreadLocal其实应用场景不是很多，但却是被炸了千百遍的面试老油条，涉及到多线程、数据结构、JVM，可问的点比较多，一定要拿下。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;10.ThreadLocal是什么？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;ThreadLocal，也就是线程本地变量。如果你创建了一个ThreadLocal变量，那么访问这个变量的每个线程都会有这个变量的一个本地拷贝，多个线程操作这个变量的时候，实际是操作自己本地内存里面的变量，从而起到线程隔离的作用，避免了线程安全问题。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.7027027027027027&quot; data-type=&quot;png&quot; data-w=&quot;666&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWcMxSzU05DWGIZ1b1icvRXTS7OzNCVicicddtUicSdxR1sqVnbUbK2cggB1Tib0nhhGqWSxbcUKibQ52sxw/640?wx_fmt=png&quot;/&gt;&lt;figcaption&gt;ThreadLocal线程副本&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;创建了一个ThreadLoca变量localVariable，任何一个线程都能并发访问localVariable。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;//创建一个ThreadLocal变量&lt;/span&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; ThreadLocal&amp;lt;String&amp;gt; localVariable = &lt;span&gt;new&lt;/span&gt; ThreadLocal&amp;lt;&amp;gt;();&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;线程可以在任何地方使用localVariable，写入变量。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;localVariable.set(&lt;span&gt;&quot;鄙人三某”);&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;线程在任何地方读取的都是它写入的变量。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;localVariable.get();&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;11.你在工作中用到过ThreadLocal吗？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;有用到过的，用来做用户信息上下文的存储。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们的系统应用是一个典型的MVC架构，登录后的用户每次访问接口，都会在请求头中携带一个token，在控制层可以根据这个token，解析出用户的基本信息。那么问题来了，假如在服务层和持久层都要用到用户信息，比如rpc调用、更新用户获取等等，那应该怎么办呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;一种办法是显式定义用户相关的参数，比如账号、用户名……这样一来，我们可能需要大面积地修改代码，多少有点瓜皮，那该怎么办呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这时候我们就可以用到ThreadLocal，在控制层拦截请求把用户信息存入ThreadLocal，这样我们在任何一个地方，都可以取出ThreadLocal中存的用户数据。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1.1645021645021645&quot; data-type=&quot;png&quot; data-w=&quot;462&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWcMxSzU05DWGIZ1b1icvRXTSLxvRaYIsxKVfiaiaARYGuicb8atXdAtVhLt8sSbmLMa4PGuMSsVdCxxbw/640?wx_fmt=png&quot;/&gt;&lt;figcaption&gt;ThreadLoca存放用户上下文&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;很多其它场景的cookie、session等等数据隔离也都可以通过ThreadLocal去实现。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们常用的数据库连接池也用到了ThreadLocal：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;数据库连接池的连接交给ThreadLoca进行管理，保证当前线程的操作都是同一个Connnection。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;12.ThreadLocal怎么实现的呢？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们看一下ThreadLocal的set(T)方法，发现先获取到当前线程，再获取&lt;code&gt;ThreadLocalMap&lt;/code&gt;，然后把元素存到这个map中。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;(T value)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;//获取当前线程&lt;/span&gt;&lt;br/&gt;        Thread t = Thread.currentThread();&lt;br/&gt;        &lt;span&gt;//获取ThreadLocalMap&lt;/span&gt;&lt;br/&gt;        ThreadLocalMap map = getMap(t);&lt;br/&gt;        &lt;span&gt;//讲当前元素存入map&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (map != &lt;span&gt;null&lt;/span&gt;)&lt;br/&gt;            map.set(&lt;span&gt;this&lt;/span&gt;, value);&lt;br/&gt;        &lt;span&gt;else&lt;/span&gt;&lt;br/&gt;            createMap(t, value);&lt;br/&gt;    }&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;ThreadLocal实现的秘密都在这个&lt;code&gt;ThreadLocalMap&lt;/code&gt;了，可以Thread类中定义了一个类型为&lt;code&gt;ThreadLocal.ThreadLocalMap&lt;/code&gt;的成员变量&lt;code&gt;threadLocals&lt;/code&gt;。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;Thread&lt;/span&gt; &lt;span&gt;implements&lt;/span&gt; &lt;span&gt;Runnable&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;   &lt;span&gt;//ThreadLocal.ThreadLocalMap是Thread的属性&lt;/span&gt;&lt;br/&gt;   ThreadLocal.ThreadLocalMap threadLocals = &lt;span&gt;null&lt;/span&gt;;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;ThreadLocalMap既然被称为Map，那么毫无疑问它是&amp;lt;key,value&amp;gt;型的数据结构。我们都知道map的本质是一个个&amp;lt;key,value&amp;gt;形式的节点组成的数组，那ThreadLocalMap的节点是什么样的呢？&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;        &lt;span&gt;static&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;Entry&lt;/span&gt; &lt;span&gt;extends&lt;/span&gt; &lt;span&gt;WeakReference&lt;/span&gt;&amp;lt;&lt;span&gt;ThreadLocal&lt;/span&gt;&amp;lt;?&amp;gt;&amp;gt; &lt;/span&gt;{&lt;br/&gt;            &lt;span&gt;/** The value associated with this ThreadLocal. */&lt;/span&gt;&lt;br/&gt;            Object value;&lt;br/&gt;&lt;br/&gt;            &lt;span&gt;//节点类&lt;/span&gt;&lt;br/&gt;            Entry(ThreadLocal&amp;lt;?&amp;gt; k, Object v) {&lt;br/&gt;                &lt;span&gt;//key赋值&lt;/span&gt;&lt;br/&gt;                &lt;span&gt;super&lt;/span&gt;(k);&lt;br/&gt;                &lt;span&gt;//value赋值&lt;/span&gt;&lt;br/&gt;                value = v;&lt;br/&gt;            }&lt;br/&gt;        }&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里的节点，key可以简单低视作ThreadLocal，value为代码中放入的值，当然实际上key并不是ThreadLocal本身，而是它的一个&lt;strong&gt;弱引用&lt;/strong&gt;，可以看到Entry的key继承了 WeakReference（弱引用），再来看一下key怎么赋值的：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;WeakReference&lt;/span&gt;&lt;span&gt;(T referent)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;super&lt;/span&gt;(referent);&lt;br/&gt;    }&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;key的赋值，使用的是WeakReference的赋值。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6018041237113402&quot; data-type=&quot;png&quot; data-w=&quot;776&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWcMxSzU05DWGIZ1b1icvRXTSxFgEObg5arqOtcKsnCpibAyuEINwG41poYJtQxiaMowJFv4dhicg6X9tA/640?wx_fmt=png&quot;/&gt;&lt;figcaption&gt;ThreadLoca结构图&lt;/figcaption&gt;&lt;/figure&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;所以，怎么回答ThreadLocal原理？要答出这几个点：&lt;/p&gt;&lt;/blockquote&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;Thread类有一个类型为ThreadLocal.ThreadLocalMap的实例变量threadLocals，每个线程都有一个属于自己的ThreadLocalMap。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;ThreadLocalMap内部维护着Entry数组，每个Entry代表一个完整的对象，key是ThreadLocal的弱引用，value是ThreadLocal的泛型值。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;每个线程在往ThreadLocal里设置值的时候，都是往自己的ThreadLocalMap里存，读也是以某个ThreadLocal作为引用，在自己的map里找对应的key，从而实现了线程隔离。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;ThreadLocal本身不存储值，它只是作为一个key来让线程往ThreadLocalMap里存取值。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;13.ThreadLocal 内存泄露是怎么回事？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们先来分析一下使用ThreadLocal时的内存，我们都知道，在JVM中，栈内存线程私有，存储了对象的引用，堆内存线程共享，存储了对象实例。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以呢，栈中存储了ThreadLocal、Thread的引用，堆中存储了它们的具体实例。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.4344086021505376&quot; data-type=&quot;png&quot; data-w=&quot;930&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWcMxSzU05DWGIZ1b1icvRXTSJOAVnpoBkPjgRy503rPYLiaSGDIqol7Pohf6WQgibNKekuD9Sp4TWJnw/640?wx_fmt=png&quot;/&gt;&lt;figcaption&gt;ThreadLocal内存分配&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;ThreadLocalMap中使用的 key 为 ThreadLocal 的弱引用。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;“弱引用：只要垃圾回收机制一运行，不管JVM的内存空间是否充足，都会回收该对象占用的内存。”&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那么现在问题就来了，弱引用很容易被回收，如果ThreadLocal（ThreadLocalMap的Key）被垃圾回收器回收了，但是ThreadLocalMap生命周期和Thread是一样的，它这时候如果不被回收，就会出现这种情况：ThreadLocalMap的key没了，value还在，这就会&lt;strong&gt;造成了内存泄漏问题&lt;/strong&gt;。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;那怎么解决内存泄漏问题呢？&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;很简单，使用完ThreadLocal后，及时调用remove()方法释放内存空间。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;ThreadLocal&amp;lt;String&amp;gt; localVariable = &lt;span&gt;new&lt;/span&gt; ThreadLocal();&lt;br/&gt;&lt;span&gt;try&lt;/span&gt; {&lt;br/&gt;    localVariable.set(&lt;span&gt;&quot;鄙人三某”);&lt;br/&gt;    ……&lt;br/&gt;} finally {&lt;br/&gt;    localVariable.remove();&lt;br/&gt;}&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;那为什么key还要设计成弱引用？&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;key设计成弱引用同样是为了防止内存泄漏。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;假如key被设计成强引用，如果ThreadLocal Reference被销毁，此时它指向ThreadLoca的强引用就没有了，但是此时key还强引用指向ThreadLoca，就会导致ThreadLocal不能被回收，这时候就发生了内存泄漏的问题。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;14.ThreadLocalMap的结构了解吗？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;ThreadLocalMap虽然被叫做Map，其实它是没有实现Map接口的，但是结构还是和HashMap比较类似的，主要关注的是两个要素：&lt;code&gt;元素数组&lt;/code&gt;和&lt;code&gt;散列方法&lt;/code&gt;。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.3925925925925926&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWcMxSzU05DWGIZ1b1icvRXTSgI4lgEHeM9mwORic2rkq4KJ4vsibqs7eezWc6kiarB3LvnxhibaZzUSIDQ/640?wx_fmt=png&quot;/&gt;&lt;figcaption&gt;ThreadLocalMap结构示意图&lt;/figcaption&gt;&lt;/figure&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;元素数组&lt;/p&gt;&lt;p&gt;一个table数组，存储Entry类型的元素，Entry是ThreaLocal弱引用作为key，Object作为value的结构。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt; &lt;span&gt;private&lt;/span&gt; Entry[] table;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;散列方法&lt;/p&gt;&lt;p&gt;散列方法就是怎么把对应的key映射到table数组的相应下标，ThreadLocalMap用的是哈希取余法，取出key的threadLocalHashCode，然后和table数组长度减一&amp;amp;运算（相当于取余）。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;int&lt;/span&gt; i = key.threadLocalHashCode &amp;amp; (table.length - &lt;span&gt;1&lt;/span&gt;);&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里的threadLocalHashCode计算有点东西，每创建一个ThreadLocal对象，它就会新增&lt;code&gt;0x61c88647&lt;/code&gt;，这个值很特殊，它是&lt;strong&gt;斐波那契数&lt;/strong&gt;  也叫 &lt;strong&gt;黄金分割数&lt;/strong&gt;。&lt;code&gt;hash&lt;/code&gt;增量为 这个数字，带来的好处就是 &lt;code&gt;hash&lt;/code&gt; &lt;strong&gt;分布非常均匀&lt;/strong&gt;。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; HASH_INCREMENT = &lt;span&gt;0x61c88647&lt;/span&gt;;&lt;br/&gt;    &lt;br/&gt;    &lt;span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; &lt;span&gt;nextHashCode&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; nextHashCode.getAndAdd(HASH_INCREMENT);&lt;br/&gt;    }&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;15.ThreadLocalMap怎么解决Hash冲突的？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们可能都知道HashMap使用了链表来解决冲突，也就是所谓的链地址法。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;ThreadLocalMap没有使用链表，自然也不是用链地址法来解决冲突了，它用的是另外一种方式——&lt;strong&gt;开放定址法&lt;/strong&gt;。开放定址法是什么意思呢？简单来说，就是这个坑被人占了，那就接着去找空着的坑。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.4471057884231537&quot; data-type=&quot;png&quot; data-w=&quot;1002&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWcMxSzU05DWGIZ1b1icvRXTSXqlXgzl4viatlpaKZ2NcpQaKOwODCJicogsE6ico6TOFGicv6GGEJmAbTg/640?wx_fmt=png&quot;/&gt;&lt;figcaption&gt;ThreadLocalMap解决冲突&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如上图所示，如果我们插入一个value=27的数据，通过 hash计算后应该落入第 4 个槽位中，而槽位 4 已经有了 Entry数据，而且Entry数据的key和当前不相等。此时就会线性向后查找，一直找到 Entry为 null的槽位才会停止查找，把元素放到空的槽中。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在get的时候，也会根据ThreadLocal对象的hash值，定位到table中的位置，然后判断该槽位Entry对象中的key是否和get的key一致，如果不一致，就判断下一个位置。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;16.ThreadLocalMap扩容机制了解吗？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在ThreadLocalMap.set()方法的最后，如果执行完启发式清理工作后，未清理到任何数据，且当前散列数组中&lt;code&gt;Entry&lt;/code&gt;的数量已经达到了列表的扩容阈值&lt;code&gt;(len*2/3)&lt;/code&gt;，就开始执行&lt;code&gt;rehash()&lt;/code&gt;逻辑：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;if&lt;/span&gt; (!cleanSomeSlots(i, sz) &amp;amp;&amp;amp; sz &amp;gt;= threshold)&lt;br/&gt;    rehash();&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;再着看rehash()具体实现：这里会先去清理过期的Entry，然后还要根据条件判断&lt;code&gt;size &amp;gt;= threshold - threshold / 4&lt;/code&gt; 也就是&lt;code&gt;size &amp;gt;= threshold* 3/4&lt;/code&gt;来决定是否需要扩容。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;rehash&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;//清理过期Entry&lt;/span&gt;&lt;br/&gt;    expungeStaleEntries();&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;//扩容&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (size &amp;gt;= threshold - threshold / &lt;span&gt;4&lt;/span&gt;)&lt;br/&gt;        resize();&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;//清理过期Entry&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;expungeStaleEntries&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    Entry[] tab = table;&lt;br/&gt;    &lt;span&gt;int&lt;/span&gt; len = tab.length;&lt;br/&gt;    &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; j = &lt;span&gt;0&lt;/span&gt;; j &amp;lt; len; j++) {&lt;br/&gt;        Entry e = tab[j];&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (e != &lt;span&gt;null&lt;/span&gt; &amp;amp;&amp;amp; e.get() == &lt;span&gt;null&lt;/span&gt;)&lt;br/&gt;            expungeStaleEntry(j);&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;接着看看具体的&lt;code&gt;resize()&lt;/code&gt;方法，扩容后的&lt;code&gt;newTab&lt;/code&gt;的大小为老数组的两倍，然后遍历老的table数组，散列方法重新计算位置，开放地址解决冲突，然后放到新的&lt;code&gt;newTab&lt;/code&gt;，遍历完成之后，&lt;code&gt;oldTab&lt;/code&gt;中所有的&lt;code&gt;entry&lt;/code&gt;数据都已经放入到&lt;code&gt;newTab&lt;/code&gt;中了，然后table引用指向&lt;code&gt;newTab&lt;/code&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-type=&quot;png&quot; data-ratio=&quot;0.3558648111332008&quot; data-w=&quot;1006&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWcMxSzU05DWGIZ1b1icvRXTSV7Bjxb1CgQ5AIGI4IianWrjsGI6FeU8WkZP88b0HJye0ibdY3lIrcXUw/640?wx_fmt=png&quot;/&gt;&lt;figcaption&gt;ThreadLocalMap扩容&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;具体代码：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.9412568306010929&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;1464&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWcMxSzU05DWGIZ1b1icvRXTSGjqQa74l4ibU9LUxAyiccib1M1ygC69DhiaAY9pLcTsVXh8kB5mG5hAUFw/640?wx_fmt=png&quot;/&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;figcaption&gt;ThreadLocalMap resize&lt;/figcaption&gt;&lt;/figure&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;17.父子线程怎么共享数据？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;父线程能用ThreadLocal来给子线程传值吗？毫无疑问，不能。那该怎么办？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这时候可以用到另外一个类——&lt;code&gt;InheritableThreadLocal&lt;/code&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;使用起来很简单，在主线程的InheritableThreadLocal实例设置值，在子线程中就可以拿到了。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;InheritableThreadLocalTest&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;(String[] args)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;final&lt;/span&gt; ThreadLocal threadLocal = &lt;span&gt;new&lt;/span&gt; InheritableThreadLocal();&lt;br/&gt;        &lt;span&gt;// 主线程&lt;/span&gt;&lt;br/&gt;        threadLocal.set(&lt;span&gt;&quot;不擅技术&quot;&lt;/span&gt;);&lt;br/&gt;        &lt;span&gt;//子线程&lt;/span&gt;&lt;br/&gt;        Thread t = &lt;span&gt;new&lt;/span&gt; Thread() {&lt;br/&gt;            &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;run&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;                &lt;span&gt;super&lt;/span&gt;.run();&lt;br/&gt;                System.out.println(&lt;span&gt;&quot;鄙人三某 ，&quot;&lt;/span&gt; + threadLocal.get());&lt;br/&gt;            }&lt;br/&gt;        };&lt;br/&gt;        t.start();&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;那原理是什么呢？&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;原理很简单，在Thread类里还有另外一个变量：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;ThreadLocal.ThreadLocalMap inheritableThreadLocals = &lt;span&gt;null&lt;/span&gt;;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在Thread.init的时候，如果父线程的&lt;code&gt;inheritableThreadLocals&lt;/code&gt;不为空，就把它赋给当前线程（子线程）的&lt;code&gt;inheritableThreadLocals&lt;/code&gt;。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;        &lt;span&gt;if&lt;/span&gt; (inheritThreadLocals &amp;amp;&amp;amp; parent.inheritableThreadLocals != &lt;span&gt;null&lt;/span&gt;)&lt;br/&gt;            &lt;span&gt;this&lt;/span&gt;.inheritableThreadLocals =&lt;br/&gt;                ThreadLocal.createInheritedMap(parent.inheritableThreadLocals);&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;Java内存模型&lt;/span&gt;&lt;/h1&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;18.说一下你对Java内存模型（JMM）的理解？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Java内存模型（Java Memory Model，JMM），是一种抽象的模型，被定义出来屏蔽各种硬件和操作系统的内存访问差异。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;JMM定义了线程和主内存之间的抽象关系：线程之间的共享变量存储在&lt;code&gt;主内存&lt;/code&gt;（Main Memory）中，每个线程都有一个私有的&lt;code&gt;本地内存&lt;/code&gt;（Local Memory），本地内存中存储了该线程以读/写共享变量的副本。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Java内存模型的抽象图：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.8428351309707242&quot; data-type=&quot;png&quot; data-w=&quot;649&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWcMxSzU05DWGIZ1b1icvRXTSnonAhOvsLyIq9oVniaHbQoBBiabb3icDmUj9QPpwr6JTicxLvUXjkyA5iag/640?wx_fmt=png&quot;/&gt;&lt;figcaption&gt;Java内存模型&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;本地内存是JMM的 一个抽象概念，并不真实存在。它其实涵盖了缓存、写缓冲区、寄存器以及其他的硬件和编译器优化。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.9327217125382263&quot; data-type=&quot;png&quot; data-w=&quot;654&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWcMxSzU05DWGIZ1b1icvRXTSAc5mhRToS0npoiaVx3X8JlsodFZK6fhurcicHpgRp14WfL8JvicvcOr6A/640?wx_fmt=png&quot;/&gt;&lt;figcaption&gt;实际线程工作模型&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;图里面的是一个双核 CPU 系统架构 ，每个核有自己的控制器和运算器，其中控制器包含一组寄存器和操作控制器，运算器执行算术逻辅运算。每个核都有自己的一级缓存，在有些架构里面还有一个所有 CPU 共享的二级缓存。那么 Java 内存模型里面的工作内存，就对应这里的 Ll 缓存或者 L2 缓存或者 CPU 寄存器。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;19.说说你对原子性、可见性、有序性的理解？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;原子性、有序性、可见性是并发编程中非常重要的基础概念，JMM的很多技术都是围绕着这三大特性展开。&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;原子性&lt;/strong&gt;：原子性指的是一个操作是不可分割、不可中断的，要么全部执行并且执行的过程不会被任何因素打断，要么就全不执行。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;可见性&lt;/strong&gt;：可见性指的是一个线程修改了某一个共享变量的值时，其它线程能够立即知道这个修改。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;有序性&lt;/strong&gt;：有序性指的是对于一个线程的执行代码，从前往后依次执行，单线程下可以认为程序是有序的，但是并发时有可能会发生指令重排。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;分析下面几行代码的原子性？&lt;/p&gt;&lt;/blockquote&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;2&lt;/span&gt;;&lt;br/&gt;&lt;span&gt;int&lt;/span&gt; j = i;&lt;br/&gt;i++;&lt;br/&gt;i = i + &lt;span&gt;1&lt;/span&gt;;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;第1句是基本类型赋值，是原子性操作。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;第2句先读i的值，再赋值到j，两步操作，不能保证原子性。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;第3和第4句其实是等效的，先读取i的值，再+1，最后赋值到i，三步操作了，不能保证原子性。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;原子性、可见性、有序性都应该怎么保证呢？&lt;/p&gt;&lt;/blockquote&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;原子性：JMM只能保证基本的原子性，如果要保证一个代码块的原子性，需要使用&lt;code&gt;synchronized&lt;/code&gt;。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;可见性：Java是利用&lt;code&gt;volatile&lt;/code&gt;关键字来保证可见性的，除此之外，&lt;code&gt;final&lt;/code&gt;和&lt;code&gt;synchronized&lt;/code&gt;也能保证可见性。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;有序性：&lt;code&gt;synchronized&lt;/code&gt;或者&lt;code&gt;volatile&lt;/code&gt;都可以保证多线程之间操作的有序性。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;20.那说说什么是指令重排？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在执行程序时，为了提高性能，编译器和处理器常常会对指令做重排序。重排序分3种类型。&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;编译器优化的重排序。编译器在不改变单线程程序语义的前提下，可以重新安排语句的执行顺序。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;指令级并行的重排序。现代处理器采用了指令级并行技术（Instruction-Level Parallelism，ILP）来将多条指令重叠执行。如果不存在数据依赖性，处理器可以改变语句对应 机器指令的执行顺序。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;内存系统的重排序。由于处理器使用缓存和读/写缓冲区，这使得加载和存储操作看上去可能是在乱序执行。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;从Java源代码到最终实际执行的指令序列，会分别经历下面3种重排序，如图：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-type=&quot;png&quot; data-ratio=&quot;0.18840579710144928&quot; data-w=&quot;1035&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWcMxSzU05DWGIZ1b1icvRXTSic5DZznpibPK6xYic2ia1qfAvCm2rgjicibgxl13iaib4EIFbCkTuTQibianGebw/640?wx_fmt=png&quot;/&gt;&lt;figcaption&gt;多级指令重排&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们比较熟悉的双重校验单例模式就是一个经典的指令重排的例子，&lt;code&gt;Singleton instance=new Singleton()；&lt;/code&gt;对应的JVM指令分为三步：分配内存空间--&amp;gt;初始化对象---&amp;gt;对象指向分配的内存空间，但是经过了编译器的指令重排序，第二步和第三步就可能会重排序。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6703662597114317&quot; data-type=&quot;png&quot; data-w=&quot;901&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWcMxSzU05DWGIZ1b1icvRXTSoocg32Q3ch7OlT42qibFohN60RgRYZ7sMAx6iciaHRDictnV8mJjib0Cy7w/640?wx_fmt=png&quot;/&gt;&lt;figcaption&gt;双重校验单例模式异常情形&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;JMM属于语言级的内存模型，它确保在不同的编译器和不同的处理器平台之上，通过禁止特定类型的编译器重排序和处理器重排序，为程序员提供一致的内存可见性保证。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;21.指令重排有限制吗？happens-before了解吗？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;指令重排也是有一些限制的，有两个规则&lt;code&gt;happens-before&lt;/code&gt;和&lt;code&gt;as-if-serial&lt;/code&gt;来约束。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;happens-before的定义：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;如果一个操作happens-before另一个操作，那么第一个操作的执行结果将对第二个操作可见，而且第一个操作的执行顺序排在第二个操作之前。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;两个操作之间存在happens-before关系，并不意味着Java平台的具体实现必须要按照 happens-before关系指定的顺序来执行。如果重排序之后的执行结果，与按happens-before关系来执行的结果一致，那么这种重排序并不非法&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;happens-before和我们息息相关的有六大规则：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.7006060606060606&quot; data-type=&quot;png&quot; data-w=&quot;825&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWcMxSzU05DWGIZ1b1icvRXTSG26AK357jeffoicWUO9hou5heVHIz0ib2Dzk3tz5mcWSWmFUXhGja5Lg/640?wx_fmt=png&quot;/&gt;&lt;figcaption&gt;happens-before六大规则&lt;/figcaption&gt;&lt;/figure&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;程序顺序规则&lt;/strong&gt;：一个线程中的每个操作，happens-before于该线程中的任意后续操作。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;监视器锁规则&lt;/strong&gt;：对一个锁的解锁，happens-before于随后对这个锁的加锁。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;volatile变量规则&lt;/strong&gt;：对一个volatile域的写，happens-before于任意后续对这个volatile域的读。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;传递性&lt;/strong&gt;：如果A happens-before B，且B happens-before C，那么A happens-before C。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;start()规则&lt;/strong&gt;：如果线程A执行操作ThreadB.start()（启动线程B），那么A线程的 ThreadB.start()操作happens-before于线程B中的任意操作。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;join()规则&lt;/strong&gt;：如果线程A执行操作ThreadB.join()并成功返回，那么线程B中的任意操作 happens-before于线程A从ThreadB.join()操作成功返回。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;22.as-if-serial又是什么？单线程的程序一定是顺序的吗？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;as-if-serial语义的意思是：不管怎么重排序（编译器和处理器为了提高并行度），&lt;strong&gt;单线程程序的执行结果不能被改变&lt;/strong&gt;。编译器、runtime和处理器都必须遵守as-if-serial语义。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;为了遵守as-if-serial语义，编译器和处理器不会对存在数据依赖关系的操作做重排序，因为这种重排序会改变执行结果。但是，如果操作之间不存在数据依赖关系，这些操作就可能被编译器和处理器重排序。为了具体说明，请看下面计算圆面积的代码示例。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;double&lt;/span&gt; pi = &lt;span&gt;3.14&lt;/span&gt;;   &lt;span&gt;// A&lt;/span&gt;&lt;br/&gt;&lt;span&gt;double&lt;/span&gt; r = &lt;span&gt;1.0&lt;/span&gt;;   &lt;span&gt;// B &lt;/span&gt;&lt;br/&gt;&lt;span&gt;double&lt;/span&gt; area = pi * r * r;   &lt;span&gt;// C&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上面3个操作的数据依赖关系：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5300925925925926&quot; data-type=&quot;png&quot; data-w=&quot;432&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWcMxSzU05DWGIZ1b1icvRXTSoicqQts0bjMgrE0ydNavibWlNQ2PoXiadcZBFQoZw1osxvKymibuIqYYSw/640?wx_fmt=png&quot;/&gt;&lt;figcaption&gt;image-20210812200646364&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;A和C之间存在数据依赖关系，同时B和C之间也存在数据依赖关系。因此在最终执行的指令序列中，C不能被重排序到A和B的前面（C排到A和B的前面，程序的结果将会被改变）。但A和B之间没有数据依赖关系，编译器和处理器可以重排序A和B之间的执行顺序。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以最终，程序可能会有两种执行顺序：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.36804853387259856&quot; data-type=&quot;png&quot; data-w=&quot;989&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWcMxSzU05DWGIZ1b1icvRXTSicLH66iaiaxc40M9Trt5Oibibeh38rTWArPs9lzibbbiar9cZydb3CUjT6zhQ/640?wx_fmt=png&quot;/&gt;&lt;figcaption&gt;两种执行结果&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;as-if-serial语义把单线程程序保护了起来，遵守as-if-serial语义的编译器、runtime和处理器共同编织了这么一个“楚门的世界”：单线程程序是按程序的“顺序”来执行的。as- if-serial语义使单线程情况下，我们不需要担心重排序的问题，可见性的问题。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;23.volatile实现原理了解吗？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;volatile有两个作用，保证&lt;strong&gt;可见性&lt;/strong&gt;和&lt;strong&gt;有序性&lt;/strong&gt;。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;volatile怎么保证可见性的呢？&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;相比synchronized的加锁方式来解决共享变量的内存可见性问题，volatile就是更轻量的选择，它没有上下文切换的额外开销成本。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;volatile可以确保对某个变量的更新对其他线程马上可见，一个变量被声明为volatile 时，线程在写入变量时不会把值缓存在寄存器或者其他地方，而是会把值刷新回主内存 当其它线程读取该共享变量 ，会从主内存重新获取最新值，而不是使用当前线程的本地内存中的值。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;例如，我们声明一个 volatile 变量 volatile int x = 0，线程A修改x=1，修改完之后就会把新的值刷新回主内存，线程B读取x的时候，就会清空本地内存变量，然后再从主内存获取最新值。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.38055555555555554&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWcMxSzU05DWGIZ1b1icvRXTSGcrh3iaF31I0HPWFgCvJwYz9LzdocCsvDwwpTLFcWCib9WDUOXJBSYRw/640?wx_fmt=png&quot;/&gt;&lt;figcaption&gt;volatile内存可见性&lt;/figcaption&gt;&lt;/figure&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;volatile怎么保证有序性的呢？&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;重排序可以分为编译器重排序和处理器重排序，valatile保证有序性，就是通过分别限制这两种类型的重排序。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5185659411011524&quot; data-type=&quot;png&quot; data-w=&quot;781&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWcMxSzU05DWGIZ1b1icvRXTS2ZQ1DzwFGiao8t8BK6RrXAfZxXKiagoDmcWY2vqxuLKTr7SvlJNyQsRQ/640?wx_fmt=png&quot;/&gt;&lt;figcaption&gt;volatile重排序规则表&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;为了实现volatile的内存语义，编译器在生成字节码时，会在指令序列中插入内存屏障来禁止特定类型的处理器重排序。&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;在每个volatile写操作的前面插入一个&lt;code&gt;StoreStore&lt;/code&gt;屏障&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;在每个volatile写操作的后面插入一个&lt;code&gt;StoreLoad&lt;/code&gt;屏障&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;在每个volatile读操作的后面插入一个&lt;code&gt;LoadLoad&lt;/code&gt;屏障&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;在每个volatile读操作的后面插入一个&lt;code&gt;LoadStore&lt;/code&gt;屏障&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.7437185929648241&quot; data-type=&quot;png&quot; data-w=&quot;796&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWcMxSzU05DWGIZ1b1icvRXTS3M20yZxcKh01sIRcmlfictrIiaFiamFAz6F6heFib3rUNekdic6aBcxQd8A/640?wx_fmt=png&quot;/&gt;&lt;figcaption&gt;volatile写插入内存屏障后生成的指令序列示意图&lt;/figcaption&gt;&lt;/figure&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.7459119496855345&quot; data-type=&quot;png&quot; data-w=&quot;795&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWcMxSzU05DWGIZ1b1icvRXTSckMwF6bKicicIo4KB8WWUBtxiazY0RYjkaHTPSficTicqFN8T1AJZ1ZHhoQ/640?wx_fmt=png&quot;/&gt;&lt;figcaption&gt;volatile写插入内存屏障后生成的指令序列示意图&lt;/figcaption&gt;&lt;/figure&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;锁&lt;/span&gt;&lt;/h1&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;24.synchronized用过吗？怎么使用？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;synchronized经常用的，用来保证代码的原子性。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;synchronized主要有三种用法：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;修饰实例方法:&lt;/strong&gt; 作用于当前对象实例加锁，进入同步代码前要获得 &lt;strong&gt;当前对象实例的锁&lt;/strong&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;synchronized&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;method&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;//业务代码&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;修饰静态方法&lt;/strong&gt;：也就是给当前类加锁，会作⽤于类的所有对象实例 ，进⼊同步代码前要获得当前 class 的锁。因为静态成员不属于任何⼀个实例对象，是类成员（ static 表明这是该类的⼀个静态资源，不管 new 了多少个对象，只有⼀份）。&lt;/p&gt;&lt;p&gt;如果⼀个线程 A 调⽤⼀个实例对象的⾮静态 synchronized ⽅法，⽽线程 B 需要调⽤这个实例对象所属类的静态 synchronized ⽅法，是允许的，不会发⽣互斥现象，因为访问静态 synchronized ⽅法占⽤的锁是当前类的锁，⽽访问⾮静态 synchronized ⽅法占⽤的锁是当前实例对象锁。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;synchronized&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; staic &lt;span&gt;method&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt; &lt;span&gt;//业务代码&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;修饰代码块&lt;/strong&gt; ：指定加锁对象，对给定对象/类加锁。synchronized(this|object) 表示进⼊同步代码库前要获得给定对象的锁。synchronized(类.class) 表示进⼊同步代码前要获得 当前 &lt;strong&gt;class&lt;/strong&gt; 的锁&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;synchronized&lt;/span&gt;(&lt;span&gt;this&lt;/span&gt;) {&lt;br/&gt; &lt;span&gt;//业务代码&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;25.synchronized的实现原理？&lt;/span&gt;&lt;/h2&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;synchronized是怎么加锁的呢？&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们使用synchronized的时候，发现不用自己去lock和unlock，是因为JVM帮我们把这个事情做了。&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;synchronized修饰代码块时，JVM采用&lt;code&gt;monitorenter&lt;/code&gt;、&lt;code&gt;monitorexit&lt;/code&gt;两个指令来实现同步，&lt;code&gt;monitorenter&lt;/code&gt; 指令指向同步代码块的开始位置， &lt;code&gt;monitorexit&lt;/code&gt; 指令则指向同步代码块的结束位置。&lt;/p&gt;&lt;p&gt;反编译一段synchronized修饰代码块代码，&lt;code&gt;javap -c -s -v -l SynchronizedDemo.class&lt;/code&gt;，可以看到相应的字节码指令。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.7293625914315569&quot; data-type=&quot;png&quot; data-w=&quot;957&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWcMxSzU05DWGIZ1b1icvRXTSRr65FWYHibtxk43IlzxZEuO4ibSzXiakqolF1FWDibuWGWRqqF5xG89zTQ/640?wx_fmt=png&quot;/&gt;&lt;figcaption&gt;monitorenter和monitorexit&lt;/figcaption&gt;&lt;/figure&gt;&lt;ol start=&quot;2&quot; data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;synchronized修饰同步方法时，JVM采用&lt;code&gt;ACC_SYNCHRONIZED&lt;/code&gt;标记符来实现同步，这个标识指明了该方法是一个同步方法。&lt;/p&gt;&lt;p&gt;同样可以写段代码反编译看一下。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.4750795334040297&quot; data-type=&quot;png&quot; data-w=&quot;943&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWcMxSzU05DWGIZ1b1icvRXTSvZkByFiaSR186ic6tG7tMUaz2gWloo5WpChlWgg0zOkmbzicLQibzBhX2g/640?wx_fmt=png&quot;/&gt;&lt;figcaption&gt;synchronized修饰同步方法&lt;/figcaption&gt;&lt;/figure&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;synchronized锁住的是什么呢？&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;monitorenter、monitorexit或者ACC_SYNCHRONIZED都是&lt;strong&gt;基于Monitor实现&lt;/strong&gt;的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;实例对象结构里有对象头，对象头里面有一块结构叫Mark Word，Mark Word指针指向了&lt;strong&gt;monitor&lt;/strong&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所谓的Monitor其实是一种&lt;strong&gt;同步工具&lt;/strong&gt;，也可以说是一种&lt;strong&gt;同步机制&lt;/strong&gt;。在Java虚拟机（HotSpot）中，Monitor是由&lt;strong&gt;ObjectMonitor实现&lt;/strong&gt;的，可以叫做内部锁，或者Monitor锁。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;ObjectMonitor的工作原理：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;ObjectMonitor有两个队列：_WaitSet、_EntryList，用来保存ObjectWaiter 对象列表。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;_owner，获取 Monitor 对象的线程进入 _owner 区时， _count + 1。如果线程调用了 wait() 方法，此时会释放 Monitor 对象， _owner 恢复为空， _count - 1。同时该等待线程进入 _WaitSet 中，等待被唤醒。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;ObjectMonitor() {&lt;br/&gt;    _header       = NULL;&lt;br/&gt;    _count        = &lt;span&gt;0&lt;/span&gt;; &lt;span&gt;// 记录线程获取锁的次数&lt;/span&gt;&lt;br/&gt;    _waiters      = &lt;span&gt;0&lt;/span&gt;,&lt;br/&gt;    _recursions   = &lt;span&gt;0&lt;/span&gt;;  &lt;span&gt;//锁的重入次数&lt;/span&gt;&lt;br/&gt;    _object       = NULL;&lt;br/&gt;    _owner        = NULL;  &lt;span&gt;// 指向持有ObjectMonitor对象的线程&lt;/span&gt;&lt;br/&gt;    _WaitSet      = NULL;  &lt;span&gt;// 处于wait状态的线程，会被加入到_WaitSet&lt;/span&gt;&lt;br/&gt;    _WaitSetLock  = &lt;span&gt;0&lt;/span&gt; ;&lt;br/&gt;    _Responsible  = NULL ;&lt;br/&gt;    _succ         = NULL ;&lt;br/&gt;    _cxq          = NULL ;&lt;br/&gt;    FreeNext      = NULL ;&lt;br/&gt;    _EntryList    = NULL ;  &lt;span&gt;// 处于等待锁block状态的线程，会被加入到该列表&lt;/span&gt;&lt;br/&gt;    _SpinFreq     = &lt;span&gt;0&lt;/span&gt; ;&lt;br/&gt;    _SpinClock    = &lt;span&gt;0&lt;/span&gt; ;&lt;br/&gt;    OwnerIsThread = &lt;span&gt;0&lt;/span&gt; ;&lt;br/&gt;  }&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可以类比一个去医院就诊的例子[18]：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;首先，患者在&lt;strong&gt;门诊大厅&lt;/strong&gt;前台或自助挂号机&lt;strong&gt;进行挂号&lt;/strong&gt;；&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;随后，挂号结束后患者找到对应的&lt;strong&gt;诊室就诊&lt;/strong&gt;：&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;诊室每次只能有一个患者就诊；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;如果此时诊室空闲，直接进入就诊；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;如果此时诊室内有其它患者就诊，那么当前患者进入&lt;strong&gt;候诊室&lt;/strong&gt;，等待叫号；&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;就诊结束后，&lt;strong&gt;走出就诊室&lt;/strong&gt;，候诊室的&lt;strong&gt;下一位候诊患者&lt;/strong&gt;进入就诊室。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.4444444444444444&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWcMxSzU05DWGIZ1b1icvRXTSiagkLrT13ODJIGtCoqmkaqHAr8ajLSn9yrssSYc4tCuFyFzmtFRW5BA/640?wx_fmt=png&quot;/&gt;&lt;figcaption&gt;就诊-图片来源参考[18]&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个过程就和Monitor机制比较相似：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;门诊大厅&lt;/strong&gt;：所有待进入的线程都必须先在&lt;strong&gt;入口Entry Set&lt;/strong&gt;挂号才有资格；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;就诊室&lt;/strong&gt;：就诊室**_Owner**里里只能有一个线程就诊，就诊完线程就自行离开&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;候诊室&lt;/strong&gt;：就诊室繁忙时，进入&lt;strong&gt;等待区（Wait Set）&lt;/strong&gt;，就诊室空闲的时候就从**等待区（Wait Set）**叫新的线程&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.45925925925925926&quot; data-type=&quot;png&quot; data-w=&quot;945&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWcMxSzU05DWGIZ1b1icvRXTSos3QdH4PxYjvib985CQRpnWcRVfjEPUUpNlOS9qdqVcMeiaP45JeH4xg/640?wx_fmt=png&quot;/&gt;&lt;figcaption&gt;Java Montior机制&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以我们就知道了，同步是锁住的什么东西：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;monitorenter，在判断拥有同步标识 ACC_SYNCHRONIZED 抢先进入此方法的线程会优先拥有 Monitor 的 owner ，此时计数器 +1。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;monitorexit，当执行完退出后，计数器 -1，归 0 后被其他进入的线程获得。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;26.除了原子性，synchronized可见性，有序性，可重入性怎么实现？&lt;/span&gt;&lt;/h2&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;synchronized怎么保证可见性？&lt;/p&gt;&lt;/blockquote&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;线程加锁前，将清空工作内存中共享变量的值，从而使用共享变量时需要从主内存中重新读取最新的值。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;线程加锁后，其它线程无法获取主内存中的共享变量。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;线程解锁前，必须把共享变量的最新值刷新到主内存中。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;synchronized怎么保证有序性？&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;synchronized同步的代码块，具有排他性，一次只能被一个线程拥有，所以synchronized保证同一时刻，代码是单线程执行的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;因为as-if-serial语义的存在，单线程的程序能保证最终结果是有序的，但是不保证不会指令重排。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以synchronized保证的有序是执行结果的有序性，而不是防止指令重排的有序性。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;synchronized怎么实现可重入的呢？&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;synchronized 是可重入锁，也就是说，允许一个线程二次请求自己持有对象锁的临界资源，这种情况称为可重入锁。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;synchronized 锁对象的时候有个计数器，他会记录下线程获取锁的次数，在执行完对应的代码块之后，计数器就会-1，直到计数器清零，就释放锁了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;之所以，是可重入的。是因为 synchronized 锁对象有个计数器，会随着线程获取锁后 +1 计数，当线程执行完毕后 -1，直到清零释放锁。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;27.锁升级？synchronized优化了解吗？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;了解锁升级，得先知道，不同锁的状态是什么样的。这个状态指的是什么呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Java对象头里，有一块结构，叫&lt;code&gt;Mark Word&lt;/code&gt;标记字段，这块结构会随着锁的状态变化而变化。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;64 位虚拟机 Mark Word 是 64bit，我们来看看它的状态变化：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.43461900282220134&quot; data-type=&quot;png&quot; data-w=&quot;1063&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWcMxSzU05DWGIZ1b1icvRXTSIibOhyPThvSk8jq1BpXuUcrcNfa2M7VEXg5yQn8NCFLLic4zMr8pG8EQ/640?wx_fmt=png&quot;/&gt;&lt;figcaption&gt;Mark Word变化&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Mark Word存储对象自身的运行数据，如&lt;strong&gt;哈希码、GC分代年龄、锁状态标志、偏向时间戳（Epoch）&lt;/strong&gt; 等。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;synchronized做了哪些优化？&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在JDK1.6之前，synchronized的实现直接调用ObjectMonitor的enter和exit，这种锁被称之为&lt;strong&gt;重量级锁&lt;/strong&gt;。从JDK6开始，HotSpot虚拟机开发团队对Java中的锁进行优化，如增加了适应性自旋、锁消除、锁粗化、轻量级锁和偏向锁等优化策略，提升了synchronized的性能。&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;偏向锁：在无竞争的情况下，只是在Mark Word里存储当前线程指针，CAS操作都不做。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;轻量级锁：在没有多线程竞争时，相对重量级锁，减少操作系统互斥量带来的性能消耗。但是，如果存在锁竞争，除了互斥量本身开销，还额外有CAS操作的开销。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;自旋锁：减少不必要的CPU上下文切换。在轻量级锁升级为重量级锁时，就使用了自旋加锁的方式&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;锁粗化：将多个连续的加锁、解锁操作连接在一起，扩展成一个范围更大的锁。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;锁消除：虚拟机即时编译器在运行时，对一些代码上要求同步，但是被检测到不可能存在共享数据竞争的锁进行消除。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;锁升级的过程是什么样的？&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;锁升级方向：无锁--&amp;gt;偏向锁---&amp;gt; 轻量级锁----&amp;gt;重量级锁，这个方向基本上是不可逆的。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.32&quot; data-type=&quot;png&quot; data-w=&quot;525&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWcMxSzU05DWGIZ1b1icvRXTSFBicqibx89V9xFTHnSrdwBvrxTmdichAPglf9UQtxhNNJYtiamtDxGJRug/640?wx_fmt=png&quot;/&gt;&lt;figcaption&gt;锁升级方向&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们看一下升级的过程：&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;偏向锁：&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;偏向锁的获取：&lt;/strong&gt;&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;判断是否为可偏向状态--MarkWord中锁标志是否为‘01’，是否偏向锁是否为‘1’&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;如果是可偏向状态，则查看线程ID是否为当前线程，如果是，则进入步骤&#x27;5&#x27;，否则进入步骤‘3’&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;通过CAS操作竞争锁，如果竞争成功，则将MarkWord中线程ID设置为当前线程ID，然后执行‘5’；竞争失败，则执行‘4’&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;CAS获取偏向锁失败表示有竞争。当达到safepoint时获得偏向锁的线程被挂起，&lt;strong&gt;偏向锁升级为轻量级锁&lt;/strong&gt;，然后被阻塞在安全点的线程继续往下执行同步代码块&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;执行同步代码&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;偏向锁的撤销：&lt;/strong&gt;&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;偏向锁不会主动释放(撤销)，只有遇到其他线程竞争时才会执行撤销，由于撤销需要知道当前持有该偏向锁的线程栈状态，因此要等到safepoint时执行，此时持有该偏向锁的线程（T）有‘2’，‘3’两种情况；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;撤销----T线程已经退出同步代码块，或者已经不再存活，则直接撤销偏向锁，变成无锁状态----该状态达到阈值20则执行批量重偏向&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;升级----T线程还在同步代码块中，则将T线程的偏向锁&lt;strong&gt;升级为轻量级锁&lt;/strong&gt;，当前线程执行轻量级锁状态下的锁获取步骤----该状态达到阈值40则执行批量撤销&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;轻量级锁：&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;轻量级锁的获取：&lt;/strong&gt;&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;进行加锁操作时，jvm会判断是否已经时重量级锁，如果不是，则会在当前线程栈帧中划出一块空间，作为该锁的锁记录，并且将锁对象MarkWord复制到该锁记录中&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;复制成功之后，jvm使用CAS操作将对象头MarkWord更新为指向锁记录的指针，并将锁记录里的owner指针指向对象头的MarkWord。如果成功，则执行‘3’，否则执行‘4’&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;更新成功，则当前线程持有该对象锁，并且对象MarkWord锁标志设置为‘00’，即表示此对象处于轻量级锁状态&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;更新失败，jvm先检查对象MarkWord是否指向当前线程栈帧中的锁记录，如果是则执行‘5’，否则执行‘4’&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;表示锁重入；然后当前线程栈帧中增加一个锁记录第一部分（Displaced Mark Word）为null，并指向Mark Word的锁对象，起到一个重入计数器的作用。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;表示该锁对象已经被其他线程抢占，则进行&lt;strong&gt;自旋等待&lt;/strong&gt;（默认10次），等待次数达到阈值仍未获取到锁，则&lt;strong&gt;升级为重量级锁&lt;/strong&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;大体上省简的升级过程：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.2&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWcMxSzU05DWGIZ1b1icvRXTSUdHGNFiaN1E2Zr5MxUCOLXzsmdazwmo4icmdbDt1Trq3jnKPMuJ7jia9g/640?wx_fmt=png&quot;/&gt;&lt;figcaption&gt;锁升级简略过程&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;完整的升级过程：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.47685185185185186&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWcMxSzU05DWGIZ1b1icvRXTSkjvnRAc4TnSIA1U2icO3p0LuvwqOjhxmPUuNkUXf1joULVyycxHeu8A/640?wx_fmt=png&quot;/&gt;&lt;figcaption&gt;synchronized 锁升级过程-来源参考[14]&lt;/figcaption&gt;&lt;/figure&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;28.说说synchronized和ReentrantLock的区别？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可以从锁的实现、功能特点、性能等几个维度去回答这个问题：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;锁的实现：&lt;/strong&gt; synchronized是Java语言的关键字，基于JVM实现。而ReentrantLock是基于JDK的API层面实现的（一般是lock()和unlock()方法配合try/finally 语句块来完成。）&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;性能：&lt;/strong&gt; 在JDK1.6锁优化以前，synchronized的性能比ReenTrantLock差很多。但是JDK6开始，增加了适应性自旋、锁消除等，两者性能就差不多了。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;功能特点：&lt;/strong&gt; ReentrantLock 比 synchronized 增加了一些高级功能，如等待可中断、可实现公平锁、可实现选择性通知。&lt;/section&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;ReentrantLock提供了一种能够中断等待锁的线程的机制，通过lock.lockInterruptibly()来实现这个机制&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;ReentrantLock可以指定是公平锁还是非公平锁。而synchronized只能是非公平锁。所谓的公平锁就是先等待的线程先获得锁。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;synchronized与wait()和notify()/notifyAll()方法结合实现等待/通知机制，ReentrantLock类借助Condition接口与newCondition()方法实现。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;ReentrantLock需要手工声明来加锁和释放锁，一般跟finally配合释放锁。而synchronized不用手动释放锁。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;下面的表格列出出了两种锁之间的区别：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-type=&quot;png&quot; data-ratio=&quot;0.5582010582010583&quot; data-w=&quot;756&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWcMxSzU05DWGIZ1b1icvRXTSYVosAF4icCeqKaSzMCOibQBHniaPwlicAVUiapic0M78KCQsoH8NkkGDibTicA/640?wx_fmt=png&quot;/&gt;&lt;figcaption&gt;synchronized和ReentrantLock的区别&lt;/figcaption&gt;&lt;/figure&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;29.AQS了解多少？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;AbstractQueuedSynchronizer 抽象同步队列，简称 AQS ，它是Java并发包的根基，并发包中的锁就是基于AQS实现的。&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;AQS是基于一个FIFO的双向队列，其内部定义了一个节点类Node，Node 节点内部的 SHARED 用来标记该线程是获取共享资源时被阻挂起后放入AQS 队列的， EXCLUSIVE 用来标记线程是 取独占资源时被挂起后放入AQS 队列&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;AQS 使用一个 volatile 修饰的 int 类型的成员变量 state 来表示同步状态，修改同步状态成功即为获得锁，volatile 保证了变量在多线程之间的可见性，修改 State 值时通过 CAS 机制来保证修改的原子性&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;获取state的方式分为两种，独占方式和共享方式，一个线程使用独占方式获取了资源，其它线程就会在获取失败后被阻塞。一个线程使用共享方式获取了资源，另外一个线程还可以通过CAS的方式进行获取。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;如果共享资源被占用，需要一定的阻塞等待唤醒机制来保证锁的分配，AQS 中会将竞争共享资源失败的线程添加到一个变体的 CLH 队列中。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-type=&quot;png&quot; data-ratio=&quot;0.3574074074074074&quot; data-w=&quot;1080&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWcMxSzU05DWGIZ1b1icvRXTSHibmXuU9fNatvbDvmliawbRgKe1N7ThtQPKaJicIVTnY6jfgp0KzwktWQ/640?wx_fmt=png&quot;/&gt;先简单了解一下CLH：Craig、Landin and Hagersten 队列，是 &lt;strong&gt;单向链表实现的队列&lt;/strong&gt;。申请线程只在本地变量上自旋，&lt;strong&gt;它不断轮询前驱的状态&lt;/strong&gt;，如果发现 &lt;strong&gt;前驱节点释放了锁就结束自旋&lt;/strong&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-type=&quot;png&quot; data-ratio=&quot;0.2759259259259259&quot; data-w=&quot;1080&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWcMxSzU05DWGIZ1b1icvRXTSb1rsYZx0s7UfGico3DU3xL4vVWuopBj5fE9jJPyMutQkFgOom8phllA/640?wx_fmt=png&quot;/&gt;&lt;figcaption&gt;CLH队列&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;AQS 中的队列是 CLH 变体的虚拟双向队列，通过将每条请求共享资源的线程封装成一个节点来实现锁的分配：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-type=&quot;png&quot; data-ratio=&quot;0.2935185185185185&quot; data-w=&quot;1080&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWcMxSzU05DWGIZ1b1icvRXTShod0nzG9dWkP9pgooxqstkWOSmtiahqPMdIp9FGicaujPkWFyuEHb7Fw/640?wx_fmt=png&quot;/&gt;&lt;figcaption&gt;AQS变种CLH队列&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;AQS 中的 CLH 变体等待队列拥有以下特性：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;AQS 中队列是个双向链表，也是 FIFO 先进先出的特性&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;通过 Head、Tail 头尾两个节点来组成队列结构，通过 volatile 修饰保证可见性&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Head 指向节点为已获得锁的节点，是一个虚拟节点，节点本身不持有具体线程&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;获取不到同步状态，会将节点进行自旋获取锁，自旋一定次数失败后会将线程阻塞，相对于 CLH 队列性能较好&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;ps:AQS源码里面有很多细节可问，建议有时间好好看看AQS源码。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;30.&lt;strong&gt;ReentrantLock&lt;/strong&gt;实现原理？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;ReentrantLock 是可重入的独占锁，只能有一个线程可以获取该锁，其它获取该锁的线程会被阻塞而被放入该锁的阻塞队列里面。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;看看ReentrantLock的加锁操作：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;    &lt;span&gt;// 创建非公平锁&lt;/span&gt;&lt;br/&gt;    ReentrantLock lock = &lt;span&gt;new&lt;/span&gt; ReentrantLock();&lt;br/&gt;    &lt;span&gt;// 获取锁操作&lt;/span&gt;&lt;br/&gt;    lock.lock();&lt;br/&gt;    &lt;span&gt;try&lt;/span&gt; {&lt;br/&gt;        &lt;span&gt;// 执行代码逻辑&lt;/span&gt;&lt;br/&gt;    } &lt;span&gt;catch&lt;/span&gt; (Exception ex) {&lt;br/&gt;        &lt;span&gt;// ...&lt;/span&gt;&lt;br/&gt;    } &lt;span&gt;finally&lt;/span&gt; {&lt;br/&gt;        &lt;span&gt;// 解锁操作&lt;/span&gt;&lt;br/&gt;        lock.unlock();&lt;br/&gt;    }&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;new ReentrantLock()&lt;/code&gt;构造函数默认创建的是非公平锁 NonfairSync。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;公平锁 FairSync&lt;/strong&gt;&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;公平锁是指多个线程按照申请锁的顺序来获取锁，线程直接进入队列中排队，队列中的第一个线程才能获得锁&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;公平锁的优点是等待锁的线程不会饿死。缺点是整体吞吐效率相对非公平锁要低，等待队列中除第一个线程以外的所有线程都会阻塞，CPU 唤醒阻塞线程的开销比非公平锁大&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;非公平锁 NonfairSync&lt;/strong&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;非公平锁是多个线程加锁时直接尝试获取锁，获取不到才会到等待队列的队尾等待。但如果此时锁刚好可用，那么这个线程可以无需阻塞直接获取到锁&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;非公平锁的优点是可以减少唤起线程的开销，整体的吞吐效率高，因为线程有几率不阻塞直接获得锁，CPU 不必唤醒所有线程。缺点是处于等待队列中的线程可能会饿死，或者等很久才会获得锁&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;默认创建的对象lock()的时候：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;如果锁当前没有被其它线程占用，并且当前线程之前没有获取过该锁，则当前线程会获取到该锁，然后设置当前锁的拥有者为当前线程，并设置 AQS 的状态值为1 ，然后直接返回。如果当前线程之前己经获取过该锁，则这次只是简单地把 AQS 的状态值加1后返回。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;如果该锁己经被其他线程持有，非公平锁会尝试去获取锁，获取失败的话，则调用该方法线程会被放入 AQS 队列阻塞挂起。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-type=&quot;png&quot; data-ratio=&quot;0.6967930029154519&quot; data-w=&quot;686&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWcMxSzU05DWGIZ1b1icvRXTSxW4UK7CjYTOdRgwfib67w89iay9r7m4vhSzZQ24LXNFaKqtFyq8ibHu9Q/640?wx_fmt=png&quot;/&gt;&lt;figcaption&gt;ReentrantLock 非公平锁加锁流程简图&lt;/figcaption&gt;&lt;/figure&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;31.ReentrantLock怎么实现公平锁的？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;new ReentrantLock()&lt;/code&gt;构造函数默认创建的是非公平锁 NonfairSync&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;ReentrantLock&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    sync = &lt;span&gt;new&lt;/span&gt; NonfairSync();&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;同时也可以在创建锁构造函数中传入具体参数创建公平锁 FairSync&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;ReentrantLock lock = &lt;span&gt;new&lt;/span&gt; ReentrantLock(&lt;span&gt;true&lt;/span&gt;);&lt;br/&gt;--- ReentrantLock&lt;br/&gt;&lt;span&gt;// true 代表公平锁，false 代表非公平锁&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;ReentrantLock&lt;/span&gt;&lt;span&gt;(&lt;span&gt;boolean&lt;/span&gt; fair)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    sync = fair ? &lt;span&gt;new&lt;/span&gt; FairSync() : &lt;span&gt;new&lt;/span&gt; NonfairSync();&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;FairSync、NonfairSync 代表公平锁和非公平锁，两者都是 ReentrantLock 静态内部类，只不过实现不同锁语义。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;非公平锁和公平锁的两处不同：&lt;/strong&gt;&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;非公平锁在调用 lock 后，首先就会调用 CAS 进行一次抢锁，如果这个时候恰巧锁没有被占用，那么直接就获取到锁返回了。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;非公平锁在 CAS 失败后，和公平锁一样都会进入到 tryAcquire 方法，在 tryAcquire 方法中，如果发现锁这个时候被释放了（state == 0），非公平锁会直接 CAS 抢锁，但是公平锁会判断等待队列是否有线程处于等待状态，如果有则不去抢锁，乖乖排到后面。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-type=&quot;png&quot; data-ratio=&quot;1.0907407407407408&quot; data-w=&quot;1080&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWcMxSzU05DWGIZ1b1icvRXTSCS1z5onhYJcWagbrTJI5rcWrKribFQ5S3j7lMibJfwJY9z2vL2BDx6zg/640?wx_fmt=png&quot;/&gt;&lt;figcaption&gt;公平锁tryAcquire&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;相对来说，非公平锁会有更好的性能，因为它的吞吐量比较大。当然，非公平锁让获取锁的时间变得更加不确定，可能会导致在阻塞队列中的线程长期处于饥饿状态。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;32.CAS呢？CAS了解多少？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;CAS叫做CompareAndSwap，⽐较并交换，主要是通过处理器的指令来保证操作的原⼦性的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;CAS 指令包含 3 个参数：共享变量的内存地址 A、预期的值 B 和共享变量的新值 C。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;只有当内存中地址 A 处的值等于 B 时，才能将内存中地址 A 处的值更新为新值 C。作为一条 CPU 指令，CAS 指令本身是能够保证原子性的 。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;33.CAS 有什么问题？如何解决？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;CAS的经典三大问题：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-type=&quot;png&quot; data-ratio=&quot;0.4019138755980861&quot; data-w=&quot;836&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWcMxSzU05DWGIZ1b1icvRXTSCmW9YFZQxA82BH87mhNickMyP1GtHDUTQoTO5ajoPfvKeNgBfI9U0iaQ/640?wx_fmt=png&quot;/&gt;&lt;figcaption&gt;CAS三大问题&lt;/figcaption&gt;&lt;/figure&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;ABA 问题&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;并发环境下，假设初始条件是A，去修改数据时，发现是A就会执行修改。但是看到的虽然是A，中间可能发生了A变B，B又变回A的情况。此时A已经非彼A，数据即使成功修改，也可能有问题。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;怎么解决ABA问题？&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;每次修改变量，都在这个变量的版本号上加1，这样，刚刚A-&amp;gt;B-&amp;gt;A，虽然A的值没变，但是它的版本号已经变了，再判断版本号就会发现此时的A已经被改过了。参考乐观锁的版本号，这种做法可以给数据带上了一种实效性的检验。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Java提供了AtomicStampReference类，它的compareAndSet方法首先检查当前的对象引用值是否等于预期引用，并且当前印戳（Stamp）标志是否等于预期标志，如果全部相等，则以原子方式将引用值和印戳标志的值更新为给定的更新值。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;循环性能开销&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;自旋CAS，如果一直循环执行，一直不成功，会给CPU带来非常大的执行开销。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;怎么解决循环性能开销问题？&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在Java中，很多使用自旋CAS的地方，会有一个自旋次数的限制，超过一定次数，就停止自旋。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;只能保证一个变量的原子操作&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;CAS 保证的是对一个变量执行操作的原子性，如果对多个变量操作时，CAS 目前无法直接保证操作的原子性的。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;怎么解决只能保证一个变量的原子操作问题？&lt;/p&gt;&lt;/blockquote&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;可以考虑改用锁来保证操作的原子性&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;可以考虑合并多个变量，将多个变量封装成一个对象，通过AtomicReference来保证原子性。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;34.Java有哪些保证原子性的方法？如何保证多线程下i++ 结果正确？&lt;/span&gt;&lt;/h2&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-type=&quot;png&quot; data-ratio=&quot;0.4114114114114114&quot; data-w=&quot;666&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWcMxSzU05DWGIZ1b1icvRXTSzoU0PfIVzIW6XOxevaHvDKTibuysDUZaDOibBElaM77pMYIM7kAKd43A/640?wx_fmt=png&quot;/&gt;&lt;figcaption&gt;Java保证原子性方法&lt;/figcaption&gt;&lt;/figure&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;使用循环原子类，例如AtomicInteger，实现i++原子操作&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;使用juc包下的锁，如ReentrantLock ，对i++操作加锁lock.lock()来实现原子性&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;使用synchronized，对i++操作加锁&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;35.原子操作类了解多少？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当程序更新一个变量时，如果多线程同时更新这个变量，可能得到期望之外的值，比如变量i=1，A线程更新i+1，B线程也更新i+1，经过两个线程操作之后可能i不等于3，而是等于2。因为A和B线程在更新变量i的时候拿到的i都是1，这就是线程不安全的更新操作，一般我们会使用synchronized来解决这个问题，synchronized会保证多线程不会同时更新变量i。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其实除此之外，还有更轻量级的选择，Java从JDK 1.5开始提供了java.util.concurrent.atomic包，这个包中的原子操作类提供了一种用法简单、性能高效、线程安全地更新一个变量的方式。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;因为变量的类型有很多种，所以在Atomic包里一共提供了13个类，属于4种类型的原子更新方式，分别是原子更新基本类型、原子更新数组、原子更新引用和原子更新属性（字段）。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-type=&quot;png&quot; data-ratio=&quot;0.8307849133537207&quot; data-w=&quot;981&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWcMxSzU05DWGIZ1b1icvRXTSQDecO0hWicHCSFaxnibCBlyH2bxBGvEeZr4cmYIiavD4D7o9YSlSfk67w/640?wx_fmt=png&quot;/&gt;&lt;figcaption&gt;原子操作类&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Atomic包里的类基本都是使用Unsafe实现的包装类。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;使用原子的方式更新基本类型，Atomic包提供了以下3个类：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;AtomicBoolean：原子更新布尔类型。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;AtomicInteger：原子更新整型。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;AtomicLong：原子更新长整型。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;通过原子的方式更新数组里的某个元素，Atomic包提供了以下4个类：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;AtomicIntegerArray：原子更新整型数组里的元素。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;AtomicLongArray：原子更新长整型数组里的元素。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;AtomicReferenceArray：原子更新引用类型数组里的元素。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;AtomicIntegerArray类主要是提供原子的方式更新数组里的整型&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;原子更新基本类型的AtomicInteger，只能更新一个变量，如果要原子更新多个变量，就需要使用这个原子更新引用类型提供的类。Atomic包提供了以下3个类：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;AtomicReference：原子更新引用类型。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;AtomicReferenceFieldUpdater：原子更新引用类型里的字段。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;AtomicMarkableReference：原子更新带有标记位的引用类型。可以原子更新一个布尔类型的标记位和引用类型。构造方法是AtomicMarkableReference（V initialRef，boolean initialMark）。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果需原子地更新某个类里的某个字段时，就需要使用原子更新字段类，Atomic包提供了以下3个类进行原子字段更新：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;AtomicIntegerFieldUpdater：原子更新整型的字段的更新器。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;AtomicLongFieldUpdater：原子更新长整型字段的更新器。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;AtomicStampedReference：原子更新带有版本号的引用类型。该类将整数值与引用关联起来，可用于原子的更新数据和数据的版本号，可以解决使用CAS进行原子更新时可能出现的 ABA问题。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;36.AtomicInteger 的原理？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;一句话概括：&lt;strong&gt;使用CAS实现&lt;/strong&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;以AtomicInteger的添加方法为例：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; &lt;span&gt;getAndIncrement&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; unsafe.getAndAddInt(&lt;span&gt;this&lt;/span&gt;, valueOffset, &lt;span&gt;1&lt;/span&gt;);&lt;br/&gt;    }&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;通过&lt;code&gt;Unsafe&lt;/code&gt;类的实例来进行添加操作，来看看具体的CAS操作：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; &lt;span&gt;getAndAddInt&lt;/span&gt;&lt;span&gt;(Object var1, &lt;span&gt;long&lt;/span&gt; var2, &lt;span&gt;int&lt;/span&gt; var4)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;int&lt;/span&gt; var5;&lt;br/&gt;        &lt;span&gt;do&lt;/span&gt; {&lt;br/&gt;            var5 = &lt;span&gt;this&lt;/span&gt;.getIntVolatile(var1, var2);&lt;br/&gt;        } &lt;span&gt;while&lt;/span&gt;(!&lt;span&gt;this&lt;/span&gt;.compareAndSwapInt(var1, var2, var5, var5 + var4));&lt;br/&gt;&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; var5;&lt;br/&gt;    }&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;compareAndSwapInt 是一个native方法，基于CAS来操作int类型变量。其它的原子操作类基本都是大同小异。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;37.线程死锁了解吗？该如何避免？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;死锁是指两个或两个以上的线程在执行过程中，因争夺资源而造成的互相等待的现象，在无外力作用的情况下，这些线程会一直相互等待而无法继续运行下去。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-type=&quot;png&quot; data-ratio=&quot;0.5182481751824818&quot; data-w=&quot;411&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWcMxSzU05DWGIZ1b1icvRXTSJZBWAeMMS4QmWpfWhuUf9hmricZSX2fE9hRjatRjNVCoMXxbwDN9GxA/640?wx_fmt=png&quot;/&gt;&lt;figcaption&gt;死锁示意图&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那么为什么会产生死锁呢？死锁的产生必须具备以下四个条件：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-type=&quot;png&quot; data-ratio=&quot;0.4772344013490725&quot; data-w=&quot;593&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWcMxSzU05DWGIZ1b1icvRXTSLvMeyd8aibH7WpmtvvqgVnricnFQEEA0waM0CytWbM53yGcr4jOlHxFQ/640?wx_fmt=png&quot;/&gt;&lt;figcaption&gt;死锁产生必备四条件&lt;/figcaption&gt;&lt;/figure&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;互斥条件：指线程对己经获取到的资源进行它性使用，即该资源同时只由一个线程占用。如果此时还有其它线程请求获取获取该资源，则请求者只能等待，直至占有资源的线程释放该资源。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;请求并持有条件：指一个 线程己经持有了至少一个资源，但又提出了新的资源请求，而新资源己被其它线程占有，所以当前线程会被阻塞，但阻塞 的同时并不释放自己已经获取的资源。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;不可剥夺条件：指线程获取到的资源在自己使用完之前不能被其它线程抢占，只有在自己使用完毕后才由自己释放该资源。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;环路等待条件：指在发生死锁时，必然存在一个线程——资源的环形链，即线程集合 {T0，T1，T2,…… ，Tn} 中 T0 正在等待一 T1 占用的资源，Tl1正在等待 T2用的资源，…… Tn 在等待己被 T0占用的资源。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;该如何避免死锁呢？答案是&lt;strong&gt;至少破坏死锁发生的一个条件&lt;/strong&gt;。&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;其中，互斥这个条件我们没有办法破坏，因为用锁为的就是互斥。不过其他三个条件都是有办法破坏掉的，到底如何做呢？&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;对于“请求并持有”这个条件，可以一次性请求所有的资源。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;对于“不可剥夺”这个条件，占用部分资源的线程进一步申请其他资源时，如果申请不到，可以主动释放它占有的资源，这样不可抢占这个条件就破坏掉了。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;对于“环路等待”这个条件，可以靠按序申请资源来预防。所谓按序申请，是指资源是有线性顺序的，申请的时候可以先申请资源序号小的，再申请资源序号大的，这样线性化后就不存在环路了。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;38.那死锁问题怎么排查呢？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可以使用jdk自带的命令行工具排查：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;使用jps查找运行的Java进程：jps -l&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;使用jstack查看线程堆栈信息：jstack -l  进程id&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;基本就可以看到死锁的信息。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;还可以利用图形化工具，比如JConsole。出现线程死锁以后，点击JConsole线程面板的&lt;code&gt;检测到死锁&lt;/code&gt;按钮，将会看到线程的死锁信息。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-type=&quot;png&quot; data-ratio=&quot;0.6527777777777778&quot; data-w=&quot;1080&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWcMxSzU05DWGIZ1b1icvRXTSZaDcxh51tkQdYyOk2Mj56hV8d1c3L1HAdzZ0MREJXicxXicrWj0rlGdQ/640?wx_fmt=png&quot;/&gt;&lt;figcaption&gt;线程死锁检测&lt;/figcaption&gt;&lt;/figure&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;并发工具类&lt;/span&gt;&lt;/h1&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;39.CountDownLatch（倒计数器）了解吗？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;CountDownLatch，倒计数器，有两个常见的应用场景[18]：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;场景1：协调子线程结束动作：等待所有子线程运行结束&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;CountDownLatch允许一个或多个线程等待其他线程完成操作。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;例如，我们很多人喜欢玩的王者荣耀，开黑的时候，得等所有人都上线之后，才能开打。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-type=&quot;jpeg&quot; data-ratio=&quot;0.5314814814814814&quot; data-w=&quot;1080&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/PMZOEonJxWcMxSzU05DWGIZ1b1icvRXTSDeuziaia9bUbDlgkVXZuy3Tn8mhsbfV0cHY6Y44VGXblHuzxDpibwibLng/640?wx_fmt=jpeg&quot;/&gt;&lt;figcaption&gt;王者荣耀等待玩家确认-来源参考[18]&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;CountDownLatch模仿这个场景(参考[18])：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;创建大乔、兰陵王、安其拉、哪吒和铠等五个玩家，主线程必须在他们都完成确认后，才可以继续运行。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在这段代码中，&lt;code&gt;new CountDownLatch(5)&lt;/code&gt;用户创建初始的latch数量，各玩家通过&lt;code&gt;countDownLatch.countDown()&lt;/code&gt;完成状态确认，主线程通过&lt;code&gt;countDownLatch.await()&lt;/code&gt;等待。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;(String[] args)&lt;/span&gt; &lt;span&gt;throws&lt;/span&gt; InterruptedException &lt;/span&gt;{&lt;br/&gt;        CountDownLatch countDownLatch = &lt;span&gt;new&lt;/span&gt; CountDownLatch(&lt;span&gt;5&lt;/span&gt;);&lt;br/&gt;&lt;br/&gt;        Thread 大乔 = &lt;span&gt;new&lt;/span&gt; Thread(countDownLatch::countDown);&lt;br/&gt;        Thread 兰陵王 = &lt;span&gt;new&lt;/span&gt; Thread(countDownLatch::countDown);&lt;br/&gt;        Thread 安其拉 = &lt;span&gt;new&lt;/span&gt; Thread(countDownLatch::countDown);&lt;br/&gt;        Thread 哪吒 = &lt;span&gt;new&lt;/span&gt; Thread(countDownLatch::countDown);&lt;br/&gt;        Thread 铠 = &lt;span&gt;new&lt;/span&gt; Thread(() -&amp;gt; {&lt;br/&gt;            &lt;span&gt;try&lt;/span&gt; {&lt;br/&gt;                &lt;span&gt;// 稍等，上个卫生间，马上到...&lt;/span&gt;&lt;br/&gt;                Thread.sleep(&lt;span&gt;1500&lt;/span&gt;);&lt;br/&gt;                countDownLatch.countDown();&lt;br/&gt;            } &lt;span&gt;catch&lt;/span&gt; (InterruptedException ignored) {}&lt;br/&gt;        });&lt;br/&gt;&lt;br/&gt;        大乔.start();&lt;br/&gt;        兰陵王.start();&lt;br/&gt;        安其拉.start();&lt;br/&gt;        哪吒.start();&lt;br/&gt;        铠.start();&lt;br/&gt;        countDownLatch.await();&lt;br/&gt;        System.out.println(&lt;span&gt;&quot;所有玩家已经就位！&quot;&lt;/span&gt;);&lt;br/&gt;    }&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;场景2. 协调子线程开始动作：统一各线程动作开始的时机&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;王者游戏中也有类似的场景，游戏开始时，各玩家的初始状态必须一致。不能有的玩家都出完装了，有的才降生。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以大家得一块出生，在&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-type=&quot;jpeg&quot; data-ratio=&quot;0.462037037037037&quot; data-w=&quot;1080&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/PMZOEonJxWcMxSzU05DWGIZ1b1icvRXTS5ibDQ2dibUe6icuZLpE6FxA33gtJ4f86g1BgCSOiaDHl5hwEO29gXOJhBA/640?wx_fmt=jpeg&quot;/&gt;&lt;figcaption&gt;王者荣耀-来源参考[18]&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在这个场景中，仍然用五个线程代表大乔、兰陵王、安其拉、哪吒和铠等五个玩家。需要注意的是，各玩家虽然都调用了&lt;code&gt;start()&lt;/code&gt;线程，但是它们在运行时都在等待&lt;code&gt;countDownLatch&lt;/code&gt;的信号，在信号未收到前，它们不会往下执行。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;(String[] args)&lt;/span&gt; &lt;span&gt;throws&lt;/span&gt; InterruptedException &lt;/span&gt;{&lt;br/&gt;        CountDownLatch countDownLatch = &lt;span&gt;new&lt;/span&gt; CountDownLatch(&lt;span&gt;1&lt;/span&gt;);&lt;br/&gt;&lt;br/&gt;        Thread 大乔 = &lt;span&gt;new&lt;/span&gt; Thread(() -&amp;gt; waitToFight(countDownLatch));&lt;br/&gt;        Thread 兰陵王 = &lt;span&gt;new&lt;/span&gt; Thread(() -&amp;gt; waitToFight(countDownLatch));&lt;br/&gt;        Thread 安其拉 = &lt;span&gt;new&lt;/span&gt; Thread(() -&amp;gt; waitToFight(countDownLatch));&lt;br/&gt;        Thread 哪吒 = &lt;span&gt;new&lt;/span&gt; Thread(() -&amp;gt; waitToFight(countDownLatch));&lt;br/&gt;        Thread 铠 = &lt;span&gt;new&lt;/span&gt; Thread(() -&amp;gt; waitToFight(countDownLatch));&lt;br/&gt;&lt;br/&gt;        大乔.start();&lt;br/&gt;        兰陵王.start();&lt;br/&gt;        安其拉.start();&lt;br/&gt;        哪吒.start();&lt;br/&gt;        铠.start();&lt;br/&gt;        Thread.sleep(&lt;span&gt;1000&lt;/span&gt;);&lt;br/&gt;        countDownLatch.countDown();&lt;br/&gt;        System.out.println(&lt;span&gt;&quot;敌方还有5秒达到战场，全军出击！&quot;&lt;/span&gt;);&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;waitToFight&lt;/span&gt;&lt;span&gt;(CountDownLatch countDownLatch)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;try&lt;/span&gt; {&lt;br/&gt;            countDownLatch.await(); &lt;span&gt;// 在此等待信号再继续&lt;/span&gt;&lt;br/&gt;            System.out.println(&lt;span&gt;&quot;收到，发起进攻！&quot;&lt;/span&gt;);&lt;br/&gt;        } &lt;span&gt;catch&lt;/span&gt; (InterruptedException e) {&lt;br/&gt;            e.printStackTrace();&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;CountDownLatch的&lt;strong&gt;核心方法&lt;/strong&gt;也不多：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;await()&lt;/code&gt;：等待latch降为0；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;boolean await(long timeout, TimeUnit unit)&lt;/code&gt;：等待latch降为0，但是可以设置超时时间。比如有玩家超时未确认，那就重新匹配，总不能为了某个玩家等到天荒地老。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;countDown()&lt;/code&gt;：latch数量减1；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;getCount()&lt;/code&gt;：获取当前的latch数量。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;40.CyclicBarrier（同步屏障）了解吗？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;CyclicBarrier的字面意思是可循环使用（Cyclic）的屏障（Barrier）。它要做的事情是，让一 组线程到达一个屏障（也可以叫同步点）时被阻塞，直到最后一个线程到达屏障时，屏障才会开门，所有被屏障拦截的线程才会继续运行。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;它和CountDownLatch类似，都可以协调多线程的结束动作，在它们结束后都可以执行特定动作，但是为什么要有CyclicBarrier，自然是它有和CountDownLatch不同的地方。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;不知道你听没听过一个新人UP主小约翰可汗，小约翰生平有两大恨——“想结衣结衣不依,迷爱理爱理不理。”我们来还原一下事情的经过：小约翰在亲政后认识了新垣结衣，于是决定第一次选妃，向结衣表白，等待回应。然而新垣结衣回应嫁给了星野源，小约翰伤心欲绝，发誓生平不娶，突然发现了铃木爱理，于是小约翰决定第二次选妃，求爱理搭理，等待回应。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-type=&quot;png&quot; data-ratio=&quot;0.5009259259259259&quot; data-w=&quot;1080&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWcMxSzU05DWGIZ1b1icvRXTSwJOkr0nM9chATLIqHc3Kx2uzViaulDeWk3mibsmm18gOx4SXSLJzsu0Q/640?wx_fmt=png&quot;/&gt;&lt;figcaption&gt;想结衣结衣不依,迷爱理爱理不理。&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们拿代码模拟这一场景，发现CountDownLatch无能为力了，因为CountDownLatch的使用是一次性的，无法重复利用，而这里等待了两次。此时，我们用CyclicBarrier就可以实现，因为它可以重复利用。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-type=&quot;png&quot; data-ratio=&quot;1.2722222222222221&quot; data-w=&quot;1080&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWcMxSzU05DWGIZ1b1icvRXTSHRdvLYeibZpliby0H0hu1h1PCRRlCyS7oECAVv2YDPDH77RGiaRWMESJw/640?wx_fmt=png&quot;/&gt;&lt;figcaption&gt;小约翰可汗选妃模拟代码&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;运行结果：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-type=&quot;png&quot; data-ratio=&quot;0.6259259259259259&quot; data-w=&quot;1080&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWcMxSzU05DWGIZ1b1icvRXTSvgPTibpiaM3TBarbGDCRo20hXlQEulasJQj6CHHWP8yP6I1BibVylAqQQ/640?wx_fmt=png&quot;/&gt;&lt;figcaption&gt;运行结果&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;CyclicBarrier最最核心的方法，仍然是await()：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;如果当前线程不是第一个到达屏障的话，它将会进入等待，直到其他线程都到达，除非发生&lt;strong&gt;被中断&lt;/strong&gt;、&lt;strong&gt;屏障被拆除&lt;/strong&gt;、&lt;strong&gt;屏障被重设&lt;/strong&gt;等情况；&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上面的例子抽象一下，本质上它的流程就是这样就是这样：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-type=&quot;png&quot; data-ratio=&quot;0.40555555555555556&quot; data-w=&quot;1080&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWcMxSzU05DWGIZ1b1icvRXTSTv4BWvMFc29kVvm9L8UcuZ2AL8EiauGxSV4TJbht7b3lhkLqibC8S6WA/640?wx_fmt=png&quot;/&gt;&lt;figcaption&gt;CyclicBarrier工作流程&lt;/figcaption&gt;&lt;/figure&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;41.CyclicBarrier和CountDownLatch有什么区别？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;两者最核心的区别[18]：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;CountDownLatch是一次性的，而CyclicBarrier则可以多次设置屏障，实现重复利用；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;CountDownLatch中的各个子线程不可以等待其他线程，只能完成自己的任务；而CyclicBarrier中的各个线程可以等待其他线程&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;它们区别用一个表格整理：&lt;/p&gt;&lt;section data-tool=&quot;mdnice编辑器&quot;&gt;&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;CyclicBarrier&lt;/th&gt;&lt;th&gt;CountDownLatch&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;CyclicBarrier是可重用的，其中的线程会等待所有的线程完成任务。届时，屏障将被拆除，并可以选择性地做一些特定的动作。&lt;/td&gt;&lt;td&gt;CountDownLatch是一次性的，不同的线程在同一个计数器上工作，直到计数器为0.&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;CyclicBarrier面向的是线程数&lt;/td&gt;&lt;td&gt;CountDownLatch面向的是任务数&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;在使用CyclicBarrier时，你必须在构造中指定参与协作的线程数，这些线程必须调用await()方法&lt;/td&gt;&lt;td&gt;使用CountDownLatch时，则必须要指定任务数，至于这些任务由哪些线程完成无关紧要&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;CyclicBarrier可以在所有的线程释放后重新使用&lt;/td&gt;&lt;td&gt;CountDownLatch在计数器为0时不能再使用&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;在CyclicBarrier中，如果某个线程遇到了中断、超时等问题时，则处于await的线程都会出现问题&lt;/td&gt;&lt;td&gt;在CountDownLatch中，如果某个线程出现问题，其他线程不受影响&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/section&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;42.Semaphore（信号量）了解吗？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Semaphore（信号量）是用来控制同时访问特定资源的线程数量，它通过协调各个线程，以保证合理的使用公共资源。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;听起来似乎很抽象，现在汽车多了，开车出门在外的一个老大难问题就是停车 。停车场的车位是有限的，只能允许若干车辆停泊，如果停车场还有空位，那么显示牌显示的就是绿灯和剩余的车位，车辆就可以驶入；如果停车场没位了，那么显示牌显示的就是绿灯和数字0，车辆就得等待。如果满了的停车场有车离开，那么显示牌就又变绿，显示空车位数量，等待的车辆就能进停车场。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-type=&quot;jpeg&quot; data-ratio=&quot;0.8613518197573656&quot; data-w=&quot;577&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/PMZOEonJxWcMxSzU05DWGIZ1b1icvRXTSwY9aohegYwwHF0CEfDEPSLu1W083XZxJ3SibjK9FMLmXicEib480apbYw/640?wx_fmt=jpeg&quot;/&gt;&lt;figcaption&gt;停车场空闲车位提示-图片来源网络&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们把这个例子类比一下，车辆就是线程，进入停车场就是线程在执行，离开停车场就是线程执行完毕，看见红灯就表示线程被阻塞，不能执行，Semaphore的本质就是&lt;strong&gt;协调多个线程对共享资源的获取&lt;/strong&gt;。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-type=&quot;jpeg&quot; data-ratio=&quot;0.6240740740740741&quot; data-w=&quot;1080&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/PMZOEonJxWcMxSzU05DWGIZ1b1icvRXTSdbG4FgP1SvkcndmuCC0qznN86KtYm62Gia2JLBI0ncbadspaAFfBCOw/640?wx_fmt=jpeg&quot;/&gt;&lt;figcaption&gt;Semaphore许可获取-来源参考[18]&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们再来看一个Semaphore的用途：它可以用于做流量控制，特别是公用资源有限的应用场景，比如数据库连接。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;假如有一个需求，要读取几万个文件的数据，因为都是IO密集型任务，我们可以启动几十个线程并发地读取，但是如果读到内存后，还需要存储到数据库中，而数据库的连接数只有10个，这时我们必须控制只有10个线程同时获取数据库连接保存数据，否则会报错无法获取数据库连接。这个时候，就可以使用Semaphore来做流量控制，如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;SemaphoreTest&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; THREAD_COUNT = &lt;span&gt;30&lt;/span&gt;;&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; ExecutorService threadPool = Executors.newFixedThreadPool(THREAD_COUNT);&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; Semaphore s = &lt;span&gt;new&lt;/span&gt; Semaphore(&lt;span&gt;10&lt;/span&gt;);&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;(String[] args)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; THREAD_COUNT; i++) {&lt;br/&gt;            threadPool.execute(&lt;span&gt;new&lt;/span&gt; Runnable() {&lt;br/&gt;                &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;                &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;run&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;                    &lt;span&gt;try&lt;/span&gt; {&lt;br/&gt;                        s.acquire();&lt;br/&gt;                        System.out.println(&lt;span&gt;&quot;save data&quot;&lt;/span&gt;);&lt;br/&gt;                        s.release();&lt;br/&gt;                    } &lt;span&gt;catch&lt;/span&gt; (InterruptedException e) {&lt;br/&gt;                    }&lt;br/&gt;                }&lt;br/&gt;            });&lt;br/&gt;        }&lt;br/&gt;        threadPool.shutdown();&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在代码中，虽然有30个线程在执行，但是只允许10个并发执行。Semaphore的构造方法&lt;code&gt;Semaphore（int permits&lt;/code&gt;）接受一个整型的数字，表示可用的许可证数量。&lt;code&gt;Semaphore（10）&lt;/code&gt;表示允许10个线程获取许可证，也就是最大并发数是10。Semaphore的用法也很简单，首先线程使用 Semaphore的acquire()方法获取一个许可证，使用完之后调用release()方法归还许可证。还可以用tryAcquire()方法尝试获取许可证。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;43.Exchanger 了解吗？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Exchanger（交换者）是一个用于线程间协作的工具类。Exchanger用于进行线程间的数据交换。它提供一个同步点，在这个同步点，两个线程可以交换彼此的数据。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-type=&quot;jpeg&quot; data-ratio=&quot;0.34629629629629627&quot; data-w=&quot;1080&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/PMZOEonJxWcMxSzU05DWGIZ1b1icvRXTSjKoOWuWQEY5yjvDU7GY5lUTia7rd8xUD90pULvzAS2KarJeBCRs2FRQ/640?wx_fmt=jpeg&quot;/&gt;&lt;figcaption&gt;英雄交换猎物-来源参考[18]&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这两个线程通过 exchange方法交换数据，如果第一个线程先执行exchange()方法，它会一直等待第二个线程也执行exchange方法，当两个线程都到达同步点时，这两个线程就可以交换数据，将本线程生产出来的数据传递给对方。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Exchanger可以用于遗传算法，遗传算法里需要选出两个人作为交配对象，这时候会交换两人的数据，并使用交叉规则得出2个交配结果。Exchanger也可以用于校对工作，比如我们需要将纸制银行流水通过人工的方式录入成电子银行流水，为了避免错误，采用AB岗两人进行录入，录入到Excel之后，系统需要加载这两个Excel，并对两个Excel数据进行校对，看看是否录入一致。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;ExchangerTest&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; Exchanger&amp;lt;String&amp;gt; exgr = &lt;span&gt;new&lt;/span&gt; Exchanger&amp;lt;String&amp;gt;();&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; ExecutorService threadPool = Executors.newFixedThreadPool(&lt;span&gt;2&lt;/span&gt;);&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;(String[] args)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        threadPool.execute(&lt;span&gt;new&lt;/span&gt; Runnable() {&lt;br/&gt;            &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;run&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;                &lt;span&gt;try&lt;/span&gt; {&lt;br/&gt;                    String A = &lt;span&gt;&quot;银行流水A&quot;&lt;/span&gt;; &lt;span&gt;// A录入银行流水数据 &lt;/span&gt;&lt;br/&gt;                    exgr.exchange(A);&lt;br/&gt;                } &lt;span&gt;catch&lt;/span&gt; (InterruptedException e) {&lt;br/&gt;                }&lt;br/&gt;            }&lt;br/&gt;        });&lt;br/&gt;        threadPool.execute(&lt;span&gt;new&lt;/span&gt; Runnable() {&lt;br/&gt;            &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;run&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;                &lt;span&gt;try&lt;/span&gt; {&lt;br/&gt;                    String B = &lt;span&gt;&quot;银行流水B&quot;&lt;/span&gt;; &lt;span&gt;// B录入银行流水数据 &lt;/span&gt;&lt;br/&gt;                    String A = exgr.exchange(&lt;span&gt;&quot;B&quot;&lt;/span&gt;);&lt;br/&gt;                    System.out.println(&lt;span&gt;&quot;A和B数据是否一致：&quot;&lt;/span&gt; + A.equals(B) + &lt;span&gt;&quot;，A录入的是：&quot;&lt;/span&gt;&lt;br/&gt;                            + A + &lt;span&gt;&quot;，B录入是：&quot;&lt;/span&gt; + B);&lt;br/&gt;                } &lt;span&gt;catch&lt;/span&gt; (InterruptedException e) {&lt;br/&gt;                }&lt;br/&gt;            }&lt;br/&gt;        });&lt;br/&gt;        threadPool.shutdown();&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;假如两个线程有一个没有执行exchange()方法，则会一直等待，如果担心有特殊情况发生，避免一直等待，可以使用&lt;code&gt;exchange(V x, long timeOut, TimeUnit unit)&lt;/code&gt;设置最大等待时长。&lt;/p&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;线程池&lt;/span&gt;&lt;/h1&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;44.什么是线程池？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;线程池：&lt;/strong&gt; 简单理解，它就是一个管理线程的池子。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-type=&quot;png&quot; data-ratio=&quot;0.3867595818815331&quot; data-w=&quot;574&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWcMxSzU05DWGIZ1b1icvRXTSf2k5phoelUUlI70EgtQd1y511gbMT2dHibsoT2AWrxicQvEj4JK4f7hA/640?wx_fmt=png&quot;/&gt;&lt;figcaption&gt;管理线程的池子&lt;/figcaption&gt;&lt;/figure&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;它帮我们管理线程，避免增加创建线程和销毁线程的资源损耗&lt;/strong&gt;。因为线程其实也是一个对象，创建一个对象，需要经过类加载过程，销毁一个对象，需要走GC垃圾回收流程，都是需要资源开销的。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;提高响应速度。&lt;/strong&gt; 如果任务到达了，相对于从线程池拿线程，重新去创建一条线程执行，速度肯定慢很多。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;重复利用。&lt;/strong&gt; 线程用完，再放回池子，可以达到重复利用的效果，节省资源。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;45.能说说工作中线程池的应用吗？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;之前我们有一个和第三方对接的需求，需要向第三方推送数据，引入了多线程来提升数据推送的效率，其中用到了线程池来管理线程。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-type=&quot;png&quot; data-ratio=&quot;0.33366141732283466&quot; data-w=&quot;1016&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWcMxSzU05DWGIZ1b1icvRXTSus2LEXwloZbsTicqwu3iaSnkicgOb9GCM00Du50GkZ6IIicG1C8fMppOPA/640?wx_fmt=png&quot;/&gt;&lt;figcaption&gt;业务示例&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;主要代码如下：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1.9267578125&quot; data-type=&quot;png&quot; data-w=&quot;2048&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWcMxSzU05DWGIZ1b1icvRXTSfo2EaKMOdxA6kFLib00aJjkXhVow9WibVZlk5rDtFXXb8DPpguXyVKeA/640?wx_fmt=png&quot;/&gt;&lt;figcaption&gt;主要代码&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;完整可运行代码地址：https://gitee.com/fighter3/thread-demo.git&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;线程池的参数如下：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;corePoolSize：线程核心参数选择了CPU数×2&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;maximumPoolSize：最大线程数选择了和核心线程数相同&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;keepAliveTime：非核心闲置线程存活时间直接置为0&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;unit：非核心线程保持存活的时间选择了 TimeUnit.SECONDS 秒&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;workQueue：线程池等待队列，使用 LinkedBlockingQueue阻塞队列&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;同时还用了synchronized 来加锁，保证数据不会被重复推送：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;  &lt;span&gt;synchronized&lt;/span&gt; (PushProcessServiceImpl&lt;span&gt;.&lt;span&gt;class&lt;/span&gt;) &lt;/span&gt;{}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;ps:这个例子只是简单地进行了数据推送，实际上还可以结合其他的业务，像什么数据清洗啊、数据统计啊，都可以套用。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;46.能简单说一下线程池的工作流程吗？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;用一个通俗的比喻：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;有一个营业厅，总共有六个窗口，现在开放了三个窗口，现在有三个窗口坐着三个营业员小姐姐在营业。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;老三去办业务，可能会遇到什么情况呢？&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;老三发现有空间的在营业的窗口，直接去找小姐姐办理业务。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-type=&quot;png&quot; data-ratio=&quot;0.28717201166180756&quot; data-w=&quot;686&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWcMxSzU05DWGIZ1b1icvRXTSjpvyfZib7ew5ZVdU4sdQZkj8rxzXxO5mCMw17VvoCd3bibYzpYq29SCg/640?wx_fmt=png&quot;/&gt;&lt;figcaption&gt;直接办理&lt;/figcaption&gt;&lt;/figure&gt;&lt;ol start=&quot;2&quot; data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;老三发现没有空闲的窗口，就在排队区排队等。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-type=&quot;png&quot; data-ratio=&quot;0.32954545454545453&quot; data-w=&quot;704&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWcMxSzU05DWGIZ1b1icvRXTSic6ichibZ4noB72VhkLQNNaUZbfuTa2fwcDEZVahvk1dcC7pVMibKnI9CA/640?wx_fmt=png&quot;/&gt;&lt;figcaption&gt;排队等待&lt;/figcaption&gt;&lt;/figure&gt;&lt;ol start=&quot;3&quot; data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;老三发现没有空闲的窗口，等待区也满了，蚌埠住了，经理一看，就让休息的小姐姐赶紧回来上班，等待区号靠前的赶紧去新窗口办，老三去排队区排队。小姐姐比较辛苦，假如一段时间发现他们可以不用接着营业，经理就让她们接着休息。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-type=&quot;png&quot; data-ratio=&quot;0.4326424870466321&quot; data-w=&quot;772&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWcMxSzU05DWGIZ1b1icvRXTSPzDkc95d4iaibp28VMlfdEibFLCngcsMmgEWiaXZ1n4lYZ3ngPDnqHjicLg/640?wx_fmt=png&quot;/&gt;&lt;figcaption&gt;排队区满&lt;/figcaption&gt;&lt;/figure&gt;&lt;ol start=&quot;4&quot; data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;老三一看，六个窗口都满了，等待区也没位置了。老三急了，要闹，经理赶紧出来了，经理该怎么办呢？&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-type=&quot;png&quot; data-ratio=&quot;0.40234375&quot; data-w=&quot;768&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWcMxSzU05DWGIZ1b1icvRXTS1ehibUjaq5qHicxgMjd9CZbd7Q4dZuGKNUwl5gnQgC3mbqSVNMQ9z2Rw/640?wx_fmt=png&quot;/&gt;&lt;figcaption&gt;等待区，排队区都满&lt;/figcaption&gt;&lt;/figure&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;ol class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;我们银行系统已经瘫痪&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;谁叫你来办的你找谁去&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;看你比较急，去队里加个塞&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;今天没办法，不行你看改一天&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上面的这个流程几乎就跟 JDK 线程池的大致流程类似，&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;ol class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;营业中的 3个窗口对应核心线程池数：corePoolSize&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;总的营业窗口数6对应：maximumPoolSize&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;打开的临时窗口在多少时间内无人办理则关闭对应：unit&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;排队区就是等待队列：workQueue&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;无法办理的时候银行给出的解决方法对应：RejectedExecutionHandler&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;threadFactory 该参数在 JDK 中是 线程工厂，用来创建线程对象，一般不会动。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以我们线程池的工作流程也比较好理解了：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;线程池刚创建时，里面没有一个线程。任务队列是作为参数传进来的。不过，就算队列里面有任务，线程池也不会马上执行它们。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;当调用 execute() 方法添加一个任务时，线程池会做如下判断：&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;如果正在运行的线程数量小于 corePoolSize，那么马上创建线程运行这个任务；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;如果正在运行的线程数量大于或等于 corePoolSize，那么将这个任务放入队列；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;如果这时候队列满了，而且正在运行的线程数量小于 maximumPoolSize，那么还是要创建非核心线程立刻运行这个任务；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;如果队列满了，而且正在运行的线程数量大于或等于 maximumPoolSize，那么线程池会根据拒绝策略来对应处理。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-type=&quot;png&quot; data-ratio=&quot;0.6517482517482518&quot; data-w=&quot;715&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWcMxSzU05DWGIZ1b1icvRXTSibgvbJBh08S7ZeC4ULW8dRucYedq5XCGW0dicJMw5m12561icGetUb2xQ/640?wx_fmt=png&quot;/&gt;&lt;figcaption&gt;线程池执行流程&lt;/figcaption&gt;&lt;/figure&gt;&lt;ol start=&quot;3&quot; data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;当一个线程完成任务时，它会从队列中取下一个任务来执行。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;当一个线程无事可做，超过一定的时间（keepAliveTime）时，线程池会判断，如果当前运行的线程数大于 corePoolSize，那么这个线程就被停掉。所以线程池的所有任务完成后，它最终会收缩到 corePoolSize 的大小。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;47.线程池主要参数有哪些？&lt;/span&gt;&lt;/h2&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.7838874680306905&quot; data-type=&quot;png&quot; data-w=&quot;782&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWcMxSzU05DWGIZ1b1icvRXTSpl3zNLric81KibgVWibibDkrjusELR26w8EmFsUm6tSWgAb8KicmXulBMPQ/640?wx_fmt=png&quot;/&gt;&lt;figcaption&gt;线程池参数&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;线程池有七大参数，需要重点关注&lt;code&gt;corePoolSize&lt;/code&gt;、&lt;code&gt;maximumPoolSize&lt;/code&gt;、&lt;code&gt;workQueue&lt;/code&gt;、&lt;code&gt;handler&lt;/code&gt;这四个。&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;corePoolSize&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;此值是用来初始化线程池中核心线程数，当线程池中线程池数&amp;lt; &lt;code&gt;corePoolSize&lt;/code&gt;时，系统默认是添加一个任务才创建一个线程池。当线程数 = corePoolSize时，新任务会追加到workQueue中。&lt;/p&gt;&lt;ol start=&quot;2&quot; data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;maximumPoolSize&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;maximumPoolSize&lt;/code&gt;表示允许的最大线程数 = (非核心线程数+核心线程数)，当&lt;code&gt;BlockingQueue&lt;/code&gt;也满了，但线程池中总线程数 &amp;lt; &lt;code&gt;maximumPoolSize&lt;/code&gt;时候就会再次创建新的线程。&lt;/p&gt;&lt;ol start=&quot;3&quot; data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;keepAliveTime&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;非核心线程 =(maximumPoolSize - corePoolSize ) ,非核心线程闲置下来不干活最多存活时间。&lt;/p&gt;&lt;ol start=&quot;4&quot; data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;unit&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;线程池中非核心线程保持存活的时间的单位&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;TimeUnit.DAYS;天&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;TimeUnit.HOURS;小时&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;TimeUnit.MINUTES;分钟&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;TimeUnit.SECONDS;秒&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;TimeUnit.MILLISECONDS;  毫秒&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;TimeUnit.MICROSECONDS;  微秒&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;TimeUnit.NANOSECONDS;  纳秒&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;ol start=&quot;5&quot; data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;workQueue&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;线程池等待队列，维护着等待执行的&lt;code&gt;Runnable&lt;/code&gt;对象。当运行当线程数= corePoolSize时，新的任务会被添加到&lt;code&gt;workQueue&lt;/code&gt;中，如果&lt;code&gt;workQueue&lt;/code&gt;也满了则尝试用非核心线程执行任务，等待队列应该尽量用有界的。&lt;/p&gt;&lt;ol start=&quot;6&quot; data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;threadFactory&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;创建一个新线程时使用的工厂，可以用来设定线程名、是否为daemon线程等等。&lt;/p&gt;&lt;ol start=&quot;7&quot; data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;handler&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;corePoolSize&lt;/code&gt;、&lt;code&gt;workQueue&lt;/code&gt;、&lt;code&gt;maximumPoolSize&lt;/code&gt;都不可用的时候执行的饱和策略。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;48.线程池的拒绝策略有哪些？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;类比前面的例子，无法办理业务时的处理方式，帮助记忆：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.9244992295839753&quot; data-type=&quot;png&quot; data-w=&quot;649&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWcMxSzU05DWGIZ1b1icvRXTSEialhu9UoRSTBT2grUaJdmGflo3ORHhHEE2pQZptibgqDjAg8nJxrq2g/640?wx_fmt=png&quot;/&gt;&lt;figcaption&gt;四种策略&lt;/figcaption&gt;&lt;/figure&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;AbortPolicy ：直接抛出异常，默认使用此策略&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;CallerRunsPolicy：用调用者所在的线程来执行任务&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;DiscardOldestPolicy：丢弃阻塞队列里最老的任务，也就是队列里靠前的任务&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;DiscardPolicy ：当前任务直接丢弃&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;想实现自己的拒绝策略，实现RejectedExecutionHandler接口即可。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;49.线程池有哪几种工作队列？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;常用的阻塞队列主要有以下几种：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.48073022312373226&quot; data-type=&quot;png&quot; data-w=&quot;986&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWcMxSzU05DWGIZ1b1icvRXTSPNoYnf7B8TtrxRXCOfgkLXxmKEuqqfuJZKVPArLOJCIrLgLUxmuIWA/640?wx_fmt=png&quot;/&gt;&lt;figcaption&gt;线程池常用阻塞队列&lt;/figcaption&gt;&lt;/figure&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;ArrayBlockingQueue：ArrayBlockingQueue（有界队列）是一个用数组实现的有界阻塞队列，按FIFO排序量。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;LinkedBlockingQueue：LinkedBlockingQueue（可设置容量队列）是基于链表结构的阻塞队列，按FIFO排序任务，容量可以选择进行设置，不设置的话，将是一个无边界的阻塞队列，最大长度为Integer.MAX_VALUE，吞吐量通常要高于ArrayBlockingQuene；newFixedThreadPool线程池使用了这个队列&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;DelayQueue：DelayQueue（延迟队列）是一个任务定时周期的延迟执行的队列。根据指定的执行时间从小到大排序，否则根据插入到队列的先后排序。newScheduledThreadPool线程池使用了这个队列。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;PriorityBlockingQueue：PriorityBlockingQueue（优先级队列）是具有优先级的无界阻塞队列&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;SynchronousQueue：SynchronousQueue（同步队列）是一个不存储元素的阻塞队列，每个插入操作必须等到另一个线程调用移除操作，否则插入操作一直处于阻塞状态，吞吐量通常要高于LinkedBlockingQuene，newCachedThreadPool线程池使用了这个队列。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;50.线程池提交execute和submit有什么区别？&lt;/span&gt;&lt;/h2&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;execute 用于提交不需要返回值的任务&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;threadsPool.execute(&lt;span&gt;new&lt;/span&gt; Runnable() { &lt;br/&gt;    &lt;span&gt;@Override&lt;/span&gt; &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;run&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{ &lt;br/&gt;        &lt;span&gt;// TODO Auto-generated method stub } &lt;/span&gt;&lt;br/&gt;    });&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;ol start=&quot;2&quot; data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;submit()方法用于提交需要返回值的任务。线程池会返回一个future类型的对象，通过这个 future对象可以判断任务是否执行成功，并且可以通过future的get()方法来获取返回值&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;Future&amp;lt;Object&amp;gt; future = executor.submit(harReturnValuetask); &lt;br/&gt;&lt;span&gt;try&lt;/span&gt; { Object s = future.get(); } &lt;span&gt;catch&lt;/span&gt; (InterruptedException e) { &lt;br/&gt;    &lt;span&gt;// 处理中断异常 &lt;/span&gt;&lt;br/&gt;} &lt;span&gt;catch&lt;/span&gt; (ExecutionException e) { &lt;br/&gt;    &lt;span&gt;// 处理无法执行任务异常 &lt;/span&gt;&lt;br/&gt;} &lt;span&gt;finally&lt;/span&gt; { &lt;br/&gt;    &lt;span&gt;// 关闭线程池 executor.shutdown();&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;51.线程池怎么关闭知道吗？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可以通过调用线程池的&lt;code&gt;shutdown&lt;/code&gt;或&lt;code&gt;shutdownNow&lt;/code&gt;方法来关闭线程池。它们的原理是遍历线程池中的工作线程，然后逐个调用线程的interrupt方法来中断线程，所以无法响应中断的任务可能永远无法终止。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;shutdown() 将线程池状态置为shutdown,并不会立即停止&lt;/strong&gt;：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;停止接收外部submit的任务&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;内部正在跑的任务和队列里等待的任务，会执行完&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;等到第二步完成后，才真正停止&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;shutdownNow() 将线程池状态置为stop。一般会立即停止，事实上不一定&lt;/strong&gt;：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;和shutdown()一样，先停止接收外部提交的任务&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;忽略队列里等待的任务&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;尝试将正在跑的任务interrupt中断&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;返回未执行的任务列表&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;shutdown 和shutdownnow简单来说区别如下：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;shutdownNow()能立即停止线程池，正在跑的和正在等待的任务都停下了。这样做立即生效，但是风险也比较大。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;shutdown()只是关闭了提交通道，用submit()是无效的；而内部的任务该怎么跑还是怎么跑，跑完再彻底停止线程池。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;52.线程池的线程数应该怎么配置？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;线程在Java中属于稀缺资源，线程池不是越大越好也不是越小越好。任务分为计算密集型、IO密集型、混合型。&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;计算密集型：大部分都在用CPU跟内存，加密，逻辑操作业务处理等。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;IO密集型：数据库链接，网络通讯传输等。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5944444444444444&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWcMxSzU05DWGIZ1b1icvRXTS911XXzD3vbwfoTaWB8BduS0zvR0ky7JFAFlia3eHgwpTq7dTj2alMcQ/640?wx_fmt=png&quot;/&gt;&lt;figcaption&gt;常见线程池参数配置方案-来源美团技术博客&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;一般的经验，不同类型线程池的参数配置：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;计算密集型一般推荐线程池不要过大，一般是CPU数 + 1，+1是因为可能存在&lt;strong&gt;页缺失&lt;/strong&gt;(就是可能存在有些数据在硬盘中需要多来一个线程将数据读入内存)。如果线程池数太大，可能会频繁的 进行线程上下文切换跟任务调度。获得当前CPU核心数代码如下：&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;Runtime.getRuntime().availableProcessors();&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;ol start=&quot;2&quot; data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;IO密集型：线程数适当大一点，机器的Cpu核心数*2。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;混合型：可以考虑根绝情况将它拆分成CPU密集型和IO密集型任务，如果执行时间相差不大，拆分可以提升吞吐量，反之没有必要。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当然，实际应用中没有固定的公式，需要结合测试和监控来进行调整。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;53.有哪几种常见的线程池？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;面试常问，主要有四种，都是通过工具类Excutors创建出来的，需要注意，阿里巴巴《Java开发手册》里禁止使用这种方式来创建线程池。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.4021505376344086&quot; data-type=&quot;png&quot; data-w=&quot;930&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWcMxSzU05DWGIZ1b1icvRXTSndSYswbkly8nx1qibaD0AtnyjnxUypp15Cyf5ibJssbkYB8TXHPFf8NQ/640?wx_fmt=png&quot;/&gt;&lt;figcaption&gt;四大线程池&lt;/figcaption&gt;&lt;/figure&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;newFixedThreadPool  (固定数目线程的线程池)&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;newCachedThreadPool (可缓存线程的线程池)&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;newSingleThreadExecutor (单线程的线程池)&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;newScheduledThreadPool (定时及周期执行的线程池)&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;54.能说一下四种常见线程池的原理吗？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;前三种线程池的构造直接调用ThreadPoolExecutor的构造方法。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;newSingleThreadExecutor&lt;/span&gt;&lt;/h3&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;  &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; ExecutorService &lt;span&gt;newSingleThreadExecutor&lt;/span&gt;&lt;span&gt;(ThreadFactory threadFactory)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; FinalizableDelegatedExecutorService&lt;br/&gt;            (&lt;span&gt;new&lt;/span&gt; ThreadPoolExecutor(&lt;span&gt;1&lt;/span&gt;, &lt;span&gt;1&lt;/span&gt;,&lt;br/&gt;                                    &lt;span&gt;0L&lt;/span&gt;, TimeUnit.MILLISECONDS,&lt;br/&gt;                                    &lt;span&gt;new&lt;/span&gt; LinkedBlockingQueue&amp;lt;Runnable&amp;gt;(),&lt;br/&gt;                                    threadFactory));&lt;br/&gt;    }&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;线程池特点&lt;/strong&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;核心线程数为1&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;最大线程数也为1&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;阻塞队列是无界队列LinkedBlockingQueue，可能会导致OOM&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;keepAliveTime为0&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.46943231441048033&quot; data-type=&quot;png&quot; data-w=&quot;916&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWcMxSzU05DWGIZ1b1icvRXTSoPO2yic7w1Pupakc9GeQzCw0mkURCNHptnmRE3vfiaVQLTyIicnbAUIgA/640?wx_fmt=png&quot;/&gt;&lt;figcaption&gt;SingleThreadExecutor运行流程&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;工作流程：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;提交任务&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;线程池是否有一条线程在，如果没有，新建线程执行任务&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;如果有，将任务加到阻塞队列&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;当前的唯一线程，从队列取任务，执行完一个，再继续取，一个线程执行任务。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;适用场景&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;适用于串行执行任务的场景，一个任务一个任务地执行。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;newFixedThreadPool&lt;/span&gt;&lt;/h3&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;  &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; ExecutorService &lt;span&gt;newFixedThreadPool&lt;/span&gt;&lt;span&gt;(&lt;span&gt;int&lt;/span&gt; nThreads, ThreadFactory threadFactory)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; ThreadPoolExecutor(nThreads, nThreads,&lt;br/&gt;                                      &lt;span&gt;0L&lt;/span&gt;, TimeUnit.MILLISECONDS,&lt;br/&gt;                                      &lt;span&gt;new&lt;/span&gt; LinkedBlockingQueue&amp;lt;Runnable&amp;gt;(),&lt;br/&gt;                                      threadFactory);&lt;br/&gt;    }&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;线程池特点：&lt;/strong&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;核心线程数和最大线程数大小一样&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;没有所谓的非空闲时间，即keepAliveTime为0&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;阻塞队列为无界队列LinkedBlockingQueue，可能会导致OOM&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-type=&quot;png&quot; data-ratio=&quot;0.5287588294651867&quot; data-w=&quot;991&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWcMxSzU05DWGIZ1b1icvRXTSQQBIZZBy7dwTtTUpmbraicYVEJvbaDsiamZDMuFKY2kTPWcyYOYeBS1g/640?wx_fmt=png&quot;/&gt;&lt;figcaption&gt;FixedThreadPool&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;工作流程：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;提交任务&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;如果线程数少于核心线程，创建核心线程执行任务&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;如果线程数等于核心线程，把任务添加到LinkedBlockingQueue阻塞队列&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;如果线程执行完任务，去阻塞队列取任务，继续执行。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;使用场景&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;FixedThreadPool 适用于处理CPU密集型的任务，确保CPU在长期被工作线程使用的情况下，尽可能的少的分配线程，即适用执行长期的任务。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;newCachedThreadPool&lt;/span&gt;&lt;/h3&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;   &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; ExecutorService &lt;span&gt;newCachedThreadPool&lt;/span&gt;&lt;span&gt;(ThreadFactory threadFactory)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; ThreadPoolExecutor(&lt;span&gt;0&lt;/span&gt;, Integer.MAX_VALUE,&lt;br/&gt;                                      &lt;span&gt;60L&lt;/span&gt;, TimeUnit.SECONDS,&lt;br/&gt;                                      &lt;span&gt;new&lt;/span&gt; SynchronousQueue&amp;lt;Runnable&amp;gt;(),&lt;br/&gt;                                      threadFactory);&lt;br/&gt;    }&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;线程池特点：&lt;/strong&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;核心线程数为0&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;最大线程数为Integer.MAX_VALUE，即无限大，可能会因为无限创建线程，导致OOM&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;阻塞队列是SynchronousQueue&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;非核心线程空闲存活时间为60秒&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当提交任务的速度大于处理任务的速度时，每次提交一个任务，就必然会创建一个线程。极端情况下会创建过多的线程，耗尽 CPU 和内存资源。由于空闲 60 秒的线程会被终止，长时间保持空闲的 CachedThreadPool 不会占用任何资源。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-type=&quot;png&quot; data-ratio=&quot;0.745928338762215&quot; data-w=&quot;921&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWcMxSzU05DWGIZ1b1icvRXTSVC6RoUUiabxbQibKjhtjC6UfvNiawscicuj8MYfmdQlct3enazyicQxzENQ/640?wx_fmt=png&quot;/&gt;&lt;figcaption&gt;CachedThreadPool执行流程&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;工作流程：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;提交任务&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;因为没有核心线程，所以任务直接加到SynchronousQueue队列。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;判断是否有空闲线程，如果有，就去取出任务执行。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;如果没有空闲线程，就新建一个线程执行。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;执行完任务的线程，还可以存活60秒，如果在这期间，接到任务，可以继续活下去；否则，被销毁。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;适用场景&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;用于并发执行大量短期的小任务。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;newScheduledThreadPool&lt;/span&gt;&lt;/h3&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;ScheduledThreadPoolExecutor&lt;/span&gt;&lt;span&gt;(&lt;span&gt;int&lt;/span&gt; corePoolSize)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;super&lt;/span&gt;(corePoolSize, Integer.MAX_VALUE, &lt;span&gt;0&lt;/span&gt;, NANOSECONDS,&lt;br/&gt;              &lt;span&gt;new&lt;/span&gt; DelayedWorkQueue());&lt;br/&gt;    }&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;线程池特点&lt;/strong&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;最大线程数为Integer.MAX_VALUE，也有OOM的风险&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;阻塞队列是DelayedWorkQueue&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;keepAliveTime为0&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;scheduleAtFixedRate() ：按某种速率周期执行&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;scheduleWithFixedDelay()：在某个延迟后执行&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-type=&quot;png&quot; data-ratio=&quot;0.5436991869918699&quot; data-w=&quot;984&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWcMxSzU05DWGIZ1b1icvRXTSpLIibSktN1W8Y63icicLw6WNSlVc3yeFyuibJq7Gkkj4MibxCJ1Qznvwe5Q/640?wx_fmt=png&quot;/&gt;&lt;figcaption&gt;ScheduledThreadPool执行流程&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;工作机制&lt;/strong&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;线程从DelayQueue中获取已到期的ScheduledFutureTask（DelayQueue.take()）。到期任务是指ScheduledFutureTask的time大于等于当前时间。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;线程执行这个ScheduledFutureTask。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;线程修改ScheduledFutureTask的time变量为下次将要被执行的时间。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;线程把这个修改time之后的ScheduledFutureTask放回DelayQueue中（DelayQueue.add()）。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-type=&quot;png&quot; data-ratio=&quot;0.5269978401727862&quot; data-w=&quot;926&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWcMxSzU05DWGIZ1b1icvRXTSgGFneaLl3DOo26lX6mr6PBWGmx6XSFLK5ibzzxf3I2ZsBGuia68awLFg/640?wx_fmt=png&quot;/&gt;&lt;figcaption&gt;ScheduledThreadPoolExecutor执行流程&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;使用场景&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;周期性执行任务的场景，需要限制线程数量的场景&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;使用无界队列的线程池会导致什么问题吗？&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;例如newFixedThreadPool使用了无界的阻塞队列LinkedBlockingQueue，如果线程获取一个任务后，任务的执行时间比较长，会导致队列的任务越积越多，导致机器内存使用不停飙升，最终导致OOM。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;55.线程池异常怎么处理知道吗？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在使用线程池处理任务的时候，任务代码可能抛出RuntimeException，抛出异常后，线程池可能捕获它，也可能创建一个新的线程来代替异常的线程，我们可能无法感知任务出现了异常，因此我们需要考虑线程池异常情况。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;常见的异常处理方式：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-type=&quot;png&quot; data-ratio=&quot;0.7060478199718706&quot; data-w=&quot;711&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWcMxSzU05DWGIZ1b1icvRXTSITic450VQC8zhvBae0x7bLCQU2BlmnEsMe1Ww18Kh4vf0zIVibP6Jr1g/640?wx_fmt=png&quot;/&gt;&lt;figcaption&gt;线程池异常处理&lt;/figcaption&gt;&lt;/figure&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;56.能说一下线程池有几种状态吗？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;线程池有这几个状态：RUNNING,SHUTDOWN,STOP,TIDYING,TERMINATED。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;   &lt;span&gt;//线程池状态&lt;/span&gt;&lt;br/&gt;   &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; RUNNING    = -&lt;span&gt;1&lt;/span&gt; &amp;lt;&amp;lt; COUNT_BITS;&lt;br/&gt;   &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; SHUTDOWN   =  &lt;span&gt;0&lt;/span&gt; &amp;lt;&amp;lt; COUNT_BITS;&lt;br/&gt;   &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; STOP       =  &lt;span&gt;1&lt;/span&gt; &amp;lt;&amp;lt; COUNT_BITS;&lt;br/&gt;   &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; TIDYING    =  &lt;span&gt;2&lt;/span&gt; &amp;lt;&amp;lt; COUNT_BITS;&lt;br/&gt;   &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; TERMINATED =  &lt;span&gt;3&lt;/span&gt; &amp;lt;&amp;lt; COUNT_BITS;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;线程池各个状态切换图：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-type=&quot;png&quot; data-ratio=&quot;0.29161882893226176&quot; data-w=&quot;871&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWcMxSzU05DWGIZ1b1icvRXTSCmytA2eBOib4TUlWRjmQ0WlIHdlH5d0IXHPiae8xHkyVfqF2nImX1zmA/640?wx_fmt=png&quot;/&gt;&lt;figcaption&gt;线程池状态切换图&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;RUNNING&lt;/strong&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;该状态的线程池会接收新任务，并处理阻塞队列中的任务;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;调用线程池的shutdown()方法，可以切换到SHUTDOWN状态;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;调用线程池的shutdownNow()方法，可以切换到STOP状态;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;SHUTDOWN&lt;/strong&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;该状态的线程池不会接收新任务，但会处理阻塞队列中的任务；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;队列为空，并且线程池中执行的任务也为空,进入TIDYING状态;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;STOP&lt;/strong&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;该状态的线程不会接收新任务，也不会处理阻塞队列中的任务，而且会中断正在运行的任务；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;线程池中执行的任务为空,进入TIDYING状态;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;TIDYING&lt;/strong&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;该状态表明所有的任务已经运行终止，记录的任务数量为0。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;terminated()执行完毕，进入TERMINATED状态&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;TERMINATED&lt;/strong&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;57.线程池如何实现参数的动态修改？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;线程池提供了几个  setter方法来设置线程池的参数。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-type=&quot;png&quot; data-ratio=&quot;0.21203703703703702&quot; data-w=&quot;1080&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWcMxSzU05DWGIZ1b1icvRXTSavbupJDShuicur1MP6r55ANkIbmzhkoSYn6yRGOrcrPBExbtd9cgGPw/640?wx_fmt=png&quot;/&gt;&lt;figcaption&gt;JDK 线程池参数设置接口来源参考[7]&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里主要有两个思路：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-type=&quot;png&quot; data-ratio=&quot;0.547798066595059&quot; data-w=&quot;931&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWcMxSzU05DWGIZ1b1icvRXTSLrfjLDicA55ZfCzjAaicbk47vicbGUs88z1U3xD478zQAckYQkGCVtUlQ/640?wx_fmt=png&quot;/&gt;&lt;figcaption&gt;动态修改线程池参数&lt;/figcaption&gt;&lt;/figure&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;在我们微服务的架构下，可以利用配置中心如Nacos、Apollo等等，也可以自己开发配置中心。业务服务读取线程池配置，获取相应的线程池实例来修改线程池的参数。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;如果限制了配置中心的使用，也可以自己去扩展&lt;strong&gt;ThreadPoolExecutor&lt;/strong&gt;，重写方法，监听线程池参数变化，来动态修改线程池参数。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;线程池调优了解吗？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;线程池配置没有固定的公式，通常事前会对线程池进行一定评估，常见的评估方案如下：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-type=&quot;png&quot; data-ratio=&quot;0.5944444444444444&quot; data-w=&quot;1080&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWcMxSzU05DWGIZ1b1icvRXTS911XXzD3vbwfoTaWB8BduS0zvR0ky7JFAFlia3eHgwpTq7dTj2alMcQ/640?wx_fmt=png&quot;/&gt;&lt;figcaption&gt;线程池评估方案 来源参考[7]&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上线之前也要进行充分的测试，上线之后要建立完善的线程池监控机制。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;事中结合监控告警机制，分析线程池的问题，或者可优化点，结合线程池动态参数配置机制来调整配置。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;事后要注意仔细观察，随时调整。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-type=&quot;png&quot; data-ratio=&quot;0.3566333808844508&quot; data-w=&quot;701&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWcMxSzU05DWGIZ1b1icvRXTSjlUdjTG0hA2bQABkZ1KFYK5RUfrumweRprdxzwErgJrTMYNHJnx46g/640?wx_fmt=png&quot;/&gt;&lt;figcaption&gt;线程池调优&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;具体的调优案例可以查看参考[7]美团技术博客。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;58.你能设计实现一个线程池吗？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;⭐这道题在阿里的面试中出现频率比较高&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;线程池实现原理可以查看 &lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzkwODE5ODM0Ng==&amp;amp;mid=2247488521&amp;amp;idx=1&amp;amp;sn=66b0ae23ef24ba47f4487aa8a3646886&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;要是以前有人这么讲线程池，我早就该明白了！&lt;/a&gt;  ，当然，我们自己实现， 只需要抓住线程池的核心流程-参考[6]：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-type=&quot;png&quot; data-ratio=&quot;0.46633416458852867&quot; data-w=&quot;802&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWcMxSzU05DWGIZ1b1icvRXTS6pnG8oPaia0Kicic8DhQ08mkzn8iaGEJk8whPYZ4E3sGYf2gUGoDfUW5Hg/640?wx_fmt=png&quot;/&gt;&lt;figcaption&gt;线程池主要实现流程&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们自己的实现就是完成这个核心流程：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;线程池中有N个工作线程&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;把任务提交给线程池运行&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;如果线程池已满，把任务放入队列&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;最后当有空闲时，获取队列中任务来执行&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;实现代码[6]：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-type=&quot;png&quot; data-ratio=&quot;2.6546296296296297&quot; data-w=&quot;1080&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWcMxSzU05DWGIZ1b1icvRXTS9pA3JJZyEsgepVkQ9M2prjsiamJ8cBKb8MCWnX9l6jsn1aNyQuH2vpw/640?wx_fmt=png&quot;/&gt;&lt;figcaption&gt;自定义线程池&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这样，一个实现了线程池主要流程的类就完成了。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;59.单机线程池执行断电了应该怎么处理？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;br/&gt;我们可以对正在处理和阻塞队列的任务做事务管理或者对阻塞队列中的任务持久化处理，并且当断电或者系统崩溃，操作无法继续下去的时候，可以通过回溯日志的方式来撤销&lt;code&gt;正在处理&lt;/code&gt;的已经执行成功的操作。然后重新执行整个阻塞队列。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;也就是说，对阻塞队列持久化；正在处理任务事务控制；断电之后正在处理任务的回滚，通过日志恢复该次操作；服务器重启后阻塞队列中的数据再加载。&lt;/p&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;并发容器和框架&lt;/span&gt;&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;关于一些并发容器，可以去看看 &lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzkwODE5ODM0Ng==&amp;amp;mid=2247488788&amp;amp;idx=1&amp;amp;sn=01875e3e45515c2d57593cb7a01d0b6b&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;面渣逆袭：Java集合连环三十问  &lt;/a&gt;，里面有&lt;code&gt;CopyOnWriteList&lt;/code&gt;和&lt;code&gt;ConcurrentHashMap&lt;/code&gt;这两种线程安全容器类的问答。。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;60.Fork/Join框架了解吗？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Fork/Join框架是Java7提供的一个用于并行执行任务的框架，是一个把大任务分割成若干个小任务，最终汇总每个小任务结果后得到大任务结果的框架。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;要想掌握Fork/Join框架，首先需要理解两个点，&lt;strong&gt;分而治之&lt;/strong&gt;和&lt;strong&gt;工作窃取算法&lt;/strong&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;分而治之&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Fork/Join框架的定义，其实就体现了分治思想：将一个规模为N的问题分解为K个规模较小的子问题，这些子问题相互独立且与原问题性质相同。求出子问题的解，就可得到原问题的解。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-type=&quot;png&quot; data-ratio=&quot;0.8277356446370531&quot; data-w=&quot;923&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWcMxSzU05DWGIZ1b1icvRXTS6J3czqIO12fQuCQKZZWHQdd6Egdjia4ertvp8Ap80Zx3BZ4mkeTsvJQ/640?wx_fmt=png&quot;/&gt;&lt;figcaption&gt;Fork/Join分治算法&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;工作窃取算法&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;大任务拆成了若干个小任务，把这些小任务放到不同的队列里，各自创建单独线程来执行队列里的任务。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那么问题来了，有的线程干活块，有的线程干活慢。干完活的线程不能让它空下来，得让它去帮没干完活的线程干活。它去其它线程的队列里窃取一个任务来执行，这就是所谓的&lt;strong&gt;工作窃取&lt;/strong&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;工作窃取发生的时候，它们会访问同一个队列，为了减少窃取任务线程和被窃取任务线程之间的竞争，通常任务会使用双端队列，被窃取任务线程永远从双端队列的头部拿，而窃取任务的线程永远从双端队列的尾部拿任务执行。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-type=&quot;png&quot; data-ratio=&quot;0.5126162018592297&quot; data-w=&quot;753&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWcMxSzU05DWGIZ1b1icvRXTSMU4VPDmKLHgz7FU8UKgQOvmpH9oDI7fOiboDYQz7nhwIAjdE1Y2NZicg/640?wx_fmt=png&quot;/&gt;&lt;figcaption&gt;工作窃取&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;看一个Fork/Join框架应用的例子，计算1~n之间的和：1+2+3+…+n&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;设置一个分割阈值，任务大于阈值就拆分任务&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;任务有结果，所以需要继承RecursiveTask&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;CountTask&lt;/span&gt; &lt;span&gt;extends&lt;/span&gt; &lt;span&gt;RecursiveTask&lt;/span&gt;&amp;lt;&lt;span&gt;Integer&lt;/span&gt;&amp;gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; THRESHOLD = &lt;span&gt;16&lt;/span&gt;; &lt;span&gt;// 阈值&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; start;&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; end;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;CountTask&lt;/span&gt;&lt;span&gt;(&lt;span&gt;int&lt;/span&gt; start, &lt;span&gt;int&lt;/span&gt; end)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;this&lt;/span&gt;.start = start;&lt;br/&gt;        &lt;span&gt;this&lt;/span&gt;.end = end;&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;protected&lt;/span&gt; Integer &lt;span&gt;compute&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;int&lt;/span&gt; sum = &lt;span&gt;0&lt;/span&gt;;&lt;br/&gt;        &lt;span&gt;// 如果任务足够小就计算任务&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;boolean&lt;/span&gt; canCompute = (end - start) &amp;lt;= THRESHOLD;&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (canCompute) {&lt;br/&gt;            &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = start; i &amp;lt;= end; i++) {&lt;br/&gt;                sum += i;&lt;br/&gt;            }&lt;br/&gt;        } &lt;span&gt;else&lt;/span&gt; {&lt;br/&gt;            &lt;span&gt;// 如果任务大于阈值，就分裂成两个子任务计算&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;int&lt;/span&gt; middle = (start + end) / &lt;span&gt;2&lt;/span&gt;;&lt;br/&gt;            CountTask leftTask = &lt;span&gt;new&lt;/span&gt; CountTask(start, middle);&lt;br/&gt;            CountTask rightTask = &lt;span&gt;new&lt;/span&gt; CountTask(middle + &lt;span&gt;1&lt;/span&gt;, end);&lt;br/&gt;            &lt;span&gt;// 执行子任务&lt;/span&gt;&lt;br/&gt;            leftTask.fork();&lt;br/&gt;            rightTask.fork(); &lt;span&gt;// 等待子任务执行完，并得到其结果&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;int&lt;/span&gt; leftResult = leftTask.join();&lt;br/&gt;            &lt;span&gt;int&lt;/span&gt; rightResult = rightTask.join(); &lt;span&gt;// 合并子任务&lt;/span&gt;&lt;br/&gt;            sum = leftResult + rightResult;&lt;br/&gt;        }&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; sum;&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;(String[] args)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        ForkJoinPool forkJoinPool = &lt;span&gt;new&lt;/span&gt; ForkJoinPool(); &lt;span&gt;// 生成一个计算任务，负责计算1+2+3+4&lt;/span&gt;&lt;br/&gt;        CountTask task = &lt;span&gt;new&lt;/span&gt; CountTask(&lt;span&gt;1&lt;/span&gt;, &lt;span&gt;100&lt;/span&gt;); &lt;span&gt;// 执行一个任务&lt;/span&gt;&lt;br/&gt;        Future&amp;lt;Integer&amp;gt; result = forkJoinPool.submit(task);&lt;br/&gt;        &lt;span&gt;try&lt;/span&gt; {&lt;br/&gt;            System.out.println(result.get());&lt;br/&gt;        } &lt;span&gt;catch&lt;/span&gt; (InterruptedException e) {&lt;br/&gt;        } &lt;span&gt;catch&lt;/span&gt; (ExecutionException e) {&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;    &lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;ForkJoinTask与一般Task的主要区别在于它需要实现compute方法，在这个方法里，首先需要判断任务是否足够小，如果足够小就直接执行任务。如果比较大，就必须分割成两个子任务，每个子任务在调用fork方法时，又会进compute方法，看看当前子任务是否需要继续分割成子任务，如果不需要继续分割，则执行当前子任务并返回结果。使用join方法会等待子任务执行完并得到其结果。&lt;/p&gt;&lt;section&gt;&lt;mp-common-profile class=&quot;custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mpprofile&quot; data-weuitheme=&quot;light&quot; data-id=&quot;MzkwOTAyMTY2NA==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/RkqIyCg0bs5RxSfSeAUVCFlYkTgwFzSTian35nERyNxV5th5VQ64LCrrQ0HQeSCXErDw9rEKIy2JAJ00Wex8ZlQ/0?wx_fmt=png&quot; data-nickname=&quot;Java充电社&quot; data-alias=&quot;nihaojava8&quot; data-signature=&quot;Java充电社，专注分享Java技术干货，包括多线程、JVM、SpringBoot、SpringCloud、Dubbo、Zookeeper、Redis、架构设计、微服务、消息队列、Git、面试题、程序员攻略、最新动态等。&quot; data-from=&quot;0&quot; data-weui-theme=&quot;light&quot;/&gt;&lt;/section&gt;&lt;br data-tool=&quot;mdnice编辑器&quot;/&gt;&lt;pre&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1.2204545454545455&quot; data-w=&quot;440&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/RkqIyCg0bs5eA3lABIgSNCAiaiaXF3XfK77DciajeWbGUJ91ribtXtpsDEzlYeAB4icdIhcSrlEeJM4Kf0FiaS68icE8w/640?wx_fmt=png&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;↓&lt;strong&gt;↓&lt;strong&gt;↓ &lt;/strong&gt;&lt;/strong&gt;点击阅读原文，直达个人博客&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-croporisrc=&quot;https://mmbiz.qlogo.cn/mmbiz_jpg/xe4FY1hGDmq17JSGmvlibgJjT73DIFV5hNpPbbL7bDtKBKyOka9bl1LLiam25MusZplIsuk5l0zQW2Pg1WhvCRJw/?wx_fmt=jpeg&quot; data-cropx1=&quot;0&quot; data-cropx2=&quot;193&quot; data-cropy1=&quot;63&quot; data-cropy2=&quot;246&quot; data-fileid=&quot;100014145&quot; data-ratio=&quot;0.9583333333333334&quot; data-type=&quot;jpeg&quot; data-w=&quot;192&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/x0kXIOa6owVWZPKyaM6oCE4YHtIwIicLjFIDeHX6FKElExLvJakC6vZk9b33M8ghbhyg0t8Bts4sh9ia98kC11eA/640?wx_fmt=jpeg&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot;/&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;strong&gt;&lt;span&gt;你在看吗&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/pre&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>