<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>aeee774544196a08a5c7ef0386ca49b4</guid>
<title>20 图 ｜6 千字｜缓存实战（上篇）</title>
<link>https://toutiao.io/k/4uqm3n6</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;前言&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;先说个小事情，今天试了下做动图，就一张动图都花了我 &lt;span&gt;1 个小时&lt;/span&gt;，还做得很难看。。在线求个做动图的好软件～&lt;img data-ratio=&quot;0.6666666666666666&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/SfAHMuUxqJ3fX1LcLILYlWibxyyicmlLk9hxbHXH2x3B4AWCibRIcw24OicKnrNhnrMe6B9OW6WtliabudRWqiblwibjw/640?wx_fmt=gif&quot; data-type=&quot;gif&quot; data-w=&quot;360&quot;/&gt;本文主要内容如下：&lt;img data-ratio=&quot;0.6103896103896104&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/SfAHMuUxqJ3fX1LcLILYlWibxyyicmlLk9lBdbOexGuBEpobCpjptCY6yPLZfJem2hQeZCJ7vITTkxcdvgOZyI8g/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;539&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上一篇讲到如何做性能调优的方式：&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzAwMjI0ODk0NA==&amp;amp;mid=2451952448&amp;amp;idx=1&amp;amp;sn=4351e18bf793ed42a55db20b38de89f6&amp;amp;chksm=8d1c2adfba6ba3c96d5018d8266de3f6eec2b7abd89e073cd3fbf0c4a122baa84c69dd1f6cc0&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;《48 张图 | 手摸手教你微服务的性能监控、压测和调优》&lt;/a&gt;，比如给表加索引、动静分离、减少不必要的日志打印。但有一个很强大的优化方式没有提到，那就是加缓存，比如查询小程序的广告位配置，因为没什么人会去频繁的改，将广告位配置丢到缓存里面再适合不过了。那我们就给开源 Spring Cloud 实战项目 PassJava 加下缓存来提升下性能。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我把&lt;code&gt;后端&lt;/code&gt;、&lt;code&gt;前端&lt;/code&gt;、&lt;code&gt;小程序&lt;/code&gt;都上传到同一个仓库里面了，大家可以通过 &lt;code&gt;Github&lt;/code&gt; 或 &lt;code&gt;码云&lt;/code&gt;访问。地址如下：&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;&lt;strong&gt;Github&lt;/strong&gt;: https://github.com/Jackson0714/PassJava-Platform&lt;/p&gt;&lt;p&gt;&lt;strong&gt;码云&lt;/strong&gt;：https://gitee.com/jayh2018/PassJava-Platform&lt;/p&gt;&lt;p&gt;&lt;strong&gt;配套教程&lt;/strong&gt;：www.passjava.cn&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在实战之前，我们先来看下使用缓存的原理和问题。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;一、缓存&lt;/span&gt;&lt;/h2&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;1.1 为什么要用缓存&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;20 年前常见的系统就是单机的，比如 ERP 系统，对性能要求不高，使用缓存的并不常见，但现如今，已经步入到互联网时代，高并发、高可用、高性能总是被提起，而缓存在这“三高”中立下&lt;strong&gt;汗马功劳&lt;/strong&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们通过会将部分数据放入缓存中，来提高访问速度，然后数据库承担存储的工作。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;那么哪些数据适合放入缓存中呢？&lt;/strong&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;即时性。例如查询最新的物流状态信息。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;数据一致性要求不高。例如门店信息，修改后，数据库中已经改了，5 分钟后缓存中才是最新的，但不影响功能使用。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;访问量大且更新频率不高。比如首页的广告信息，访问量，但是不会经常变化。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当我们想要查询数据时，使用缓存的流程如下：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.8650793650793651&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/SfAHMuUxqJ3fX1LcLILYlWibxyyicmlLk97XpicL7aHZPjksHr9VmL0DOjewnsTJ2a9WMjDibBsww5ryAE0Lw3sNiaQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;630&quot;/&gt;&lt;figcaption&gt;读模式缓存使用流程&lt;/figcaption&gt;&lt;/figure&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;1.2  本地缓存&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;比如现在有一个需求：前端小程序需要查询题目的类型，而题目类型放在小程序的首页在，访问量是非常高的，但是又不是经常变化的数据，所以可以将题目类型数据放到缓存中。&lt;/span&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.4921135646687697&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/SfAHMuUxqJ3fX1LcLILYlWibxyyicmlLk9Xczd7ic4ZXNOqhichPQtIfm9am9dQSjM5SftbRbyhy0hgojUgeupDhtg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;317&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;最简单的使用缓存的方式是使用本地缓存，也就是在内存中缓存数据，可以用 HashMap、数组等数据结构来缓存数据。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;1.2.1 不使用缓存&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们先来看下不使用缓存的情况：前端的请求先经过网关，然后请求到题目微服务，然后查询数据库，返回查询结果。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.268361581920904&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/SfAHMuUxqJ3fX1LcLILYlWibxyyicmlLk9BJj5C9u71YiaOaIyhqiahbQddAaPwXWEEEqYUH6YiaN6icYDV976nrBM7A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;708&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;再来看下核心代码是怎么样的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;先自定义一个 Rest API 用来查询题目类型列表，数据是从数据库查询出来后直接返回给前端。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;@RequestMapping&lt;/span&gt;(&lt;span&gt;&quot;/list&quot;&lt;/span&gt;)&lt;br/&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; R &lt;span&gt;list&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;// 从数据库中查询数据&lt;/span&gt;&lt;br/&gt;    typeEntityList = ITypeService.list(); &lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; R.ok().put(&lt;span&gt;&quot;typeEntityList&quot;&lt;/span&gt;, typeEntityList);&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;1.2.2 使用缓存&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;来看下使用缓存的情况：前端先经过网关，然后到题目微服务，先判断缓存中有没有数据，如果没有，则查询数据库再更新缓存，最后返回查询到的结果。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.4582743988684583&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/SfAHMuUxqJ3fX1LcLILYlWibxyyicmlLk95xwIiclKA3DFBNNG3Puao4ic2SicgQEI0O2cyUxZtGdslU5mX5hIL6suQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;707&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那我们现在创建一个 HashMap 来缓存题目的类型列表：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;private&lt;/span&gt; Map&amp;lt;String, Object&amp;gt; cache = &lt;span&gt;new&lt;/span&gt; HashMap&amp;lt;&amp;gt;();&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;先获取缓存的类型列表&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;List&amp;lt;TypeEntity&amp;gt; typeEntityListCache = (List&amp;lt;TypeEntity&amp;gt;) cache.get(&lt;span&gt;&quot;typeEntityList&quot;&lt;/span&gt;);&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果缓存中没有，则先从数据库中获取。当然，第一次查询缓存时，肯定是没有这个数据的。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;// 如果缓存中没有数据&lt;/span&gt;&lt;br/&gt;&lt;span&gt;if&lt;/span&gt; (typeEntityListCache == &lt;span&gt;null&lt;/span&gt;) {&lt;br/&gt;  System.out.println(&lt;span&gt;&quot;The cache is empty&quot;&lt;/span&gt;);&lt;br/&gt;  &lt;span&gt;// 从数据库中查询数据&lt;/span&gt;&lt;br/&gt;  List&amp;lt;TypeEntity&amp;gt; typeEntityList = ITypeService.list();&lt;br/&gt;  &lt;span&gt;// 将数据放入缓存中&lt;/span&gt;&lt;br/&gt;  typeEntityListCache = typeEntityList;&lt;br/&gt;  cache.put(&lt;span&gt;&quot;typeEntityList&quot;&lt;/span&gt;, typeEntityList);&lt;br/&gt;}&lt;br/&gt;&lt;span&gt;return&lt;/span&gt; R.ok().put(&lt;span&gt;&quot;typeEntityList&quot;&lt;/span&gt;, typeEntityListCache);&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们用 Postman 工具来看下查询结果：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;请求URL：https://github.com/Jackson0714/PassJava-Platform&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.6009036144578314&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/SfAHMuUxqJ3fX1LcLILYlWibxyyicmlLk9D843rQtJ4W47f50odhTFbKHlW1YM8EPcAmGQic7bJl9JkpXTYLUOI7g/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;664&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;返回了题目类型列表，共 14 条数据。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;以后再次查询时，因为缓存中已经有该数据了，所以直接走缓存，不会再从数据库中查询数据了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;从上面的例子中我们可以知道本地缓存有哪些优点呢？&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;减少和数据库的交互，降低因磁盘 I/O 引起的性能问题。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;避免数据库的死锁问题。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;加速相应速度。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当然，本地缓存也存在一些问题：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;占用本地内存资源。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;机器宕机重启后，缓存丢失。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;可能会存在数据库数据和缓存数据不一致的问题。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;同一台机器中的多个微服务缓存的数据不一致。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;1.0800821355236139&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/SfAHMuUxqJ3fX1LcLILYlWibxyyicmlLk9JpKy1tynm0eTJ7RvWkTcXhciavtjloCspPnYQkQVibtyibOe9nQClicQKA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;487&quot;/&gt;&lt;/figure&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;1.1931818181818181&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/SfAHMuUxqJ3fX1LcLILYlWibxyyicmlLk90cBTpgicoS4hFQicEPv2LyhShwDXlAeuGZgnia70vIZ3xRHRmicbnGcMoQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;440&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;基于本地缓存的问题，我们引入了分布式缓存 &lt;code&gt;Redis&lt;/code&gt; 来解决。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;二、缓存 Redis&lt;/span&gt;&lt;/h2&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;2.1 Docker 安装 Redis&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;首先需要安装 Redis，我是通过 Docker 来安装 Redis。另外我在 ubuntu 和 Mac M1 上都装过 docker 版的 Redis，大家可以参照这两篇来安装。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzAwMjI0ODk0NA==&amp;amp;mid=2451943021&amp;amp;idx=4&amp;amp;sn=d372944f4d7275217e24af16b4014939&amp;amp;chksm=8d1c57f2ba6bdee43537bf0bd44b0f314053b6562065feae2dbd6dc04a1304ed8c393342f557&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;《Ubuntu 上到 Docker 安装redis》&lt;/a&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzAwMjI0ODk0NA==&amp;amp;mid=2451954169&amp;amp;idx=1&amp;amp;sn=950ef7a2ca1faafd29783c2872e41095&amp;amp;chksm=8d1c2066ba6ba97059874423f7507603306a381fce2e200008ad14f6b775364495c01b56fc84&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;《M1 和 Docker 谈了个恋爱...》&lt;/a&gt;&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;2.2 引入 Redis 组件&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我用的是 passjava-question 微服务，所以是在 passjava-question 模块下的配置文件 pom.xml 中引入 redis 组件。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;文件路径：/passjava-question/pom.xml&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&amp;lt;&lt;span&gt;dependency&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&amp;lt;&lt;span&gt;groupId&lt;/span&gt;&amp;gt;&lt;/span&gt;org.springframework.boot&lt;span&gt;&amp;lt;/&lt;span&gt;groupId&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&amp;lt;&lt;span&gt;artifactId&lt;/span&gt;&amp;gt;&lt;/span&gt;spring-boot-starter-data-redis&lt;span&gt;&amp;lt;/&lt;span&gt;artifactId&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&amp;lt;/&lt;span&gt;dependency&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;2.3 测试 Redis&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们可以写一个测试方法来测试引入的 redis 是否能存数据，以及能否查出存的数据。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们都是使用 &lt;code&gt;StringRedisTemplate&lt;/code&gt; 库来操作 Redis，所以可以自动装载下 &lt;code&gt;StringRedisTemplate&lt;/code&gt;。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;@Autowired&lt;/span&gt;&lt;br/&gt;StringRedisTemplate stringRedisTemplate;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;然后在测试方法中，测试存储方法：ops.set()，以及 查询方法：ops.get()&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;@Test&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;TestStringRedisTemplate&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;// 初始化 redis 组件&lt;/span&gt;&lt;br/&gt;    ValueOperations&amp;lt;String, String&amp;gt; ops = stringRedisTemplate.opsForValue();&lt;br/&gt;    &lt;span&gt;// 存储数据&lt;/span&gt;&lt;br/&gt;    ops.set(&lt;span&gt;&quot;悟空&quot;&lt;/span&gt;, &lt;span&gt;&quot;悟空聊架构_&quot;&lt;/span&gt; + UUID.randomUUID().toString());&lt;br/&gt;    &lt;span&gt;// 查询数据&lt;/span&gt;&lt;br/&gt;    String wukong = ops.get(&lt;span&gt;&quot;悟空&quot;&lt;/span&gt;);&lt;br/&gt;    System.out.println(wukong);&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;set 方法的第一个参数是 key，比如示例中的 “悟空”。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;get 方法的参数也是 key。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;最后打印出了 redis 中 key = “&lt;span&gt;悟空&lt;/span&gt;” 的缓存的值：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.23170731707317074&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/SfAHMuUxqJ3fX1LcLILYlWibxyyicmlLk9KxgxWZ7LjugeDkmicTPAMpo2NiaW8ia3pYVGzAPpFd0AWjOMuQPCg6qdw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;574&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;另外也可以通过客户端工具来查看，如下图所示：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.40028490028490027&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/SfAHMuUxqJ3fX1LcLILYlWibxyyicmlLk9OU8In9Qf17NibnaIwvibmR1jgKDyZWV0Houqic2GEPSZYxDjagZk9S5fg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;702&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我下载的是这个软件：Redis Desktop Manager windows，Mac M1 上正常使用。下载地址：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;http://www.pc6.com/softview/SoftView_450180.html&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;2.4 用  Redis 改造业务逻辑&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;用 redis 替换 hashmap 也不难，把用到 hashmap 的地方都用 redis 改下。另外需要注意的是：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;从数据库中查询到的数据先要&lt;code&gt;序列化&lt;/code&gt;成 JSON 字符串后再存入到 Redis 中，从 Redis 中查询数据时，也需要将 JSON 字符串&lt;code&gt;反序列化&lt;/code&gt;为对象实例。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; List&amp;lt;TypeEntity&amp;gt; &lt;span&gt;getTypeEntityList&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;// 1.初始化 redis 组件&lt;/span&gt;&lt;br/&gt;  ValueOperations&amp;lt;String, String&amp;gt; ops = stringRedisTemplate.opsForValue();&lt;br/&gt;  &lt;span&gt;// 2.从缓存中查询数据&lt;/span&gt;&lt;br/&gt;  String typeEntityListCache = ops.get(&lt;span&gt;&quot;typeEntityList&quot;&lt;/span&gt;);&lt;br/&gt;  &lt;span&gt;// 3.如果缓存中没有数据&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;if&lt;/span&gt; (StringUtils.isEmpty(typeEntityListCache)) {&lt;br/&gt;    System.out.println(&lt;span&gt;&quot;The cache is empty&quot;&lt;/span&gt;);&lt;br/&gt;    &lt;span&gt;// 4.从数据库中查询数据&lt;/span&gt;&lt;br/&gt;    List&amp;lt;TypeEntity&amp;gt; typeEntityListFromDb = &lt;span&gt;this&lt;/span&gt;.list();&lt;br/&gt;    &lt;span&gt;// 5.将从数据库中查询出的数据序列化 JSON 字符串&lt;/span&gt;&lt;br/&gt;    typeEntityListCache = JSON.toJSONString(typeEntityListFromDb);&lt;br/&gt;    &lt;span&gt;// 6.将序列化后的数据存入缓存中&lt;/span&gt;&lt;br/&gt;    ops.set(&lt;span&gt;&quot;typeEntityList&quot;&lt;/span&gt;, typeEntityListCache);&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; typeEntityListFromDb;&lt;br/&gt;  }&lt;br/&gt;  &lt;span&gt;// 7.如果缓存中有数据，则从缓存中拿出来，并反序列化为实例对象&lt;/span&gt;&lt;br/&gt;  List&amp;lt;TypeEntity&amp;gt; typeEntityList = JSON.parseObject(typeEntityListCache, &lt;span&gt;new&lt;/span&gt; TypeReference&amp;lt;List&amp;lt;TypeEntity&amp;gt;&amp;gt;(){});&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; typeEntityList;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;整个流程如下：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;1.初始化 redis 组件。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;2.从缓存中查询数据。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;3.如果缓存中没有数据，执行步骤 4、5、6。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;4.从数据库中查询数据。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;5.将从数据库中查询出的数据转化为 JSON 字符串。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;6.将序列化后的数据存入缓存中，并返回数据库中查询到的数据。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;7.如果缓存中有数据，则从缓存中拿出来，并反序列化为实例对象。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;2.5 测试业务逻辑&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们还是用 postman 工具进行测试：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.6794682422451994&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/SfAHMuUxqJ3fX1LcLILYlWibxyyicmlLk9eMEl1PKDKJbw8MXSE2YctvfQVE2LoHvoOHWaBCObZA8THcicSNshNeg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;677&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;通过多次测试，第一次请求会稍微慢点，后面几次速度非常快。说明使用缓存后性能有提升。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;另外我们用 Redis 客户端看下结果：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Redis key = typeEntityList，Redis value 是一个 JSON 字符串，里面的内容是题目分类列表。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.46786632390745503&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/SfAHMuUxqJ3fX1LcLILYlWibxyyicmlLk9c0m1LvBic4VmFgWZ1xVqfRogB6OpW7l4aRQbBCK7LJwic2R3BWHorNbw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;778&quot;/&gt;&lt;/figure&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;三、缓存穿透、雪崩、击穿&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;高并发下使用缓存会带来的几个问题：缓存穿透、雪崩、击穿。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;3.1 缓存穿透&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;3.1.1 缓存穿透的概念&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;缓存穿透指一个一定不存在的数据，由于缓存未命中这条数据，就会去查询数据库，数据库也没有这条数据，所以返回结果是 &lt;code&gt;null&lt;/code&gt;。如果每次查询都走数据库，则缓存就失去了意义，就像穿透了缓存一样。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.8795180722891566&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/SfAHMuUxqJ3fX1LcLILYlWibxyyicmlLk9Aibu2yMhQEpVdhhLVAvzURIFSXoaY4Juic2LbsfO1ylmeLZzEoktrW7A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;664&quot;/&gt;&lt;/figure&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;3.1.2 带来的风险&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;利用不存在的数据进行攻击，数据库压力增大，最终导致系统崩溃。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;3.1.3 解决方案&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;对结果 &lt;code&gt;null&lt;/code&gt; 进行缓存，并加入短暂的过期时间。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;3.2 缓存雪崩&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.6666666666666666&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/SfAHMuUxqJ3fX1LcLILYlWibxyyicmlLk9hxbHXH2x3B4AWCibRIcw24OicKnrNhnrMe6B9OW6WtliabudRWqiblwibjw/640?wx_fmt=gif&quot; data-type=&quot;gif&quot; data-w=&quot;360&quot;/&gt;&lt;/figure&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;3.2.1 缓存雪崩的概念&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;缓存雪崩是指我们缓存多条数据时，采用了相同的过期时间，比如 00:00:00 过期，如果这个时刻缓存同时失效，而有大量请求进来了，因未缓存数据，所以都去查询数据库了，数据库压力增大，最终就会导致雪崩。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.875748502994012&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/SfAHMuUxqJ3fX1LcLILYlWibxyyicmlLk90v2lr9RqITxorEribrwcs2BpzbSleEIVAYlVzBW3agEz8iaWt7ia5ntQQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;668&quot;/&gt;&lt;/figure&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;3.2.2 带来的风险&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;尝试找到大量 key 同时过期的时间，在某时刻进行大量攻击，数据库压力增大，最终导致系统崩溃。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;3.2.3 解决方案&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在原有的实效时间基础上增加一个碎挤汁，比如 1-5 分钟随机，降低缓存的过期时间的重复率，避免发生缓存集体实效。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;3.3 缓存击穿&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;3.3.1 缓存击穿的概念&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;某个 key 设置了过期时间，但在正好失效的时候，有大量请求进来了，导致请求都到数据库查询了。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.8819969742813918&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/SfAHMuUxqJ3fX1LcLILYlWibxyyicmlLk9OPU3Rz080AtJ9gIt4MicHmdC9G8yQ3LxqWn6lxWibKlE96qYMF4AuVaA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;661&quot;/&gt;&lt;/figure&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;3.3.2 解决方案&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;大量并发时，只让一个请求可以获取到查询数据库的锁，其他请求需要等待，查到以后释放锁，其他请求获取到锁后，先查缓存，缓存中有数据，就不用查数据库。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;四、加锁解决缓存击穿&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;怎么处理缓存穿透、雪崩、击穿的问题呢？&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;对空结果进行缓存，用来解决缓存穿透问题。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;设置过期时间，且加上随机值进行过期偏移，用来解决缓存雪崩问题。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;加锁，解决缓存击穿问题。另外需要注意，加锁对性能会带来影响。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里我们来看下用代码演示如何解决缓存击穿问题。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们需要用 synchronized 来进行加锁。当然这是本地锁的方式，分布式锁我们会在下篇讲到。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; List&amp;lt;TypeEntity&amp;gt; &lt;span&gt;getTypeEntityListByLock&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;synchronized&lt;/span&gt; (&lt;span&gt;this&lt;/span&gt;) {&lt;br/&gt;    &lt;span&gt;// 1.从缓存中查询数据&lt;/span&gt;&lt;br/&gt;    String typeEntityListCache = stringRedisTemplate.opsForValue().get(&lt;span&gt;&quot;typeEntityList&quot;&lt;/span&gt;);&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (!StringUtils.isEmpty(typeEntityListCache)) {&lt;br/&gt;      &lt;span&gt;// 2.如果缓存中有数据，则从缓存中拿出来，并反序列化为实例对象，并返回结果&lt;/span&gt;&lt;br/&gt;      List&amp;lt;TypeEntity&amp;gt; typeEntityList = JSON.parseObject(typeEntityListCache, &lt;span&gt;new&lt;/span&gt; TypeReference&amp;lt;List&amp;lt;TypeEntity&amp;gt;&amp;gt;(){});&lt;br/&gt;      &lt;span&gt;return&lt;/span&gt; typeEntityList;&lt;br/&gt;    }&lt;br/&gt;    &lt;span&gt;// 3.如果缓存中没有数据，从数据库中查询数据&lt;/span&gt;&lt;br/&gt;    System.out.println(&lt;span&gt;&quot;The cache is empty&quot;&lt;/span&gt;);&lt;br/&gt;    List&amp;lt;TypeEntity&amp;gt; typeEntityListFromDb = &lt;span&gt;this&lt;/span&gt;.list();&lt;br/&gt;    &lt;span&gt;// 4.将从数据库中查询出的数据序列化 JSON 字符串&lt;/span&gt;&lt;br/&gt;    typeEntityListCache = JSON.toJSONString(typeEntityListFromDb);&lt;br/&gt;    &lt;span&gt;// 5.将序列化后的数据存入缓存中，并返回数据库查询结果&lt;/span&gt;&lt;br/&gt;    stringRedisTemplate.opsForValue().set(&lt;span&gt;&quot;typeEntityList&quot;&lt;/span&gt;, typeEntityListCache, &lt;span&gt;1&lt;/span&gt;, TimeUnit.DAYS);&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; typeEntityListFromDb;&lt;br/&gt;  }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;1.从缓存中查询数据。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;2.如果缓存中有数据，则从缓存中拿出来，并反序列化为实例对象，并返回结果。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;3.如果缓存中没有数据，从数据库中查询数据。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;4.将从数据库中查询出的数据序列化 JSON 字符串。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;5.将序列化后的数据存入缓存中，并返回数据库查询结果。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;五、本地锁的问题&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;本地锁只能锁定当前服务的线程，如下图所示，部署了多个题目微服务，每个微服务用本地锁进行加锁。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;1.4048582995951417&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/SfAHMuUxqJ3fX1LcLILYlWibxyyicmlLk9OPowicfDr5sbQwA9WbRqD9vuClXPyGOgHRCHrmRoY2pJkhicJZibRibUXg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;741&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;本地锁在一般情况下没什么问题，但是在某些情况下就会出问题：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;比如在&lt;/span&gt;&lt;span&gt;高并发情况下&lt;/span&gt;用来锁&lt;span&gt;库存&lt;/span&gt;就有问题了：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;1.比如当前总库存为 100，被缓存在 Redis 中。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;2.库存微服务 A 用本地锁扣减库存 1 之后，总库存为 99。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;3.库存微服务 B 用本地锁扣减库存 1 之后，总库存为 99。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;4.那库存扣减了 2 次后，还是 99，&lt;strong&gt;就超卖了 1 个&lt;/strong&gt;。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那如何解决本地加锁的问题呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;缓存实战（中篇）：实战分布式锁。我们下篇见！&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.352112676056338&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/SfAHMuUxqJ3fX1LcLILYlWibxyyicmlLk9telicoPHa1C71wrUX5joGW3BsfqHZZdrdd06YDYnLY4nxnXtlMk5GtQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;142&quot;/&gt;&lt;/p&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>0701138292d6df44b011e6cd5ab82c57</guid>
<title>语雀桌面端技术架构实践</title>
<link>https://toutiao.io/k/481hlbi</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot; data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;🙋🏻‍♀️ 编者按：本文作者是蚂蚁集团前端工程师维骏，介绍了语雀在做桌面端时的一些技术架构思考和实践，同时分享沉淀的一些通用桌面应用解决方案和经验，欢迎一起交流～&lt;/p&gt;&lt;/blockquote&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;313&quot; data-backw=&quot;558&quot; data-ratio=&quot;0.5616045845272206&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/M7OtEw9eDKHXdeaIvEMKHlCySvKXVRmOKfL5r51XChkmiaHSaWM8iacuwfggURMSqfg5CbyhLn4UiaOW7ibrpibWVoQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2094&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;语雀桌面端作为语雀为用户提供的生产力工具，上线两年多来一直保持高频的迭代和健康的业务增长。&lt;strong&gt;本次主要介绍我们在做桌面端时的一些技术架构思考和实践，同时也将分享我们沉淀的一些通用桌面应用解决方案和经验。&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;br/&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;304&quot; data-backw=&quot;542&quot; data-ratio=&quot;0.5616698292220114&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/M7OtEw9eDKHXdeaIvEMKHlCySvKXVRmOlicaBvvVD32mCcg0gs2bULTgLr6PPibnUSKYc8OFFic1ue5iczEDf8p6Zw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2108&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;文章会分为四部分，首先会简单介绍语雀桌面端，然后介绍当前语雀桌面端的应用架构以及关键点，之后介绍架构中的几个架构重点项，最后再进行总结。&lt;/p&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;/h1&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt; &lt;/strong&gt;&lt;/span&gt;&lt;span&gt; &lt;/span&gt;语&lt;span&gt;雀桌面端介绍&lt;/span&gt;&lt;/h1&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;/&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;语雀是孵化自蚂蚁体验技术部的一款笔记与文档知识库工具。我们在两年前，针对语雀用户特点，以及后续发展策略，旨在为创作者提供更好的创作体验，推出语雀桌面客户端。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;br/&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5628140703517588&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/M7OtEw9eDKHXdeaIvEMKHlCySvKXVRmOPI7EMvXgDohBXTwX59K2N4WDEDzicJl6xPVkibbflBz5v7hLdTb9pbyg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1990&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;相较于现有浏览器提供的产品服务而言，我们提供的桌面端产品主要考虑以下几点：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.560418648905804&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/M7OtEw9eDKHXdeaIvEMKHlCySvKXVRmOTqrVVopttjAeXAGeRMdOiaSkrV6msquwVnmiblbTME3fibze4uoOvHf9w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2102&quot;/&gt;&lt;figcaption&gt;&lt;br/&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;无干扰&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;给用户一个沉浸式的创作体验，而不像浏览器有其他窗口、tab 进行干扰，以及用完即走的用户心智。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;系统级常驻&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;打开速度更快，可以一键启动或者利用各类快捷工具唤起。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;集成更多操作系统能力&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;提升创作效率的多窗口、系统菜单和快捷键、对文件读写、与系统软件集成等。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;离线&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;期望能在离线或弱网的情况下，无障碍地进行创作。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;br/&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.561787072243346&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/M7OtEw9eDKHXdeaIvEMKHlCySvKXVRmORHZj3JlKGOW089Y38J72qTpMAb2C7bOpiaBSnxlTwHSxNOeh5Uu2q0Q/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2104&quot;/&gt;&lt;/p&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;/h1&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt; &lt;/strong&gt;&lt;/span&gt;&lt;span&gt; &lt;/span&gt;桌面端架构概览&lt;/h1&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;/&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;313&quot; data-backw=&quot;558&quot; data-ratio=&quot;0.5616698292220114&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/M7OtEw9eDKHXdeaIvEMKHlCySvKXVRmOfowEwVVUYePOHxXdFtxr3SudFeyes8Ij09ibmjfQu0uW9nB69rpBUkg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2108&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;研发侧主要分为左边三层，最底层是语雀的基础设施，依赖了语雀后台提供或封装的大量云服务，以及底层依赖的安全能力和存储模块。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;中间一层是比较偏应用架构的一些能力封装，上面是代码层面用的的辅助能力，还有主进程的模块，然后有给应用提供的一些管理能力和一些跟 UI 相关的功能模块，最上层就是基于底层架构搭建的业务应用。包括桌面端应用比较核心的几个模块，以及一些由子应用方式承接的业务模块（后面也会详细介绍子应用这个概念） &lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;同时最右侧也有很多辅助研发的依赖能力，来完成语雀桌面端的发布、质量和稳定性管理。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;架构概览 - 关键点&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;相比较普通 web 应用来说，我们觉得桌面端有以下几个能力比较重要：包括安全、软件升级、以及桌面端通用的的基础能力：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;br/&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;305&quot; data-backw=&quot;542&quot; data-ratio=&quot;0.5627376425855514&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/M7OtEw9eDKHXdeaIvEMKHlCySvKXVRmOMicqBYUr4UTF8nrJkUnZhDZLrc1WRwlbTBvS9cAI2GwbxXAcTQ1kFbw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2104&quot;/&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;架构概览 - 安全&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;安全是一个生产力工具软件的生命线，特别是语雀作为一款知识管理工具，对于安全是非常看重。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;br/&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;314&quot; data-backw=&quot;558&quot; data-ratio=&quot;0.5626794258373206&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/M7OtEw9eDKHXdeaIvEMKHlCySvKXVRmO8a1ucw9FaVaPF8zNQotGloXErOKzBRk7mc8YHXVzXIfz8ZsAHkv16g/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2090&quot;/&gt;&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;基础安全&lt;span/&gt;&lt;/h4&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;下载安装包时，需要有安全管理机制，避免下载过程中被恶意替换；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;升级到最新的 Electron 版本（语雀目前紧跟官方大版本，同时也会参考微软的头部应用 (vscode)，避免有没考虑到的场景；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;同时用户离线下载到本地的文件，包括图片，附件等，也需要经过加密。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;启动安全&lt;span/&gt;&lt;/h4&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;杀毒软件：&lt;/strong&gt;启动安全主要是在启动软件时的一些安全问题，例如二进制模块是否有加签名，避免被杀毒软件查杀导致无法启动，也可以联系安全厂商加白名单，同时还能提升启动速度。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;禁止调试：&lt;/strong&gt;因为软件代码都会下载到客户端，可以禁止软件在客户端浏览器进行调试。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;数据库密钥管理：&lt;/strong&gt;本地数据库文件需要保证即使被恶意拿到，也要保证无法查看到里面的内容。我们通过生成内存安全级别的方案，确保其他非当前电脑的语雀软件即使拿到数据库文件后也无法打开。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;应用安全&lt;span/&gt;&lt;/h4&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;渲染容器设置白名单来控制不被引入恶意页面；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;渲染进程关闭 Node 功能以及开启隔离模式，避免渲染进程权限过高；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Electron 本身是 web 开发模式，所以 web 中遇到的安全问题，在 Electron 同样会遇到，可以统一处理；&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;架构概览 - 软件升级&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;客户端软件相比较于 web 来说，还有一个非常大的区别就是有功能更新时，有一个升级过程，不像 web 直接刷新页面即可。语雀桌面端作为迭代迅速的产品，对于升级这块也是踩了不少坑。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;br/&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;305&quot; data-backw=&quot;542&quot; data-ratio=&quot;0.561787072243346&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/M7OtEw9eDKHXdeaIvEMKHlCySvKXVRmOKbnU8fkSmt6TLiaBvPPq7kojem6qUkvtwh5ryy1l1icw6w6Aic4ZRCfyA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2104&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;语雀桌面端由两大部分组成：&lt;/span&gt;&lt;span&gt;包括 Electron 和 Node.js 等基础模块的软件包 + 以及自己的业务代码。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;Mac OS：&lt;/strong&gt;Mac 下的升级流程比较简单，软件下载完成后，利用 &lt;code&gt;hdiutil&lt;/code&gt;来模拟用户手动安装流程，用户重启即可完成安装。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;Windows：&lt;/strong&gt;Windows 下因为环境特殊性，需要下载安装包后，通过主进程自动打开安装界面，引导用户进行手动一步一步安装。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其实这种方案很好地满足了我们早期的功能迭代，但是随着用户量上涨，也遇到了很多问题。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;br/&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;314&quot; data-backw=&quot;558&quot; data-ratio=&quot;0.5620853080568721&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/M7OtEw9eDKHXdeaIvEMKHlCySvKXVRmOyqmsvpjEAvtq1xv5haxorm2FpeicPIn00LMdl77y8sVsQVr0U9IvNrg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2110&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;比如：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;每次升级带宽消耗巨大：&lt;/strong&gt;对于每次安装每个 UV 都有近 100M 的下载，每次推送版本时，都会遇到 OSS 流量告警，这背后都对应着成本。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;安装体验差：&lt;/strong&gt;Windows 下因为每次升级几乎都是一次新的安装流程，所以体验也是比较差的，经常收到用户吐槽。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以我们就调研了一种增量更新的方案，一个 Electron 程序包括 Electron 核心包以及业务代码，其实每次变更的仅仅是业务代码，所以理论上每次更新只需要增量更新业务代码即可。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;br/&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;305&quot; data-backw=&quot;542&quot; data-ratio=&quot;0.5627376425855514&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/M7OtEw9eDKHXdeaIvEMKHlCySvKXVRmOa3VicicwYABmibpRwG2SyBskeeTczbeltmLzpWC7mHR7G0vRAMmHCeFMg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2104&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Mac 下增量直接下载到增量代码后，替换掉即可。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Windows 下比较复杂，我们主要遇到两个问题：、&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;文件占用问题：&lt;/strong&gt;由于 Windows 系统特性，如果某个文件在使用，会无法删除。所以说如果要替换，肯定关闭程序，然后进行删除操作后再启动。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以我们写了一个  .exe 可执行文件来做关闭程序、更新文件、启动语雀。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;UAB 权限控制：&lt;/strong&gt;文件写入另一个问题是 C 盘文件一般是需要授权才可以操作的。我们软件启动没办法拿到这么高权限。不过还在 Windows 7 及以后新增了一个 PowerShell 功能，通过这个功能执行，能引导用户授权，拿到更高级的权限。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当然过程中还碰到不少细节问题，比如替换过程中路径中英文问题、用户自定义过环境变量位置问题等等&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;架构概览 - 基础能力沉淀&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;另外我们在做软件的过程中，也沉淀了一些与业务无耦合的组件：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;br/&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;304&quot; data-backw=&quot;542&quot; data-ratio=&quot;0.5601895734597157&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/M7OtEw9eDKHXdeaIvEMKHlCySvKXVRmOf5dVa1oqsxVjKD0wFWYFPZsqJIG1sokgHxEF97ONCiczlAO9WFZMEKQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2110&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;多窗口管理：&lt;/strong&gt;当给用户提供提供更方便的多窗口编辑能力时，如何去管理这些窗口打开，关闭，性能监控等；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;Webview：&lt;/strong&gt;不同编辑器以及子应用都是通过 Webview 来承载的，需要有一个通用的模块来维护系统中用到的各个 webview 的生命周期等。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;离线在线：&lt;/strong&gt;电脑离线和在线状态获取，虽然浏览器有提供这个状态的获取和事件监听，但是 Windows 下不太准确。我们封装了一个比较通用的模块。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;/h1&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt; &lt;/strong&gt;&lt;/span&gt;&lt;span&gt; &lt;/span&gt;桌面端架构重点&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;从架构上来说，相较于用了多酷炫的技术，更重要的是研发交付效率高不高，性能怎么样，稳定性高不高。我们认为以下三点是架构好坏评判的重要标准。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;303&quot; data-backw=&quot;542&quot; data-ratio=&quot;0.5592417061611374&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/M7OtEw9eDKHXdeaIvEMKHlCySvKXVRmOuFToicgzyI7wTBgwSZEBJmuJ8w3xuGQsj2jCoCRNKVpOPg4f6UFuYZg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2110&quot;/&gt;&lt;figcaption&gt;&lt;br/&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;架构重点 - 交付效率&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;从桌面端功能上来说，包括编辑器在内，有超过 60% 的功能模块都是与 web 一致的，所以开始是用到了同构的方案。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;br/&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;305&quot; data-backw=&quot;542&quot; data-ratio=&quot;0.5619047619047619&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/M7OtEw9eDKHXdeaIvEMKHlCySvKXVRmOiay4PQJXoWElGEEdcv9z4kmyURl8bLsvnYMdDoqtCuicnCL5ygcnwqibA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2100&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;同构过程中的一些经验：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;通用代码移动到 Common 目录：&lt;/strong&gt;语雀代码仓库是 &lt;code&gt;monorepo&lt;/code&gt;模式，如果没有很清晰的目录划分，很容易造成跨端兼容问题。有了这个约定以后，业务研发同学就会注意到这个会用在移动端或者桌面端&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;通过 webpack alias 适配多端：&lt;/strong&gt;这个方式比较常见，比如各端有不同的网络请求库，在组件层面使用 adapter/request。webpack 在构建时，adapter 映射到不同的端实现。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;定义多端代码研发规范：&lt;/strong&gt;梳理出不同端的一些差异点，在研发时避免采坑。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;架构重点 - 交付效率（同构问题）&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;br/&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;305&quot; data-backw=&quot;542&quot; data-ratio=&quot;0.5622032288698955&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/M7OtEw9eDKHXdeaIvEMKHlCySvKXVRmOT64eHgFmEflH0AUbk7zMhdY3iccp6Vkk8RD7YPrXxHzbo5lW2JGMKwQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2106&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;虽然同构模式可以解决我们当时遇到的一些问题，但是随着业务规模和功能增加，陆续有些问题暴露出来：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;迁移到 Common 目录，各种依赖问题：&lt;/strong&gt;很多功能在桌面端之前已经上线，有些复杂组件迁移到 Common 下本身也需要耗费不少时间。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;缺少动态化能力，迭代滞后（web 与桌面端功能不一致）：&lt;/strong&gt;组件在 web 发布上线后，桌面端需要发布才支持，所以经常会碰到 web 和桌面端不一致的吐槽。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;容易出现多端兼容问题（环境依赖等）：&lt;/strong&gt;虽然我们定义了一些规范，但很难彻底避免出现环境依赖问题。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;缺少独立沙箱，容易影响主应用(内存泄漏、样式)：&lt;/strong&gt;web 可能用完即走，可以刷新等，不太容易遇到问题，但是桌面端因为是常驻的，如果有些内存泄漏或者样式污染问题，就直接影响到整体可用性。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;架构重点 - 交付效率（子应用）&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;考虑到上述原因，我们将代码复用架构升级成子应用模式，利用桌面端容器，嵌套一个 html 在线或者离线页面。简单来说，子应用模式可以理解为支付宝九宫格进去的各个小程序模块。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;br/&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;314&quot; data-backw=&quot;558&quot; data-ratio=&quot;0.561787072243346&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/M7OtEw9eDKHXdeaIvEMKHlCySvKXVRmOicxSibb3gWiaucqxDicmia4n4jiaxEOBpdpQYibrjcJXqOkdr96Infs4yZvZQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2104&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;快速迭代：&lt;/strong&gt;提供独立的发布迭代能力，所以无需跟随桌面端整体发布。而且直接由业务同学跟进整个交付流程，无需桌面端同学参与，提升交付效率。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;具备端相关能力：&lt;/strong&gt;每个子应用默认就能使用桌面端提供的 JSBridge 能力，天然能做到跟桌面端模块一样的能力。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;独立沙箱：&lt;/strong&gt;独立于桌面端主窗口，利用桌面端的容器来完成渲染，所以能完全做到进程级别隔离，相互之间的内存开销一目了然，更好得做到管控，保证整体应用稳定性。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;加载初始化：&lt;/strong&gt;除了上述的一些优势，也会到来一些问题，比如加载速度慢等，我们通过 webview 预热、缓存等方式，一定程度上解决了这个问题。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;架构重点 - 性能&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;性能是一个桌面端软件必须要面对的问题，是需要持续在不同角度进行优化的&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;br/&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;313&quot; data-backw=&quot;558&quot; data-ratio=&quot;0.560303893637227&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/M7OtEw9eDKHXdeaIvEMKHlCySvKXVRmOX3miba1SythG1bCtNeRBHpO16XGnOt9mh75RLHibolJRhcjR6bibWsyXg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2106&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;主要包括这几个方面：&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;strong&gt;启动速度优化：&lt;/strong&gt;&lt;span&gt;启动速度是用户第一映像，我们主要是将主进程代码进行缓存，尽早展示 loading 避免白屏，主窗口和渲染进程的部分任务同时执行，达到并发效果。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;strong&gt;主进程优化：&lt;/strong&gt;&lt;span&gt;主进程和渲染进程执行是同步的，如果主进程做了太多任务，会导致用户使用起来卡顿，甚至闪退。&lt;/span&gt;&lt;span&gt;所以尽量减少主进程所做的事情。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;strong&gt;Web 优化：&lt;/strong&gt;&lt;span&gt;同时，之前很多在 web 上做的优化，一样可以拿过来使用。&lt;/span&gt;&lt;span&gt;例如懒加载，合并模块等（组合多个模块本身也有开销）&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;Webview 优化：&lt;/strong&gt;&lt;span&gt;例如预热 webview、并进行一些性能管控措施，避免失控。&lt;/span&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;架构重点 - 性能（持续性任务）&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;性能优化其实不是说做完哪些事情就可以彻底解决，而是一个长期过程。可能我们后续新增功能时，代码里有某一个内存泄漏问题，就很容易导致性能拉胯下来。所以我们也建立了一些持续性的机制：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;br/&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;305&quot; data-backw=&quot;542&quot; data-ratio=&quot;0.5631528964862298&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/M7OtEw9eDKHXdeaIvEMKHlCySvKXVRmOR2y4Ttfohg4m3mxo9y1erPYGCt4MC2yelUNJMlzsGd9LXu8nIXx8Qg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2106&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;主要包括：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;日常观测：&lt;/strong&gt;在开发模式下，建立观测性能指标能力，做到心中有数；&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;自动化任务：&lt;/strong&gt;日常也会有自动化任务，模拟真实用户长时间使用，及时发现内存泄漏等问题；&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;性能大盘：&lt;/strong&gt;对于线上性能水位，能有一个全盘的感知能力，灰度发布过程中可重点关注。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;架构重点 - 稳定性&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;相比较于 web 而言，桌面端的稳定性也是要求更高的&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;br/&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;314&quot; data-backw=&quot;558&quot; data-ratio=&quot;0.562618595825427&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/M7OtEw9eDKHXdeaIvEMKHlCySvKXVRmOoFFsv15aicibgDe439nuZibhUQNk3O37nHNxRgfictoygRV8QL2EhCYCMg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2108&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;从研发流程上看，我们主要有两块事情：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;单测、集成测试：&lt;/strong&gt;利用代码测试来辅助整体稳定性&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;UIA：&lt;/strong&gt;通过模拟用户行为的 UIA 自动化测试回归来提升稳定性，及时发现异常。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;br/&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;339&quot; data-backw=&quot;542&quot; data-ratio=&quot;0.6262626262626263&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/M7OtEw9eDKHXdeaIvEMKHlCySvKXVRmOWwZk1J1fGhg6khkWNpKdJppZQs1JtlV7xUTp6mGRRQqjLZ9PTz5KCA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;3762&quot;/&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;392&quot; data-backw=&quot;542&quot; data-ratio=&quot;0.724112426035503&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/M7OtEw9eDKHXdeaIvEMKHlCySvKXVRmOjhkibicrq9LWU0aGrwklG5bHv39ykQSpwrjAHtZvs9ORiaUByoBGDBaqg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2704&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;注：UIA 是语雀工程师自研的自动化方案，详见 ：Macaca MacOS（https://github.com/macacajs/macaca-macos）&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;br/&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;305&quot; data-backw=&quot;542&quot; data-ratio=&quot;0.561787072243346&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/M7OtEw9eDKHXdeaIvEMKHlCySvKXVRmOibia3MnDiaOXaDaV42ox36jYSzq7Zvzz2eqOHJzibFEXF9v7DhknzPwhpA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2104&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;另外建立了稳定性大盘和实时告警，来感知到线上性能情况。为了保证每次发布的稳定性，减少回归成本，我们利用每周一次预览版发布的敏捷研发模式，来分解大版本发布带来的集成风险。&lt;/p&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;/h1&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt; &lt;/strong&gt;&lt;/span&gt;&lt;span&gt; &lt;/span&gt;总结&lt;/h1&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;br/&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;314&quot; data-backw=&quot;558&quot; data-ratio=&quot;0.5616698292220114&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/M7OtEw9eDKHXdeaIvEMKHlCySvKXVRmOmO0svtCicE3yXhwPKR8OwkiaJqMLmbr7Km53z1xoiav08knibrw6pZwHnQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2108&quot;/&gt;&lt;figcaption&gt;&lt;br/&gt;&lt;/figcaption&gt;&lt;figcaption&gt;&lt;br/&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;针对当前的业务体量和团队经验，选择合适的技术架构；&lt;/section&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;现在肯定有比 Electron 更新的桌面端架构，比如 flutter、tauri 等，要综合看比如团队积累以及稳定性，是否有成熟的商业化产品等。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;li&gt;&lt;section&gt;性能和稳定性优化是持续性的过程，先建立度量和感知；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;交付效率和交付质量最容易被忽视，但却是架构方案的重要考量；&lt;/section&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;架构好坏的评判标准一定是由业务效果决定的，交付效率和交付质量是衡量业务效果的手段之一。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/ul&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section class=&quot;mp_profile_iframe_wrp&quot;&gt;&lt;mp-common-profile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mpprofile&quot; data-id=&quot;Mzg2OTYyODU0NQ==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/M7OtEw9eDKG4jX2R3CQUS31Q65Rc9LVibaxJrgqkMmBSU7jUmYjNT4q0Q3gUVqpQf8Zepp6Ilo6X6qrffiawJoeQ/0?wx_fmt=png&quot; data-nickname=&quot;支付宝体验科技&quot; data-alias=&quot;antf2e&quot; data-signature=&quot;探索极致用户体验和最佳工程实践。&quot; data-from=&quot;0&quot; data-is_biz_ban=&quot;0&quot;/&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;有点意思，那就点个关注呗 💁🏼‍♀️&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;👇🏾&lt;/span&gt;&lt;span&gt;点击「阅读原文」，在评论区与我们互动噢&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>a8314071672531daeb9c7ab8e7b58e89</guid>
<title>读者推荐的 6 个 GitHub 项目！</title>
<link>https://toutiao.io/k/5zipv5q</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content                           autoTypeSetting24psection&amp;#10;                          &quot; id=&quot;js_content&quot;&gt;&lt;section&gt;本文盘点近一个月粉丝推荐的 6 个开源项目，如果你在逛 GitHub 的时候发现了宝藏开源项目。欢迎来公众号逛逛 GitHub 留言，你推荐的优质开源项目会放到优质开源项目专栏。&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.9653679653679653&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ePw3ZeGRruxXkAKXNUjmNWq8W4bUkia0deYjRTOTjvVaPzVwS24Gv6ibkWXVNZrY5wDRQmrkRpHZbVt7UrlrlzcQ/640?wx_fmt=png&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; data-w=&quot;462&quot;/&gt;&lt;/p&gt;&lt;p&gt;当然，如果你是优秀的开发者，自己维护了一些开源项目，同样可以告诉来逛逛 GitHub 投稿，投稿方式扫上方二维码，或者你可以关注公众号逛逛 GitHub，关注后点击底部的菜单栏也有投稿入口。&lt;span/&gt;&lt;/p&gt;&lt;p&gt;本期推荐开源项目目录：&lt;/p&gt;&lt;p&gt;1. 低代码可视化平台&lt;/p&gt;&lt;p&gt;2. 云原生多云应用管理平台&lt;/p&gt;&lt;p&gt;3. 开源分布式存储系统&lt;/p&gt;&lt;p&gt;4. 一站式微服务解决方案&lt;/p&gt;&lt;p&gt;5. 简易版 ElasticSearch 客户端&lt;/p&gt;&lt;p&gt;6. 词库生成&lt;/p&gt;&lt;hr/&gt;&lt;h1&gt;01&lt;/h1&gt;&lt;p&gt;&lt;span&gt;低代码可视化平台&lt;/span&gt;&lt;/p&gt;&lt;p&gt;开源项目 openDataV 由开发者 @AnsGoo 开源，这是一个基于 Vue.js 的前端低代码平台，通过可视化拖拽生成大屏数据展示网站。逛逛GitHub 历史盘点过多个可视化平台，可以参考文章：&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzUxNjg4NDEzNA==&amp;amp;mid=2247513708&amp;amp;idx=1&amp;amp;sn=95afd6dac175f0874dadcaf3e23d4f46&amp;amp;chksm=f9a265a5ced5ecb326049427ec4dfea372d4cb30234c021c25a0f12cb0ffeaf427a8a9b197ee&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;可视化项目推荐一&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;可视化项目推荐一&lt;/a&gt;、&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzUxNjg4NDEzNA==&amp;amp;mid=2247501143&amp;amp;idx=1&amp;amp;sn=7899a9db2fad691a259cc7571cb390f1&amp;amp;chksm=f9a2169eced59f88850ff3b3e36279a245e7d6ff15eb170101231083f19d4eb78603de5cf9b9&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;可视化项目推荐二&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;可视化项目推荐二&lt;/a&gt;、&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzUxNjg4NDEzNA==&amp;amp;mid=2247498492&amp;amp;idx=2&amp;amp;sn=823ff5005f42a2ad94349301448d578c&amp;amp;chksm=f9a22935ced5a0235e47ea7eba9fa56d89ad5e4088453c46104e29ce84a5288fa1e3e40849f7&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;可视化项目推荐三&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;可视化项目推荐三&lt;/a&gt;&lt;/p&gt;&lt;p&gt;和很多低代码平台一样，左中右分别对应组件、画布、属性。通过拖拉拽的交互，将组建拖动到画布区域，并且可以调节各种图表的属性，比如颜色、字体大小等等。&lt;/p&gt;&lt;p&gt;&lt;span&gt;编程语言：JavaScript、HTML、CSS&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5453703703703704&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ePw3ZeGRruxLvm4pcNz6JPHCX2TkZc0wMo9xCRERianyXwwAHMFZzxApFjr511moUqWKLdTeaYDj01icCEVb9b2Q/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/p&gt;&lt;p&gt;据开发者描述，openDataV 项目的特殊功能和技术点如下。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5203703703703704&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ePw3ZeGRruxLvm4pcNz6JPHCX2TkZc0w5zYXDJDw5n37mnpS8Er2c8ZRaDLGSagNib4icptDr9biaFYeCSGm8UW6w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/p&gt;&lt;p&gt;开源地址：https://github.com/AnsGoo/openDataV&lt;/p&gt;&lt;h1&gt;02&lt;/h1&gt;&lt;p&gt;&lt;span&gt;云原生多云应用管理平台&lt;/span&gt;&lt;/p&gt;&lt;section&gt;开源项目由开发者 @rainbond 开源，编程语言 Golang，据开发者介绍：&lt;/section&gt;&lt;blockquote class=&quot;js_blockquote_wrap&quot; data-type=&quot;2&quot; data-url=&quot;&quot; data-author-name=&quot;&quot; data-content-utf8-length=&quot;164&quot; data-source-title=&quot;https://www.rainbond.com/docs/quick-start/quick-install&quot;&gt;&lt;section class=&quot;js_blockquote_digest&quot;&gt;&lt;p&gt;&lt;span&gt;Rainbond 是一个云原生多云应用管理平台，使用简单，不需要懂容器、Kubernetes 和底层复杂技术，支持管理多个 Kubernetes 集群，和管理企业应用全生命周期。主要功能包括应用开发环境、应用市场、微服务架构、应用交付、应用运维、应用级多云管理等。使用简单应用一键交付云原生转型
Rainbond 的功能和架构。&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;section class=&quot;blockquote_info js_blockquote_source&quot; data-json=&quot;%7B%22type%22%3A%22out%22%2C%22source%22%3A%22url%22%2C%22digest%22%3A%22%22%2C%22digestLen%22%3A164%2C%22text%22%3A%22Rainbond%20%E6%98%AF%E4%B8%80%E4%B8%AA%E4%BA%91%E5%8E%9F%E7%94%9F%E5%A4%9A%E4%BA%91%E5%BA%94%E7%94%A8%E7%AE%A1%E7%90%86%E5%B9%B3%E5%8F%B0%EF%BC%8C%E4%BD%BF%E7%94%A8%E7%AE%80%E5%8D%95%EF%BC%8C%E4%B8%8D%E9%9C%80%E8%A6%81%E6%87%82%E5%AE%B9%E5%99%A8%E3%80%81Kubernetes%20%E5%92%8C%E5%BA%95%E5%B1%82%E5%A4%8D%E6%9D%82%E6%8A%80%E6%9C%AF%EF%BC%8C%E6%94%AF%E6%8C%81%E7%AE%A1%E7%90%86%E5%A4%9A%E4%B8%AA%20Kubernetes%20%E9%9B%86%E7%BE%A4%EF%BC%8C%E5%92%8C%E7%AE%A1%E7%90%86%E4%BC%81%E4%B8%9A%E5%BA%94%E7%94%A8%E5%85%A8%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E3%80%82%E4%B8%BB%E8%A6%81%E5%8A%9F%E8%83%BD%E5%8C%85%E6%8B%AC%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E3%80%81%E5%BA%94%E7%94%A8%E5%B8%82%E5%9C%BA%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84%E3%80%81%E5%BA%94%E7%94%A8%E4%BA%A4%E4%BB%98%E3%80%81%E5%BA%94%E7%94%A8%E8%BF%90%E7%BB%B4%E3%80%81%E5%BA%94%E7%94%A8%E7%BA%A7%E5%A4%9A%E4%BA%91%E7%AE%A1%E7%90%86%E7%AD%89%E3%80%82%E4%BD%BF%E7%94%A8%E7%AE%80%E5%8D%95%E5%BA%94%E7%94%A8%E4%B8%80%E9%94%AE%E4%BA%A4%E4%BB%98%E4%BA%91%E5%8E%9F%E7%94%9F%E8%BD%AC%E5%9E%8B%5CnRainbond%20%E7%9A%84%E5%8A%9F%E8%83%BD%E5%92%8C%E6%9E%B6%E6%9E%84%E3%80%82%22%2C%22article%22%3A%7B%7D%2C%22hasReportOverSize%22%3Afalse%2C%22editorReportData%22%3A%5B%7B%22id%22%3A%22122333%22%2C%22key%22%3A%2276%22%2C%22len%22%3A1%7D%5D%2C%22from%22%3A%22https%3A%2F%2Fwww.rainbond.com%2Fdocs%2Fquick-start%2Fquick-install%22%7D&quot;&gt;&lt;span class=&quot;blockquote_other&quot;&gt;https://www.rainbond.com/docs/quick-start/quick-install&lt;/span&gt;&lt;/section&gt;&lt;/blockquote&gt;&lt;p&gt;该开源项目提供了详细的文档和教程，感兴趣的可以访问如下链接查看。&lt;/p&gt;&lt;p&gt;入门教程：https://www.rainbond.com/docs/quick-start/quick-install&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5555555555555556&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ePw3ZeGRruxLvm4pcNz6JPHCX2TkZc0wLHDOdNicJKiafgCOyf8PUyNREA9qbpE2AwgsPlu1tLsYRWQ48PI06TBQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.4546296296296296&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ePw3ZeGRruxLvm4pcNz6JPHCX2TkZc0w38J3ZkCfzAib8C4IpN9BWvxODZgIia9CpC20BsrTt2eeaNPZnwicOOJyA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/p&gt;&lt;p&gt;开源地址：https://github.com/goodrain/rainbond&lt;/p&gt;&lt;h1&gt;03&lt;/h1&gt;&lt;p&gt;&lt;span&gt;开源分布式存储系统&lt;/span&gt;&lt;/p&gt;&lt;section&gt;Curve 是网易官宣的第一个进入 CNCF Sandbox 的分布式存储项目。是一款对标国外开源存储 Ceph ，主打高性能、易运维、云原生的开源分布式存储系统，投稿读者介绍：&lt;/section&gt;&lt;blockquote class=&quot;js_blockquote_wrap&quot; data-type=&quot;2&quot; data-url=&quot;&quot; data-author-name=&quot;&quot; data-content-utf8-length=&quot;189&quot; data-source-title=&quot;https://github.com/opencurve/curve&quot;&gt;&lt;section class=&quot;js_blockquote_digest&quot;&gt;&lt;section&gt;&lt;span&gt;可应用于主流的云原生基础设施平台：对接 OpenStack 平台为云主机提供高性能块存储服务；对接 Kubernetes 为其提供 RWO、RWX 等类型的持久化存储卷；对接 PolarFS 作为云原生数据库的高性能存储底座，完美支持云原生数据库的存算分离架构；Curve 也可作为云存储中间件使用 S3 兼容的对象存储作为数据存储引擎，为公有云用户提供高性价比的共享文件存储。&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;section class=&quot;blockquote_info js_blockquote_source&quot; data-json=&quot;%7B%22type%22%3A%22out%22%2C%22source%22%3A%22url%22%2C%22digest%22%3A%22%3Cp%3E%E5%8F%AF%E5%BA%94%E7%94%A8%E4%BA%8E%E4%B8%BB%E6%B5%81%E7%9A%84%E4%BA%91%E5%8E%9F%E7%94%9F%E5%9F%BA%E7%A1%80%E8%AE%BE%E6%96%BD%E5%B9%B3%E5%8F%B0%EF%BC%9A%E5%AF%B9%E6%8E%A5%26nbsp%3BOpenStack%26nbsp%3B%E5%B9%B3%E5%8F%B0%E4%B8%BA%E4%BA%91%E4%B8%BB%E6%9C%BA%E6%8F%90%E4%BE%9B%E9%AB%98%E6%80%A7%E8%83%BD%E5%9D%97%E5%AD%98%E5%82%A8%E6%9C%8D%E5%8A%A1%EF%BC%9B%E5%AF%B9%E6%8E%A5%26nbsp%3BKubernetes%26nbsp%3B%E4%B8%BA%E5%85%B6%E6%8F%90%E4%BE%9B%26nbsp%3BRWO%E3%80%81RWX%26nbsp%3B%E7%AD%89%E7%B1%BB%E5%9E%8B%E7%9A%84%E6%8C%81%E4%B9%85%E5%8C%96%E5%AD%98%E5%82%A8%E5%8D%B7%EF%BC%9B%E5%AF%B9%E6%8E%A5%26nbsp%3BPolarFS%26nbsp%3B%E4%BD%9C%E4%B8%BA%E4%BA%91%E5%8E%9F%E7%94%9F%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E9%AB%98%E6%80%A7%E8%83%BD%E5%AD%98%E5%82%A8%E5%BA%95%E5%BA%A7%EF%BC%8C%E5%AE%8C%E7%BE%8E%E6%94%AF%E6%8C%81%E4%BA%91%E5%8E%9F%E7%94%9F%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E5%AD%98%E7%AE%97%E5%88%86%E7%A6%BB%E6%9E%B6%E6%9E%84%EF%BC%9BCurve%26nbsp%3B%E4%B9%9F%E5%8F%AF%E4%BD%9C%E4%B8%BA%E4%BA%91%E5%AD%98%E5%82%A8%E4%B8%AD%E9%97%B4%E4%BB%B6%E4%BD%BF%E7%94%A8%26nbsp%3BS3%26nbsp%3B%E5%85%BC%E5%AE%B9%E7%9A%84%E5%AF%B9%E8%B1%A1%E5%AD%98%E5%82%A8%E4%BD%9C%E4%B8%BA%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E%EF%BC%8C%E4%B8%BA%E5%85%AC%E6%9C%89%E4%BA%91%E7%94%A8%E6%88%B7%E6%8F%90%E4%BE%9B%E9%AB%98%E6%80%A7%E4%BB%B7%E6%AF%94%E7%9A%84%E5%85%B1%E4%BA%AB%E6%96%87%E4%BB%B6%E5%AD%98%E5%82%A8%E3%80%82%3C%2Fp%3E%22%2C%22digestLen%22%3A189%2C%22text%22%3A%22%22%2C%22article%22%3A%7B%7D%2C%22hasReportOverSize%22%3Afalse%2C%22editorReportData%22%3A%5B%7B%22id%22%3A%22122333%22%2C%22key%22%3A%2276%22%2C%22len%22%3A1%7D%5D%2C%22from%22%3A%22https%3A%2F%2Fgithub.com%2Fopencurve%2Fcurve%22%7D&quot;&gt;&lt;span class=&quot;blockquote_other&quot;&gt;https://github.com/opencurve/curve&lt;/span&gt;&lt;/section&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;span&gt;编程语言：C++&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5944444444444444&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ePw3ZeGRruxLvm4pcNz6JPHCX2TkZc0wjB1ukd8t7maHC8oD8pVOB9N0UKOv9iawfo23HhkU6Bibz18XBxWfneLQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/p&gt;&lt;p&gt;开源地址：https://github.com/opencurve/curve&lt;/p&gt;&lt;h1&gt;04&lt;/h1&gt;&lt;p&gt;&lt;span&gt;一站式微服务解决方案&lt;/span&gt;&lt;/p&gt;&lt;section&gt;本开源项目由腾讯公司的工程师开源，至今已经 2.3k 的 Star。开发者介绍：&lt;/section&gt;&lt;blockquote class=&quot;js_blockquote_wrap&quot; data-type=&quot;2&quot; data-url=&quot;&quot; data-author-name=&quot;&quot; data-content-utf8-length=&quot;186&quot; data-source-title=&quot;Tencent 开发者&quot;&gt;&lt;section class=&quot;js_blockquote_digest&quot;&gt;&lt;section&gt;&lt;span&gt;Spring Cloud Tencent 是腾讯开源的一站式微服务解决方案，它实现了Spring Cloud 标准微服务 SPI，开发者可以基于 Spring Cloud Tencent 快速开发 Spring Cloud 云原生分布式应用。Spring Cloud Tencent 的核心依托腾讯开源的一站式服务发现与治理平台 Polaris，实现各种分布式微服务场景。&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;section class=&quot;blockquote_info js_blockquote_source&quot; data-json=&quot;%7B%22type%22%3A%22out%22%2C%22source%22%3A%22url%22%2C%22digest%22%3A%22%3Cp%3ESpring%26nbsp%3BCloud%26nbsp%3BTencent%26nbsp%3B%E6%98%AF%E8%85%BE%E8%AE%AF%E5%BC%80%E6%BA%90%E7%9A%84%E4%B8%80%E7%AB%99%E5%BC%8F%E5%BE%AE%E6%9C%8D%E5%8A%A1%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%EF%BC%8C%E5%AE%83%E5%AE%9E%E7%8E%B0%E4%BA%86Spring%26nbsp%3BCloud%26nbsp%3B%E6%A0%87%E5%87%86%E5%BE%AE%E6%9C%8D%E5%8A%A1%26nbsp%3BSPI%EF%BC%8C%E5%BC%80%E5%8F%91%E8%80%85%E5%8F%AF%E4%BB%A5%E5%9F%BA%E4%BA%8E%26nbsp%3BSpring%26nbsp%3BCloud%26nbsp%3BTencent%26nbsp%3B%E5%BF%AB%E9%80%9F%E5%BC%80%E5%8F%91%26nbsp%3BSpring%26nbsp%3BCloud%26nbsp%3B%E4%BA%91%E5%8E%9F%E7%94%9F%E5%88%86%E5%B8%83%E5%BC%8F%E5%BA%94%E7%94%A8%E3%80%82Spring%26nbsp%3BCloud%26nbsp%3BTencent%26nbsp%3B%E7%9A%84%E6%A0%B8%E5%BF%83%E4%BE%9D%E6%89%98%E8%85%BE%E8%AE%AF%E5%BC%80%E6%BA%90%E7%9A%84%E4%B8%80%E7%AB%99%E5%BC%8F%E6%9C%8D%E5%8A%A1%E5%8F%91%E7%8E%B0%E4%B8%8E%E6%B2%BB%E7%90%86%E5%B9%B3%E5%8F%B0%26nbsp%3BPolaris%EF%BC%8C%E5%AE%9E%E7%8E%B0%E5%90%84%E7%A7%8D%E5%88%86%E5%B8%83%E5%BC%8F%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%9C%BA%E6%99%AF%E3%80%82%3C%2Fp%3E%22%2C%22digestLen%22%3A186%2C%22text%22%3A%22%22%2C%22article%22%3A%7B%7D%2C%22hasReportOverSize%22%3Afalse%2C%22editorReportData%22%3A%5B%7B%22id%22%3A%22122333%22%2C%22key%22%3A%2276%22%2C%22len%22%3A1%7D%5D%2C%22from%22%3A%22Tencent%20%E5%BC%80%E5%8F%91%E8%80%85%22%7D&quot;&gt;&lt;span class=&quot;blockquote_other&quot;&gt;Tencent 开发者&lt;/span&gt;&lt;/section&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.49537037037037035&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ePw3ZeGRruxLvm4pcNz6JPHCX2TkZc0whCUrudkQIO2xfbTysr4siaiaceqnBl1WWyQO1ianxbeDREG6VgoWp4icmg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/p&gt;&lt;p&gt;开源地址：https://github.com/Tencent/spring-cloud-tencent&lt;/p&gt;&lt;h1&gt;05&lt;/h1&gt;&lt;p&gt;&lt;span&gt;简易版 ElasticSearch 客户端&lt;/span&gt;&lt;/p&gt;&lt;section&gt;本开源项目由 @2316367743 开发者开源，是一个简易版的 ElasticSearch 查询客户端，据开发者介绍：&lt;/section&gt;&lt;blockquote class=&quot;js_blockquote_wrap&quot; data-type=&quot;2&quot; data-url=&quot;&quot; data-author-name=&quot;&quot; data-content-utf8-length=&quot;195&quot; data-source-title=&quot;https://github.com/q2316367743/es-client&quot;&gt;&lt;section class=&quot;js_blockquote_digest&quot;&gt;&lt;section&gt;&lt;span&gt;elasticsearch 的客户端比较出名的就是 elasticsearch head 和 Kibana，但是 elasticsearch head 已经停止更新，且样式老旧，功能不全；而 Kibana 虽功能全面，但是启动麻烦，大部分功能用不上，很不灵活，所以采用 vite2 + vue3 + ts + element-plus 进行开发了一个 elasticsearch 的客户端&lt;/span&gt;。&lt;/section&gt;&lt;/section&gt;&lt;section class=&quot;blockquote_info js_blockquote_source&quot; data-json=&quot;%7B%22type%22%3A%22out%22%2C%22source%22%3A%22url%22%2C%22digest%22%3A%22%3Cp%3Eelasticsearch%26nbsp%3B%E7%9A%84%E5%AE%A2%E6%88%B7%E7%AB%AF%E6%AF%94%E8%BE%83%E5%87%BA%E5%90%8D%E7%9A%84%E5%B0%B1%E6%98%AF%26nbsp%3Belasticsearch%26nbsp%3Bhead%26nbsp%3B%E5%92%8C%26nbsp%3BKibana%EF%BC%8C%E4%BD%86%E6%98%AF%26nbsp%3Belasticsearch%26nbsp%3Bhead%26nbsp%3B%E5%B7%B2%E7%BB%8F%E5%81%9C%E6%AD%A2%E6%9B%B4%E6%96%B0%EF%BC%8C%E4%B8%94%E6%A0%B7%E5%BC%8F%E8%80%81%E6%97%A7%EF%BC%8C%E5%8A%9F%E8%83%BD%E4%B8%8D%E5%85%A8%EF%BC%9B%E8%80%8C%26nbsp%3BKibana%26nbsp%3B%E8%99%BD%E5%8A%9F%E8%83%BD%E5%85%A8%E9%9D%A2%EF%BC%8C%E4%BD%86%E6%98%AF%E5%90%AF%E5%8A%A8%E9%BA%BB%E7%83%A6%EF%BC%8C%E5%A4%A7%E9%83%A8%E5%88%86%E5%8A%9F%E8%83%BD%E7%94%A8%E4%B8%8D%E4%B8%8A%EF%BC%8C%E5%BE%88%E4%B8%8D%E7%81%B5%E6%B4%BB%EF%BC%8C%E6%89%80%E4%BB%A5%E9%87%87%E7%94%A8%26nbsp%3Bvite2%26nbsp%3B%2B%26nbsp%3Bvue3%26nbsp%3B%2B%26nbsp%3Bts%26nbsp%3B%2B%26nbsp%3Belement-plus%26nbsp%3B%E8%BF%9B%E8%A1%8C%E5%BC%80%E5%8F%91%E4%BA%86%E4%B8%80%E4%B8%AA%26nbsp%3Belasticsearch%26nbsp%3B%E7%9A%84%E5%AE%A2%E6%88%B7%E7%AB%AF%E3%80%82%3C%2Fp%3E%22%2C%22digestLen%22%3A195%2C%22text%22%3A%22%22%2C%22article%22%3A%7B%7D%2C%22hasReportOverSize%22%3Afalse%2C%22editorReportData%22%3A%5B%7B%22id%22%3A%22122333%22%2C%22key%22%3A%2276%22%2C%22len%22%3A1%7D%5D%2C%22from%22%3A%22https%3A%2F%2Fgithub.com%2Fq2316367743%2Fes-client%22%7D&quot;&gt;&lt;span class=&quot;blockquote_other&quot;&gt;https://github.com/q2316367743/es-client&lt;/span&gt;&lt;/section&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.4777777777777778&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ePw3ZeGRruxLvm4pcNz6JPHCX2TkZc0wa2wQkVHRoOK8ThefQJTGtkxeenjM7MTm1psI82TfFcTORcDNYpibxMw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.4777777777777778&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ePw3ZeGRruxLvm4pcNz6JPHCX2TkZc0wZ1ticXibWFImPqUMeeALqHAicZnCAiaic7Y9AIA7K6ia3PdRTyeDOawJ843g/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/p&gt;&lt;p&gt;开源地址：https://github.com/q2316367743/es-client&lt;/p&gt;&lt;h1&gt;06&lt;/h1&gt;&lt;p&gt;&lt;span&gt;词库生成&lt;/span&gt;&lt;/p&gt;&lt;p&gt;该开源项目由开发者 @tangshimin 开源，使用编程语言 Kotlin 开发，具开发者介绍：&lt;/p&gt;&lt;p&gt;这个开源项目可以用 MKV 视频或字幕生成词库（单词本），让每个单词都有具体的语境，然后通过语境记忆单词，句子，字幕。&lt;/p&gt;&lt;p&gt;如下图所示，你选择一个 MKV 文件后，就能将该视频的中的字幕生成一个词库，还能够标注出这些词汇属于六级还是牛津等等。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6805555555555556&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ePw3ZeGRruxLvm4pcNz6JPHCX2TkZc0wf5VJiakictkTLQlCxLOJaWZMH9ej30U00jyG84Cm56hKHwqVHTd9Y4icg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/p&gt;&lt;p&gt;开源地址：https://github.com/tangshimin/typing-learner&lt;/p&gt;&lt;section&gt;&lt;span&gt;历史盘点&lt;/span&gt;&lt;/section&gt;&lt;section&gt;逛逛 GitHub 每天推荐一个好玩有趣的开源项目。历史推荐的开源项目已经收录到 GitHub 项目，欢迎 Star：&lt;/section&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;ruby&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__symbol&quot;&gt;https:&lt;/span&gt;/&lt;span class=&quot;code-snippet__regexp&quot;&gt;/github.com/&lt;/span&gt;Wechat-ggGitHub/Awesome-GitHub-Repo&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.8091503267973856&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ePw3ZeGRruzicgHPfCeAsrkT2JZwiaOF05zRiaXr2dUukXKGk8CJwfrXALKJ5l0fLpV2abibCYKb7d8B7vNp2u3iccg/640?wx_fmt=png&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; data-type=&quot;png&quot; data-w=&quot;1530&quot;/&gt;&lt;br/&gt;&lt;/section&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-paragraph-type=&quot;ignored&quot;&gt;&lt;hr/&gt;&lt;/section&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;section&gt;&lt;span&gt;推荐阅读&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;em&gt;&lt;span&gt;1. &lt;/span&gt;&lt;/em&gt;&lt;/span&gt;&lt;span&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzUxNjg4NDEzNA==&amp;amp;mid=2247498662&amp;amp;idx=1&amp;amp;sn=0087c4f3b79ba3420e917e9b42d45eda&amp;amp;chksm=f9a2286fced5a1794eb9a73d0be7c2e16eaceabf3a0420647c40cb4202bd116d9a15dd57c008&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot; hasload=&quot;1&quot; wah-hotarea=&quot;click&quot;&gt;GitHub 上有什么好玩的项目？&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;em&gt;&lt;span&gt;2.&lt;/span&gt;&lt;/em&gt;&lt;span&gt; &lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzUxNjg4NDEzNA==&amp;amp;mid=2247507541&amp;amp;idx=1&amp;amp;sn=79edebda20ac94221aa641090fc9878e&amp;amp;chksm=f9a20d9cced5848a5ba699a819f52907f537e557c10c7bb24bf87b2e0212feecfb06419b2feb&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;推荐一款高颜值网易云播放器&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot; wah-hotarea=&quot;click&quot; hasload=&quot;1&quot;&gt;推荐一款高颜值网易云播放器&lt;/a&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;em&gt;&lt;span&gt;3. &lt;/span&gt;&lt;/em&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzUxNjg4NDEzNA==&amp;amp;mid=2247500031&amp;amp;idx=1&amp;amp;sn=b4349fc85264c255bf9a22e1f25b035a&amp;amp;chksm=f9a21336ced59a20518444a3e2bddb584f6d02266e831546ee5c00935d01d5bd61ed86ab606f&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot; hasload=&quot;1&quot; wah-hotarea=&quot;click&quot;&gt;基于 Spring Boot 的百度云高仿项目&lt;/a&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;em&gt;&lt;span&gt;4. &lt;/span&gt;&lt;/em&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzUxNjg4NDEzNA==&amp;amp;mid=2247498464&amp;amp;idx=1&amp;amp;sn=4f85123d6ca67578ca7bad8f7dc71453&amp;amp;chksm=f9a22929ced5a03ffded2c41fd257d3eb96be02195de3ca66a083177bf5f73e2f418728f7f06&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot; hasload=&quot;1&quot; wah-hotarea=&quot;click&quot;&gt;盘点百度 4 个牛逼哄哄的开源项目&lt;/a&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;172&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;172&quot; data-ratio=&quot;1.005449591280654&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ePw3ZeGRruxW7LMX2Iz5DfjRIbFTS7UROhxibBmicicT0HpjIh1yniaJJibSnLFuicMHRx5NEdiaOh2OOACfr6MvR38ibQ/640?wx_fmt=png&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; data-type=&quot;png&quot; data-w=&quot;734&quot;/&gt;&lt;/section&gt;&lt;/div&gt;

          

          
          &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>fa6eebf5e455202acd81e467de90a1cb</guid>
<title>聊聊 8种 架构模式</title>
<link>https://toutiao.io/k/luf0yh6</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;section&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzUzMTA2NTU2Ng==&amp;amp;mid=2247487551&amp;amp;idx=1&amp;amp;sn=18f64ba49f3f0f9d8be9d1fdef8857d9&amp;amp;chksm=fa496f8ecd3ee698f4954c00efb80fe955ec9198fff3ef4011e331aa37f55a6a17bc8c0335a8&amp;amp;scene=21&amp;amp;token=899450012&amp;amp;lang=zh_CN#wechat_redirect&quot; data-linktype=&quot;1&quot;&gt;&lt;span class=&quot;js_jump_icon h5_image_link&quot; data-positionback=&quot;static&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-croporisrc=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/PxMzT0Oibf4gcAIbmYIy26eeHbictB2RQvpBnEwgsSD9yB5AQz2JHE3a86fo6rKVwgrgdhtRlXrXN2v5VbCIfCZw/0?wx_fmt=jpeg&quot; data-cropx1=&quot;30.64516129032258&quot; data-cropx2=&quot;853.2258064516128&quot; data-cropy1=&quot;38.70967741935483&quot; data-cropy2=&quot;367.7419354838709&quot; data-ratio=&quot;0.3997569866342649&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/JdLkEI9sZfdXia2dn1ggRdtyicWQibkGopv9lXcHlAfRS054nst8Bok8XnB1HQSo9QUCfpnsrA89WcFubo51icvZSQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;823&quot;/&gt;&lt;/span&gt;&lt;/a&gt;&lt;/section&gt;&lt;hr data-tool=&quot;mdnice编辑器&quot;/&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我想这个问题，十个人回答得有十一个答案，因为另外的那一个是大家妥协的结果。哈哈，我理解，架构就是&lt;strong&gt;骨架&lt;/strong&gt; ，如下图所示：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;a target=&quot;_blank&quot; href=&quot;https://mp.weixin.qq.com/s?__biz=MzUzMTA2NTU2Ng==&amp;amp;mid=2247487551&amp;amp;idx=1&amp;amp;sn=18f64ba49f3f0f9d8be9d1fdef8857d9&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;你已选中了添加链接的内容&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; tab=&quot;innerlink&quot; data-linktype=&quot;1&quot;&gt;&lt;span class=&quot;js_jump_icon h5_image_link&quot; data-positionback=&quot;static&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.615625&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/JdLkEI9sZfdXia2dn1ggRdtyicWQibkGopvqT0hZiahuyvDDgJT6P0DeGlPaqmGOPpmWmaaxLBu7x2tbDphHgDKw2A/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;640&quot;/&gt;&lt;/span&gt;&lt;/a&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;人类的身体的支撑是主要由骨架来承担的，然后是其上的肌肉、神经、皮肤。架构对于软件的重要性不亚于骨架对人类身体的重要性。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;基于 Spring Boot + MyBatis Plus + Vue &amp;amp; Element 实现的后台管理系统 + 用户小程序，支持 RBAC 动态权限、多租户、数据权限、工作流、三方登录、支付、短信、商城等功能&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;项目地址：https://gitee.com/zhijiantianya/ruoyi-vue-pro&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;视频教程：https://doc.iocoder.cn/video/&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个问题我问过的面试者不下于数十次，回答五花八门，在我看来，模式就是经验，设计模式就是&lt;strong&gt;设计经验&lt;/strong&gt; ，有了这些经验，我们就能在特定情况下使用特定的设计、组合设计，这样可以大大节省我们的设计时间，提高工作效率。作为一个工作10年以上的老码农，经历的系统架构设计也算不少，接下来，我会把工作中用到的一些架构方面的设计模式分享给大家，望大家少走弯路。总体而言，共有八种，分别是：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;单库单应用模式&lt;/strong&gt; ：最简单的，可能大家都见过&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;内容分发模式&lt;/strong&gt; ：目前用的比较多&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;查询分离模式&lt;/strong&gt; ：对于大并发的查询、业务&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;微服务模式&lt;/strong&gt; ：适用于复杂的业务模式的拆解&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;多级缓存模式&lt;/strong&gt; ：可以把缓存玩的很好&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;分库分表模式&lt;/strong&gt; ：解决单机数据库瓶颈&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;弹性伸缩模式&lt;/strong&gt; ：解决波峰波谷业务流量不均匀的方法之一&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;多机房模式&lt;/strong&gt; ：解决高可用、高性能的一种方法&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;基于 Spring Cloud Alibaba + Gateway + Nacos + RocketMQ + Vue &amp;amp; Element 实现的后台管理系统 + 用户小程序，支持 RBAC 动态权限、多租户、数据权限、工作流、三方登录、支付、短信、商城等功能&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;项目地址：https://gitee.com/zhijiantianya/yudao-cloud&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;视频教程：https://doc.iocoder.cn/video/&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这是最简单的一种设计模式，我们的大部分本科毕业设计、一些小的应用，基本上都是这种模式，这种模式的一般设计见下图：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;a target=&quot;_blank&quot; href=&quot;https://mp.weixin.qq.com/s?__biz=MzUzMTA2NTU2Ng==&amp;amp;mid=2247487551&amp;amp;idx=1&amp;amp;sn=18f64ba49f3f0f9d8be9d1fdef8857d9&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;你已选中了添加链接的内容&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; tab=&quot;innerlink&quot; data-linktype=&quot;1&quot;&gt;&lt;span class=&quot;js_jump_icon h5_image_link&quot; data-positionback=&quot;static&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1.059375&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/JdLkEI9sZfdXia2dn1ggRdtyicWQibkGopv0ichzOS2nlrwCuZh2sfFynnzdunga5OukFjsQA4zb6zgkstPY9T8Tsw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;640&quot;/&gt;&lt;/span&gt;&lt;/a&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如上图所示，这种模式一般只有一个数据库，一个业务应用层，一个后台管理系统，所有的业务都是用过业务层完成的，所有的数据也都是存储在一个数据库中的，好一点会有数据库的同步。虽然简单，但是&lt;strong&gt;也并不是一无是处&lt;/strong&gt; 。&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;优点&lt;/strong&gt; ：结构简单、开发速度快、实现简单，可用于产品的第一版等有原型验证需求、用户少的设计。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;缺点&lt;/strong&gt; ：性能差、基本没有高可用、扩展性差，不适用于大规模部署、应用等生产环境。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;基本上所有的大型的网站都有或多或少的采用这一种设计模式，常见的应用场景是使用CDN技术把网页、图片、CSS、JS等这些静态资源分发到离用户最近的服务器。这种模式的一般设计见下图：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;a target=&quot;_blank&quot; href=&quot;https://mp.weixin.qq.com/s?__biz=MzUzMTA2NTU2Ng==&amp;amp;mid=2247487551&amp;amp;idx=1&amp;amp;sn=18f64ba49f3f0f9d8be9d1fdef8857d9&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;你已选中了添加链接的内容&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; tab=&quot;innerlink&quot; data-linktype=&quot;1&quot;&gt;&lt;span class=&quot;js_jump_icon h5_image_link&quot; data-positionback=&quot;static&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.70625&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/JdLkEI9sZfdXia2dn1ggRdtyicWQibkGopvibswDLx2l3ciaSj4iaBaom8QaIrZgwzH6qxJQwicOdDic7cp0bTaJ4k2WZw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;640&quot;/&gt;&lt;/span&gt;&lt;/a&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如上图所示，这种模式较单库单应用模式多了一个CDN、一个云存储OSS(七牛、又拍等雷同)。一个典型的应用流程(以用户上传、查看图片需求为例)如下：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;上传的时候，用户选择本地机器上的一个图片进行上传&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;程序会把这个图片上传到云存储OSS上，并返回该图片的一个URL&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;程序把这个URL字符串存储在业务数据库中，上传完成。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;查看的时候，程序从业务数据库得到该图片的URL&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;程序通过DNS查询这个URL的图片服务器&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;智能DNS会解析这个URL，得到与用户最近的服务器(或集群)的地址A&lt;/strong&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;然后把服务器A上的图片返回给程序&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;程序显示该图片，查看完成。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;由上可知，这个模式的关键是智能DNS，它能够解析出离用户最近的服务器。运行原理大致是：根据请求者的IP得到请求地点B，然后通过计算或者配置得到与B最近或通讯时间最短的服务器C，然后把C的IP地址返回给请求者。这种模式的优缺点如下：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;优点&lt;/strong&gt; ：资源下载快、无需过多的开发与配置，同时也减轻了后端服务器对资源的存储压力，减少带宽的使用。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;缺点&lt;/strong&gt; ：目前来说OSS，CDN的价格还是稍微有些贵(虽然已经降价好几次了)，只适用于中小规模的应用，另外由于网络传输的延迟、CDN的同步策略等，会有一些一致性、更新慢方面的问题。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;这种模式主要解决单机数据库压力过大，从而导致业务缓慢甚至超时，查询响应时间变长的问题，也包括需要大量数据库服务器计算资源的查询请求。这个可以说是单库单应用模式的升级版本，也是技术架构迭代演进过程中的必经之路。这种模式的一般设计见下图：&lt;/strong&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;a target=&quot;_blank&quot; href=&quot;https://mp.weixin.qq.com/s?__biz=MzUzMTA2NTU2Ng==&amp;amp;mid=2247487551&amp;amp;idx=1&amp;amp;sn=18f64ba49f3f0f9d8be9d1fdef8857d9&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;你已选中了添加链接的内容&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; tab=&quot;innerlink&quot; data-linktype=&quot;1&quot;&gt;&lt;span class=&quot;js_jump_icon h5_image_link&quot; data-positionback=&quot;static&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6515625&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/JdLkEI9sZfdXia2dn1ggRdtyicWQibkGopvG2tKQURic3lOVzIFoVKFr2ey8EeLjCP8h6lZMia2cFqx54LKuD3RFCZg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;640&quot;/&gt;&lt;/span&gt;&lt;/a&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如上图所示，这种模式较单库单应用模式与内容分发模式多了几个部分，一个是&lt;strong&gt;业务数据库的主从分离&lt;/strong&gt; ，一个是&lt;strong&gt;引入了ES&lt;/strong&gt; ，为什么要这样？都解决了哪些痛点，下面具体结合业务需求场景进行叙述。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;场景一：全文关键词检索&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我想这个需求，绝大多数应用都会有，如果使用传统的数据库技术，大部分可能都会使用like这种SQL语句，高级一点可能是先分词，然后通过分词index相关的记录。SQL语句的性能问题与全表扫描机制导致了非常严重的性能问题，现在基本上很少见到。这里的ES是ElasticSearch的缩写，是一种查询引擎，类似的还有Solr等，都差不多的技术，ES较Solr配置简单、使用方便，所以这里选用了它。另外，ES支持横向扩展，理论上没有性能的瓶颈。同时，还支持各种插件、自定义分词器等，可扩展性较强。在这里，使用ES不仅可以替代数据库完成全文检索功能，还可以实现诸如分页、排序、分组、分面等功能。具体的，请同学们自行学习之。那怎么使用呢？一个一般的流程是这样的：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;服务端把一条业务数据落库&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;服务端异步把该条数据发送到ES&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;ES把该条记录按照规则、配置&lt;strong&gt;放入自己的索引库&lt;/strong&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;客户端查询的时候，由服务端把这个&lt;strong&gt;请求发送到ES&lt;/strong&gt; ，得到数据后，根据需求拼装、组合数据，返回给客户端&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;实际中怎么用，还请同学们根据实际情况做组合、取舍。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;场景二：大量的普通查询&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个场景是指我们的业务中的大部分辅助性的查询，如：取钱的时候先查询一下余额，根据用户的ID查询用户的记录，取得该用户最新的一条取钱记录等。我们肯定是要天天要用的，而且用的还非常多。同时呢，我们的写入请求也是非常多的，导致&lt;strong&gt;大量的写入、查询操作压向同一数据库&lt;/strong&gt; ，然后，数据库挂了，系统挂了，领导生气了，被开除了，还不起房贷了，露宿街头了，老婆跟别人跑了，......&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;不敢想，所以要求我们必须分散数据库的压力，一个业界较成熟的方案就是数据库的读写分离，&lt;strong&gt;写的时候入主库，读的时候读从库&lt;/strong&gt; 。这样就把压力分散到不同的数据库了，如果一个读库性能不行，扛不住的话，可以一主多从，横向扩展。可谓是一剂良药啊！那怎么使用呢？一个一般的流程是这样的：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;服务端把一条业务数据落库&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;数据库同步或异步或半同步把该条数据&lt;strong&gt;复制&lt;/strong&gt; 到从库&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;服务端读数据的时候直接去&lt;strong&gt;从库读&lt;/strong&gt; 相应的数据&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;比较简单吧，一些聪明的、爱思考的、上进的同学可能发现问题了，也包括上面介绍的场景一，就是延迟问题，如：数据还没有到从库，我就马上读，那么是读不到的，会发生问题的。对于这个问题，各家公司解决的思路不一样，方法不尽相同。一个普遍的解决方案是：&lt;strong&gt;读不到就读主库&lt;/strong&gt; ，当然这么说也是有前提条件的，但具体的方案这里就不一一展开了，我可能会在接下来的分享中详解各种方案。另外，关于数据库的复制模式，还请同学们自行学习，太多了，这里说不清。该总结一下这种模式的优缺点的了，如下：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;优点&lt;/strong&gt; ：减少数据库的压力，理论上提供无限高的读性能，间接提高业务(写)的性能，专用的查询、索引、全文(分词)解决方案。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;缺点&lt;/strong&gt; ：数据延迟，数据一致性的保证。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上面的模式看似不错，解决了性能问题，我可以不用露宿街头了、老婆还是我的，哈哈。但是软件系统天生的复杂性决定了，除了性能，还有其他诸如高可用、健壮性等大量问题等待我们解决，再加上各个部门间的撕逼、扯皮，更让我们码农雪上加霜，所以&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;继续吧......&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;微服务模式可以说是最近的热点，花花绿绿、大大小小、国内国外的公司都在鼓吹，实践这个模式，可是大部分都没有弄清楚&lt;strong&gt;为什么&lt;/strong&gt; 要这么做，也并不知道这么做有什么&lt;strong&gt;好处、坏处&lt;/strong&gt; ，在这里，我将以我自己的亲身实践说一下我对这个模式的看法，不喜勿喷！随着业务与人员的增加，遇到了如下的问题：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;单机数据库写请求量大量增加，导致数据库压力变大&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;数据库一旦挂了，那么整个业务都挂了&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;业务代码越来越多，都在一个GIT里，越来越难以维护&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;代码腐化严重、臭味越来越浓&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;上线越来越频繁，经常是一个小功能的修改，就要整个大项目要重新编译&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;部门越来越多，该哪个部门改动大项目中的哪个东西，撕逼的厉害&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;其他一些外围系统直接连接数据库，导致一旦数据库结构发生变化，所有的相关系统都要通知，甚至对修改不敏感的系统也要通知&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;每个应用服务器需要开通所有的权限、网络、FTP、各种各样的，因为每个服务器部署的应用都是一样的&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;作为架构师，我已经失去了对这个系统的把控......&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;为了解决上述问题，我司使用了微服务模式，这种模式的一般设计见下图：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;a target=&quot;_blank&quot; href=&quot;https://mp.weixin.qq.com/s?__biz=MzUzMTA2NTU2Ng==&amp;amp;mid=2247487551&amp;amp;idx=1&amp;amp;sn=18f64ba49f3f0f9d8be9d1fdef8857d9&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;你已选中了添加链接的内容&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; tab=&quot;innerlink&quot; data-linktype=&quot;1&quot;&gt;&lt;span class=&quot;js_jump_icon h5_image_link&quot; data-positionback=&quot;static&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1.0171875&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/JdLkEI9sZfdXia2dn1ggRdtyicWQibkGopve48ULyjXbqtZdyxRvOgAVmaV7sV6EBULVJf4XCl1uR8bfCYAcicVMuQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;640&quot;/&gt;&lt;/span&gt;&lt;/a&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如上图所示，我把&lt;strong&gt;业务分块，做了垂直切分，切成一个个独立的系统，每个系统各自衍化，有自己的库、缓存、ES等辅助系统，系统之间的实时交互通过RPC，异步交互通过MQ，通过这种组合，共同完成整个系统功能。&lt;/strong&gt; 那么，这么做是否真的解决上述问题了呢？不玩虚的，一个个来说。对于问题一，由于拆分成了多个子系统，系统的压力被分散了，而各个子系统都有自己的数据库实例，所以数据库的压力变小。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;对于问题二，一个子系统A的数据库挂了，只是影响到系统A和使用系统A的那些功能，不会所有的功能不可用，从而解决一个数据库挂了，导致所有功能不可用的问题。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;问题三、四，也因为拆分得到了解决，各个子系统有自己独立的GIT代码库，不会相互影响。通用的模块可通过库、服务、平台的形式解决。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;问题五，子系统A发生改变，需要上线，那么我只需要编译A，然后上线就可以了，不需要其他系统做同样的事情。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;问题六，顺应了&lt;strong&gt;康威定律&lt;/strong&gt; ，我部门该干什么事、输出什么，也通过服务的形式暴露出来，我部只管把我部的职责、软件功能做好就可以。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;问题七，所有需要我部数据的需求，都通过接口的形式发布出去，客户通过接口获取数据，从而屏蔽了底层数据库结构，甚至数据来源，我部只需保证我部的接口契约没有发生变化即可，新的需求增加新的接口，不会影响老的接口。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;问题八，不同的子系统需要不同的权限，这个问题也优雅的解决了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;问题九，暂时控制住了复杂性，我只需控制好大的方面，定义好系统边界、接口、大的流程，然后再分而治之、逐个击破、合纵连横。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;目前来说，所有问题得到解决！bingo! 但是，还有许多其他的副作用会随之产生，如RPC、MQ的超高稳定性、超高性能，网络延迟，数据一致性等问题，这里就不展开来讲了，太多了，一本书都讲不完。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;另外，对于这个模式来说，最难把握的是&lt;strong&gt;度&lt;/strong&gt; ，切记&lt;strong&gt;不要切分过细&lt;/strong&gt; ，我见过一个功能一个子系统，上百个方法分成上百个子系统的，真的是太过度了。实践中，一个较为可行的方法是：&lt;strong&gt;能不分就不分，除非有非常必要的理由&lt;/strong&gt; ！。&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;优点&lt;/strong&gt; ：相对高性能，可扩展性强，高可用，适合于中等以上规模公司架构。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;缺点&lt;/strong&gt; ：复杂、度不好把握。指不仅需要一个能在高层把控大方向、大流程、总体技术的人，还需要能够针对各个子系统有针对性的开发。把握不好度或者滥用的话，这个模式适得其反！&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;这个模式可以说是应对超高查询压力的一种普遍采用的策略，基本的思想就是在所有链路的地方，能加缓存就加缓存，如下图所示：&lt;/strong&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;a target=&quot;_blank&quot; href=&quot;https://mp.weixin.qq.com/s?__biz=MzUzMTA2NTU2Ng==&amp;amp;mid=2247487551&amp;amp;idx=1&amp;amp;sn=18f64ba49f3f0f9d8be9d1fdef8857d9&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;你已选中了添加链接的内容&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; tab=&quot;innerlink&quot; data-linktype=&quot;1&quot;&gt;&lt;span class=&quot;js_jump_icon h5_image_link&quot; data-positionback=&quot;static&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.86875&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/JdLkEI9sZfdXia2dn1ggRdtyicWQibkGopvib3uuAKRM2Ej4jb8kH8HficL2PyFlf76oFic9PCicqKpSDCmnLSWqJdfyQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;640&quot;/&gt;&lt;/span&gt;&lt;/a&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如上图所示，一般在三个地方加入缓存，一个是客户端处，一个是API网关处，一个是具体的后端业务处，下面分别介绍。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;客户端处缓存&lt;/strong&gt; ：这个地方加缓存可以说是效果最好的---无延迟。因为不用经过长长的网络链条去后端业务处获取数据，从而导致加载时间过长，客户流失等损失。虽然有CDN的支持，但是从客户端到CDN还是有网络延迟的，虽然不大。具体的技术依据不同的客户端而定，对于WEB来讲，有浏览器本地缓存、Cookie、Storage、缓存策略等技术；对于APP来讲，有本地数据库、本地文件、本地内存、进程内缓存支持。以上提到的各种技术有兴趣的同学可以继续展开来学习。如果客户端缓存没有命中，那么就会去后端业务拿数据，一般来讲，都会有个API网关，在这里加缓存也是非常有必要的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;API网关处缓存&lt;/strong&gt; ：这个地方加缓存的好处是不用把请求发送到后方，直接在这里就处理了，然后返回给请求者。常见的技术，如http请求，API网关用的基本都是nginx，可以使用nginx本身的缓存模块，也可以使用Lua+Redis技术定制化。其他的也都大同小异。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;后端业务处&lt;/strong&gt; ：这个我想就不用多说了，大家应该差不多都知道，什么Redis,Memcache,Jvm内等等，不熬述了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;实践中，要结合具体的实际情况，综合利用各级缓存技术，使得各种请求最大程度的在到达后端业务之前就被解决掉，从而减少后端服务压力、减少占用带宽、增强用户体验。至于是否只有这三个地方加缓存，我觉得要活学活用，&lt;strong&gt;心法比剑法重要！&lt;/strong&gt; 总结一下这个模式的优缺点：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;优点&lt;/strong&gt; ：抗住大量读请求，减少后端压力。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;缺点&lt;/strong&gt; ：数据一致性问题较突出，容易发生雪崩，即：如果客户端缓存失效、API网关缓存失效，那么所有的大量请求瞬间压向后端业务系统，后果可想而知。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这种模式主要解决单表写入、读取、存储压力过大，从而导致业务缓慢甚至超时，交易失败，容量不够的问题。一般有水平切分和垂直切分两种，这里主要介绍水平切分。这个模式也是技术架构迭代演进过程中的必经之路。这种模式的一般设计见下图：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;a target=&quot;_blank&quot; href=&quot;https://mp.weixin.qq.com/s?__biz=MzUzMTA2NTU2Ng==&amp;amp;mid=2247487551&amp;amp;idx=1&amp;amp;sn=18f64ba49f3f0f9d8be9d1fdef8857d9&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;你已选中了添加链接的内容&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; tab=&quot;innerlink&quot; data-linktype=&quot;1&quot;&gt;&lt;span class=&quot;js_jump_icon h5_image_link&quot; data-positionback=&quot;static&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.8609375&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/JdLkEI9sZfdXia2dn1ggRdtyicWQibkGopvj7tNBQa8zMePUoOrGJkBIaPzMOdZQeGm4sKFecTlOMoClaT53LIzdA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;640&quot;/&gt;&lt;/span&gt;&lt;/a&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如上图所示红色部分，把一张表分到了几个不同的库中，从而分担压力。是不是很笼统？哈哈，那我们接下来就详细的讲解一下。首先澄清几个概念，如下：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;主机&lt;/strong&gt; ：硬件，指一台物理机，或者虚拟机，有自己的CPU，内存，硬盘等。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;实例&lt;/strong&gt; ：数据库实例，如一个MySQL服务进程。一个主机可以有多个实例，不同的实例有不同的进程，监听不同的端口。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;库&lt;/strong&gt; ：指表的集合，如学校库，可能包含教师表、学生表、食堂表等等，这些表在一个库中。一个实例中可以有多个库。库与库之间用库名来区分。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;表&lt;/strong&gt; ：库中的表，不必多说，不懂的就不用往下看了，不解释。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那么怎么把单表分散呢？到底怎么个分发呢？分发到哪里呢？以下是几个工作中的实践，分享一下：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;主机&lt;/strong&gt; ：这是最主要的也是最重要的点，本质上分库分表是因为计算与存储资源不够导致的，而这种资源主要是由物理机，主机提供的，所以在这里分是最基本的，毕竟没有可用的计算资源，怎么分效果都不是太好的。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;实例&lt;/strong&gt; ：实例控制着连接数，同时受OS限制，CPU、内存、硬盘、网络IO也会受间接影响。会出现热实例的现象，即：有些实例特别忙，有些实例非常的空闲。一个典型的现象是：由于单表反应慢，导致连接池被打满，所有其他的业务都受影响了。这时候，把表分到不同的实例是有一些效果的。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;库&lt;/strong&gt; ：一般是由于单库中最大单表数量的限制，才采取分库。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;表&lt;/strong&gt; ：单表压力过大，索引量大，容量大，单表的锁。据以上，把单表水平切分成不同的表。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;大型应用中，都是一台主机上只有一个实例，一个实例中只有一个库，&lt;strong&gt;库==实例==主机，所以才有了分库分表&lt;/strong&gt; 这个简称。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;既然知道了基本理论，那么具体是怎么做的呢？逻辑是怎么跑的呢？接下来以一个例子来讲解一下。这个需求很简单，用户表(user)，单表数据量1亿，查询、插入、存储都出现了问题，怎么办呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;首先，分析问题，这个明显是由于数据量太大了而导致的问题。其次，设计方案，可以分为10个库，这样每个库的数据量就降到了1KW，单表1KW数据量还是有些大，而且不利于以后量的增长，所以每个库再分100个表，这个每个单表数据量就为10W了，对于查询、索引更新、单表文件大小、打开速度，都有一些益处。接下来，给IT部门打电话，要10台物理机，扩展数据库...... 最后，逻辑实现，这里应该是最有学问的地方。首先是写入数据，需要知道写到哪个分库分表中，读也是一样的，所以，需要有个请求&lt;strong&gt;路由层&lt;/strong&gt; ，负责把请求分发、转换到不同的库表中，一般有路由规则的概念。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;怎么样，简单吧？哈哈，too 那义务。说说这个模式的问题，主要是带来了事务上的问题，因为分库分表，事务完成不了，而&lt;strong&gt;分布式事务&lt;/strong&gt; 又太笨重，所以这里需要有一定的策略，保证在这种情况下事务能够完成。采取的策略如：最终一致性、复制、特殊设计等。再有就是业务代码的改造，一些关联查询要改造，一些单表orderBy的问题需要特殊处理，也包括groupBy语句，如何解决这些副作用不是一句两句能说清楚的，以后有时间，我单独讲讲这些。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;该总结一下这种模式的优缺点的了，如下：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;优点&lt;/strong&gt; ：减少数据库单表的压力。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;缺点&lt;/strong&gt; ：事务保证困难、业务逻辑需要做大量改造。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;这种模式主要解决突发流量的到来，导致无法横向扩展或者横向扩展太慢，进而影响业务，全站崩溃的问题。这个模式是一种相对来说比较高级的技术，也是各个大公司目前都在研究、试用的技术。截至今日，有这种思想的架构师就已经是很不错了，能够拿到较高薪资，更别提那些已经实践过的，甚至实现了底层系统的那些，所以，你懂得...... 这种模式的一般设计见下图：&lt;/strong&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;a target=&quot;_blank&quot; href=&quot;https://mp.weixin.qq.com/s?__biz=MzUzMTA2NTU2Ng==&amp;amp;mid=2247487551&amp;amp;idx=1&amp;amp;sn=18f64ba49f3f0f9d8be9d1fdef8857d9&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;你已选中了添加链接的内容&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; tab=&quot;innerlink&quot; data-linktype=&quot;1&quot;&gt;&lt;span class=&quot;js_jump_icon h5_image_link&quot; data-positionback=&quot;static&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.971875&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/JdLkEI9sZfdXia2dn1ggRdtyicWQibkGopv47CYkADtG2Ajw4X1RssC50ofW079lhlV0P1yTcrAicbgxB4K1CKpHKw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;640&quot;/&gt;&lt;/span&gt;&lt;/a&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如上图所示，多了一个弹性伸缩服务，用来动态的增加、减少实例。原理上非常简单，但是这个模式到底解决什么问题呢？先说说由来和意义。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;每年的双11、六一八或者一些大促到来之前，我们都会为大流量的到来做以下几个方面的工作: 提前准备10倍甚至更多的机器，即使用不上也要放在那里备着，以防万一。这样浪费了大量的资源。每台机器配置、调试、引流，以便让所有的机器都可用。这样浪费了大量的人力、物力，更容易出错。如果机器准备不充分，那么还要加班加点的重复上面的工作。这样做特别容易出错，引来领导的不满，没时间回家陪老婆，然后你的老婆就......(自己想)&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在双十一之后，我们还要人工做缩容，非常的辛苦。一般一年中会有多次促销，那么我们就会一直这样，实在是烦！&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;最严重的，&lt;strong&gt;突然间的大流量爆发，会让我们触不及防&lt;/strong&gt; ，半夜起来扩容是在正常不过的事情，为此，我们偷懒起来，要更多的机器备着，也就出现了大量的cpu利用率为1%的机器。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我相信，如果你是老板一定很&lt;strong&gt;震惊&lt;/strong&gt; 吧！！！哈哈，那么如何改变这种情况呢？请接着看&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;为此，首先把所有的计算资源整合成资源池的概念，然后通过一些策略、监控、服务，动态的从资源池中获取资源，用完后在放回到池子中，供其他系统使用。具体实现上比较成熟的两种资源池方案是VM、docker，每个都有着自己强大的生态。监控的点有CPU、内存、硬盘、网络IO、服务质量等，根据这些，在配合一些预留、扩张、收缩策略，就可以简单的实现自动伸缩。怎么样？是不是很神奇？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;该总结一下这种模式的优缺点的了，如下：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;优点&lt;/strong&gt; ：弹性、随需计算，充分优化企业计算资源。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;缺点&lt;/strong&gt; ：应用要从架构层做到可横向扩展化改造、依赖的底层配套比较多，对技术水平、实力、应用规模要求较高。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这种模式主要解决&lt;strong&gt;不同地区高性能、高可用&lt;/strong&gt; 的问题。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;随着应用用户不断的增加，用户群体分布在全球各地，如果把服务器部署在一个地方，一个机房，比如北京，那么美国的用户使用应用的时候就会特别慢，因为每一个请求都需要通过海底光缆走上个那么一秒钟(预估)左右，这样对用户体验及其不好。怎么办？使用多机房部署。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这种模式的一般设计见下图：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;a target=&quot;_blank&quot; href=&quot;https://mp.weixin.qq.com/s?__biz=MzUzMTA2NTU2Ng==&amp;amp;mid=2247487551&amp;amp;idx=1&amp;amp;sn=18f64ba49f3f0f9d8be9d1fdef8857d9&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;你已选中了添加链接的内容&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; tab=&quot;innerlink&quot; data-linktype=&quot;1&quot;&gt;&lt;span class=&quot;js_jump_icon h5_image_link&quot; data-positionback=&quot;static&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.646875&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/JdLkEI9sZfdXia2dn1ggRdtyicWQibkGopv5PJibrbjdwu0CicdiabL9At2TjnlKKUYOk6KCicj8HH5kaAJsVDEZTJicfw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;640&quot;/&gt;&lt;/span&gt;&lt;/a&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如上图所示，一个典型的用户请求流程如下：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;用户请求一个链接A 通过DNS智能解析到离用户最近的机房B 使用B机房服务链接A&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;是不是觉得很简单，没啥？其实这里面的问题没有表面这么简单，下面一一道来。首先是&lt;strong&gt;数据同步&lt;/strong&gt; 问题，在中国产生的数据要同步到美国，美国的也一样，数据同步就会涉及数据版本、一致性、更新丢弃、删除等问题。其次是一地多机房的请求&lt;strong&gt;路由&lt;/strong&gt; 问题，典型的是如上图，中国的北京机房和杭州机房，如果北京机房挂了，那么要能够通过路由把所有发往北京机房的请求转发到杭州机房。异地也存在这个问题。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以，多机房模式，也就是异地多活并不是那么的简单，这里只是起了个头，具体的有哪些坑，会在另一篇文章中介绍。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;该总结一下这种模式的优缺点的了，如下：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;优点&lt;/strong&gt; ：高可用、高性能、异地多活。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;缺点&lt;/strong&gt; ：数据同步、数据一致性、请求路由。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;至此，整个关于&lt;strong&gt;八种架构设计模式及其优缺点概述&lt;/strong&gt; 就介绍完了，大约1W字左右。最后，我想说的是没有银弹、灵活运用，共勉！&lt;/p&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>58f2ef17e52dc2d96255417a48a1fcd4</guid>
<title>尴尬，在Kafka生产实践中又出问题了</title>
<link>https://toutiao.io/k/guru5it</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;1、背景&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;最近在折腾Kafka日志集群，由于公司部署的应用不断增加，日志采集程序将采集到的日志发送到Kafka集群时出现了较大延迟，总的TPS始终上不去，为了不影响业务团队通过日志排查问题，采取了先解决问题，再排查的做法，对Kafka集群进行扩容，但扩容后尴尬的是新增加的5台机器中，有两台机器的消费发送响应时间比其他机器明显高出不少，为了确保消息服务的稳定性，又临时对集群进行缩容，将这台机器从集群中剔除，&lt;strong&gt;具体的操作就是简单粗暴的使用 kill pid命令&lt;/strong&gt;，但意外发生了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;发现Java客户端报如下错误：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.13125&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Wkp2azia4QFuZrnLUMCOzyvxyeke4CsztSv8w2ARHbdPOP4ETzbfEQdicibmPyaQUOvVwsajtlR1ia0EiaKUEoMMFsA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;而Go客户端报的错误如下所示：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.0796875&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Wkp2azia4QFuZrnLUMCOzyvxyeke4CsztnIyseibAFjbynhbnuCXxbD4MYgMhcmtxpuD3BvP8MNH8LwQAROYXUcQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;基本可以认为是部分分区没有在线Leader,无法成功发送消息。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;2、问题分析&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那为什么会出现这个问题吗？Kafka一个节点下线，不是会自动触发故障转移，分区leader不是会被重新选举吗？请带着这个疑问，开始我们今天的探究之旅。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;首先我们可以先看看当前存在问题的分区的路由信息，从第一张图中看出主题dw_test_kafka_0816000的101分区消息发送失败，我们在Zookeeper中看一下其状态，具体命令如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;./zkCli.sh -server 127.0.0.1:2181&lt;br/&gt;get -s  /kafka_cluster_01/brokers/topics/dw_test_kafka_0816000/partitions/101/state&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;该命令可以看到对应分区的相信信息，如下图所示：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.2831661092530658&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Wkp2azia4QFuZrnLUMCOzyvxyeke4CsztWOBoXN9tJYIGsWfrPNY2BX83W8sGFe9xYFjxmamhd5VX8uWRc472ng/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;897&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里显示出leader的状态为-1,而isr列表中只有一副本，在broker-1上，但此时broker id为1的机器已经下线了，那为什么不会触发分区Leader重新选举呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;其实看到这里，我相信你只要稍微细想一下，就能发现端倪&lt;/strong&gt;，isr字段的值为1,说明该分区的副本数为1，说明该分区只在一个Broker上存储数据，一旦Broker下线，由于集群内其他Broker上并没有该分区的数据，此时是无法进行故障转移的，因为一旦要进行故障转移，分区的数据就会丢失，这样带来的影响将是非常严重的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那为什么该主题的副本数会设置为1呢？那是因为当时集群的压力太大，节点之间复制数据量巨大，网卡基本满负荷在运转，而又是日志集群，对数据的丢失的接受程度较大，故当时为了避免数据在集群之间的大量复制，将该主题的副本数设置为了1。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但集群节点的停机维护是少不了的，总不能每一次停机维护，都会出现一段时间数据写入失败吧。要解决这个问题，我们在停机之前，需要先对主题进行分区移动，将该主题的分区从需要停机的集群中移除。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;主题分区移动的具体做法，请参考我之前的一篇文章&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzIzNzgyMjYxOQ==&amp;amp;mid=2247486692&amp;amp;idx=1&amp;amp;sn=77cb091b9b8095bd162c09472d33a5fb&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;Kafka主题迁移实践&lt;/a&gt; 的第三部分。&lt;/p&gt;&lt;/blockquote&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;3、Kafka节点下线分区的故障转移机制&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Kafka单副本的主题在集群内一台节点下线后，将无法完成分区的故障转移机制，为了深入掌握底层的一些实现细节，我想再深入探究一下kafka节点下线的一些故障转移机制。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;温馨提示：接下来主要是从源码角度深入探究实现原理，加深对这个过程的理解，如果大家不感兴趣，可以直接进入到本文的第4个部分：总结。&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在Kafka中依赖的Zookeeper服务器上存储了当前集群内存活的broker信息，具体的路径为/{namespace}/brokers/brokers/ids，具体图示如下：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.1761467889908257&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Wkp2azia4QFuZrnLUMCOzyvxyeke4CsztXBAGrjEYGflQ8gah2PhASm92iaiaFxU7AA9h1Q7GBmqnHichJtCNyE8Hw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;545&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;并且ids下的每一个节点记录了Broker的一些信息，例如对外提供服务的协议、端口等，值得注意的是这些节点为&lt;strong&gt;临时节点&lt;/strong&gt;，如下图所示：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.30965005302226933&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Wkp2azia4QFuZrnLUMCOzyvxyeke4CsztHibTsbbcXXO4whoHbB9w85MbKq0fkaibsB5fR1Nmia8vrvUnMpqwDj8Sw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;943&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这样一旦对应的Broker宕机下线，对应的节点会删除，Kafka集群内的Controller角色在启动时会监听该节点下节点的变化，并作出响应，最终将会调用KafkaController的onBrokerFailure方法,具体代码如下所示：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.3258536585365854&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Wkp2azia4QFuZrnLUMCOzyvxyeke4Csztoe4atxgVDKRgPEQLXjj3v6c2tQD9egtfMkW87YBEm8PZHw2jaW2NLw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1025&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个方法实现比较复杂，我们在这里不做过多分散，重点查找分区的故障转移机制，也就是接下来我们将具体分析KafkaController的onReplicasBecomeOffline方法，主要探究分区的故障转移机制。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;3.1 onReplicasBecomeOffline故障转移&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;由于该方法实现复杂，接下来将分布对其进行详解。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Step1：从需要设置为下线状态分区进行分组，分组依据为是否需要删除，没有触发删除的集合用newofflineReplicasNotForDeletion表示，需要被删除的集合用newofflineReplicasForDeletion表示。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.3953125&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Wkp2azia4QFuZrnLUMCOzyvxyeke4CsztnOoFIwveGoEByiaFE5jKSL5F7QYCTZZnMGWA5n7cBbFASjlibUn7q6Ew/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Step2：挑选没有Leader的分区，用partitionsWithoutLeader，代码如下图所示：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.35&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Wkp2azia4QFuZrnLUMCOzyvxyeke4Csztu142Nice50ON44GuZXGbZK8LIMNC8h3ZqntgEHsjibFsdRWfsOjcjnHQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;分区没有Leader的标准是：分区的Leader副本所在的Broker没有下线，并且没有被删除。&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Step3：将没有Leader的分区状态变更为OfflinePartition（离线状态）,这里的状态更新是放在kafka Controller中的内存中，具体的内存结构：Map[TopicPartition, PartitionState]。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Step4：Kafka分区状态机驱动(触发）分区状态为OfflinePartition、NewPartition向OnlinePartition转化，状态的转化主要包括两个重要的步骤：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;调用PartitionStateMachine的doHandleStateChanges的方法，驱动分区状态机的转换。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;然后调用ControllerBrokerRequestBatch的sendRequestsToBrokers方法，实现元信息在其他Broker上的同步。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;由于篇幅的问题，我们这篇文章不会体系化的介绍Kafka分区状态机的实现细节，先重点关注OfflinePartition离线状态向OnlinePartition转化过程。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.15859375&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Wkp2azia4QFuZrnLUMCOzyvxyeke4CsztCJGPGNLrvSKDoQexsibvQGxsonZGXDYWANcicJ4Bw2w7ALmhyiaJgmoiag/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们首先说明一下OfflinePartition离线状态向OnlinePartition转化过程时各个参数的含义：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;Seq[TopicPartition] partitions
当前处于OfflinePartition、NewPartition状态、并且没有删除的分区。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;PartitionState targetState
状态驱动的目标状态：OnlinePartition。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;PartitionLeaderElectionStrategy
分区Leader选举策略，这里传入的是OfflinePartitionLeaderElectionStrategy，分区离线状态的Leader选举策略&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里判断一下分区是否有效的依据主要是要根据状态机设置的驱动条件，例如只有分区状态为OnlinePartition、NewPartition、OfflinePartition三个状态才能转换为OnlinePartition。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;接下来重点看变更为OnlinePartition的具体实现逻辑，具体代码如下所示：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.39765625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Wkp2azia4QFuZrnLUMCOzyvxyeke4CsztOm5x9NjVtta5c52wK5OWnWrSaJJnxT44kz3I9RuRMYIoz39HvRLibEg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;具体实现分为3个步骤：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;首先先分别帅选出当前状态为NewPartition的集合与（OfflinePartition或者OnlinePartition）分区。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;状态为NewPartition的分区，执行分区的初始化，通常为分区扩容或主题新创建&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;状态为OfflinePartition或者OnlinePartition的执行分区重新选举，因为这些集合中的分区是当前没有Leader的分区，这些分区暂时无法接受读写请求。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;接下来我们重点看一下离线状态变更为OnlinePartition的分区leader选举实现，具体方法为：PartitionStateMachine的electLeaderForPartitions方法，其代码如下所示：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.41015625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Wkp2azia4QFuZrnLUMCOzyvxyeke4Cszt6DSJXhDbg42VXKXTETGJEzWRTc0UXCOic8PtMYev2HEbDyumdPqylvQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个方法的实现结构比较简单，返回值为两个集合，一个选举成功的集合，一个选举失败的集合，同时选举过程中如果出现&lt;strong&gt;可恢复异常，则会进行重试&lt;/strong&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;具体的重试逻辑由doElectLeaderForPartitions方法实现，该方法非常复杂。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;3.2 分区选举机制&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;分区选举由PartitionStateMachine的doElectLeaderForPartitions方法实现，接下来分步进行讲解。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Step1：首先从Zookeeper中获取需要选举分区的元信息，代码如下所示：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.28842832469775476&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Wkp2azia4QFuZrnLUMCOzyvxyeke4CsztAkCMzUBMVsLMjwAspRvRaYnaKMlPnuCicBwCbum2oyZwIfkyBOwNFvw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1158&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Kafka中主题的路由信息存储在Zookeeper中，具体路径为：/{namespace}/brokers/topics/{topicName}}/partitions/{partition}/state,具体存储的内容如下所示：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.11640625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Wkp2azia4QFuZrnLUMCOzyvxyeke4Cszt6vy3HHX6hw4aWl2VBcFjQamBYcib790Bals4C2XjMra1mD4mMmm4Dlg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Step2：将查询出来的主题分区元信息，组装成Map&amp;lt; TopicPartition, LeaderIsrAndControllerEpoch&amp;gt;的Map结构，代码如下所示：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.34792806880375293&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Wkp2azia4QFuZrnLUMCOzyvxyeke4CszthNx1ZI8oSuGpjUnH6albn0GF5ia8XsrenZjt2olwIiaibSuO1AX46Yo2Q/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1279&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Step3：将分区中的controllerEpoch与当前Kafka Controller的epoch对比，刷选出无效与有效集合，具体代码如下所示：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.22421875&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Wkp2azia4QFuZrnLUMCOzyvxyeke4CsztUgqEqHgtHqvDyiaoibTYGf7hNAloaibD9bEiasj3RfsIohTN2YFxAsEZicA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果当前控制器的controllerEpoch小于分区状态中的controllerEpoch,说明已有新的Broker已取代当前Controller成为集群新的Controller，本次无法进行Leader选取，并且打印日志。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Step4：根据Leader选举策略进行Leader选举，代码如下所示:&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.19765625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Wkp2azia4QFuZrnLUMCOzyvxyeke4Cszt8nfmIdn4NyrWgNALEdJGIoLdSdduDXTLA89wMoybofKaIlMOVLQIrQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;由于我们这次是由OfflinePartition状态向OnlinePartition状态转换，进入的分支为leaderForOffline，稍后我们再详细介绍该方法，经过选举后的返回值为两个集合，其中partitionsWithoutLeaders表示未成功选举出Leader的分区，而partitionsWithLeaders表示成功选举出Leader的分区。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Step5:没有成功选举出Leader的分区打印对应日志，并加入到失败队列集合中，如下图所示：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.1359375&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Wkp2azia4QFuZrnLUMCOzyvxyeke4CsztMUicnTwS9o7w0Miby0SBLemldhxwlfL63N65ttiaN6FxLqdNvev5mZjUA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Step5:将选举结果更新到zookeeper中，如下图所示：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.090625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Wkp2azia4QFuZrnLUMCOzyvxyeke4Cszt9zticbKa66hF7RLC5eNTIC7pSebfdyUf9Rvm8Lzk38gqPTYNwOORJAg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Step6：将最新的分区选举结果同步到其他Broker节点上。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.2078125&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Wkp2azia4QFuZrnLUMCOzyvxyeke4CsztObaYmoxp7Bfj1lje4lIysLCDmECSoFEXK6RJW8MFozKbYGjtGj1tIQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;更新分区状态的请求LEADER_AND_ISR被其他Broker接受后，会根据分区的leader与副本信息，成为该分区的Leader节点或从节点，关于这块的实现细节在专栏的后续文章中会专门提及。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那OfflinePartitionLeaderElectionStrategy选举策略具体是如何进行选举的呢？接下来我们探究其实现细节。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;3.3 OfflinePartitionLeaderElectionStrategy选举策略&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;OfflinePartitionLeaderElectionStrategy的选举策略实现代码见PartitionStateMachine的leaderForOffline，我们还是采取分步探讨的方式。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Step1：主要初始化几个集合，代码如下&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.24140625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Wkp2azia4QFuZrnLUMCOzyvxyeke4CsztEYcVzviccOn8saA6BvlnCzoibw1icUngh7TC95jia6iayic5QtMGQ98E7PIA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;对上面的变量做一个简单介绍：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;partitionsWithNoLiveInSyncReplicas
分区的副本所在的Broker全部不存活&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;partitionsWithLiveInSyncReplicas
分区副本集合所在的broker部分或全部存活&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;partitionsWithUncleanLeaderElectionState
主题是否开启了副本不在isr集合中也可以参与Leader竞选，可在主题级别设置unclean.leader.election.enable，默认为false。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Step2：执行分区Leader选举，具体实现代码如下所示：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.2984375&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Wkp2azia4QFuZrnLUMCOzyvxyeke4CsztngoFeHAkOmhichJ8ibZ2u52QDeB1Qp7yR9DnhVU5YIGjicXFCjYSxSpfw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;首先解释如下几个变量的含义：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;assignment 分区设置的副本集（所在brokerId）&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;liveReplicas 当前在线的副本集&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;具体的选举算法如下所示：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.21328125&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Wkp2azia4QFuZrnLUMCOzyvxyeke4CsztHvhdjZHT01VrOqODQiaMyKjDY7IlB19mXoWj0kmHJR9TrIAAoWg7rVg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;离线转在线的选举算法比较简单：如果unclean.leader.election.enable=false，则从存活的ISR集合中选择第一个成为分区的Leader，如果没有存活的ISR副本，并且unclean.leader.election.enable=true，则选择一个在线的副本，否则返回NONE，表示没有成功选择一个合适的Leader。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;然后返回本次选举的结果，完成本次选举。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;4、总结&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;本文从一个生产实际故障开始进行分析，经过分析得出单副本主题在集群中单台节点下线会引起部分队列无法写入，解决办法是要先执行主题分区移动，也就是将需要停止的broker上所在的分区移动到其他broker上，这个过程并不会对消息发送，消息消费造成影响。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;最后大家如果和我一样，喜欢看看分区故障转移相关实现细节的话，我也带领大家一睹源码，加深对分区选举机制的理解，做到举一反三。&lt;/p&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>