<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>152466dcf8a5a6c4d331d085df506b2c</guid>
<title>Redis碎片整理原理解析与实践</title>
<link>https://toutiao.io/k/wmkid6f</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;span&gt;说实话，我当时脑子的瞬间想法是：&lt;/span&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;业务应该指的是删除期间耗时涨了？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;删除后Redis端的耗时不会涨吧？AOF和RDB也没开，感觉业务那边描述有问题。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;业务服务有异常？判断标准，当时瞄了一眼主调服务有20个，其中只有3个可用性下降。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;带着疑问快速过了下相关指标，得到以下结论：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;确实是删除数据后，耗时上涨了3倍（avg:1ms-&amp;gt;3ms），删除期间整体还好（&lt;strong&gt;略诡异&lt;/strong&gt;，脑子瞬间想到碎片整理，但这个集群的碎片整理cpu参数控制在10%-20%）&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;主调机器确实有异常，但是之前也有问题（可排除）&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Redis Server cpu消耗涨了3倍，但是max=24%，依据经验是没问题的，除非业务对耗时极度敏感。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;综合看，流量无上涨、主调方无变动、删除大量数据、CPU上涨但可容忍（但业务可能不容忍），立刻做了关掉碎片整理的决定，服务瞬间恢复。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;ps: 上述是3分钟内完成的^_^&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;自认为对碎片率、已经相关实践有所了解，但还是出了个问题，于是准备仔细研究下，同时也分享给大家。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;二、什么是Redis内存碎片&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;内存分配器为了更好地管理和重复利用内存，分配策略一般采用固定范围的内存块进行分配。Redis默认使用的是jemalloc在64位系统中将内存空间划分为：小、大、巨大三个范围，每个范围内又划分为多个小的内存块单位：&lt;/p&gt;&lt;section data-tool=&quot;mdnice编辑器&quot;&gt;&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;类型&lt;/th&gt;&lt;th&gt;空间&lt;/th&gt;&lt;th&gt;值&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;小&lt;/td&gt;&lt;td&gt;8&lt;/td&gt;&lt;td&gt;[8]&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;br/&gt;&lt;/td&gt;&lt;td&gt;16&lt;/td&gt;&lt;td&gt;[16，32，48，...，128]&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;br/&gt;&lt;/td&gt;&lt;td&gt;32&lt;/td&gt;&lt;td&gt;[160, 192, 224, 256]&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;br/&gt;&lt;/td&gt;&lt;td&gt;64&lt;/td&gt;&lt;td&gt;[320, 384, 448, 512]&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;br/&gt;&lt;/td&gt;&lt;td&gt;128&lt;/td&gt;&lt;td&gt;[640, 768, 896, 1024]&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;br/&gt;&lt;/td&gt;&lt;td&gt;256&lt;/td&gt;&lt;td&gt;[1280, 1536, 1792, 2048]&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;br/&gt;&lt;/td&gt;&lt;td&gt;512&lt;/td&gt;&lt;td&gt;[2560, 3072, 3584]&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;大&lt;/td&gt;&lt;td&gt;4KB&lt;/td&gt;&lt;td&gt;[4KB，8KB，12KB，...，4072KB]&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;巨&lt;/td&gt;&lt;td&gt;4MB&lt;/td&gt;&lt;td&gt;[4MB，8MB，12MB，...]&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;也就是如果申请一个20字节，那jemalloc会直接申请32字节的空间，这种分配策略必然会有一个问题，有一些散碎的小空间分配不出去（内存碎片），例如(演示需要)&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;(1)  从0开始申请6字节、3字节、3字节、3字节，从图中可以看到，开辟了3*8个字节，但实际使用了(6+3+3+3)字节，空闲了9字节（即为碎片，当然如果有后面有继续申请可能会填满）&lt;/p&gt;&lt;span&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.49513513513513513&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ZULLb8I10cwI9vnic3c981ENdqz9kAXIrP5uwLm1CyhfryDiaL0o88pCd2p2LdI6da1BalhHQD1X3dgxicJWGr3fg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1850&quot;/&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;(2) 开始是填满的，但是删除后空出了一些小空间，后续就无法使用了：&lt;/span&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.46275395033860045&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ZULLb8I10cwI9vnic3c981ENdqz9kAXIr7Paicj6Qw13liaYrOqECARic8cqagRjibMFLQxnWgLl5M6mibzFV2hhiaPdg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1772&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;通常如下情况可能会产生较多的内存碎片：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;大量删除：主动删除(比如上述工单)、被动删除(过期、逐出等)后产生大量内存碎片，导致碎片率上升。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;频繁更新：例如对已经存在的字符串类型键值做append、set扩容（触发sds扩容）操作。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;例如第一节提到的数据删除后，碎片率猛增&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.31564625850340133&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ZULLb8I10cwI9vnic3c981ENdqz9kAXIrgiaFb2jcFMQXMFUyX9wxdvAlpnrIZmxeMhzHuhA6M6pEAV6nibQv2Icw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2940&quot;/&gt;&lt;/figure&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;三、内存碎片的危害&lt;span/&gt;&lt;/h3&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;1. 碎片率&amp;lt;1&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这种情况一般出现在操作系统把Redis内存交换(Swap)到硬盘导致，一定要密切监控这种情况，Redis性能会急剧下降，甚至hang死。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;正确的做法的是，关闭掉swap(&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=Mzg2NTEyNzE0OA==&amp;amp;mid=2247483828&amp;amp;idx=1&amp;amp;sn=cf3381916c0ceead671b0eff32908b25&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;Redis在Linux系统的配置优化&lt;/a&gt;)，大多数看，真死比hang死要好很多。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;2. 碎片率&amp;gt;1&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这种情况说明内存并没有被充分利用，碎片率越高，说明浪费越严重（💰，考虑下1个集群和1万个集群的区别），我们假设有一个日常满的100GB（一主一从）集群，不同碎片率的表现如下：&lt;/p&gt;&lt;section data-tool=&quot;mdnice编辑器&quot;&gt;&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;碎片率&lt;/th&gt;&lt;th&gt;容量&lt;/th&gt;&lt;th&gt;实际占用内存量&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;1.05&lt;/td&gt;&lt;td&gt;100GB * 2&lt;/td&gt;&lt;td&gt;100GB * 2*1.05 = 210GB&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;1.1&lt;/td&gt;&lt;td&gt;100GB * 2&lt;/td&gt;&lt;td&gt;100GB * 2*1.1 = 220GB&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;1.2&lt;/td&gt;&lt;td&gt;100GB * 2&lt;/td&gt;&lt;td&gt;100GB * 2*1.2 = 240GB&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;1.3&lt;/td&gt;&lt;td&gt;100GB * 2&lt;/td&gt;&lt;td&gt;100GB * 2*1.3 = 260GB&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;1.4&lt;/td&gt;&lt;td&gt;100GB * 2&lt;/td&gt;&lt;td&gt;100GB * 2*1.4 = 280GB&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;1.5&lt;/td&gt;&lt;td&gt;100GB * 2&lt;/td&gt;&lt;td&gt;100GB * 2*1.5 = 300GB&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;2&lt;/td&gt;&lt;td&gt;100GB * 2&lt;/td&gt;&lt;td&gt;100GB * 2*2 = 400GB&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;从Redis的内存分配模型看，碎片率是一定存在，但碎片率高到什么程度需要治理，是具体情况具体分析，本文最后会给出一些”最佳实践“&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;四、如何监控Redis内存碎片&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Redis提供info memory命令查看相关内存情况:&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;127.0.0.1&amp;gt; info memory&lt;br/&gt;&lt;span&gt;# Memory&lt;/span&gt;&lt;br/&gt;used_memory:     4285839160&lt;br/&gt;used_memory_rss: 4349640704&lt;br/&gt;mem_fragmentation_ratio:1.01&lt;br/&gt;mem_allocator:jemalloc-5.1.0&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其中有三条指标可以描述碎片率，各自含义如下&lt;/p&gt;&lt;section data-tool=&quot;mdnice编辑器&quot;&gt;&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;指标名&lt;/th&gt;&lt;th&gt;含义&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;used_memory&lt;/td&gt;&lt;td&gt;从Redis角度，Redis占用的内存用量&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;used_memory_rss&lt;/td&gt;&lt;td&gt;从操作系统角度，Redis占用的内存用量&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;mem_fragmentation_ratio&lt;/td&gt;&lt;td&gt;used_memory_rss/used_memory，表示内存碎片率&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/section&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;五、怎么解决内存碎片(Redis版本小于4.0)&lt;span/&gt;&lt;/h3&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;数据对齐：保持键值尽量使用较为固定的长度，说实话这个对业务来说很难做到。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;安全重启&lt;/section&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;slave节点：如无流量，可以重启（一主一从的情况要谨慎，万一重启期间，master挂了。）&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;master节点：如果当前架构可主从切换（例如redis sentinel、redis cluster等），可以尝试（但通常来说主从切换对业务100%有损）&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;li&gt;&lt;section&gt;切换到新集群：新建一个集群，将老集群群整体迁移到新集群（但新集群不久后也会碎片率高）&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;总结：上述方法要不不合实际，要不治标不治本。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;六、怎么解决内存碎片(Redis版本大于等于4.0)&lt;span/&gt;&lt;/h3&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;1. 碎片整理功能：(仅jemalloc支持)&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Redis 4.0 release后，提供了碎片整理功能&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;4.0 RC3&lt;br/&gt;New major feature: Memory de-fragmentation. This feature, contributed by Oran Agra, allows Redis to perform &lt;span&gt;&quot;online defragmentation&quot;&lt;/span&gt; of memory &lt;span&gt;if&lt;/span&gt; the Jemalloc allocator is used. &lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;一图胜过千言万语：经过整理后24字节变为了16字节&lt;/p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.4887940234791889&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ZULLb8I10cwI9vnic3c981ENdqz9kAXIrJYqoVLPx770ViaDTytmZEHN7LicYRrJrOlHjN8EsUzicAdkYGeb99xEpQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1874&quot;/&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;2. 如何开启&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Redis提供了activedefrag配置实现对碎片整理的开启（默认关闭）&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;(1) 启动Redis前添加配置&lt;span/&gt;&lt;/h5&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;activedefrag yes&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;(2) 动态开启&lt;span/&gt;&lt;/h5&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;config &lt;span&gt;set&lt;/span&gt; activedefrag yes (关闭)&lt;br/&gt;config &lt;span&gt;set&lt;/span&gt; activedefrag no (关闭)&lt;br/&gt;config rewrite (记得配置落盘)&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;(3) 动态参数开启(用于测试)&lt;span/&gt;&lt;/h5&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;./redis-server --activedefrag yes&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;3. 相关配置解析&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;为了更好的控制和管理Redis做碎片整理，还提供了多个参数&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;(1)  开启阈值&lt;span/&gt;&lt;/h5&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;active-defrag-ignore-bytes 100mb (默认值)&lt;br/&gt;active-defrag-threshold-lower 10 (默认值)&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;三个条件同时满足：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;activedefrag = yes&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;碎片率大于active-defrag-threshold-lower&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;碎片量大于active-defrag-ignore-bytes&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;if&lt;/span&gt;(frag_pct &amp;lt; server.active_defrag_threshold_lower || frag_bytes &amp;lt; server.active_defrag_ignore_bytes){&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt;;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;(2) 增强系数&lt;span/&gt;&lt;/h5&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;active_defrag_threshold_upper 100（默认值）&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个参数很有迷惑性，好像相对于active-defrag-threshold-lower是碎片整理的上限，其实不是，它是一个增强系数：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;size_t frag_bytes;&lt;br/&gt;//获取碎片率和碎片量&lt;br/&gt;&lt;span&gt;float&lt;/span&gt; frag_pct = getAllocatorFragmentation(&amp;amp;frag_bytes);&lt;br/&gt;int cpu_pct = INTERPOLATE(frag_pct,&lt;br/&gt;                server.active_defrag_threshold_lower,&lt;br/&gt;                server.active_defrag_threshold_upper,&lt;br/&gt;                server.active_defrag_cycle_min,&lt;br/&gt;                server.active_defrag_cycle_max);&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;INTERPOLATE的定义如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;#define INTERPOLATE(x, x1, x2, y1, y2) ( (y1) + ((x)-(x1)) * ((y2)-(y1)) / ((x2)-(x1)) )&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;把公式整理下如下：&lt;/p&gt;&lt;span data-tool=&quot;mdnice编辑器&quot;&gt;&lt;section role=&quot;presentation&quot; data-formula=&quot;y1 + \frac{(x-x1)}{(x2-x1)}*(y2-y1)&amp;#10;&quot; data-formula-type=&quot;block-equation&quot;&gt;&lt;embed src=&quot;https://mmbiz.qpic.cn/mmbiz_svg/X6Ucic5kYIBOO3CzbOEgf4lk6VsBxm8KAwo2gYErt0icKJVJtjld5KZUr5es4pVo1CdfPv0POiacmr0iaFIuOa1YvoNw6RKDHMqU/0?wx_fmt=svg&quot; data-type=&quot;svg+xml&quot;/&gt;&lt;/section&gt;&lt;/span&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;套用公式：&lt;/p&gt;&lt;span data-tool=&quot;mdnice编辑器&quot;&gt;&lt;section role=&quot;presentation&quot; data-formula=&quot;active\_defrag\_cycle\_min + \frac{(frag\_pct-active\_defrag\_threshold\_lower)}{(active\_defrag\_threshold\_upper-active\_defrag\_threshold\_lower)}*(active\_defrag\_cycle\_max-active\_defrag\_cycle\_min)&amp;#10;&quot; data-formula-type=&quot;block-equation&quot;&gt;&lt;embed src=&quot;https://mmbiz.qpic.cn/mmbiz_svg/X6Ucic5kYIBOO3CzbOEgf4lk6VsBxm8KA0tA5tsvTqVPee0Vm9XiatYQbsibheqON6uETn1HG9vibKjSus2qgNB8jCXQ8XJu7Qwt/0?wx_fmt=svg&quot; data-type=&quot;svg+xml&quot;/&gt;&lt;/section&gt;&lt;/span&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可以看到active_defrag_threshold_upper越大，整个值越小，这个值就是用来碎片整理的预估CPU值。&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;(3) 整理粒度&lt;span/&gt;&lt;/h5&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;# active-defrag-cycle-min 25&lt;/span&gt;&lt;br/&gt;&lt;span&gt;# active-defrag-cycle-max 75&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;active-defrag-cycle-min和active-defrag-cycle-max就是每次碎片整理的最小CPU时间和最大CPU时间，上述公式计算得到的cpu_pct还是会被这两个参数限制：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;cpu_pct = LIMIT(cpu_pct, server.active_defrag_cycle_min, server.active_defrag_cycle_max)&lt;br/&gt;&lt;span&gt;#define LIMIT(y, min, max) ((y)&amp;lt;(min)? min: ((y)&amp;gt;(max)? max: (y)))            &lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;需要注意的是，这两个参数在不同版本的Redis默认值不太一样：&lt;/p&gt;&lt;section data-tool=&quot;mdnice编辑器&quot;&gt;&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;参数&lt;/th&gt;&lt;th&gt;4.0.14&lt;/th&gt;&lt;th&gt;5.0.14&lt;/th&gt;&lt;th&gt;6.0.16&lt;/th&gt;&lt;th&gt;6.2.7&lt;/th&gt;&lt;th&gt;7.0.4&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;active-defrag-cycle-min&lt;/td&gt;&lt;td&gt;25&lt;/td&gt;&lt;td&gt;5&lt;/td&gt;&lt;td&gt;1&lt;/td&gt;&lt;td&gt;1&lt;/td&gt;&lt;td&gt;1&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;active-defrag-cycle-max&lt;/td&gt;&lt;td&gt;75&lt;/td&gt;&lt;td&gt;75&lt;/td&gt;&lt;td&gt;25&lt;/td&gt;&lt;td&gt;25&lt;/td&gt;&lt;td&gt;25&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/section&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;(4) 大key优化 (since 5.0.0)&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;碎片整理需要对Redis字典scan，如果在进行中发现set/hash/zset/list/stream的元素个数超过1000，则把这些键值放到一个单独的队列之后进行处理，这样做主要是为了防止碎片整理超时（如果一次scan中包含了很多大的键值，可能在内部已经超时了。）。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;# Maximum number of set/hash/zset/list fields that will be processed from the main dictionary scan&lt;/span&gt;&lt;br/&gt;&lt;span&gt;#active-defrag-max-scan-fields 1000&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;相关代码：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;long defragQuicklist(redisDb *db, dictEntry *kde) {&lt;br/&gt;    robj *ob = dictGetVal(kde);&lt;br/&gt;    quicklist *ql = ob-&amp;gt;ptr;&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (ql-&amp;gt;len &amp;gt; server.active_defrag_max_scan_fields)&lt;br/&gt;        defragLater(db, kde);&lt;br/&gt;    ....&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;long defragZsetSkiplist(redisDb *db, dictEntry *kde) {&lt;br/&gt;    robj *ob = dictGetVal(kde);&lt;br/&gt;    zset *zs = (zset*)ob-&amp;gt;ptr;&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (dictSize(zs-&amp;gt;dict) &amp;gt; server.active_defrag_max_scan_fields)&lt;br/&gt;        defragLater(db, kde);&lt;br/&gt;    ....&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;long defragHash(redisDb *db, dictEntry *kde) {&lt;br/&gt; &lt;span&gt;if&lt;/span&gt; (dictSize(d) &amp;gt; server.active_defrag_max_scan_fields)&lt;br/&gt;        defragLater(db, kde);&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;long defragStream(redisDb *db, dictEntry *kde) {&lt;br/&gt;  ....&lt;br/&gt;    defragLater(db, kde);&lt;br/&gt;    .....&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;long defragSet(redisDb *db, dictEntry *kde) {&lt;br/&gt;  ....&lt;br/&gt;    defragLater(db, kde);&lt;br/&gt;    .....&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;defragLater:&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;//list *defrag_later;&lt;br/&gt;void defragLater(redisDb *db, dictEntry *kde) {&lt;br/&gt;    sds key = sdsdup(dictGetKey(kde));&lt;br/&gt;    listAddNodeTail(db-&amp;gt;defrag_later, key);&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;六、Redis碎片整理原理解析&lt;span/&gt;&lt;/h3&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;1. 什么时候执行&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;碎片整理(activeExpireCycle)在Redis的时间事件中执行，具体路径：serverCron-&amp;gt;databasesCron-&amp;gt;activeExpireCycle&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;serverCron&lt;br/&gt; clientsCron();&lt;br/&gt; .....&lt;br/&gt; databasesCron();&lt;br/&gt;  activeExpireCycle(ACTIVE_EXPIRE_CYCLE_SLOW)&lt;br/&gt;  activeDefragCycle();&lt;br/&gt;  ......&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;相关代码：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;if&lt;/span&gt; (server.active_defrag_enabled)&lt;br/&gt;  activeDefragCycle();&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;2. 执行频率&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;和hz是同步的，默认1秒钟执行十次。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;3. 怎么整理 （以Redis 4代码为例子，Redis 6稍有变化）&lt;span/&gt;&lt;/h4&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;(1) 定期(每秒钟)更新任务超时参数server.active_defrag_running&lt;span/&gt;&lt;/h5&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;run_with_period(1000) {&lt;br/&gt;    size_t frag_bytes;&lt;br/&gt;    &lt;span&gt;float&lt;/span&gt; frag_pct = getAllocatorFragmentation(&amp;amp;frag_bytes);&lt;br/&gt;    &lt;br/&gt;    //前文已经说明&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (!server.active_defrag_running) {&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt;(frag_pct &amp;lt; server.active_defrag_threshold_lower || frag_bytes &amp;lt; server.active_defrag_ignore_bytes)&lt;br/&gt;            &lt;span&gt;return&lt;/span&gt;;&lt;br/&gt;    }&lt;br/&gt;    //前文已经说明&lt;br/&gt;    int cpu_pct = INTERPOLATE(frag_pct, server.active_defrag_threshold_lower, server.active_defrag_threshold_upper, server.active_defrag_cycle_min, server.active_defrag_cycle_max);&lt;br/&gt;    cpu_pct = LIMIT(cpu_pct, server.active_defrag_cycle_min, server.active_defrag_cycle_max);&lt;br/&gt;&lt;br/&gt;  //server.active_defrag_running是执行限定时间的重要因素&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (!server.active_defrag_running || cpu_pct &amp;gt; server.active_defrag_running)&lt;br/&gt;        server.active_defrag_running = cpu_pct;&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;//任务超时时间：争分夺秒&lt;br/&gt;timelimit = 1000000*server.active_defrag_running/server.hz/100;&lt;br/&gt;&lt;span&gt;if&lt;/span&gt; (timelimit &amp;lt;= 0) timelimit = 1;&lt;br/&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;(2) 开始整理&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;针对每一个db进行scan，进行如下回调：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;defragDictBucketCallback：针对每个bucket进行碎片整理&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;defragScanCallback：针对每个dictEntry进行碎片整理&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;timelimit = 1000000*server.active_defrag_running/server.hz/100;&lt;br/&gt;&lt;span&gt;if&lt;/span&gt; (timelimit &amp;lt;= 0) timelimit = 1;&lt;br/&gt;&lt;span&gt;do&lt;/span&gt; {&lt;br/&gt;    cursor = dictScan(db-&amp;gt;dict, cursor, defragScanCallback, defragDictBucketCallback, db);&lt;br/&gt;    //检查是否超时&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (cursor &amp;amp;&amp;amp; (++iterations &amp;gt; 16 || server.stat_active_defrag_hits - defragged &amp;gt; 1000)) {&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; ((ustime() - start) &amp;gt; timelimit) {&lt;br/&gt;            &lt;span&gt;return&lt;/span&gt;;&lt;br/&gt;        }&lt;br/&gt;        iterations = 0;&lt;br/&gt;        defragged = server.stat_active_defrag_hits;&lt;br/&gt;    }&lt;br/&gt;} &lt;span&gt;while&lt;/span&gt;(cursor);&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;defragDictBucketCallback的逻辑：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;void defragDictBucketCallback(void *privdata, dictEntry **bucketref) {&lt;br/&gt;    UNUSED(privdata);&lt;br/&gt;    &lt;span&gt;while&lt;/span&gt;(*bucketref) {&lt;br/&gt;        dictEntry *de = *bucketref, *newde;&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; ((newde = activeDefragAlloc(de))) {&lt;br/&gt;            *bucketref = newde;&lt;br/&gt;        }&lt;br/&gt;        bucketref = &amp;amp;(*bucketref)-&amp;gt;next;&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;defragScanCallback的逻辑&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;void defragScanCallback(void *privdata, const dictEntry *de) {&lt;br/&gt;    int defragged = defragKey((redisDb*)privdata, (dictEntry*)de);&lt;br/&gt;    server.stat_active_defrag_hits += defragged;&lt;br/&gt;    if(defragged)&lt;br/&gt;        server.stat_active_defrag_key_hits++;&lt;br/&gt;    else&lt;br/&gt;        server.stat_active_defrag_key_misses++;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;defragKey对dictEntry中sds key和各个类型的value进行整理(复杂类型就是for循环整理)&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;int defragKey(redisDb *db, dictEntry *de) {&lt;br/&gt;    sds keysds = dictGetKey(de);&lt;br/&gt;&lt;br/&gt;    //整理key sds&lt;br/&gt;    newsds = activeDefragSds(keysds);&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (newsds)&lt;br/&gt;        defragged++, de-&amp;gt;key = newsds;&lt;br/&gt;   ....&lt;br/&gt;&lt;br/&gt;  //整理value robj&lt;br/&gt;    ob = dictGetVal(de);&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; ((newob = activeDefragStringOb(ob, &amp;amp;defragged))) {&lt;br/&gt;        de-&amp;gt;v.val = newob;&lt;br/&gt;        ob = newob;&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (ob-&amp;gt;&lt;span&gt;type&lt;/span&gt; == OBJ_STRING) {&lt;br/&gt;        /* Already handled &lt;span&gt;in&lt;/span&gt; activeDefragStringOb. */&lt;br/&gt;    } &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (ob-&amp;gt;&lt;span&gt;type&lt;/span&gt; == OBJ_LIST) {&lt;br/&gt;        //循环整理quicklist或者ziplist的每个元素 &lt;br/&gt;    } &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (ob-&amp;gt;&lt;span&gt;type&lt;/span&gt; == OBJ_SET) {&lt;br/&gt;        //循环整理&lt;span&gt;hash&lt;/span&gt;或者intset的每个元素 &lt;br/&gt;    } &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (ob-&amp;gt;&lt;span&gt;type&lt;/span&gt; == OBJ_ZSET) {&lt;br/&gt;        //循环整理skiplist或者ziplist的每个元素 &lt;br/&gt;    } &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (ob-&amp;gt;&lt;span&gt;type&lt;/span&gt; == OBJ_HASH) {&lt;br/&gt;        //循环整理&lt;span&gt;hash&lt;/span&gt;或者ziplist的每个元素 &lt;br/&gt;    } &lt;br/&gt;    ....&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; defragged;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;activeDefragSds针对sds可能的碎片进行整理&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;sds activeDefragSds(sds sdsptr) {&lt;br/&gt;    void* ptr = sdsAllocPtr(sdsptr);&lt;br/&gt;    void* newptr = activeDefragAlloc(ptr);&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (newptr) {&lt;br/&gt;        size_t offset = sdsptr - (char*)ptr;&lt;br/&gt;        sdsptr = (char*)newptr + offset;&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; sdsptr;&lt;br/&gt;    }&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; NULL;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;activeDefragAlloc是核心方法，其调用jemalloc相关函数判断是否有整理价值，如需要则重新整理(生成new 释放old)&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;void* activeDefragAlloc(void *ptr) {&lt;br/&gt;    int bin_util, run_util;&lt;br/&gt;    size_t size;&lt;br/&gt;    void *newptr;&lt;br/&gt;    //不值得整理&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt;(!je_get_defrag_hint(ptr, &amp;amp;bin_util, &amp;amp;run_util)) {&lt;br/&gt;        server.stat_active_defrag_misses++;&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; NULL;&lt;br/&gt;    }&lt;br/&gt;    //不值得整理&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (run_util &amp;gt; bin_util || run_util == 1&amp;lt;&amp;lt;16) {&lt;br/&gt;        server.stat_active_defrag_misses++;&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; NULL;&lt;br/&gt;    }&lt;br/&gt;    &lt;br/&gt;    //分配新区域，丢掉老的&lt;br/&gt;    size = zmalloc_size(ptr);&lt;br/&gt;    newptr = zmalloc_no_tcache(size);&lt;br/&gt;    memcpy(newptr, ptr, size);&lt;br/&gt;    zfree_no_tcache(ptr);&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; newptr;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其中int je_get_defrag_hint(void* ptr, int *bin_util, int *run_util)是jemalloc库函数用于判断是否值得整理。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;/* this method was added to jemalloc &lt;span&gt;in&lt;/span&gt; order to &lt;span&gt;help&lt;/span&gt; us understand &lt;span&gt;which&lt;/span&gt;&lt;br/&gt; * pointers are worthwhile moving and &lt;span&gt;which&lt;/span&gt; aren&lt;span&gt;&#x27;t */&lt;br/&gt;int je_get_defrag_hint(void* ptr, int *bin_util, int *run_util);&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;七、核心监控参数和&lt;span/&gt;&lt;/h3&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;1. active_defrag_running&lt;span/&gt;&lt;/h5&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;2. active_defrag_key_hits和active_defrag_key_misses&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;站在每个key的角度看，是否命中碎片整理。&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;3. active_defrag_hits和active_defrag_misses&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;站在每个key-values(如果是复杂数据结构，就可能多次)，是否命中碎片整理。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;例如一个hash键值对，有200个元素，其中有元素要做碎片整理：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;active_defrag_key_hits = 1&lt;br/&gt;active_defrag_hits &amp;gt; 1&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;七、最佳实践&lt;span/&gt;&lt;/h3&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;1. 开不开&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;最“佳”实践&lt;/span&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;如果规模不大、碎片率不高、没专职维护建议关闭，ROI低。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;如果规模大（比如我司100万+个节点），碎片整理的成本效果很明显，”成本优化，降本增效~“&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;img data-ratio=&quot;1.2317073170731707&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ZULLb8I10cwI9vnic3c981ENdqz9kAXIrWcljaglaC6r0m4fAfKVribw2zNe3suN633Kaugz2FbZzvXB6EoGlXwQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;656&quot;/&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;2. 怎么配置&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里重点说下active-defrag-cycle-min和active-defrag-cycle-max，因为设置不当的话可能会影响Redis的性能或者可用性。&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;选择大于4.0版本的Redis，该版本碎片整理处于试验阶段(比如大key问题，但不用惊慌没有大问题(线上数十万实例开启))&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;不要用默认值，建议根据业务场景进行调节，例如本文提到的业务超敏感型业务，可以直接调低或者关掉。Redis的工作线程是非常忙的：各种cron。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;需要注意的是，这两个参数在不同版本的Redis默认值不太一样：&lt;/p&gt;&lt;section data-tool=&quot;mdnice编辑器&quot;&gt;&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;参数&lt;/th&gt;&lt;th&gt;4.0.14&lt;/th&gt;&lt;th&gt;5.0.14&lt;/th&gt;&lt;th&gt;6.0.16&lt;/th&gt;&lt;th&gt;6.2.7&lt;/th&gt;&lt;th&gt;7.0.4&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;active-defrag-cycle-min&lt;/td&gt;&lt;td&gt;25&lt;/td&gt;&lt;td&gt;5&lt;/td&gt;&lt;td&gt;1&lt;/td&gt;&lt;td&gt;1&lt;/td&gt;&lt;td&gt;1&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;active-defrag-cycle-max&lt;/td&gt;&lt;td&gt;75&lt;/td&gt;&lt;td&gt;75&lt;/td&gt;&lt;td&gt;25&lt;/td&gt;&lt;td&gt;25&lt;/td&gt;&lt;td&gt;25&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;最“佳”实践(一定不要用默认值)&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我的线上配置是Redis 6+、active-defrag-cycle-min：5、active-defrag-cycle-max：10&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;3. 怎么开&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;最“佳”实践&lt;/span&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;低峰开：一般是夜间(和业务场景有关，比如海外业务可能就不适合)，但需要配合一定调度能力，Redis并没有提供按时间段开启功能。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;暴力开：降低active-defrag-cycle-min和active-defrag-cycle-max，提高安全系数。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;4.版本选择&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;(1) Redis 4：试验版本，除了大key问题，整体还好，如果用了也不用过渡担心它的稳定性&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;########################### ACTIVE DEFRAGMENTATION #######################&lt;/span&gt;&lt;br/&gt;&lt;span&gt;#&lt;/span&gt;&lt;br/&gt;&lt;span&gt;# WARNING THIS FEATURE IS EXPERIMENTAL. However it was stress tested&lt;/span&gt;&lt;br/&gt;&lt;span&gt;# even in production and manually tested by multiple engineers for some&lt;/span&gt;&lt;br/&gt;&lt;span&gt;# time.&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;(2) Redis5：是碎片整理的第二个版本(例如解决了大key问题)，&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;release note: Active defragmentation version 2&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但它还是试验版本：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;########################### ACTIVE DEFRAGMENTATION #######################&lt;/span&gt;&lt;br/&gt;&lt;span&gt;#&lt;/span&gt;&lt;br/&gt;&lt;span&gt;# WARNING THIS FEATURE IS EXPERIMENTAL. However it was stress tested&lt;/span&gt;&lt;br/&gt;&lt;span&gt;# even in production and manually tested by multiple engineers for some&lt;/span&gt;&lt;br/&gt;&lt;span&gt;# time.&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;(3) 大于Redis 6：正式版&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;没了EXPERIMENTAL的标识&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;最“佳”实践&lt;/span&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;最好选择Redis 6以上版本，毕竟是正式版。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;如果选择了Redis 4、5版本，也不用过渡惊慌，基本还好。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;在整体碎片率上，Redis 6确实高于Redis 3、4，下面是一组数据：&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;section data-tool=&quot;mdnice编辑器&quot;&gt;&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;&lt;br/&gt;&lt;/th&gt;&lt;th&gt;实例数&lt;/th&gt;&lt;th&gt;平均碎片率&lt;/th&gt;&lt;th&gt;jemalloc版本&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;Redis 3.0.5&lt;/td&gt;&lt;td&gt;2235&lt;/td&gt;&lt;td&gt;1.28&lt;/td&gt;&lt;td&gt;jemalloc-3.6.0&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;Redis 4.0.14&lt;/td&gt;&lt;td&gt;451361&lt;/td&gt;&lt;td&gt;1.156&lt;/td&gt;&lt;td&gt;jemalloc-4.0.3&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;Redis 6.0.15&lt;/td&gt;&lt;td&gt;623632&lt;/td&gt;&lt;td&gt;1.112&lt;/td&gt;&lt;td&gt;jemalloc-5.1.0&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;(1) Redis 3采样较少，可以忽略&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;(2) Redis 4、6如无特殊均开启碎片整理&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;(3) Redis 6的碎片率比Redis 4确实低了一丢丢&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;(4) 不同版本的jemalloc不同，猜测肯定越来越优秀(这块了解不多，正在学习，请了解的大佬指教)&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;5. 怎么监控&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;最“佳”实践&lt;/span&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;实例、集群、全局数据收集、监控图、报警策略：active_defrag_running、active_defrag_key_hits|misses、active_defrag_hits|misses&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;”时刻“监控used_cpu_*&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;核心日志：但注意对于Redis来说打印太多日志不是什么好事情&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;6. memory purge命令清理&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;除了碎片整理配置，也可以通过如下命令实现&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;127.0&lt;/span&gt;&lt;span&gt;.0&lt;/span&gt;&lt;span&gt;.1&lt;/span&gt;:&lt;span&gt;6379&lt;/span&gt;&amp;gt; memory purge&lt;br/&gt;OK&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但需要注意的是，他和defrag不同的是，它们的不是作用在同一块内存，memory purge主要用于清理脏页：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;int &lt;span&gt;&lt;span&gt;jemalloc_purge&lt;/span&gt;&lt;/span&gt;() {&lt;br/&gt;    /* &lt;span&gt;return&lt;/span&gt; all unused (reserved) pages to the OS */&lt;br/&gt;    char tmp[32];&lt;br/&gt;    unsigned narenas = 0;&lt;br/&gt;    size_t sz = sizeof(unsigned);&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (!je_mallctl(&lt;span&gt;&quot;arenas.narenas&quot;&lt;/span&gt;, &amp;amp;narenas, &amp;amp;sz, NULL, 0)) {&lt;br/&gt;        sprintf(tmp, &lt;span&gt;&quot;arena.%d.purge&quot;&lt;/span&gt;, narenas);&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (!je_mallctl(tmp, NULL, 0, NULL, 0))&lt;br/&gt;            &lt;span&gt;return&lt;/span&gt; 0;&lt;br/&gt;    }&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; -1;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;通过原理以及实际场景看，memory purge的整理效果是没有defrag明显的，如果有需要可以结合使用。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;7. 一些“谣言”和&quot;错误&quot;&lt;span/&gt;&lt;/h4&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;(1) 1 &amp;lt; mem_fragmentation_ratio &amp;lt; 1.5 ,可以认为是合理的，无需处理&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个和规模有关，如果规模较大，你能视而不见吗？&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;(2) active-defrag-max-scan-fields配置的含义&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;错误：直译&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;# 碎片整理期间，对于 List/Set/Hash/ZSet 类型元素一次 Scan 的数量&lt;/span&gt;&lt;br/&gt;&lt;span&gt;# Maximum number of set/hash/zset/list fields that will be processed from the main dictionary scan&lt;/span&gt;&lt;br/&gt;&lt;span&gt;# active-defrag-max-scan-fields 1000&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;正确：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;对于List/Set/Hash/ZSet类型元素数量大于XX，则不在scan dict中完成，通过上文我们知道有一个单独的队列，防止超时。&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;(3) active_defrag_threshold_upper配置的含义&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个参数很有迷惑性，好像相对于active-defrag-threshold-lower是碎片整理的上限，其实不是，它是一个增强系数，这个网上好多解释有问题。&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;(4)  frag_pct 等同于 mem_fragmentation_ratio？&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;错误：它两是一回事&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;正确：它们不完全相等，可以看下源码中的描述，&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;float&lt;/span&gt; getAllocatorFragmentation(size_t *out_frag_bytes) {&lt;br/&gt;    size_t epoch = 1, allocated = 0, resident = 0, active = 0, sz = sizeof(size_t);&lt;br/&gt;    ......&lt;br/&gt;    //stats.resident与操作系统的RSS不同，它不包含共享库和other non heap mappings&lt;br/&gt;    je_mallctl(&lt;span&gt;&quot;stats.resident&quot;&lt;/span&gt;, &amp;amp;resident, &amp;amp;sz, NULL, 0);&lt;br/&gt;    &lt;br/&gt;    //stats.active和stats.resident 不同，它不包含jemalloc保留以供重用的页面&lt;br/&gt;    je_mallctl(&lt;span&gt;&quot;stats.active&quot;&lt;/span&gt;, &amp;amp;active, &amp;amp;sz, NULL, 0);&lt;br/&gt;    &lt;br/&gt;    //stats.allocated与zmalloc_used_memory 不同，它通过考虑此进程完成的所有分配&lt;br/&gt;    je_mallctl(&lt;span&gt;&quot;stats.allocated&quot;&lt;/span&gt;, &amp;amp;allocated, &amp;amp;sz, NULL, 0);&lt;br/&gt;    &lt;span&gt;float&lt;/span&gt; frag_pct = ((&lt;span&gt;float&lt;/span&gt;)active / allocated)*100 - 100;&lt;br/&gt;    size_t frag_bytes = active - allocated;&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; frag_pct;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>1dae447415c9ed528125a1673bd75bfd</guid>
<title>从原则、方案、策略及难点阐述分库分表</title>
<link>https://toutiao.io/k/6u20gmf</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content                                       &quot; id=&quot;js_content&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot; data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;img data-ratio=&quot;1.0285714285714285&quot; data-type=&quot;png&quot; data-w=&quot;70&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/9YmUctibIWGRG39U9npALUmvibgRFaqtX7ictTddL5iaCCNJ07CZXoWytE91y43pLcfLdvmIsEqGBMiadOicts5U9D0A/640?wx_fmt=png&quot;/&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p data-mid=&quot;&quot;&gt;点击上方&lt;span data-mid=&quot;&quot;&gt;蓝字&lt;/span&gt;关注我们&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.6666666666666666&quot; data-type=&quot;jpeg&quot; data-w=&quot;960&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/xicWYTSICzRsgbRXe9nDaFh5J0QIAEcTD9W8m3sIaKxl5SPicqnOyGGJmia8bp3Q4AMkZhkAObQmv8LfeHEv0FgBQ/640?wx_fmt=jpeg&quot;/&gt;&lt;/p&gt;&lt;h3&gt;、分库分表原则&lt;/h3&gt;&lt;p&gt;关系型数据库本身比较容易成为系统性能瓶颈，单机存储容量、连接数、处理能力等都很有限，数据库本身的“有状态性”导致了它并不像Web和应用服务器那么容易扩展。在互联网行业海量数据和高并发访问的考验下，聪明的技术人员提出了分库分表技术（有些地方也称为Sharding、分片）。同时，流行的分布式系统中间件（例如MongoDB、ElasticSearch等）均自身友好支持Sharding，其原理和思想都是大同小异的。&lt;/p&gt;&lt;p&gt;目前针对海量数据的优化，其分库分表是MySQL永远的话题，一般情况下认为MySQL是个简单的数据库，在数据量大到一定程度之后处理查询的效率降低，如果需要继续保持高性能运转的话，必须分库或者分表了。关于数据量达到多少大是个极限这个事儿，本文先不讨论，研究源码的同学已经证实MySQL或者Innodb内部的锁粒度太大的问题大大限制了MySQL提供QPS的能力或者处理大规模数据的能力。在这点上，一般的使用者只好坐等官方不断推出的优化版本了。&lt;/p&gt;&lt;p&gt;在一般运维的角度来看，我们什么情况下需要考虑分库分表？&lt;/p&gt;&lt;p&gt;首先说明，这里所说的分库分表是指把数据库数据的物理拆分到多个实例或者多台机器上去，而不是类似分区表的原地切分。&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;原则零：能不分就不分&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;是的，MySQL 是关系数据库，数据库表之间的关系从一定的角度上映射了业务逻辑。任何分库分表的行为都会在某种程度上提升业务逻辑的复杂度，数据库除了承载数据的存储和访问外，协助业务更好的实现需求和逻辑也是其重要工作之一。分库分表会带来数据的合并，查询或者更新条件的分离，事务的分离等等多种后果，业务实现的复杂程度往往会翻倍或者指数级上升。所以，在分库分表之前，不要为分而分，去做其他力所能及的事情吧，例如升级硬件，升级，升级网络，升级数据库版本，读写分离，负载均衡等等。所有分库分表的前提是，这些你已经尽力了。&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;原则一：数据量太大，正常的运维影响正常业务访问&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;这里说的运维，例如：&lt;/p&gt;&lt;p&gt;1）对数据库的备份。如果单表或者单个实例太大，在做备份的时候需要大量的磁盘IO或者网络IO资源。例如1T的数据，网络传输占用50MB的时候，需要20000秒才能传输完毕，在此整个过程中的维护风险都是高于平时的。我们在Qunar的做法是给所有的数据库机器添加第二块网卡，用来做备份，或者SST，Group Communication等等各种内部的数据传输。1T的数据的备份，也会占用大量的磁盘IO，如果是SSD还好，当然这里忽略某些厂商的产品在集中IO的时候会出一些BUG的问题。如果是普通的物理磁盘，则在不限流的情况下去执行xtrabackup，该实例基本不可用。&lt;/p&gt;&lt;p&gt;2）对数据表的修改。如果某个表过大，对此表做DDL的时候，MySQL会锁住全表，这个时间可能很长，在这段时间业务不能访问此表，影响甚大。解决的办法有类似腾讯游戏DBA自己改造的可以在线秒改表，不过他们目前也只是能添加字段而已，对别的DDL还是无效；或者使用pt-online-schema-change，当然在使用过程中，它需要建立触发器和影子表，同时也需要很长很长的时间，在此操作过程中的所有时间，都可以看做是风险时间。把数据表切分，总量减小，有助于改善这种风险。&lt;/p&gt;&lt;p&gt;3）整个表热点，数据访问和更新频繁，经常有锁等待，你又没有能力去修改源码，降低锁的粒度，那么只会把其中的数据物理拆开，用空间换时间，变相降低访问压力。&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;原则二：表设计不合理，需要对某些字段垂直拆分&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;这里举一个例子，如果你有一个用户表，在最初设计的时候可能是这样：&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;properties&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;       &lt;span class=&quot;code-snippet__attr&quot;&gt;id&lt;/span&gt;                   &lt;span class=&quot;code-snippet__string&quot;/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__attr&quot;&gt;bigint&lt;/span&gt; &lt;span class=&quot;code-snippet__string&quot;/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__attr&quot;&gt;name&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__attr&quot;&gt;varchar&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__attr&quot;&gt;last_login_time&lt;/span&gt;      &lt;span class=&quot;code-snippet__string&quot;/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__attr&quot;&gt;datetime&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;       &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__attr&quot;&gt;personal&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__attr&quot;&gt;_info&lt;/span&gt;    &lt;span class=&quot;code-snippet__string&quot;/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__attr&quot;&gt;text&lt;/span&gt;   &lt;span class=&quot;code-snippet__string&quot;/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__attr&quot;&gt;xxxxx&lt;/span&gt;                                 &lt;span class=&quot;code-snippet__string&quot;/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;设想情况一：你的业务中彩了，用户数从100w飙升到10个亿。你为了统计活跃用户，在每个人登录的时候都会记录一下他的最近登录时间。并且的用户活跃得很，不断的去更新这个login_time，搞的你的这个表不断的被update，压力非常大。那么，在这个时候，只要考虑对它进行拆分，站在业务的角度，最好的办法是先把last_login_time拆分出去，我们叫它 user_time。这样做，业务的代码只有在用到这个字段的时候修改一下就行了。如果你不这么做，直接把users表水平切分了，那么，所有访问users表的地方，都要修改。或许你会说，我有proxy，能够动态merge数据。到目前为止我还从没看到谁家的proxy不影响性能的。&lt;/p&gt;&lt;p&gt;设想情况二：personal_info这个字段本来没啥用，你就是让用户注册的时候填一些个人爱好而已，基本不查询。一开始的时候有它没它无所谓。但是到后来发现两个问题，一，这个字段占用了大量的空间，因为是text嘛，有很多人喜欢长篇大论地介绍自己。更糟糕的是二，不知道哪天哪个产品经理心血来潮，说允许个人信息公开吧，以方便让大家更好的相互了解。那么在所有人猎奇窥私心理的影响下，对此字段的访问大幅度增加。数据库压力瞬间抗不住了，这个时候，只好考虑对这个表的垂直拆分了。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;原则三：某些数据表出现了无穷增长&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;例子很好举，各种的评论，消息，日志记录。这个增长不是跟人口成比例的，而是不可控的，例如微博的feed的广播，我发一条消息，会扩散给很多很多人。虽然主体可能只存一份，但不排除一些索引或者路由有这种存储需求。这个时候，增加存储，提升机器配置已经苍白无力了，水平切分是最佳实践。拆分的标准很多，按用户的，按时间的，按用途的，不在一一举例。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;原则四：安全性和可用性的考虑&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;这个很容易理解，鸡蛋不要放在一个篮子里，我不希望我的数据库出问题，但我希望在出问题的时候不要影响到100%的用户，这个影响的比例越少越好，那么，水平切分可以解决这个问题，把用户，库存，订单等等本来同统一的资源切分掉，每个小的数据库实例承担一小部分业务，这样整体的可用性就会提升。这对Qunar这样的业务还是比较合适的，人与人之间，某些库存与库存之间，关联不太大，可以做一些这样的切分。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;原则五：业务耦合性考虑&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;这个跟上面有点类似，主要是站在业务的层面上，我们的火车票业务和烤羊腿业务是完全无关的业务，虽然每个业务的数据量可能不太大，放在一个MySQL实例中完全没问题，但是很可能烤羊腿业务的DBA 或者开发人员水平很差，动不动给你出一些幺蛾子，直接把数据库搞挂。这个时候，火车票业务的人员虽然技术很优秀，工作也很努力，照样被老板打屁股。解决的办法很简单:惹不起，躲得起。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;h3&gt;二、分库分表方案&lt;/h3&gt;&lt;p&gt;垂直拆分常见有垂直分库和垂直分表两种。垂直分表在日常开发和设计中比较常见，通俗的说法叫做“大表拆小表”，拆分是基于关系型数据库中的“列”（字段）进行的。通常情况，某个表中的字段比较多，可以新建立一张“扩展表”，将不经常使用或者长度较大的字段拆分出去放到“扩展表”中，如下图所示：&lt;/p&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.48048780487804876&quot; data-type=&quot;png&quot; data-w=&quot;410&quot; title=&quot;从原则、方案、策略及难点阐述分库分表&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/xicWYTSICzRsgbRXe9nDaFh5J0QIAEcTDN9eYPyn7PNv8hVk4WMozDjxkOaTiaibJsc7oe7FlIJGiaibDvfzC2qMCWA/640?wx_fmt=png&quot;/&gt;&lt;/p&gt;&lt;p&gt;在字段很多的情况下，拆分开确实更便于开发和维护（笔者曾见过某个遗留系统中，一个大表中包含100多列的）。某种意义上也能避免“跨页”的问题（MySQL、MSSQL底层都是通过“数据页”来存储的，“跨页”问题可能会造成额外的性能开销，这里不展开，感兴趣的朋友可以自行查阅相关资料进行研究）。&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;拆分字段的操作建议在数据库设计阶段就做好。如果是在发展过程中拆分，则需要改写以前的查询语句，会额外带来一定的成本和风险，建议谨慎。&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;垂直分库是根据数据库里面的数据表的相关性进行拆分，比如：一个数据库里面既存在用户数据，又存在订单数据，那么垂直拆分可以把用户数据放到用户库、把订单数据放到订单库。垂直分表是对数据表进行垂直拆分的一种方式，常见的是把一个多字段的大表按常用字段和非常用字段进行拆分，每个表里面的数据记录数一般情况下是相同的，只是字段不一样，使用主键关联。&lt;/p&gt;&lt;p&gt;另外，在“微服务”盛行的今天已经非常普及了，按照业务模块来划分出不同的数据库，也是一种垂直拆分。而不是像早期一样将所有的数据表都放到同一个数据库中。如下图：&lt;/p&gt;&lt;p&gt;&lt;img data-ratio=&quot;1.029090909090909&quot; data-type=&quot;jpeg&quot; data-w=&quot;275&quot; title=&quot;从原则、方案、策略及难点阐述分库分表&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/xicWYTSICzRsgbRXe9nDaFh5J0QIAEcTDbD7pOq0vf7WibrjQEACJXKCiavwQ2gVl9VJcLBviaTn9jLfHTr39jjOEQ/640?wx_fmt=jpeg&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;垂直拆分优点：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;垂直拆分缺点：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;垂直拆分小结：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;系统层面的“服务化”拆分操作，能够解决业务系统层面的耦合和性能瓶颈，有利于系统的扩展维护。而数据库层面的拆分，道理也是相通的。与服务的“治理”和“降级”机制类似，我们也能对不同业务类型的数据进行“分级”管理、维护、监控、扩展等。&lt;/p&gt;&lt;p&gt;众所周知，数据库往往最容易成为应用系统的瓶颈，而数据库本身属于“有状态”的，相对于Web和应用服务器来讲，是比较难实现“横向扩展”的。数据库的连接资源比较宝贵且单机处理能力也有限，在高并发场景下，垂直分库一定程度上能够突破IO、连接数及单机硬件资源的瓶颈，是大型分布式系统中优化数据库架构的重要手段。&lt;/p&gt;&lt;p&gt;然后，很多人并没有从根本上搞清楚为什么要拆分，也没有掌握拆分的原则和技巧，只是一味的模仿大厂的做法。导致拆分后遇到很多问题（例如：跨库join，分布式事务等）。&lt;/p&gt;&lt;p&gt;水平拆分是通过某种策略将数据分片来存储，分为库内分表和分库分表两部分，每片数据会分散到不同的MySQL表或库，达到分布式的效果，能够支持非常大的数据量。&lt;/p&gt;&lt;p&gt;库内分表，仅仅是单纯的解决了单一表数据过大的问题，由于没有把表的数据分布到不同的机器上，因此对于减轻 MySQL 服务器的压力来说，并没有太大的作用，大家还是竞争同一个物理机上的 IO、CPU、网络，这个就要通过分库分表来解决。&lt;/p&gt;&lt;p&gt;最常见的方式就是通过主键或者时间等字段进行Hash和取模后拆分。如下图所示：&lt;/p&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.4957983193277311&quot; data-type=&quot;png&quot; data-w=&quot;476&quot; title=&quot;从原则、方案、策略及难点阐述分库分表&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/xicWYTSICzRsgbRXe9nDaFh5J0QIAEcTDMHrcgDklvUJfOknXbibhUl1wicbQxaiatuVjtibkvrlbMWNsaS1ibDHczLg/640?wx_fmt=png&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;当下分表有静态分表和动态分表两种：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;静态分表&lt;/span&gt;：事先估算出表能达到的量，然后根据每一个表需要存多少数据直接算出需要创建表的数量。如：1亿数据每一个表100W条数据那就要建100张表，然后通过一定的hash算法计算每一条数据存放在那张表。其实就有点像是使用partition table一样。静态分表有一个毙命就是当分的那么多表还不满足时，需要再扩展难度和成本就会很高。&lt;/p&gt;&lt;p&gt;&lt;span&gt;动态分表&lt;/span&gt;：同样也是对大数据量的表进行拆分，他可以避免静态分表带来的后遗症。当然也需要在设计上多一些东西（这往往是我们能接受的）。&lt;/p&gt;&lt;p&gt;某种意义上来讲，有些系统中使用的“冷热数据分离”（将一些使用较少的历史数据迁移到其他的数据库中。而在业务功能上，通常默认只提供热点数据的查询），也是类似的实践。在高并发和海量数据的场景下，分库分表能够有效缓解单机和单库的性能瓶颈和压力，突破IO、连接数、硬件资源的瓶颈。当然，投入的硬件成本也会更高。同时，这也会带来一些复杂的技术问题和挑战（例如：跨分片的复杂查询，跨分片事务等）。&lt;/p&gt;&lt;p&gt;&lt;span&gt;水平拆分优点:&lt;/span&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;不存在单库大数据和高并发的性能瓶颈。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;应用端改造较少。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;提高了系统的稳定性和负载能力。&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;span&gt;水平拆分缺点：&lt;/span&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;分片事务一致性难以解决。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;跨节点 Join 性能差，逻辑复杂。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;数据多次扩展难度跟维护量极大。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3&gt;三、分库分表难点&lt;/h3&gt;&lt;p&gt;垂直分库带来的问题和解决思路：&lt;/p&gt;&lt;p&gt;在拆分之前，系统中很多列表和详情页所需的数据是可以通过sql join来完成的。而拆分后，数据库可能是分布式在不同实例和不同的主机上，join将变得非常麻烦。而且基于架构规范，性能，安全性等方面考虑，一般是禁止跨库join的。那该怎么办呢？首先要考虑下垂直分库的设计问题，如果可以调整，那就优先调整。如果无法调整的情况，下面笔者将结合以往的实际经验，总结几种常见的解决思路，并分析其适用场景。&lt;/p&gt;&lt;p&gt;跨库Join的几种解决思路&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;全局表&lt;/span&gt;&lt;/p&gt;&lt;p&gt;所谓全局表，就是有可能系统中所有模块都可能会依赖到的一些表。比较类似我们理解的“数据字典”。为了避免跨库join查询，我们可以将这类表在其他每个数据库中均保存一份。同时，这类数据通常也很少发生修改（甚至几乎不会），所以也不用太担心“一致性”问题。&lt;/p&gt;&lt;p&gt;&lt;span&gt;字段冗余&lt;/span&gt;&lt;/p&gt;&lt;p&gt;这是一种典型的反范式设计，在互联网行业中比较常见，通常是为了性能来避免join查询。&lt;/p&gt;&lt;p&gt;举个电商业务中很简单的场景：“订单表”中保存“卖家Id”的同时，将卖家的“Name”字段也冗余，这样查询订单详情的时候就不需要再去查询“卖家用户表”。&lt;/p&gt;&lt;p&gt;字段冗余能带来便利，是一种“空间换时间”的体现。但其适用场景也比较有限，比较适合依赖字段较少的情况。最复杂的还是数据一致性问题，这点很难保证，可以借助数据库中的触发器或者在业务代码层面去保证。当然，也需要结合实际业务场景来看一致性的要求。就像上面例子，如果卖家修改了Name之后，是否需要在订单信息中同步更新呢？&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;数据同步&lt;/span&gt;&lt;/p&gt;&lt;p&gt;定时A库中的tab_a表和B库中tbl_b有关联，可以定时将指定的表做同步。当然，同步本来会对数据库带来一定的影响，需要性能影响和数据时效性中取得一个平衡。这样来避免复杂的跨库查询。笔者曾经在项目中是通过ETL工具来实施的。&lt;/p&gt;&lt;p&gt;&lt;span&gt;系统层组装&lt;/span&gt;&lt;/p&gt;&lt;p&gt;在系统层面，通过调用不同模块的组件或者服务，获取到数据并进行字段拼装。说起来很容易，但实践起来可真没有这么简单，尤其是数据库设计上存在问题但又无法轻易调整的时候。具体情况通常会比较复杂。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;按业务拆分数据库之后，不可避免的就是“分布式事务”的问题。想要了解分布式事务，就需要了解“XA接口”和“两阶段提交”。值得提到的是，MySQL5.5x和5.6x中的xa支持是存在问题的，会导致主从数据不一致。直到5.7x版本中才得到修复。Java应用程序可以采用Atomikos框架来实现XA事务（J2EE中JTA）。感兴趣的读者可以自行参考《分布式事务一致性解决方案》，链接地址：http://www.infoq.com/cn/articles/solution-of-distributed-system-transaction-consistency&lt;/p&gt;&lt;h3&gt;四、常见分片规则和策略&lt;/h3&gt;&lt;p&gt;在很多中小项目中，我们往往直接使用数据库自增特性来生成主键ID，这样确实比较简单。而在分库分表的环境中，数据分布在不同的分片上，不能再借助数据库自增长特性直接生成，否则会造成不同分片上的数据表主键会重复。简单介绍下使用和了解过的几种ID生成算法。&lt;/p&gt;&lt;p&gt;1. Twitter的Snowflake（又名“雪花算法”）&lt;/p&gt;&lt;p&gt;2. UUID/GUID（一般应用程序和数据库均支持）&lt;/p&gt;&lt;p&gt;3. MongoDB ObjectID（类似UUID的方式）&lt;/p&gt;&lt;p&gt;4. Ticket Server（数据库生存方式，Flickr采用的就是这种方式）&lt;/p&gt;&lt;p&gt;其中，Twitter的Snowflake算法是近几年在分布式系统项目中使用最多的，未发现重复或并发的问题。该算法生成的是64位唯一Id（由41位的timestamp+10位自定义的机器码+13位累加计数器组成）。这里不做过多介绍，感兴趣的读者可自行查阅相关资料。&lt;/p&gt;&lt;p&gt;在开始分片之前，我们首先要确定分片字段（也可称为“片键”）。很多常见的例子和场景中是采用ID或者时间字段进行拆分。这也并不绝对的，我的建议是结合实际业务，通过对系统中执行的sql语句进行统计分析，选择出需要分片的那个表中最频繁被使用，或者最重要的字段来作为分片字段。&lt;/p&gt;&lt;p&gt;常见的分片策略有随机分片和连续分片这两种，如下图所示：&lt;/p&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.506398537477148&quot; data-type=&quot;jpeg&quot; data-w=&quot;547&quot; title=&quot;从原则、方案、策略及难点阐述分库分表&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/xicWYTSICzRsgbRXe9nDaFh5J0QIAEcTDUC3GhVicSfS8yXibNjVFNrbVCanBaqmwMHv76plJuxTiaSWicice8q4oqxQ/640?wx_fmt=jpeg&quot;/&gt;&lt;/p&gt;&lt;p&gt;当需要使用分片字段进行范围查找时，连续分片可以快速定位分片进行高效查询，大多数情况下可以有效避免跨分片查询的问题。后期如果想对整个分片集群扩容时，只需要添加节点即可，无需对其他分片的数据进行迁移。但是，连续分片也有可能存在数据热点的问题，就像图中按时间字段分片的例子，有些节点可能会被频繁查询压力较大，热数据节点就成为了整个集群的瓶颈。而有些节点可能存的是历史数据，很少需要被查询到。&lt;/p&gt;&lt;p&gt;随机分片其实并不是随机的，也遵循一定规则。通常，我们会采用Hash取模的方式进行分片拆分，所以有些时候也被称为离散分片。随机分片的数据相对比较均匀，不容易出现热点和并发访问的瓶颈。但是，后期分片集群扩容起来需要迁移旧的数据。使用一致性Hash算法能够很大程度的避免这个问题，所以很多中间件的分片集群都会采用一致性Hash算法。离散分片也很容易面临跨分片查询的复杂问题。&lt;/p&gt;&lt;p&gt;很少有项目会在初期就开始考虑分片设计的，一般都是在业务高速发展面临性能和存储的瓶颈时才会提前准备。因此，不可避免的就需要考虑历史数据迁移的问题。一般做法就是通过程序先读出历史数据，然后按照指定的分片规则再将数据写入到各个分片节点中。&lt;/p&gt;&lt;p&gt;此外，我们需要根据当前的数据量和QPS等进行容量规划，综合成本因素，推算出大概需要多少分片（一般建议单个分片上的单表数据量不要超过1000W）。&lt;/p&gt;&lt;p&gt;如果是采用随机分片，则需要考虑后期的扩容问题，相对会比较麻烦。如果是采用的范围分片，只需要添加节点就可以自动扩容。&lt;/p&gt;&lt;h3&gt;五、跨分片技术问题&lt;/h3&gt;&lt;p&gt;一般来讲，分页时需要按照指定字段进行排序。当排序字段就是分片字段的时候，我们通过分片规则可以比较容易定位到指定的分片，而当排序字段非分片字段的时候，情况就会变得比较复杂了。为了最终结果的准确性，我们需要在不同的分片节点中将数据进行排序并返回，并将不同分片返回的结果集进行汇总和再次排序，最后再返回给用户。如下图所示：&lt;/p&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.7132987910189983&quot; data-type=&quot;jpeg&quot; data-w=&quot;579&quot; title=&quot;从原则、方案、策略及难点阐述分库分表&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/xicWYTSICzRsgbRXe9nDaFh5J0QIAEcTDSXEBu5MEVia6XQad3S1moMialPJtYMZ38IXNrFCDQcKBdOdthicGtdcqw/640?wx_fmt=jpeg&quot;/&gt;&lt;/p&gt;&lt;p&gt;上面图中所描述的只是最简单的一种情况（取第一页数据），看起来对性能的影响并不大。但是，如果想取出第10页数据，情况又将变得复杂很多，如下图所示：&lt;/p&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.6968085106382979&quot; data-type=&quot;jpeg&quot; data-w=&quot;564&quot; title=&quot;从原则、方案、策略及难点阐述分库分表&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/xicWYTSICzRsgbRXe9nDaFh5J0QIAEcTDLdXh084mBEicGGQQY3eD2cXhEuvgSddibs0JQOSsibbw5f4vDhHQt4pvw/640?wx_fmt=jpeg&quot;/&gt;&lt;/p&gt;&lt;p&gt;有些读者可能并不太理解，为什么不能像获取第一页数据那样简单处理（排序取出前10条再合并、排序）。其实并不难理解，因为各分片节点中的数据可能是随机的，为了排序的准确性，必须把所有分片节点的前N页数据都排序好后做合并，最后再进行整体的排序。很显然，这样的操作是比较消耗资源的，用户越往后翻页，系统性能将会越差。&lt;/p&gt;&lt;p&gt;在使用Max、Min、Sum、Count之类的函数进行统计和计算的时候，需要先在每个分片数据源上执行相应的函数处理，然后再将各个结果集进行二次处理，最终再将处理结果返回。如下图所示：&lt;/p&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.704225352112676&quot; data-type=&quot;jpeg&quot; data-w=&quot;568&quot; title=&quot;从原则、方案、策略及难点阐述分库分表&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/xicWYTSICzRsgbRXe9nDaFh5J0QIAEcTDN42Cn2vIhr32EvyuTEvz0r1x3cTVIRW18ZK0Qibiab1NaqhSqz3XeQuA/640?wx_fmt=jpeg&quot;/&gt;&lt;/p&gt;&lt;section data-recommend-type=&quot;list-title&quot; data-recommend-tid=&quot;8&quot; data-mpa-template=&quot;t&quot; data-mid=&quot;&quot; data-from=&quot;yb-recommend&quot;&gt;&lt;section data-mid=&quot;&quot;&gt;&lt;section data-mid=&quot;&quot;&gt;&lt;section data-mid=&quot;&quot;&gt;&lt;section data-mid=&quot;&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot;&gt;&lt;p data-mid=&quot;&quot;&gt;往期推荐&lt;/p&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; data-recommend-article-type=&quot;list-title&quot; data-recomment-template-id=&quot;8&quot; data-recommend-article-id=&quot;2247486047_1&quot; data-recommend-article-time=&quot;1612135800&quot; data-recommend-article-cover=&quot;http://mmbiz.qpic.cn/mmbiz_jpg/xicWYTSICzRuaItggtTicnNvgdK94EDNzNP5572L0GQXnDiaibU6MAlS6V4qSOMclzZ8kkbRJHuRicFians72Y9SQUvw/0?wx_fmt=jpeg&quot; data-recommend-article-title=&quot;时序数据库InfluxDB引擎浅析&quot; data-recommend-article-content-url=&quot;http://mp.weixin.qq.com/s?__biz=MzU2NDc4MjE2Ng==&amp;amp;mid=2247486047&amp;amp;idx=1&amp;amp;sn=0001f4326790dd93014bfd342c90fb41&amp;amp;chksm=fc44ff66cb337670354c4ed1e0e4bb362e1f97b909c0d2ba27214fcd32de284b1d22e110f48f#rd&quot;&gt;&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzU2NDc4MjE2Ng==&amp;amp;mid=2247486047&amp;amp;idx=1&amp;amp;sn=0001f4326790dd93014bfd342c90fb41&amp;amp;chksm=fc44ff66cb337670354c4ed1e0e4bb362e1f97b909c0d2ba27214fcd32de284b1d22e110f48f&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;&lt;section data-recommend-title=&quot;t&quot; data-mid=&quot;&quot;&gt;&lt;p data-mid=&quot;&quot;&gt;时序数据库InfluxDB引擎浅析&lt;/p&gt;&lt;/section&gt;&lt;/a&gt;&lt;/section&gt;&lt;section data-mpa-template=&quot;t&quot; data-recommend-article-type=&quot;list-title&quot; data-recomment-template-id=&quot;8&quot; data-recommend-article-id=&quot;2247485965_1&quot; data-recommend-article-time=&quot;1612049400&quot; data-recommend-article-cover=&quot;http://mmbiz.qpic.cn/mmbiz_jpg/xicWYTSICzRuw1laYB5sHPMO13k4yQibogNnI8rcuhHwev6FoeKdVdINnM8HZ7icia30pJRFVMhVzf2ry8nEEhLjkg/0?wx_fmt=jpeg&quot; data-recommend-article-title=&quot;精髓！深入浅出剖析12个Zookeeper知识点&quot; data-recommend-article-content-url=&quot;http://mp.weixin.qq.com/s?__biz=MzU2NDc4MjE2Ng==&amp;amp;mid=2247485965&amp;amp;idx=1&amp;amp;sn=98927d2f8845948c18930a639d01c211&amp;amp;chksm=fc44ff34cb337622d4a2ba8c39bb06f3ab4cc4ab32c6fab6dbef6365363b945ef5664820db7c#rd&quot;&gt;&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzU2NDc4MjE2Ng==&amp;amp;mid=2247485965&amp;amp;idx=1&amp;amp;sn=98927d2f8845948c18930a639d01c211&amp;amp;chksm=fc44ff34cb337622d4a2ba8c39bb06f3ab4cc4ab32c6fab6dbef6365363b945ef5664820db7c&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;&lt;section data-recommend-title=&quot;t&quot; data-mid=&quot;&quot;&gt;&lt;p data-mid=&quot;&quot;&gt;精髓！深入浅出剖析12个Zookeeper知识点&lt;/p&gt;&lt;/section&gt;&lt;/a&gt;&lt;/section&gt;&lt;section data-mpa-template=&quot;t&quot; data-recommend-article-type=&quot;list-title&quot; data-recomment-template-id=&quot;8&quot; data-recommend-article-id=&quot;2247485952_1&quot; data-recommend-article-time=&quot;1611963000&quot; data-recommend-article-cover=&quot;http://mmbiz.qpic.cn/mmbiz_jpg/xicWYTSICzRuw1laYB5sHPMO13k4yQibogWjQvedIKwykOr5REqhnaHFUeicptxnssnuod6854H0GhTRSeQOD8dqA/0?wx_fmt=jpeg&quot; data-recommend-article-title=&quot;分不清ARM和X86架构，来看看服务器的产品形态&quot; data-recommend-article-content-url=&quot;http://mp.weixin.qq.com/s?__biz=MzU2NDc4MjE2Ng==&amp;amp;mid=2247485952&amp;amp;idx=1&amp;amp;sn=840512fbd429fae2d6798ecbcee1d43e&amp;amp;chksm=fc44ff39cb33762fb912485cd5a3f94062a4a21f712092caedd6c00989da48cbdad2ee60cb05#rd&quot;&gt;&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzU2NDc4MjE2Ng==&amp;amp;mid=2247485952&amp;amp;idx=1&amp;amp;sn=840512fbd429fae2d6798ecbcee1d43e&amp;amp;chksm=fc44ff39cb33762fb912485cd5a3f94062a4a21f712092caedd6c00989da48cbdad2ee60cb05&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;&lt;section data-recommend-title=&quot;t&quot; data-mid=&quot;&quot;&gt;&lt;p data-mid=&quot;&quot;&gt;分不清ARM和X86架构，来看看服务器的产品形态&lt;/p&gt;&lt;/section&gt;&lt;/a&gt;&lt;/section&gt;&lt;section data-mpa-template=&quot;t&quot; data-recommend-article-type=&quot;list-title&quot; data-recomment-template-id=&quot;8&quot; data-recommend-article-id=&quot;2247485732_1&quot; data-recommend-article-time=&quot;1611876600&quot; data-recommend-article-cover=&quot;http://mmbiz.qpic.cn/mmbiz_jpg/xicWYTSICzRsPwWe9ws9b1eZv1kGseImPMYrrenEhpfSmxicBNR3GFa1JIacnF81eOJDYBb2pe7jRhG6yCWEvTAg/0?wx_fmt=jpeg&quot; data-recommend-article-title=&quot;全面认识OpenStack架构&quot; data-recommend-article-content-url=&quot;http://mp.weixin.qq.com/s?__biz=MzU2NDc4MjE2Ng==&amp;amp;mid=2247485732&amp;amp;idx=1&amp;amp;sn=86b955de280cfee3c22bdd83489b6e5e&amp;amp;chksm=fc44fc1dcb33750b737127bfb2c3846152f27036accb2192fe702bf86c9a5b08854e79608586#rd&quot;&gt;&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzU2NDc4MjE2Ng==&amp;amp;mid=2247485732&amp;amp;idx=1&amp;amp;sn=86b955de280cfee3c22bdd83489b6e5e&amp;amp;chksm=fc44fc1dcb33750b737127bfb2c3846152f27036accb2192fe702bf86c9a5b08854e79608586&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;&lt;section data-recommend-title=&quot;t&quot; data-mid=&quot;&quot;&gt;&lt;p data-mid=&quot;&quot;&gt;全面认识OpenStack架构&lt;/p&gt;&lt;/section&gt;&lt;/a&gt;&lt;/section&gt;&lt;section data-mpa-template=&quot;t&quot; data-recommend-article-type=&quot;list-title&quot; data-recomment-template-id=&quot;8&quot; data-recommend-article-id=&quot;2247485657_1&quot; data-recommend-article-time=&quot;1611790200&quot; data-recommend-article-cover=&quot;http://mmbiz.qpic.cn/mmbiz_jpg/xicWYTSICzRuEo5gyxME0m1UvDjzp5Uibwiamydfnj9dh0vU4hoYvReZSPKPacq9v3iaiciazicfHdCYialtBuVib4fP69g/0?wx_fmt=jpeg&quot; data-recommend-article-title=&quot;MAC认证技术&quot; data-recommend-article-content-url=&quot;http://mp.weixin.qq.com/s?__biz=MzU2NDc4MjE2Ng==&amp;amp;mid=2247485657&amp;amp;idx=1&amp;amp;sn=aa6fb6e87300dfee313677c12828a982&amp;amp;chksm=fc44fde0cb3374f60a3e6c8745be5a87d39fc892177c09cbd5afbd9bf27765a196373a648e75#rd&quot;&gt;&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzU2NDc4MjE2Ng==&amp;amp;mid=2247485657&amp;amp;idx=1&amp;amp;sn=aa6fb6e87300dfee313677c12828a982&amp;amp;chksm=fc44fde0cb3374f60a3e6c8745be5a87d39fc892177c09cbd5afbd9bf27765a196373a648e75&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;&lt;section data-recommend-title=&quot;t&quot; data-mid=&quot;&quot;&gt;&lt;p data-mid=&quot;&quot;&gt;MAC认证技术&lt;/p&gt;&lt;/section&gt;&lt;/a&gt;&lt;/section&gt;&lt;section data-mpa-template=&quot;t&quot; data-recommend-article-type=&quot;list-title&quot; data-recomment-template-id=&quot;8&quot; data-recommend-article-id=&quot;2247485643_1&quot; data-recommend-article-time=&quot;1611757173&quot; data-recommend-article-cover=&quot;http://mmbiz.qpic.cn/mmbiz_jpg/xicWYTSICzRuEo5gyxME0m1UvDjzp5UibwaurF75mBg9grDFg0wExzWDgxN6L31KFk5B3EJFkjvprrq0iaH0asqtA/0?wx_fmt=jpeg&quot; data-recommend-article-title=&quot;接入与身份认证技术概述&quot; data-recommend-article-content-url=&quot;http://mp.weixin.qq.com/s?__biz=MzU2NDc4MjE2Ng==&amp;amp;mid=2247485643&amp;amp;idx=1&amp;amp;sn=88166c4206f884ecb60efd2001432785&amp;amp;chksm=fc44fdf2cb3374e4ee04288c58be76e011f4d73e49021e3a0f8c2d5308073dcb288d1ac97726#rd&quot;&gt;&lt;section data-recommend-title=&quot;t&quot; data-mid=&quot;&quot;&gt;&lt;p data-mid=&quot;&quot;&gt;&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzU2NDc4MjE2Ng==&amp;amp;mid=2247485643&amp;amp;idx=1&amp;amp;sn=88166c4206f884ecb60efd2001432785&amp;amp;chksm=fc44fdf2cb3374e4ee04288c58be76e011f4d73e49021e3a0f8c2d5308073dcb288d1ac97726&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;接入与身份认证技术概述&lt;/a&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;img class=&quot;rich_pages&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;578&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;321&quot; data-ratio=&quot;0.4255555555555556&quot; data-s=&quot;300,640&quot; data-type=&quot;jpeg&quot; data-w=&quot;900&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/xicWYTSICzRvzhdKrMicSPIibg8PEbOka8njc8rEfaKkOXLp2wmprLicBQicX1iauQsXGSL9iaxkxVSotPCavShokSoTw/640?wx_fmt=jpeg&quot;/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mpa-category=&quot;模板&quot; data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;img data-ratio=&quot;1&quot; data-type=&quot;gif&quot; data-w=&quot;92&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/GGTr0OaZf2XsT2qUbElibBOVzt2iajO2wPBFcRSvnBNiat1rmEAxsXC1icuGJgTRtrJ52am2wk5q6SWtef8KNHAoGg/640?wx_fmt=gif&quot;/&gt;&lt;p data-mid=&quot;&quot;&gt;戳这儿&lt;/p&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/div&gt;

          

          
          &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>904b293dc9cac15f5f766ffb53e479f2</guid>
<title>Python中关闭文件很重要</title>
<link>https://toutiao.io/k/8r3kcz7</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;post-body&quot; itemprop=&quot;articleBody&quot;&gt;

      
      

      
        &lt;h2 id=&quot;引言&quot;&gt;&lt;a href=&quot;#引言&quot; class=&quot;headerlink&quot; title=&quot;引言&quot;/&gt;引言&lt;/h2&gt;&lt;p&gt;在使用 Python 操作文件时，很多人会使用上下文管理器来操作。例如：&lt;br/&gt;&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br/&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;with&lt;/span&gt; open(&lt;span class=&quot;string&quot;&gt;&quot;xx.txt&quot;&lt;/span&gt;, mode=&lt;span class=&quot;string&quot;&gt;&quot;w&quot;&lt;/span&gt;) &lt;span class=&quot;keyword&quot;&gt;as&lt;/span&gt; f:&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;    f.write(&lt;span class=&quot;string&quot;&gt;&quot;Hello, World!&quot;&lt;/span&gt;)&lt;/span&gt;&lt;br/&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;该with语句启动上下文管理器。在此示例中，只要上下文处于活动状态，上下文管理器就会打开文件xx.txt并管理文件资源。通常，缩进块结束或引发异常，文件将关闭。可能很多初学者都会被建议这样用，可是为什么要这样写程序才更健壮？或者说为什么一定要关闭文件？&lt;/p&gt;
&lt;a id=&quot;more&quot;/&gt;
&lt;h2 id=&quot;从系统的角度看&quot;&gt;&lt;a href=&quot;#从系统的角度看&quot; class=&quot;headerlink&quot; title=&quot;从系统的角度看&quot;/&gt;从系统的角度看&lt;/h2&gt;&lt;h3 id=&quot;系统限制进程打开的文件数&quot;&gt;&lt;a href=&quot;#系统限制进程打开的文件数&quot; class=&quot;headerlink&quot; title=&quot;系统限制进程打开的文件数&quot;/&gt;系统限制进程打开的文件数&lt;/h3&gt;&lt;p&gt;调用open()打开文件时，会对操作系统进行系统调用，硬盘驱动器找到该文件并为读取或写入做好准备。然后，操作系统将返回一个无符号整数n， Python 进程进行系统调用并获取整数 n 作为文件句柄获得与文件关联的编号后，就可以进行读取或写入操作了。&lt;br/&gt;操作系统限制任何单个进程可以拥有的打开文件的数量，这个可以使用工具 ulimit 查看， 或者直接修改 /etc/security/limits.conf 改变文件数限制。&lt;/p&gt;
&lt;h3 id=&quot;为什么限制？突破限制会怎样&quot;&gt;&lt;a href=&quot;#为什么限制？突破限制会怎样&quot; class=&quot;headerlink&quot; title=&quot;为什么限制？突破限制会怎样&quot;/&gt;为什么限制？突破限制会怎样&lt;/h3&gt;&lt;p&gt;从操作系统的角度来看，任何达到限制的进程都可能会泄漏文件句柄以及其他资源。资源泄漏可能是由于不良的编程习惯或试图攻击系统的恶意程序造成的，操作系统为了保护系统的稳定而采取限制措施。另外，对于大多数应用程序来说，打开这么多文件是没有意义的。在一个硬盘驱动器上最多只能同时进行一次读取或写入操作。&lt;/p&gt;
&lt;p&gt;比如你写了一个简单的文件上传服务，在服务中你需要将用户上传的文件保存在服务器上，如果你没有在写完文件后关闭文件，随着服务的时间变长，服务开启的文件会越来越多，最后你会得到这个报错， OSError: [Errno 24] Too many open files。&lt;/p&gt;
&lt;p&gt;那能不能突破这个文件限制呢？那肯定是可以的，当然你必须知道你的服务为什么要开启这么多的文件，比如对于一个长连接服务，他可能要求单个实例要支撑数万的tcp链接(Linux中套接字也是文件)，那这时候如果还采取默认的单进程开启文件数量限制可能就不合适了，你就需要修正 /etc/security/limits.conf 配置文件。&lt;/p&gt;
&lt;h2 id=&quot;从稳定性的角度看&quot;&gt;&lt;a href=&quot;#从稳定性的角度看&quot; class=&quot;headerlink&quot; title=&quot;从稳定性的角度看&quot;/&gt;从稳定性的角度看&lt;/h2&gt;&lt;p&gt;我们每次操作文件都去使用with来管理上下文，with封装了 try…except…finally 编码范式，能在任何情况下(当然不包括断电)极大限度的帮你关闭文件。&lt;/p&gt;
&lt;p&gt;但是如果我们不关闭文件，将会面临什么？比如下边的代码&lt;br/&gt;&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br/&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;import&lt;/span&gt; os&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;f = open(&lt;span class=&quot;string&quot;&gt;&quot;xxx.txt&quot;&lt;/span&gt;, mode=&lt;span class=&quot;string&quot;&gt;&quot;w&quot;&lt;/span&gt;)&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;f.write(&lt;span class=&quot;string&quot;&gt;&quot;Hello, world!&quot;&lt;/span&gt;)&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;os._exit(&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;)  &lt;span class=&quot;comment&quot;&gt;# 模拟程序异常退出&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;这段代码你确实可以找到 xxx.txt 文件，但是文件里边没有Hello, world!内容。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;为每个写操作都去操作磁盘是很昂贵。出于这个原因，Python 默认是使用一个缓冲区来收集写操作。当缓冲区满时，或者文件被显式关闭时，缓冲区被刷新，写操作完成，这时候才会写入磁盘。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Python 进程完成后，操作系统会执行自己的清理，关闭进程打开的所有文件描述符。崩溃可能发生在多个级别，并会干扰操作系统的清理，使文件句柄悬空。在 Windows 上，悬空文件句柄可能会出现问题，打开文件的进程也会锁定它，另一个进程在关闭之前无法打开该文件。Windows 用户可能熟悉不允许您打开或删除文件的恶意进程。文件句柄泄漏和缓冲区中的内容丢失已经够糟糕的了，但是中断文件操作的崩溃也可能导致文件损坏。&lt;/p&gt;
&lt;h2 id=&quot;总结&quot;&gt;&lt;a href=&quot;#总结&quot; class=&quot;headerlink&quot; title=&quot;总结&quot;/&gt;总结&lt;/h2&gt;&lt;p&gt;首先因为受系统的限制，我们不管用哪种语言编程，都要把不在使用的文件描述符关闭，一来避免因开启文件过多导致服务异常，二来及时关闭不用的文件描述符也能节约资源。&lt;/p&gt;
&lt;p&gt;另外我们永远无法完全避免崩溃的影响，但是我们可以通过使用上下文管理器来减少崩溃带来的影响。&lt;/p&gt;

      
    &lt;/div&gt;

    
      


    

    
    
    

    
      &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>f3245593491d5a22af72c050fdb6c186</guid>
<title>高并发下如何防重？</title>
<link>https://toutiao.io/k/qqouiqz</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot; data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;/h2&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;大家好，我是码哥，可以叫我靓仔。&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;&lt;/p&gt;&lt;section class=&quot;mp_profile_iframe_wrp&quot;&gt;&lt;mpprofile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mpprofile&quot; data-id=&quot;MzkzMDI1NjcyOQ==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/EoJib2tNvVtf7icAmS0BQH6oDVG37Q8NzcfdguS5qAqOhfxvZyIKqmuX5BbnDjynrBbZzktp1EiaeFLzapp1nHysw/0?wx_fmt=png&quot; data-nickname=&quot;码哥字节&quot; data-alias=&quot;MageByte&quot; data-signature=&quot;拥抱硬核技术和对象，面向人民币编程。&quot; data-from=&quot;0&quot;/&gt;&lt;/section&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;前言&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;最近测试给我提了一个bug，说我之前提供的一个批量复制商品的接口，产生了重复的商品数据。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;追查原因之后发现，这个事情没想象中简单，可以说一波多折。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;1. 需求&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;产品有个需求：用户选择一些品牌，点击确定按钮之后，系统需要基于一份&lt;code&gt;默认&lt;/code&gt;品牌的商品数据，复制出一批&lt;code&gt;新&lt;/code&gt;的商品。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;拿到这个需求时觉得太简单了，三下五除二就搞定。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我提供了一个复制商品的基础接口，给商城系统调用。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当时的流程图如下：&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.2962382445141066&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ibJZVicC7nz5iaKjv5crmHjKwiakCWXlN74v073cEphxgnuialQdxJ1APTqGmxga34icfB9dD7VVPPq7rjYbYF7Pdyqg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1276&quot;/&gt;如果每次复制的商品数量不多，使用同步接口调用的方案问题也不大。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;2. 性能优化&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但由于每次需要复制的商品数量比较多，可能有几千。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果每次都是用同步接口的方式复制商品，可能会有性能问题。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;因此，后来我把复制商品的逻辑改成使用&lt;code&gt;mq&lt;/code&gt;异步处理。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;改造之后的流程图：&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.25058823529411767&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ibJZVicC7nz5iaKjv5crmHjKwiakCWXlN74vGmIG2UQ0ACq9ibuIG9mV02Bjdjtw4ibmE06BJucicvkBTaAgibNuEeLdsA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1700&quot;/&gt;复制商品的结果还需要通知商城系统：&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.4166666666666667&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ibJZVicC7nz5iaKjv5crmHjKwiakCWXlN74vfCDzNOsHJ1a6TElFvSNKEEA8B7320Rhm2hje3tib4B8cdGUzMHK94KQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1128&quot;/&gt;这个方案看起来，挺不错的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但后来出现问题了。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;3. 出问题了&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;测试给我们提了一个bug，说我之前提供的一个批量复制商品的接口，产生了重复的商品数据。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;经过追查之后发现，商城系统为了性能考虑，也改成异步了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;他们没有在接口中直接调用基础系统的复制商品接口，而是在&lt;code&gt;job&lt;/code&gt;中调用的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;站在他们的视角流程图是这样的：&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.28144458281444584&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ibJZVicC7nz5iaKjv5crmHjKwiakCWXlN74vibicaial4QeBQweXfssQVwcqaMnTPY52iaBOGzRd6GuajlLDmicAsHKq0Pw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1606&quot;/&gt;用户调用商城的接口，他们会往&lt;code&gt;请求记录表&lt;/code&gt;中写入一条数据，然后在另外一个&lt;code&gt;job&lt;/code&gt;中，异步调用基础系统的接口去复制商品。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但实际情况是这样的：商城系统内部出现了bug，在请求记录表中，同一条请求产生了重复的数据。这样导致的结果是，在job中调用基础系统复制商品接口时，发送了重复的请求。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;刚好基础系统现在是使用&lt;code&gt;RocketMQ&lt;/code&gt;异步处理的。由于商城的job一次会取一批数据（比如:20条记录），在极短的时间内（其实就是在一个for循环中）多次调用接口，可能存在相同的请求参数连续调用复制商品接口情况。于是，出现了并发插入重复数据的问题。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;为什么会出现这个问题呢？&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;4. 多线程消费&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;RocketMQ&lt;/code&gt;的消费者，为了性能考虑，默认是用多线程并发消费的，最大支持&lt;code&gt;64&lt;/code&gt;个线程。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;例如：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;@RocketMQMessageListener&lt;/span&gt;(topic = &lt;span&gt;&quot;${com.susan.topic:PRODUCT_TOPIC}&quot;&lt;/span&gt;,&lt;br/&gt;        consumerGroup = &lt;span&gt;&quot;${com.susan.group:PRODUCT_TOPIC_GROUP}&quot;&lt;/span&gt;)&lt;br/&gt;&lt;span&gt;@Service&lt;/span&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;MessageReceiver&lt;/span&gt; &lt;span&gt;implements&lt;/span&gt; &lt;span&gt;RocketMQListener&lt;/span&gt;&amp;lt;&lt;span&gt;MessageExt&lt;/span&gt;&amp;gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;onMessage&lt;/span&gt;&lt;span&gt;(MessageExt message)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        String message = &lt;span&gt;new&lt;/span&gt; String(message.getBody(), StandardCharsets.UTF_8);&lt;br/&gt;        doSamething(message);&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;也就是说，如果在极短的时间内，连续发送重复的消息，就会被不同的线程消费。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;即使在代码中有这样的判断：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;Product oldProduct = query(hashCode);&lt;br/&gt;&lt;span&gt;if&lt;/span&gt;(oldProduct == &lt;span&gt;null&lt;/span&gt;) {&lt;br/&gt;    productMapper.insert(product);&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在插入数据之前，先判断该数据是否已经存在，只有不存在才会插入。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但由于在并发情况下，不同的线程都判断商品数据不存在，于是同时进行了插入操作，所以就产生了&lt;code&gt;重复数据&lt;/code&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如下图所示：&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1.432601880877743&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ibJZVicC7nz5iaKjv5crmHjKwiakCWXlN74vqwIZ9vSeRvxOrn1vhCYibVaGM9Zz9z9sTlu9LrDFUoCROAiaMN4k81Xw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;638&quot;/&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;5. 顺序消费&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;为了解决上述并发消费重复消息的问题，我们从两方面着手：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;商城系统修复产生重复记录的bug。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;基础系统将消息改成&lt;code&gt;单线程顺序消费&lt;/code&gt;。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我仔细思考了一下，如果只靠商城系统修复bug，以后很难避免不出现类似的重复商品问题，比如：如果用户在极短的时间内点击创建商品按钮多次，或者商城系统主动发起重试。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以，基础系统还需进一步处理。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其实&lt;code&gt;RocketMQ&lt;/code&gt;本身是支持顺序消费的，需要消息的生产者和消费者一起改。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;生产者改为：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;rocketMQTemplate.asyncSendOrderly(topic, message, hashKey, &lt;span&gt;new&lt;/span&gt; SendCallback() {&lt;br/&gt;  &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;onSuccess&lt;/span&gt;&lt;span&gt;(SendResult sendResult)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;      log.info(&lt;span&gt;&quot;sendMessage success&quot;&lt;/span&gt;);&lt;br/&gt;  }&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;onException&lt;/span&gt;&lt;span&gt;(Throwable e)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;      log.error(&lt;span&gt;&quot;sendMessage failed!&quot;&lt;/span&gt;);&lt;br/&gt;  }&lt;br/&gt;});&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;重点是要调用&lt;code&gt;rocketMQTemplate&lt;/code&gt;对象的&lt;code&gt;asyncSendOrderly&lt;/code&gt;方法，发送顺序消息。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;消费者改为：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;@RocketMQMessageListener&lt;/span&gt;(topic = &lt;span&gt;&quot;${com.susan.topic:PRODUCT_TOPIC}&quot;&lt;/span&gt;,&lt;br/&gt;        consumeMode = ConsumeMode.ORDERLY,&lt;br/&gt;        consumerGroup = &lt;span&gt;&quot;${com.susan.group:PRODUCT_TOPIC_GROUP}&quot;&lt;/span&gt;)&lt;br/&gt;&lt;span&gt;@Service&lt;/span&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;MessageReceiver&lt;/span&gt; &lt;span&gt;implements&lt;/span&gt; &lt;span&gt;RocketMQListener&lt;/span&gt;&amp;lt;&lt;span&gt;MessageExt&lt;/span&gt;&amp;gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;onMessage&lt;/span&gt;&lt;span&gt;(MessageExt message)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        String message = &lt;span&gt;new&lt;/span&gt; String(message.getBody(), StandardCharsets.UTF_8);&lt;br/&gt;        doSamething(message);&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;接收消息的重点是&lt;code&gt;RocketMQMessageListener&lt;/code&gt;注解中的&lt;code&gt;consumeMode&lt;/code&gt;参数，要设置成&lt;code&gt;ConsumeMode.ORDERLY&lt;/code&gt;，这样就能顺序消费消息了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;修改后关键流程图如下：&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;2.2842105263157895&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ibJZVicC7nz5iaKjv5crmHjKwiakCWXlN74vmDcibWsNfwwiag30A8LHM0UIjibtV9tDYv9HFmL6xQuDxNe5MFfxC7kjA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;380&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;两边都修改之后，复制商品这一块就没有再出现重复商品的问题了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;But，修完bug之后，我又思考了良久。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;复制商品只是创建商品的其中一个入口，如果有其他入口，跟复制商品功能同时创建新商品呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;不也会出现重复商品问题？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;虽说，这种概率非常非常小。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但如果一旦出现重复商品问题，后续涉及到要合并商品的数据，非常麻烦。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;经过这一次的教训，一定要防微杜渐。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;不管是用户，还是自己的内部系统，从不同的入口创建商品，都需要解决重复商品创建问题。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那么，如何解决这个问题呢？&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;6. 唯一索引&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;解决重复商品数据问题，最快成本最低最有效的办法是：&lt;code&gt;给表建唯一索引&lt;/code&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;想法是好的，但我们这边有个规范就是：&lt;code&gt;业务表必须都是逻辑删除&lt;/code&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;而我们都知道，要删除表的某条记录的话，如果用&lt;code&gt;delete&lt;/code&gt;语句操作的话。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;例如：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;delete&lt;/span&gt; &lt;span&gt;from&lt;/span&gt; product &lt;span&gt;where&lt;/span&gt; &lt;span&gt;id&lt;/span&gt;=&lt;span&gt;123&lt;/span&gt;;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这种delete操作是&lt;code&gt;物理删除&lt;/code&gt;，即该记录被删除之后，后续通过sql语句基本查不出来。（不过通过其他技术手段可以找回，那是后话了）&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;还有另外一种是逻辑删除，主要是通过&lt;code&gt;update&lt;/code&gt;语句操作的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;例如：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;update&lt;/span&gt; product &lt;span&gt;set&lt;/span&gt; delete_status=&lt;span&gt;1&lt;/span&gt;,edit_time=&lt;span&gt;now&lt;/span&gt;(&lt;span&gt;3&lt;/span&gt;) &lt;br/&gt;&lt;span&gt;where&lt;/span&gt; &lt;span&gt;id&lt;/span&gt;=&lt;span&gt;123&lt;/span&gt;;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;逻辑删除需要在表中额外增加一个&lt;code&gt;删除状态字段&lt;/code&gt;，用于记录数据是否被删除。在所有的业务查询的地方，都需要过滤掉已经删除的数据。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;通过这种方式删除数据之后，数据任然还在表中，只是从逻辑上过滤了删除状态的数据而已。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其实对于这种逻辑删除的表，是没法加&lt;code&gt;唯一索引&lt;/code&gt;的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;为什么呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;假设之前给商品表中的name和model加了唯一索引，如果用户把某条记录删除了，delete_status设置成1了。后来，该用户发现不对，又重新添加了一模一样的商品。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;由于唯一索引的存在，该用户第二次添加商品会失败，即使该商品已经被删除了，也没法再添加了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个问题显然有点严重。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;有人可能会说：把name、model和delete_status三个字段同时做成唯一索引不就行了？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;答：这样做确实可以解决用户逻辑删除了某个商品，后来又重新添加相同的商品时，添加不了的问题。但如果第二次添加的商品，又被删除了。该用户第三次添加相同的商品，不也出现问题了？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;由此可见，&lt;strong&gt;如果表中有逻辑删除功能，是不方便创建唯一索引的。&lt;/strong&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;5. 分布式锁&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;接下来，你想到的第二种解决数据重复问题的办法可能是：&lt;code&gt;加分布式锁&lt;/code&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;目前最常用的性能最高的分布式锁，可能是&lt;code&gt;redis分布式锁&lt;/code&gt;了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;使用redis分布式锁的伪代码如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;try&lt;/span&gt;{&lt;br/&gt;  String result = jedis.set(lockKey, requestId, &lt;span&gt;&quot;NX&quot;&lt;/span&gt;, &lt;span&gt;&quot;PX&quot;&lt;/span&gt;, expireTime);&lt;br/&gt;  &lt;span&gt;if&lt;/span&gt; (&lt;span&gt;&quot;OK&quot;&lt;/span&gt;.equals(result)) {&lt;br/&gt;      doSamething();&lt;br/&gt;      &lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;;&lt;br/&gt;  }&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;;&lt;br/&gt;} &lt;span&gt;finally&lt;/span&gt; {&lt;br/&gt;    unlock(lockKey,requestId);&lt;br/&gt;}  &lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;不过需要在&lt;code&gt;finally&lt;/code&gt;代码块中&lt;code&gt;释放锁&lt;/code&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其中lockKey是由商品表中的name和model组合而成的，requestId是每次请求的唯一标识，以便于它每次都能正确得释放锁。还需要设置一个过期时间expireTime，防止释放锁失败，锁一直存在，导致后面的请求没法获取锁。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果只是单个商品，或者少量的商品需要复制添加，则加分布式锁没啥问题。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;主要流程如下：&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1.8079470198675496&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ibJZVicC7nz5iaKjv5crmHjKwiakCWXlN74vGcexEIvtOkk5Jfh2JwW8cvMKIibvp3JvHQdQoia82efOcepStGicuTNcQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;604&quot;/&gt;可以在复制添加商品之前，先尝试加锁。如果加锁成功，则在查询商品是否存在，如果不存在，则添加商品。此外，在该流程中如果加锁失败，或者查询商品时不存在，则直接返回。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;加分布式锁的目的是：保证查询商品和添加商品的两个操作是原子性的操作。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但现在的问题是，&lt;strong&gt;我们这次需要复制添加的商品数量很多，如果每添加一个商品都要加分布式锁的话，会非常影响性能。&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;显然对于批量接口，加redis分布式锁，不是一个理想的方案。&lt;/strong&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;6. 统一mq异步处理&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;前面我们已经聊过，在批量复制商品的接口，我们是通过RocketMQ的顺序消息，单线程异步复制添加商品的，可以暂时解决商品重复的问题。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但那只改了一个添加商品的入口，还有其他添加商品的入口。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;能不能把添加商品的底层逻辑统一一下，最终都调用同一段代码。然后通过RocketMQ的顺序消息，单线程异步添加商品。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;主要流程如下图所示：&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6787762906309751&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ibJZVicC7nz5iaKjv5crmHjKwiakCWXlN74vp4QahsQibEx0YLVVX1xLYMzETZOdC0LNJP9VwkNo5MxANC3moic6ZZ2w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1046&quot;/&gt;这样确实能够解决重复商品的问题。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但同时也带来了另外两个问题：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;现在所有的添加商品功能都改成异步了，之前同步添加商品的接口如何返回数据呢？这就需要修改前端交互，否则会影响用户体验。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;之前不同的添加商品入口，是多线程添加商品的，现在改成只能由一个线程添加商品，这样修改的结果导致添加商品的整体效率降低了。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;由此，综合考虑了一下各方面因素，这个方案最终被否定了。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;7. insert on duplicate key update&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其实，在mysql中存在这样的语法，即：&lt;code&gt;insert on duplicate key update&lt;/code&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在添加数据时，mysql发现数据不存在，则直接&lt;code&gt;insert&lt;/code&gt;。如果发现数据已经存在了，则做&lt;code&gt;update&lt;/code&gt;操作。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;不过要求表中存在&lt;code&gt;唯一索引&lt;/code&gt;或&lt;code&gt;PRIMARY KEY&lt;/code&gt;，这样当这两个值相同时，才会触发更新操作，否则是插入。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;现在的问题是PRIMARY KEY是商品表的主键，是根据&lt;code&gt;雪花算法&lt;/code&gt;提前生成的，不可能产生重复的数据。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但由于商品表有逻辑删除功能，导致唯一索引在商品表中创建不了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;由此，insert on duplicate key update这套方案，暂时也没法用。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;此外，insert on duplicate key update在高并发的情况下，可能会产生&lt;code&gt;死锁&lt;/code&gt;问题，需要特别注意一下。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;8. insert ignore&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在mysql中还存在这样的语法，即：&lt;code&gt;insert ... ignore&lt;/code&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在insert语句执行的过程中：mysql发现如果数据重复了，就忽略，否则就会插入。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;它主要是用来忽略，插入重复数据产生的&lt;code&gt;Duplicate entry &#x27;XXX&#x27; for key &#x27;XXXX&#x27;&lt;/code&gt;异常的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;不过也要求表中存在&lt;code&gt;唯一索引&lt;/code&gt;或&lt;code&gt;PRIMARY KEY&lt;/code&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但由于商品表有逻辑删除功能，导致唯一索引在商品表中创建不了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;由此可见，这个方案也不行。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;温馨的提醒一下，使用insert ... ignore也有可能会导致&lt;code&gt;死锁&lt;/code&gt;。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;9. 防重表&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;之前聊过，因为有逻辑删除功能，给商品表加唯一索引，行不通。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;后面又说了加分布式锁，或者通过mq单线程异步添加商品，影响创建商品的性能。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那么，如何解决问题呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们能否换一种思路，加一张&lt;code&gt;防重表&lt;/code&gt;，&lt;strong&gt;在防重表中增加商品表的name和model字段作为唯一索引。&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;例如：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;CREATE&lt;/span&gt; &lt;span&gt;TABLE&lt;/span&gt; &lt;span&gt;`product_unique`&lt;/span&gt; (&lt;br/&gt;  &lt;span&gt;`id`&lt;/span&gt; &lt;span&gt;bigint&lt;/span&gt;(&lt;span&gt;20&lt;/span&gt;) &lt;span&gt;NOT&lt;/span&gt; &lt;span&gt;NULL&lt;/span&gt; &lt;span&gt;COMMENT&lt;/span&gt; &lt;span&gt;&#x27;id&#x27;&lt;/span&gt;,&lt;br/&gt;  &lt;span&gt;`name`&lt;/span&gt; &lt;span&gt;varchar&lt;/span&gt;(&lt;span&gt;130&lt;/span&gt;) &lt;span&gt;DEFAULT&lt;/span&gt; &lt;span&gt;NULL&lt;/span&gt; &lt;span&gt;COMMENT&lt;/span&gt; &lt;span&gt;&#x27;名称&#x27;&lt;/span&gt;,&lt;br/&gt;  &lt;span&gt;`model`&lt;/span&gt; &lt;span&gt;varchar&lt;/span&gt;(&lt;span&gt;255&lt;/span&gt;)  &lt;span&gt;NOT&lt;/span&gt; &lt;span&gt;NULL&lt;/span&gt; &lt;span&gt;COMMENT&lt;/span&gt; &lt;span&gt;&#x27;规格&#x27;&lt;/span&gt;,&lt;br/&gt;  &lt;span&gt;`user_id`&lt;/span&gt; &lt;span&gt;bigint&lt;/span&gt;(&lt;span&gt;20&lt;/span&gt;) &lt;span&gt;unsigned&lt;/span&gt; &lt;span&gt;NOT&lt;/span&gt; &lt;span&gt;NULL&lt;/span&gt; &lt;span&gt;COMMENT&lt;/span&gt; &lt;span&gt;&#x27;创建用户id&#x27;&lt;/span&gt;,&lt;br/&gt;  &lt;span&gt;`user_name`&lt;/span&gt; &lt;span&gt;varchar&lt;/span&gt;(&lt;span&gt;30&lt;/span&gt;)  &lt;span&gt;NOT&lt;/span&gt; &lt;span&gt;NULL&lt;/span&gt; &lt;span&gt;COMMENT&lt;/span&gt; &lt;span&gt;&#x27;创建用户名称&#x27;&lt;/span&gt;,&lt;br/&gt;  &lt;span&gt;`create_date`&lt;/span&gt; datetime(&lt;span&gt;3&lt;/span&gt;) &lt;span&gt;NOT&lt;/span&gt; &lt;span&gt;NULL&lt;/span&gt; &lt;span&gt;DEFAULT&lt;/span&gt; &lt;span&gt;CURRENT_TIMESTAMP&lt;/span&gt;(&lt;span&gt;3&lt;/span&gt;) &lt;span&gt;COMMENT&lt;/span&gt; &lt;span&gt;&#x27;创建时间&#x27;&lt;/span&gt;,&lt;br/&gt;  PRIMARY &lt;span&gt;KEY&lt;/span&gt; (&lt;span&gt;`id`&lt;/span&gt;),&lt;br/&gt;  &lt;span&gt;UNIQUE&lt;/span&gt; &lt;span&gt;KEY&lt;/span&gt; &lt;span&gt;`ux_name_model`&lt;/span&gt; (&lt;span&gt;`name`&lt;/span&gt;,&lt;span&gt;`model`&lt;/span&gt;)&lt;br/&gt;) &lt;span&gt;ENGINE&lt;/span&gt;=&lt;span&gt;InnoDB&lt;/span&gt; &lt;span&gt;DEFAULT&lt;/span&gt; &lt;span&gt;CHARSET&lt;/span&gt;=utf8mb4 &lt;span&gt;COMMENT&lt;/span&gt;=&lt;span&gt;&#x27;商品防重表&#x27;&lt;/span&gt;;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其中表中的id可以用商品表的id，表中的name和model就是商品表的name和model，不过在这张防重表中增加了这两个字段的唯一索引。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;视野一下子被打开了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在添加商品数据之前，先添加防重表。如果添加成功，则说明可以正常添加商品，如果添加失败，则说明有重复数据。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;防重表添加失败，后续的业务处理，要根据实际业务需求而定。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果业务上允许添加一批商品时，发现有重复的，直接抛异常，则可以提示用户：系统检测到重复的商品，请刷新页面重试。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;例如：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;try&lt;/span&gt; {&lt;br/&gt;  transactionTemplate.execute((status) -&amp;gt; {&lt;br/&gt;      productUniqueMapper.batchInsert(productUniqueList);&lt;br/&gt;      productMapper.batchInsert(productList);&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; Boolean.TRUE;&lt;br/&gt;  });&lt;br/&gt;} &lt;span&gt;catch&lt;/span&gt;(DuplicateKeyException e) {&lt;br/&gt;   &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; BusinessException(&lt;span&gt;&quot;系统检测到重复的商品，请刷新页面重试&quot;&lt;/span&gt;);&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在批量插入数据时，如果出现了重复数据，捕获&lt;code&gt;DuplicateKeyException&lt;/code&gt;异常，转换成&lt;code&gt;BusinessException&lt;/code&gt;这样运行时的业务异常。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;还有一种业务场景，要求即使出现了重复的商品，也不抛异常，让业务流程也能够正常走下去。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;例如：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;try&lt;/span&gt; {&lt;br/&gt;  transactionTemplate.execute((status) -&amp;gt; {&lt;br/&gt;      productUniqueMapper.insert(productUnique);&lt;br/&gt;      productMapper.insert(product);&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; Boolean.TRUE;&lt;br/&gt;  });&lt;br/&gt;} &lt;span&gt;catch&lt;/span&gt;(DuplicateKeyException e) {&lt;br/&gt;   product = productMapper.query(product);&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在插入数据时，如果出现了重复数据，则捕获&lt;code&gt;DuplicateKeyException&lt;/code&gt;，在&lt;code&gt;catch&lt;/code&gt;代码块中再查询一次商品数据，将数据库已有的商品直接返回。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果调用了同步添加商品的接口，这里非常关键的一点，是要返回已有数据的id，业务系统做后续操作，要拿这个id操作。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当然在执行execute之前，还是需要先查一下商品数据是否存在，如果已经存在，则直接返回已有数据，如果不存在，才执行execute方法。这一步千万不能少。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;例如：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;Product oldProduct = productMapper.query(product);&lt;br/&gt;&lt;span&gt;if&lt;/span&gt;(Objects.nonNull(oldProduct)) {&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; oldProduct;&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;try&lt;/span&gt; {&lt;br/&gt;  transactionTemplate.execute((status) -&amp;gt; {&lt;br/&gt;      productUniqueMapper.insert(productUnique);&lt;br/&gt;      productMapper.insert(product);&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; Boolean.TRUE;&lt;br/&gt;  });&lt;br/&gt;} &lt;span&gt;catch&lt;/span&gt;(DuplicateKeyException e) {&lt;br/&gt;   product = productMapper.query(product);&lt;br/&gt;}&lt;br/&gt;&lt;span&gt;return&lt;/span&gt; product;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;千万注意：防重表和添加商品的操作必须要在同一个事务中，否则会出问题。&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;顺便说一下，还需要对商品的删除功能做特殊处理一下，在逻辑删除商品表的同时，要物理删除防重表。用商品表id作为查询条件即可。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;说实话，解决重复数据问题的方案挺多的，没有最好的方案，只有最适合业务场景的，最优的方案。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;如果这篇文章对您有所帮助，或者有所启发的&lt;/span&gt;&lt;span&gt;话，帮忙扫描下发二维码关注一下，您的支持是我坚持写作最大的动力。&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>87f80252163dcd2cd2ad5e43237d881b</guid>
<title>innodb 是如何存数据的？</title>
<link>https://toutiao.io/k/bxpv123</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot; data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;section&gt;&lt;span&gt;如果你使用过mysql数据库，对它的存储引擎：&lt;/span&gt;&lt;code&gt;&lt;span&gt;innodb&lt;/span&gt;&lt;/code&gt;&lt;span&gt;，一定不会感到陌生。&lt;/span&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;众所周知，在mysql5以前，默认的存储引擎是：myslam。但mysql5之后，默认的存储引擎已经变成了：innodb，它是我们建表的首选存储引擎。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;那么，问题来了：&lt;/span&gt;&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;innodb底层是如何存储数据的？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;表中有哪些隐藏列？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;用户记录之间是如何关联起来的？&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;如果你想知道上面三个问题的答案，那么，请继续往下面看。&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;1.磁盘or内存？&lt;/span&gt;&lt;/section&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;1.1 磁盘&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;数据对系统来说是非常重要的东西，比如：用户的身份证、手机号、银行号、会员过期时间、积分等等。一旦丢失，会对用户造成很大的影响。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;那么问题来了，如何才能保证这些重要的数据不丢呢？&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;答案：把数据存在磁盘上。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;当然有人会说，如果磁盘坏了怎么办？&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;那就需要备份，或者做主从了。。。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;好了，打住，这不是今天的重点。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;言归正传。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;大家都知道，从磁盘上读写数据，至少需要两次IO请求才能完成。一次是读IO，另一次是写IO。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;而IO请求是比较耗时的操作，如果频繁的进行IO请求势必会影响数据库的性能。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;那么，如何才能解决数据库的性能问题呢？&lt;/span&gt;&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;1.2 内存&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;把数据存在寄存器？&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;没错，操作系统从寄存器中读取数据是最快的，因为它离CPU最近。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;但是寄存器有个非常致命的问题是：它只能存储非常少量的数据，设计它的目的主要是用来暂存指令和地址，并非存储大量用户数据的。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;这样看来，只能把数据存在内存中了。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;因为内存同样能满足我们，快速读取和写入数据的需求，而且性能是非常可观的，只是比较寄存器稍稍慢了一丢丢而已。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;不过有个让人讨厌的地方是，内存相对于磁盘来说，是更加昂贵的资源。通常情况下，500G或者1T的磁盘，是很常见的。但你有听说过有500G的内存吗？别人会以为你疯了。内存大小讨论的数量级一般是16G或32G。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;内存可以存储一些用户数据，但无法存储所有的用户数据，因为如果数据量太大了，它可能还是存不下。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;此外，即使用户数据能刚好存在内存，以后万一有一天，数据库服务器或者部署节点挂了，或者重启了，数据不就丢了？&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;怎么做，才能不会因为异常情况，而丢数据。同时，又能保证数据的读写速度呢？&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;2.数据页&lt;/span&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;我们可以把一批数据放在一起。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;写操作时，先将数据写到内存的某个批次中，然后再将该批次的数据一次性刷到磁盘上。如下图所示：&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;读操作时，从磁盘上一次读一批数据，然后加载到内存当中，以后就在内存中操作。如下图所示：&lt;/span&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.8022727272727272&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/uL371281oDER9lbESUVq7L6u9ftCRzaTBwXKnlhniafxnXXvcfz4Erutjxaicj6rkYCicx2zvgBic130771ib62s8rg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;880&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;将内存中的数据刷到磁盘，或者将磁盘中的数据加载到内存，都是以批次为单位，这个批次就是我们常说的：&lt;/span&gt;&lt;code&gt;数据页&lt;/code&gt;&lt;span&gt;。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;当然innodb中存在多种不同类型的页，数据页只是其中一种，我们在这里重点介绍一下数据页。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;那么问题来了，什么是数据页？&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;数据页主要是用来存储表中记录的，它在磁盘中是用双向链表相连的，方便查找，能够非常快速得从一个数据页，定位到另一个数据页。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;很多时候，由于我们表中的数据比较多，在磁盘中可能存放在多个数据页当中。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;有一天，我们要根据某个条件查询数据时，需要从一个数据页找到另一个数据页，这时候的双向链表就派上大用场了。磁盘中各数据页的整体结构如下图所示：&lt;/span&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1.5654205607476634&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/uL371281oDER9lbESUVq7L6u9ftCRzaTrqmQSib5Pv6G7FUlkuAA2fSaMD1GTTD8ZyM7TeUUOmvkmLDMYlibiaqXg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;428&quot;/&gt;&lt;span&gt;通常情况下，单个数据页默认的大小是&lt;/span&gt;&lt;code&gt;16kb&lt;/code&gt;&lt;span&gt;。当然，我们也可以通过参数：&lt;/span&gt;&lt;code&gt;innodb_page_size&lt;/code&gt;&lt;span&gt;，来重新设置大小。不过，一般情况下，用它的默认值就够了。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;好吧，数据页的整体结构已经搞明白了。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;那么，单个数据页包含哪些内容呢？&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1.607843137254902&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/uL371281oDER9lbESUVq7L6u9ftCRzaTuicGNp08dpZUgJVaZ28dZt4XHrsD5O2IQpE7t730ib4otYjbicOTuaePQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;408&quot;/&gt;&lt;span&gt;从上图中可以看出，数据页主要包含如下几个部分：&lt;/span&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;文件头部&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;页头部&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;最大和最小记录&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;用户记录&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;空闲空间&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;页目录&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;文件尾部&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;3.用户记录&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;对于新申请的数据页，用户记录是空的。当插入数据时，innodb会将一部分&lt;/span&gt;&lt;code&gt;空闲空间&lt;/code&gt;&lt;span&gt;分配给用户记录。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;用户记录是innodb的重中之重，我们平时保存到数据库中的数据，就存储在它里面。那么，它里面又包含哪些内容呢？你不好奇吗？&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;其实在innodb支持的数据行格式有四种：&lt;/span&gt;&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;compact行格式&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;redundant行格式&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;dynamic行格式&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;compressed行格式&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;我们以compact行格式为例：&lt;/span&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.22176308539944903&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/uL371281oDER9lbESUVq7L6u9ftCRzaTWR8QYayp9b3bhGCkRUhDMyfUkXbagFia4qJGZZTzULPFCTMSf8OFRhA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1452&quot;/&gt;&lt;span&gt;一条用户记录主要包含三部分内容：&lt;/span&gt;&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;记录额外信息，它包含了变长字段、null值列表和记录头信息。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;隐藏列，它包含了行id、事务id和回滚点。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;真正的数据列，包含真正的用户数据，可以有很多列。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;下面让我们一起了解一下这些内容。&lt;/span&gt;&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;3.1 额外信息&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;额外信息并非真正的用户数据，它是为了辅助存数据用的。&lt;/span&gt;&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;3.1.1 变长字段列表&lt;/span&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;有些数据如果直接存会有问题，比如：如果某个字段是varchar或text类型，它的长度不固定，可以根据存入数据的长度不同，而随之变化。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;如果不在一个地方记录数据真正的长度，innodb很可能不知道要分配多少空间。假如都按某个固定长度分配空间，但实际数据又没占多少空间，岂不是会浪费？&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;所以，需要在变长字段中记录某个变长字段占用的字节数，方便按需分配空间。&lt;/span&gt;&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;3.1.2 null值列表&lt;/span&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;数据库中有些字段的值允许为null，如果把每个字段的null值，都保存到用户记录中，显然有些浪费存储空间。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;有没有办法只简单的标记一下，不存储实际的null值呢？&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;答案：将为null的字段保存到null值列表。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;在列表中用二进制的值1，表示该字段允许为null，用0表示不允许为null。它只占用了1位，就能表示某个字符是否为null，确实可以节省很多存储空间。&lt;/span&gt;&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;3.1.3 记录头信息&lt;/span&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;记录头信息用于描述一些特殊的属性。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.21900161030595813&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/uL371281oDER9lbESUVq7L6u9ftCRzaTsFNKxYEMAjLkCarV0smyTfcRCqP11xdcaBA11ySIuz2v2qIOp57Dicg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1242&quot;/&gt;&lt;span&gt;它主要包含：&lt;/span&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;deleted_flag：即删除标记，用于标记该记录是否被删除了。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;min_rec_flag：即最小目录标记，它是非叶子节点中的最小目录标记。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;n_owned：即拥有的记录数，记录该组索引记录的条数。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;heap_no：即堆上的位置，它表示当前记录在堆上的位置。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;record_type：即记录类型，其中：0表示普通记录，1表示非叶子节点，2表示Infrimum记录， 3表示Supremum记录。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;next_record：即下一条记录的位置。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;3.2 隐藏列&lt;/span&gt;&lt;/h3&gt;&lt;section&gt;&lt;span&gt;数据库在保存一条用户记录时，会自动创建一些隐藏列。如下图所示：&lt;/span&gt;&lt;/section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.4148471615720524&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/uL371281oDER9lbESUVq7L6u9ftCRzaT9JJTf5zsLLmjOduicsWlCibbW0OEWHz87pzDzoJItibjuWCu3b0yzsubA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;458&quot;/&gt;&lt;span&gt;目前innodb自动创建的隐藏列有三种：&lt;/span&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;db_row_id，即行id，它是一条记录的唯一标识。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;db_trx_id，即事务id，它是事务的唯一标识。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;db_roll_ptr，即回滚点，它用于事务回滚。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;如果表中有主键，则用主键做行id，无需额外创建。如果表中没有主键，假如有不为null的unique唯一键，则用它做为行id，同样无需额外创建。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;如果表中既没有主键，又没有唯一键，则数据库会自动创建行id。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;也就是说在innodb中，隐藏列中&lt;/span&gt;&lt;code&gt;事务id&lt;/code&gt;&lt;span&gt;和&lt;/span&gt;&lt;code&gt;回滚点&lt;/code&gt;&lt;span&gt;是一定会被创建的，但行id要根据实际情况决定。&lt;/span&gt;&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;3.3 真正数据列&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;真正的数据列中存储了用户的真实数据，它可以包含很多列的数据。这个比较简单，没有什么好多说的。&lt;/span&gt;&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;3.4 用户记录是如何相连的？&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;通过上面介绍的内容，大家对一条用户记录是如何存储的，应该有了一定的认识。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;但问题来了，一条用户记录和另一条用户记录是如何相连的，innodb是怎么知道，某条记录的下一条记录是谁？&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;答案是：用前面提到过的， 记录额外信息 》 记录头信息 》下一条记录的位置。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.9116022099447514&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/uL371281oDER9lbESUVq7L6u9ftCRzaTGZ7pAQLNneVSVRwDmXR2icQBftNCKHVqd4wROSaJQJJT3AVbkX7srFA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1086&quot;/&gt;&lt;span&gt;多条用户记录之间通过&lt;/span&gt;&lt;code&gt;下一条记录的位置&lt;/code&gt;&lt;span&gt;，组成了一个单向链表。这样就能从前往后，找到所有的记录了。&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;4.最大和最小记录&lt;/span&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;从上面可以得知，在一个数据页当中，如果存在多条用户记录，它们是通过&lt;/span&gt;&lt;code&gt;下一条记录的位置&lt;/code&gt;&lt;span&gt;相连的。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;不过有个问题：如果才能快速找到最大的记录和最小的记录呢？&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;这就需要在保存用户记录的同时，也保存最大和最小记录了。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;最大记录保存到Supremum记录中。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;最小记录保存在Infimum记录中。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;在保存用户记录时，数据库会自动创建两条额外的记录：Supremum 和 Infimum。它们之间的关系，如下图所示：&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1.5045871559633028&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/uL371281oDER9lbESUVq7L6u9ftCRzaTum4U3w1utKO16lVa3QKMDlCS1bEibG3icjmeBxZDRuWGma7jbudm81Jg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;654&quot;/&gt;&lt;span&gt;从图中可以看出用户数据是从最小记录开始，通过下一条记录的位置，从小到大，一步步查找，最后找到最大记录为止。&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;5.页目录&lt;/span&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;从上面可以看出，如果我们要查询某条记录的话，数据库会从最小记录开始，一条条查找所有记录。如果中途找到了，则直接返回该记录。如果一直找到最大记录，还没有找到想要的记录，则返回空。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;咋一看，没有问题。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;但如果仔细想想。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;效率会不会有点低？&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;这不是要对整页用户数据进行扫描吗？&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;有没有更高效的方法？&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;这就需要使用&lt;/span&gt;&lt;code&gt;页目录&lt;/code&gt;&lt;span&gt;了。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;说白了，就是把一页用户记录分为若干组，每一组的最大记录都保存到一个地方，这个地方就是&lt;/span&gt;&lt;code&gt;页目录&lt;/code&gt;&lt;span&gt;。每一组的最大记录叫做&lt;/span&gt;&lt;code&gt;槽&lt;/code&gt;&lt;span&gt;。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;由此可见，页目录是有多个槽组成的。所下图所示：&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6590909090909091&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/uL371281oDER9lbESUVq7L6u9ftCRzaTLECzMXJSzZGusugGkiaFpyj5zLXEdp64jYmSLdbtyRQUoBwBzZzI9cA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;968&quot;/&gt;&lt;span&gt;假设一页的数据分为4组，这样在页目录中，就对应了4个槽，每个槽中都保存了该组数据的最大值。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;这样就能通过二分查找，比较槽中的记录跟需要找到的记录的大小。如果用户需要查找的记录，小于当前槽中的记录，则向上查找上一个槽。如果用户需要查找的记录，大于当前槽中的记录，则向下查找下一个槽。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;如此一来，就能通过二分查找，快速的定位需要查找的记录了。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;so easy&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;6.文件头部和尾部&lt;/span&gt;&lt;/section&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;6.1 文件头部&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;通过前面介绍的行记录中&lt;/span&gt;&lt;code&gt;下一条记录的位置&lt;/code&gt;&lt;span&gt;和&lt;/span&gt;&lt;code&gt;页目录&lt;/code&gt;&lt;span&gt;，innodb能非常快速的定位某一条记录。但有个前提条件，就是用户记录必须在同一个数据页当中。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;如果用户记录非常多，在第一个数据页找不到我们想要的数据，需要到另外一页找该怎么办呢？&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;这时就需要使用&lt;/span&gt;&lt;code&gt;文件头部&lt;/code&gt;&lt;span&gt;了。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;它里面包含了多个信息，但我只列出了其中4个最关键的信息：&lt;/span&gt;&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;页号&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;上一页页号&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;下一页页号&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;页类型&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;顾名思义，innodb是通过页号、上一页页号和下一页页号来串联不同数据页的。如下图所示：&lt;/span&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1.5045454545454546&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/uL371281oDER9lbESUVq7L6u9ftCRzaTRordc1Srg47FYLnjhHEIXg0a0Bj1SibDHRYiawMI7N5lNNcp35cvszSg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;440&quot;/&gt;&lt;span&gt;不同的数据页之间，通过上一页页号和下一页页号构成了双向链表。这样就能从前向后，一页页查找所有的数据了。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;此外，页类型也是一个非常重要的字段，它包含了多种类型，其中比较出名的有：数据页、索引页（目录项页）、溢出页、undo日志页等。&lt;/span&gt;&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;6.2 文件尾部&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;我之前提过，数据库的数据是以数据页为单位，加载到内存中，如果数据有更新的话，需要刷新到磁盘上。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;但如果某一天比较倒霉，程序在刷新到磁盘的过程中，出现了异常，比如：进程被kill掉了，或者服务器被重启了。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;这时候数据可能只刷新了一部分，如何判断上次刷盘的数据是完整的呢？&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;这就需要用到&lt;/span&gt;&lt;code&gt;文件尾部&lt;/code&gt;&lt;span&gt;。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;它里面记录了页面的&lt;/span&gt;&lt;code&gt;校验和&lt;/code&gt;&lt;span&gt;。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;在数据刷新到磁盘之前，会先计算一个页面的校验和。后面如果数据有更新的话，会计算一个新值。文件头部中也会记录这个校验和，由于文件头部在前面，会先被刷新到磁盘上。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;接下来，刷新用户记录到磁盘的时候，假设刷新了一部分，恰好程序出现异常了。这时，文件尾部的校验和，还是一个旧值。数据库会去校验，文件尾部的校验和，不等于文件头部的新值，说明该数据页的数据是不完整的。&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;7.页头部&lt;/span&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;通过上面介绍的内容，数据页之间能够轻松访问了，但剩下还有个比较重要的问题，就是记录的状态信息。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;比如一页数据到底保存了多条记录，或者页目录到底使用了多个槽等。这些信息是实时统计，还是事先统计好了，保存到某个地方？&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;为了性能考虑，上面的这些统计数据，当然是先统计好，保存到一个地方。后面需要用到该数据时，再读取出来会更好。这个保存统计数据的地方，就是&lt;/span&gt;&lt;code&gt;页头部&lt;/code&gt;&lt;span&gt;。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;当然页头部不仅仅只保存：槽的数量、记录条数等信息。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;它还记录了：&lt;/span&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;已删除记录所占的字节数&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;最后插入记录的位置&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;最大事务id&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;索引id&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;索引层级&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;其实还有很多，在这里就不一一列举了。&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;总结&lt;/span&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;多个数据页之间通过&lt;/span&gt;&lt;code&gt;页号&lt;/code&gt;&lt;span&gt;构成了双向链表。而每一个数据页的行数据之间，又通过&lt;/span&gt;&lt;code&gt;下一条记录的位置&lt;/code&gt;&lt;span&gt;构成了单项链表。整体架构图如下：&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.561525129982669&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/uL371281oDER9lbESUVq7L6u9ftCRzaTtRWdBL3V9p9UOMy1Pqk1vf2Vy4nxK4ia07d1oZZdxS4kjSzgAUDVcog/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1154&quot;/&gt;&lt;span&gt;好了，本文内容先到这里。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;参考：《mysql是怎样运行的》&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>