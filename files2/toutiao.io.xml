<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>04048bc469ccb6962538592f678430b3</guid>
<title>Low-Code，一定“low”吗？</title>
<link>https://toutiao.io/k/ntem83g</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;preview&quot;&gt;&lt;p&gt;&lt;strong&gt;作者：京东保险 吴凯&lt;/strong&gt;&lt;/p&gt;

&lt;h1&gt;前言&lt;/h1&gt;

&lt;p&gt;低代码是一组数字技术工具平台，基于图形化拖拽、参数化配置等更为高效的方式，实现快速构建、数据编排、连接生态、中台服务。通过少量代码或不用代码实现数字化转型中的场景应用创新。本文将重点介绍低代码相关知识，包括低代码的定义与意义、相关概念、行业发展等，同时介绍京东的低代码工具，期望能帮助大家更好地认识与理解低代码。&lt;/p&gt;

&lt;h1&gt;一、低代码介绍&lt;/h1&gt;

&lt;p&gt;2014年，Forrester（著名研究咨询机构）提出“低代码”的术语，定义为“利用很少或几乎不需要写代码就可以快速开发应用，并可以快速配置和部署的一种技术和工具”。或者说是“（能力）多（出品）快（质量）好（功夫）省”。﻿&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://p3-sign.toutiaoimg.com/tos-cn-i-qvj2lq49k0/68f69a26265b4dec94b71e9ce6ffd814%7Enoop.image?_iz=58558&amp;amp;from=article.pc_detail&amp;amp;x-expires=1681085687&amp;amp;x-signature=f8EUid2x4pT7tkO0tooz3qLbXfA%3D&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;这个定义体现出低代码的核心价值：&lt;/p&gt;

&lt;p&gt;1、低代码开发平台能够实现业务应用的快速交付。低代码开发的重点是开发应用快，不像传统意义上仅仅是一个应用的开发，而是通过可视化的开发，达到“设计及交付”的目的，提高开发效率。&lt;/p&gt;

&lt;p&gt;2、低代码开发平台能够降低业务应用的开发成本。低代码开发投入更低，主要体现在开发时间短，可以快速配置和部署，同时也更容易使非开发人员上手。&lt;/p&gt;

&lt;h1&gt;二、我们为什么用低代码&lt;/h1&gt;

&lt;p&gt;低代码可以降本增效，一方面低代码的出现避免了“反复造轮子”的问题，其通过可视化的编程方式实现“千人千面”的效果，驱使技术回归本源--支持业务。另一方面低代码的生命周期贯穿整个软件开发周期(设计、开发、测试、交付)，周期上的各角色都可以在同一个低代码开发平台上紧密协作，由传统的开发方式变为敏捷开发，实现了快速交付的目的。&lt;/p&gt;

&lt;p&gt;低代码的使用场景：&lt;/p&gt;

&lt;p&gt;1、构建新的SaaS应用，而借助低代码平台可以快速有效地构建、测试和推出应用。低代码与SaaS的结合，可以为企业提供独特的业务解决方案。&lt;/p&gt;

&lt;p&gt;2、基于Web的门户网站是提供自助服务的数字化工具。使用低代码开发平台，更简单、更快速地构建个性化应用，打造数字化平台。&lt;/p&gt;

&lt;p&gt;3、历史系统的迁移或升级。基于低代码技术：一方面，最大限度地保留遗留系统的代码，保留其“公共数据服务”；另一方面，基于遗留系统的开发环境和能力构建相应的“功能适配器”，然后在此基础上，通过低代码技术快速定制新业务和流程的交互式UI与业务逻辑。&lt;/p&gt;

&lt;p&gt;4、应用复杂性低，业务流程相对简单，95%的应用场景可以通过低代码完成。﻿&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://p3-sign.toutiaoimg.com/tos-cn-i-qvj2lq49k0/18d7857439b348b486a588044d761822%7Enoop.image?_iz=58558&amp;amp;from=article.pc_detail&amp;amp;x-expires=1681085687&amp;amp;x-signature=kKK1f21Dzvlo8PWApXFI8r2Yaiw%3D&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h1&gt;三、低代码会使程序员失业吗&lt;/h1&gt;

&lt;p&gt;回答这个问题，我们首先需要搞明白：低代码和零代码的区别。作为程序员，大家都会把低代码认为是零代码，这也是会被误解程序员失业的原因之一。&lt;/p&gt;

&lt;p&gt;低代码，意味着反复迭代的代码质量高，在必要的时候，也会进行代码的编写；BUG更少，减少了测试环节的工作量。&lt;/p&gt;

&lt;p&gt;零代码，字面意思：完全不需要任何代码即可完成应用开发，从软件开发效率看，&lt;strong&gt;零代码是低代码的最终形态。&lt;/strong&gt;零代码平台由于采用全部都是封装模块进行搭建，所有控件都已经被固化了，所以用零代码平台搭建的系统想要进行扩展是有些困难的。&lt;/p&gt;

&lt;p&gt;现实是，编码的最终目的是支持业务，业务逻辑的复杂与否依旧需要人来掌握，低代码只是写的少，并不是不写代码，这并不会导致程序员的失业﻿&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://p3-sign.toutiaoimg.com/tos-cn-i-qvj2lq49k0/566650c3d06a4a078c5fd76308992334%7Enoop.image?_iz=58558&amp;amp;from=article.pc_detail&amp;amp;x-expires=1681085687&amp;amp;x-signature=xR1IkROqLKgChkE4AL2mt6iUoyo%3D&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h1&gt;四、低代码的行业现状&lt;/h1&gt;

&lt;p&gt;2021年11月11日，Forrester发布《The State Of Low-Code Platforms In China》，这是低代码概念提出者第一次将视角聚焦在中国。Forrester认为，低代码目前在国内主要应用于银行、保险、零售、医疗、政府、制造、电信和建筑行业。比如，为了针对各个业务单元量身定制各种业务需求，中国建设银行采用&lt;strong&gt;云枢&lt;/strong&gt;为其分布式开发团队构建统一的低代码开发平台（LCDP）。另外，报告指出：中国企业数字化转型过程中，有58%的决策者正在采用低代码工具进行软件构建，另有16%的决策者计划采用低代码。&lt;/p&gt;

&lt;p&gt;目前，国内的低代码开发平台不断涌现，Forrester划分了9类低代码平台厂商：&lt;/p&gt;

&lt;p&gt;▪数字流程自动化（BPM）：炎黄盈动（AWS PaaS）、奥哲（云枢）&lt;/p&gt;

&lt;p&gt;▪公有云：阿里巴巴（宜搭）、百度（爱速搭）、华为（应用魔方）、微软（Power Platform）、腾讯（微搭）&lt;/p&gt;

&lt;p&gt;▪面向专业开发者的低代码开发平台：ClickPaaS、葡萄城（活字格）、Mendix、Outsystems&lt;/p&gt;

&lt;p&gt;▪面向业务开发者的低代码开发平台：捷德（Joget DX）、轻流&lt;/p&gt;

&lt;p&gt;▪AI/机器学习：第四范式（HyperCycle）&lt;/p&gt;

&lt;p&gt;▪BI：帆软（简道云）&lt;/p&gt;

&lt;p&gt;▪协作管理：泛微（E-Builder）&lt;/p&gt;

&lt;p&gt;▪流程自动化机器人（RPA）：云扩（ViCode）、来也（流程创造者）&lt;/p&gt;

&lt;p&gt;▪数字化运营平台：博科（Yigo）、金蝶（金蝶云·苍穹）、浪潮（iGIX）、用友（YonBIP）&lt;/p&gt;

&lt;p&gt;由此可知，中国的低代码市场正在飞速发展，各种低代码工具的发布问世，也意味着低代码未来将成为主流的开发方式。&lt;/p&gt;

&lt;h1&gt;五、业内的低代码平台&lt;/h1&gt;

&lt;p&gt;1、Out-System&lt;/p&gt;

&lt;p&gt;OutSytems 作为国外著名的低代码开发平台，出发点就是简化整个应用开发和交付的过程，让开发人员可以快速响应市场的需求变化。通过可视化和模型驱动的开发方式，大幅减少时间和成本。并通过预构建的连接器加速集成后端系统，同时还提供了一个集中式的控制台来管理应用的版本、发布以及部署。&lt;/p&gt;

&lt;p&gt;OutSytems 生成的应用可以不依赖于 OutSytems 运行。数据是直接存储到数据库，这样就可以通过任何标准的 ETL、 BI或其他第三方数据工具来访问数据。&lt;/p&gt;

&lt;p&gt;官网：&lt;br/&gt;
&lt;a href=&quot;https://www.outsystems.com/demos/&quot;&gt;https://www.outsystems.com/demos/&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;2、阿里-云凤蝶&lt;/p&gt;

&lt;p&gt;云凤蝶是蚂蚁金服体验技术部的重点研发项目，是面向中后台产品的快速研发平台，主要用户面向工程师，使用场景专注在标准化的中后台产品研发，目标是为了提高效率。&lt;/p&gt;

&lt;p&gt;云凤蝶的核心思路是将组件生产和组件组装这两部分工作进行职责分离，通过建立一条组件组装流水线，打通 npm 组件的一键导入流程，从而完成一条产业链式的分工协作，最终实现规模化的快速生产。&lt;/p&gt;

&lt;p&gt;淘系的“乐高”系统以及蚂蚁金服的“金蝉”系统、“云凤蝶”系统成微阿里系主要的低代码开发工具。&lt;/p&gt;

&lt;p&gt;3、京东-星链&lt;/p&gt;

&lt;p&gt;星链是京东科技消金基础研发部开发的一款研发效能提升工具，主要为面向后端服务研发需求，因此前端简洁可视化开发界面需要满足极致的细节，并依赖其自身后端的能力来实现用户的低代码。&lt;/p&gt;

&lt;p&gt;核心概念：&lt;/p&gt;

&lt;p&gt;VMS可视化微服务应用，是星链的基本单元，同时VMS也是一种模型，各种配置均在模型中。支持京东中间件（JSF、定时任务、JMQ，缓存服务、分布式配置等），服务流程编排，DEBUG调试等；&lt;/p&gt;

&lt;p&gt;Serverless部署，星链的部署及配置均由系统自动分配。用户只需关注系统的开发，资源的使用情况。&lt;/p&gt;

&lt;p&gt;地址：&lt;a href=&quot;http://jddlink.jd.com/&quot;&gt;http://jddlink.jd.com/&lt;/a&gt;&lt;/p&gt;

&lt;h1&gt;结论&lt;/h1&gt;

&lt;p&gt;低代码，一定不“low”，却更low-code。&lt;/p&gt;

&lt;p&gt;参考：&lt;/p&gt;

&lt;p&gt;2021年低代码平台中国市场现状分析报告&lt;br/&gt;
&lt;a href=&quot;https://www.authine.com/report/56.html&quot;&gt;https://www.authine.com/report/56.html&lt;/a&gt;&lt;/p&gt;
&lt;/div&gt;
  &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>8a8e40d13e17727392acca52e178f1e3</guid>
<title>5 种微服务网关，该选哪个？</title>
<link>https://toutiao.io/k/fzxlagi</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot; data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;大家好呀，我是楼仔。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;发现最近最近很多号主发网关的文章，质量参差不齐，建议直接看这篇，有理论，有实战。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;不 BB，上文章目录：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.7203703703703703&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sXFqMxQoVLF8nib1JalS4mKP0xKmFF9jqfHmeEMxyp90Y0uN9Fm90pCa1KppUWSdN3U5T6r6X7LibdwyU7ZVvWdg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/figure&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;1 API网关基础&lt;/h1&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;1.1 什么是API网关&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;API网关是一个服务器，是系统的唯一入口。&lt;/strong&gt; 从面向对象设计的角度看，它与外观模式类似。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;API网关封装了系统内部架构，为每个客户端提供一个定制的API。它可能还具有其它职责，如身份验证、监控、负载均衡、缓存、协议转换、限流熔断、静态响应处理。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;API网关方式的核心要点是，所有的客户端和消费端都通过统一的网关接入微服务&lt;/strong&gt;，在网关层处理所有的非业务功能。通常，网关也是提供REST/HTTP的访问API。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;1.2 网关的主要功能&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;微服务网关作为微服务后端服务的统一入口，它可以统筹管理后端服务，主要分为数据平面和控制平面：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;数据平面主要功能是接入用户的HTTP请求和微服务被拆分后的聚合。使用微服务网关统一对外暴露后端服务的API和契约，路由和过滤功能正是网关的核心能力模块。另外，微服务网关可以实现拦截机制和专注跨横切面的功能，包括协议转换、安全认证、熔断限流、灰度发布、日志管理、流量监控等。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;控制平面主要功能是对后端服务做统一的管控和配置管理。例如，可以控制网关的弹性伸缩；可以统一下发配置；可以对网关服务添加标签；可以在微服务网关上通过配置Swagger功能统一将后端服务的API契约暴露给使用方，完成文档服务，提高工作效率和降低沟通成本。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.9646697388632872&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sXFqMxQoVLF8nib1JalS4mKP0xKmFF9jq9I05BYItaablgPbjFnwhuhia633g0YAiaRiaF2vWQ1Hg4675GbSnwTWibw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;651&quot;/&gt;&lt;/figure&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;路由功能&lt;/strong&gt;：路由是微服务网关的核心能力。通过路由功能微服务网关可以将请求转发到目标微服务。在微服务架构中，网关可以结合注册中心的动态服务发现，实现对后端服务的发现，调用方只需要知道网关对外暴露的服务API就可以透明地访问后端微服务。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;负载均衡&lt;/strong&gt;：API网关结合负载均衡技术，利用Eureka或者Consul等服务发现工具，通过轮询、指定权重、IP地址哈希等机制实现下游服务的负载均衡。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;统一鉴权&lt;/strong&gt;：一般而言，无论对内网还是外网的接口都需要做用户身份认证，而用户认证在一些规模较大的系统中都会采用统一的单点登录（Single Sign On）系统，如果每个微服务都要对接单点登录系统，那么显然比较浪费资源且开发效率低。API网关是统一管理安全性的绝佳场所，可以将认证的部分抽取到网关层，微服务系统无须关注认证的逻辑，只关注自身业务即可。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;协议转换&lt;/strong&gt;：API网关的一大作用在于构建异构系统，API网关作为单一入口，通过协议转换整合后台基于REST、AMQP、Dubbo等不同风格和实现技术的微服务，面向Web Mobile、开放平台等特定客户端提供统一服务。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;指标监控&lt;/strong&gt;：网关可以统计后端服务的请求次数，并且可以实时地更新当前的流量健康状态，可以对URL粒度的服务进行延迟统计，也可以使用Hystrix Dashboard查看后端服务的流量状态及是否有熔断发生。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;限流熔断&lt;/strong&gt;：在某些场景下需要控制客户端的访问次数和访问频率，一些高并发系统有时还会有限流的需求。在网关上可以配置一个阈值，当请求数超过阈值时就直接返回错误而不继续访问后台服务。当出现流量洪峰或者后端服务出现延迟或故障时，网关能够主动进行熔断，保护后端服务，并保持前端用户体验良好。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;黑白名单&lt;/strong&gt;：微服务网关可以使用系统黑名单，过滤HTTP请求特征，拦截异常客户端的请求，例如DDoS攻击等侵蚀带宽或资源迫使服务中断等行为，可以在网关层面进行拦截过滤。比较常见的拦截策略是根据IP地址增加黑名单。在存在鉴权管理的路由服务中可以通过设置白名单跳过鉴权管理而直接访问后端服务资源。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;灰度发布&lt;/strong&gt;：微服务网关可以根据HTTP请求中的特殊标记和后端服务列表元数据标识进行流量控制，实现在用户无感知的情况下完成灰度发布。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;流量染色&lt;/strong&gt;：和灰度发布的原理相似，网关可以根据HTTP请求的Host、Head、Agent等标识对请求进行染色，有了网关的流量染色功能，我们可以对服务后续的调用链路进行跟踪，对服务延迟及服务运行状况进行进一步的链路分析。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;文档中心&lt;/strong&gt;：网关结合Swagger，可以将后端的微服务暴露给网关，网关作为统一的入口给接口的使用方提供查看后端服务的API规范，不需要知道每一个后端微服务的Swagger地址，这样网关起到了对后端API聚合的效果。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;日志审计&lt;/strong&gt;：微服务网关可以作为统一的日志记录和收集器，对服务URL粒度的日志请求信息和响应信息进行拦截。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;2 API网关选型&lt;/h1&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;2.1 常用API网关&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;先简单看一下市面上常用的API网关：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.524074074074074&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sXFqMxQoVLF8nib1JalS4mKP0xKmFF9jqY353q2CibSiaEAYxgJib7pvaicj330wFDQ1rlyQgTChRib2cf9obe2nqd9Q/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/figure&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;Nginx&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Nginx是一个高性能的HTTP和反向代理服务器。&lt;strong&gt;Nginx一方面可以做反向代理，另外一方面可以做静态资源服务器，接口使用Lua动态语言可以完成灵活的定制功能。&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Nginx 在启动后，会有一个 Master 进程和多个 Worker 进程，Master 进程和 Worker 进程之间是通过进程间通信进行交互的，如图所示。Worker 工作进程的阻塞点是在像 select()、epoll_wait() 等这样的 I/O 多路复用函数调用处，以等待发生数据可读 / 写事件。Nginx 采用了异步非阻塞的方式来处理请求，也就是说，Nginx 是可以同时处理成千上万个请求的。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;Zuul&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Zuul 是 Netflix 开源的一个API网关组件，它可以和 Eureka、Ribbon、Hystrix 等组件配合使用。社区活跃，融合于 SpringCloud 完整生态，是构建微服务体系前置网关服务的最佳选型之一。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Zuul 的核心是一系列的过滤器，这些过滤器可以完成以下功能：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;统一鉴权 + 动态路由 + 负载均衡 + 压力测试&lt;/strong&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;审查与监控&lt;/strong&gt;：与边缘位置追踪有意义的数据和统计结果，从而带来精确的生产视图。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;多区域弹性&lt;/strong&gt;：跨越 AWS Region 进行请求路由，旨在实现 ELB（Elastic Load Balancing，弹性负载均衡）使用的多样化，以及让系统的边缘更贴近系统的使用者。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Zuul 目前有两个大的版本：&lt;strong&gt;Zuul1 和 Zuul2&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Zuul1 是基于 Servlet 框架构建，如图所示，采用的是阻塞和多线程方式，即一个线程处理一次连接请求，这种方式在内部延迟严重、设备故障较多情况下会引起存活的连接增多和线程增加的情况发生。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5944444444444444&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sXFqMxQoVLF8nib1JalS4mKP0xKmFF9jqERPadLibGEtmQZGJuxv8R5mq8bibMicyLmQKg22k6kssIJhyyLVopoHcw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Netflix 发布的 Zuul2 有重大的更新，它运行在异步和无阻塞框架上，每个 CPU 核一个线程，处理所有的请求和响应，请求和响应的生命周期是通过事件和回调来处理的，这种方式减少了线程数量，因此开销较小。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.775&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sXFqMxQoVLF8nib1JalS4mKP0xKmFF9jqciahkeSJciawxEMX7ujQoKowwTiavDVvOWOBFNccwyUo4tOohKIM6Z0WQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/figure&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;Spring Cloud GetWay&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Spring Cloud Gateway 是Spring Cloud的一个全新的API网关项目，目的是为了替换掉Zuul1，它基于Spring5.0 + SpringBoot2.0 + WebFlux（基于⾼性能的Reactor模式响应式通信框架Netty，异步⾮阻塞模型）等技术开发，性能⾼于Zuul，官⽅测试，&lt;strong&gt;Spring Cloud GateWay是Zuul的1.6倍&lt;/strong&gt;，旨在为微服务架构提供⼀种简单有效的统⼀的API路由管理⽅式。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Spring Cloud Gateway可以与Spring Cloud Discovery Client（如Eureka）、Ribbon、Hystrix等组件配合使用，&lt;strong&gt;实现路由转发、负载均衡、熔断、鉴权、路径重写、⽇志监控等，并且Gateway还内置了限流过滤器，实现了限流的功能。&lt;/strong&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6675925925925926&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sXFqMxQoVLF8nib1JalS4mKP0xKmFF9jqbqSiaRYnxafR2VPUZfWvFbMDjC2I8dpkXia0jsfkc1tvy1jWQiaMBc7JA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/figure&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;Kong&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Kong是一款基于OpenResty（Nginx + Lua模块）编写的高可用、易扩展的，由Mashape公司开源的API Gateway项目。&lt;strong&gt;Kong是基于NGINX和Apache Cassandra或PostgreSQL构建的&lt;/strong&gt;，能提供易于使用的RESTful API来操作和配置API管理系统，所以它可以水平扩展多个Kong服务器，通过前置的负载均衡配置把请求均匀地分发到各个Server，来应对大批量的网络请求。&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6703703703703704&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sXFqMxQoVLF8nib1JalS4mKP0xKmFF9jqjhEVqqsQh31ib4tpkKMFucWAvFiadSoxnGl7vzsyjuib9BW3DGujmcRUA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Kong主要有三个组件：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;Kong Server ：基于Nginx的服务器，用来接收API请求。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Apache Cassandra/PostgreSQL ：用来存储操作数据。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Kong dashboard：官方推荐UI管理工具，也可以使用 restfull 方式管理admin api。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Kong采用插件机制进行功能定制，插件集（可以是0或N个）在API请求响应循环的生命周期中被执行。插件使用Lua编写，目前已有几个基础功能：&lt;strong&gt;HTTP基本认证、密钥认证、CORS（Cross-Origin Resource Sharing，跨域资源共享）、TCP、UDP、文件日志、API请求限流、请求转发以及Nginx监控。&lt;/strong&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.40555555555555556&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sXFqMxQoVLF8nib1JalS4mKP0xKmFF9jqySX8C24AZ8vtzFajwZBRxfOdkqLXop2OjMZl9cGGiaM6FXz83EMbUcg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Kong网关具有以下的特性：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;可扩展性: 通过简单地添加更多的服务器，可以轻松地进行横向扩展，这意味着您的平台可以在一个较低负载的情况下处理任何请求；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;模块化: 可以通过添加新的插件进行扩展，这些插件可以通过RESTful Admin API轻松配置；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;在任何基础架构上运行: Kong网关可以在任何地方都能运行。您可以在云或内部网络环境中部署Kong，包括单个或多个数据中心设置，以及public，private 或invite-only APIs。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;Traefik&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Træfɪk 是一个为了让部署微服务更加便捷而诞生的现代HTTP反向代理、负载均衡工具。它支持多种后台 (Docker, Swarm, Kubernetes, Marathon, Mesos, Consul, Etcd, Zookeeper, BoltDB, Rest API, file…) 来自动化、动态的应用它的配置文件设置。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5675925925925925&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sXFqMxQoVLF8nib1JalS4mKP0xKmFF9jqM7nPc2rZXA7q6V49efdkE0J512K904IiatwfGvDeXGgC7pTJYmzFcxg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;重要特性：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;它非常快，无需安装其他依赖，通过Go语言编写的单一可执行文件；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;多种后台支持：Docker, Swarm, Kubernetes, Marathon, Mesos, Consul, Etcd；&lt;/strong&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;支持支持Rest API、Websocket、HTTP/2、Docker镜像；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;监听后台变化进而自动化应用新的配置文件设置；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;配置文件热更新，无需重启进程；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;后端断路器、负载均衡、容错机制；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;清爽的前端页面，可监控服务指标。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;关于Traefik的更多内容，可以查看官网：https://traefik.cn/&lt;/p&gt;&lt;/blockquote&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;2.2 API网关对比&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.7694444444444445&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sXFqMxQoVLF8nib1JalS4mKP0xKmFF9jqmdcAhlyOCoQO3ZWp4x2VPe4TOb2CnicX6w7a6cq0SjYL8fibssMFtg6Q/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.7157407407407408&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sXFqMxQoVLF8nib1JalS4mKP0xKmFF9jqsstHBuG95GdhfLC5AmrfpAndwrQ63RrlXsEMulGV806J2jQAYZ8sHQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.26944444444444443&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sXFqMxQoVLF8nib1JalS4mKP0xKmFF9jqs2RJ6eaVFUInFOy8VOESXrricic7EIqvuFu7g7f6RZv8iasV9uIOuASEw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上面是网关对比截图，偷个懒，大家主要关注Kong、Traefik和Zuul即可：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;从&lt;strong&gt;开源社区活跃度&lt;/strong&gt;来看，无疑是Kong和Traefik较好；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;从&lt;strong&gt;成熟度&lt;/strong&gt;来看，较好的是Kong、Tyk、Traefik；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;从&lt;strong&gt;性能&lt;/strong&gt;来看，Kong要比其他几个领先一些；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;从&lt;strong&gt;架构优势&lt;/strong&gt;的扩展性来看，Kong、Tyk有丰富的插件，Ambassador也有插件但不多，而Zuul是完全需要自研，但Zuul由于与Spring Cloud深度集成，使用度也很高，近年来Istio服务网格的流行，Ambassador因为能够和Istio无缝集成也是相当大的优势。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;下面是其它网友的思考结论，可供参考：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;性能&lt;/strong&gt;：Nginx+Lua形式必然是高于Java语言实现的网关的，Java技术栈里面Zuul1.0是基于Servlet实现的，剩下都是基于webflux实现，性能是高于基于Servlet实现的。&lt;strong&gt;在性能方面我觉得选择网关可能不算那么重要，多加几台机器就可以搞定。&lt;/strong&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;可维护性和扩展性&lt;/strong&gt;：Nginx+Lua这个组合掌握的人不算多，如果团队有大神，大佬们就随意了，当没看到这段话，对于一般团队来说的话，选择自己团队擅长的语言更重要。Java技术栈下的3种网关，对于Zuul和Spring Cloud Getway需要或多或少要搞一些集成和配置页面来维护，但是对于Soul我就无脑看看文章，需要哪个搬哪个好了，尤其是可以无脑对接Dubbo美滋滋，此外Soul2.0以后版本可以摆脱ZK，在我心里再无诟病，我就喜欢无脑操作。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;高可用&lt;/strong&gt;：对于网关高可用基本都是统一的策略都是采用多机器部署的方式，前面挂一个负载，对于而外需要用的一些组件大家注意一下。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;3 基于Traefik自研的微服务网关&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个是我司自研的微服务网关，基于Traefik进行开发，下面从技术选型、网关框架、网关后台、协议转换进行讲解，绝对干货！&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;3.1 技术栈选型&lt;/h2&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;Traefik&lt;/strong&gt;：一款开源的反向代理与负载均衡工具，它最大的优点是能够与常见的微服务系统直接整合，可以实现自动化动态配置。traefik较为轻量，非常易于使用和设置，性能比较好，已在全球范围内用于生产环境。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;Etcd&lt;/strong&gt;：一个Go言编写的分布式、高可用的一致性键值存储系统，用于提供可靠的分布式键值存储、配置共享和服务发现等功能。（更多内容可以查看文章 &lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=Mzg3OTU5NzQ1Mw==&amp;amp;mid=2247485759&amp;amp;idx=1&amp;amp;sn=41957e94a2c69426befafd373fbddcc5&amp;amp;chksm=cf034bddf874c2cb52a7aafea5cd194e70308c7d4ad74183db8a36d3747122be1c7a31b84ee3&amp;amp;token=179167416&amp;amp;lang=zh_CN&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;肝了一个月的ETCD，从Raft原理到实践&lt;/a&gt; ）&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;Go&lt;/strong&gt;：并发能力强，性能媲美C，处理能力是PHP的4倍，效率高，语法简单，易上手，开发效率接近PHP。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.43425925925925923&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sXFqMxQoVLF8nib1JalS4mKP0xKmFF9jqaroPNjp44FypocdwqVibvrFHC4icPg5arzCIlIgL9p9vG90VichvlRnVA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/figure&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;3.3 网关框架&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;整个网关框架分为3块：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;网关后台&lt;/strong&gt;（hal-fe和hal-admin）：用于应用、服务和插件的配置，然后将配置信息发布到ETCD；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;Traefik&lt;/strong&gt;：读取ETCD配置，根据配置信息对请求进行路由分发，如果需要鉴权，会直接通过hal-agent模块进行统一鉴权。鉴权完毕后，如果是Http请求，直接打到下游服务，如果是Grpc和Thrift协议，会通过hal-proxy模块进行协议转换。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;协议转换模块&lt;/strong&gt;：读取ETCD配置，对Traefik分发过来的请求，进行Grpc和Thrift协议转换（更多内容可以查看文章 &lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=Mzg3OTU5NzQ1Mw==&amp;amp;mid=2247486405&amp;amp;idx=1&amp;amp;sn=e03722a78de27f7aacea2189461b1848&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;RPC框架：从原理到选型，一文带你搞懂RPC&lt;/a&gt;），并通过服务发现机制，获取服务下游机器，并通过负载均衡，将转换后的数据打到下游服务机器。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5685185185185185&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sXFqMxQoVLF8nib1JalS4mKP0xKmFF9jqtMNEG126KCJMHTZiaJf98lJsuicfoVmY4zugsCPYHzOu1uKM8L2PiabnA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/figure&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;3.4 网关后台&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;主要由3大模块组成：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;应用&lt;/strong&gt;：主要包括应用名、域名、路径前缀、所属组、状态等，比如印度海外商城、印度社区；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;服务&lt;/strong&gt;：主要包括服务名、注册方式、协议类型、所属组、状态等，比如评论服务、地址服务、搜索服务。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;插件&lt;/strong&gt;：主要包括插件名称、插件类型、插件属性配置等，比如路径前缀替换插件、鉴权插件。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.42592592592592593&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sXFqMxQoVLF8nib1JalS4mKP0xKmFF9jqTM0TJicvSWQ20WTibfvZajvmIsR76fQ3lEFBfwoccQD8dzplqUMY70pg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;一个应用只能绑定一个服务，但是可以绑定多个插件。&lt;/strong&gt; 通过后台完成网关配置后，将这些配置信息生成Config文件，发布到ETCD中，Config文件需要遵循严格的数据格式，比如Traefix配置需要遵循官方的文件配置格式，才能被Traefik识别。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.4324074074074074&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sXFqMxQoVLF8nib1JalS4mKP0xKmFF9jqOZqWmgHH2NpwCrR1DxRScwnAicEpNJqmrvbSVsm31NPJtF130giaicP2Q/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/figure&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;3.5 协议转换模块&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;hal-proxy模块是整个微服务网关最复杂，也是技术含量最高的模块，所以给大家详细讲解一下。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;问题引入&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在讲这个模块前，我们先看下面几个问题：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;当请求从上游的trafik过来时，需要知道访问下游的机器IP和端口，才能将请求发送给下游，这些机器如何获取呢？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;有了机器后，我们需要和下游机器建立连接，如果连接用一次就直接释放，肯定对服务会造成很大的压力，这就需要引入Client缓存池，那这个Client缓存池我们又该如何实现呢？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;最后就是需要对协议进行转换，因为不同的下游服务，支持的协议类型是不一样的，这个网关又是如何动态支持的呢？&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6166666666666667&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sXFqMxQoVLF8nib1JalS4mKP0xKmFF9jq8S1H0Oia8ibe93YXy5zzqmQfkic0wm121qo9KSjuy5KgKia6d0HWFzWO4g/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/figure&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;实现原理&lt;span/&gt;&lt;/h4&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5092592592592593&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sXFqMxQoVLF8nib1JalS4mKP0xKmFF9jqpbZh1JkoCM2mAm5uMWsMTEzLaRheRecS1mtKwFDpxdeeDKan9LtHeA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们还是先看一下hal-proxy内部有哪些模块，首先是Resolver模块，这个模块的是什么作用呢？这里我简单介绍一下，目前公司内部通过服务获取到机器列表的方式有多种，比如MIS平台、服务树等，也就是有的是通过平台配置的，有的是直接挂在服务树下，无论哪种方式，我们都通过服务名，通过一定的方式，找到该服务下面所有的主机。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;所以Resolver模块的作用，其实就是通过服务名，找到该服务下的所有机器的IP和服务端口，然后持久化到内存中，并定时更新。&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;协议模块就是支持不同的协议转换，每个协议类型的转换，都需要单独实现，&lt;strong&gt;这些协议转换，无非就是先通过机器IP和端口初始化Client，然后再将数据进行转换后，直接发送到下游的机器。&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;最后就是连接池，之前我们其实也用到go自带的pool来做，但是当对pool数据进行更新时，需要加锁，所以性能一直起不来，后来&lt;strong&gt;改成了环形队列，然后对数据的操作全部通过原子操作方式，就实现了无锁操作，大大提高的并发性能。&lt;/strong&gt; 环形队列的代码，也给你安排上，可以直接看这篇文章 &lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=Mzg3OTU5NzQ1Mw==&amp;amp;mid=2247484024&amp;amp;idx=1&amp;amp;sn=8345b28106df822b7299dc1efaf49f30&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;Go语言核心手册-10.原子操作&lt;/a&gt;。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;实现逻辑&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个是hal-proxy的逻辑实现图，画了2天，包含所有核心对象的交互方式，这里就不去细讲，能掌握多少，靠大家自己领悟，如果有任何疑问(或者看不清图片)，可以关注我公众号，加我微信沟通。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6638888888888889&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sXFqMxQoVLF8nib1JalS4mKP0xKmFF9jqJJk0oKRNxaGUO3lribwQicHsQcHLvvS6NicpkjTkOQnO5c7ibqd91T8VkA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/figure&gt;&lt;hr data-tool=&quot;mdnice编辑器&quot;/&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;最后，把楼仔的座右铭送给你&lt;/strong&gt;：我从清晨走过，也拥抱夜晚的星辰，人生没有捷径，你我皆平凡，你好，陌生人，一起共勉。&lt;/p&gt;&lt;section&gt;&lt;mp-common-profile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mpprofile&quot; data-weui-theme=&quot;light&quot; data-id=&quot;Mzg3OTU5NzQ1Mw==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/sXFqMxQoVLFTdSvrrpJnCZ0Fp5Z1wKkhKFQBxTaFfxOpib3E2zgUu39BFbsBqqJbEpxicUvz3H6csoL2JQ9EP1yQ/0?wx_fmt=png&quot; data-nickname=&quot;楼仔&quot; data-alias=&quot;&quot; data-signature=&quot;8 年一线大厂（百度小米美团）开发/架构/管理经验，专注硬核文章输出！&quot; data-from=&quot;0&quot; data-is_biz_ban=&quot;0&quot;/&gt;&lt;/section&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;硬核推荐：&lt;span/&gt;&lt;/h5&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>dc88d98f6b59aeb1ff77cc30ec9bacc1</guid>
<title>AIGC 时代，程序员生产力工具推荐（二）</title>
<link>https://toutiao.io/k/cf0zawn</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content js_underline_content              autoTypeSetting24psection&amp;#10;            &quot; id=&quot;js_content&quot;&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;1.3333333333333333&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/hfMV21YZJgjZaTBszDvtCnlzBmaQcLbUwtHCgB9WqFAdBxg7Ty8WUaOCVPJoUDYCST0rWXjYaKZqEf5ib2fFvdQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1080&quot;/&gt;&lt;/p&gt;&lt;p&gt;在&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzAwMTYwNzE2Mg==&amp;amp;mid=2651036900&amp;amp;idx=1&amp;amp;sn=9c1c57b9da06dcbba9f4a84d5e2cb874&amp;amp;scene=21#wechat_redirect&quot; title=&quot;《AIGC 时代，程序员生产力工具推荐》&quot; data-linktype=&quot;2&quot;&gt;《AIGC 时代，程序员生产力工具推荐》&lt;/a&gt;一文中，我们介绍了五个热门的生产力工具。今天，我们将继续分享几个优秀的工具，希望这些工具能够大大提高你的工作效率。&lt;/p&gt;&lt;h2&gt;&lt;span&gt;SQL Chat&lt;sup&gt;[1]&lt;/sup&gt;&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;这是一个开源的客户端，它能够通过自然语言聊天的方式帮助你快速生成 SQL 语句，而无需具备深入的 SQL 知识。此外，它还提供了一种方便的方式来执行 SQL 查询，并获取查询结果。这对于那些需要经常执行 SQL 查询的人来说尤为重要。SQL Chat 的用户界面非常简单易用，你只需要输入你想查询的内容，然后它就会自动生成 SQL 语句。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.3675925925925926&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/hfMV21YZJgjZaTBszDvtCnlzBmaQcLbU5VicWJxalVQ8jQXatSY6rVYoTyM8LK4NVohFiacAD7Ws7bg0GUYgaAicA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/p&gt;&lt;h2&gt;&lt;span&gt;Regex.ai&lt;sup&gt;[2]&lt;/sup&gt;&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;这是一款非常实用的基于 AI 技术的正则表达式自动生成工具。它可以帮助你快速生成正则表达式，同时提供多种提取数据的方式，这能够大大提升你的工作效率。无论你是一名程序员还是数据分析师，Regex.ai 都是一款非常实用的工具。同时，它的所见即所得的功能也使得使用变得更加方便。你只需要选择相应的数据，它就会自动帮你生成正则表达式。因此，它是一款适用于任何技能水平的人的工具，无需任何深入的正则表达式知识。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.48148148148148145&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/hfMV21YZJgjZaTBszDvtCnlzBmaQcLbUEHxtFTb5f8f1K2WkTSMYFt7ib9nYX60ssG808eZw9tNqLI8qqbg8IIQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/p&gt;&lt;h2&gt;&lt;span&gt;Warp.dev&lt;sup&gt;[3]&lt;/sup&gt;&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;如果你是一位经常使用命令行的程序员，那么你可能会发现每天都要键入大量的命令，这可能会使你的工作效率变得低下。但是现在，有了一款全新的命令行工具，你可以通过自然语言执行 shell 命令，这将使你的工作变得更加轻松和高效。这款工具是使用 Rust 编写的，并集成了 GPT3 的能力，可以通过自然语言理解你的意图，并执行相应的命令。无论你是一个经验丰富的程序员还是一个新手，这款工具都能够帮助你提高工作效率。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.5055555555555555&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/hfMV21YZJgjZaTBszDvtCnlzBmaQcLbUNRP6DJrAZXwicQf9l0gWWX86sgHRsB5NfRibmpHUVV7juBwYibH7PGWCg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/p&gt;&lt;h2&gt;&lt;span&gt;Open Commit&lt;sup&gt;[4]&lt;/sup&gt;&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;这是一款非常实用的命令行工具，它能够自动生成 Git 提交信息。无论你是一名新手还是经验丰富的程序员，Open Commit 都能够帮助你生成高质量的提交信息，省去你不必要的时间和精力。这款工具能够生成规范的提交信息，帮助你更加清晰地记录每一个提交的目的和意义。这样，你可以更加专注于开发，而不是手动撰写提交信息。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.5472222222222223&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/hfMV21YZJgjZaTBszDvtCnlzBmaQcLbUJZ1iaVhBjaTl9h4d5icps1Qc0MPucP3tgtZNNPtPicicpFGHLBQ3G71mMw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/p&gt;&lt;p&gt;以上就是本期要推荐的几个优秀的生产力工具。希望这些工具能够帮助你更加高效地完成工作。如果你有任何问题或想法，请随时在评论区留言，我们将尽快回复你。&lt;/p&gt;&lt;h3&gt;References&lt;/h3&gt;&lt;p&gt;&lt;code&gt;[1]&lt;/code&gt; SQL Chat: &lt;em&gt;https://www.sqlchat.ai/&lt;/em&gt;&lt;br/&gt;&lt;code&gt;[2]&lt;/code&gt; Regex.ai: &lt;em&gt;https://regex.ai/&lt;/em&gt;&lt;br/&gt;&lt;code&gt;[3]&lt;/code&gt; Warp.dev: &lt;em&gt;https://www.warp.dev/&lt;/em&gt;&lt;br/&gt;&lt;code&gt;[4]&lt;/code&gt; Open Commit: &lt;em&gt;https://github.com/di-sukharev/opencommit&lt;/em&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;mp-style-type data-value=&quot;3&quot;/&gt;&lt;/p&gt;&lt;/div&gt;

          
        &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>58951e9aa1dbca3d56bcfaa665fd465c</guid>
<title>Golang 整洁架构实践</title>
<link>https://toutiao.io/k/5fvrx8u</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;RichText ztext Post-RichText css-1g0fqss&quot; options=&quot;[object Object]&quot;&gt;&lt;p data-first-child=&quot;&quot;/&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-89bb28ac30cad27078cce97f6a344644_b.gif&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-thumbnail=&quot;https://pic1.zhimg.com/v2-89bb28ac30cad27078cce97f6a344644_b.jpg&quot; class=&quot;content_image&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-thumbnail=&quot;https://pic1.zhimg.com/v2-89bb28ac30cad27078cce97f6a344644_b.jpg&quot; class=&quot;content_image lazy&quot; data-actualsrc=&quot;https://pic1.zhimg.com/v2-89bb28ac30cad27078cce97f6a344644_b.gif&quot;/&gt;&lt;/figure&gt;&lt;p class=&quot;ztext-empty-paragraph&quot;&gt;&lt;/p&gt;&lt;p class=&quot;ztext-empty-paragraph&quot;&gt;&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-a27f722f9cc4ad405b5779a770c6a080_b.gif&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-thumbnail=&quot;https://pic1.zhimg.com/v2-a27f722f9cc4ad405b5779a770c6a080_b.jpg&quot; class=&quot;content_image&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-thumbnail=&quot;https://pic1.zhimg.com/v2-a27f722f9cc4ad405b5779a770c6a080_b.jpg&quot; class=&quot;content_image lazy&quot; data-actualsrc=&quot;https://pic1.zhimg.com/v2-a27f722f9cc4ad405b5779a770c6a080_b.gif&quot;/&gt;&lt;/figure&gt;&lt;p class=&quot;ztext-empty-paragraph&quot;&gt;&lt;/p&gt;&lt;p data-pid=&quot;T7s0C02m&quot;&gt;&lt;b&gt;  腾小云导读&lt;/b&gt;&lt;/p&gt;&lt;p data-pid=&quot;NO_Gl700&quot;&gt;为了降低系统组件之间的耦合、提升系统的可维护性，一个好的代码框架显得尤为重要。本文将为大家介绍众所周知的三种代码框架，并从三种框架引申出COLA 架构以及作者基于 COLA 架构设计的 Go 语言项目脚手架实践方案。希望能给广大开发爱好者带来帮助和启发！&lt;/p&gt;&lt;hr/&gt;&lt;p data-pid=&quot;NVzc2ZJY&quot;&gt;&lt;b&gt;  看目录，点收藏&lt;/b&gt;&lt;/p&gt;&lt;p data-pid=&quot;swBsurZ5&quot;&gt;1.为什么要有代码架构&lt;/p&gt;&lt;p data-pid=&quot;Oi0F9D87&quot;&gt;2.好的代码架构是如何构建的&lt;/p&gt;&lt;p data-pid=&quot;qbAt8TUY&quot;&gt;    2.1 整洁架构&lt;/p&gt;&lt;p data-pid=&quot;jxXdqX4W&quot;&gt;    2.2 洋葱架构&lt;/p&gt;&lt;p data-pid=&quot;vBHb5PV7&quot;&gt;    2.3 六边形架构&lt;/p&gt;&lt;p data-pid=&quot;dYUhWRyx&quot;&gt;    2.4 COLA架构&lt;/p&gt;&lt;p data-pid=&quot;7Za0GUu1&quot;&gt;3.推荐一种 Go 代码架构实践&lt;/p&gt;&lt;p data-pid=&quot;FGmjDXk7&quot;&gt;4.总结&lt;/p&gt;&lt;p data-pid=&quot;KZxbVUip&quot;&gt;*本文提及的架构主要指项目组织的“代码架构”，注意与微服务架构等名词中的服务架构进行区分。&lt;/p&gt;&lt;p class=&quot;ztext-empty-paragraph&quot;&gt;&lt;/p&gt;&lt;h2 id=&quot;h_618123369_0&quot; data-into-catalog-status=&quot;&quot;&gt;01、为什么要有代码架构&lt;/h2&gt;&lt;p data-pid=&quot;vFqRj6UP&quot;&gt;历史悠久的项目大都会有很多开发人员参与“贡献”，在没有好的指导规则约束的情况下，大抵会变成一团乱麻。剪不断，理还乱，也没有开发勇士愿意去剪去理。被迫接手的开发勇士如果想要增加一个小需求，可能需要花10倍的时间去理顺业务逻辑，再花 10 倍的时间去补充测试代码，实在是低效又痛苦。&lt;/p&gt;&lt;p data-pid=&quot;NjqKDLFa&quot;&gt;这是一个普遍的痛点问题，有无数开发者尝试过去解决它。这么多年发展下来，业界自然也诞生了很多软件架构。大家耳熟能详的就有六边形架构（Hexagonal Architecture），洋葱架构（Onion Architecture），整洁架构（Clean Architecture）等。&lt;/p&gt;&lt;p data-pid=&quot;7O6BTyox&quot;&gt;这些架构在细节上有所差异，但是核心目标是一致的：致力于实现软件系统的&lt;b&gt;关注点分离&lt;/b&gt;（separation of concerns）。&lt;/p&gt;&lt;p data-pid=&quot;_aS6Mt77&quot;&gt;关注点分离之后的软件系统都具备如下特征：&lt;/p&gt;&lt;ul&gt;&lt;li data-pid=&quot;jC3U4XUa&quot;&gt;&lt;b&gt;不依赖特定 UI。&lt;/b&gt;UI 可以任意替换，不会影响系统中其他组件。从 Web UI 变成桌面 UI，甚至变成控制台 UI 都无所谓，业务逻辑不会被影响。&lt;/li&gt;&lt;li data-pid=&quot;zaRRXlYE&quot;&gt;&lt;b&gt;不依赖特定框架。&lt;/b&gt;以 JavaScript 生态举例，不管是使用 web 框架 koa、express，还是使用桌面应用框架 electron，还是控制台框架 commander，业务逻辑都不会被影响，被影响的只会是框架接入的那一层。&lt;/li&gt;&lt;li data-pid=&quot;m0LDnBdk&quot;&gt;&lt;b&gt;不依赖特定外部组件。&lt;/b&gt;系统可以任意使用 MySQL、MongoDB或 Neo4j 作为数据库，任意使用 Redis、Memcached或 etcd 作为键值存储等。业务逻辑不会因为这些外部组件的替换而变化。&lt;/li&gt;&lt;li data-pid=&quot;38C3WaqS&quot;&gt;&lt;b&gt;容易测试。&lt;/b&gt;核心业务逻辑可以在不需要 UI、不需要数据库、不需要 Web 服务器等一切外界组件的情况下被测试。这种纯粹的代码逻辑意味着清晰容易的测试。&lt;/li&gt;&lt;/ul&gt;&lt;p data-pid=&quot;yMhTF-6S&quot;&gt;软件系统有了这些特征后，易于测试，更易于维护、更新，大大减轻了软件开发人员的心理负担。所以，好的代码架构值得推崇。&lt;/p&gt;&lt;p class=&quot;ztext-empty-paragraph&quot;&gt;&lt;/p&gt;&lt;h2 id=&quot;h_618123369_1&quot; data-into-catalog-status=&quot;&quot;&gt;02、好的代码架构是如何构建的&lt;/h2&gt;&lt;p data-pid=&quot;kyrHCRXd&quot;&gt;前文所述的三个架构在理念上是近似的，从下文图 1 到图 3 三幅架构图中也能看出相似的圈层结构。图中可以看到，越往外层越具体，越往内层越抽象。这也意味着，越往外越有可能发生变化，包括但不限于框架升级、中间件变更、适配新终端等等。&lt;/p&gt;&lt;p class=&quot;ztext-empty-paragraph&quot;&gt;&lt;/p&gt;&lt;h3 id=&quot;h_618123369_2&quot; data-into-catalog-status=&quot;&quot;&gt;&lt;b&gt;2.1&lt;/b&gt; 整洁架构&lt;/h3&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-cb24a37eb63e6dbba71e7d1800ee8289_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; class=&quot;content_image&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; class=&quot;content_image lazy&quot; data-actualsrc=&quot;https://pic2.zhimg.com/v2-cb24a37eb63e6dbba71e7d1800ee8289_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p data-pid=&quot;6xcWynrf&quot;&gt;图 1 The Clean Architecture, Robert C. Martin&lt;/p&gt;&lt;p class=&quot;ztext-empty-paragraph&quot;&gt;&lt;/p&gt;&lt;p data-pid=&quot;5XpsI0n3&quot;&gt;图 1&lt;b&gt; 整洁架构&lt;/b&gt;的同心圆结构中可以看见三条由外向内的黑色箭头，它表示依赖规则（The Dependency Rule）。依赖规则规定外层的代码可以依赖内层，但是内层的代码不可以依赖外层。也就是说内层逻辑不可以依赖任何外层定义的变量、函数、结构体、类、模块等等代码实体。假如最外层蓝色层“Frameworks &amp;amp; Drivers” DB 处使用了 go 语言的 gorm 三方库，并定义了 gorm 相关的数据库结构体及其 tag 等。那么内层的 Gateways、Use Cases、Entities 等处不可以引用任何外层中 gorm 相关的结构体或方法，甚至不应该感知到 gorm 的存在。&lt;/p&gt;&lt;p data-pid=&quot;f6ZAfd-D&quot;&gt;核心层的 Entities 定义表示核心业务规则的核心业务实体。这些实体既可以是带方法的类，也可以是带有一堆函数的结构体。但它们必须是高度抽象的，只可以随着核心业务规则而变化，不可以随着外层组件的变化而变化。以简单博客系统举例的话，此层可以定义 Blog、Comment 等核心业务实体。&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;type Blog struct {...}
type Comment struct {...}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p data-pid=&quot;FWOl7ymC&quot;&gt;应用业务层的 Use Cases 应该包含软件系统的所有业务逻辑。该层控制所有流向和流出核心层的数据流，并使用核心层的实体及其业务规则来完成业务需求。此层的变更不会影响核心层、更外层的变更，例如开发框架、数据库、UI 等变化，也不会影响此层。接着博客系统的例子，此层可以定义 BlogManager 接口，并定义其中的 CreateBlog, LeaveComment 等业务逻辑方法。&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;type BlogManager interface {
    CreateBlog(...) ...
    LeaveComment(...) ...}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p data-pid=&quot;S07iEaUt&quot;&gt;接口适配层的 Controllers 将外层输入的数据格式转换成内层 Use Cases 和 Entities 方便使用的格式，然后 Presenters，Gateways 再将内层处理结果转换成外层方便使用的格式，然后再由更外层呈现到 Web、UI 或者写入到数据库。假如系统选择关系型数据库做为其持久化方案的话，那么所有关于 SQL 的处理都应该在此层完成，更内层不需要感知到任何数据库的存在。&lt;/p&gt;&lt;p data-pid=&quot;jjoeomxX&quot;&gt;同理，假如系统与外界服务通信，那么所有有关外界服务数据的转化都在此层完成，更内层也不需要感知到外界服务的存在。外层通过此层传递数据一般通过DTO（Data Transfer Object）或者DO（Data Object）完成。接上文博客系统例子，示例代码如下：&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;type BlogDTO struct { // Data Transfer Object
    Content string `json:&quot;...&quot;`
}

// DTO 与 model.Blog 的转化在此层完成

func CreateBlog(b *model.Blog) { 
 dbClient.Create(&amp;amp;blog{...})
 ...}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p data-pid=&quot;T0wu86GV&quot;&gt;该层包含具体的框架和依赖工具的细节，例如系统使用的数据库、Web 框架、消息队列等等。此层主要帮助外部的框架、工具，和内层进行数据衔接。接博客系统例子，框架和驱动层如果使用 gorm 来操作数据库，则相关的示例代码如下：&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;import &quot;gorm.io/driver/mysql&quot;
import &quot;gorm.io/gorm&quot;

type blog struct { // Data Object
    Content string `gorm:&quot;...&quot;` // 本层的数据库 ORM 如果替换，此处的 tag 也需要随之改变
} 
type MySQLClient struct { DB *gorm.DB }
func New(...) { gorm.Open(...) ... }
func Create(...)...&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p data-pid=&quot;aSTcZBy8&quot;&gt;至此，整洁架构图中的四层已介绍完成。但此图中的四层结构仅作示意，整洁架构并不要求软件系统必须按照此四层结构设计。只要软件系统能保证“由外向内”的依赖规则，系统的层数多少可自由决定。&lt;/p&gt;&lt;p data-pid=&quot;irLvUhu_&quot;&gt;&lt;b&gt;整体结构与洋葱架构二者齐名且结构图相似，都是四层同心圆。&lt;/b&gt;&lt;/p&gt;&lt;h3 id=&quot;h_618123369_3&quot; data-into-catalog-status=&quot;&quot;&gt;&lt;b&gt;2.2&lt;/b&gt; 洋葱架构&lt;/h3&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-4925226a03bb03362c78c04e441f1f49_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; class=&quot;content_image&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; class=&quot;content_image lazy&quot; data-actualsrc=&quot;https://pic2.zhimg.com/v2-4925226a03bb03362c78c04e441f1f49_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p data-pid=&quot;9feLgtzU&quot;&gt;图 2 Onion Architecture, Jeffrey Palermo&lt;/p&gt;&lt;p data-pid=&quot;dNEpq4jm&quot;&gt;图 2 中&lt;b&gt;洋葱架构&lt;/b&gt;最核心的 Domain Model 为组织中核心业务的状态及其行为模型，与整洁架构中的 Entities 高度一致。&lt;/p&gt;&lt;p data-pid=&quot;U4WC0kd5&quot;&gt;其外层的 Domain Services 与整洁架构中的 Use Cases 职责相近。更外层的 Application Services 桥接 UI 和 Infrastructue 中的数据库、文件、外部服务等，与整洁架构中的  Interface Adaptors 功能相同。最边缘层的 User Interface 与整洁架构中的最外层 UI 部分一致，Infrastructure 则与整洁架构中的 DB， Devices， External Interfaces 作用一致，只有 Tests 部分稍有差异。&lt;/p&gt;&lt;p data-pid=&quot;9b83nCNs&quot;&gt;同前两者齐名的六边形架构，虽然外形不是同心圆，但是结构上还是有很多对应的地方。&lt;/p&gt;&lt;h3 id=&quot;h_618123369_4&quot; data-into-catalog-status=&quot;&quot;&gt;&lt;b&gt;2.3&lt;/b&gt; 六边形架构&lt;/h3&gt;&lt;p class=&quot;ztext-empty-paragraph&quot;&gt;&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-fe23a5822d85977362e4427b015c49a0_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; class=&quot;content_image&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; class=&quot;content_image lazy&quot; data-actualsrc=&quot;https://pic1.zhimg.com/v2-fe23a5822d85977362e4427b015c49a0_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p data-pid=&quot;DPg77qkp&quot;&gt;图 3 Hexagon Architecture, Andrew Gordon&lt;/p&gt;&lt;p data-pid=&quot;MFobbF4K&quot;&gt;图 3 &lt;b&gt;六边形架构&lt;/b&gt;中灰色箭头表示依赖注入（Dependency Injection），其与整洁架构中的依赖规则（The Dependency Rule）有异曲同工之妙，也限制了整个架构各组件的依赖方向必须是“由外向内”。图中的各种 Port 和 Adapter 是六边形架构的重中之重，故该架构别称 Ports and Adapters。&lt;/p&gt;&lt;p class=&quot;ztext-empty-paragraph&quot;&gt;&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-409fed97b5dbfff71d6d961a0e633ec0_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; class=&quot;content_image&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; class=&quot;content_image lazy&quot; data-actualsrc=&quot;https://pic1.zhimg.com/v2-409fed97b5dbfff71d6d961a0e633ec0_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p data-pid=&quot;QBj3I1uf&quot;&gt;图 4 Hexagon Architecture Phase 1, Pablo Martinez&lt;/p&gt;&lt;p data-pid=&quot;ohIBlQbB&quot;&gt;如图 4 所示，在六边形架构中，来自驱动边（Driving Side）的用户或外部系统输入指令通过左边的 Port &amp;amp; Adapter 到达应用系统，处理后，再通过右边的 Adapter &amp;amp; Port 输出到被驱动边（Driven Side）的数据库和文件等。&lt;/p&gt;&lt;p data-pid=&quot;MncLNJVO&quot;&gt;Port 是系统的一个与具体实现无关的入口，该入口定义了外界与系统通信的接口（interface）。Port 不关心接口的具体实现，就像 USB 端口允许多种设备通过其与电脑通信，但它不关心设备与电脑之间的照片、视频等等具体数据是如何编解码传输的。&lt;/p&gt;&lt;p class=&quot;ztext-empty-paragraph&quot;&gt;&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-349d64a69523a720971cebea393d3358_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; class=&quot;content_image&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; class=&quot;content_image lazy&quot; data-actualsrc=&quot;https://pic1.zhimg.com/v2-349d64a69523a720971cebea393d3358_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p data-pid=&quot;bjnFX6zF&quot;&gt;图 5 Hexagon Architecture Phase 2, Pablo Martinez&lt;/p&gt;&lt;p data-pid=&quot;20UG7NoG&quot;&gt;如图 5 所示，Adapter 负责 Port 定义的接口的技术实现，并通过 Port 发起与应用系统的交互。例如，图左 Driving Side 的 Adapter 可以是一个 REST 控制器，客户端通过它与应用系统通信。图右 Driven Side 的 Adapter 可以是一个数据库驱动，应用系统的数据通过它写入数据库。此图中可以看到，虽然六边形架构看上去与整洁架构不那么相似，但其应用系统核心层的 Domain 、边缘层的User Interface 和 Infrastructure 与整洁架构中的 Entities 和 Frameworks &amp;amp; Drivers 完全是一一对应的。&lt;/p&gt;&lt;p data-pid=&quot;WqXD7RoL&quot;&gt;再次回到图 3 的六边形架构整体图：&lt;/p&gt;&lt;p data-pid=&quot;QUO4zsxr&quot;&gt;以 Java 生态为例，Driving Side 的 HTTP Server In Port 可以承接来自 Jetty 或 Servlet 等 Adapter 的请求，其中 Jetty 的请求可以是来自其他服务的调用。既处在 Driving Side 又处在 Driven Sides 中的 Messaging In/Out Port 可以承接来自 RabbitMQ 的事件请求，也可以将 Application Adapters 中生成的数据写入到 RabbitMQ。Driven Side 的 Store Out Port 可以将 Application Adapters 产生的数据写入到 MongoDB；HTTP Client Out Port 则可以将 Application Adapters 产生的数据通过 JettyHTTP 发送到外部服务。&lt;/p&gt;&lt;p data-pid=&quot;E0ylM327&quot;&gt;其实，不仅国外有优秀的代码架构，国内也有。&lt;/p&gt;&lt;h3 id=&quot;h_618123369_5&quot; data-into-catalog-status=&quot;&quot;&gt;&lt;b&gt;2.4&lt;/b&gt; COLA架构&lt;/h3&gt;&lt;p class=&quot;ztext-empty-paragraph&quot;&gt;&lt;/p&gt;&lt;p data-pid=&quot;cT_3-crO&quot;&gt;国内开发者在学习了六边形架构、洋葱架构和整洁架构之后，提出了&lt;b&gt; COLA&lt;/b&gt;（Clean Object-oriented and Layered Architecture）&lt;b&gt;架构&lt;/b&gt;，其名称含义为「整洁的基于面向对象和分层的架构」。它的核心理念与国外三种架构相同，都是提倡以业务为核心，解耦外部依赖，分离业务复杂度和技术复杂度[4]。整体架构形式如图 6 所示。&lt;/p&gt;&lt;p class=&quot;ztext-empty-paragraph&quot;&gt;&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-f81275fd3c25ea56b26ee5b24681dff5_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; class=&quot;content_image&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; class=&quot;content_image lazy&quot; data-actualsrc=&quot;https://pic2.zhimg.com/v2-f81275fd3c25ea56b26ee5b24681dff5_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p data-pid=&quot;0D5TVZ9H&quot;&gt;图 6 COLA 架构, 张建飞&lt;/p&gt;&lt;p data-pid=&quot;OeFNXljV&quot;&gt;虽然 COLA 架构不再是同心圆或者六边形的形式，但是还是能明显看到前文三种架构的影子。Domain 层中 model 对应整洁架构的 Entities、六边形架构和洋葱架构中的 Domain Model。Domain 层中 gateway 和 ability 对应整洁架构的 Use Cases、六边形架构中的 Application Logic以及洋葱架构中的 Domain Services。App 层则对应整洁架构 Interface Adapters 层中的 Controllers、Gateways和 Presenters。最上方的 Adapter 层和最下方的 Infrastructure 层合起来与整洁架构的边缘层 Frameworks &amp;amp; Drivers 相对应。&lt;/p&gt;&lt;p data-pid=&quot;g7JCpezI&quot;&gt;Adapter 层上方的 Driving adater 与 Infrastructure 层下方的 Driven adapter 更是与六边形架构中的 Driving Side 和 Driven Side 高度相似。&lt;/p&gt;&lt;p data-pid=&quot;AY_hQLxM&quot;&gt;COLA 架构在 Java 生态中落地已久，也为开发者们提供了 Java 语言的 archetype，可方便地用于 Java 项目脚手架代码的生成。笔者受其启发，推出了一种符合 COLA 架构规则的 Go 语言项目脚手架实践方案。&lt;/p&gt;&lt;h2 id=&quot;h_618123369_6&quot; data-into-catalog-status=&quot;&quot;&gt;03、推荐一种 Go 代码架构实践&lt;/h2&gt;&lt;p data-pid=&quot;_bAjZDTe&quot;&gt;项目目录结构如下：&lt;/p&gt;&lt;p data-pid=&quot;Trgul6MI&quot;&gt;├── adapter // Adapter层，适配各种框架及协议的接入，比如：Gin，tRPC，Echo，Fiber 等&lt;br/&gt;├── application // App层，处理Adapter层适配过后与框架、协议等无关的业务逻辑&lt;br/&gt;│   ├── consumer //（可选）处理外部消息，比如来自消息队列的事件消费&lt;br/&gt;│   ├── dto // App层的数据传输对象，外层到达App层的数据，从App层出发到外层的数据都通过DTO传播&lt;br/&gt;│   ├── executor // 处理请求，包括command和query&lt;br/&gt;│   └── scheduler //（可选）处理定时任务，比如Cron格式的定时Job&lt;br/&gt;├── domain // Domain层，最核心最纯粹的业务实体及其规则的抽象定义&lt;br/&gt;│   ├── gateway // 领域网关，model的核心逻辑以Interface形式在此定义，交由Infra层去实现&lt;br/&gt;│   └── model // 领域模型实体&lt;br/&gt;├── infrastructure // Infra层，各种外部依赖，组件的衔接，以及domain/gateway的具体实现&lt;br/&gt;│   ├── cache //（可选）内层所需缓存的实现，可以是Redis，Memcached等&lt;br/&gt;│   ├── client //（可选）各种中间件client的初始化&lt;br/&gt;│   ├── config // 配置实现&lt;br/&gt;│   ├── database //（可选）内层所需持久化的实现，可以是MySQL，MongoDB，Neo4j等&lt;br/&gt;│   ├── distlock //（可选）内层所需分布式锁的实现，可以基于Redis，ZooKeeper，etcd等&lt;br/&gt;│   ├── log // 日志实现，在此接入第三方日志库，避免对内层的污染&lt;br/&gt;│   ├── mq //（可选）内层所需消息队列的实现，可以是Kafka，RabbitMQ，Pulsar等&lt;br/&gt;│   ├── node //（可选）服务节点一致性协调控制实现，可以基于ZooKeeper，etcd等&lt;br/&gt;│   └── rpc //（可选）广义上第三方服务的访问实现，可以通过HTTP，gRPC，tRPC等&lt;br/&gt;└── pkg // 各层可共享的公共组件代&lt;/p&gt;&lt;p class=&quot;ztext-empty-paragraph&quot;&gt;&lt;/p&gt;&lt;p data-pid=&quot;dmOcQbFM&quot;&gt;由此目录结构可以看出通过 Adapter 层屏蔽外界框架、协议的差异，Infrastructure 层囊括各种中间件和外部依赖的具体实现，App 层负责组织输入、输出， Domain 层可以完全聚焦在最纯粹也最不容易变化的核心业务规则上。&lt;/p&gt;&lt;p data-pid=&quot;f75Hag32&quot;&gt;按照前文 infrastructure 中目录结构，各子目录中文件样例参考如下：&lt;/p&gt;&lt;p data-pid=&quot;ksECAgNu&quot;&gt;├── infrastructure&lt;br/&gt;│   ├── cache&lt;br/&gt;│   │   └── redis.go // Redis 实现的缓存&lt;br/&gt;│   ├── client&lt;br/&gt;│   │   ├── kafka.go // 构建 Kafka client&lt;br/&gt;│   │   ├── mysql.go // 构建 MySQL client&lt;br/&gt;│   │   ├── redis.go // 构建 Redis client（cache和distlock中都会用到 Redis，统一在此构建）&lt;br/&gt;│   │   └── zookeeper.go // 构建 ZooKeeper client&lt;br/&gt;│   ├── config&lt;br/&gt;│   │   └── config.go // 配置定义及其解析&lt;br/&gt;│   ├── database&lt;br/&gt;│   │   ├── dataobject.go // 数据库操作依赖的数据对象&lt;br/&gt;│   │   └── mysql.go // MySQL 实现的数据持久化&lt;br/&gt;│   ├── distlock&lt;br/&gt;│   │   ├── distributed_lock.go // 分布式锁接口，在此是因为domain/gateway中没有直接需要此接口&lt;br/&gt;│   │   └── redis.go // Redis 实现的分布式锁&lt;br/&gt;│   ├── log&lt;br/&gt;│   │   └── log.go // 日志封装&lt;br/&gt;│   ├── mq&lt;br/&gt;│   │   ├── dataobject.go // 消息队列操作依赖的数据对象&lt;br/&gt;│   │   └── kafka.go // Kafka 实现的消息队列&lt;br/&gt;│   ├── node&lt;br/&gt;│   │   └── zookeeper_client.go // ZooKeeper 实现的一致性协调节点客户端&lt;br/&gt;│   └── rpc&lt;br/&gt;│       ├── dataapi.go // 第三方服务访问功能封装&lt;br/&gt;│       └── dataobject.go // 第三方服务访问操作依赖的数据对象&lt;/p&gt;&lt;p data-pid=&quot;6B_s-Vle&quot;&gt;再接前文提到的博客系统例子，假设用 Gin 框架搭建博客系统 API 服务的话，架构各层相关目录内容大致如下：&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;// Adapter 层 router.go，路由入口
import (
    &quot;mybusiness.com/blog-api/application/executor&quot; // 向内依赖 App 层

    &quot;github.com/gin-gonic/gin&quot;
)

func NewRouter(...) (*gin.Engine, error) {
  r := gin.Default()
  r.GET(&quot;/blog/:blog_id&quot;, getBlog)
  ...
}

func getBlog(...) ... {
  // b&#x27;s type: *executor.BlogOperator
  result := b.GetBlog(blogID)
  // c&#x27;s type: *gin.Context
  c.JSON(..., result)}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p data-pid=&quot;MXW6vm0e&quot;&gt;如代码所体现，Gin 框架的内容会被全部限制在 Adapter 层，其他层不会感知到该框架的存在。&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;// App 层 executor/blog_operator.go
import &quot;mybusiness.com/blog-api/domain/gateway&quot; // 向内依赖 Domain 层

type BlogOperator struct {
  blogManager gateway.BlogManager // 字段 type 是接口类型，通过 Infra 层具体实现进行依赖注入
}

func (b *BlogOperator) GetBlog(...) ... {
    blog, err := b.blogManager.Load(ctx, blogID)
    ...
    return dto.BlogFromModel(...) // 通过 DTO 传递数据到外层}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p data-pid=&quot;kvsZ-hVL&quot;&gt;App 层会依赖 Domain 层定义的领域网关，而领域网关接口会由 Infra 层的具体实现注入。外层调用 App 层方法，通过 DTO 传递数据，App 层组织好输入交给 Domain 层处理，再将得到的结果通过 DTO 传递到外层。&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;// Domain 层 gateway/blog_manager.go
import &quot;mybusiness.com/blog-api/domain/model&quot; // 依赖同层的 model

type BlogManager interface { //定义核心业务逻辑的接口方法
  Load(...) ...
  Save(...) ...
  ...
}
 Domain 层是核心层，不会依赖任何外层组件，只能层内依赖。这也保障了 Domain 层的纯粹，保障了整个软件系统的可维护性。
// Infrastructure 层 database/mysql.go
import (
    &quot;mybusiness.com/blog-api/domain/model&quot; // 依赖内层的 model
    &quot;mybusiness.com/blog-api/infrastructure/client&quot; // 依赖同层的 client
)

type MySQLPersistence struct {
  client client.SQLClient // client 中已构建好了所需客户端，此处不用引入 MySQL, gorm 相关依赖
}

func (p ...) Load(...) ... { // Domain 层 gateway 中接口方法的实现
  record := p.client.FindOne(...)
  return record.ToModel() // 将 DO（数据对象）转成 Domain 层 model}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p data-pid=&quot;0vDC6UyA&quot;&gt;Infrastructure 层中接口方法的实现都需要将结果的数据对象转化成 Domain 层 model 返回，因为领域网关 gateway 中定义的接口方法的入参、出参只能包含同层的 model，不可以有外层的数据类型。&lt;/p&gt;&lt;p data-pid=&quot;YF8MUU1l&quot;&gt;前文提及的完整调用流程如图 7 所示。&lt;/p&gt;&lt;p class=&quot;ztext-empty-paragraph&quot;&gt;&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-99acf572870b1e3d0df22e3eb320a10c_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; class=&quot;content_image&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; class=&quot;content_image lazy&quot; data-actualsrc=&quot;https://pic1.zhimg.com/v2-99acf572870b1e3d0df22e3eb320a10c_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p data-pid=&quot;SCjwj-BY&quot;&gt;图 7 Blog 读取过程时序示意图&lt;/p&gt;&lt;p data-pid=&quot;RBfcOLlT&quot;&gt;如图，外部请求首先抵达 Adapter 层。如果是读请求，则携带简单参数来调用 App 层；如果是写请求，则携带 DTO 调用 App 层。App 层将收到的DTO转化成对应的 Model 调用 Domain 层 gateway 相关业务逻辑接口方法。由于系统初始化阶段已经完成依赖注入，接口对应的来自 Infra 层的具体实现会处理完成并返回 Model 到 Domain 层，再由 Domain 层返回到 App 层，最终经由 Adapter 层将响应内容呈现给外部。&lt;/p&gt;&lt;p data-pid=&quot;k7U-PsJu&quot;&gt;至此可知，参照 COLA 设计的系统分层架构可以一层一层地将业务请求剥离干净，分别处理后再一层一层地组装好返回到请求方。各层之间互不干扰，职责分明，有效地降低了系统组件之间的耦合，提升了系统的可维护性。&lt;/p&gt;&lt;h2 id=&quot;h_618123369_7&quot; data-into-catalog-status=&quot;&quot;&gt;04、总结&lt;/h2&gt;&lt;p data-pid=&quot;JuGQJz6l&quot;&gt;无论哪种架构都不会是项目开发的银弹，也不会有百试百灵的开发方法论。毕竟引入一种架构是有一定复杂度和较高维护成本的，所以开发者需要根据自身项目类型判断是否需要引入架构：&lt;/p&gt;&lt;p data-pid=&quot;4GITn1Rs&quot;&gt;&lt;b&gt;不建议引入架构的项目类型：&lt;/b&gt;&lt;/p&gt;&lt;p data-pid=&quot;mYt9dJQd&quot;&gt;* 软件生命周期大概率会小于三个月的&lt;/p&gt;&lt;p data-pid=&quot;XdhjRPJF&quot;&gt;* 项目维护人员在现在以及可见的将来只有自己的&lt;/p&gt;&lt;p data-pid=&quot;WgiIUhpK&quot;&gt;&lt;b&gt;可以考虑引入架构的项目类型：&lt;/b&gt;&lt;/p&gt;&lt;p data-pid=&quot;sPR5ZO3t&quot;&gt;* 软件生命周期大概率会大于三个月的&lt;/p&gt;&lt;p data-pid=&quot;U8ylxycC&quot;&gt;* 项目维护人员多于1人的&lt;/p&gt;&lt;p data-pid=&quot;6Iffhb4Q&quot;&gt;&lt;b&gt;强烈建议引入架构的项目类型：&lt;/b&gt;&lt;/p&gt;&lt;p data-pid=&quot;mUfY9m5n&quot;&gt;* 软件生命周期大概率会大于三年的&lt;/p&gt;&lt;p data-pid=&quot;RiIvyl3g&quot;&gt;* 项目维护人员多于5人的&lt;/p&gt;&lt;h2 id=&quot;h_618123369_8&quot; data-into-catalog-status=&quot;&quot;&gt;&lt;i&gt;参考文献:&lt;/i&gt;&lt;/h2&gt;&lt;p data-pid=&quot;S_-83oCd&quot;&gt;&lt;i&gt;[1] Robert C. Martin, The Clean Architecture, &lt;a href=&quot;https://link.zhihu.com/?target=https%3A//blog.cleancoder.com/uncle-bob/2012/08/13/the-clean-architecture.html&quot; class=&quot; external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;&lt;span class=&quot;invisible&quot;&gt;https://&lt;/span&gt;&lt;span class=&quot;visible&quot;&gt;blog.cleancoder.com/unc&lt;/span&gt;&lt;span class=&quot;invisible&quot;&gt;le-bob/2012/08/13/the-clean-architecture.html&lt;/span&gt;&lt;span class=&quot;ellipsis&quot;/&gt;&lt;/a&gt; (2012)&lt;/i&gt;&lt;/p&gt;&lt;p data-pid=&quot;arMT91VJ&quot;&gt;&lt;i&gt;[2] Andrew Gordon, Clean Architecture,  &lt;a href=&quot;https://link.zhihu.com/?target=https%3A//www.andrewgordon.me/posts/Clean-Architecture/&quot; class=&quot; external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;&lt;span class=&quot;invisible&quot;&gt;https://www.&lt;/span&gt;&lt;span class=&quot;visible&quot;&gt;andrewgordon.me/posts/C&lt;/span&gt;&lt;span class=&quot;invisible&quot;&gt;lean-Architecture/&lt;/span&gt;&lt;span class=&quot;ellipsis&quot;/&gt;&lt;/a&gt; (2021)&lt;/i&gt;&lt;/p&gt;&lt;p data-pid=&quot;JoXSWyLq&quot;&gt;&lt;i&gt;[3] Pablo Martinez, Hexagonal Architecture, there are always two sides to every story,  &lt;a href=&quot;https://link.zhihu.com/?target=https%3A//medium.com/ssense-tech/hexagonal-architecture-there-are-always-two-sides-to-every-story-bc0780ed7d9c&quot; class=&quot; external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;&lt;span class=&quot;invisible&quot;&gt;https://&lt;/span&gt;&lt;span class=&quot;visible&quot;&gt;medium.com/ssense-tech/&lt;/span&gt;&lt;span class=&quot;invisible&quot;&gt;hexagonal-architecture-there-are-always-two-sides-to-every-story-bc0780ed7d9c&lt;/span&gt;&lt;span class=&quot;ellipsis&quot;/&gt;&lt;/a&gt; (2021)&lt;/i&gt;&lt;/p&gt;&lt;p data-pid=&quot;mo1WbpJe&quot;&gt;&lt;i&gt;[4] 张建飞, COLA 4.0：应用架构的最佳实践,  &lt;a href=&quot;https://link.zhihu.com/?target=https%3A//blog.csdn.net/significantfrank/article/details/110934799&quot; class=&quot; external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;&lt;span class=&quot;invisible&quot;&gt;https://&lt;/span&gt;&lt;span class=&quot;visible&quot;&gt;blog.csdn.net/significa&lt;/span&gt;&lt;span class=&quot;invisible&quot;&gt;ntfrank/article/details/110934799&lt;/span&gt;&lt;span class=&quot;ellipsis&quot;/&gt;&lt;/a&gt; (2022)&lt;/i&gt;&lt;/p&gt;&lt;p data-pid=&quot;kux5BE3H&quot;&gt;&lt;i&gt;[5] Jeffrey Palermo, The Onion Architecture,  &lt;a href=&quot;https://link.zhihu.com/?target=https%3A//jeffreypalermo.com/2008/07/the-onion-architecture-part-1/&quot; class=&quot; external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;&lt;span class=&quot;invisible&quot;&gt;https://&lt;/span&gt;&lt;span class=&quot;visible&quot;&gt;jeffreypalermo.com/2008&lt;/span&gt;&lt;span class=&quot;invisible&quot;&gt;/07/the-onion-architecture-part-1/&lt;/span&gt;&lt;span class=&quot;ellipsis&quot;/&gt;&lt;/a&gt; (2008)&lt;/i&gt;&lt;/p&gt;&lt;p class=&quot;ztext-empty-paragraph&quot;&gt;&lt;/p&gt;&lt;p data-pid=&quot;wJqgGC5J&quot;&gt;以上是本次分享全部内容，欢迎大家在评论区分享交流。如果觉得内容有用，欢迎转发～&lt;/p&gt;&lt;p data-pid=&quot;Ll-enA4a&quot;&gt;-End-&lt;/p&gt;&lt;p data-pid=&quot;H_xCAXDL&quot;&gt;原创作者｜donghui&lt;/p&gt;&lt;p data-pid=&quot;sHcMV2rO&quot;&gt;技术责编｜donghui&lt;/p&gt;&lt;p data-pid=&quot;c4-1bUQH&quot;&gt;“如何更好的降低系统组件之间的耦合、提升系统的可维护性”是让开发者们亘古不变的头疼问题，除了设计好的代码架构，容器化技术等也是重要的解耦技术。&lt;b&gt;大家还能想到哪些可以降低系统耦合度，提高系统可维护性的方法呢？&lt;/b&gt;&lt;/p&gt;&lt;p data-pid=&quot;kamQjT4l&quot;&gt;欢迎在评论区聊一聊你的看法。在4月4日前将你的评论记录截图，发送给腾讯云开发者公众号后台，可领取腾讯云「开发者春季限定红包封面」一个，数量有限先到先得 。我们还将选取点赞量最高的1位朋友，送出腾讯QQ公仔1个。4月4日中午12点开奖。快邀请你的开发者朋友们一起来参与吧！&lt;/p&gt;&lt;p data-pid=&quot;iJoxmuN9&quot;&gt;最近微信改版啦&lt;/p&gt;&lt;p data-pid=&quot;Hx_TIVvL&quot;&gt;很多开发者朋友反馈收不到我们更新的文章&lt;/p&gt;&lt;p data-pid=&quot;ErGqk2hX&quot;&gt;大家可以&lt;b&gt;关注并点亮星标&lt;/b&gt;&lt;/p&gt;&lt;p data-pid=&quot;h4MUJUNF&quot;&gt;不再错过小云的知识速递&lt;/p&gt;&lt;a target=&quot;_blank&quot; href=&quot;https://link.zhihu.com/?target=https%3A//mp.weixin.qq.com/s/xJ5bCHFLkvFB6hHfbzAJDw&quot; data-draft-node=&quot;block&quot; data-draft-type=&quot;link-card&quot; data-image=&quot;https://pic3.zhimg.com/v2-8f3d199778ec03735b21ae3054c90b9e_180x120.jpg&quot; data-image-width=&quot;1280&quot; data-image-height=&quot;545&quot; data-text=&quot;Golang整洁架构实践&quot; class=&quot;LinkCard new&quot;&gt;&lt;span class=&quot;LinkCard-contents&quot;&gt;&lt;span class=&quot;LinkCard-title loading&quot; data-text=&quot;true&quot;/&gt;&lt;span class=&quot;LinkCard-desc loading&quot;/&gt;&lt;/span&gt;&lt;span class=&quot;LinkCard-image LinkCard-image--default&quot;/&gt;&lt;/a&gt;&lt;p/&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>1d149c8564da5714504e7e135ff031c0</guid>
<title>为什么 Python、Go 和 Rust 都不支持三元运算符？</title>
<link>https://toutiao.io/k/4cfms3h</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在编程时，我们经常要作条件判断，并根据条件的结果选择执行不同的语句块。在许多编程语言中，最常见的写法是三元运算符，但是，Python 并不支持三元运算符，无独有偶，两个最热门的新兴语言 Go 和 Rust 也不支持！&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;为什么 Python 不支持三元运算符呢？本文将主要分析 Python 在设计&lt;strong&gt;条件选择语法&lt;/strong&gt;时的过程，科普为什么它会采用现今的与众不同的实现方案，同时，我们也将考察为什么其它语言也要抛弃传统的三元运算符。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在开篇之前，我再声明一下：就像“Python为什么”系列的大部分文章一样，本文关注的仅是一个很小的语法点，但它并不是“茴香豆有几种写法”那种毫无意义的话题。因为，&lt;strong&gt;细微之处见真功夫，深入研究语言设计背后的原因、历史和哲学，可以让我们在编程时有更加清晰和自由的思维。&lt;/strong&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;什么是三元运算符？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;三元运算符通常指的是“&lt;strong&gt;?:&lt;/strong&gt;”，其语法形式为：&lt;code&gt;condition ? expression1 : expression2&lt;/code&gt;，如果 condition 为真，则取 expression1，若不为真，则取 expression2。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;语法简化形式“a ? b : c”，可以读成“如果 a 条件成立，则为 b，否则为 c”。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;三元运算符是对普通一重 if-else 结构的简化，常用于在一条语句中同时实现条件判断和取值操作。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;// 常规 if-else &lt;/span&gt;&lt;br/&gt;&lt;span&gt;if&lt;/span&gt; (a &amp;gt; b) {&lt;br/&gt;    result = x;&lt;br/&gt;} &lt;span&gt;else&lt;/span&gt; {&lt;br/&gt;    result = y;&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// 简化后的写法&lt;/span&gt;&lt;br/&gt;result = a &amp;gt; b ? x : y;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;采用了这种语法设计的编程语言有很多，比如 C、C#、C++、Java、JavaScript、PHP、Perl、Ruby、Swift 等等。毫无争议，它就是编程语言界的主流设计方案（至今仍是）。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这种语法非常简洁高效，代码的可读性也很强（如果你不是第一次接触的话），深得很多人的喜欢。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但是，它并非毫无缺点。Python 是这种语法设计的最著名的挑战者，接下来，我们将看看为什么 Python 要另辟蹊径。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;Python 社区的投票&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Python 发布于 1991 年，但在接下来的 15 年里，除了 if-else 语法外，它并不支持三元运算符和其它条件表达式。而且，在 2006 年引入条件表达式前，社区对此进行了漫长而曲折的争论，可以说这是一个设计得很艰难的语法了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;最初，由于时常有人请求添加 if-then-else（三元）表达式，因此在 2003 年 2 月，PEP 308 – Conditional Expressions 被提了出来，目的是让社区选出一个让多数人支持的方案。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.36081242532855434&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/LLRiaS9YfFTPmQp4bWv7UJaGFIWYYIUibspaIbvGOaAxJZr0RsJMjzp4Gw8lsbCa8tib4g1dQhFXtyeoeqxpsQGZg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;837&quot;/&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;figcaption&gt;PEP-308&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;很快，除了少部分人希望啥也不做外，社区里出现了好几种方案：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;（1）使用标点符号构建的三元运算符&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;即常规的三元运算符，跟前文介绍的语法一样：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&amp;lt;condition&amp;gt; ? &amp;lt;expression1&amp;gt; : &amp;lt;expression2&amp;gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个方案的呼声挺高，有开发者甚至已提交了实现代码。但是，Guido 给出了两个反对的理由：冒号在 Python 中已经有许多用途（即使它实际上不会产生歧义，因为问号需要匹配冒号）；对于不习惯 C 衍生语言的人来说，理解起来很困难。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;（2）使用现有和新的关键字构建&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;引入新的“then”关键字，结合现有的“else”关键字：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&amp;lt;condition&amp;gt; then &amp;lt;expression1&amp;gt; &lt;span&gt;else&lt;/span&gt; &amp;lt;expression2&amp;gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;它的优点是简单明了、不需要括号、不改变现有关键字的语义，不大可能与语句混淆，而且不需要重载冒号。缺点是引入新关键字的实现成本较高。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;（3）其它思路&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;跟上一种方案的思路相似，但没有上述两类方案的支持度高。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;(&lt;span&gt;if&lt;/span&gt; &amp;lt;condition&amp;gt;: &amp;lt;expression1&amp;gt; &lt;span&gt;else&lt;/span&gt;: &amp;lt;expression2&amp;gt;)&lt;br/&gt;&amp;lt;condition&amp;gt; &lt;span&gt;and&lt;/span&gt; &amp;lt;expression1&amp;gt; &lt;span&gt;else&lt;/span&gt; &amp;lt;expression2&amp;gt;&lt;br/&gt;&amp;lt;expression1&amp;gt; &lt;span&gt;if&lt;/span&gt; &amp;lt;condition&amp;gt; &lt;span&gt;else&lt;/span&gt; &amp;lt;expression2&amp;gt;&lt;br/&gt;cond(&amp;lt;condition&amp;gt;, &amp;lt;expression1&amp;gt;, &amp;lt;expression2&amp;gt;)&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;值得一提的是&lt;code&gt;(if &amp;lt;condition&amp;gt;: &amp;lt;expression1&amp;gt; else: &amp;lt;expression2&amp;gt;)&lt;/code&gt; ，它是常规 if-else 语法的扁平化，容易理解，但缺点是需要使用圆括号，容易跟生成器表达式混淆，而且需要解释器对冒号做特殊化处理。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;另外值得一提的是&lt;code&gt;&amp;lt;expression1&amp;gt; if &amp;lt;condition&amp;gt; else &amp;lt;expression2&amp;gt;&lt;/code&gt;，它是 PEP-308 最早版本的推荐方案，但是这种不将条件放在首位的风格让一些人感觉不舒服，而且，当“expression1”很长的时候，很容易就忽略掉它的条件。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当时参与投票的全部设计方案：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.9336823734729494&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/LLRiaS9YfFTPmQp4bWv7UJaGFIWYYIUibsSmy0ib5J6KA1Efeia58kfCVbYjz7OvBOjb7GEpNMvsdqzBOvC3ezAq9w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;573&quot;/&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;/&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;总体上，开发者们希望引入某种形式的 if-then-else 表达式，但投票后却没有哪种方案能取得绝对的优势。概括起来，分歧的问题主要有：是否用标点符号、是否复用关键字、是否复用圆括号、是否引入新关键字、是否引入新语法……&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;由于得票太分散，因此，这个 PEP 在当时被拒绝了。PEP 中写道：“&lt;strong&gt;Python 的一个设计原则是在不确定采取哪条路线时，则保持现状。&lt;/strong&gt;”&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;and-or 用于条件选择的问题&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;以上的投票事件发生在 2004 年 3 月，但是，在 PEP 被拒绝后，相关话题的讨论并未平息，因为大家总想找一种简洁的方式来替换“if-else“。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;时间到了 2005 年 9 月，邮件组中有人提议在  Py3.0 中变更&quot;and&quot;与&quot;or&quot;操作符的逻辑，提议将&quot;and&quot; 和 &quot;or&quot; 运算符简化成始终返回布尔值，而不是返回最后一个被求值的参数。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;之所以发起这个提议，原因是他使用了&lt;code&gt;&amp;lt;condition&amp;gt; and &amp;lt;expression1&amp;gt; or &amp;lt;expression2&amp;gt;&lt;/code&gt;的方式来实现条件判断与选择。但是这种写法在 Python 中的行为跟有些语言并不一样，使用不严谨的话，可能会酿成 Bug！&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;看看下面的两个例子，你觉得它们会得到什么结果呢？&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;a = &lt;span&gt;True&lt;/span&gt; &lt;span&gt;and&lt;/span&gt; &lt;span&gt;True&lt;/span&gt; &lt;span&gt;or&lt;/span&gt; &lt;span&gt;&quot;Python猫&quot;&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;b = &lt;span&gt;True&lt;/span&gt; &lt;span&gt;and&lt;/span&gt; &lt;span&gt;False&lt;/span&gt; &lt;span&gt;or&lt;/span&gt; &lt;span&gt;&quot;Python猫&quot;&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;对于&lt;code&gt;&amp;lt;condition&amp;gt; and &amp;lt;expression1&amp;gt; or &amp;lt;expression2&amp;gt;&lt;/code&gt; ，若 condition 为假，则会直接对 expression2 求值并返回结果；若 condition 为真，则先对 expression1 求值，若也为真，则不会继续对 expression2 求值，若 expression1 不为真，则对 expression2 求值。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;因此，上述例子得到的 a 是“True”，而 b 会得到“Python猫”。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;本系列的《&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzUyOTk2MTcwNg==&amp;amp;mid=2247486105&amp;amp;idx=1&amp;amp;sn=cc504bc090d29e9ef41526cf8f3062fd&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;Python 为什么能支持任意的真值判断？&lt;/a&gt; 》介绍过 Python 在真值判断的特殊之处，运用到以上结构中，将出现更不易察觉的问题。比如，该邮件的作者就是遇到了“expression1”为复数“0+4i”，这个数的真值判断为 False，因此导致最后返回的不是预期的“expression1”，而是“expression2”！&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在没有更好的方案前，“and-or”是比较常见的条件选择写法，PEP-308 也提及了它，也指出了当“expression1”为假的情况，还认为这种方案是丑陋和令人费解的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这封邮件再次引发了社区对条件选择语法的讨论，大佬们纷纷登场。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;以我现在的视角分析，其实就是开发者们不满足于“if-else”的现状，但是当时流行的“and-or”写法并不够好，因此，大家期望 Python 设计出新的规范性语法，来解决这个痛点。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;与众不同的条件表达式&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在经过 10 天的邮件讨论后，Guido van Rossum 最终决定添加一个&lt;strong&gt;条件表达式&lt;/strong&gt;，语法形式为&lt;code&gt;X if C else Y&lt;/code&gt; 。因此，PEP-308 被重开和更新，并很快就在次年的 2.5 版本中实现了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;前文已提到过这个让一些人感觉不舒服的方案了，因为它没有将条件判断逻辑放在最前面。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那么，为什么最后的胜者会是它呢？这是不是最优的设计呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;不可否认，起到决定性作用的原因是 Guido。由于社区在一年半前投票时没有形成多数意见，因此他行使 BDFL （终身仁慈独裁者）的决策权力，裁定出一个他认为是最佳的方案。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;X if C else Y&lt;/code&gt; 非常易于理解，可读性高。它延续了“&lt;strong&gt;明确优于隐式&lt;/strong&gt;”的风格，使用了直观口语化的“if-else”，而不是引入可能引起混淆的标点符号，就像 Python 选择“and”和“or”两个单词，而不是“&amp;amp;&amp;amp;”和“||”两个符号，它们有着异曲同工之妙。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;虽然调整后的语法顺序让人不太习惯，但其实这样的实现却大有好处。首先，它只需复用“if-else”两个关键字，而不需要引入“then”、“when”和其它语法要素，也不像&lt;code&gt;(if &amp;lt;condition&amp;gt;: &amp;lt;expression1&amp;gt; else: &amp;lt;expression2&amp;gt;)&lt;/code&gt; 那样的繁琐。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其次，为了验证&lt;code&gt;X if C else Y&lt;/code&gt; 的有效性，Guido 排查了标准库中所有“and-or”组合的写法，发现那些&lt;code&gt;C and X or Y&lt;/code&gt; 写法都可以被&lt;code&gt;X if C else Y&lt;/code&gt; 替换掉。标准库的情况，证明了这新的语法是可行的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;最后，在 PEP-308 提及的原因外，我还想补充一点。据观察，我发现很多时候我们有一个已初始化的变量，然后需要在出现某个条件时，更新变量的值。在这种情况下，“else”部分可以被省略，非常便捷。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;my_str = &lt;span&gt;&quot;&quot;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;# 中间存在其它代码逻辑&lt;/span&gt;&lt;br/&gt;&lt;span&gt;# 当 condition 为真时，变量会被重新赋值&lt;/span&gt;&lt;br/&gt;my_str = &lt;span&gt;&quot;Python猫&quot;&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; condition&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;回顾这段历史，我们可以梳理出一条线索：&lt;strong&gt;Python 没有设计三元运算符“?:”，主要是因为它不符合 Python 明确直观的设计风格。最后采用&lt;code&gt;X if C else Y&lt;/code&gt; 这种设计，主要的意图其实是消除“and-or”写法的隐患，这种设计简明易读，而且还有&lt;code&gt;&amp;lt;expression&amp;gt; if &amp;lt;condition&amp;gt;&lt;/code&gt; 简化写法的妙用。&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;总体而言，&lt;strong&gt;Python 设计者非常看重可读性与可维护性，不采用三元运算符而创造条件表达式语法，这是一个经过了开放讨论、谨慎评估与权衡取舍的结果。&lt;/strong&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;Go、Rust 为什么不支持三元运算符？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;考察完 Python 的设计原因后，我们再来考察“反派阵营”中两门最热门的语言。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;首先是 Go 语言，官网的 FAQ 专门列出了一个问题：“Why does Go not have the &lt;code&gt;?:&lt;/code&gt; operator?”。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Go 语言不支持“?:”运算符，而是推荐使用原生的“if-else”写法。文档的解释很简短，只有一段话：&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;Go 语言没有 ?: 运算符，因为语言的设计者们经常看到它被用来创建难以理解的复杂表达式。虽然 if-else 形式比较长，但是它无疑更清晰易懂。&lt;strong&gt;一个语言只需要一个条件控制流结构&lt;/strong&gt;。&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;接着是 Rust 语言，它的官方文档中似乎没有任何关于不支持三元运算符的解释。但在查阅资料后，我发现它也有一段特殊的故事，非常有意思：在 2011 年 6 月时，Rust 曾经引入过三元运算符（#565），然而半年后，设计者意识到这个特性是多余的，因此又把它移除了（#1698、#4632）!&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;为什么三元运算符在 Rust 是多余的呢？因为它的 if 语法并不像其它语言是“语句（&lt;strong&gt;statement&lt;/strong&gt;）”，而是一个“表达式（&lt;strong&gt;expression&lt;/strong&gt;）”，这意味着你可以直接将 if 表达式赋值给变量：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;// 若条件为真，得到 5，否则 6&lt;/span&gt;&lt;br/&gt;&lt;span&gt;let&lt;/span&gt; number = &lt;span&gt;if&lt;/span&gt; condition { &lt;span&gt;5&lt;/span&gt; } &lt;span&gt;else&lt;/span&gt; { &lt;span&gt;6&lt;/span&gt; };&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这种语法形式足够简单明了，不就是将大家都熟悉的“if-else”直接用于赋值么，太方便了，替换成三元运算符的话，确实有点画蛇添足之感。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;另外，Rust 使用花括号划分代码块，因此上例的花括号内可以包含多条表达式，也支持换行，例如这个例子：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;let&lt;/span&gt; x = &lt;span&gt;42&lt;/span&gt;;&lt;br/&gt;&lt;span&gt;let&lt;/span&gt; result = &lt;span&gt;if&lt;/span&gt; x &amp;gt; &lt;span&gt;50&lt;/span&gt; {&lt;br/&gt;    &lt;span&gt;println!&lt;/span&gt;(&lt;span&gt;&quot;x is greater than 50&quot;&lt;/span&gt;);&lt;br/&gt;    x * &lt;span&gt;2&lt;/span&gt; &lt;span&gt;// 这是一个表达式，将返回的值赋给 result&lt;/span&gt;&lt;br/&gt;} &lt;span&gt;else&lt;/span&gt; {&lt;br/&gt;    &lt;span&gt;println!&lt;/span&gt;(&lt;span&gt;&quot;x is less than or equal to 50&quot;&lt;/span&gt;);&lt;br/&gt;    x / &lt;span&gt;2&lt;/span&gt; &lt;span&gt;// 也是一个表达式，将返回的值赋给 result&lt;/span&gt;&lt;br/&gt;};&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这种用法，Python 是不可能做到的。最关键的区别在于，Rust 的 if 是表达式而不是语句。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这两个概念的区别是：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;表达式（expression）通常指的是由变量、常量、运算符等组成的一个&lt;strong&gt;可求值的代码片段&lt;/strong&gt;，它的求值结果可以用到其它表达式或语句中。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;语句（statement）通常指的是完成某个任务的&lt;strong&gt;单个指令或一组指令&lt;/strong&gt;，例如赋值语句、条件语句、循环语句等，它没有返回值（或者为空），不能用于赋值操作。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;除了 Rust 外，还有一些编程语言中的 if 是表达式而不是语句，例如 Kotlin、Scala、F#、Swift，它们在理论上也不需要使用三元运算符。（题外话：Swift 是个例外，它也有三元运算符。Kotlin 有“?:”运算符，注意两个符号是连在一起的，&lt;code&gt;val result = a ?: b&lt;/code&gt; 表示：如果 &lt;code&gt;a&lt;/code&gt; 不为 &lt;code&gt;null&lt;/code&gt;，则赋值给 &lt;code&gt;result&lt;/code&gt; ；否则将 &lt;code&gt;b&lt;/code&gt; 赋给 &lt;code&gt;result&lt;/code&gt;）&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;由于有这种语言设计层面的区别，因此在面对“是否要支持三元运算符”这个问题时，Rust 和 Python/Go 的思考角度有着天然不同的起点。知道了这种区别后，我们对编程语言会有更明晰地认知。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;回到本文的问题：为什么有些编程语言不采用主流的三元运算符语法呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;不可否认，“?:”确实是一种简洁好用的设计，然而，标点符号的负面影响是过于抽象，可读性并不及“if-else”那样强。另外，不同语言的设计风格与使用习惯，也会导致不同的选择。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Python 在经过一番波折后，最后设计出了与众不同的条件表达式。Go 语言明确表示不支持三元运算符。Rust 先设计后舍去，主要的原因在于 if 表达式的语言基础。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;考察完这三个热门语言后，我相信你已收获了一个满意的答案。如果是这样，请点赞支持一下本文吧！&lt;/p&gt;&lt;section&gt;最后，本文出自“Python为什么”系列，全部文章已归档在 Github 上，欢迎 star 和提 issue。&lt;span&gt;https://github.com/chinesehuazhou/python-whydo&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>