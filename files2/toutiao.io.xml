<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>6d5fe5bc9572abae21d479693d8d9a55</guid>
<title>当面试官问你 MySQL 优化时该怎么应对？</title>
<link>https://toutiao.io/k/d0rry8q</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;span class=&quot;RichText ztext CopyrightRichText-richText css-1g0fqss&quot; options=&quot;[object Object]&quot; itemprop=&quot;text&quot;&gt;&lt;p data-first-child=&quot;&quot;&gt;本篇回答从以下三个阶段详细的为你阐述如何准备数据分析师的面试，一应俱全，你需要的全都有。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;第 1 阶段：面试开始，逃不掉的自我介绍&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;第 2 阶段：考察能力的技术问题&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;第 3 阶段：面试结束时的问题&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;最后，我们聊聊面试当天要注意什么，以及面试失败以后怎么办&lt;/strong&gt;&lt;/p&gt;
&lt;h2&gt;&lt;strong&gt;一、逃不掉的自我介绍&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;首先，面试的开头就是&lt;strong&gt;自我介绍&lt;/strong&gt;。通常面试官也会根据你的自我介绍来展开问后面的问题。比如你在自我介绍种说了一个项目，那面试官就问这个项目的细节，比如你用了什么技术，如何实现某个功能的等等。通过项目的细节来考察你某个方面的能力，因此，自我介绍非常重要。&lt;br/&gt;
&lt;/p&gt;
&lt;p&gt;如果你实在不知道如何准备自我介绍，可以按下面模板准备：&lt;/p&gt;
&lt;p&gt;1）我是谁：一句话说清楚你哪年在哪里获得什么学位。&lt;/p&gt;
&lt;p&gt;2）我做过什么：按时间顺序讲下你认为做过的最好的 1 个或者 2 个项目。&lt;/p&gt;
&lt;p&gt;简单说下用了什么技术，最后的成果是什么。最好能有些量化的指标，比如达到了怎样的效果等等。&lt;/p&gt;
&lt;p&gt;注意这里自我介绍不要展开了说项目，而是从总体上介绍项目，这样做的好处是，留有余地，让面试官后面能根据你的描述展开问你这些项目的细节。不然，如果你连细节都说了，后面面试官都不知道该问你啥了，这就叫做留有余地。&lt;/p&gt;
&lt;p&gt;3）我想做什么：在最后说下我希望能在贵公司继续发挥我的 xxx 能力。&lt;/p&gt;
&lt;h2&gt;&lt;strong&gt;二、考察对数据分析岗位的理解与职业规划&lt;/strong&gt;&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;数据分析师与&lt;a class=&quot;internal&quot; href=&quot;https://www.zhihu.com/search?q=%E6%95%B0%E6%8D%AE%E5%B7%A5%E7%A8%8B%E5%B8%88&amp;amp;search_source=Entity&amp;amp;hybrid_search_source=Entity&amp;amp;hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A566098609%7D&quot;&gt;数据工程师&lt;/a&gt;的区别在哪里？&lt;/li&gt;
&lt;li&gt;为什么转行， 为什么没在公司内部转岗？&lt;/li&gt;
&lt;li&gt;你理解的分析师的工作是怎样的？&lt;/li&gt;
&lt;li&gt;分析团队的价值是什么？&lt;/li&gt;
&lt;li&gt;你觉得数据分析最重要的是什么？&lt;/li&gt;
&lt;li&gt;你平时都是怎么做数据清洗的？&lt;/li&gt;
&lt;li&gt;数据分析都用哪些工具？&lt;/li&gt;
&lt;li&gt;你认为数据分析师应该具备哪些能力？&lt;/li&gt;
&lt;li&gt;你对数据分析这个职位有什么看法？&lt;/li&gt;
&lt;li&gt;你对自己的职业定位是怎样的？&lt;/li&gt;
&lt;li&gt;你的优点和缺点是什么？&lt;/li&gt;
&lt;li&gt;为什么要选择做数据分析？（如果是转行，一般面试官会必问这个问题，建议结合原工作回答，从原工作引申过来。）&lt;/li&gt;
&lt;li&gt;你觉得数据分析最难的地方在哪里？（这个最好结合面试公司的业务产品来说，容易引起共鸣）&lt;/li&gt;
&lt;li&gt;你觉得数据分析的工作最大的收获是什么？&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;&lt;strong&gt;三、考察技术能力的问题&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;虽然各个数据分析师要做的事情不同，但是数据分析师最重要的 3 个能力却是通用的。面试过程一般会根据这 3 个能力来提问：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1）数据分析工具&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2）理论知识&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3）业务逻辑&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;这一部分是对业务能力的考察，可以说是整个面试中最重要的环节了，直接决定你能不能过。&lt;/p&gt;
&lt;p&gt;如果&lt;strong&gt;觉得自己在专业能力上还需要提升，或者基础薄弱但想做数据分析师，可以报名猴子老师在知乎上开设的「数据分析 3 天实战训练营」。&lt;/strong&gt;&lt;/p&gt;
&lt;a data-draft-node=&quot;block&quot; data-draft-type=&quot;edu-card&quot; data-edu-card-id=&quot;1572977657947566080&quot;/&gt;
&lt;p&gt;&lt;strong&gt;不仅会结合具体的工作场景，教你数据分析工具的使用方法，还会带你 get 面试官尤其看&lt;/strong&gt;&lt;a class=&quot;internal&quot; href=&quot;https://www.zhihu.com/search?q=%E6%95%B0%E6%8D%AE%E6%80%9D%E7%BB%B4&amp;amp;search_source=Entity&amp;amp;hybrid_search_source=Entity&amp;amp;hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A566098609%7D&quot;&gt;重的数据&lt;/a&gt;&lt;strong&gt;思维&lt;/strong&gt;。既掌握了专业技能、又具备思路和逻辑，面试会顺利不少。&lt;/p&gt;
&lt;p&gt;下面分别谈下这 3 个能力要掌握哪些知识。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1. 工具&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;常用的数据分析工具有 Excel+SQL+Python/R，有的公司要求会一种就可以，有的要求都会，所以根据你应聘职位的不同自由选择学习就可以。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1）Excel&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;需要掌握的核心技能有：&lt;/p&gt;
&lt;p&gt;&lt;a class=&quot;internal&quot; href=&quot;https://www.zhihu.com/search?q=%E6%95%B0%E6%8D%AE%E9%80%8F%E8%A7%86%E8%A1%A8&amp;amp;search_source=Entity&amp;amp;hybrid_search_source=Entity&amp;amp;hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A566098609%7D&quot;&gt;数据透视表&lt;/a&gt;，vlookup，常用函数的使用，基础图表的制作&lt;br/&gt;
&lt;/p&gt;
&lt;p&gt;常见的面试题：之前工作里用过什么报表？&lt;/p&gt;
&lt;p&gt;面试官主要想通过这个题目看下之前工作的复杂性，可以针对类似的问题准备下，比如说自学做项目的时候遇到过什么类型的报表之类的。不过不要脱离现实瞎编，因为很容易被戳穿。&lt;/p&gt;
&lt;p&gt;建议面试前准备一个项目，面试当天把电脑带过去，当问到 excel 技能的时候，直接拿出来给面试官演示。面试官除了问 excel 技能，还会问做表的逻辑，所以要能够讲清楚做表的逻辑，对方就会比较认可。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2）SQL&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;公司的内部数据存储在数据库中，作为数据分析师要能够从数据库中获取数据并进行分析。&lt;/p&gt;
&lt;p&gt;需要掌握的核心技能有：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;会利用 SQL &lt;a class=&quot;internal&quot; href=&quot;https://www.zhihu.com/search?q=%E5%BC%80%E6%BA%90%E6%95%B0%E6%8D%AE%E5%BA%93&amp;amp;search_source=Entity&amp;amp;hybrid_search_source=Entity&amp;amp;hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A566098609%7D&quot;&gt;操作开源数&lt;/a&gt;据库 mysql 进行查询&lt;/li&gt;
&lt;li&gt;存储过程&lt;/li&gt;
&lt;li&gt;数据库的分组、聚合、排序&lt;br/&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;最常见的考 SQL 的方法给你一个虚拟的数据库表结构，然后让你按给出的条件查询出数据，并用手写的形式写出在纸上。所以面试前把常用的语句记清楚就行了。&lt;/p&gt;
&lt;p&gt;&lt;a class=&quot;internal&quot; href=&quot;https://zhuanlan.zhihu.com/p/38354000&quot;&gt;常见的 SQL 笔试题和面试题：经典 50 题 4888 赞同 · 235&lt;/a&gt; 评论文&lt;br/&gt;
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3）编程语言 Python 或者 R&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;一般情况下，这两种语言会一种就够了。如果是学习 Python 的话，需要掌握的核心技能：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Python 基本语法&lt;/li&gt;
&lt;li&gt;Python 数据分析的包（numpy, pandas, matplotlib)&lt;/li&gt;
&lt;li&gt;能够用 python 操作结构化数据，进行数据清洗，数据抽取，数据可视化等&lt;/li&gt;
&lt;li&gt;使用 python 操作数据库&lt;/li&gt;
&lt;/ul&gt;
&lt;p class=&quot;ztext-empty-paragraph&quot;&gt;&lt;/p&gt;
&lt;p&gt;一般不会在代码上问得太细，毕竟写工作的时候不会的就用搜索引擎搜呗，面试官重要的想知道你究竟有没有用过这个技能。 参考复习资料：&lt;a class=&quot;internal&quot; href=&quot;https://www.zhihu.com/lives/903272047218692096&quot;&gt;零基础掌握人工智能(AI)核心语言：Python&lt;/a&gt;&lt;br/&gt;
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2.理论知识&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1）统计概率&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;这是数据分析必须要学的，不然很多统计指标看不懂，统计方法也不了解，怎么做数据分析呢？&lt;/p&gt;
&lt;p&gt;需要掌握的核心技能有：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;描述性统计（平均值，标准差，中位数）&lt;/li&gt;
&lt;li&gt;概率（独立事件，相关事件，期望，包括贝叶斯）&lt;/li&gt;
&lt;li&gt;概率分布（&lt;a class=&quot;internal&quot; href=&quot;https://www.zhihu.com/search?q=%E7%A6%BB%E6%95%A3%E6%A6%82%E7%8E%87%E5%88%86%E5%B8%83&amp;amp;search_source=Entity&amp;amp;hybrid_search_source=Entity&amp;amp;hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A566098609%7D&quot;&gt;离散概率分布&lt;/a&gt;，连续概率分布）&lt;/li&gt;
&lt;li&gt;统计推断（抽样，置信区间，假设检验）&lt;br/&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;例如面试官可能会这样问：置信区间 （Confidence Interval） 是更怕 I 型错误还是 II 型错误？如果还不会，可以看这&lt;a class=&quot;internal&quot; href=&quot;https://www.zhihu.com/lives/957267433334034432&quot;&gt;个复习：统计概率思维：误差思维和&lt;/a&gt;置信区间&lt;/p&gt;
&lt;p class=&quot;ztext-empty-paragraph&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2）机器学习（加分项）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;机器学习这一块其实应该算是数据分析岗位的加分项，不一定是必须的，要看具体岗位。&lt;/p&gt;
&lt;p&gt;需要掌握的机器学习算法：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;a class=&quot;internal&quot; href=&quot;https://www.zhihu.com/search?q=%E5%88%86%E7%B1%BB%E7%AE%97%E6%B3%95&amp;amp;search_source=Entity&amp;amp;hybrid_search_source=Entity&amp;amp;hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A566098609%7D&quot;&gt;分类算法&lt;/a&gt;：逻辑回归，贝叶斯、决策树、随机森林&lt;/li&gt;
&lt;li&gt;回归算法：线性回归&lt;/li&gt;
&lt;li&gt;&lt;a class=&quot;internal&quot; href=&quot;https://www.zhihu.com/search?q=%E8%81%9A%E7%B1%BB%E7%AE%97%E6%B3%95&amp;amp;search_source=Entity&amp;amp;hybrid_search_source=Entity&amp;amp;hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A566098609%7D&quot;&gt;聚类算法&lt;/a&gt;：K-means&lt;br/&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;需要掌握的核心技能：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;特征工程&lt;/li&gt;
&lt;li&gt;模型评价&lt;/li&gt;
&lt;li&gt;交叉检验（用已有的数据监测算法的预测力）&lt;br/&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;能够熟悉常见算法的基本原理、了解各类算法的优缺点和使用场景即可，如果是学到 Python，要会使用 Python 的机器学习 sklearn 包应用这些算法解决具体的问题。这方面多做几个 kaggle &lt;a class=&quot;internal&quot; href=&quot;https://www.zhihu.com/question/23987009/answer/285179721&quot;&gt;项目可以解决：Kagg&lt;/a&gt;le 如何入门？&lt;br/&gt;
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3.业务知识&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;主要包括业务指标和数据分析报告 2 块内容的掌握。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1）业务指标&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;数据分析师每天要关注大量数据指标，而数据指标又与具体的领域业务相关，掌握常用的数据指标可以灵活应对面试中提出的业务问题。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;需要掌握的核心技能：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;某一领域的业务知识&lt;/li&gt;
&lt;li&gt;数据分析思维：漏斗思维，&lt;a class=&quot;internal&quot; href=&quot;https://www.zhihu.com/search?q=%E5%88%86%E7%B1%BB%E6%80%9D%E7%BB%B4&amp;amp;search_source=Entity&amp;amp;hybrid_search_source=Entity&amp;amp;hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A566098609%7D&quot;&gt;分类思维&lt;/a&gt;，平衡思维，A/B test，&lt;a class=&quot;internal&quot; href=&quot;https://www.zhihu.com/search?q=%E9%87%91%E5%AD%97%E5%A1%94%E5%8E%9F%E7%90%86&amp;amp;search_source=Entity&amp;amp;hybrid_search_source=Entity&amp;amp;hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A566098609%7D&quot;&gt;金字塔原理&lt;/a&gt;等&lt;/li&gt;
&lt;li&gt;相关性和因果关系的区别， 通过案例可以分析出来&lt;/li&gt;
&lt;/ul&gt;
&lt;p class=&quot;ztext-empty-paragraph&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;常见的面试题：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;分析一个你在工作中能体现&lt;a class=&quot;internal&quot; href=&quot;https://www.zhihu.com/search?q=%E5%88%86%E6%9E%90%E6%80%9D%E7%BB%B4&amp;amp;search_source=Entity&amp;amp;hybrid_search_source=Entity&amp;amp;hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A566098609%7D&quot;&gt;分析思维&lt;/a&gt;的例子？&lt;/p&gt;
&lt;p&gt;各个指标如何衡量，比如 app 的转换率，是点击算转化还是注册了算转化还是购买产品后算转化？&lt;/p&gt;
&lt;p&gt;运营过程中，看某个指标有问题，你会怎么具体分析？&lt;/p&gt;
&lt;p&gt;跟我讲讲你之前公司业务运作模式或者情况？&lt;/p&gt;
&lt;p&gt;你做的事情对于业务有什么作用？&lt;/p&gt;
&lt;p class=&quot;ztext-empty-paragraph&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;业务知识面试如何准备？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;1）确定好要找哪个领域的数据分析师工作&lt;/p&gt;
&lt;p&gt;如果你说自己想进入「互联网行业&#x27;，那就说明你还没想清楚到底要干什么。因为互联网的存在是为了解决某个领域的问题，比如滴滴、高德地图解决的是出行交通领域的问题，小学英语在线平台 vipkid 解决的是教育行业的问题，蚂蚁金服解决的是金融行业的问题，饿了么解决的是餐饮行业的问题。&lt;/p&gt;
&lt;p&gt;而这些领域都需要数据分析师，每个领域的业务知识也不一样。所以以后你找的也是成为 XXX 行业的数据分析师。只有确定了行业，才能研究这个行业是什么，对症下药，这样成功转型的概率最大。&lt;/p&gt;
&lt;p&gt;选择领域建议优先选择与之前行业相关领域的数据分析师，因为有之前的行业经验作为你的业务知识，可以很快找到工作。&lt;br/&gt;
&lt;/p&gt;
&lt;p&gt;2）找到某领域的招聘职位需求&lt;/p&gt;
&lt;p&gt;确定好领域以后，就可以在招聘网站查找这个领域的数据分析职位，看看具体要求哪些。然后对应的去准备。&lt;/p&gt;
&lt;p&gt;3）简历中的项目要有针对性，转行成功的社群会员小周说的很对：&lt;/p&gt;
&lt;blockquote&gt;「聚焦」某个领域的数据分析才能有用。比如我做的有两个项目都是关于金融的，所以我在投互联网金融公司的时候获取到的面试机会比较多。&lt;/blockquote&gt;
&lt;p&gt;2）&lt;strong&gt;如何做数据分析报告？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;数据分析的最终产出是一份份报告，可能是 PPT，也可能是 PDF 等，活在使用 python 的 notebo&lt;a class=&quot;internal&quot; href=&quot;https://www.zhihu.com/lives/941368090206994432&quot;&gt;ok 来生成：如何用 Python 绘图和&lt;/a&gt;制作数据分析报告？。所以你还要会做数据分析报告。&lt;/p&gt;
&lt;p class=&quot;ztext-empty-paragraph&quot;&gt;&lt;/p&gt;
&lt;p&gt;上面每个技能的熟练程度划分为 5 个等级，依次分别是：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;了解基本概念&lt;/li&gt;
&lt;li&gt;了解基本概念/会简单操作&lt;/li&gt;
&lt;li&gt;熟悉基本概念/熟练操作&lt;/li&gt;
&lt;li&gt;精通逻辑论证/能改进优化&lt;br/&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;对于找数据分析师实习或者初级数据分析师的工作来说，上面这几个知识大多只需要掌握到第 2 个等级就可以了。&lt;br/&gt;
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3）面试中遇到不会的问题怎么回答&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;可以参考这个里面的经验分享（来源：&lt;a class=&quot;internal&quot; href=&quot;https://www.zhihu.com/question/47760443/answer/404494610&quot;&gt;柯本：从零开始学数据分析，什么程度可以找工作？&lt;/a&gt;）：&lt;/p&gt;
&lt;blockquote&gt;面试官的出身决定了他/她对哪个方面更看重。数学专业出身的会问更多的统计概率、分析思维，甚至模型方面的问题；&lt;br/&gt;
&lt;br/&gt;
计算机专业出身的会问更多的 SQL、python，甚至 Hive、spark 方面的问题，面对这种类型的面试官，就不要跟他们说 Excel，power BI 用的如何如何了，会直接拉低好感。&lt;br/&gt;
&lt;br/&gt;
不管哪种情况，都会有一个共同的可能性：被问到自己一窍不通的知识点。这时候不要慌张，我们都是转行的，有些工具没用过是正常的，我们可以真诚的表达出自己愿意按公司的需要快速学习提升的意愿。&lt;br/&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;4.考察项目&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;通常会这样问题：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;请举例说明自己参与的一个数据分析项目&lt;/li&gt;
&lt;li&gt;在这个项目中你做了什么？&lt;/li&gt;
&lt;li&gt;遇到的困难是怎么解决的？&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;还会问：&lt;/p&gt;
&lt;p&gt;1）分析维度有哪些？&lt;/p&gt;
&lt;p&gt;2）用了哪些分析方法？&lt;/p&gt;
&lt;p&gt;3）分析得出哪些结论？&lt;/p&gt;
&lt;p&gt;4）提出了哪些有效的建议？&lt;/p&gt;
&lt;p&gt;5）达到了什么样的效果？&lt;/p&gt;
&lt;p&gt;介绍项目主要采用主要采用 STAR 法则，不懂的看这个：&lt;/p&gt;
&lt;p&gt;&lt;a class=&quot;internal&quot; href=&quot;https://www.zhihu.com/question/60591411/answer/616955210&quot;&gt;面试时问到我的项目经历，是在问我什么呢？118 赞同 · 9 评论回答&lt;/a&gt;&lt;/p&gt;
&lt;figure&gt;&lt;noscript&gt;&lt;img alt=&quot;&quot; data-rawheight=&quot;608&quot; data-rawwidth=&quot;1080&quot; src=&quot;https://picx.zhimg.com/50/v2-0b16697b891ea1e571df8098b5230f34_720w.jpg?source=1940ef5c&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://picx.zhimg.com/v2-0b16697b891ea1e571df8098b5230f34_r.jpg?source=1940ef5c&quot;/&gt;&lt;/noscript&gt;&lt;img alt=&quot;&quot; data-rawheight=&quot;608&quot; data-rawwidth=&quot;1080&quot; src=&quot;&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://picx.zhimg.com/v2-0b16697b891ea1e571df8098b5230f34_r.jpg?source=1940ef5c&quot; data-actualsrc=&quot;https://picx.zhimg.com/50/v2-0b16697b891ea1e571df8098b5230f34_720w.jpg?source=1940ef5c&quot;/&gt;&lt;/figure&gt;
&lt;p class=&quot;ztext-empty-paragraph&quot;&gt;&lt;/p&gt;
&lt;p&gt;面试官会根据你说的内容，看你是否真的做过这个项目，考察你的实际技术能力，和逻辑能力是否清晰。&lt;/p&gt;
&lt;h2&gt;&lt;strong&gt;四、面试结束时的问题&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;问完上面的技术问题，到了面试快结束的环节，面试官通常会问：&lt;strong&gt;你有什么问公司的？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;这时候绝对不要问工资、五险一金和年假制度（这种是面试通过后，到了 HR 阶段有的是机会私下问 HR）。你可以提前准备这样几个问题，比如：&lt;/p&gt;
&lt;p&gt;我会和谁一起工作？&lt;/p&gt;
&lt;p&gt;如果我遇到问题，我可以通过哪些方式获得指导？&lt;/p&gt;
&lt;p&gt;公司希望我在三个月左右能达到什么水平？&lt;/p&gt;
&lt;p&gt;在我以前，公司里最优秀的新人是什么样的？&lt;/p&gt;
&lt;h2&gt;五、最后，和你谈谈心&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;1.找工作什么时机概率最大？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;秋招（每年的 10、11 月份）和春招（每年的 3、4 月份），是各大企业招聘的黄金时期，在这个时候会涌现出大量的岗位需求，包括数据分析师。并且，由于需求的突然涌现，一般都会带来一定程度的供不应求的状态，企业也会根据需求的紧急程度来适当调整入职门槛。大部分互联网公司都在这个阶段完成招聘。&lt;br/&gt;
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2.面试当天要注意什么？&lt;/strong&gt; 穿的正常就可以，不要太与众不同。手机不要调成振动，一定要调整到无声。坐下就拿出笔记本（能写字的那种笔记本哦）。对面试官不要叫「某总」，张嘴就叫「老师」。&lt;/p&gt;
&lt;p&gt;简历里不写错别字。面试时一直笑眯眯。&lt;/p&gt;
&lt;p&gt;进入面试环节后，不要被对方牵着鼻子走，要多说你会的，你熟悉的，不会的就说没做过。这是为什么呢？因为面试的时间相对固定，你说的多了。面试官问的就少了。你暴露的几率也就低了。&lt;br/&gt;
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3.如果面试失败怎么办？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1）第 1 种情况，简历制作太差&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;如果你是转行到数据分析，是没有项目经验的，但是如果简历里面也是一片空白，连面试的机会都没有，这方面可以具体看我详细写的：&lt;a class=&quot;internal&quot; href=&quot;https://www.zhihu.com/question/39722495/answer/489814492&quot;&gt;如何制作高水平简历？&lt;/a&gt;&lt;br/&gt;
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2）第 2 种情况，找错职位了&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;市面上的职位虽然名称都是「数据分析师」，但是要做的事情却是大大的不一样。面试失败，可能是你应聘的职位并不是适合你的那个「数据分析师」。&lt;/p&gt;
&lt;p&gt;比如之前有位社群会员是学到了入门阶段，但是去应聘一家数据分析师，要求精通机器学习，那么这种能力和职位不匹配，肯定是过不了面试的。这种情况你就要筛选出符合自己能力的职位，并看清楚职位的介绍，根据自己的能力来找到适合自己的工作。&lt;/p&gt;
&lt;p&gt;所以，如果面试被拒也不要气馁，有可能并不是你的原因，只是与岗位要求不匹配。&lt;br/&gt;
&lt;/p&gt;
&lt;p&gt;现在已经转行成功的社群会员 insight 是这么分享他找工作中犯的一个错误的：&lt;/p&gt;
&lt;blockquote&gt;收到面试通知时，没有问 HR 在公司数据分析职位是做哪些工作或是用什么分析工具。我投递简历选择的是拉勾网和 BOSS 直聘，前两天很认真的投递了简历，也收到了三家金融公司的面试，但一了解是让做金融交易员的，瞬间心脆。&lt;br/&gt;
&lt;br/&gt;
三天过去还有合适的公司，就有点心慌了，于是看到职位描述上有 EXCEl 和 Mysql 相关技能的，我都投了一份简历。没有针对性，也是犯了效率不高的错，这个错误等下说，重要的是收到面试通知时，没有问清 HR 数据分析工作是用什么分析工具或者主要是做什么工作。 我去北京第一家公司面试的时候，就是奔着他们的职位描述去的，当时想就是自己要的工作，但去了之后，HR 说他们公司只用 EXCEL 做数据分析，公司慢慢的会有数据团队。&lt;br/&gt;
&lt;br/&gt;
还有另外一家做大数据的公司，面试的时候出的是这样的题目，问题 1:tensorflow 构建一个神经网络的步骤；问题 2：试用 scikit-learn 实现一个简单的线性回归模型(这个记不太清了)，全都是诸如此类的问题。 所以说，如果提早的询问下，就会减少不必要的麻烦，可以多面试几家相符的公司。&lt;br/&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;3）第 3 种情况，面试失败是中常态&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;记住，面试是个长期的过程，很可能你投递简历很长时间没有人联系你，突然有一天电话就来了。这时候考察的就是谁能坚持到最后，一边积极等待投简历，一边积极准备技术。&lt;/p&gt;
&lt;p&gt;失败的面试不代表你不行，而是你和公司不适合。这就好比谈恋爱，双方互相看对眼了才能双宿双飞。&lt;/p&gt;
&lt;p&gt;动感单车健身公司飞轮运动（Flywheel Sports）的 CEO 欧哈根，她曾在 30 岁之前两次被公司开除。所以几次失败，不要否定自己。学会拥抱失败。你经历的每件事情都会给你收获，所以在经历这些时不要压力太大。而且人生不止一次机会。如果面试失败就去看《当幸福来敲门》，学会鼓励自己。再不行，就多看看这些经过多次失败，但是最后转行成功的朋友。记住，你并不孤单。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;4）第 4 情况，还没准备好&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;如果到最后经过 N 多次面试，并且排除了前面几种情况的可能，那么你已经总结好了面试中哪些能力是自己没有准备好的，那么你后面就可以多花些时间在这些欠缺的地方花更多时间去弥补上。等准备好了，再去应聘。有时候，人生比的不是谁跑的更快，而是谁能跑到终点。因为，有很多人没到终点，就放弃了。&lt;/p&gt;
&lt;p&gt;同时，如果是转行数据分析，因为没有工作经验被拒的话，也可以通过测试、运营、产品、等岗位曲线救国。&lt;/p&gt;
&lt;p&gt;因为互联网公司的测试岗位，空余时间多，你可以有更多的时间来同时学习数据分析方面的知识，还赚取了互联网工作的经验。而运营、产品工作中要经常跟数据打交道，不仅能熟悉公司的业务，还能接触到数据，后期合适的机会不管是进行内部转岗到数据分析部门，还是再找数据分析的工作会比较有优势。&lt;br/&gt;
&lt;/p&gt;
&lt;p&gt;最后，祝你成功。每个人生下来都是猴子，可有些人却最终可以逆袭为悟空。所以每个人心中其实住了个大圣。齐天大圣是不会死的，他只是睡着了。有一天，你要是够坚强，够勇敢，就能驾驭它。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;如果觉得自己在能力上还需要提升，欢迎体验「知乎数据分析 3 天实战训练营」，点击下面链接即可体验。&lt;/strong&gt;&lt;br/&gt;
&lt;/p&gt;
&lt;a data-draft-node=&quot;block&quot; data-draft-type=&quot;edu-card&quot; data-edu-card-id=&quot;1572977658060849152&quot;/&gt;
&lt;p&gt;本文作者：@猴子&lt;/p&gt;&lt;/span&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>3f5be48e9f00e2e80e79e633cba6f740</guid>
<title>【JVM 札记】JVM 内存划分</title>
<link>https://toutiao.io/k/vazr8q6</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content js_underline_content               autoTypeSetting24psection&amp;#10;            &quot; id=&quot;js_content&quot;&gt;&lt;section&gt;&lt;mp-common-profile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mpprofile&quot; data-weui-theme=&quot;light&quot; data-id=&quot;MzI0MzA2OTc4MQ==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/Bfv9smoHwth5nBzNr9kZshQ25yhLz08JicGiaeuWY5k8z6JHS4KYxQ2zp2lU9mjSC6PsvBlib658u3CnrSQsuCzAg/0?wx_fmt=png&quot; data-nickname=&quot;码农UP2U&quot; data-alias=&quot;&quot; data-signature=&quot;努力成为一个初级程序员！&quot; data-from=&quot;0&quot; data-is_biz_ban=&quot;0&quot;/&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;早期文章&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Java 之所以能够跨平台，完全仰仗于 JVM，JVM 作为操作系统中的一个进程而存在。它主要用来将 .class 文件翻译成二进制的机器码并在 CPU 上进行执行。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;是否有必要学习 JVM&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;为什么要了解 JVM 的内存划分或者内存管理呢？其实本身我觉得是没有太多必要的，因为作为一个普通的程序员而言，去了解它是一种破坏黑盒子的行为。但是，JVM 提供了自动的内存管理机制，它的内存自动管理机制虽然有很多实现方式，但是在各种不同的场景下它不一定是最优的。在追求极致的状态下，就要通过人为的调控它来让它最优，因此又不得不去学习它，去了解它。这就好比，作为一个普通的司机，会开汽车就可以了，不用关心发动机的原理与实现；而对于一个赛车手可能就需要对发动机在不同环境下的性能等有深入的了解，从而让赛车发挥最大的优势。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;为什么进行内存划分&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;既然需要了解 JVM 的内存划分，那么就先说说 JVM 为什么要进行内存划分呢？这个其实比较好理解，因为这种划分区域的方式可以说随处可见。比如家里的房子会按照人的作用划分为客厅、卧室、卫生间等，基本上每个房间是按照其作用进行划分的，也方便进行管理，还有不同的权限，比如去别人家，在客厅坐坐就好，不要去人家的卧室。其实软件中也是这样。比如新买的硬盘会进行分区，会进行格式化操作。除此而外，&lt;/span&gt;&lt;span&gt;操作系统也会对内存进行划分，可执行程序被加载入内存后，也会有相应的不同属性的内存。我们知道程序大体分为两部分，一部分是指令，一部分是数据。&lt;/span&gt;&lt;span&gt;指令和数据在内存中通常也是分开的。比如，&lt;/span&gt;&lt;span&gt;代码是只读和可执行的，而不可写；数据有的是可读写的，有的是只读的；这样可以根据不同的内存属性来划分不同的内存区域。&lt;/span&gt;&lt;span&gt;事实上，操作系统也是这么做的。这种做法也符合分治思想。（你可能会说，万事没有绝对，代码所属的内存有时也是可以写的，比如加壳、脱壳，数据所属的内存也是可以被执行，比如缓冲区溢出、虚拟机等。当然了，虽然这是事实，但是也并不说明内存按属性划分的管理方式有问题）&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;JVM 内存大致划分&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;JVM 作为虚拟机的存在可以被认为是一台独立的机器，.class 作为 JVM 上的可执行文件，因此，JVM 也会划分不同的内存区域来管理 .class 文件在执行时的状态。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;JDK 8 的内存区域划分与之前 JDK 版本有所不同，大体是移除了持久代，而改用了元空间。JDK 8 的 JVM 内存区域划分大体如下：&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.4218512898330804&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Bfv9smoHwtiaCmh4HkpCNUENLDQAiaIJqBjCnmogpcJxOmYZQDSKXibFMagAICG2dTwYPxSr1p6L9Lb4PskTI2L5A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;659&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在图中，可以看到内存大体划分为：方法区、堆、虚拟机栈、本地方法栈、程序计数器和直接内存。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;这里大体来介绍一下这些内存区域的作用。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在上面的内存区域中，方法区与堆是各个线程共享的；而虚拟机栈、本地方法栈和程序计数器是线程相关的，也就是各个线程是独立的、隔离的。&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;程序计数器&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;先来说一下程序计数器。程序计数器相当于 CPU 中的 IP 寄存器，即指令指针寄存器，32 位的 CPU 被称为 EIP，64 位的 CPU 称为 RIP。它的作用是保存了下一条要执行的指令的地址。JVM 中的程序计数器其实也是同样的道理。为什么程序计数器是线程相关的呢？比如一个方法可以被多个线程同时执行（毕竟一个方法的代码在内存中应该只有一份），而每个线程执行到当前方法的哪条指令就需要分别由各自线程的程序计数器来保存。也就是 A 线程有 A 线程自己的程序计数器，B 线程有 B 线程自己的程序计数器，它们互相独立，互不影响。&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;栈结构&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;虚拟机栈是一个“栈”结构，栈中存放局部变量、参数、返回地址等。且它们也是线程相关的，也就是每个线程都有自己的栈。在栈中有多个栈帧，每进入一个方法，就会开辟相应的栈帧。什么是栈帧呢？可以理解为栈对应着线程，栈帧对应着方法。这种解释方法并不一定准确，但是我个人认为比较好理解。CPU 管理栈时，使用 BP 和 SP 两个寄存器来进行管理，分别管理着栈顶和栈底。当调用方法时，会将参数和返回地址入栈，然后保存 BP 寄存器，即栈底指针，然后通过按照局部变量的大小来改变 SP 寄存器分配新的栈顶，这样就相当于是一个新的栈帧。当方法执行完成后，会通过改变 SP 寄存器的值来回收栈空间，栈中保存的 BP 寄存器的值再送回 BP 寄存器，将返回地址送到 IP 寄存器。这样一顿操作下来，栈帧就恢复到了方法调用前的情况。当然了，JVM 虚拟机对栈的管理应该不是直接使用 BP 和 SP 寄存器，但是原理应该是类似的。毕竟栈这种数据结构，主要就是栈底和栈顶两个指针就可以管理了。&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;本地方法栈是虚拟机使用到本地方法时会用到的栈。&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;堆内存&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;堆是 JVM 中较大的一块内存，在方法中的基本数据类型会使用栈，而对象和数组则会在堆上进行分配。Java 是面向对象的程序设计语言，会有很多的对象要进行使用，也就是所有的对象会在堆中进行分配。当堆中的对象不再使用时，JVM 会在某个时间点回收这些内存空间。由于堆空间较大，而对于较大的内存进行回收时就是比较耗时的事情，因此 JVM 又把堆空间又被进行了各种细分，比如 Eden、Survivor 等。这块应该是学习的一个重点，毕竟垃圾回收就主要是针对堆内存进行的。对于 C 和 C++ 这样的语言，就是使用 malloc、free、new、delete 一类的函数来进行管理，当然了是程序员自己进行管理。&lt;/span&gt;&lt;span&gt;如果程序员管理不好自己分配的内存就会导致内存泄漏，最后可能明明有内存却申请不到内存而导致进程挂掉或其他的问题吧。JVM 就是来替程序员管理这部分内存的，管理的重点就是堆空间什么时候回收，怎么回收。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;方法区&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;方法区与 Java 的堆空间一样，也是被线程共享的，其中存放了类型信息、常量、静态变量等。比如这里可以放置 Java 代码对应的字节码，那么代码当然是所有线程共享的，我们不需要把同样的代码在内存中加载两次，让两个线程分别执行两份相同的代码，毕竟同一份代码的逻辑是相同的，不同的只是数据。因此，代码是共享的，不同的线程各自操作各自的数据即可。（当然了，共享的数据在多个线程下同时被操作时是有危险的，所以就搞出了线程的同步、互斥之类的）&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;总结&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;其实这种知识我觉得还是不要迷信的好，能把代码真正的写好也不容易，去学习数据结构、设计模式可能更贴近工作。在相同的算法下，在经过调优当然会更好，但是代码写的很糟糕，就想着用这种方式调优，感觉有些离谱。当然了，如果了解了 JVM 以后，在写代码时能更亲和 JVM 的工作方式去写代码，那样也不错。但是还是那个前提，就是代码效率的本身已经不错了，再考虑这些。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;当然了，如果工作中真的能用到 JVM，或者也真的需要用到 JVM 那就另当别论了。（面试要问的话，也得准备！！）&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.0712962962962963&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Bfv9smoHwthBDooApBDUM9yqM6BWHMOaJyrXzMxqibI7B90xNgZswWSVSatF56vMAicAA56UmJkc2rQlDUARycYQ/640?wx_fmt=png&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;mpcps class=&quot;js_editor_new_cps&quot; data-templateid=&quot;list&quot; data-traceid=&quot;undefined&quot; data-goodssouce=&quot;1&quot; data-pid=&quot;101_10060770213143&quot; data-appuin=&quot;3243069781&quot; data-buffer=&quot;{&amp;quot;category_id&amp;quot;:0,&amp;quot;pid&amp;quot;:&amp;quot;101_10060770213143&amp;quot;,&amp;quot;biz_uin&amp;quot;:&amp;quot;3243069781&amp;quot;,&amp;quot;sku_id&amp;quot;:&amp;quot;101_10060770213143&amp;quot;,&amp;quot;source_id&amp;quot;:2,&amp;quot;source_name&amp;quot;:&amp;quot;京东&amp;quot;,&amp;quot;audit_state&amp;quot;:1,&amp;quot;main_img&amp;quot;:&amp;quot;https://pcm-img.zhls.qq.com/productcenter-6fa174af--1018824-7975090560325406147/23105240921122022/b7eff0a3125954d219c32e31f2511988.jpg&amp;quot;,&amp;quot;product_name&amp;quot;:&amp;quot;逆向分析实战冀云人民邮电出版社9787115590701 计算机与互联网书籍&amp;quot;,&amp;quot;current_price&amp;quot;:7390,&amp;quot;first_category_id&amp;quot;:&amp;quot;0&amp;quot;,&amp;quot;product_label_name_list&amp;quot;:[],&amp;quot;select_tag_name_list&amp;quot;:[],&amp;quot;templateId&amp;quot;:&amp;quot;card&amp;quot;,&amp;quot;appuin&amp;quot;:&amp;quot;3243069781&amp;quot;,&amp;quot;isNewCpsKOL&amp;quot;:1}&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;公众号内回复 【mongo】 下载 SpringBoot 整合操作 MongoDB 的文档。&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;公众号内回复 【&lt;/strong&gt;&lt;strong&gt;cisp知识整理&lt;/strong&gt;&lt;strong&gt;】 下载 CISP 读书笔记。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;公众号内&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;回复【java开发手册】获取《Java开发手册》黄山版。&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.36484375&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Bfv9smoHwth5nBzNr9kZshQ25yhLz08JHWsQdz8yVn3MVh22hia7NFoPyNJz4ZI7XUnMa9xM50TJRqPkWf7BRibQ/640?wx_fmt=jpeg&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; data-type=&quot;jpeg&quot; data-w=&quot;1280&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;mp-style-type data-value=&quot;3&quot;/&gt;&lt;/p&gt;&lt;/div&gt;

          
        &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>21ea937a99242d6816624d3ec9cea1e2</guid>
<title>消息队列的过去、现在和未来</title>
<link>https://toutiao.io/k/pvfb3ip</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section&gt;&lt;section&gt;&lt;span&gt;本文以互联网的发展为主线，用叙事的方式向读者再现了消息系统从诞生至今的发展历史。从 1983 年开始，消息系统经历了不同历史时期的历练与打磨，它们的使用方式、功能特性、产品形态、应用场景都发生了非常大的变化。作者选取了五款不同时代的代表性作品，描述了这些产品诞生的历史背景，立足解决的核心问题，并尝试分析它们取得成功的关键因素。最后作者给出了在 Serverless 时代的三个断言，指出了当前消息系统在解决 Serverless 场景存在的核心痛点，展望了未来消息产品应该具备的关键能力，并给出了几款最新流行的适合 serverless 场景的开源消息队列。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;开源史前的消息队列&lt;/span&gt;
&lt;/section&gt;&lt;p&gt;故事要从一位印度小哥说起。1983 年 26 岁的孟买工程师 Vivek Ranadive&lt;sup&gt;&lt;sup&gt;&lt;span&gt;[1]&lt;/span&gt;&lt;/sup&gt;&lt;/sup&gt; 从 MIT 毕业后决定创办自己的信息技术公司。当时与硬件相比，软件开发效率非常低。受计算机总线的启发，Vivek 设计了一款软件计算机总线，名为 The Information Bus（TIB），从此消息队列踏入了软件历史，开启了一个全球每年数十亿美金的新市场。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.5806451612903226&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/YriaiaJPb26VMyhzsVgnMFM4JN1Zh8ahP29otCkm6jrKnRoMmG1Towue1lxCB6Jg7FD1PTrnX9XIQNyp1NEpaLGg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;620&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Vivek Ranadiv&lt;sup&gt;&lt;sup&gt;[2]&lt;/sup&gt;&lt;/sup&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;1985 年，Vivek 从 Teknekron Corp 获得种子资金，Teknekron Software Systems Inc. (TSS) 诞生了，专注于 TIB 商业化。TIB 主要服务于金融行业，解决证券交易软件之间的数据交换问题。20 世纪 80 年代美国金融交易行业门厅若市，因此 TIB 被广泛使用大获成功。Teknekron 于 1993 年被路透集团收购 &lt;sup&gt;&lt;sup&gt;&lt;span&gt;[3]&lt;/span&gt;&lt;/sup&gt;&lt;/sup&gt;，1997 年路透成立 TIBCO Softwore&lt;sup&gt;&lt;sup&gt;&lt;span&gt;[4]&lt;/span&gt;&lt;/sup&gt;&lt;/sup&gt; 独立运营 TIB 软件解决方案。2014 年 TIBCO Software 通过 Vista Equity Partners 的 43 亿美元的收购，被正式私有化 &lt;sup&gt;&lt;sup&gt;&lt;span&gt;[5]&lt;/span&gt;&lt;/sup&gt;&lt;/sup&gt;。&lt;/p&gt;&lt;p&gt;TIB 的成功受到蓝色巨人 IBM 的关注，因为 IBM 的客户也主要来自于金融行业。1990 年 IBM 开始研发消息队列，三年后 IBM WebSphere MQ 产品面世&lt;sup&gt;&lt;sup&gt;&lt;span&gt;[6,7]&lt;/span&gt;&lt;/sup&gt;&lt;/sup&gt;。经过不断发展，IBM MQ 成为全球极具竞争力的商业消息系统 &lt;sup&gt;&lt;sup&gt;&lt;span&gt;[8,9]&lt;/span&gt;&lt;/sup&gt;&lt;/sup&gt;。根据 Gartner 报告 &lt;sup&gt;&lt;sup&gt;&lt;span&gt;[1&lt;/span&gt;&lt;/sup&gt;&lt;/sup&gt;&lt;sup&gt;&lt;sup&gt;&lt;span&gt;0] &lt;/span&gt;&lt;/sup&gt;&lt;/sup&gt;2020 年 IBM MQ 每年全球仍有近 10 亿美金的营收, 占全球消息中间件市场份额近三分之一。&lt;/p&gt;&lt;section&gt;&lt;span&gt;开源时代&lt;/span&gt;
&lt;/section&gt;&lt;p&gt;商业化 MQ 的成功，使其占据了大型企业的应用通信市场，然而高昂的价格却令中小企业望而却步。同时，商业化 MQ 提供商为了维持其竞争壁垒，建立了封闭的产品生态，不与其他 MQ 互通。导致很多大企业同时用了多个 MQ 供应商的产品，彼此却无法打通。例如，应用已经订阅了 TIBCO MQ 消息，若需要消费来自 IBM MQ 的消息，则实现起来会非常困难。这些产品使用不同的 API、不同的协议，因而毫无疑问无法联合起来组成单一的总线。为了解决这个问题，Java Message Service（JMS）在 1998 年诞生了 &lt;sup&gt;&lt;sup&gt;&lt;span&gt;[11,12]&lt;/span&gt;&lt;/sup&gt;&lt;/sup&gt;。&lt;/p&gt;&lt;p&gt;JMS 之于 MQ 类似于 JDBC 之于数据库，它试图通过提供公共 Java API 的方式，隐藏单独 MQ 产品供应商提供的实际接口，从而跨越壁垒解决互通问题。从技术上讲，Java 应用程序只需针对 JMS API 编程，选择合适的 MQ 驱动即可，JMS 会打理好其他部分。JMS 确实一定程度上解决了 MQ 之间互通的问题，但当应用通讯底层适配不同的 MQ 时需要代码去胶合众多不同 MQ 接口，这使 JMS 应用程序非常脆弱，可用性下降。很明显，市场急需一个原生支持 JMS 协议的 MQ 出现。&lt;/p&gt;&lt;p&gt;基于这样的背景，2003 年 ActiveMQ 诞生&lt;sup&gt;&lt;sup&gt;&lt;span&gt; [13]&lt;/span&gt;&lt;/sup&gt;&lt;/sup&gt;，它是第一个原生支持 JMS 协议的开源消息队列产品。ActiveMQ 完整实现了 JMS。ActiveMQ 的出现解决了适配 JMS 稳定性的问题，受到很多企业的支持。而且 ActiveMQ 是开源产品，鉴于商业版 MQ 高昂的价格，ActiveMQ 深受中小企业的追捧。2005 年 Damarillo 等人围绕 ActiveMQ 项目成立了 LogicBlaze 公司&lt;sup&gt;&lt;sup&gt;&lt;span&gt; [14]&lt;/span&gt;&lt;/sup&gt;&lt;/sup&gt;，该公司 2 年后被 IONA 收购&lt;sup&gt;&lt;sup&gt;&lt;span&gt; [15]&lt;/span&gt;&lt;/sup&gt;&lt;/sup&gt;。&lt;/p&gt;&lt;p&gt;JMS 有一个比较严重的不足，只针对于 Java 应用。其他语言开发的程序无法使用 JMS 完成信息的交换，在此背景下，真正的救世主 AMQP 出现了。AMQP&lt;sup&gt;&lt;sup&gt;&lt;span&gt;[16]&lt;/span&gt;&lt;/sup&gt;&lt;/sup&gt;（Advanced Message Queuing Protocol）在 2003 年时被 John O&#x27;Hara 提出，由摩根大通牵头联合 Cisco, IONA,Red Hat, iMatix 等成立了 AMQP 工作组，用于解决金融领不同平台之间的消息传递交互问题。AMQP 是一种协议，更准确的说是一种 Binary Wire-Level Protocol（链接协议）。这是其与 JMS 的本质差别，AMQP 不从 API 层进行限定，而是直接定义网络交换的数据格式。这使得实现了 AMQP 的 Provider 天然性就是跨平台的。意味着我们可以使用 Java 的 AMQP Provider，同时使用一个 Python 的 Producer 加一个 Ruby 的 Consumer。从这一点看，AMQP 可以用 HTTP 来进行类比，不关心实现的语言，只要大家都按照相应的数据格式去发送报文请求，不同语言的 Client 均可以和不同语言的 Server 链接。AMQP 的 Scope 要比 JMS 更广阔。&lt;/p&gt;&lt;p&gt;显然市场上需要一个完全实现 AMQP 协议的消息队列产品。2007 年由 Alexis 和 Matthias 联合创办的公司 Rabbit Technologies 成立 &lt;sup&gt;&lt;sup&gt;&lt;span&gt;[17]&lt;/span&gt;&lt;/sup&gt;&lt;/sup&gt;，同年该公司推出了第一个完全实现 AMQP 协议的消息队列产品 RabbitMQ，该公司 2010 年被 VMware 收购 &lt;sup&gt;&lt;sup&gt;&lt;span&gt;[18]&lt;/span&gt;&lt;/sup&gt;&lt;/sup&gt;。RabbitMQ 用 Erlang 语言开发，性能非常好，微秒级延时。因为对 AMQP 的完全支持，较之 IBM MQ 等商业产品以及实现 JMS 的 ActiveMQ，其更加开放，可以支持更多的应用接入集成。而且较之同时代的 AMQP 其他实现产品比如 Apache Qpid&lt;sup&gt;&lt;sup&gt;&lt;span&gt;[19]&lt;/span&gt;&lt;/sup&gt;&lt;/sup&gt;，其多语言客户端、技术文档更加规范、健全，开源社区更加活跃&lt;sup&gt;&lt;sup&gt;&lt;span&gt;[20][21]&lt;/span&gt;&lt;/sup&gt;&lt;/sup&gt;。这使得 RabbitMQ 逐渐成为中小企业甚至大企业进行消息交换的理想选择。实际上在全球范围内，RabbitMQ 至今仍然是最成功的开源消息队列之一。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.475&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/YriaiaJPb26VMyhzsVgnMFM4JN1Zh8ahP2RMlRkyuEf1ome56e6FBObUXK72n1vtoZSLHFVeAASQcjJL1C8yfnrA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;RabbitMQ 架构图&lt;sup&gt;&lt;sup&gt; [22]&lt;/sup&gt;&lt;/sup&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;当然 RabbitMQ 并非完美无缺，恰恰由于其对 AMQP 协议的完美支持，实现过于复杂。这也导致它的吞吐量并不高。&lt;/p&gt;&lt;section&gt;&lt;section&gt;
&lt;span&gt;大数据时代&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;互联网的诞生让企业产生的数据越来越多，2010 年移动互联网的到来，使互联网这个超级入口被彻底引爆。2010 年全球有 19 亿 7 千万网民，占全球人口的 28.7%&lt;sup&gt;&lt;sup&gt;&lt;span&gt;[23]&lt;/span&gt;&lt;/sup&gt;&lt;/sup&gt;。因此互联网企业需要处理越来越多的数据，LinkedIn 作为一个全球性的社交网站，2010 年已经有超过 9000 万&lt;sup&gt;&lt;sup&gt;&lt;span&gt;[24]&lt;/span&gt;&lt;/sup&gt;&lt;/sup&gt;的会员。它需要每天通过大量日志分析互联网用户的行为，进行产品优化与广告投放。大数据分析的基本范式 Lamdba&lt;sup&gt;&lt;sup&gt;&lt;span&gt;[25,26]&lt;/span&gt;&lt;/sup&gt;&lt;/sup&gt;是通过数据采集组件从众多系统中采集数据，然后汇聚到 Spark 或者 Hadoop 等大数据平台。用户行为日志数据是通过分布式的采集程序进行日志获取，Hadoop 可以实现大量数据的批量分析，如何将海量的日志数据传输到 Hadoop 成为一个关键问题&lt;sup&gt;&lt;sup&gt;&lt;span&gt;[27]&lt;/span&gt;&lt;/sup&gt;&lt;/sup&gt;。在数据集成的场景中 LinkedIn 最初的方案是通过 ActiveMQ 进行日志传输。然而在大数据集成的场景中，ActiveMQ 的性能问题暴露无疑。它虽然有完整的消息机制、灵活的配置方式以及安全的消息交付保证，但是对于 LinkedIn 传输海量数据的场景，并无帮助&lt;sup&gt;&lt;sup&gt;&lt;span&gt;[28]&lt;/span&gt;&lt;/sup&gt;&lt;/sup&gt;。大数据集成场景需要将海量日志数据快速传输到大数据平台，并不需要复杂配置以及 AMQP 协议的支持，最需要的是高吞吐量的传输产品，这一点 AcitveMQ 无法满足。&lt;/p&gt;&lt;p&gt;在这样的背景下，2009 年底 LinkedIn 计划自研了新一代的消息产品 Kafka&lt;sup&gt;&lt;sup&gt;&lt;span&gt;[29,30&lt;/span&gt;&lt;/sup&gt;&lt;/sup&gt;&lt;sup&gt;&lt;sup&gt;&lt;span&gt;]&lt;/span&gt;&lt;/sup&gt;&lt;/sup&gt;，以解决海量网站活动跟踪事件、应用监控指标&lt;sup&gt; [31]&lt;/sup&gt;、数据库等数据到大数据分析平台的传输。根据 Kafka 创始人 Jay Kreps 的分享，kafka 最初的设计主要有三个要求 &lt;sup&gt;&lt;sup&gt;&lt;span&gt;[32]&lt;/span&gt;&lt;/sup&gt;&lt;/sup&gt;：每个节点每秒钟数百兆的数据吞吐量，所有数据都要持久化，数据分布式存储。这其中最大的挑战是既要求高吞吐量又要求消息的持久化。这是一个两难的需求，因为通常情况下如果需要高吞吐量，程序一般会将数据直接放到内存而不是磁盘，因为内存的读取速度更快。而如果需要数据的持久化，一般会将数据存储到磁盘上，但是磁盘读取的速度会非常慢。对于这个问题，研究了消息队列特殊的数据存储与传输模式后，基于对日志深入而独到的见解&lt;sup&gt;&lt;sup&gt;&lt;span&gt; [33]&lt;/span&gt;&lt;/sup&gt;&lt;/sup&gt;，并且充分利用了操作系统软硬件的特点，Jay Kreps 团队给出了非常巧妙的设计方案&lt;sup&gt;&lt;sup&gt;&lt;span&gt;[34]&lt;/span&gt;&lt;/sup&gt;&lt;/sup&gt;，将数据以日志的形式顺序写到磁盘，并且顺序的读日志数据。由于硬盘的特殊结构，顺序写磁盘可以获得超过 100MB/s 的写入速度，甚至高于随机写内存。Kafka 读取数据也是顺序读取，而由于操作系统有 Page Cache 机制的原因，顺序读磁盘也可以获得接近读内存的性能。通过这样的方式，Kafka 虽然将消息写入了磁盘，但是获得了接近内存的读写速度，这就是 Kafka 高吞吐的奥秘。当然，kafka 还采用了批量发送、数据压缩、zero-copy&lt;sup&gt;&lt;sup&gt;&lt;span&gt;[35] &lt;/span&gt;&lt;/sup&gt;&lt;/sup&gt;三项技术，通过这些技术很大程度提高了 kafka 的吞吐量，并保障了消息的持久化。Kafka 高性能读写具体分析可参考这里 &lt;sup&gt;&lt;sup&gt;&lt;span&gt;[36]&lt;/span&gt;&lt;/sup&gt;&lt;/sup&gt;。Kafka 的数据存储方式如下图，其将一个 Topic 分成若干个 Partition，生产者在发送数据时会按照一定的规则顺序向 Partition 中写入数据。而对于消息的一些特性，比如事务消息、延时消息、死信队列等，Kafka 并没有实现。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.5703125&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/YriaiaJPb26VMyhzsVgnMFM4JN1Zh8ahP20yCaY9fu43L0HvXyLGlYecHPm9lTAXJ9eHu7ImAWHdA9ibkjCdlawwg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Kafka 的存储模式&lt;sup&gt;&lt;sup&gt;[37]&lt;/sup&gt;&lt;/sup&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;基于以上理念设计的 Kafka 达到了非常高的吞吐量，并且能够同时实现数据在磁盘的持久化。下图是 kafka 在 LinkedIn 上线后，Jay Kreps 团队将 kafka 与当时最流行的消息队列 ActiveMQ、RabbitMQ 性能对比情况 &lt;sup&gt;&lt;sup&gt;&lt;span&gt;[38]&lt;/span&gt;&lt;/sup&gt;&lt;/sup&gt;。从下图可以看出由于 kafka 在生产消息和消费消息的吞吐量逗比其他两个消息系统有 4 倍以上的优势。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.3671875&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/YriaiaJPb26VMyhzsVgnMFM4JN1Zh8ahP2btS5Vyv2Oc2lbdibfUe37y2kSzia5R9N5Zb90ibGP2ia7JChOmYQmK2Xxw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;Kafka 于 2010 年底被开源，2011 年 7 月被 LinkedIn 捐献到了 Apache 基金会&lt;sup&gt;&lt;sup&gt;&lt;span&gt;[39]&lt;/span&gt;&lt;/sup&gt;&lt;/sup&gt;，2012 年 10 月 23 日 Kafka 从 Apache 毕业成为顶级开源项目。Kafka 用其独特的设计方式解决了大数据集成场景常见而且关键的问题，开源之后很快被 Twitter、Netflix、Uber 等硅谷互联网公司大量用于大数据分析场景 &lt;sup&gt;&lt;sup&gt;&lt;span&gt;[40]&lt;/span&gt;&lt;/sup&gt;&lt;/sup&gt;。&lt;/p&gt;&lt;p&gt;2014 年 11 月 1 日 Kafka 创始团队成员宣布从 LinkedIn 离职，并创立了公司 Confluent&lt;sup&gt;&lt;sup&gt;&lt;span&gt;[41]&lt;/span&gt;&lt;/sup&gt;&lt;/sup&gt;，专注于 Kafka 产品的开源与商业化，Benchmark、LinkedIn 等为该公司投资 690 万美金。Confluent 成立之后，为了更全面的解决大数据分析问题，2016 年和 2017 年 Kafka 陆续推出了 Kafka Connect&lt;sup&gt;&lt;sup&gt;&lt;span&gt;[42]&lt;/span&gt;&lt;/sup&gt;&lt;/sup&gt;和 KsqlDB 两款生态组件，一举奠定了 Kafka 大数据领域数据传输事实标准的地位。Kafka Connect 主要用于将 Kafka 与周边的产品更好的集成，比如通过 MySQL Source Connector 用户可以更好的将 MySQL 的变更数据抽取到 Kafka 系统。通过 Hadoop Sink Connector 用户可以将 Kafka 中的数据更方便地写到 Hadoop 中。Kafka KsqlDB 旨在实时处理 Kafka 传输的数据。比如大数据传输的过程中通常需要数据过滤、去重等 ETL 操作，借助 Kafka 的 KsqlDB 可以比较好的完成这些工作。下图是增加两个大数据组件后的 Kafka 生态架构图，详细分析可参考这里&lt;sup&gt;&lt;sup&gt;&lt;span&gt;[43]&lt;/span&gt;&lt;/sup&gt;&lt;/sup&gt;。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.5&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/YriaiaJPb26VMyhzsVgnMFM4JN1Zh8ahP2psklTNvDZ4yOwLdJjmgpPoibFbHKUvdib4Arfxto3zG1AvRCmWFsTu4Q/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;微服务时代&lt;/span&gt;
&lt;/section&gt;&lt;p&gt;随着互联网的持续发展，越来越多的网民被民主的信息获取方式以及便捷的生活方式所吸引。网民的持续入场，对于互联网公司意味着持续飞速的业绩增长以及一波又一波的股市浪潮。2011 年谷歌市值为 1800 亿美元，员工总数 2.4 万多人&lt;sup&gt;&lt;sup&gt;&lt;span&gt;[44]&lt;/span&gt;&lt;/sup&gt;&lt;/sup&gt;。而 2021 年谷歌市值逼近 2 万亿美金&lt;sup&gt;&lt;sup&gt;&lt;span&gt; [45]&lt;/span&gt;&lt;/sup&gt;&lt;/sup&gt;，超过 2010 年 10 倍，人数超过 15 万人。然而应用软件，却面临着越来越大的挑战。为了应对数以亿计的网民的访问，应用软件不得不做架构性的重构，以保证越来越多的用户能够更顺滑的访问网站。&lt;/p&gt;&lt;p&gt;在这个大的背景下微服务进入了众多开发者的视野，任何一个技术并不是它发明的时候被人关注，而是需要的时候。微服务就是这样的技术，虽然微服务 &lt;sup&gt;&lt;sup&gt;&lt;span&gt;[46]&lt;/span&gt;&lt;/sup&gt;&lt;/sup&gt; 在 2005 年就被提出，但实际上直到 2014 年之后才陆续被用于重构网站的后端系统，以应对越来越多的高并发访问。RocketMQ 就是因为这样的需求诞生的。为了应对双十一海量用户的访问，淘宝、天猫等阿里巴巴的网站陆续做了微服务化的改造。此前，电商系统只有几个大型的后端服务程序构成，为了提高整个网站的高并发能力，后端服务被重新构造成了数百个微服务。2010 年之前，淘宝网站服务通信是通过基于 ActiveMQ 构建的消息平台 Napoli 完成，Napoli 将消息持久化的数据库中 &lt;sup&gt;&lt;sup&gt;&lt;span&gt;[47]&lt;/span&gt;&lt;/sup&gt;&lt;/sup&gt;。&lt;/p&gt;&lt;p&gt;随着阿里巴巴电商系统完成微服务改造后，如何为成百上千的微服提供异步通信能力成为关键问题。Napoli 由于需要将数据存储到数据库，吞吐量非常有限，无法支持大规模微服务集群的异步通信。Kafka 开源之后，阿里用 Java 重写了 Kafka 的核心逻辑，并命名为 MetaQ，希望能解决大规模微服务异步交互问题。Kafka 虽然有非常高的吞吐量与持久化能力，但还是无法支撑大规模微服务的场景 &lt;sup&gt;&lt;sup&gt;&lt;span&gt;[48]&lt;/span&gt;&lt;/sup&gt;&lt;/sup&gt;。主要有三个核心问题：1 该场景需要较好的消息特性支持，比如事务消息、延时消息。例如，用户通常是在提交订单后付款，如果提交订单后长时间不付款，该订单会被取消。这个场景就用到了延时消息的能力。而 Kafka 没有这方面消息特性的支持。2 微服务场景下对单条消息的质量要求非常高，如果有任何一条消息丢失，就意味着订单数据的丢失。这种情况是业务无法容忍的，而 Kafka 消息丢失的情况时有发生。Kafka 最初的设计是为了提高消息的吞吐量，采用了批量消息发送的方式，该方式不利于消息安全性。大数据场景对于单条消息丢失是可以容忍的，因为单条消息通常不会影响大数据分析的整体结论。3 当 Kafka 创建多个 Topic 时非常不稳定，严重影响整个系统的吞吐量。这与 Kafka 系统模型的设计有很大关系。&lt;/p&gt;&lt;p&gt;鉴于以上情况，阿里自主研发一款可以满足大规模微服务场景的消息队列产品，并命名为 RocketMQ。RocketMQ 可以简单理解为 Kafka 和 RabbitMQ 的合体版。RocketMQ 实现了事务消息、延时消息、死信队列等消息特性。为了保证高吞吐量，RocketMQ 整体上采用的 Kafka 的存储模型，也采用了顺序读写的方案。但是为了提高消息的质量，RocketMQ 并没有采用消息批量发送和接收的方式，而是单条发、单条收。另外为了解决 Kafka 模型在大量 Topic 场景下性能不稳定的问题，RocketMQ 改进了 Kafka 的数据存储机制。Kafka 的设计是每个 Topic 包括若干个 Partition，每个 Partition 同一时刻只会写一个存储文件。当存储文件写满后（例如 1G），再写下一个存储文件。Kafka 的存储目录如下图&lt;sup&gt;&lt;sup&gt;&lt;span&gt;[49]&lt;/span&gt;&lt;/sup&gt;&lt;/sup&gt;所示。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.7651515151515151&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/YriaiaJPb26VMyhzsVgnMFM4JN1Zh8ahP2LdeM5EYwqNB7qvSFszjf8vSGCzT02pXReAkJcDtT4x3ibs3yCoVtG2w/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1056&quot;/&gt;&lt;/p&gt;&lt;p&gt;这样的存储机制在 Topic 比较少的情况下并不会有问题，大数据场景下通常 Topic 不需要设置太多。而用在大规模微服务的场景下由于业务的需求，需要设置很多 Topic，通常几百甚至上千个。当 Kafka 设置了几百个 Topic 后，由于其特有的存储模型，每个 Broker 节点会创建数百个文件，而众多的文件在被读取时，部分数据会被加载到操作系统的 Page Cache 中，使用过多的 Page Cache 会令系统极其不稳定。这也是为什么 Kafka 在多 Topic 时，性能表现很差的原因。而 RocketMQ 对这一点进行了改进，RocketMQ 将同一个 Broker 所有的 Partition（RocketMQ 中称之为 Message Queue）中的数据存储到一个日志文件中。这样虽然读取时会稍显复杂，但是可以解决多 Topic 的性能问题。&lt;/p&gt;&lt;p&gt;由于解决了消息队列应用在大规模微服务场景的问题，RocketMQ 在开源后受到互联网公司的很大关注。2019 年 RocketMQ 年获得“中国最受欢迎开源软件”第一名 &lt;sup&gt;&lt;sup&gt;&lt;span&gt;[50]&lt;/span&gt;&lt;/sup&gt;&lt;/sup&gt;。在此之前，滴滴、微众银行、同程艺龙、快手等众多的互联网公司大数据分析场景和大规模微服务交互场景都使用了 Kafka，RocketMQ 开源之后，各大公司陆续将大规模微服务场景替换为 RocketMQ&lt;sup&gt;&lt;sup&gt;&lt;span&gt;[51]&lt;/span&gt;&lt;/sup&gt;&lt;/sup&gt;。下图是滴滴 RocketMQ 和 Kafka 在使用不同消息大小，在不同 Topic 数量下的对比测试&lt;sup&gt;&lt;sup&gt;&lt;span&gt;[52]&lt;/span&gt;&lt;/sup&gt;&lt;/sup&gt;。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.5972222222222222&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/YriaiaJPb26VMyhzsVgnMFM4JN1Zh8ahP2OPPyDQ1lH9mBuicIY3wvWZkUqlJicsa85KTCPr0by0HWsamcHic80Dic9g/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/p&gt;&lt;p&gt;从测试可见，最上面第一组数据，使用的是 Kafka 开启消费，每条消息大小为 2048 字节。Topic 数量不断增加，当到 256 Topic 之后，其吞吐急剧下降。第二组是 RocketMQ，Topic 增大影响非常小。第三组和第四组，是上面两组关闭了消费的情况，结论与上面两组基本类似，整体吞吐量会高一点点。&lt;/p&gt;&lt;section&gt;&lt;span&gt;从云计算到云原生&lt;/span&gt;
&lt;/section&gt;&lt;p&gt;互联网对人类的贡献当然不仅仅是信息的民主化，还为我们催生了云计算技术。2000 年美国知名在线购物平台 Amazon 推出了一项名为 Merchant.com 的电子商务服务&lt;sup&gt;&lt;sup&gt;&lt;span&gt;[53]&lt;/span&gt;&lt;/sup&gt;&lt;/sup&gt;，以帮助第三方商家在 Amazon 的电子商务引擎之上构建在线购物网站。为了 Merchant.com 项目的顺利推进，Andy Jassy 带人用 API 的方式完全重构了 Amazon 的内部系统，以保证内部团队和第三方商家都可以顺利的与 Amazon 的电商引擎集成。2003 年 Andy Jassy&lt;sup&gt;&lt;sup&gt;&lt;span&gt;[54]&lt;/span&gt;&lt;/sup&gt;&lt;/sup&gt;提出了打造互联网操作系统的构想，希望为更多公司提供在线的计算、存储等软件基础设施，帮助用户更简单的构建软件系统。2004 年 AWS 推出了第一个基础设施服务：简单队列服务（SQS）&lt;sup&gt;&lt;sup&gt;&lt;span&gt;[55]&lt;/span&gt;&lt;/sup&gt;&lt;/sup&gt;。2006 年陆续推出了 S3 和 EC2，至此 Amazon 的在线 Web 服务基本框架基本形成，也因此为全球创造了一个每年超过数千亿美金&lt;sup&gt;&lt;sup&gt;&lt;span&gt;[56]&lt;/span&gt;&lt;/sup&gt;&lt;/sup&gt;的超级大市场——云计算时代大幕被拉开。&lt;/p&gt;&lt;p&gt;云计算为需要构建软件系统的企业提供了非常好的体验，一方面 AWS 等云计算平台提供了虚拟计算机，用户在 AWS 平台上构建软件系统无需再购买计算机，只需租用 AWS 的虚拟计算机即可。另一方面，AWS 还提供了消息队列、数据库、存储等常用组件，使用户构建软件系统非常方便。2010 年之后，互联网公司飞速发展，云计算的需求也越来越强烈。所有的互联网公司都是软件公司，都有构建软件系统的需要。互联网公司要求响应性更高，而且更看重成本，云计算无疑是互联网公司最好的选择。这一点通过 AWS 的财报就可以看出，2006 年 AWS 营收只有 2100 万美金，随着互联网崛起以及全球企业数字化转型热情的高涨，AWS 营收一路飞涨。2021 年全球营收超过 1500 亿美金，Amazon 最高市值逼近 2 万亿美金。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.6279904306220095&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/YriaiaJPb26VMyhzsVgnMFM4JN1Zh8ahP2Z6gAqgy8BP4Yib03F6iakER9FR4dN7q1EjfL2ibZJRib4pQMvOxgxPkkZA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;836&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;NAVIGATING THE REVENUE STREAMS AND PROFIT POOLS OF AWS&lt;sup&gt;&lt;sup&gt;[&lt;/sup&gt;&lt;/sup&gt;&lt;sup&gt;&lt;sup&gt;57]&lt;/sup&gt;&lt;/sup&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;随着云计算在各个企业的深入落地，也暴露出许多问题，其中成本问题最为突出。很多互联网企业基于云厂商的云服务构建软件后发现，成本比之前买服务器还要高很多。采购服务器硬件只需要付费一次，而基于云服务构建需要按时间缴费。例如，市面上采购一个 8 核 16G 的硬件服务器，价格一般在 1.7 万元 &lt;sup&gt;&lt;sup&gt;&lt;span&gt;[58]&lt;/span&gt;&lt;/sup&gt;&lt;/sup&gt; 左右。而在某云计算机提供商购买 8 核 16G 的云服务器，每年租用的价格为 1.8 万元&lt;sup&gt;&lt;sup&gt;&lt;span&gt;[59]&lt;/span&gt;&lt;/sup&gt;&lt;/sup&gt;，与采购一台硬件服务器价格相当。为了解决使用云计算的成本问题，让企业能更好的享受到云计算的红利，云原生在这种背景下诞生了。云原生不仅仅是一类技术，更是一种理念，希望企业用云计算原生的方式去构建软件系统。什么是云计算原生的方式，首先应用是弹性的，按需运行的。按照云计算的愿景，基于云构建的软件应该是有需要才会运行。比如一个网站，没有用户访问时最好不运行，访问的用户多了可以启动更大的集群支撑海量用户访问。由于虚拟机是按量付费，如果基于虚拟机构建的网站在没有访问的时候也运行，一样是需要付费的。所以对于企业来讲，最好的方式是有一类技术，让其构建出按照访问情况运行的软件。Serverless 就是这样的技术，Serverless 为企业用户提供了一种原生使用云计算的关键能力，即只有在需要的时候软件才会运行。&lt;/p&gt;&lt;p&gt;Serverless 一词是 2012 年由 Iron 公司提出 &lt;sup&gt;&lt;sup&gt;&lt;span&gt;[60]&lt;/span&gt;&lt;/sup&gt;&lt;/sup&gt;，如同云计算一样，Serverless 形态的产品其实早已经存在。2008 年谷歌就推出了 Serverless 形态产品 Google App engine&lt;sup&gt;&lt;sup&gt;&lt;span&gt;[61]&lt;/span&gt;&lt;/sup&gt;&lt;/sup&gt;。正如前文所说，任何一个技术并不是在它发明的时候被人关注，而是需要的时候。微服务如此，Serverless 同样如此。2014 年 AWS 推出 Serverless 产品 Lamdba 后，由于使用云计算的互联网企业降本诉求强烈，Lamdba 被越来越多的企业所采用。之后 Azure、GCP 等主流云计算提供商也陆续推出相应的 Serverless 产品。曾经成功预测云计算时代的伯克利大学 2019 年再次撰写《Cloud Programming Simplified: A Berkeley View on Serverless Computing》&lt;sup&gt;&lt;sup&gt;&lt;span&gt;[62]&lt;/span&gt;&lt;/sup&gt;&lt;/sup&gt; 一文，预测 Serverless 是云计算下一个十年的发展方向。论文里也给出了关于 Serverless 的定义，简单来讲就是 Serverless Computing，由 FaaS + BaaS（Backend as a Service）构成一个 Serverless 软件架构。特点就是能够按需弹性、按需付费。2020 年 AWS 有一半的用户采用了 Lamdba 构建其业务系统。根据 Datadog 的调查报告，2021 年 Lamdba 被调用的次数相比两年前增长了 350%。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.53&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/YriaiaJPb26VMyhzsVgnMFM4JN1Zh8ahP2LsEah4jAw5kXM3picQ9DZpQGD4oDWkbF4c3vyibO5UtxTLdjPTnaj9Ng/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1200&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;Serverless 时代&lt;/span&gt;
&lt;/section&gt;&lt;p&gt;虽然 Serverless 已经走过了漫长的道路，但这仅仅是开始。Serverless 颠覆性的运行模式，使软件的架构发生了极大的变化，这也给软件系统的构建带来了非常大的机遇与挑战。Serverless 因为其按需运行的特性非常好的履行了云计算的承诺，也契合了用户将本增效的本质需求，注定会成为云计算下一个十年的主角。一个全新的时代呼之欲出，让我们一起看一下这个新的时代可能的一些变化。&lt;/p&gt;&lt;section&gt;&lt;span&gt;1  EDA 将会替代 SOA 成为未来软件架构的典型范式&lt;/span&gt;
&lt;/section&gt;&lt;p&gt;Event Driven Architecture（EDA）&lt;sup&gt;&lt;sup&gt;&lt;span&gt;[63]&lt;/span&gt;&lt;/sup&gt;&lt;/sup&gt;并不是一种新的技术，但正如前文所言，任何一个技术并不是它发明的时候被人关注，而是需要的时候。没有任何时代像 Serverless 时代一样需要 EDA 技术。因为 Serverless 特有的按需运行的特性，通过 EDA 的方式触发 Serverless 程序将成为最流行的模式。在软件架构演进的历史中基于 Service-oriented architecture（SOA）&lt;sup&gt;&lt;sup&gt;&lt;span&gt;[64]&lt;/span&gt;&lt;/sup&gt;&lt;/sup&gt;的设计模式一直是主角，而 RPC 一直是 SOA 架构软件的默认模式，所以过去程序之间的绝大部分通信方式是同步通信。而 Serverless 的出现使得异步通信方式或许会成为主角。下图源自 2022 年是 Datadog 的 Serverless report&lt;sup&gt;&lt;sup&gt;&lt;span&gt;[65]&lt;/span&gt;&lt;/sup&gt;&lt;/sup&gt; 。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.59375&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/YriaiaJPb26VMyhzsVgnMFM4JN1Zh8ahP2CuwpJluibZgLYaT2BXJhZwWicJOuduhNuV5cbOCH6UR7uXCUBaoiaWtRg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;排名前四的 Lamdba 触发方式中，除了 API GATEWAY，SQS、EVENTBRIDGE、SNS 都采用了异步的方式。可以预见，未来消息系统将是 Serverless 最主要的触发源，企业通过事件驱动的形式构建软件系统将成为新常态。&lt;/p&gt;&lt;section&gt;&lt;span&gt;2 Serverless 将通过事件驱动的方式连接云中的一切。&lt;/span&gt;
&lt;/section&gt;&lt;p&gt;RPC 这种同步通信模式和消息的异步通信模式非常不同，程序通过 RPC 方式通信如同打电话，需要双向通信。一方发起请求后，对方必须响应，如果不响应通信就会失败。而且同一时间程序只能响应一个 RPC，其他程序只能占线。而异步通信更像在 Facebook 中发一条消息给对方，对方是否在线不影响通信，而且可以同时与多人通信。Serverless 因为采用异步方式通信带来一个巨大的收益，软件集成的成本被大大降低。之前基于 SOA 的软件设计理念，一个系统中所包含的微服务最多在百量级。过多的服务会令系统非常复杂，可用性急剧下降。而通过事件驱动构建的系统可以容纳成千上万的 Serverless 程序，而且受地域的影响比较小。因为过去服务之间基于 RPC 通信，如果两个服务跨云或者跨数据中心有可能因为超时、网络故障等原因导致通信失败，而异步通信这种情况大大降低。&lt;/p&gt;&lt;p&gt;由于异步通信的优势，使得跨云、跨地域基于 Serverless 构建大规模的业务系统成为可能。这将为未来数字化企业构建大规模人工智能、物联网、自动驾驶等系统打开了更多的可能性。比如，未来物联网系统一定是跨云、边、端共同构建，云端负责大数据分析，边缘端负责数据汇聚与实时分析，终端负责数据上报以及命令执行。同时，这种通信方式给企业构建业务系统带来了更多的可能性。过去用户业务系统基本在一个云上构建，但基于多云构建的业务系统会让用户避免厂商锁定、成本更低、竞争力更强。想象这样一种场景，用户需要基于 Serverless 构建一个图像处理的场景。AWS S3 存储图片非常方便，而且成本低，但是谷歌云的图像处理服务精度更高、速度更快。这种情况下最好的解决方案是通过事件驱动的方式跨云构建图像处理通信。图像存储到 AWS 的 S3，每当图像被存储后通过事件的方式触发谷歌云的 Serverless 程序调用图像服务完成图像处理。&lt;/p&gt;&lt;section&gt;&lt;span&gt;3 CloudEvents 将成为未来应用通信新的事实标准。&lt;/span&gt;
&lt;/section&gt;&lt;p&gt;新的时代需要新的标准，Serverless 时代用户构建的业务系统特点是规模更大、跨范围更广、服务更加多元。前两个特点上文已经解释。对传统的 SOA 架构的系统，主要有若干的用户开发的服务构成，构成相对单一。而 Serverless 时代的业务系统包括大量 Serverless 服务，众多数量的云服务（可能来自不同的云计算提供商）、甚至还可能有物联网设备。大量的跨多云异构系统之间需要频繁的通信，这需要统一的数据标准。而从目前来看，CloudEvents 无疑是最好的选择。CloudEvents 是 CNCF 发起的旨在帮助云提供商之间的函数可移植性和事件流处理的互操作性而制定的标准。它天生具有对 Serverless 非常好的亲和性，而且得到了 Knative、OpenFaaS、Serverless.com&lt;sup&gt;&lt;sup&gt;&lt;span&gt;[66]&lt;/span&gt;&lt;/sup&gt;&lt;/sup&gt;、IBM Cloud Code Engine 等众多 Serverless 产品的支持。目前，市场上并没有一款能够完全支持 CloudEvents 协议的消息产品出现。&lt;/p&gt;&lt;p&gt;在 Serverless 时代基于 EDA 构建软件系统，消息系统无疑会成为最核心的基础组件。但是目前的 MQ 在 Serverless 场景下支持事件收发挑战巨大。目前主流的 MQ 大都是在 2010 年左右诞生，当时主要是为了解决大数据和大规模微服务的场景而研发，当时它们对于 Serverless 几乎一无所知。所以站在 Serverless 的视角审视，目前主流 MQ 的架构设计支持基于 Serverless 构建的应用软件会碰到非常多的问题。&lt;/p&gt;&lt;p&gt;主要表现在四方面：第一个问题是传统 MQ 无法直接触发 Lamdba 等 Serverless 产品运行。核心原因是目前 MQ 的消费者与服务直接通信基本都是基于 TCP 协议，无论是 Kafka、RabbitMQ。TCP 是面向连接的协议，通信之前双方需要建立一个 connection，而且需要一直维护这条 connection。而 Serverless 需要面向无连接的通信模型，因为 serverless 有一个非常关键的特性是按需运行，因而无法使用 TCP 通信。所以现在业界主流的 Cloud Function，例如 AWS Lambda、Knative、OpenFaaS 等都是采用 Http 协议进行通信。而且，目前的消息队列大多数采用 Pull 的消费模型，而目前的主流队列都是采用 Push 模型。Gartner 在 2020 年关于如何选择合适的 Event Broker 的报告中也很有预见性的指出了这个问题&lt;sup&gt;&lt;sup&gt;&lt;span&gt;[67]&lt;/span&gt;&lt;/sup&gt;&lt;/sup&gt;。&lt;/p&gt;&lt;p&gt;第二个问题是目前消息系统极大的限制了 Serverless 应用的弹性能力。以 Kafka 为例，按照其存储模型，每个 topic 分成若干个 partition。因为每个 partition 只能有一个消费者消费消息，这意味着 kafka 下游系统消费单个 topic 的集群规模不能大于该 topic partition 数量。这在传统的大数据场景中并没有问题。但是如果 kafka 下游是应用是 serverless 集群，问题比较严重。因为即使 serverless 按照扩缩策略弹出很多消费者实例，但是多于 Partition 的消费者只能空闲无法消费数据 &lt;sup&gt;&lt;sup&gt;&lt;span&gt;[68]&lt;/span&gt;&lt;/sup&gt;&lt;/sup&gt;。当然开发者可以选择手动修改扩大 partition 的数量，但是这无法响应快速变化的业务。而且当一段时间消费者集群收缩后，过多的 Partition 对系统资源也是很大是浪费。&lt;/p&gt;&lt;p&gt;第三个问题是 Serverless 需要处理大量的云事件，在传输的过程中可能需要对这些事件进行过滤、转换等处理，而目前主流消息队列处理能力比较弱。Kafka 本身没有事件处理能力，其消息过滤能力是通过 KSQL 提供的，RabbitMQ、ActiveMQ 等就没有提供消息处理的能力。&lt;/p&gt;&lt;p&gt;第四个问题目前主流的消息队列在提供负载均衡时大多采用了 Reblance 的机制，每当有使用消息队列的消费者加入到集群或者从集群离开时，都会触发消息队列 Reblance。该机制会触发消费集群所有的客户端重新负载均衡。在 Serverless 场景下，由于系统需要频繁切换启动、停止等动作。这会频繁触发系统的 Reblance，这种情况会给系统带来非常大的开销。&lt;/p&gt;&lt;section&gt;如果想更好的支持 Serverless 场景，从上面分析看，未来的消息系统需要应该具备以下的特点：&lt;/section&gt;&lt;section&gt;&lt;strong&gt;· &lt;/strong&gt;原生支持 HTTP 协议，消息的接收采用 push 模式，push 模式可以直接将消息推送给 Serverless 系统完成事件的触发。&lt;/section&gt;&lt;section&gt;&lt;strong&gt;· &lt;/strong&gt;原生支持 CloudEvents&lt;sup&gt;&lt;sup&gt;&lt;span&gt;[69]&lt;/span&gt;&lt;/sup&gt;&lt;/sup&gt; 标准事件发送，CloudEvents 是云原生时代全新的事件交互标准，目前得到了诸如 Knative、OpenFaaS 等主流开源 Serverless 平台支持。&lt;/section&gt;&lt;section&gt;&lt;strong&gt;·&lt;/strong&gt; 原生支持 CloudEvents 标准可以将事件直接投递给 Serverless 平台，更方便。&lt;/section&gt;&lt;section&gt;&lt;strong&gt;·&lt;/strong&gt; 提供过滤、转化等更加丰富的事件处理能力。解决当前消息队列的 Reblance 问题。原生基于新的云原生基础设施 Kubertenes 设计，具备自动弹性扩缩的能力。&lt;/section&gt;&lt;section&gt;目前能很好支持 Serverless 场景的消息产品比较少，AWS、Azure 等云计算厂商提供 EventBridge 或许是一个选择，EventBridge 提供了 push 事件的能力可以直接触发 Serverless 程序，而且提供一定的事件过滤等能力。但是云厂商提供的 EventBridge 存在的普遍问题是让自己公司的云产品可以较好的完成事件交互，而对其他公司提供的云产品以及开源产品支持的能力较弱。这导致的结果是企业采用了 EventBrigde 本来是想完成应用之间消息的互通，但却被困在 EventBrigde 中。历史总是惊人的相似，这与 AMQP 协议出现之前的场景非常类似。当然有需求才会催生新的产品和技术，下面是几款近两年诞生的，比较适用于 serverless 场景的消息队列，供读者参考。&lt;/section&gt;&lt;section&gt;&lt;span&gt;Serverless 时代的 MQ&lt;/span&gt;
&lt;/section&gt;&lt;section&gt;&lt;span&gt;1  Vanus   vanus.ai&lt;/span&gt;
&lt;/section&gt;&lt;p&gt;Vanus(vanus.ai) 是一个开源的无服务器事件流平台，具有内置的事件处理功能。它可以连接云函数、 SaaS、云服务和数据库，帮助用户构建下一代事件驱动的应用程序。Vanus 将存储和计算资源分离，原生支持 CloudEvents 标准。同时其通过内置函数的方式提供了通用、灵活的过滤和转换能力，可以帮助开发者无代码做事件处理。&lt;/p&gt;&lt;p&gt;Vanus 原生基于 Kubertenes 设计，具备完全的弹性能力。可以根据事件流量自动扩展或缩减集群。Vanus 非常轻量，可以 1 键部署，几十秒可以完成安装。而且其无缝集成了 Serverless，可以将事件无缝的投递给 AWS Lambda、Knative 等云函数与 FaaS 平台。&lt;/p&gt;&lt;section&gt;&lt;span&gt;2 Redpanda  redpanda.com&lt;/span&gt;
&lt;/section&gt;&lt;p&gt;Redpanda 是一个开源分布式事件流平台，可用作高性能消息队列。Redpanda 做了原生兼容 Kafka 的设计，而且提供了多项改进，例如更快的性能、更低的延迟和更好的可扩展性。&lt;/p&gt;&lt;p&gt;Redpanda 消息队列允许多个生产者将消息写入单个主题，多个消费者并行读取来自该主题的消息。消息可以缓冲在内存中以实现快速传递，也可以持久保存到磁盘以实现持久性。Redpanda 还提供许多功能，例如复制、分区和压缩，以帮助管理大量数据。使用 Redpanda 消息队列的主要好处之一是它能够实时处理大量数据。这使其成为需要高吞吐量和低延迟的应用程序的热门选择，例如流分析、实时监控和在线游戏。&lt;/p&gt;&lt;section&gt;&lt;span&gt;3 KubeMQ   kubemq.io&lt;/span&gt;
&lt;/section&gt;&lt;p&gt;KubeMQ 也是一个 Kubernetes 原生消息队列和消息系统，为分布式应用程序提供可靠、可扩展和高性能的消息基础设施。它旨在易于在 Kubernetes 环境中部署、操作和使用。&lt;/p&gt;&lt;p&gt;KubeMQ 构建为一组微服务，可以作为容器部署在 Kubernetes 集群上。它包括消息队列、发布 / 订阅消息传递、请求 / 回复消息传递和事件驱动的消息传递等功能。KubeMQ 的主要优势之一是它被设计为具有高可用性和容错性。它包括自动分片、数据复制以及数据备份和恢复等功能，这些功能有助于确保即使在节点故障或网络中断的情况下也能可靠地传递消息。&lt;/p&gt;&lt;section&gt;&lt;span&gt;4 memphis  memphis.dev&lt;/span&gt;
&lt;/section&gt;&lt;p&gt;Memphis 是一个开源的云原生消息队列和流媒体平台。它旨在为分布式应用程序提供可靠且可扩展的消息传递基础架构。Memphis 可以部署在 Kubernetes 上，它支持多种消息模式，包括发布 / 订阅、请求 / 回复和流处理。&lt;/p&gt;&lt;p&gt;Memphis 使用 Rust 构建，Rust 以其性能、可靠性和安全性著称。该平台使用分布式架构，允许水平扩展和高可用性。它还包括消息持久化、消息过滤和消息批处理等功能，有助于确保可靠地传递和处理消息。&lt;/p&gt;&lt;p&gt;Memphis 的主要优点之一是它的简单性和易用性。它提供了一个简单直观的 API，可以与多种编程语言一起使用，包括 Rust、Python 和 Java。此外，它还包括一个基于 Web 的管理控制台，允许用户监控消息流量、查看统计数据和管理消息传递基础结构。&lt;/p&gt;&lt;section&gt;&lt;section&gt;&lt;span/&gt;
作者简介&lt;/section&gt;&lt;p&gt;&lt;strong&gt;厉启鹏&lt;/strong&gt;，vanus.ai CEO，开源爱好者，北京大学硕士。曾就职于阿里云，Apache RocketMQ PMC , 长期专注于云基础设施及中间件架构设计与研发。&lt;/p&gt;&lt;/section&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;参考文献&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>82a4c688a2977cebf368672d518f1dc8</guid>
<title>这 25 个 Pandas 高频实用技巧，不得不服！</title>
<link>https://toutiao.io/k/fgs48bk</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;首先我们需要先提前下载好&lt;code&gt;示例数据集&lt;/code&gt;：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;drinksbycountry.csv : http://bit.ly/drinksbycountry&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;imdbratings.csv : http://bit.ly/imdbratings&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;chiporders.csv : http://bit.ly/chiporders&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;smallstockers.csv : http://bit.ly/smallstocks&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;kaggletrain.csv : http://bit.ly/kaggletrain&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;uforeports.csv : http://bit.ly/uforeports&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;导入案例数据集&lt;/span&gt;&lt;/h2&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;import&lt;/span&gt; pandas &lt;span&gt;as&lt;/span&gt; pd&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; numpy &lt;span&gt;as&lt;/span&gt; np&lt;br/&gt;&lt;br/&gt;drinks = pd.read_csv(&lt;span&gt;&#x27;http://bit.ly/drinksbycountry&#x27;&lt;/span&gt;)&lt;br/&gt;movies = pd.read_csv(&lt;span&gt;&#x27;http://bit.ly/imdbratings&#x27;&lt;/span&gt;)&lt;br/&gt;orders = pd.read_csv(&lt;span&gt;&#x27;http://bit.ly/chiporders&#x27;&lt;/span&gt;, sep=&lt;span&gt;&#x27;\t&#x27;&lt;/span&gt;)&lt;br/&gt;orders[&lt;span&gt;&#x27;item_price&#x27;&lt;/span&gt;] = orders.item_price.str.replace(&lt;span&gt;&#x27;$&#x27;&lt;/span&gt;, &lt;span&gt;&#x27;&#x27;&lt;/span&gt;).astype(&lt;span&gt;&#x27;float&#x27;&lt;/span&gt;)&lt;br/&gt;stocks = pd.read_csv(&lt;span&gt;&#x27;http://bit.ly/smallstocks&#x27;&lt;/span&gt;, parse_dates=[&lt;span&gt;&#x27;Date&#x27;&lt;/span&gt;])&lt;br/&gt;titanic = pd.read_csv(&lt;span&gt;&#x27;http://bit.ly/kaggletrain&#x27;&lt;/span&gt;)&lt;br/&gt;ufo = pd.read_csv(&lt;span&gt;&#x27;http://bit.ly/uforeports&#x27;&lt;/span&gt;, parse_dates=[&lt;span&gt;&#x27;Time&#x27;&lt;/span&gt;])&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;1显示已安装的版本&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;有时你需要知道正在使用的pandas版本，特别是在阅读pandas文档时。你可以通过输入以下命令来显示pandas版本:&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;pd.__version__&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&#x27;0.25.8&#x27;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果你还想知道pandas所依赖的模块的版本，你可以使用&lt;code&gt;show_versions()&lt;/code&gt;函数:&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;pd.show_versions()&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;INSTALLED VERSIONS&lt;br/&gt;------------------&lt;br/&gt;commit: None&lt;br/&gt;python: 3.7.3.final.0&lt;br/&gt;python-bits: 64&lt;br/&gt;OS: Darwin&lt;br/&gt;OS-release: 18.6.0&lt;br/&gt;machine: x86_64&lt;br/&gt;processor: i386&lt;br/&gt;byteorder: little&lt;br/&gt;LC_ALL: None&lt;br/&gt;LANG: en_US.UTF-8&lt;br/&gt;LOCALE: en_US.UTF-8&lt;br/&gt;&lt;br/&gt;pandas: 0.24.2&lt;br/&gt;pytest: None&lt;br/&gt;pip: 19.1.1&lt;br/&gt;setuptools: 41.0.1&lt;br/&gt;Cython: None&lt;br/&gt;numpy: 1.16.4&lt;br/&gt;scipy: None&lt;br/&gt;pyarrow: None&lt;br/&gt;xarray: None&lt;br/&gt;IPython: 7.5.0&lt;br/&gt;sphinx: None&lt;br/&gt;patsy: None&lt;br/&gt;dateutil: 2.8.0&lt;br/&gt;pytz: 2019.1&lt;br/&gt;blosc: None&lt;br/&gt;bottleneck: None&lt;br/&gt;tables: None&lt;br/&gt;numexpr: None&lt;br/&gt;feather: None&lt;br/&gt;matplotlib: 3.1.0&lt;br/&gt;openpyxl: None&lt;br/&gt;xlrd: None&lt;br/&gt;xlwt: None&lt;br/&gt;xlsxwriter: None&lt;br/&gt;lxml.etree: None&lt;br/&gt;bs4: None&lt;br/&gt;html5lib: None&lt;br/&gt;sqlalchemy: None&lt;br/&gt;pymysql: None&lt;br/&gt;psycopg2: None&lt;br/&gt;jinja2: 2.10.1&lt;br/&gt;s3fs: None&lt;br/&gt;fastparquet: None&lt;br/&gt;pandas_gbq: None&lt;br/&gt;pandas_datareader: None&lt;br/&gt;gcsfs: None&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;你可以查看到Python，pandas, Numpy, matplotlib等的版本信息。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;&lt;strong&gt;2创建示例DataFrame&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;假设你需要创建一个示例DataFrame。有很多种实现的途径，我最喜欢的方式是传一个字典给DataFrame constructor，其中字典中的keys为列名，values为列的取值。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;df = pd.DataFrame({&lt;span&gt;&#x27;col one&#x27;&lt;/span&gt;:[&lt;span&gt;100&lt;/span&gt;, &lt;span&gt;200&lt;/span&gt;], &lt;span&gt;&#x27;col two&#x27;&lt;/span&gt;:[&lt;span&gt;300&lt;/span&gt;, &lt;span&gt;400&lt;/span&gt;]})&lt;br/&gt;df&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.29354838709677417&quot; data-type=&quot;png&quot; data-w=&quot;620&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/hN1l83J6PhibibyviaTndatOurjRCHGfW6puYzfmf01mHiaBPnbjME0YyRdYcxqYaQREeib5M6ia15iasE5SX8Uh0vPhA/640?wx_fmt=png&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果你需要更大的DataFrame，上述方法将需要太多的输入。在这种情况下，你可以使用NumPy的 &lt;code&gt;random.rand()&lt;/code&gt;函数，定义好该函数的行数和列数，并将其传递给DataFrame构造器:&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;pd.DataFrame(np.random.rand(&lt;span&gt;4&lt;/span&gt;, &lt;span&gt;8&lt;/span&gt;))&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.25&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;1056&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/hN1l83J6PhibibyviaTndatOurjRCHGfW6pGnucyvZVhIcWFflics2ZMtL5RwkCzYT6JuicQlLcuic7hKib2pHtAT5jicw/640?wx_fmt=png&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这种方式很好，但如果你还想把列名变为非数值型的，你可以强制地将一串字符赋值给columns参数：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;pd.DataFrame(np.random.rand(&lt;span&gt;4&lt;/span&gt;, &lt;span&gt;8&lt;/span&gt;), columns=list(&lt;span&gt;&#x27;abcdefgh&#x27;&lt;/span&gt;))&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.2708333333333333&quot; data-type=&quot;png&quot; data-w=&quot;1056&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/hN1l83J6PhibibyviaTndatOurjRCHGfW6pic63dryKJyaKTUFhP9Qic3P7s3ZXy5ibW71gPiby7dgjyTzJvGxfAeN3Fg/640?wx_fmt=png&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;你可以想到，你传递的字符串的长度必须与列数相同。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;3更改列名&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们来看一下刚才我们创建的示例DataFrame:&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;df&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.29354838709677417&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/hN1l83J6PhibibyviaTndatOurjRCHGfW6pWsNjIsH5uAPpX5RDIUQ27OBxNPrKun75ZnOsgkcChzZwAiao2FIIu3A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;620&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我更喜欢在选取pandas列的时候使用点（.），但是这对那么列名中含有空格的列不会生效。让我们来修复这个问题。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;更改列名最灵活的方式是使用&lt;code&gt;rename()&lt;/code&gt;函数。你可以传递一个字典，其中keys为原列名，values为新列名，还可以指定axis:&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;df = df.rename({&lt;span&gt;&#x27;col one&#x27;&lt;/span&gt;:&lt;span&gt;&#x27;col_one&#x27;&lt;/span&gt;,&lt;br/&gt;                &lt;span&gt;&#x27;col two&#x27;&lt;/span&gt;:&lt;span&gt;&#x27;col_two&#x27;&lt;/span&gt;},&lt;br/&gt;                axis=&lt;span&gt;&#x27;columns&#x27;&lt;/span&gt;)&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;使用这个函数最好的方式是你需要更改任意数量的列名，不管是一列或者全部的列。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果你需要一次性重新命令所有的列名，更简单的方式就是重写DataFrame的&lt;code&gt;columns&lt;/code&gt;属性：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;df.columns = [&lt;span&gt;&#x27;col_one&#x27;&lt;/span&gt;, &lt;span&gt;&#x27;col_two&#x27;&lt;/span&gt;]&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果你需要做的仅仅是将空格换成下划线，那么更好的办法是用&lt;code&gt;str.replace()&lt;/code&gt;方法，这是因为你都不需要输入所有的列名：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;df.columns = df.columns.str.replace(&lt;span&gt;&#x27; &#x27;&lt;/span&gt;, &lt;span&gt;&#x27;_&#x27;&lt;/span&gt;)&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上述三个函数的结果都一样，可以更改列名使得列名中不含有空格：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;df&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.3122923588039867&quot; data-type=&quot;png&quot; data-w=&quot;602&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/hN1l83J6PhibibyviaTndatOurjRCHGfW6peVqbEyuSMFRMJxRsjQ1ovhYL89kSu0Ks5FjCyAFRbSO8YkDO5TxdBg/640?wx_fmt=png&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;最后，如果你需要在列名中添加前缀或者后缀，你可以使用&lt;code&gt;add_prefix()&lt;/code&gt;函数：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;df.add_prefix(&lt;span&gt;&#x27;X_&#x27;&lt;/span&gt;)&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.27927927927927926&quot; data-type=&quot;png&quot; data-w=&quot;666&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/hN1l83J6PhibibyviaTndatOurjRCHGfW6pXibUgzaXuxfzL0rSq2miarrg5XosBOMzVJBHiacv2d72lNLVtgv1z5fBA/640?wx_fmt=png&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;或者使用&lt;code&gt;add_suffix()&lt;/code&gt;函数：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;df.add_suffix(&lt;span&gt;&#x27;_Y&#x27;&lt;/span&gt;)&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.2786377708978328&quot; data-type=&quot;png&quot; data-w=&quot;646&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/hN1l83J6PhibibyviaTndatOurjRCHGfW6pvUAvj8wdvOrPribIN6AJf1f802lJ93HDkyWAqUs6zTsKXGd24E4ziaCw/640?wx_fmt=png&quot;/&gt;&lt;/figure&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;4. 行序反转&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们来看一下drinks这个DataFame:&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;drinks.head()&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.266025641025641&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;1248&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/hN1l83J6PhibibyviaTndatOurjRCHGfW6pUDC9kJtIXpwaEELOkye7d96Tc2PNC612iar8Aftb6icchwuJyG2xA1VA/640?wx_fmt=png&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;该数据集描述了每个国家的平均酒消费量。如果你想要将行序反转呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;最直接的办法是使用&lt;code&gt;loc&lt;/code&gt;函数并传递&lt;code&gt;::-1&lt;/code&gt;，跟Python中列表反转时使用的切片符号一致：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;drinks.loc[::&lt;span&gt;-1&lt;/span&gt;].head()&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.2550231839258114&quot; data-type=&quot;png&quot; data-w=&quot;1294&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/hN1l83J6PhibibyviaTndatOurjRCHGfW6p82tDHs5icyGRibGlVrF4VuNMJFHEkFUrpRxxbQ9iaenztGFibtHLRuEqYw/640?wx_fmt=png&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果你还想重置索引使得它从0开始呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;你可以使用&lt;code&gt;reset_index()&lt;/code&gt;函数，告诉他去掉完全抛弃之前的索引：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;drinks.loc[::&lt;span&gt;-1&lt;/span&gt;].reset_index(drop=&lt;span&gt;True&lt;/span&gt;).head()&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.2611111111111111&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/hN1l83J6PhibibyviaTndatOurjRCHGfW6pgKGlSW3zbrcBwiajicLOrVic6m0cU7J3nhGfVQXDXQCoKbqBiaHucfzqGQ/640?wx_fmt=png&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;你可以看到，行序已经反转，索引也被重置为默认的整数序号。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;5. 列序反转&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;跟之前的技巧一样，你也可以使用&lt;code&gt;loc&lt;/code&gt;函数将列从左至右反转&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;drinks.loc[:, ::&lt;span&gt;-1&lt;/span&gt;].head()&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.26136363636363635&quot; data-type=&quot;png&quot; data-w=&quot;1232&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/hN1l83J6PhibibyviaTndatOurjRCHGfW6p9RM9uCELJBRrvOXnrjnglVVUHhGhyjN12voFpdwUnCghkKfd61FJ0Q/640?wx_fmt=png&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;逗号之前的冒号表示选择所有行，逗号之后的&lt;code&gt;::-1&lt;/code&gt;表示反转所有的列，这就是为什么country这一列现在在最右边。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;6. 通过数据类型选择列&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里有drinks这个DataFrame的数据类型：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;drinks.dtypes&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;country                          object&lt;br/&gt;beer_servings                     int64&lt;br/&gt;spirit_servings                   int64&lt;br/&gt;wine_servings                     int64&lt;br/&gt;total_litres_of_pure_alcohol    float64&lt;br/&gt;continent                        object&lt;br/&gt;dtype: object&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;假设你仅仅需要选取数值型的列，那么你可以使用&lt;code&gt;select_dtypes()&lt;/code&gt;函数：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;drinks.select_dtypes(include=&lt;span&gt;&#x27;number&#x27;&lt;/span&gt;).head()&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.3465553235908142&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/hN1l83J6PhibibyviaTndatOurjRCHGfW6pjYwJMr3BlIrgGqGqTs1SE11MF9xChMLBYxIIibB9XHgpCmw5XPeYlrA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;958&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这包含了int和float型的列。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;你也可以使用这个函数来选取数据类型为object的列：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;drinks.select_dtypes(include=&lt;span&gt;&#x27;object&#x27;&lt;/span&gt;).head()&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5014836795252225&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/hN1l83J6PhibibyviaTndatOurjRCHGfW6pHibu9q3qA1NHpovn3Fe05Xce39UIWSxkZYzFQd1oLClP5VjC33tXR3A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;674&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;你还可以选取多种数据类型，只需要传递一个列表即可：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;drinks.select_dtypes(include=[&lt;span&gt;&#x27;number&#x27;&lt;/span&gt;, &lt;span&gt;&#x27;object&#x27;&lt;/span&gt;, &lt;span&gt;&#x27;category&#x27;&lt;/span&gt;, &lt;span&gt;&#x27;datetime&#x27;&lt;/span&gt;]).head()&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.2601851851851852&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/hN1l83J6PhibibyviaTndatOurjRCHGfW6pq2CuicdG25EGuJzzNFmibrribgdvCRTGTZhQicupC947SgLQ5sBg5FrWnQ/640?wx_fmt=png&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;你还可以用来排除特定的数据类型：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;drinks.select_dtypes(exclude=&lt;span&gt;&#x27;number&#x27;&lt;/span&gt;).head()&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5014836795252225&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/hN1l83J6PhibibyviaTndatOurjRCHGfW6pHibu9q3qA1NHpovn3Fe05Xce39UIWSxkZYzFQd1oLClP5VjC33tXR3A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;674&quot;/&gt;&lt;/figure&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;7. 将字符型转换为数值型&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们来创建另一个示例DataFrame:&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;df = pd.DataFrame({&lt;span&gt;&#x27;col_one&#x27;&lt;/span&gt;:[&lt;span&gt;&#x27;1.1&#x27;&lt;/span&gt;, &lt;span&gt;&#x27;2.2&#x27;&lt;/span&gt;, &lt;span&gt;&#x27;3.3&#x27;&lt;/span&gt;],&lt;br/&gt;                   &lt;span&gt;&#x27;col_two&#x27;&lt;/span&gt;:[&lt;span&gt;&#x27;4.4&#x27;&lt;/span&gt;, &lt;span&gt;&#x27;5.5&#x27;&lt;/span&gt;, &lt;span&gt;&#x27;6.6&#x27;&lt;/span&gt;],&lt;br/&gt;                   &lt;span&gt;&#x27;col_three&#x27;&lt;/span&gt;:[&lt;span&gt;&#x27;7.7&#x27;&lt;/span&gt;, &lt;span&gt;&#x27;8.8&#x27;&lt;/span&gt;, &lt;span&gt;&#x27;-&#x27;&lt;/span&gt;]})&lt;br/&gt;df&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.37&quot; data-type=&quot;png&quot; data-w=&quot;600&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/hN1l83J6PhibibyviaTndatOurjRCHGfW6pTk0R7zoU0mgC8VUibLwv9H8CQ8maKztfOYFaTleib78IBSTRyqibzUcEA/640?wx_fmt=png&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这些数字实际上储存为字符型，导致其数据类型为object:&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;df.dtypes&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;col_one      object&lt;br/&gt;col_two      object&lt;br/&gt;col_three    object&lt;br/&gt;dtype: object&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;为了对这些列进行数学运算，我们需要将数据类型转换成数值型。你可以对前两列使用&lt;code&gt;astype()&lt;/code&gt;函数：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;df.astype({&lt;span&gt;&#x27;col_one&#x27;&lt;/span&gt;:&lt;span&gt;&#x27;float&#x27;&lt;/span&gt;, &lt;span&gt;&#x27;col_two&#x27;&lt;/span&gt;:&lt;span&gt;&#x27;float&#x27;&lt;/span&gt;}).dtypes&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;col_one      float64&lt;br/&gt;col_two      float64&lt;br/&gt;col_three     object&lt;br/&gt;dtype: object&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但是，如果你对第三列也使用这个函数，将会引起错误，这是因为这一列包含了破折号（用来表示0）但是pandas并不知道如何处理它。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;你可以对第三列使用&lt;code&gt;to_numeric()&lt;/code&gt;函数，告诉其将任何无效数据转换为&lt;code&gt;NaN&lt;/code&gt;:&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;pd.to_numeric(df.col_three, errors=&lt;span&gt;&#x27;coerce&#x27;&lt;/span&gt;)&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;0    7.7&lt;br/&gt;1    8.8&lt;br/&gt;2    NaN&lt;br/&gt;Name: col_three, dtype: float64&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果你知道&lt;code&gt;NaN&lt;/code&gt;值代表0，那么你可以&lt;code&gt;fillna()&lt;/code&gt;函数将他们替换成0：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;pd.to_numeric(df.col_three, errors=&lt;span&gt;&#x27;coerce&#x27;&lt;/span&gt;).fillna(&lt;span&gt;0&lt;/span&gt;)&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;0    7.7&lt;br/&gt;1    8.8&lt;br/&gt;2    0.0&lt;br/&gt;Name: col_three, dtype: float64&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;最后，你可以通过&lt;code&gt;apply()&lt;/code&gt;函数一次性对整个DataFrame使用这个函数：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;df = df.apply(pd.to_numeric, errors=&lt;span&gt;&#x27;coerce&#x27;&lt;/span&gt;).fillna(&lt;span&gt;0&lt;/span&gt;)&lt;br/&gt;df&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.3352601156069364&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/hN1l83J6PhibibyviaTndatOurjRCHGfW6pR2KegGAzSyyTjpcGJDtxdQV5EGjwoKzn3RdFLBAbGf3Scur7yjrkhw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;692&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;仅需一行代码就完成了我们的目标，因为现在所有的数据类型都转换成float:&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;df.dtypes&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;col_one      float64&lt;br/&gt;col_two      float64&lt;br/&gt;col_three    float64&lt;br/&gt;dtype: object&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;8. 减小DataFrame空间大小&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;pandas DataFrame被设计成可以适应内存，所以有些时候你可以减小DataFrame的空间大小，让它在你的系统上更好地运行起来。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这是drinks这个DataFrame所占用的空间大小：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;drinks.info(memory_usage=&lt;span&gt;&#x27;deep&#x27;&lt;/span&gt;)&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&amp;lt;class &#x27;pandas.core.frame.DataFrame&#x27;&amp;gt;&lt;br/&gt;RangeIndex: 193 entries, 0 to 192&lt;br/&gt;Data columns (total 6 columns):&lt;br/&gt;country                         193 non-null object&lt;br/&gt;beer_servings                   193 non-null int64&lt;br/&gt;spirit_servings                 193 non-null int64&lt;br/&gt;wine_servings                   193 non-null int64&lt;br/&gt;total_litres_of_pure_alcohol    193 non-null float64&lt;br/&gt;continent                       193 non-null object&lt;br/&gt;dtypes: float64(1), int64(3), object(2)&lt;br/&gt;memory usage: 30.4 KB&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可以看到它使用了304.KB。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果你对你的DataFrame有操作方面的问题，或者你不能将它读进内存，那么在读取文件的过程中有两个步骤可以使用来减小DataFrame的空间大小。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;第一个步骤是只读取那些你实际上需要用到的列，可以调用&lt;code&gt;usecols&lt;/code&gt;参数：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;cols = [&lt;span&gt;&#x27;beer_servings&#x27;&lt;/span&gt;, &lt;span&gt;&#x27;continent&#x27;&lt;/span&gt;]&lt;br/&gt;small_drinks = pd.read_csv(&lt;span&gt;&#x27;http://bit.ly/drinksbycountry&#x27;&lt;/span&gt;, usecols=cols)&lt;br/&gt;small_drinks.info(memory_usage=&lt;span&gt;&#x27;deep&#x27;&lt;/span&gt;)&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&amp;lt;class &#x27;pandas.core.frame.DataFrame&#x27;&amp;gt;&lt;br/&gt;RangeIndex: 193 entries, 0 to 192&lt;br/&gt;Data columns (total 2 columns):&lt;br/&gt;beer_servings    193 non-null int64&lt;br/&gt;continent        193 non-null object&lt;br/&gt;dtypes: int64(1), object(1)&lt;br/&gt;memory usage: 13.6 KB&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;通过仅读取用到的两列，我们将DataFrame的空间大小缩小至13.6KB。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;第二步是将所有实际上为类别变量的object列转换成类别变量，可以调用&lt;code&gt;dtypes&lt;/code&gt;参数：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;dtypes = {&lt;span&gt;&#x27;continent&#x27;&lt;/span&gt;:&lt;span&gt;&#x27;category&#x27;&lt;/span&gt;}&lt;br/&gt;smaller_drinks = pd.read_csv(&lt;span&gt;&#x27;http://bit.ly/drinksbycountry&#x27;&lt;/span&gt;, usecols=cols, dtype=dtypes)&lt;br/&gt;smaller_drinks.info(memory_usage=&lt;span&gt;&#x27;deep&#x27;&lt;/span&gt;)&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&amp;lt;class &#x27;pandas.core.frame.DataFrame&#x27;&amp;gt;&lt;br/&gt;RangeIndex: 193 entries, 0 to 192&lt;br/&gt;Data columns (total 2 columns):&lt;br/&gt;beer_servings    193 non-null int64&lt;br/&gt;continent        193 non-null category&lt;br/&gt;dtypes: category(1), int64(1)&lt;br/&gt;memory usage: 2.3 KB&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;通过将continent列读取为category数据类型，我们进一步地把DataFrame的空间大小缩小至2.3KB。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;值得注意的是，如果跟行数相比，category数据类型的列数相对较小，那么catefory数据类型可以减小内存占用。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;9. 按行从多个文件中构建DataFrame&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;假设你的数据集分化为多个文件，但是你需要将这些数据集读到一个DataFrame中。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;举例来说，我有一些关于股票的小数聚集，每个数据集为单天的CSV文件。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;pd.read_csv(&lt;span&gt;&#x27;data/stocks1.csv&#x27;&lt;/span&gt;)&lt;br/&gt;pd.read_csv(&lt;span&gt;&#x27;data/stocks2.csv&#x27;&lt;/span&gt;)&lt;br/&gt;pd.read_csv(&lt;span&gt;&#x27;data/stocks3.csv&#x27;&lt;/span&gt;)&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;你可以将每个CSV文件读取成DataFrame，将它们结合起来，然后再删除原来的DataFrame，但是这样会多占用内存且需要许多代码。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;更好的方式为使用内置的&lt;code&gt;glob&lt;/code&gt;模块。你可以给&lt;code&gt;glob()&lt;/code&gt;函数传递某种模式，包括未知字符，这样它会返回符合该某事的文件列表。在这种方式下，glob会查找所有以stocks开头的CSV文件：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;from&lt;/span&gt; glob &lt;span&gt;import&lt;/span&gt; glob&lt;br/&gt;&lt;br/&gt;stock_files = sorted(glob(&lt;span&gt;&#x27;data/stocks*.csv&#x27;&lt;/span&gt;))&lt;br/&gt;stock_files&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;[&#x27;data/stocks1.csv&#x27;, &#x27;data/stocks2.csv&#x27;, &#x27;data/stocks3.csv&#x27;]&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;glob会返回任意排序的文件名，这就是我们为什么要用Python内置的&lt;code&gt;sorted()&lt;/code&gt;函数来对列表进行排序。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们以生成器表达式用&lt;code&gt;read_csv()&lt;/code&gt;函数来读取每个文件，并将结果传递给&lt;code&gt;concat()&lt;/code&gt;函数，这会将单个的DataFrame按行来组合：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;pd.concat((pd.read_csv(file) &lt;span&gt;for&lt;/span&gt; file &lt;span&gt;in&lt;/span&gt; stock_files))&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.6206088992974239&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/hN1l83J6PhibibyviaTndatOurjRCHGfW6pkBxYZubjbtR4AmhAwjDHpo7nUP9LeiaMicfRnJJsYLfLCI6Er1JQjwrw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;854&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;不幸的是，索引值存在重复。为了避免这种情况，我们需要告诉&lt;code&gt;concat()&lt;/code&gt;函数来忽略索引，使用默认的整数索引：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;pd.concat((pd.read_csv(file) &lt;span&gt;for&lt;/span&gt; file &lt;span&gt;in&lt;/span&gt; stock_files), ignore_index=&lt;span&gt;True&lt;/span&gt;)&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6136363636363636&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/hN1l83J6PhibibyviaTndatOurjRCHGfW6pDsqWzRUO9icibyEWYxLz5A6pXpkoYp2R6EvnCmmPMoqRRjoVUWYFg8vQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;880&quot;/&gt;&lt;/figure&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;10. 按列从多个文件中构建DataFrame&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上一个技巧对于数据集中每个文件包含行记录很有用。但是如果数据集中的每个文件包含的列信息呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里有一个例子，dinks数据集被划分成两个CSV文件，每个文件包含三列：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;pd.read_csv(&lt;span&gt;&#x27;data/drinks1.csv&#x27;&lt;/span&gt;).head()&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.38073394495412843&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/hN1l83J6PhibibyviaTndatOurjRCHGfW6pQibXCojswL10RqEnehPREia9LDQXos2431egRMxSyOLOrThQ2mJM2X2g/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;872&quot;/&gt;&lt;/figure&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;pd.read_csv(&lt;span&gt;&#x27;data/drinks2.csv&#x27;&lt;/span&gt;).head()&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.42480211081794195&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/hN1l83J6PhibibyviaTndatOurjRCHGfW6pBd2tkpgc1bKj1wU8eZ1lsyzU6AwGAibibf7VVT7TbzLzic4gbLEzQrHoQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;758&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;同上一个技巧一样，我们以使用&lt;code&gt;glob()&lt;/code&gt;函数开始。这一次，我们需要告诉&lt;code&gt;concat()&lt;/code&gt;函数按列来组合：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;drink_files = sorted(glob(&lt;span&gt;&#x27;data/drinks*.csv&#x27;&lt;/span&gt;))&lt;br/&gt;pd.concat((pd.read_csv(file) &lt;span&gt;for&lt;/span&gt; file &lt;span&gt;in&lt;/span&gt; drink_files), axis=&lt;span&gt;&#x27;columns&#x27;&lt;/span&gt;).head()&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.26366559485530544&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/hN1l83J6PhibibyviaTndatOurjRCHGfW6pMXYakjhxxlC5WzicOQyE4vyfqUvt7Jqr94U8at02Ip6NtdicCePaxQ5g/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1244&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;现在我们的DataFrame已经有六列了。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;11. 从剪贴板中创建DataFrame&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;假设你将一些数据储存在Excel或者Google Sheet中，你又想要尽快地将他们读取至DataFrame中。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;你需要选择这些数据并复制至剪贴板。然后，你可以使用&lt;code&gt;read_clipboard()&lt;/code&gt;函数将他们读取至DataFrame中：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;df = pd.read_clipboard()&lt;br/&gt;df&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.34441087613293053&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/hN1l83J6PhibibyviaTndatOurjRCHGfW6puEJCBAbdrpiapiaSAlyvU3AH0Pic0sSiafaciaMYrdYEAr9wW5vwZrNLsNQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;662&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;和&lt;code&gt;read_csv()&lt;/code&gt;类似，&lt;code&gt;read_clipboard()&lt;/code&gt;会自动检测每一列的正确的数据类型：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;df.dtypes&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;Column A      int64&lt;br/&gt;Column B    float64&lt;br/&gt;Column C     object&lt;br/&gt;dtype: object&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们再复制另外一个数据至剪贴板：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;df = pd.read_clipboard()&lt;br/&gt;df&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.3684210526315789&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/hN1l83J6PhibibyviaTndatOurjRCHGfW6pcwhAEob1Bzc33RBQcBMYaIvIpEllHOEneZhMZficrrsEAh2jH9rcOaA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;608&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;神奇的是，pandas已经将第一列作为索引了：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;df.index&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;Index([&#x27;Alice&#x27;, &#x27;Bob&#x27;, &#x27;Charlie&#x27;], dtype=&#x27;object&#x27;)&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;需要注意的是，如果你想要你的工作在未来可复制，那么&lt;code&gt;read_clipboard()&lt;/code&gt;并不值得推荐。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;12. 将DataFrame划分为两个随机的子集&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;假设你想要将一个DataFrame划分为两部分，随机地将75%的行给一个DataFrame，剩下的25%的行给另一个DataFrame。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;举例来说，我们的movie ratings这个DataFrame有979行：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;len(movies)&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;979&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;12. 将DataFrame划分为两个随机的子集&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;假设你想要将一个DataFrame划分为两部分，随机地将75%的行给一个DataFrame，剩下的25%的行给另一个DataFrame。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;举例来说，我们的movie ratings这个DataFrame有979行：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;movies_1 = movies.sample(frac=&lt;span&gt;0.75&lt;/span&gt;, random_state=&lt;span&gt;1234&lt;/span&gt;)&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;接着我们使用&lt;code&gt;drop()&lt;/code&gt;函数来舍弃“moive_1”中出现过的行，将剩下的行赋值给&quot;movies_2&quot;DataFrame：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;movies_2 = movies.drop(movies_1.index)&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;你可以发现总的行数是正确的：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;len(movies_1) + len(movies_2)&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;979&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;你还可以检查每部电影的索引，或者&quot;moives_1&quot;:&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;movies_1.index.sort_values()&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;Int64Index([  0,   2,   5,   6,   7,   8,   9,  11,  13,  16,&lt;br/&gt;            ...&lt;br/&gt;            966, 967, 969, 971, 972, 974, 975, 976, 977, 978],&lt;br/&gt;           dtype=&#x27;int64&#x27;, length=734)&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;或者&quot;moives_2&quot;:&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;movies_2.index.sort_values()&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;Int64Index([  1,   3,   4,  10,  12,  14,  15,  18,  26,  30,&lt;br/&gt;            ...&lt;br/&gt;            931, 934, 937, 941, 950, 954, 960, 968, 970, 973],&lt;br/&gt;           dtype=&#x27;int64&#x27;, length=245)&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;需要注意的是，这个方法在索引值不唯一的情况下不起作用。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;读者注&lt;/code&gt;：该方法在机器学习或者深度学习中很有用，因为在模型训练前，我们往往需要将全部数据集按某个比例划分成训练集和测试集。该方法既简单又高效，值得学习和尝试。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;13. 通过多种类型对DataFrame进行过滤&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们先看一眼movies这个DataFrame：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;movies.head()&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.21481481481481482&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/hN1l83J6PhibibyviaTndatOurjRCHGfW6pIqawVJUNofYNKdJqMLq5vYOIU5QsGMsDFPEjKBSfEmIB3iaG0Bw5PuA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其中有一列是genre（类型）:&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;movies.genre.unique()&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;array([&#x27;Crime&#x27;, &#x27;Action&#x27;, &#x27;Drama&#x27;, &#x27;Western&#x27;, &#x27;Adventure&#x27;, &#x27;Biography&#x27;,&lt;br/&gt;       &#x27;Comedy&#x27;, &#x27;Animation&#x27;, &#x27;Mystery&#x27;, &#x27;Horror&#x27;, &#x27;Film-Noir&#x27;, &#x27;Sci-Fi&#x27;,&lt;br/&gt;       &#x27;History&#x27;, &#x27;Thriller&#x27;, &#x27;Family&#x27;, &#x27;Fantasy&#x27;], dtype=object)&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;比如我们想要对该DataFrame进行过滤，我们只想显示genre为Action或者Drama或者Western的电影，我们可以使用多个条件，以&quot;or&quot;符号分隔&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;movies[(movies.genre == &lt;span&gt;&#x27;Action&#x27;&lt;/span&gt;) |&lt;br/&gt;       (movies.genre == &lt;span&gt;&#x27;Drama&#x27;&lt;/span&gt;) |&lt;br/&gt;       (movies.genre == &lt;span&gt;&#x27;Western&#x27;&lt;/span&gt;)].head()&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.2081736909323116&quot; data-type=&quot;png&quot; data-w=&quot;1566&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/hN1l83J6PhibibyviaTndatOurjRCHGfW6pL9Piajib1ebldxH8Q6Jt1DxmuJjxHXjYJOhFibh0UXia1GEl2uDQZ77d5w/640?wx_fmt=png&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但是，你实际上可以使用&lt;code&gt;isin()&lt;/code&gt;函数将代码写得更加清晰，将genres列表传递给该函数：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;movies[movies.genre.isin([&lt;span&gt;&#x27;Action&#x27;&lt;/span&gt;, &lt;span&gt;&#x27;Drama&#x27;&lt;/span&gt;, &lt;span&gt;&#x27;Western&#x27;&lt;/span&gt;])].head()&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.2111111111111111&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/hN1l83J6PhibibyviaTndatOurjRCHGfW6pwA6fOMJS8c6ZJibDYgy7RnPw9MoWvB0DbhPrAFHPdh7sOg9XUCDmkNA/640?wx_fmt=png&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果你想要进行相反的过滤，也就是你将吧刚才的三种类型的电影排除掉，那么你可以在过滤条件前加上破浪号：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;movies[~movies.genre.isin([&lt;span&gt;&#x27;Action&#x27;&lt;/span&gt;, &lt;span&gt;&#x27;Drama&#x27;&lt;/span&gt;, &lt;span&gt;&#x27;Western&#x27;&lt;/span&gt;])].head()&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.29411764705882354&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/hN1l83J6PhibibyviaTndatOurjRCHGfW6pGWF6pibZ0kHP03oqYJCBhiaV1D0fdic1HvBzt5fhXu2iciaKIY6iaiaVRFCdQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1598&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这种方法能够起作用是因为在Python中，波浪号表示“not”操作。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;14. 从DataFrame中筛选出数量最多的类别&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;假设你想要对movies这个DataFrame通过genre进行过滤，但是只需要前3个数量最多的genre。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们对genre使用&lt;code&gt;value_counts()&lt;/code&gt;函数，并将它保存成counts（type为Series）:&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;counts = movies.genre.value_counts()&lt;br/&gt;counts&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;Drama        278&lt;br/&gt;Comedy       156&lt;br/&gt;Action       136&lt;br/&gt;Crime        124&lt;br/&gt;Biography     77&lt;br/&gt;Adventure     75&lt;br/&gt;Animation     62&lt;br/&gt;Horror        29&lt;br/&gt;Mystery       16&lt;br/&gt;Western        9&lt;br/&gt;Sci-Fi         5&lt;br/&gt;Thriller       5&lt;br/&gt;Film-Noir      3&lt;br/&gt;Family         2&lt;br/&gt;Fantasy        1&lt;br/&gt;History        1&lt;br/&gt;Name: genre, dtype: int64&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;该Series的&lt;code&gt;nlargest()&lt;/code&gt;函数能够轻松地计算出Series中前3个最大值：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;counts.nlargest(&lt;span&gt;3&lt;/span&gt;)&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;Drama     278&lt;br/&gt;Comedy    156&lt;br/&gt;Action    136&lt;br/&gt;Name: genre, dtype: int64&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;事实上我们在该Series中需要的是索引：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;counts.nlargest(&lt;span&gt;3&lt;/span&gt;).index&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;Index([&#x27;Drama&#x27;, &#x27;Comedy&#x27;, &#x27;Action&#x27;], dtype=&#x27;object&#x27;)&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;最后，我们将该索引传递给&lt;code&gt;isin()&lt;/code&gt;函数，该函数会把它当成genre列表：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;movies[movies.genre.isin(counts.nlargest(&lt;span&gt;3&lt;/span&gt;).index)].head()&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.2953703703703704&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/hN1l83J6PhibibyviaTndatOurjRCHGfW6pMz4E9dOuUw1HrvNZKSF9EIv5ibXduicibhIYicKOrBoRDAicyGG9HEoEjMg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;样，在DataFrame中只剩下Drame, Comdey, Action这三种类型的电影了。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;15. 处理缺失值&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们来看一看UFO sightings这个DataFrame:&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;ufo.head()&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.31273408239700373&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/hN1l83J6PhibibyviaTndatOurjRCHGfW6pHFUy5ibzRc7F7WGQ0M7hQl81XC8rfsAiaYROtc0kfgG60NFmBtxDCptA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1068&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;你将会注意到有些值是缺失的。  为了找出每一列中有多少值是缺失的，你可以使用&lt;code&gt;isna()&lt;/code&gt;函数，然后再使用&lt;code&gt;sum()&lt;/code&gt;:&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;ufo.isna().sum()&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;City                  25&lt;br/&gt;Colors Reported    15359&lt;br/&gt;Shape Reported      2644&lt;br/&gt;State                  0&lt;br/&gt;Time                   0&lt;br/&gt;dtype: int64&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;isna()&lt;/code&gt;会产生一个由True和False组成的DataFrame，&lt;code&gt;sum()&lt;/code&gt;会将所有的True值转换为1，False转换为0并把它们加起来。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;类似地，你可以通过&lt;code&gt;mean()&lt;/code&gt;和&lt;code&gt;isna()&lt;/code&gt;函数找出每一列中缺失值的百分比。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;ufo.isna().mean()&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;City               0.001371&lt;br/&gt;Colors Reported    0.842004&lt;br/&gt;Shape Reported     0.144948&lt;br/&gt;State              0.000000&lt;br/&gt;Time               0.000000&lt;br/&gt;dtype: float64&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果你想要舍弃那些包含了缺失值的列，你可以使用&lt;code&gt;dropna()&lt;/code&gt;函数：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;ufo.dropna(axis=&lt;span&gt;&#x27;columns&#x27;&lt;/span&gt;).head()&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.4880952380952381&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/hN1l83J6PhibibyviaTndatOurjRCHGfW6pXTB8UFqBUBssia5AXLDNdpP408LrcYJJownibKsYibseQWpZamtG9km7w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;672&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;或者你想要舍弃那么缺失值占比超过10%的列，你可以给&lt;code&gt;dropna()&lt;/code&gt;设置一个阈值：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;ufo.dropna(thresh=len(ufo)*&lt;span&gt;0.9&lt;/span&gt;, axis=&lt;span&gt;&#x27;columns&#x27;&lt;/span&gt;).head()&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.4876543209876543&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/hN1l83J6PhibibyviaTndatOurjRCHGfW6p64ZicWIUf5PGzS1ENvEgQ05gBzeMwjnvibiaF1SjcO2CYOqW6DJ19ZWrQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;648&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;len(ufo)&lt;/code&gt;返回总行数，我们将它乘以0.9，以告诉pandas保留那些至少90%的值不是缺失值的列。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;16. 将一个字符串划分成多个列&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们先创建另一个新的示例DataFrame:&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;df = pd.DataFrame({&lt;span&gt;&#x27;name&#x27;&lt;/span&gt;:[&lt;span&gt;&#x27;John Arthur Doe&#x27;&lt;/span&gt;, &lt;span&gt;&#x27;Jane Ann Smith&#x27;&lt;/span&gt;],&lt;br/&gt;                   &lt;span&gt;&#x27;location&#x27;&lt;/span&gt;:[&lt;span&gt;&#x27;Los Angeles, CA&#x27;&lt;/span&gt;, &lt;span&gt;&#x27;Washington, DC&#x27;&lt;/span&gt;]})&lt;br/&gt;df&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.25210084033613445&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/hN1l83J6PhibibyviaTndatOurjRCHGfW6pPlDdQTyKiaJ8icICxMOCicvNXbhgQbX5VAkQa3UicILseW6awdOq2hm4uQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;714&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果我们需要将“name”这一列划分为三个独立的列，用来表示first, middle, last name呢？我们将会使用&lt;code&gt;str.split()&lt;/code&gt;函数，告诉它以空格进行分隔，并将结果扩展成一个DataFrame:&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;df.name.str.split(&lt;span&gt;&#x27; &#x27;&lt;/span&gt;, expand=&lt;span&gt;True&lt;/span&gt;)&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.2733118971061093&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/hN1l83J6PhibibyviaTndatOurjRCHGfW6pkULH6jKcyjZjMYNb2J8cuHYya33sf1XicZkjia3g1dE1LREOzK4Z6nvQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;622&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这三列实际上可以通过一行代码保存至原来的DataFrame:&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;df[[&lt;span&gt;&#x27;first&#x27;&lt;/span&gt;, &lt;span&gt;&#x27;middle&#x27;&lt;/span&gt;, &lt;span&gt;&#x27;last&#x27;&lt;/span&gt;]] = df.name.str.split(&lt;span&gt;&#x27; &#x27;&lt;/span&gt;, expand=&lt;span&gt;True&lt;/span&gt;)&lt;br/&gt;df&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.2265193370165746&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/hN1l83J6PhibibyviaTndatOurjRCHGfW6p8CMYUBs1ibKib0cicsAR0cyXWOibasGnV3AApMvV0DxO82gZO1U2dHystQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;724&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果我们想要划分一个字符串，但是仅保留其中一个结果列呢？比如说，让我们以&quot;, &quot;来划分location这一列：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;df.location.str.split(&lt;span&gt;&#x27;, &#x27;&lt;/span&gt;, expand=&lt;span&gt;True&lt;/span&gt;)&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.29931972789115646&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/hN1l83J6PhibibyviaTndatOurjRCHGfW6pn6yvcwE5eGlnZdVXibQYaQpZEFLpibkiaiboZ1Z33tW5EkKonfOqEMC6rw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;588&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果我们只想保留第0列作为city name，我们仅需要选择那一列并保存至DataFrame:&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;df[&lt;span&gt;&#x27;city&#x27;&lt;/span&gt;] = df.location.str.split(&lt;span&gt;&#x27;, &#x27;&lt;/span&gt;, expand=&lt;span&gt;True&lt;/span&gt;)[&lt;span&gt;0&lt;/span&gt;]&lt;br/&gt;df&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.19144144144144143&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/hN1l83J6PhibibyviaTndatOurjRCHGfW6puNib1Lno9AjR8wQ2pPADTpcgEH9GODTIYib4TH98icZyF2VyZFswicRKXw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;888&quot;/&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;17. 将一个由列表组成的Series扩展成DataFrame&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们创建一个新的示例DataFrame:&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;df = pd.DataFrame({&lt;span&gt;&#x27;col_one&#x27;&lt;/span&gt;:[&lt;span&gt;&#x27;a&#x27;&lt;/span&gt;, &lt;span&gt;&#x27;b&#x27;&lt;/span&gt;, &lt;span&gt;&#x27;c&#x27;&lt;/span&gt;], &lt;span&gt;&#x27;col_two&#x27;&lt;/span&gt;:[[&lt;span&gt;10&lt;/span&gt;, &lt;span&gt;40&lt;/span&gt;], [&lt;span&gt;20&lt;/span&gt;, &lt;span&gt;50&lt;/span&gt;], [&lt;span&gt;30&lt;/span&gt;, &lt;span&gt;60&lt;/span&gt;]]})&lt;br/&gt;df&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.3848797250859107&quot; data-type=&quot;png&quot; data-w=&quot;582&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/hN1l83J6PhibibyviaTndatOurjRCHGfW6pibR2ib3DqBLHaNqoGlok8qF5NcUb4hLte6zGU2JVibKRaE1s5wdtHtexg/640?wx_fmt=png&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里有两列，第二列包含了Python中的由整数元素组成的列表。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果我们想要将第二列扩展成DataFrame，我们可以对那一列使用&lt;code&gt;apply()&lt;/code&gt;函数并传递给Series constructor:&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;df_new = df.col_two.apply(pd.Series)&lt;br/&gt;df_new&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.43568464730290457&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/hN1l83J6PhibibyviaTndatOurjRCHGfW6pcdziabpV3tKvtMtaibicWBjicic8Y0bgIwGz9R32dN6mmq5klIdQddA2znw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;482&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;通过使用&lt;code&gt;concat()&lt;/code&gt;函数，我们可以将原来的DataFrame和新的DataFrame组合起来：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;pd.concat([df, df_new], axis=&lt;span&gt;&#x27;columns&#x27;&lt;/span&gt;)&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.4246575342465753&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/hN1l83J6PhibibyviaTndatOurjRCHGfW6pnDqia2Ao5G5sDaPeEYgel4qTXVp6YUDCZzj4yAG5pdicFFWXlDib5Zia8g/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;584&quot;/&gt;&lt;/figure&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;18. 对多个函数进行聚合&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们来看一眼从Chipotle restaurant chain得到的orders这个DataFrame:&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;orders.head(&lt;span&gt;10&lt;/span&gt;)&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.4222222222222222&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/hN1l83J6PhibibyviaTndatOurjRCHGfW6pIh37qG0Tq82ia50PF1Hibhk43ZicZ0icuAmAZNEk7SR5XLxxTO2M7gicUFw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;每个订单（order）都有订单号（order_id），包含一行或者多行。为了找出每个订单的总价格，你可以将那个订单号的价格（item_price）加起来。比如，这里是订单号为1的总价格：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;orders[orders.order_id == &lt;span&gt;1&lt;/span&gt;].item_price.sum()&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;11.56&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果你想要计算每个订单的总价格，你可以对order_id使用&lt;code&gt;groupby()&lt;/code&gt;，再对每个group的item_price进行求和。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;orders.groupby(&lt;span&gt;&#x27;order_id&#x27;&lt;/span&gt;).item_price.sum().head()&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;order_id&lt;br/&gt;1    11.56&lt;br/&gt;2    16.98&lt;br/&gt;3    12.67&lt;br/&gt;4    21.00&lt;br/&gt;5    13.70&lt;br/&gt;Name: item_price, dtype: float64&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但是，事实上你不可能在聚合时仅使用一个函数，比如&lt;code&gt;sum()&lt;/code&gt;。为了对多个函数进行聚合，你可以使用&lt;code&gt;agg()&lt;/code&gt;函数，传给它一个函数列表，比如&lt;code&gt;sum()&lt;/code&gt;和&lt;code&gt;count()&lt;/code&gt;:&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;orders.groupby(&lt;span&gt;&#x27;order_id&#x27;&lt;/span&gt;).item_price.agg([&lt;span&gt;&#x27;sum&#x27;&lt;/span&gt;, &lt;span&gt;&#x27;count&#x27;&lt;/span&gt;]).head()&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6586206896551724&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/hN1l83J6PhibibyviaTndatOurjRCHGfW6pJ02dCk3bVBvduYqRXMCK2MicMoFnjWzAfmV4nd0g9a2OAgYsA2SlKvQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;580&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这将告诉我们没定订单的总价格和数量。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;19. 将聚合结果与DataFrame进行组合&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们再看一眼orders这个DataFrame:&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;orders.head(&lt;span&gt;10&lt;/span&gt;)&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.412962962962963&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/hN1l83J6PhibibyviaTndatOurjRCHGfW6p051lTOTE0F1eDEciaDdcUAtv2wqD2RH6V1icjXO4Jwibe5apEFXynBVAA/640?wx_fmt=png&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果我们想要增加新的一列，用于展示每个订单的总价格呢？回忆一下，我们通过使用&lt;code&gt;sum()&lt;/code&gt;函数得到了总价格：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;orders.groupby(&lt;span&gt;&#x27;order_id&#x27;&lt;/span&gt;).item_price.sum().head()&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;order_id&lt;br/&gt;1    11.56&lt;br/&gt;2    16.98&lt;br/&gt;3    12.67&lt;br/&gt;4    21.00&lt;br/&gt;5    13.70&lt;br/&gt;Name: item_price, dtype: float64&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;sum()&lt;/code&gt;是一个聚合函数，这表明它返回输入数据的精简版本（reduced version ）。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;换句话说，&lt;code&gt;sum()&lt;/code&gt;函数的输出：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;len(orders.groupby(&lt;span&gt;&#x27;order_id&#x27;&lt;/span&gt;).item_price.sum())&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;1834&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;比这个函数的输入要小：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;len(orders.item_price)&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;4622&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;解决的办法是使用&lt;code&gt;transform()&lt;/code&gt;函数，它会执行相同的操作但是返回与输入数据相同的形状：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;total_price = orders.groupby(&lt;span&gt;&#x27;order_id&#x27;&lt;/span&gt;).item_price.transform(&lt;span&gt;&#x27;sum&#x27;&lt;/span&gt;)&lt;br/&gt;len(total_price)&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;4622&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们将这个结果存储至DataFrame中新的一列：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;orders[&lt;span&gt;&#x27;total_price&#x27;&lt;/span&gt;] = total_price&lt;br/&gt;orders.head(&lt;span&gt;10&lt;/span&gt;)&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.3758043758043758&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/hN1l83J6PhibibyviaTndatOurjRCHGfW6pEKiaXlm30qHWFf6q0biasfBZ1icbk2wI5FHuqjXfdOFgEib0K3UKxDfwBw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1554&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;你可以看到，每个订单的总价格在每一行中显示出来了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这样我们就能方便地甲酸每个订单的价格占该订单的总价格的百分比：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;orders[&lt;span&gt;&#x27;percent_of_total&#x27;&lt;/span&gt;] = orders.item_price / orders.total_price&lt;br/&gt;orders.head(&lt;span&gt;10&lt;/span&gt;)&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.4981481481481482&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/hN1l83J6PhibibyviaTndatOurjRCHGfW6pRXibDPtYQ1ngpOjnJwZibFDL3DB4M4dqjjiba7TtABE4Df07I3ujcO7YQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;20. 选取行和列的切片&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们看一眼另一个数据集：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;titanic.head()&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.3130434782608696&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/hN1l83J6PhibibyviaTndatOurjRCHGfW6pJMefsvrp7Btpa6n9ibhpbdD3HmgH143O5IFdPibAMibN5Y5oxqeE0ooow/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1610&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这就是著名的Titanic数据集，它保存了Titanic上乘客的信息以及他们是否存活。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果你想要对这个数据集做一个数值方面的总结，你可以使用&lt;code&gt;describe()&lt;/code&gt;函数：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;titanic.describe()&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.412962962962963&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/hN1l83J6PhibibyviaTndatOurjRCHGfW6pPEppo96zI4VM6qFkRMvdibia9sbJQAhh37Klagp1IOJYDYyRib78CzTyw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但是，这个DataFrame结果可能比你想要的信息显示得更多。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果你想对这个结果进行过滤，只想显示“五数概括法”（five-number summary）的信息，你可以使用&lt;code&gt;loc&lt;/code&gt;函数并传递&quot;min&quot;到&quot;max&quot;的切片:&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;titanic.describe().loc[&lt;span&gt;&#x27;min&#x27;&lt;/span&gt;:&lt;span&gt;&#x27;max&#x27;&lt;/span&gt;]&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.38666666666666666&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/hN1l83J6PhibibyviaTndatOurjRCHGfW6puo6CZrdOy1fTDFSCSLy6lJNLPwkcRNQgcUwgZnon2OGt7RXw1hO1IQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;900&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果你不是对所有列都感兴趣，你也可以传递列名的切片：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;titanic.describe().loc[&lt;span&gt;&#x27;min&#x27;&lt;/span&gt;:&lt;span&gt;&#x27;max&#x27;&lt;/span&gt;, &lt;span&gt;&#x27;Pclass&#x27;&lt;/span&gt;:&lt;span&gt;&#x27;Parch&#x27;&lt;/span&gt;]&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.4772727272727273&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/hN1l83J6PhibibyviaTndatOurjRCHGfW6pJFSsApKWyPa7j7LypGwqGibiazTvVliaFRicvV9xAPUBJAdxeZlmpfKI2Q/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;704&quot;/&gt;&lt;/figure&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;21. 对MultiIndexed Series进行重塑&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Titanic数据集的Survived列由1和0组成，因此你可以对这一列计算总的存活率：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;titanic.Survived.mean()&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;0.3838383838383838&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果你想对某个类别，比如“Sex”，计算存活率，你可以使用&lt;code&gt;groupby()&lt;/code&gt;:&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;titanic.groupby(&lt;span&gt;&#x27;Sex&#x27;&lt;/span&gt;).Survived.mean()&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;Sex&lt;br/&gt;female    0.742038&lt;br/&gt;male      0.188908&lt;br/&gt;Name: Survived, dtype: float64&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果你想一次性对两个类别变量计算存活率，你可以对这些类别变量使用&lt;code&gt;groupby()&lt;/code&gt;：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;titanic.groupby([&lt;span&gt;&#x27;Sex&#x27;&lt;/span&gt;, &lt;span&gt;&#x27;Pclass&#x27;&lt;/span&gt;]).Survived.mean()&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;Sex     Pclass&lt;br/&gt;female  1         0.968085&lt;br/&gt;        2         0.921053&lt;br/&gt;        3         0.500000&lt;br/&gt;male    1         0.368852&lt;br/&gt;        2         0.157407&lt;br/&gt;        3         0.135447&lt;br/&gt;Name: Survived, dtype: float64&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;该结果展示了由Sex和Passenger Class联合起来的存活率。它存储为一个MultiIndexed Series，也就是说它对实际数据有多个索引层级。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这使得该数据难以读取和交互，因此更为方便的是通过&lt;code&gt;unstack()&lt;/code&gt;函数将MultiIndexed Series重塑成一个DataFrame:&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;titanic.groupby([&lt;span&gt;&#x27;Sex&#x27;&lt;/span&gt;, &lt;span&gt;&#x27;Pclass&#x27;&lt;/span&gt;]).Survived.mean().unstack()&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.31666666666666665&quot; data-type=&quot;png&quot; data-w=&quot;720&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/hN1l83J6PhibibyviaTndatOurjRCHGfW6paj2CibZq4qvjAlUy9Qe63iatwnbQujbcbPt52afDYdI9Lia3CVNujDj0w/640?wx_fmt=png&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;该DataFrame包含了与MultiIndexed Series一样的数据，不同的是，现在你可以用熟悉的DataFrame的函数对它进行操作。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;22. 创建数据透视表（pivot table）&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果你经常使用上述的方法创建DataFrames，你也许会发现用&lt;code&gt;pivot_table()&lt;/code&gt;函数更为便捷：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;titanic.pivot_table(index=&lt;span&gt;&#x27;Sex&#x27;&lt;/span&gt;, columns=&lt;span&gt;&#x27;Pclass&#x27;&lt;/span&gt;, values=&lt;span&gt;&#x27;Survived&#x27;&lt;/span&gt;, aggfunc=&lt;span&gt;&#x27;mean&#x27;&lt;/span&gt;)&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.33532934131736525&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/hN1l83J6PhibibyviaTndatOurjRCHGfW6pSibY7Dl7CXynwYiasbQgXFKgyZuJ15hwskOYyp7WjusEZWFMficL0PoAA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;668&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;想要使用数据透视表，你需要指定索引(index), 列名(columns), 值(values)和聚合函数(aggregation function)。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;数据透视表的另一个好处是，你可以通过设置&lt;code&gt;margins=True&lt;/code&gt;轻松地将行和列都加起来：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;titanic.pivot_table(index=&lt;span&gt;&#x27;Sex&#x27;&lt;/span&gt;, columns=&lt;span&gt;&#x27;Pclass&#x27;&lt;/span&gt;, values=&lt;span&gt;&#x27;Survived&#x27;&lt;/span&gt;, aggfunc=&lt;span&gt;&#x27;mean&#x27;&lt;/span&gt;,&lt;br/&gt;                    margins=&lt;span&gt;True&lt;/span&gt;)&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.35323383084577115&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/hN1l83J6PhibibyviaTndatOurjRCHGfW6picI4jY4VOfPBao24MW8JOU2Z2HY2KWT4w7ZRUF3st5w1A1b0NEQxcNQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;804&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;T这个结果既显示了总的存活率，也显示了Sex和Passenger Class的存活率。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;最后，你可以创建交叉表（cross-tabulation），只需要将聚合函数由&quot;mean&quot;改为&quot;count&quot;:&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;titanic.pivot_table(index=&lt;span&gt;&#x27;Sex&#x27;&lt;/span&gt;, columns=&lt;span&gt;&#x27;Pclass&#x27;&lt;/span&gt;, values=&lt;span&gt;&#x27;Survived&#x27;&lt;/span&gt;, aggfunc=&lt;span&gt;&#x27;count&#x27;&lt;/span&gt;,&lt;br/&gt;                    margins=&lt;span&gt;True&lt;/span&gt;)&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.43202416918429004&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/hN1l83J6PhibibyviaTndatOurjRCHGfW6pGdKmjolel4Lwv9mAibicjYFiaKX9I9SpLvr1iaS5WmliawBu6UGnLSJv3Ew/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;662&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个结果展示了每一对类别变量组合后的记录总数。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;23. 将连续数据转变成类别数据&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们来看一下Titanic数据集中的Age那一列：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;titanic.Age.head(&lt;span&gt;10&lt;/span&gt;)&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;0    22.0&lt;br/&gt;1    38.0&lt;br/&gt;2    26.0&lt;br/&gt;3    35.0&lt;br/&gt;4    35.0&lt;br/&gt;5     NaN&lt;br/&gt;6    54.0&lt;br/&gt;7     2.0&lt;br/&gt;8    27.0&lt;br/&gt;9    14.0&lt;br/&gt;Name: Age, dtype: float64&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;它现在是连续性数据，但是如果我们想要将它转变成类别数据呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;一个解决办法是对年龄范围打标签，比如&quot;adult&quot;, &quot;young adult&quot;, &quot;child&quot;。实现该功能的最好方式是使用&lt;code&gt;cut()&lt;/code&gt;函数：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;pd.cut(titanic.Age, bins=[&lt;span&gt;0&lt;/span&gt;, &lt;span&gt;18&lt;/span&gt;, &lt;span&gt;25&lt;/span&gt;, &lt;span&gt;99&lt;/span&gt;], labels=[&lt;span&gt;&#x27;child&#x27;&lt;/span&gt;, &lt;span&gt;&#x27;young adult&#x27;&lt;/span&gt;, &lt;span&gt;&#x27;adult&#x27;&lt;/span&gt;]).head(&lt;span&gt;10&lt;/span&gt;)&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;0    young adult&lt;br/&gt;1          adult&lt;br/&gt;2          adult&lt;br/&gt;3          adult&lt;br/&gt;4          adult&lt;br/&gt;5            NaN&lt;br/&gt;6          adult&lt;br/&gt;7          child&lt;br/&gt;8          adult&lt;br/&gt;9          child&lt;br/&gt;Name: Age, dtype: category&lt;br/&gt;Categories (3, object): [child &amp;lt; young adult &amp;lt; adult]&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这会对每个值打上标签。0到18岁的打上标签&quot;child&quot;，18-25岁的打上标签&quot;young adult&quot;，25到99岁的打上标签“adult”。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;注意到，该数据类型为类别变量，该类别变量自动排好序了（有序的类别变量）。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;24. 更改显示选项&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们再来看一眼Titanic 数据集：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;titanic.head()&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.2962962962962963&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/hN1l83J6PhibibyviaTndatOurjRCHGfW6pjYic30YyvGDAUf8AOMwyvt1u0Dvl8Tib2icU771LZkPJia8QdXR2fLsiaYw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;注意到，Age列保留到小数点后1位，Fare列保留到小数点后4位。如果你想要标准化，将显示结果保留到小数点后2位呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;你可以使用&lt;code&gt;set_option()&lt;/code&gt;函数：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;pd.set_option(&lt;span&gt;&#x27;display.float_format&#x27;&lt;/span&gt;, &lt;span&gt;&#x27;{:.2f}&#x27;&lt;/span&gt;.format)&lt;br/&gt;&lt;br/&gt;titanic.head()&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.28055555555555556&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/hN1l83J6PhibibyviaTndatOurjRCHGfW6p7EBhBCU0r5FPgGuAibCfM2yia2ca8puYpkkkoAjUjt9L6mvia5ic0yy9Ag/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;set_option()&lt;/code&gt;函数中第一个参数为选项的名称，第二个参数为Python格式化字符。可以看到，Age列和Fare列现在已经保留小数点后两位。注意，这并没有修改基础的数据类型，而只是修改了数据的显示结果。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;你也可以重置任何一个选项为其默认值：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;pd.reset_option(&lt;span&gt;&#x27;display.float_format&#x27;&lt;/span&gt;)&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;对于其它的选项也是类似的使用方法。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;25. Style a DataFrame&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上一个技巧在你想要修改整个jupyter notebook中的显示会很有用。但是，一个更灵活和有用的方法是定义特定DataFrame中的格式化（style）。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们回到stocks这个DataFrame:&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;stocks&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.7431693989071039&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/hN1l83J6PhibibyviaTndatOurjRCHGfW6pMHRSGQundSCHYPWuN3ydiaCeTKiaeXTFpMib4PUEibAxXe8X1bYxUKJstw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;732&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们可以创建一个格式化字符串的字典，用于对每一列进行格式化。然后将其传递给DataFrame的&lt;code&gt;style.format()&lt;/code&gt;函数：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;format_dict = {&lt;span&gt;&#x27;Date&#x27;&lt;/span&gt;:&lt;span&gt;&#x27;{:%m/%d/%y}&#x27;&lt;/span&gt;, &lt;span&gt;&#x27;Close&#x27;&lt;/span&gt;:&lt;span&gt;&#x27;${:.2f}&#x27;&lt;/span&gt;, &lt;span&gt;&#x27;Volume&#x27;&lt;/span&gt;:&lt;span&gt;&#x27;{:,}&#x27;&lt;/span&gt;}&lt;br/&gt;&lt;br/&gt;stocks.style.format(format_dict)&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6944444444444444&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/hN1l83J6PhibibyviaTndatOurjRCHGfW6p2E885hzo2b93PCEMTVPuP4vBDx4qBx5BkpNdpJVJibwxTD36tE9jHBg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;792&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;注意到，Date列是month-day-year的格式，Close列包含一个$符号，Volume列包含逗号。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们可以通过链式调用函数来应用更多的格式化：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;(stocks.style.format(format_dict)&lt;br/&gt; .hide_index()&lt;br/&gt; .highlight_min(&lt;span&gt;&#x27;Close&#x27;&lt;/span&gt;, color=&lt;span&gt;&#x27;red&#x27;&lt;/span&gt;)&lt;br/&gt; .highlight_max(&lt;span&gt;&#x27;Close&#x27;&lt;/span&gt;, color=&lt;span&gt;&#x27;lightgreen&#x27;&lt;/span&gt;)&lt;br/&gt;)&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.9722222222222222&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/hN1l83J6PhibibyviaTndatOurjRCHGfW6plvibTHblh2ODflHRUia8V4sqvicB7r25IcSOyeXYZT4w7yFftfmKaQ27w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;576&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们现在隐藏了索引，将Close列中的最小值高亮成红色，将Close列中的最大值高亮成浅绿色。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里有另一个DataFrame格式化的例子：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;(stocks.style.format(format_dict)&lt;br/&gt; .hide_index()&lt;br/&gt; .background_gradient(subset=&lt;span&gt;&#x27;Volume&#x27;&lt;/span&gt;, cmap=&lt;span&gt;&#x27;Blues&#x27;&lt;/span&gt;)&lt;br/&gt;)&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.8255451713395638&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/hN1l83J6PhibibyviaTndatOurjRCHGfW6p8yQEiaBmPSpnk8qbdcQLP2wYzQOsVibWEz6lEhX9DQIF7EIDDmWPAVSQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;642&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Volume列现在有一个渐变的背景色，你可以轻松地识别出大的和小的数值。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;最后一个例子：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;(stocks.style.format(format_dict)&lt;br/&gt; .hide_index()&lt;br/&gt; .bar(&lt;span&gt;&#x27;Volume&#x27;&lt;/span&gt;, color=&lt;span&gt;&#x27;lightblue&#x27;&lt;/span&gt;, align=&lt;span&gt;&#x27;zero&#x27;&lt;/span&gt;)&lt;br/&gt; .set_caption(&lt;span&gt;&#x27;Stock Prices from October 2016&#x27;&lt;/span&gt;)&lt;br/&gt;)&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.7824933687002652&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/hN1l83J6PhibibyviaTndatOurjRCHGfW6p5ibic946gv7kDv1VvJkfwzW7jwxFShmNIgIdqwQVllCqqPlL7MOOeK7w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;754&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;现在，Volumn列上有一个条形图，DataFrame上有一个标题。请注意，还有许多其他的选项你可以用来格式化DataFrame。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;额外技巧：Profile a DataFrame&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;假设你拿到一个新的数据集，你不想要花费太多力气，只是想快速地探索下。那么你可以使用&lt;code&gt;pandas-profiling&lt;/code&gt;这个模块。在你的系统上安装好该模块，然后使用&lt;code&gt;ProfileReport()&lt;/code&gt;函数，传递的参数为任何一个DataFrame。它会返回一个互动的HTML报告：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;第一部分为该数据集的总览，以及该数据集可能出现的问题列表；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;第二部分为每一列的总结。你可以点击&quot;toggle details&quot;获取更多信息；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;第三部分显示列之间的关联热力图；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;第四部分为缺失值情况报告；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;第五部分显示该数据及的前几行。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;使用示例如下（只显示第一部分的报告）：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;import&lt;/span&gt; pandas_profiling&lt;br/&gt;pandas_profiling.ProfileReport(titanic)&lt;/code&gt;&lt;/pre&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.5203703703703704&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/hN1l83J6PhibibyviaTndatOurjRCHGfW6pyNCtD8kF6ckLQKno6pAsTVNdw5rRw9vdZ47BicMyR8vfKn4Brc7rTCg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;2.2848297213622293&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/hN1l83J6PhibibyviaTndatOurjRCHGfW6pWjicGJ5HrtmzxeGiar4Q8CSEn989icEA2j8Zos1Je41wRhc2ESwxInAsg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;646&quot;/&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;1.6480331262939958&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/hN1l83J6PhibibyviaTndatOurjRCHGfW6p5sgcwWoDRBhFJYibacOVib0xUicUBqMDECQTcp6JbWiaoibKS2vI6ga5IbA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;966&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;blockquote class=&quot;js_blockquote_wrap&quot; data-type=&quot;2&quot; data-url=&quot;&quot; data-author-name=&quot;&quot; data-content-utf8-length=&quot;24&quot; data-source-title=&quot;&quot;&gt;&lt;section class=&quot;js_blockquote_digest&quot;&gt;&lt;p&gt;参考：https://nbviewer.org/&lt;/p&gt;&lt;/section&gt;&lt;/blockquote&gt;&lt;pre&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;229&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;248&quot; data-ratio=&quot;1.2974079126875853&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/njjfaJS7c9rPHUPw5yicNLqwPXxTAwibgJichjbRBgDLDA1OWRCs9Md9DzknKoqyZXZvniahsR6FnGKQaaCPgotqWg/640?wx_fmt=png&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; data-type=&quot;jpeg&quot; data-w=&quot;733&quot;/&gt;&lt;/p&gt;&lt;/section&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot; data-darkmode-bgcolor-16545695970992=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16545695970992=&quot;#fff|rgb(255, 255, 255)&quot; data-darkmode-color-16545695970992=&quot;rgb(105, 105, 105)&quot; data-darkmode-original-color-16545695970992=&quot;#fff|rgb(105, 105, 105)&quot; data-style=&quot;margin: 0em 0px 0px; padding: 0px; outline: 0px; max-width: 100%; font-size: 16px; font-style: normal; font-variant-ligatures: normal; font-variant-caps: normal; font-weight: 400; letter-spacing: 0.544px; orphans: 2; text-indent: 0px; text-transform: none; widows: 2; -webkit-text-stroke-width: 0px; background-color: rgb(255, 255, 255); text-decoration-thickness: initial; text-decoration-style: initial; text-decoration-color: initial; text-align: left; word-spacing: 1px; caret-color: rgb(0, 0, 0); color: rgb(105, 105, 105); box-sizing: border-box !important; overflow-wrap: break-word !important;&quot;&gt;&lt;p data-darkmode-bgcolor-16545695970992=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16545695970992=&quot;#fff|rgb(255, 255, 255)&quot; data-darkmode-color-16545695970992=&quot;rgb(163, 163, 163)&quot; data-darkmode-original-color-16545695970992=&quot;#fff|rgb(105, 105, 105)|rgb(34, 34, 34)&quot; data-style=&quot;margin-top: 0px; margin-right: 8px; margin-left: 8px; padding: 0px; outline: 0px; max-width: 100%; clear: both; min-height: 1em; color: rgb(34, 34, 34); font-family: -apple-system, BlinkMacSystemFont, &amp;quot;Helvetica Neue&amp;quot;, &amp;quot;PingFang SC&amp;quot;, &amp;quot;Hiragino Sans GB&amp;quot;, &amp;quot;Microsoft YaHei UI&amp;quot;, &amp;quot;Microsoft YaHei&amp;quot;, Arial, sans-serif; letter-spacing: 0.544px; white-space: normal; line-height: 1.75em; visibility: visible; margin-bottom: 1.2em !important; box-sizing: border-box !important; overflow-wrap: break-word !important;&quot;&gt;&lt;span&gt;&lt;strong data-darkmode-bgcolor-16545695970992=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16545695970992=&quot;#fff|rgb(255, 255, 255)&quot; data-darkmode-color-16545695970992=&quot;rgb(163, 163, 163)&quot; data-darkmode-original-color-16545695970992=&quot;#fff|rgb(105, 105, 105)|rgb(34, 34, 34)|rgb(0, 0, 0)&quot; data-style=&quot;margin: 0px; padding: 0px; outline: 0px; max-width: 100%; word-spacing: 2px; widows: 1; caret-color: rgb(51, 51, 51); font-family: -apple-system, system-ui, BlinkMacSystemFont, &amp;quot;Helvetica Neue&amp;quot;, &amp;quot;PingFang SC&amp;quot;, &amp;quot;Hiragino Sans GB&amp;quot;, &amp;quot;Microsoft YaHei&amp;quot;, Arial, sans-serif; color: rgb(0, 0, 0); letter-spacing: 0.5px; visibility: visible; box-sizing: border-box !important; overflow-wrap: break-word !important;&quot;&gt;推荐阅读&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzA4MjYwMTc5Nw==&amp;amp;mid=2648972608&amp;amp;idx=2&amp;amp;sn=c35eee2e8d19835c6cb79b8688409a6f&amp;amp;chksm=87938f6ab0e4067c1631d1b988d0d1d64fea6e6a1fd221bbb0b02b0a959a8fca94f93fa7cfd3&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;【教程】Python数据可视化入门&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot; hasload=&quot;1&quot;&gt;【教程】Python数据可视化入门&lt;/a&gt;&lt;/section&gt;&lt;section&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzA4MjYwMTc5Nw==&amp;amp;mid=2648973003&amp;amp;idx=2&amp;amp;sn=a7df0dd64d3f3eb37d6c35852916bc94&amp;amp;chksm=87938ce1b0e405f7e894c018186de28aabfdc4e861af927292ae6c3c541e8286026e82fb356f&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;【数据分析】统计学基础知识总结&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot; hasload=&quot;1&quot;&gt;【数据分析】统计学基础知识总结&lt;/a&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzA4MjYwMTc5Nw==&amp;amp;mid=2648973082&amp;amp;idx=2&amp;amp;sn=c187826dbb62dc6fdbb4898460b1b605&amp;amp;chksm=87938d30b0e404264f6b1a586752c21bceb990358ca80f1d28ba0f14032db526acb438fb0510&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;全网最全的速查表：Python Numpy Pandas Matplotlib 机器学习等&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot; hasload=&quot;1&quot;&gt;全网最全速查表：Python 机器学习&lt;/a&gt;&lt;/section&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot; data-darkmode-bgcolor-16545695970992=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16545695970992=&quot;#fff|rgb(255, 255, 255)&quot; data-darkmode-color-16545695970992=&quot;rgb(105, 105, 105)&quot; data-darkmode-original-color-16545695970992=&quot;#fff|rgb(105, 105, 105)&quot; data-style=&quot;margin: 0em 0px 0px; padding: 0px; outline: 0px; max-width: 100%; font-size: 16px; font-style: normal; font-variant-ligatures: normal; font-variant-caps: normal; font-weight: 400; letter-spacing: 0.544px; orphans: 2; text-indent: 0px; text-transform: none; widows: 2; -webkit-text-stroke-width: 0px; background-color: rgb(255, 255, 255); text-decoration-thickness: initial; text-decoration-style: initial; text-decoration-color: initial; text-align: left; word-spacing: 1px; caret-color: rgb(0, 0, 0); color: rgb(105, 105, 105); box-sizing: border-box !important; overflow-wrap: break-word !important;&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzA4MjYwMTc5Nw==&amp;amp;mid=2648969778&amp;amp;idx=2&amp;amp;sn=838f0360048a7681d38b05e79011f6f3&amp;amp;chksm=87938018b0e4090ee61c848e02f718c74c3aa5e2a96469bd3e48a8748b3ea5875972d161c97e&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;《机器学习算法与Python实战》：搭建机器学习开发环境&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot; hasload=&quot;1&quot;&gt;搭建完美的Python 机器学习开发环境&lt;/a&gt;&lt;/section&gt;&lt;section&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzA4MjYwMTc5Nw==&amp;amp;mid=2648973292&amp;amp;idx=2&amp;amp;sn=068805ff2eb33481bdf9203c86051d9c&amp;amp;chksm=87938dc6b0e404d072d52371d642baf55955faaec3611875d20ae39a566b7403806d07c64493&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;《机器学习算法与Python实战》：训练集，验证集，测试集，交叉验证&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot; hasload=&quot;1&quot;&gt;训练集，验证集，测试集，交叉验证&lt;/a&gt;&lt;/section&gt;&lt;/section&gt;&lt;/pre&gt;&lt;/pre&gt;&lt;/pre&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>8314fdde0cd8fa54216ff8eff329a175</guid>
<title>MyBatis 都用了哪些设计模式</title>
<link>https://toutiao.io/k/3n1ss0p</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-role=&quot;outer&quot; label=&quot;edit by 135editor&quot; data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;p&gt;&lt;span&gt;👆&lt;/span&gt;&lt;span&gt;点击“&lt;/span&gt;&lt;span&gt;码哥字节&lt;/span&gt;&lt;span&gt;”，获取更多硬核&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;mp-common-profile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mpprofile&quot; data-weui-theme=&quot;light&quot; data-id=&quot;MzkzMDI1NjcyOQ==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/EoJib2tNvVtf7icAmS0BQH6oDVG37Q8NzcfdguS5qAqOhfxvZyIKqmuX5BbnDjynrBbZzktp1EiaeFLzapp1nHysw/0?wx_fmt=png&quot; data-nickname=&quot;码哥字节&quot; data-alias=&quot;MageByte&quot; data-signature=&quot;拥抱硬核技术和对象，面向人民币编程。&quot; data-from=&quot;0&quot; data-is_biz_ban=&quot;0&quot;/&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;&lt;strong/&gt;&lt;/span&gt;&lt;strong&gt;&lt;span&gt;文末送书&lt;/span&gt;&lt;/strong&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在MyBatis的两万多行的框架源码中，使用了大量的设计模式对工程架构中的复杂场景进行解耦，这些设计模式的巧妙使用是整个框架的精华。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;经过整理，大概有以下设计模式，如图1所示。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.30866425992779783&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/moaR7nLaQrFbZ79iaJB6uqGWs9nkpHROPiaEqmgIIcViaM4eYMkOt9WnRzRXs01d1kmrUofo9QWC3WNhzx3Y4Qwicg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;554&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;图1&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section data-role=&quot;title&quot; data-tools=&quot;135编辑器&quot; data-id=&quot;117920&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;strong&gt;0&lt;/strong&gt;&lt;strong data-original-title=&quot;&quot; title=&quot;&quot;&gt;1&lt;/strong&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;类型：创建型模式&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;section yne-bulb-block=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;span&gt;▊ &lt;strong&gt;&lt;span&gt;工厂模式&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;SqlSessionFactory 的结构如图2所示。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.6263537906137184&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/moaR7nLaQrFbZ79iaJB6uqGWs9nkpHROPtiaJWAlfP62qh4yxDuicXwMG2EVEk7j1ibICSwFicOJ893or1ZbKlu2U7Q/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;554&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;图2&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;工厂模式：&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;简单工厂是一种创建型模式，在父类中提供一个创建对象的方法，允许子类决定实例对象的类型。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;场景介绍：&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;SqlSessionFactory 是获取会话的工厂，每次使用MyBatis 操作数据库时， 都会开启一个新的会话。在会话工厂的实现中，SqlSessionFactory 负责获取数据源环境配置信息、构建事务工厂和创建操作SQL 的执行器，最终返回会话实现类。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;同类设计：&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;SqlSessionFactory、ObjectFactory、MapperProxyFactory 和DataSourceFactory。&lt;/span&gt;&lt;/p&gt;&lt;section yne-bulb-block=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;span&gt;▊ &lt;strong&gt;&lt;span&gt;单例模式&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;Configuration 单例配置类的结构如图3所示。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.6967509025270758&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/moaR7nLaQrFbZ79iaJB6uqGWs9nkpHROPDiaQUbbXnHeQgH1Iia8sR2nhwlWgpRIBHVp8hpkTkPwnmAMr9dV606dw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;554&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;图3&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;单例模式：&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;是一种创建型模式，能够保证一个类只有一个实例，并且提供一个访问该实例的全局节点。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;场景介绍：&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;Configuration 是一个大单例，贯穿整个会话周期，所有的配置对象（如映射、缓存、入参、出参、拦截器、注册机和对象工厂等）都在Configuration 配置项中初始化， 并且随着SqlSessionFactoryBuilder 构建阶段完成实例化操作。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;同类场景：&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;ErrorContext、LogFactory 和Configuration。&lt;/span&gt;&lt;/p&gt;&lt;section yne-bulb-block=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;span&gt;▊ &lt;strong&gt;&lt;span&gt;建造者模式&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;ResultMap 建造者模式的结构如图4所示。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.41155234657039713&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;554&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/moaR7nLaQrFbZ79iaJB6uqGWs9nkpHROPKDXYD8OEicS83k3dPIkxUI9fKrcZDwQSd81u8QyGRaDRIpYYqLO3ZUQ/640?wx_fmt=png&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;图4&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;建造者模式：&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;使用多个简单的对象一步一步地构建成一个复杂的对象，提供了一种创建对象的最佳方式。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;场景介绍：&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;建造者模式在MyBatis 中使用了大量的XxxxBuilder，将XML 文件解析到各类对象的封装中，使用建造者及建造者助手完成对象的封装。它的核心目的是不希望把过多的关于对象的属性设置写到其他业务流程中，而是用建造者方式提供最佳的边界隔离。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;同类场景：&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;SqlSessionFactoryBuilder、XMLConfigBuilder、XMLMapperBuilder、XML StatementBuilder 和CacheBuilder。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-role=&quot;title&quot; data-tools=&quot;135编辑器&quot; data-id=&quot;117920&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;strong&gt;0&lt;/strong&gt;&lt;strong data-original-title=&quot;&quot; title=&quot;&quot; data-num=&quot;2&quot;&gt;2&lt;/strong&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;类型：结构型模式&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;section yne-bulb-block=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;span&gt;▊ &lt;strong&gt;&lt;span&gt;适配器模式&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;日志实现类的结构如图5所示。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.7942238267148014&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;554&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/moaR7nLaQrFbZ79iaJB6uqGWs9nkpHROP5r6icibZlCbnVlnVlHrFicypRCF1icicW8CrQQHOKNxxmNVECfzUiavHJnqA/640?wx_fmt=png&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;图5&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;适配器模式：&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;是一种结构型模式，能使接口不兼容的对象也可以相互合作。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;场景介绍：&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;正是因为有太多的日志框架，包括Log4j、Log4j2 和Slf4J 等，而这些日志框架的使用接口又各有差异，为了统一这些日志框架的接口，MyBatis 定义了一套统一的接口，为所有的其他日志框架的接口做相应的适配。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;同类场景：&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;主要集中在对Log 日志的适配上。&lt;/span&gt;&lt;/p&gt;&lt;section yne-bulb-block=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;span&gt;▊ &lt;strong&gt;&lt;span&gt;代理模式&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;代理模式的实现结构如图6所示。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.4747292418772563&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;554&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/moaR7nLaQrFbZ79iaJB6uqGWs9nkpHROPknMgl3bia1npjZwlyeiaFGnPDLcOhR8jicZYvU5e1YiaAOpiaRMD8U9jOTg/640?wx_fmt=png&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;图6&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;代理模式：&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;是一种结构型模式，能够提供对象的替代品或占位符。代理控制元对象的访问，并且允许在将请求提交给对象前进行一些处理。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;场景介绍：&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;没有代理模式就不存在各类框架。就像MyBatis 中的MapperProxy 实现类， 代理工厂实现的功能就是完成DAO 接口的具体实现类的方法，配置的任何一个DAO 接口调用的CRUD 方法，都会被MapperProxy 接管，调用到方法执行器等，并返回最终的数据库执行结果。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;同类场景：&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;DriverProxy、Plugin、Invoker 和MapperProxy。&lt;/span&gt;&lt;/p&gt;&lt;section yne-bulb-block=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;span&gt;▊ &lt;strong&gt;&lt;span&gt;组合模式&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;解析节点类的结构如图7所示。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.8971119133574007&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;554&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/moaR7nLaQrFbZ79iaJB6uqGWs9nkpHROPqPgVVfn9s5K9fVN8zR9WKLyoYrZSibrkZMaSGd6p3uW40QYIPcs2KBw/640?wx_fmt=png&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;图7&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;组合模式：&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;是一种结构型模式，可以将对象组合成树形结构以表示“部分—整体” 的层次结构。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;场景介绍：&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;在MyBatis XML 动态的SQL 配置中，共提供了9 种标签（trim、where、set、foreach、if、choose、when、otherwise 和bind），使用者可以组合出各类场景的SQL 语句。而SqlNode 接口的实现就是每个组合结构中的规则节点，通过规则节点的组装，完成规则树组合模式的使用。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;同类场景：&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;主要体现在对各类SQL 标签的解析上，以实现SqlNode 接口的各个子类为主。&lt;/span&gt;&lt;/p&gt;&lt;section yne-bulb-block=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;span&gt;▊ &lt;strong&gt;&lt;span&gt;装饰器模式&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;二级缓存装饰器的实现结构如图8所示。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.5451263537906137&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;554&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/moaR7nLaQrFbZ79iaJB6uqGWs9nkpHROPtAiafB9fJsu1icgOrb2mUgkh6JTG9ibUXvjOzGNL9OLN3rSUqZLQmmUibw/640?wx_fmt=png&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;图8&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;装饰器模式：&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;是一种结构型设计模式，允许将对象放入包含行为的特殊封装对象中， 为元对象绑定新的行为。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;场景介绍：&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;MyBatis 的所有SQL 操作都是经过SqlSession 调用SimpleExecutor 完成的， 而一级缓存的操作也是在简单执行器中处理的。这里的二级缓存因为是基于一级缓存刷新的，所以在实现上，通过创建一个缓存执行器，包装简单执行器的处理逻辑，实现二级缓&lt;/span&gt;&lt;span&gt;存操作。这里用到的就是装饰器模式，也叫俄罗斯套娃模式。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section data-role=&quot;title&quot; data-tools=&quot;135编辑器&quot; data-id=&quot;117920&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;strong&gt;0&lt;/strong&gt;&lt;strong data-original-title=&quot;&quot; title=&quot;&quot; data-num=&quot;3&quot;&gt;3&lt;/strong&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;类型：行为型模式&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;section yne-bulb-block=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;span&gt;▊ &lt;strong&gt;&lt;span&gt;模板模式&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;SQL 执行模板模式如图9所示。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.7003610108303249&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;554&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/moaR7nLaQrFbZ79iaJB6uqGWs9nkpHROPFQ2KK6dSZ7pdrzxuG5picTMrwJB8ZFlICSibwQpSfs3HtAcEpnNoibpCQ/640?wx_fmt=png&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;图9&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;模板模式：&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;是一种行为型模式，在超类中定义了一个算法的框架，允许子类在不修改结构的情况下重写算法的特定步骤。场景介绍：存在一系列可被标准定义的流程，并且流程的步骤大部分采用通用逻辑，只有一小部分是需要子类实现的，通常采用模板模式来定义这个标准的流程。就像MyBatis 的BaseExecutor 就是一个用于定义模板模式的抽象类，在这个类中把查询、修改的操作都定义为一套标准的流程。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;同类场景：&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;BaseExecutor、SimpleExecutor 和BaseTypeHandler。&lt;/span&gt;&lt;/p&gt;&lt;section yne-bulb-block=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;span&gt;▊ &lt;strong&gt;&lt;span&gt;策略模式&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;多类型处理器策略模式的结构如图10所示。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;1.023465703971119&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;554&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/moaR7nLaQrFbZ79iaJB6uqGWs9nkpHROPdWHmfGsN5DOnkMY7K89WKp0E0Otoqf3rSR2eZRnG5pGcXKicaUlegUA/640?wx_fmt=png&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;图10&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;策略模式：&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;是一种行为型模式，能定义一系列算法，并将每种算法分别放入独立的类中，从而使算法的对象能够互相替换。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;场景介绍：&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;在MyBatis 处理JDBC 执行后返回的结果时，需要按照不同的类型获取对应的值，这样就可以避免大量的if 判断。所以，这里基于TypeHandler 接口对每个参数类型分别做了自己的策略实现。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;同类场景：&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;PooledDataSource、UnpooledDataSource、BatchExecutor、ResuseExecutor、SimpleExector、CachingExecutor、LongTypeHandler、StringTypeHandler 和DateTypeHandler。&lt;/span&gt;&lt;/p&gt;&lt;section yne-bulb-block=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;span&gt;▊ &lt;strong&gt;&lt;span&gt;迭代器模式&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;拆解字段解析实现的结构如图11所示。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.8194945848375451&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;554&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/moaR7nLaQrFbZ79iaJB6uqGWs9nkpHROPicHzHb7tXEM5PnZcyJXOYNiaM6CzDLqkOraWNzL5srByZ91Sibr0tCVlA/640?wx_fmt=png&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;图11&lt;/span&gt;&lt;/p&gt;&lt;p draggable=&quot;true&quot;&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;迭代器模式：&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;是一种行为型模式，能在不暴露集合底层表现形式的情况下遍历集合中的所有元素。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;场景介绍：&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;PropertyTokenizer 用于MyBatis 的MetaObject 反射工具包下，用来解析对象关系的迭代操作。这个类在MyBatis 中使用得非常频繁，包括解析数据源配置信息并填充到数据源类上，同时参数的解析、对象的设置都会使用这个类。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;同类场景：&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;PropertyTokenizer。&lt;/span&gt;&lt;/p&gt;&lt;section data-role=&quot;title&quot; data-tools=&quot;135编辑器&quot; data-id=&quot;117920&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;strong&gt;0&lt;/strong&gt;&lt;strong data-original-title=&quot;&quot; title=&quot;&quot; data-num=&quot;4&quot;&gt;4&lt;/strong&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;总结&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;通过梳理，MyBatis大约运用了10种左右设计模式。可以说，复杂且优秀的ORM 框架源码在设计和实现的过程中都会使用大量的设计模式。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在解决复杂场景的问题时，需要采用分治、抽象的方法，运用设计模式和设计原则等相关知识，把问题合理切割为若干子问题，以便加以理解和解决。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;学习源码远不是只是为了应付面试，更重要的是学习优秀框架在复杂场景下的解决方案。通过学习这些优秀的方案技术，可以提高对技术设计和实现的理解，扩展编码思维，积累落地经验。只有经过这样长期的积累，我们才更有可能成为优秀的高级工程师和架构师。&lt;/span&gt;&lt;/p&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;7&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;p data-autoskip=&quot;1&quot;&gt;本文节选自《手写MyBatis：渐进式源码实践》一书，欢迎阅读本书了解更多相关内容！&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;5.910791366906475&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PW0wIHxgg3krZkEpxhzIySAVco9rWvaLJEnZE7iaKIJNePH75EmPgysicKPfyXLmbcrXk3hEGC1LvnXjKhicBbJSg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;695&quot;/&gt;&lt;/p&gt;&lt;p&gt;五折优惠&lt;/p&gt;&lt;p&gt;&lt;mpcps class=&quot;js_editor_new_cps&quot; data-templateid=&quot;list&quot; data-traceid=&quot;3f058ea7-b51b-4cf4-96c1-e82bd9b2c38d&quot; data-goodssouce=&quot;1&quot; data-pid=&quot;101_13811216&quot; data-appuin=&quot;3930256729&quot; data-buffer=&quot;{&amp;quot;category_id&amp;quot;:106,&amp;quot;pid&amp;quot;:&amp;quot;101_13811216&amp;quot;,&amp;quot;biz_uin&amp;quot;:&amp;quot;3930256729&amp;quot;,&amp;quot;trace_id&amp;quot;:&amp;quot;3f058ea7-b51b-4cf4-96c1-e82bd9b2c38d&amp;quot;,&amp;quot;sku_id&amp;quot;:&amp;quot;101_13811216&amp;quot;,&amp;quot;source_id&amp;quot;:2,&amp;quot;source_name&amp;quot;:&amp;quot;京东&amp;quot;,&amp;quot;audit_state&amp;quot;:1,&amp;quot;main_img&amp;quot;:&amp;quot;https://pcm-img.zhls.qq.com/productcenter-5ef702e6--1018824-6629890333037118485/70341471627022023/fcf286a6c94ac9dafcf24d0fde10087b.jpg&amp;quot;,&amp;quot;product_name&amp;quot;:&amp;quot;手写MyBatis：渐进式源码实践（全彩）&amp;quot;,&amp;quot;current_price&amp;quot;:6400,&amp;quot;first_category_id&amp;quot;:&amp;quot;106&amp;quot;,&amp;quot;product_label_name_list&amp;quot;:[&amp;quot;京东配送&amp;quot;],&amp;quot;select_tag_name_list&amp;quot;:[],&amp;quot;templateId&amp;quot;:&amp;quot;card&amp;quot;,&amp;quot;appuin&amp;quot;:&amp;quot;3930256729&amp;quot;,&amp;quot;isNewCpsKOL&amp;quot;:1}&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-role=&quot;title&quot; data-tools=&quot;135编辑器&quot; data-id=&quot;117920&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;strong&gt;05&lt;/strong&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;福利赠书&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;关注公众号，设置星标，留言区分享你在使用 Mybatis 过程中遇到的坑，点赞获得最多的 4 位同学将第一时间拿到这本书，包邮。&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;&lt;span/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;span&gt;活动时间截至：3 月 14 号 12:00。&lt;/span&gt;&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;/pre&gt;&lt;section&gt;&lt;img class=&quot;__bg_gif rich_pages wxw-img&quot; data-ratio=&quot;0.75&quot; data-w=&quot;160&quot; data-width=&quot;100%&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/fgnkxfGnnkTMNtGy7KWfCrdJibAYY6HtIGhhtVOFQXzkE5GcmZIhTLgxggMlCe3oMwqKNesBDoU7kfgzFHuxyeA/640?wx_fmt=gif&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;点击阅读原文，查看本书详情！&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>