<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>918a4d9af9cbfe26d964101677cf50f9</guid>
<title>八万字开源图书《高并发的哲学原理》第一章 -- 找出单点，进行拆分</title>
<link>https://toutiao.io/k/04odf6a</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content js_underline_content             autoTypeSetting24psection&amp;#10;            &quot; id=&quot;js_content&quot;&gt;&lt;h3&gt;本文共 3800 字，阅读大约需要 12 分钟。&lt;/h3&gt;&lt;hr/&gt;&lt;h3&gt;人列计算机&lt;/h3&gt;&lt;p&gt;《三体》中，刘慈欣设计了一个用人进行二进制运算的计算机，使用了三千万名士兵(晶体管)：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6137171286425018&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/qehPQXlzsA1QcMpmiaoxTbiadicR3OzkffeN0BWV6yZDmTw8h607EHdiaXEay5ria0hM5R3cAGb9wzTlY7F8xC8nNpg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;2814&quot;/&gt;&lt;/p&gt;&lt;ol class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;挥舞旗帜进行二进制运算&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;用三个士兵来组成与门、或门、与非门、或非门、异或门、同或门和三态门，又用两个士兵组成了非门&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;将这些基本部件组合起来，构成了计算阵&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;li&gt;&lt;p&gt;内存：由文化程度较高的人组成，每个人挥舞多个颜色的旗帜，可以替代 20 个挥舞单色旗帜的人&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;硬盘：三百万文化程度较高的人（据说是上次坑儒留下来的）&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;显示阵列：至少配有红色和绿色像素单元（双色显示阵列）&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;维护部件：一组骑兵&lt;/p&gt;&lt;/li&gt;&lt;ol class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;传输信号&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;处理“故障”士兵&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;由秦始皇最精锐的骑兵团构成&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;li&gt;&lt;p&gt;维护方式：更换出错部件&lt;/p&gt;&lt;/li&gt;&lt;h4&gt;一提到高并发，很多人的第一反应都可以归纳为以下两种情况：&lt;/h4&gt;&lt;h4&gt;1. 进程间通信(IPC)、共享内存、管道、队列、事件：这是学院派&lt;/h4&gt;&lt;h4&gt;2. 内存缓存、消息队列、分库分表、NoSQL、ES 搜索：这是实战派&lt;/h4&gt;&lt;p&gt;其实，高并发之路，无论是学院派还是实战派，甚至是刘慈欣设计的人列计算机，其背后的哲学原理都是一样的。如果你问人列计算机和高并发有什么关系？按照上面的设计，最多一万名士兵就够了，为什么需要三千万呢？还不是为了提高性能。&lt;/p&gt;&lt;p&gt;其实，高并发的哲学原理早就隐藏在了现代计算机的基础结构之中，感兴趣的欢迎去看我的《性能之殇（二）-- 分支预测、流水线与多核 CPU》¹。&lt;/p&gt;&lt;h2&gt;本文目标&lt;/h2&gt;&lt;p&gt;上面的只是我的喃喃私语，下面我们进入正题。&lt;/p&gt;&lt;p&gt;本文的目标是在我有限的认知范围内，讨论一下高并发问题背后隐藏的一个哲学原理。我们将从动静分离讲起，一步步深入 Apache、Nginx、epoll、虚拟机、k8s、异步非阻塞、协程、应用网关、L4/L7 负载均衡器、路由器(网关)、交换机、LVS、软件定义网络(SDN)、Keepalived、DPDK、ECMP、全冗余架构、用户态网卡、集中式存储、分布式存储、PCI-E 5.0、全村的希望 CXL、InnoDB 三级索引、内存缓存、KV 数据库、列存储、内存数据库、Shared-Nothing、计算存储分离、Paxos、微服务架构、削峰、基于地理位置拆分、高可用等等等等。并最终基于地球和人类社会的基本属性，设计出可以服务地球全体人类的高并发架构。&lt;/p&gt;&lt;p&gt;先说结论，这个哲学原理就是：&lt;code&gt;找出单点，进行拆分&lt;/code&gt;。&lt;/p&gt;&lt;h2&gt;准备工作&lt;/h2&gt;&lt;h3&gt;性能问题要靠架构解决&lt;/h3&gt;&lt;p&gt;在展开这个哲学原理前，我们需要先明确一下高并发问题的解决思路：性能问题要靠架构解决。&lt;/p&gt;&lt;p&gt;首先，在架构上动刀是最简单的，也是最容易获得收益的。其次，即便是真的去做单个资源的性能优化，例如 MySQL 单机性能优化(软件优化)、x86 CPU 多核性能提升(硬件优化)，拆到微观来看，也是在做架构优化：&lt;/p&gt;&lt;p&gt;&lt;code&gt;没有银弹&lt;/code&gt;就是计算机世界的第一准则，你想获得收益，总得拿出一些东西，和&lt;code&gt;信息之神&lt;/code&gt;交换。&lt;/p&gt;&lt;h3&gt;我们讨论“哪个”高并发？&lt;/h3&gt;&lt;p&gt;本文讨论的是“web 服务高并发”问题，典型场景为电商秒杀：同一个时刻，数万人抢同一个低价商品，会给系统的每一个层面都造成显著的性能瓶颈，这种场景的集大成者，就是每年的双 11。&lt;/p&gt;&lt;h2&gt;一个小目标&lt;/h2&gt;&lt;p&gt;&lt;code&gt;找出单点，进行拆分&lt;/code&gt;，就是将每一个大单点都拆成一个小单点+多资源并行的形式。&lt;/p&gt;&lt;p&gt;在解决高并发问题的过程中，我们会不断地遇到新的单点：web server、单个操作系统、虚拟化/容器技术、编程语言运行架构、网络、UNIX 进程模型、数据库等。每遇到一个单点，我们都要见招拆招，使用&lt;code&gt;架构&lt;/code&gt;工具拆掉它。计算机的虚拟化程度非常高，几乎每个单点都可以继续往下拆。&lt;/p&gt;&lt;p&gt;接下来大家就跟着我一起，一步一步将系统性能的上限从单机 100 QPS 提升到 1,000,000（一百万）QPS。&lt;/p&gt;&lt;h3&gt;文章列表&lt;/h3&gt;&lt;ol class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;找出单点，进行拆分（本文）&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;Apache 的性能瓶颈与 Nginx 的性能优势&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;基础设施并发：虚拟机与 Kubernetes（k8s）&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;隐藏在语言背后的魔鬼：运行架构为何会成为性能瓶颈&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;拆分网络单点(上)：应用网关、负载均衡和路由器(网关)&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;拆分网络单点(下)：SDN 如何替代百万人民币的负载均衡硬件(网关、LVS、交换机)&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;最难以解决的单点：数据库以及它背后的存储&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;将 InnoDB 剥的一丝不挂：B+ 树与 Buffer Pool&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;细数四代分布式数据库并拆解 TiDB 和 OceanBase（主从、中间件、KV、计算与存储分离、列存储、CAP定理）&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;理论无限容量：站在地球表面&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h2&gt;找出第一个单点&lt;/h2&gt;&lt;p&gt;大部分系统都是从单个虚拟机开始的，原始的资源可能只有 1 核 2G，你安装了一个 Apache，一个 MySQL，把代码部署上去，这个系统就开始对外服务了。如果系统用户数量增加了，你会发现，CPU 满了，这个时候，我们第一个应该拆的就是静态流量。&lt;/p&gt;&lt;h3&gt;动静分离&lt;/h3&gt;&lt;p&gt;大概是在 2013 年，我用从同学那里买的二手 MacBook Pro 跑过 Apache 和 Nginx 的性能测试，在本机访问同一张 jpg 图片的情况下，Apache 的 QPS 为 2 万出头，而 Nginx 则超过 8 万，四倍性能。&lt;/p&gt;&lt;p&gt;所以，如果你还在用 Apache 承载所有流量，在前面加一个 Nginx 就能显著降低 CPU 占用率，大幅提升系统性能。如果你再利用云服务商把这些静态资源用 CDN 来承载，你的静态资源压力还能再降低 90%。&lt;/p&gt;&lt;p&gt;动静分离以后，CPU 又满了，该怎么办呢？这个时候就需要把数据库拆出去了。&lt;/p&gt;&lt;h3&gt;最适合独立部署的软件：数据库&lt;/h3&gt;&lt;p&gt;如果应用代码和数据库跑在一个系统上，压力稍微大一点，很容易出现“债股双杀”的局面：MySQL 的响应变慢，应用代码就需要更长时间的等待，又要消耗更多的 CPU 资源，从而形成“内卷”和“踩踏”。只要你的系统不是用户极其少，或者你们公司极其扣，把数据库独立部署的收益都是要高于投入的：1 核 2G 的虚拟机就够 MySQL 跑到 200 QPS了，配合缓存支撑一个日 PV 100 万的小系统应该够了。&lt;/p&gt;&lt;h3&gt;我的实际经验&lt;/h3&gt;&lt;h4&gt;进击的爬虫&lt;/h4&gt;&lt;p&gt;2017 年，我维护的一个 SEO 网站突然遭遇大量爬虫的袭击：由于这个网站拥有数百万个内容页面，页面内也有着大量的“类似文章推荐”，在只依靠 MySQL &lt;code&gt;like&lt;/code&gt;语句的情况下，单个页面的返回时间长达 300-500ms。一天两万的真实用户 UV 对系统的压力并不大，但这些爬虫不讲武德，上来就是 100 QPS，当时 1 核 2G 的虚拟机和 1 核 1G 的 MySQL 可遭了殃了，完全顶不住。&lt;/p&gt;&lt;p&gt;这些爬虫并不是正规大厂的爬虫，而是采集机器人，由于拥有海量代理 ip，对网站形成了 DDOS 态势，没法使用常规手段封禁，只能想办法抗住。&lt;/p&gt;&lt;p&gt;我首先做的，就是将静态资源全部 CDN 化，直接让 CPU 占用率降低了一半。然后就开始着手提升系统性能：&lt;/p&gt;&lt;ol class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;使用 ElasticSearch 提供“类似文章推荐”，将每个页面的响应时间压缩到了 200ms&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;提升数据库性能：增加索引，增加 Redis 缓存，使用定时任务刷新文章总数而不是实时计算，将响应时间压缩到了 120ms&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;访问 ES 的 HTTP 请求进行并行化：虽然 PHP 是一种阻塞语言，但是一次性发送多个 HTTP 请求的能力还是有的，平均每个页面有五次请求，每次 15ms，并行化以后从 15ms*5 减少到了 25ms，最终将平均响应时间压缩到了 70ms&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;同时，服务器和数据库也进行了计算资源的扩容，增加到了 2 核 4G 的虚拟机和 2 核 4G 的 MySQL，最终顶住了每天 200 万次页面访问的冲击，对比之下，真实用户 PV 每天只有十万左右。&lt;/p&gt;&lt;p&gt;这个时候可能有人会问了，既然是内容网站，为什么不静态化呢？因为数据量太大了，500 万个页面，一个页面 100KB，就是 476GB 的磁盘容量，这个量级太夸张了，不如做性能优化硬抗了，这么多静态资源的管理和刷新反而是个更大的问题。在百万量级下，数据库绝对是更好的数据存储解决方案，远比自己管理文件要更简单更稳定。&lt;/p&gt;&lt;p&gt;即便我做了那么多，还是不乏有一些爬虫愣头青在学习了 swoole 和 go 协程之后，对我的网站发动数千 QPS 的死亡冲锋，这个时候再怎么性能优化都是没用的，这时就需要使用倒数第二个工具：限流。&lt;/p&gt;&lt;p&gt;我做了三道限流关卡才最终顶住采集机器人 DDOS：&lt;/p&gt;&lt;ol class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;针对单个 ip 做请求频率限制&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;针对整个 /24 ip 段做请求频率限制（很多爬虫采用同一段内的多个 ip 绕过限流）&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;针对每个 UA 做请求频率限制&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;在这三板斧使出来以后，天下太平了，网站再也没有被突然发起的死亡冲锋搞挂过。&lt;/p&gt;&lt;p&gt;对了，既然限流是倒数第二个工具，肯定有人好奇最后一个工具是什么？那就是熔断，熔断属于系统鲁棒性工具，是善后用的，我们最后一篇文章还会再提一嘴。&lt;/p&gt;&lt;h3&gt;接下来&lt;/h3&gt;&lt;p&gt;下一篇文章，我们将看到真实的 Apache 性能瓶颈与 Nginx 的性能优势，同时我会继续现身说法，讲述团购秒杀业务的故事。&lt;/p&gt;&lt;h3&gt;参考资料&lt;/h3&gt;&lt;ol class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;性能之殇（二）-- 分支预测、流水线与多核 CPU https://lvwenhan.com/tech-epic/493.html&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;&lt;mp-style-type data-value=&quot;3&quot;/&gt;&lt;/p&gt;&lt;/div&gt;

          
        &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>77eadebd16da6e5606632b198d83f372</guid>
<title>优质网站同好者周刊（第 104 期） | 倾城博客</title>
<link>https://toutiao.io/k/0f7dz8m</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;content&quot;&gt;&lt;p&gt;&lt;a href=&quot;https://nicelinks.site/?utm_source=weekly&quot;&gt;倾城之链&lt;/a&gt;作为一个开放平台，旨在云集全球&lt;strong&gt;优秀网站&lt;/strong&gt;，探索互联网中更广阔的世界。此周刊，将汇聚过去一周&lt;a href=&quot;https://nicelinks.site/?utm_source=weekly&quot;&gt;倾城&lt;/a&gt;所收录的内容，以飨同好；欢迎推荐或自荐（仅限有独立域名的网站，可以是二级域名）。您如果要了解收录要求，请参见&lt;a href=&quot;https://nicelinks.site/about?utm_source=weekly&quot;&gt;关于倾城&lt;/a&gt;。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;备注&lt;/strong&gt;：本周刊&lt;strong&gt;每周五&lt;/strong&gt;生成，首发于个人微信公众号&lt;a href=&quot;https://mp.weixin.qq.com/mp/appmsgalbum?__biz=MzI5MDIwMzM2Mg==&amp;amp;action=getalbum&amp;amp;album_id=1530765143352082433&amp;amp;scene=173&amp;amp;from_msgid=2650641087&amp;amp;from_itemidx=1&amp;amp;count=3#wechat_redirect&quot;&gt;晚晴幽草轩&lt;/a&gt;、博客&lt;a href=&quot;https://www.jeffjade.com&quot;&gt;晚晴幽草轩&lt;/a&gt;，以及&lt;a href=&quot;https://forum.lovejade.cn/&quot;&gt;悠然宜想亭&lt;/a&gt;社区；此一键生成脚本基于 &lt;a href=&quot;https://nicelinks.site/post/602d30aad099ff5688618591&quot;&gt;Deno&lt;/a&gt; 编写，并在 Github 开源：&lt;a href=&quot;https://github.com/nicejade/nicelinks-weekly&quot;&gt;nicejade/nicelinks-weekly&lt;/a&gt;。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;标签&lt;/strong&gt;：&lt;a href=&quot;https://nicelinks.site/tags/Markdown&quot;&gt;&lt;code&gt;Markdown&lt;/code&gt;&lt;/a&gt; · &lt;a href=&quot;https://nicelinks.site/tags/Web%E5%BC%80%E5%8F%91&quot;&gt;&lt;code&gt;Web开发&lt;/code&gt;&lt;/a&gt; · &lt;a href=&quot;https://nicelinks.site/tags/component&quot;&gt;&lt;code&gt;component&lt;/code&gt;&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;关键字&lt;/strong&gt;：mdx, markdown, jsx, oss, react&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;MDX allows you to use JSX in your markdown content. You can import components, such as interactive charts or alerts, and embed them within your content. This makes writing long-form content with components a blast.&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;img src=&quot;https://oss.nicelinks.site/mdxjs.com.png?x-oss-process=style/png2jpg&quot; alt=&quot;倾城之链 - Markdown for the component era | MDX&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;推荐语&lt;/strong&gt;：&lt;a href=&quot;https://nicelinks.site/redirect?url=https://mdxjs.com/&quot;&gt;MDX&lt;/a&gt; ，&lt;strong&gt;组件时代&lt;/strong&gt;的 &lt;a href=&quot;https://nicelinks.site/tags/Markdown&quot;&gt;Markdown&lt;/a&gt;，允许你在 markdown 内容中使用 JSX。您可以导入组件，例如交互式图表或警报，并将它们嵌入到您的内容中。这使得使用组件编写长篇内容成为一种乐趣。经过多年的努力，MDX 的第 2 版发布了，并且有很多改进。以下是亮点：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;❤️&lt;strong&gt;强大&lt;/strong&gt;：MDX 融合了 markdown 和 JSX 语法，完美适合基于 JSX 的项目；&lt;/li&gt;&lt;li&gt;💻&lt;strong&gt;万物皆组件&lt;/strong&gt;：在您的 MDX 中使用现有组件并将其他 MDX 文件导入为组件；&lt;/li&gt;&lt;li&gt;🔧&lt;strong&gt;可定制&lt;/strong&gt;：决定为每个 Markdown 构造呈现哪个组件 ( &lt;code&gt;{h1: MyHeading}&lt;/code&gt;)；&lt;/li&gt;&lt;li&gt;📚&lt;strong&gt;Markdown-based&lt;/strong&gt; : Markdown 的简单和优雅仍然存在，你只在你想要的时候使用 JSX；&lt;/li&gt;&lt;li&gt;🔥 非常&lt;strong&gt;快&lt;/strong&gt;：MDX 没有运行时，所有编译都发生在构建阶段；&lt;/li&gt;&lt;li&gt;📝&lt;strong&gt;改进的语法&lt;/strong&gt;使得在 JSX 中使用 markdown 更容易；&lt;/li&gt;&lt;li&gt;🧑‍💻 JavaScript 表达式变成 &lt;code&gt;{2 * Math.PI}&lt;/code&gt; 6.283185307179586；&lt;/li&gt;&lt;li&gt;🔌 新的 esbuild、Rollup 和 Node.js 集成；&lt;/li&gt;&lt;li&gt;⚛️&lt;strong&gt;任何 JSX 运行时&lt;/strong&gt;：React、Preact、Vue、Emotion，应有尽有，它们都受支持&lt;/li&gt;&lt;li&gt;🌳 改进的 AST 可以更详细地公开更多信息；&lt;/li&gt;&lt;li&gt;🏃‍♀️ 编译速度至少提高 &lt;code&gt;25%&lt;/code&gt;；&lt;/li&gt;&lt;li&gt;🚴 生成的代码运行速度是原来的两倍（快 &lt;code&gt;100%&lt;/code&gt;）；&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;Markdown 是一种轻量级标记语言（该文件后缀为 &lt;code&gt;.md&lt;/code&gt;），可用于将格式元素添加到纯文本文档，现在是世界上最流行的标记语言之一，Markdown 使在网络上写作变得快速和容易，任何人都能轻易学会。 &lt;a href=&quot;https://nicelinks.site/redirect?url=https://mdxjs.com/&quot;&gt;MDX&lt;/a&gt; （结合了 Markdown 和 JSX）允许你在 markdown 内容中使用 JSX。对于诸如强调或标题之类的常见内容，Markdown 通常感觉比 HTML 或 JSX 更自然，Markdown 通常看起来更符合预期并且更简洁，而不是 HTML；在 Web 前端项目中，尤其文档类，可以让您的工作效率、开发体验更上一层楼。&lt;/p&gt;&lt;p&gt;── 出自&lt;a href=&quot;https://nicelinks.site/post/63e4e3eee63ccd089dee6686&quot;&gt;倾城之链 - Markdown for the component era | MDX&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;标签&lt;/strong&gt;：&lt;a href=&quot;https://nicelinks.site/tags/React&quot;&gt;&lt;code&gt;React&lt;/code&gt;&lt;/a&gt; · &lt;a href=&quot;https://nicelinks.site/tags/%E6%A1%86%E6%9E%B6&quot;&gt;&lt;code&gt;框架&lt;/code&gt;&lt;/a&gt; · &lt;a href=&quot;https://nicelinks.site/tags/%E7%BD%91%E7%AB%99%E7%94%9F%E6%88%90%E5%99%A8&quot;&gt;&lt;code&gt;网站生成器&lt;/code&gt;&lt;/a&gt;&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;Make beautiful websites with Next.js &amp;amp; MDX.&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;img src=&quot;https://oss.nicelinks.site/nextra.site.png?x-oss-process=style/png2jpg&quot; alt=&quot;倾城之链 - Nextra – Next.js Static Site Generator&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;推荐语&lt;/strong&gt;：&lt;a href=&quot;https://nicelinks.site/redirect?url=https://nextra.site/&quot;&gt;Nextra&lt;/a&gt; ，基于 &lt;a href=&quot;https://nicelinks.site/post/61c928af5be6454b4e3d5146&quot;&gt;Next.js&lt;/a&gt; （ &lt;a href=&quot;https://nicelinks.site/post/5b1294b5e93ed2618cfac134&quot;&gt;React&lt;/a&gt; ） 和 &lt;a href=&quot;https://nicelinks.site/post/63e4e3eee63ccd089dee6686&quot;&gt;MDX&lt;/a&gt; 的静态网站生成器，可制作漂亮的网站；它简单、强大和灵活的站点生成框架，包含您喜欢的 Next.js 的一切。Next.js，一个用于 生产环境的 React 框架，为您提供生产所需的所有功能的最佳开发人员体验：混合静态和服务器渲染、TypeScript 支持、智能捆绑、路由预取等。无需配置。&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://nicelinks.site/redirect?url=https://nextra.site/&quot;&gt;Nextra&lt;/a&gt; 在 Next.js 基础上再封装，引入 &lt;a href=&quot;https://nicelinks.site/post/62989af00f40a860b1599de2&quot;&gt;pnpm&lt;/a&gt;、&lt;a href=&quot;https://nicelinks.site/post/5fd20cb4c06d6302c1907ec7&quot;&gt;Tailwind CSS&lt;/a&gt;、&lt;a href=&quot;https://nicelinks.site/post/63e4e3eee63ccd089dee6686&quot;&gt;MDX&lt;/a&gt;、&lt;a href=&quot;https://github.com/nextapps-de/flexsearch&quot;&gt;flexsearch&lt;/a&gt;、&lt;a href=&quot;https://nicelinks.site/post/635936a6775cbe1cdc6eb333&quot;&gt;Turbo&lt;/a&gt;、&lt;a href=&quot;https://shiki.matsu.io/&quot;&gt;Shiki&lt;/a&gt;（漂亮的语法高亮库）等，使得开发更加高效、便捷，而且对链接、图片、全文搜索、暗黑主题、多语言等做了优化，开箱即用。如果您有基于 React 搭建网站的诉求，推荐 &lt;a href=&quot;https://nicelinks.site/redirect?url=https://nextra.site/&quot;&gt;Nextra&lt;/a&gt; 进入您首选考虑范畴。&lt;/p&gt;&lt;p&gt;── 出自&lt;a href=&quot;https://nicelinks.site/post/63e4db7ee63ccd089dee6599&quot;&gt;倾城之链 - Nextra – Next.js Static Site Generator&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;标签&lt;/strong&gt;：&lt;a href=&quot;https://nicelinks.site/tags/Docker&quot;&gt;&lt;code&gt;Docker&lt;/code&gt;&lt;/a&gt; · &lt;a href=&quot;https://nicelinks.site/tags/%E5%BC%80%E6%BA%90&quot;&gt;&lt;code&gt;开源&lt;/code&gt;&lt;/a&gt; · &lt;a href=&quot;https://nicelinks.site/tags/%E5%AE%B9%E5%99%A8&quot;&gt;&lt;code&gt;容器&lt;/code&gt;&lt;/a&gt;&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;Moby is an open-source project created by Docker to enable and accelerate software containerization.&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;img src=&quot;https://oss.nicelinks.site/mobyproject.org.png?x-oss-process=style/png2jpg&quot; alt=&quot;倾城之链 - Moby Project - a collaborative project for the container ecosystem to assemble container-based systems&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;推荐语&lt;/strong&gt;：&lt;a href=&quot;https://nicelinks.site/redirect?url=https://mobyproject.org/&quot;&gt;Moby&lt;/a&gt; ，是 &lt;a href=&quot;https://nicelinks.site/tags/Docker&quot;&gt;Docker&lt;/a&gt; 创建的一个开放框架，用于组装专门的容器系统，而无需重新发明轮子。它提供了一个由数十个标准组件组成的“乐高集”，以及一个将它们组装到定制平台的框架。Moby 的核心是一个用于组装专用容器系统的框架，它提供：&lt;/p&gt;&lt;h3 id=&quot;成分components&quot;&gt;&lt;a href=&quot;#%E6%88%90%E5%88%86components&quot; aria-label=&quot;成分components permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; version=&quot;1.1&quot; viewbox=&quot;0 0 16 16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;/&gt;&lt;/svg&gt;&lt;/a&gt;成分（Components）&lt;/h3&gt;&lt;p&gt;用于容器系统所有重要方面的容器化组件库：操作系统、容器运行时、编排、基础设施管理、网络、存储、安全、构建、图像分发等。&lt;/p&gt;&lt;p&gt;将组件组装成适用于各种平台和架构的可运行工件的工具：裸机（x86 和 Arm）；适用于 Linux、Mac 和 Windows 的可执行文件；适用于流行云和虚拟化提供商的 VM 映像。&lt;/p&gt;&lt;h3 id=&quot;组件assemblies&quot;&gt;&lt;a href=&quot;#%E7%BB%84%E4%BB%B6assemblies&quot; aria-label=&quot;组件assemblies permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; version=&quot;1.1&quot; viewbox=&quot;0 0 16 16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;/&gt;&lt;/svg&gt;&lt;/a&gt;组件（Assemblies）&lt;/h3&gt;&lt;p&gt;一组参考程序集，可以按原样使用、修改或用作创建您自己的参考程序集的灵感。所有 Moby 组件都是容器，因此创建新组件就像构建新的 OCI 兼容容器一样简单。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;Moby 推荐给任何想要组装基于容器的系统的人&lt;/strong&gt;：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;想要自定义或修补其 Docker 构建的黑客；&lt;/li&gt;&lt;li&gt;构建容器系统的系统工程师或集成商；&lt;/li&gt;&lt;li&gt;希望使现有容器系统适应其环境的基础架构提供商；&lt;/li&gt;&lt;li&gt;想要尝试最新容器技术的容器爱好者；&lt;/li&gt;&lt;li&gt;希望在各种不同系统中测试其项目的开源开发人员；&lt;/li&gt;&lt;li&gt;任何对 Docker 内部结构及其构建方式感到好奇的人；&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;不建议将 Moby 用于以下用例&lt;/strong&gt;：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;正在寻找一种在容器中运行应用程序的简单方法的应用程序开发人员。我们推荐使用 Docker CE。&lt;/li&gt;&lt;li&gt;企业 IT 和开发团队正在寻找即用型、商业支持的容器平台。我们推荐使用 Docker EE。&lt;/li&gt;&lt;li&gt;任何对容器感兴趣并正在寻找一种简单的学习方法的人。我们建议改用 docker.com 网站。&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;Moby Project 面向希望修改、破解、修复、试验、发明和构建基于容器的系统的工程师、集成商和爱好者。它不是为寻找商业支持系统的人准备的，而是为想要使用开源代码工作和学习的人准备的。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;与 Docker 的关系&lt;/strong&gt;，Moby Project 中的组件和工具，最初是 Docker 和社区为 Docker Project 构建的开源组件。如果新项目符合社区目标，则可以添加新项目。Docker 致力于使用 Moby 作为 Docker 产品的上游。但是，也鼓励其他项目使用 Moby 作为上游，并以不同的方式重用组件，所有这些使用将以相同的方式处理。欢迎外部维护者和贡献者。&lt;/p&gt;&lt;p&gt;Moby 项目不是作为 Docker 产品的支持或功能请求的位置，而是作为贡献者处理开源代码、修复错误并使代码更有用的地方。这些版本仅在尽力而为的基础上得到维护者、社区和用户的支持，并不适用于需要企业或商业支持的客户；Docker EE 是适合这些用例的产品。&lt;/p&gt;&lt;p&gt;── 出自&lt;a href=&quot;https://nicelinks.site/post/63e3a8afe7eec03b5eacebff&quot;&gt;倾城之链 - Moby Project - a collaborative project for the container ecosystem to assemble container-based systems&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;标签&lt;/strong&gt;：&lt;a href=&quot;https://nicelinks.site/tags/Mac&quot;&gt;&lt;code&gt;Mac&lt;/code&gt;&lt;/a&gt; · &lt;a href=&quot;https://nicelinks.site/tags/%E5%BA%94%E7%94%A8&quot;&gt;&lt;code&gt;应用&lt;/code&gt;&lt;/a&gt; · &lt;a href=&quot;https://nicelinks.site/tags/%E5%85%8D%E8%B4%B9&quot;&gt;&lt;code&gt;免费&lt;/code&gt;&lt;/a&gt;&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;Move and resize windows in macOS using keyboard shortcuts or snap areas. The official page for Rectangle.&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;img src=&quot;https://oss.nicelinks.site/rectangleapp.com.png?x-oss-process=style/png2jpg&quot; alt=&quot;倾城之链 - Rectangle Mac&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;推荐语&lt;/strong&gt;：&lt;a href=&quot;https://nicelinks.site/redirect?url=https://rectangleapp.com/&quot;&gt;Rectangle&lt;/a&gt; 一款免费开源的 Mac 分屏软件；使用键盘快捷键或捕捉区域在 macOS 中移动和调整窗口大小。在安装和配置好 Rectangle 后，你会在菜单栏上看到它的图标，该按钮提供了常用的分屏功能，比如左右分屏、上下分屏、四角分屏、左中右分屏以及窗口大小设置等，只需要选中需要分屏的窗口，再点击相关选项就可以快速分屏。&lt;/p&gt;&lt;p&gt;你也可以使用快捷键来实现分屏，Rectangle 默认已经为每个分屏选项提供了快捷键，但是你还可以到软件的偏好设置中定制自己的快捷键；如果想要更方便地分屏，你还可以使用拖拽的方式管理分屏，将窗口拖动到屏幕边缘，Rectangle 就会自动为你分屏，还可以快速恢复原窗口。如果你需要在 Mac 上进行分屏操作，推荐尝试使用 &lt;a href=&quot;https://nicelinks.site/redirect?url=https://rectangleapp.com/&quot;&gt;Rectangle&lt;/a&gt; 。&lt;/p&gt;&lt;p&gt;── 出自&lt;a href=&quot;https://nicelinks.site/post/63e393dce7eec03b5eaceb34&quot;&gt;倾城之链 - Rectangle Mac&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;标签&lt;/strong&gt;：&lt;a href=&quot;https://nicelinks.site/tags/%E5%B9%B3%E5%8F%B0&quot;&gt;&lt;code&gt;平台&lt;/code&gt;&lt;/a&gt; · &lt;a href=&quot;https://nicelinks.site/tags/%E5%9C%A8%E7%BA%BF&quot;&gt;&lt;code&gt;在线&lt;/code&gt;&lt;/a&gt; · &lt;a href=&quot;https://nicelinks.site/tags/%E7%A4%BE%E5%8C%BA&quot;&gt;&lt;code&gt;社区&lt;/code&gt;&lt;/a&gt;&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;Building new spaces for communities that can&#x27;t share a place.&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;img src=&quot;https://oss.nicelinks.site/frond.com.png?x-oss-process=style/png2jpg&quot; alt=&quot;倾城之链 - Frond - A better way to build community online&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;推荐语&lt;/strong&gt;：&lt;a href=&quot;https://nicelinks.site/redirect?url=https://frond.com/&quot;&gt;Frond&lt;/a&gt; 是一个新的在线社区平台。因为它是从线程而不是聊天构建的，所以对话更深入、更容易跟进并自动扩展。Frond 团队相信社区是一种超级力量。无论您的目标是什么，一个有意义的社区都会让您更快地到达那里，并让旅程充满乐趣。这就是为什么他们要重新设想如何&lt;strong&gt;建立在线社区&lt;/strong&gt;。在 Frond 中设置需要几秒钟，任何人都可以通过一个简单的链接被邀请。 &lt;a href=&quot;https://nicelinks.site/redirect?url=https://frond.com/&quot;&gt;Frond&lt;/a&gt; 具备以下功能特征：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;strong&gt;提醒&lt;/strong&gt;：有每日或每周线程吗？我们的反复提醒确保对话永远不会平息。&lt;/li&gt;&lt;li&gt;&lt;strong&gt;社区模板&lt;/strong&gt;：我们知道你需要什么。一切都恰到好处，快速启动您的社区。&lt;/li&gt;&lt;li&gt;&lt;strong&gt;丰富的分享&lt;/strong&gt;：给别人发帖？照片、视频或其他任何内容的预览都会吸引他们。&lt;/li&gt;&lt;li&gt;&lt;strong&gt;管理控制&lt;/strong&gt;：通过将他们提升为管理员以获得更多控制，从您的社区获得支持。&lt;/li&gt;&lt;li&gt;&lt;strong&gt;广播&lt;/strong&gt;：你的团队住在 Slack 吗？Frond 可以自动为您分享最近活动的摘要。&lt;/li&gt;&lt;li&gt;&lt;strong&gt;整合&lt;/strong&gt;：连接 Slack 以获取通知和广播。更多集成即将推出。&lt;/li&gt;&lt;/ul&gt;&lt;h3 id=&quot;为各类社区而建&quot;&gt;&lt;a href=&quot;#%E4%B8%BA%E5%90%84%E7%B1%BB%E7%A4%BE%E5%8C%BA%E8%80%8C%E5%BB%BA&quot; aria-label=&quot;为各类社区而建 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; version=&quot;1.1&quot; viewbox=&quot;0 0 16 16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;/&gt;&lt;/svg&gt;&lt;/a&gt;为各类社区而建&lt;/h3&gt;&lt;ul&gt;&lt;li&gt;&lt;strong&gt;公司&lt;/strong&gt;：伟大的工作需要良好的关系。团队使用 Frond 来寻找他们在办公室的归属感。&lt;/li&gt;&lt;li&gt;&lt;strong&gt;创作者&lt;/strong&gt;：将您的内容转变为繁荣的社区。给你的听众一个属于自己的空间，让他们真正了解彼此。&lt;/li&gt;&lt;li&gt;&lt;strong&gt;学校&lt;/strong&gt;：为学生提供一个相互了解、提出问题、创建学习小组和放松身心的场所。&lt;/li&gt;&lt;li&gt;&lt;strong&gt;Web3&lt;/strong&gt;：你的社区就是一切，它在 Frond 中更加丰富。提出问题、分享、集思广益和消除错误。&lt;/li&gt;&lt;li&gt;&lt;strong&gt;项目&lt;/strong&gt;：一个集思广益、设定目标、回答问题和相互了解的地方。链接你的 &lt;a href=&quot;https://nicelinks.site/tags/&quot;&gt;Github&lt;/a&gt; ，它就可以开始了。&lt;/li&gt;&lt;li&gt;&lt;strong&gt;维权人士&lt;/strong&gt;：运动建立在强大的社区之上。为您的积极分子提供一个组织、分享想法并真正相互了解的场所。&lt;/li&gt;&lt;li&gt;&lt;strong&gt;顾客&lt;/strong&gt;：将最活跃的用户聚集在一起。提出问题、获得帮助、分享想法和报告错误的空间。&lt;/li&gt;&lt;li&gt;&lt;strong&gt;团队&lt;/strong&gt;：场外的朋友在这上面取得了更大的成功。谈论策略，谈论垃圾，并分享您在实践之外的身份。&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;作者对当今的社区工具感到失望：社交媒体强调我们的差异，因为它的目的是关注而不是社区。聊天工具在开始时运行良好，但随着它们的发展变得混乱和难以抗拒。并且认为社区值得更好。于是构建了 Frond——在线社区平台。&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://nicelinks.site/redirect?url=https://frond.com/&quot;&gt;Frond&lt;/a&gt; 将对话组织成线程（threads）的原因，每个线程都以比聊天更丰富的内容开始：照片、视频、链接或只是长篇写作。更好的对话，更容易理解。线程被组织成组（groups），您的社区可以随着它的发展而形成。无论是烹饪、法国新浪潮电影还是可爱的柯基犬照片，您的小组都会引发丰富的对话。值得一提的是，所有在 2023 年 4 月 30 日之前注册 Frond Beta 的社区都将永久免费访问 Frond。如果您有意搭建属于自己的社区，不妨即刻取尝试 &amp;amp; 体验。&lt;/p&gt;&lt;p&gt;── 出自&lt;a href=&quot;https://nicelinks.site/post/63e251895769b373841a6065&quot;&gt;倾城之链 - Frond - A better way to build community online&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;标签&lt;/strong&gt;：&lt;a href=&quot;https://nicelinks.site/tags/HTML&quot;&gt;&lt;code&gt;HTML&lt;/code&gt;&lt;/a&gt; · &lt;a href=&quot;https://nicelinks.site/tags/CSS&quot;&gt;&lt;code&gt;CSS&lt;/code&gt;&lt;/a&gt; · &lt;a href=&quot;https://nicelinks.site/tags/Web%E5%BC%80%E5%8F%91&quot;&gt;&lt;code&gt;Web开发&lt;/code&gt;&lt;/a&gt;&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;Library of free and customizable HTML and CSS UI elements. It&lt;code&gt;s all open-source, and it&lt;/code&gt;s all free. Try it out to save you many hours spent on building; customizing UI components for your next project.&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;img src=&quot;https://oss.nicelinks.site/uiverse.io.png?x-oss-process=style/png2jpg&quot; alt=&quot;倾城之链 - Open-Source UI elements - made with CSS and HTML&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;推荐语&lt;/strong&gt;：&lt;a href=&quot;https://nicelinks.site/redirect?url=https://uiverse.io/&quot;&gt;uiverse.io&lt;/a&gt; ，免费和可定制的 &lt;a href=&quot;https://nicelinks.site/tags/HTML&quot;&gt;HTML&lt;/a&gt; 和 &lt;a href=&quot;https://nicelinks.site/tags/CSS&quot;&gt;CSS&lt;/a&gt; UI 元素库，让您的网站更独特。涉及元素颇为丰富，涵盖卡片、开关、输入框、复选框 ☑️、加载动画、按钮（Button）等，使用非常简单，复制粘贴即可。它完全是开源的，免费供给个人和商业使用，可以给你的项目增加一些有趣的元素，为你的下一个项目节省许多花在构建和定制 UI 组件上的时间。&lt;/p&gt;&lt;p&gt;── 出自&lt;a href=&quot;https://nicelinks.site/post/63e23bda5769b373841a5fa0&quot;&gt;倾城之链 - Open-Source UI elements - made with CSS and HTML&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;标签&lt;/strong&gt;：&lt;a href=&quot;https://nicelinks.site/tags/%E6%B8%B8%E6%88%8F&quot;&gt;&lt;code&gt;游戏&lt;/code&gt;&lt;/a&gt; · &lt;a href=&quot;https://nicelinks.site/tags/%E5%BC%95%E6%93%8E&quot;&gt;&lt;code&gt;引擎&lt;/code&gt;&lt;/a&gt; · &lt;a href=&quot;https://nicelinks.site/tags/3D&quot;&gt;&lt;code&gt;3D&lt;/code&gt;&lt;/a&gt;&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;Godot provides a huge set of common tools, so you can just focus on making your game without reinventing the wheel.&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;img src=&quot;https://oss.nicelinks.site/godotengine.org.png?x-oss-process=style/png2jpg&quot; alt=&quot;倾城之链 - Godot Engine - Free and open source 2D and 3D game engine&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;推荐语&lt;/strong&gt;：&lt;a href=&quot;https://nicelinks.site/redirect?url=https://godotengine.org/&quot;&gt;Godot&lt;/a&gt; 引擎是一款免费的一体化跨平台游戏引擎，可让您轻松创建 2D 和 3D 游戏；可运行于 Windows、macOS、Linux 等多种操作系统。而其创建的游戏可运行于 PC、Android、iOS、HTML5 等平台。Godot 旨在提供另一种制作游戏的方式，&lt;/p&gt;&lt;h3 id=&quot;创新设计&quot;&gt;&lt;a href=&quot;#%E5%88%9B%E6%96%B0%E8%AE%BE%E8%AE%A1&quot; aria-label=&quot;创新设计 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; version=&quot;1.1&quot; viewbox=&quot;0 0 16 16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;/&gt;&lt;/svg&gt;&lt;/a&gt;创新设计&lt;/h3&gt;&lt;p&gt;Godot 的节点和场景系统为您提供了创建任何东西的能力和灵活性。&lt;/p&gt;&lt;h3 id=&quot;为工作使用正确的语言&quot;&gt;&lt;a href=&quot;#%E4%B8%BA%E5%B7%A5%E4%BD%9C%E4%BD%BF%E7%94%A8%E6%AD%A3%E7%A1%AE%E7%9A%84%E8%AF%AD%E8%A8%80&quot; aria-label=&quot;为工作使用正确的语言 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; version=&quot;1.1&quot; viewbox=&quot;0 0 16 16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;/&gt;&lt;/svg&gt;&lt;/a&gt;为工作使用正确的语言&lt;/h3&gt;&lt;p&gt;使用 Godot 自己的 GDScript、C#、C++ 或使用 GDNative 自带的面向对象的 API 使您的代码模块化。&lt;/p&gt;&lt;h3 id=&quot;专用二维引擎&quot;&gt;&lt;a href=&quot;#%E4%B8%93%E7%94%A8%E4%BA%8C%E7%BB%B4%E5%BC%95%E6%93%8E&quot; aria-label=&quot;专用二维引擎 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; version=&quot;1.1&quot; viewbox=&quot;0 0 16 16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;/&gt;&lt;/svg&gt;&lt;/a&gt;专用二维引擎&lt;/h3&gt;&lt;p&gt;使用 Godot 的专用 2D 渲染引擎和真正的 2D 像素坐标和 2D 节点制作清晰和高性能的 2D 游戏。&lt;/p&gt;&lt;h3 id=&quot;简单而强大的-3d&quot;&gt;&lt;a href=&quot;#%E7%AE%80%E5%8D%95%E8%80%8C%E5%BC%BA%E5%A4%A7%E7%9A%84-3d&quot; aria-label=&quot;简单而强大的 3d permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; version=&quot;1.1&quot; viewbox=&quot;0 0 16 16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;/&gt;&lt;/svg&gt;&lt;/a&gt;简单而强大的 3D&lt;/h3&gt;&lt;p&gt;Godot 的 3D 节点为您提供构建、动画和渲染 3D 世界和角色所需的一切。&lt;/p&gt;&lt;h3 id=&quot;在所有平台上发布&quot;&gt;&lt;a href=&quot;#%E5%9C%A8%E6%89%80%E6%9C%89%E5%B9%B3%E5%8F%B0%E4%B8%8A%E5%8F%91%E5%B8%83&quot; aria-label=&quot;在所有平台上发布 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; version=&quot;1.1&quot; viewbox=&quot;0 0 16 16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;/&gt;&lt;/svg&gt;&lt;/a&gt;在所有平台上发布&lt;/h3&gt;&lt;p&gt;在几秒钟内将您的游戏部署到桌面、移动设备和 Web 上。Godot 甚至通过第三方发行商支持控制台。&lt;/p&gt;&lt;h3 id=&quot;开源&quot;&gt;&lt;a href=&quot;#%E5%BC%80%E6%BA%90&quot; aria-label=&quot;开源 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; version=&quot;1.1&quot; viewbox=&quot;0 0 16 16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;/&gt;&lt;/svg&gt;&lt;/a&gt;开源&lt;/h3&gt;&lt;p&gt;真正开放的开发：任何为 Godot 做出贡献的人都可以从他人的贡献中平等受益。&lt;/p&gt;&lt;p&gt;Godot 内置的 GDScript 脚本语言是一种高级动态类型编程语言，语法与 Python 类似。与 Python 不同，GDScript 是针对 Godot 的场景架构设计的，一个文件就是一个类，并且可以为变量限定类型。开发 GDScript 之前，Godot 的开发者尝试使用过 Lua、Python、Squirrel 等第三方脚本语言，但最终为了优化和编辑器集成选择使用自定义的语言。&lt;/p&gt;&lt;p&gt;Godot 最初于 2007 年开始开发，2014 年 12 月 15 日，Godot 迎来了首个稳定版本 1.0；2016 年 2 月 24 日上架 Steam；2023 年 2 月，Godot 4.0 版本发布。从宏观上看，Godot 与 &lt;a href=&quot;https://nicelinks.site/post/60f8020181b2dc066ea4bd73&quot;&gt;Unity&lt;/a&gt;、Unreal 尚有差距，但颇受开发者好评，如果您对其感兴趣，不妨前往官网了解更多。&lt;/p&gt;&lt;p&gt;── 出自&lt;a href=&quot;https://nicelinks.site/post/63e0ffe75769b373841a5526&quot;&gt;倾城之链 - Godot Engine - Free and open source 2D and 3D game engine&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;标签&lt;/strong&gt;：&lt;a href=&quot;https://nicelinks.site/tags/%E6%B8%B8%E6%88%8F&quot;&gt;&lt;code&gt;游戏&lt;/code&gt;&lt;/a&gt; · &lt;a href=&quot;https://nicelinks.site/tags/%E5%BC%95%E6%93%8E&quot;&gt;&lt;code&gt;引擎&lt;/code&gt;&lt;/a&gt; · &lt;a href=&quot;https://nicelinks.site/tags/3D&quot;&gt;&lt;code&gt;3D&lt;/code&gt;&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;关键字&lt;/strong&gt;：Digital content development, game engine, native game development, WeChat mini-game production, H5 game development, introduction to game development, real-time 3D rendering, AR&amp;amp;VR content development, virtual character, smart city, smart cockpit, IoT, HMI, digital twin, Smart Education, Smart Fitness, Metaverse, 2D&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;The world&#x27;s top lightweight, efficient, cross-platform digital content development platform can meet different development needs for 3D, 2D, AR&amp;amp;VR and other unique content creation, and can provide complete solutions in frontier fields such as smart cockpit, digital twin, virtual character, and smart education industry solutions.&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;img src=&quot;https://oss.nicelinks.site/www.cocos.com.png?x-oss-process=style/png2jpg&quot; alt=&quot;倾城之链 - Cocos - The world&#x27;s top 2D&amp;amp;3D engine, game / smart cockpit /AR/VR/ virtual character / education&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;推荐语&lt;/strong&gt;： &lt;a href=&quot;https://nicelinks.site/redirect?url=https://www.cocos.com/&quot;&gt;Cocos&lt;/a&gt; 是由厦门雅基软件有限公司推出的数字内容开发一站式解决方案，具备开源、免费、轻量、高性能等特点，服务了 2D 和 3D 游戏开发、智能座舱、在线教育、XR、数字人、数字孪生、数字文创等领域开发者。Cocos 在全球 203 个国家和地区，拥有 150 万开发者，覆盖全球超过 16 亿终端用户。&lt;/p&gt;&lt;p&gt;Cocos 成立于 2010 年，核心产品包括开源引擎框架 Cocos2d-x、编辑器 Cocos Creator、游戏加速框架 Cocos Runtime、智能座舱解决方案 Cocos HMI、互动课件编辑器 Cocos ICE、XR 方向创作工具 Cocos Creator XR 等等。Cocos 产品具有以下优势：&lt;/p&gt;&lt;h3 id=&quot;游戏开发一站式解决方案低成本高效率&quot;&gt;&lt;a href=&quot;#%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91%E4%B8%80%E7%AB%99%E5%BC%8F%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%E4%BD%8E%E6%88%90%E6%9C%AC%E9%AB%98%E6%95%88%E7%8E%87&quot; aria-label=&quot;游戏开发一站式解决方案低成本高效率 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; version=&quot;1.1&quot; viewbox=&quot;0 0 16 16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;/&gt;&lt;/svg&gt;&lt;/a&gt;&lt;strong&gt;游戏开发一站式解决方案，低成本、高效率&lt;/strong&gt;&lt;/h3&gt;&lt;p&gt;Cocos 提供了全套的引擎和开发工具，涵盖从前期设计、资源制作、开发调试、打包上线全套的解决方案。cocos 重点优化了工作流，规范了整个游戏开发流程，降低沟通成本，提高开发效率。&lt;/p&gt;&lt;h3 id=&quot;高性能一次制作多终端平台共享&quot;&gt;&lt;a href=&quot;#%E9%AB%98%E6%80%A7%E8%83%BD%E4%B8%80%E6%AC%A1%E5%88%B6%E4%BD%9C%E5%A4%9A%E7%BB%88%E7%AB%AF%E5%B9%B3%E5%8F%B0%E5%85%B1%E4%BA%AB&quot; aria-label=&quot;高性能一次制作多终端平台共享 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; version=&quot;1.1&quot; viewbox=&quot;0 0 16 16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;/&gt;&lt;/svg&gt;&lt;/a&gt;&lt;strong&gt;高性能，一次制作，多终端平台共享&lt;/strong&gt;&lt;/h3&gt;&lt;p&gt;Cocos 不断的优化游戏性能，以保证高帧速率下可以获得更华丽的效果；即使是千元低端机，运行华丽特效丝毫不卡顿，让您的游戏可以得到尽情的发挥。&lt;/p&gt;&lt;p&gt;跨平台特性确保一次制作，全平台支持。无需为后期移植耗尽人力和时间，极大的降低了时间成本，确保游戏不会错过珍贵的黄金上线档期&lt;/p&gt;&lt;h3 id=&quot;windows-与-mac-同步发布更新团队协作更容易&quot;&gt;&lt;a href=&quot;#windows-%E4%B8%8E-mac-%E5%90%8C%E6%AD%A5%E5%8F%91%E5%B8%83%E6%9B%B4%E6%96%B0%E5%9B%A2%E9%98%9F%E5%8D%8F%E4%BD%9C%E6%9B%B4%E5%AE%B9%E6%98%93&quot; aria-label=&quot;windows 与 mac 同步发布更新团队协作更容易 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; version=&quot;1.1&quot; viewbox=&quot;0 0 16 16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;/&gt;&lt;/svg&gt;&lt;/a&gt;&lt;strong&gt;Windows 与 Mac 同步发布更新，团队协作更容易&lt;/strong&gt;&lt;/h3&gt;&lt;p&gt;目前大部分开发团队根据不同需求会在不同的操作系统下工作，而一套可以运行在多个平台的游戏引擎显得至关重要。Cocos 同时支持 Windows 和 Mac 操作系统，功能完全同步。提升团队协作便捷性，不再为了配合而频繁的切换系统或者使用双系统。&lt;/p&gt;&lt;h3 id=&quot;插件商店素材丰富游戏开发更灵活更便捷&quot;&gt;&lt;a href=&quot;#%E6%8F%92%E4%BB%B6%E5%95%86%E5%BA%97%E7%B4%A0%E6%9D%90%E4%B8%B0%E5%AF%8C%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91%E6%9B%B4%E7%81%B5%E6%B4%BB%E6%9B%B4%E4%BE%BF%E6%8D%B7&quot; aria-label=&quot;插件商店素材丰富游戏开发更灵活更便捷 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; version=&quot;1.1&quot; viewbox=&quot;0 0 16 16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;/&gt;&lt;/svg&gt;&lt;/a&gt;&lt;strong&gt;插件商店，素材丰富，游戏开发更灵活更便捷&lt;/strong&gt;&lt;/h3&gt;&lt;p&gt;Cocos 开放了强大的扩展功能并推出了 Cocos Store，提供了插件、资源、工具、素材等丰富的资源，为用户的开发提供了更大的灵活性。Cocos Store 将为用户提供了一个自由的平台，连接全球的开发者，用户可以获得和分享自己的成果。&lt;/p&gt;&lt;h3 id=&quot;同步支持-2d-和-3d满足全方位开发需求&quot;&gt;&lt;a href=&quot;#%E5%90%8C%E6%AD%A5%E6%94%AF%E6%8C%81-2d-%E5%92%8C-3d%E6%BB%A1%E8%B6%B3%E5%85%A8%E6%96%B9%E4%BD%8D%E5%BC%80%E5%8F%91%E9%9C%80%E6%B1%82&quot; aria-label=&quot;同步支持 2d 和 3d满足全方位开发需求 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; version=&quot;1.1&quot; viewbox=&quot;0 0 16 16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;/&gt;&lt;/svg&gt;&lt;/a&gt;&lt;strong&gt;同步支持 2D 和 3D，满足全方位开发需求&lt;/strong&gt;&lt;/h3&gt;&lt;p&gt;Cocos Creator 支持 2D、3D 方面的游戏开发，基于华为提供的延迟渲染管线，可以为开发者提供高品质美术创作。具有可满足开发者各种游戏类型特定需求的功能，并且优化了纯 2D 游戏的编辑器使用体验和引擎性能，内建了 Spine、DragonBones、TiledMap、Box2D 和 Texture Packer 等 2D 开发中间件的支持。&lt;/p&gt;&lt;p&gt;2022 年 4 月，Cocos 宣布完成 5000 万美元 B 轮融资，投资方为建信信托、GGV 纪源资本、声网 Agora 等。本轮融资后，Cocos 将借助资本的助力，持续提升引擎核心技术，促进引擎进一步与游戏、汽车、教育、XR、家居设计、建筑工程设计等场景的结合，Cocos 也坚持将每年的利润全部投入引擎功能研发、新场景拓展、生态建设上，持续为开发者提供更便捷的创作工具，为跨行业的客户带来可靠的技术解决方案和提供更多元的产品与服务。&lt;/p&gt;&lt;p&gt;── 出自&lt;a href=&quot;https://nicelinks.site/post/63e0f4695769b373841a54aa&quot;&gt;倾城之链 - Cocos - The world&#x27;s top 2D&amp;amp;3D engine, game / smart cockpit /AR/VR/ virtual character / education&lt;/a&gt;&lt;/p&gt;&lt;p&gt;对倾城之链感兴趣的朋友，可通过 Web，小程序，快应用等渠道进行访问(后续将支持更多，如 VsCode 插件，Chrome 扩展等)。您有任何问题，欢迎随时向我们反馈（您可以通过官网反馈渠道，或添加如下客服微信），🤲 。&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;https://image.nicelinks.site/%E5%80%BE%E5%9F%8E%E4%B9%8B%E9%93%BE-%E5%BE%AE%E4%BF%A1-mini.jpeg&quot; alt=&quot;倾城之链 - 客服微信&quot;/&gt;&lt;/p&gt;&lt;h2 id=&quot;本期文末寄语&quot;&gt;&lt;a href=&quot;#%E6%9C%AC%E6%9C%9F%E6%96%87%E6%9C%AB%E5%AF%84%E8%AF%AD&quot; aria-label=&quot;本期文末寄语 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; version=&quot;1.1&quot; viewbox=&quot;0 0 16 16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;/&gt;&lt;/svg&gt;&lt;/a&gt;本期文末寄语&lt;/h2&gt;&lt;p&gt;圣人无常师。孔子师郯子、苌弘、师襄、老聃。郯子之徒，其贤不及孔子。孔子曰：三人行，则必有我师。&lt;strong&gt;是故弟子不必不如师，师不必贤于弟子，闻道有先后，术业有专攻，如是而已&lt;/strong&gt;。── 唐朝 · 韩愈《师说》&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;&lt;a href=&quot;https://nicelinks.site/?utm_source=weekly&quot;&gt;倾城之链&lt;/a&gt;作为一个开放平台，旨在云集全球&lt;strong&gt;优秀网站&lt;/strong&gt;，探索互联网中更广阔的世界；在这里，你可以轻松发现、学习、分享更多有用或有趣的事物。&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;img src=&quot;https://image.nicelinks.site/nicelinks-miniprogram-code.jpeg?imageView2/1/w/250/h/250/interlace/1/ignore-error/1&quot; alt=&quot;小程序码 - 倾城之链&quot;/&gt;&lt;/p&gt;&lt;h2 id=&quot;您可能感兴趣的文章&quot;&gt;&lt;a href=&quot;#%E6%82%A8%E5%8F%AF%E8%83%BD%E6%84%9F%E5%85%B4%E8%B6%A3%E7%9A%84%E6%96%87%E7%AB%A0&quot; aria-label=&quot;您可能感兴趣的文章 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; version=&quot;1.1&quot; viewbox=&quot;0 0 16 16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;/&gt;&lt;/svg&gt;&lt;/a&gt;您可能感兴趣的文章&lt;/h2&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>ba6a3768103a6f870b429183bdcfc4cf</guid>
<title>在 4G 内存的机器上，申请 8G 内存会怎么样？</title>
<link>https://toutiao.io/k/tznheo5</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot; data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;大家好，我是田螺。&lt;/p&gt;&lt;section&gt;&lt;mp-common-profile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mpprofile&quot; data-weui-theme=&quot;light&quot; data-id=&quot;Mzg3NTY2NDMwMQ==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/iaPU220ia3N7QfHsbKk3mGa1lsrNh9kID5jJsopIGBnric9v4xKcFOv50y6N3A3CVRteuJ9tQI0IAIh37R3dpvGog/0?wx_fmt=png&quot; data-nickname=&quot;程序员田螺&quot; data-alias=&quot;&quot; data-signature=&quot;专注分享后端面试题，包括计算机网络、MySql数据库、Redis缓存、操作系统、Java后端、大厂面试真题等领域。&quot; data-from=&quot;0&quot; data-is_biz_ban=&quot;0&quot;/&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这篇文章其实之前发过，但是最近有位读者跟我反馈，我文章中的实验在 64 位操作系统、2 G 物理内存的场景，申请 8G 内存是没问题的，而他也是这个环境，为什么他就无法申请成功呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;然后，我帮他排查了下，原来是跟 Linux 的 overcommit_memory 参数有关，这个参数主要是定义进程申请的内存收否允许激进。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;然后这位读者很用心，写了个 world 文档总结我和他交流的过程。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.9851258581235698&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZcoxxWCYHT1TIPmRm6fc0ecyzu4FoiaOpo3OZNsnphRlwOxnVFdrkdib92OpiayT9o9AKP1J43mtyRZQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1748&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我现在把这部分内容也补充了进来，相比以前的文章会更全面了一些。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;废话不多说，发车辣！&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.8020833333333334&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZcoxxWCYHT1TIPmRm6fc0ecalTd5aPGyf0dthKl9QYTm5Fx4NACDzfnMRH83EGmdSI3YfYkeiaYzNA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;576&quot;/&gt;&lt;/figure&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;正文&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;看到读者在群里讨论这些面试题：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.9181585677749361&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZcoxxWCYHT1TIPmRm6fc0ecAd4UfefyD3KtLpsvqPc0Qy13BaQXMzxhKGDOib88Fl02hD9DrTFEfsg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;782&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其中，第一个问题「&lt;strong&gt;在 4GB 物理内存的机器上，申请 8G 内存会怎么样？&lt;/strong&gt;」存在比较大的争议，有人说会申请失败，有的人说可以申请成功。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个问题在没有前置条件下，就说出答案就是耍流氓。这个问题要考虑三个前置条件：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;操作系统是 32 位的，还是 64 位的？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;申请完 8G 内存后会不会被使用？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;操作系统有没有使用 Swap 机制？&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以，我们要分场景讨论。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;操作系统虚拟内存大小&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;应用程序通过 malloc 函数申请内存的时候，实际上申请的是虚拟内存，此时并不会分配物理内存。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当应用程序读写了这块虚拟内存，CPU 就会去访问这个虚拟内存， 这时会发现这个虚拟内存没有映射到物理内存， CPU 就会产生&lt;strong&gt;缺页中断&lt;/strong&gt;，进程会从用户态切换到内核态，并将缺页中断交给内核的 Page Fault Handler （缺页中断函数）处理。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;缺页中断处理函数会看是否有空闲的物理内存：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;如果有，就直接分配物理内存，并建立虚拟内存与物理内存之间的映射关系。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;如果没有空闲的物理内存，那么内核就会开始进行回收内存的工作，如果回收内存工作结束后，空闲的物理内存仍然无法满足此次物理内存的申请，那么内核就会放最后的大招了触发 OOM （Out of Memory）机制。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;32 位操作系统和 64 位操作系统的虚拟地址空间大小是不同的，在 Linux 操作系统中，虚拟地址空间的内部又被分为&lt;strong&gt;内核空间和用户空间&lt;/strong&gt;两部分，如下所示：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.3846855059252507&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZcoxxWCYHT1TIPmRm6fc0ecibyDI7O9QmicQwibibrGPQjjrmu55PWoUPPNPl1dJfqxzuWBoMPichZbZbA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1097&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;通过这里可以看出：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;32&lt;/code&gt; 位系统的内核空间占用 &lt;code&gt;1G&lt;/code&gt;，位于最高处，剩下的 &lt;code&gt;3G&lt;/code&gt; 是用户空间；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;64&lt;/code&gt; 位系统的内核空间和用户空间都是 &lt;code&gt;128T&lt;/code&gt;，分别占据整个内存空间的最高和最低处，剩下的中间部分是未定义的。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;32 位操作系统的场景&lt;/span&gt;&lt;/h3&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;现在可以回答这个问题了：在 32 位操作系统、4GB 物理内存的机器上，申请 8GB 内存，会怎么样？&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;因为 32 位操作系统，进程最多只能申请 3 GB 大小的虚拟内存空间，所以进程申请 8GB 内存的话，在申请虚拟内存阶段就会失败（我手上没有 32 位操作系统测试，我估计失败的错误是 cannot allocate memory，也就是无法申请内存失败）。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;64 位操作系统的场景&lt;/span&gt;&lt;/h3&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;在 64 位操作系统、4GB 物理内存的机器上，申请 8G 内存，会怎么样？&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;64 位操作系统，进程可以使用 128 TB 大小的虚拟内存空间，所以进程申请 8GB 内存是没问题的，因为进程申请内存是申请虚拟内存，只要不读写这个虚拟内存，操作系统就不会分配物理内存。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们可以简单做个测试，我的服务器是 64 位操作系统，但是物理内存只有 2 GB：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.13376623376623376&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZcoxxWCYHT1TIPmRm6fc0ecsSSH5gBQibiaJEp0KsPz73icIr17nJmu4hGV9b59QO2Joowz2hm5VXumA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1540&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;现在，我在机器上，连续申请 4 次 1 GB 内存，也就是一共申请了 4 GB 内存，&lt;span&gt;注意下面代码只是单纯分配了虚拟内存，并没有使用该虚拟内存&lt;/span&gt;：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;#&lt;span&gt;include&lt;/span&gt; &lt;span&gt;&amp;lt;stdio.h&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;#&lt;span&gt;include&lt;/span&gt; &lt;span&gt;&amp;lt;stdlib.h&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;#&lt;span&gt;include&lt;/span&gt; &lt;span&gt;&amp;lt;string.h&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;#&lt;span&gt;include&lt;/span&gt; &lt;span&gt;&amp;lt;errno.h&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;#&lt;span&gt;define&lt;/span&gt; MEM_SIZE 1024 * 1024 * 1024&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;int&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;char&lt;/span&gt;* addr[&lt;span&gt;4&lt;/span&gt;];&lt;br/&gt;    &lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;;&lt;br/&gt;    &lt;span&gt;for&lt;/span&gt;(i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; &lt;span&gt;4&lt;/span&gt;; ++i) {&lt;br/&gt;        addr[i] = (&lt;span&gt;char&lt;/span&gt;*) &lt;span&gt;malloc&lt;/span&gt;(MEM_SIZE);&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt;(!addr[i]) {&lt;br/&gt;            &lt;span&gt;printf&lt;/span&gt;(&lt;span&gt;&quot;执行 malloc 失败, 错误：%s\n&quot;&lt;/span&gt;,strerror(errno));&lt;br/&gt;          &lt;span&gt;return&lt;/span&gt; &lt;span&gt;-1&lt;/span&gt;;&lt;br/&gt;        }&lt;br/&gt;        &lt;span&gt;printf&lt;/span&gt;(&lt;span&gt;&quot;主线程调用malloc后，申请1gb大小得内存，此内存起始地址：0X%p\n&quot;&lt;/span&gt;, addr[i]);&lt;br/&gt;    }&lt;br/&gt;    &lt;br/&gt;    &lt;span&gt;//输入任意字符后，才结束&lt;/span&gt;&lt;br/&gt;    getchar();&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;然后运行这个代码，可以看到，我的物理内存虽然只有 2GB，但是程序正常分配了 4GB 大小的虚拟内存：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.20496894409937888&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZcoxxWCYHT1TIPmRm6fc0ec0HYQvxhRCvHMwibJLcnzQXskClWxXH3z57zdr7yxBZqHTQmrbnwMV7g/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1288&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们可以通过下面这条命令查看进程（test）的虚拟内存大小：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; ps aux | grep &lt;span&gt;test&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;USER       PID %CPU %MEM    VSZ   RSS TTY      STAT START   TIME COMMAND&lt;br/&gt;root      7797  0.0  0.0 4198540  352 pts/1    S+   16:58   0:00 ./test&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其中，VSZ 就代表进程使用的虚拟内存大小，RSS 代表进程使用的物理内存大小。可以看到，VSZ 大小为 4198540，也就是 4GB 的虚拟内存。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;开头说的读者跟我反馈，说他自己也做了这个实验，然后发现 64 位操作系统、2G 物理内存的机子上，在申请 4GB 虚拟内存的时候失败了，这是为什么呢？&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;失败的错误：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.07112526539278131&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZcoxxWCYHT1TIPmRm6fc0ec39nvuHYV23k13fgGUWicIlzHm5UXicDZaVibGoVZYNQoIj5SZRDO8J4vg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;942&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我当时帮他排查了下，发现跟 Linux 中的 overcommit_memory 参数有关，可以使用 &lt;code&gt;cat /proc/sys/vm/overcommit_memory&lt;/code&gt; 来查看这个参数，这个参数接受三个值：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;如果值为 0（默认值），代表：Heuristic overcommit handling，它允许overcommit，但过于明目张胆的 overcommit 会被拒绝，比如malloc一次性申请的内存大小就超过了系统总内存。Heuristic的意思是“试探式的”，内核利用某种算法猜测你的内存申请是否合理，大概可以理解为单次申请不能超过free memory + free swap + pagecache的大小 + SLAB中可回收的部分 ，超过了就会拒绝overcommit。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;如果值为 1，代表：Always overcommit. 允许overcommit，对内存申请来者不拒。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;如果值为 2，代表：Don’t overcommit. 禁止overcommit。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当时那位读者的 overcommit_memory 参数是默认值 0 ，所以申请失败的原因可能是内核认为我们申请的内存太大了，它认为不合理，所以 malloc() 返回了 Cannot allocate memory 错误，这里申请 4GB 虚拟内存失败的同学可以将这个 overcommit_memory 设置为1，就可以 overcommit 了。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;echo 1 &amp;gt; /proc/sys/vm/overcommit_memory &lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;设置完为 1 后，读者的机子就可以正常申请 4GB 虚拟内存了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.18947368421052632&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZcoxxWCYHT1TIPmRm6fc0ecqnSicrHW5ubvhU2prdj7fVpdUF0JHmibH5miaFDXJFFAtXZTeu7w2V80Q/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;950&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;span&gt;不过我的环境 &lt;span&gt;overcommit_memory 是 0，在 64 系统、2 G 物理内存场景下，也是可以成功申请 4 G 内存的，我怀疑可能是不同版本的内核在 &lt;span&gt;overcommit_memory 为 0 时，检测内存申请是否合理的算法可能是不同的。&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;span&gt;总之，如果你申请大内存的时候，不想被内核检测内存申请是否合理的算法干扰的话，将 overcommit_memory 设置为 1 就行。&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;/&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;那么将这个 overcommit_memory 设置为 1 之后，64 位的主机就可以申请接近 128T 虚拟内存了吗？&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;不一定，还得看你服务器的物理内存大小。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;读者的服务器物理内存是 2 GB，实验后发现，进程还没有申请到 128T 虚拟内存的时候就被杀死了。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.4245709123757904&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZcoxxWCYHT1TIPmRm6fc0ecjNuVxBOPlGJ7HzAibYK0AHia7ibcxmz8D7WMXNic0RZZ0wRc4tLNbaAomQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1107&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;注意，这次是 killed，而不是 Cannot Allocate Memory，说明并不是内存申请有问题，而是触发 OOM 了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但是为什么会触发 OOM 呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那得看你的主机的「物理内存」够不够大了，即使 malloc 申请的是虚拟内存，只要不去访问就不会映射到物理内存，但是申请虚拟内存的过程中，还是使用到了物理内存（比如内核保存虚拟内存的数据结构，也是占用物理内存的），如果你的主机是只有 2GB 的物理内存的话，大概率会触发 OOM。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可以使用 top 命令，点击两下 m，通过进度条观察物理内存使用情况。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.1086398631308811&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZcoxxWCYHT1TIPmRm6fc0ecibcHsfT7MlFAmJgLPj17CtTUiclLiaiaqXxuw8pJMv2ibTZSIdrvKiadTN6g/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1169&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可以看到申请虚拟内存的过程中&lt;strong&gt;物理内存使用量一直在增长&lt;/strong&gt;。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.06429192006950478&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZcoxxWCYHT1TIPmRm6fc0ec7Ok2BKu4wrJXPdxoX6jI4VRUk7p0y8lAia6Dvd1d1xlUz8nTu9mjfiaA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1151&quot;/&gt;&lt;/figure&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.0636672325976231&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZcoxxWCYHT1TIPmRm6fc0ec0VCazAPwdkGH9baSOuwiawXAiaWom6doJqDHaOib0YEegvGbzksmCFjYw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1178&quot;/&gt;&lt;/figure&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.05736301369863014&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZcoxxWCYHT1TIPmRm6fc0ec4f0l2clbdx9b4os5tfIbM0kHicJrDN5ZicnkG9kOWJBNUChk7rZCe5zA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1168&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;直到直接内存回收之后，也无法回收出一块空间供这个进程使用，这个时候就会触发 OOM，给所有能杀死的进程打分，分数越高的进程越容易被杀死。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在这里当然是这个进程得分最高，那么操作系统就会将这个进程杀死，所以最后会出现 killed，而不是Cannot allocate memory。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;那么 2GB 的物理内存的 64 位操作系统，就不能申请128T的虚拟内存了吗？&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其实可以，上面的情况是还没开启 swap 的情况。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;使用 swapfile 的方式开启了 1GB 的 swap 空间之后再做实验：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.10577777777777778&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZcoxxWCYHT1TIPmRm6fc0ecxHSIviaGBGmNE6oPyGMp1dg0GgaDfdrMlMcClxIaHT5o6XZgcHib9oiag/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1125&quot;/&gt;&lt;/figure&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5283926852743022&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZcoxxWCYHT1TIPmRm6fc0ecQsIJXwc3YjJdsaR42hfkkr7ibZDaVflWicTSIaOwtGZkI6XHrQxqs4MA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1039&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;发现出现了 Cannot allocate memory，但是其实到这里已经成功了，&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;打开计算器计算一下，发现已经申请了 127.998T 虚拟内存了。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.3052109181141439&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZcoxxWCYHT1TIPmRm6fc0ecjaqIJ72icOl8rIAhpr9tGmqRhQv9SVwSKQNQerUf748svVwoicX8Qu6A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;403&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;实际上我们是不可能申请完整个 128T 的用户空间的，因为程序运行本身也需要申请虚拟空间&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;申请 127T 虚拟内存试试：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.40971585701191565&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZcoxxWCYHT1TIPmRm6fc0eclrON8lDwjoY88V6q3FciaoOO5B8UP3wWkSYMAAd0e7OdwXU0YdkOR2A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1091&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;发现进程没有被杀死，也没有 Cannot allocate memory，也正好是 127T 虚拟内存空间。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.5161290322580645&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZcoxxWCYHT1TIPmRm6fc0ecI72V1chdoAKjtsmxWDfXzgjibeJHRG7RBZ4r0Kkq6n6WvVcLIicuhTFg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;186&quot; class=&quot;rich_pages wxw-img&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在 top 中我们可以看到这个申请了127T虚拟内存的进程。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.16129032258064516&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZcoxxWCYHT1TIPmRm6fc0ecLcPibbUjwlK0cgyyXJibU4VLgGqGqEicFGfDluiaqPXWydlUqmOXrqcCNQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1178&quot;/&gt;&lt;/figure&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;Swap 机制的作用&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;前面讨论在 32 位/64 位操作系统环境下，申请的虚拟内存超过物理内存后会怎么样？&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;在 32 位操作系统，因为进程最大只能申请 3 GB 大小的虚拟内存，所以直接申请 8G 内存，会申请失败。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;在 64 位操作系统，因为进程最大只能申请 128 TB 大小的虚拟内存，即使物理内存只有 4GB，申请 8G 内存也是没问题，因为申请的内存是虚拟内存。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;程序申请的虚拟内存，如果没有被使用，它是不会占用物理空间的。当访问这块虚拟内存后，操作系统才会进行物理内存分配。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果申请物理内存大小超过了空闲物理内存大小，就要看操作系统有没有开启 Swap 机制：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;如果没有开启 Swap 机制，程序就会直接 OOM；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;如果有开启 Swap 机制，程序可以正常运行。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;什么是 Swap 机制？&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当系统的物理内存不够用的时候，就需要将物理内存中的一部分空间释放出来，以供当前运行的程序使用。那些被释放的空间可能来自一些很长时间没有什么操作的程序，这些被释放的空间会被临时保存到磁盘，等到那些程序要运行时，再从磁盘中恢复保存的数据到内存中。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;另外，当内存使用存在压力的时候，会开始触发内存回收行为，会把这些不常访问的内存先写到磁盘中，然后释放这些内存，给其他更需要的进程使用。再次访问这些内存时，重新从磁盘读入内存就可以了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这种，将内存数据换出磁盘，又从磁盘中恢复数据到内存的过程，就是 Swap 机制负责的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Swap 就是把一块磁盘空间或者本地文件，当成内存来使用，它包含换出和换入两个过程：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;换出（Swap Out）&lt;/strong&gt; ，是把进程暂时不用的内存数据存储到磁盘中，并释放这些数据占用的内存；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;换入（Swap In）&lt;/strong&gt;，是在进程再次访问这些内存的时候，把它们从磁盘读到内存中来；&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Swap 换入换出的过程如下图：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6095305832147937&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZcoxxWCYHT1TIPmRm6fc0ecp9CWO1dLo8hJDQbkOjpQgf73kD6MRMQpylJlE1UpnjDLXQR87rCoog/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1406&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;使用 Swap 机制优点是，应用程序实际可以使用的内存空间将远远超过系统的物理内存。由于硬盘空间的价格远比内存要低，因此这种方式无疑是经济实惠的。当然，频繁地读写硬盘，会显著降低操作系统的运行速率，这也是 Swap 的弊端。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Linux 中的 Swap 机制会在内存不足和内存闲置的场景下触发：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;内存不足&lt;/strong&gt;：当系统需要的内存超过了可用的物理内存时，内核会将内存中不常使用的内存页交换到磁盘上为当前进程让出内存，保证正在执行的进程的可用性，这个内存回收的过程是强制的直接内存回收（Direct Page Reclaim）。直接内存回收是同步的过程，会阻塞当前申请内存的进程。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;内存闲置&lt;/strong&gt;：应用程序在启动阶段使用的大量内存在启动后往往都不会使用，通过后台运行的守护进程（kSwapd），我们可以将这部分只使用一次的内存交换到磁盘上为其他内存的申请预留空间。kSwapd 是 Linux 负责页面置换（Page replacement）的守护进程，它也是负责交换闲置内存的主要进程，它会在时，回收内存页中的空闲内存保证系统中的其他进程可以尽快获得申请的内存。kSwapd 是后台进程，所以回收内存的过程是异步的，不会阻塞当前申请内存的进程。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Linux 提供了两种不同的方法启用 Swap，分别是 Swap 分区（Swap Partition）和 Swap 文件（Swapfile）：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;Swap 分区是硬盘上的独立区域，该区域只会用于交换分区，其他的文件不能存储在该区域上，我们可以使用 &lt;code&gt;swapon -s&lt;/code&gt; 命令查看当前系统上的交换分区；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Swap 文件是文件系统中的特殊文件，它与文件系统中的其他文件也没有太多的区别；&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;Swap 换入换出的是什么类型的内存？&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;内核缓存的文件数据，因为都有对应的磁盘文件，所以在回收文件数据的时候， 直接写回到对应的文件就可以了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但是像进程的堆、栈数据等，它们是没有实际载体，这部分内存被称为匿名页。而且这部分内存很可能还要再次被访问，所以不能直接释放内存，于是就需要有一个能保存匿名页的磁盘载体，这个载体就是 Swap 分区。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;匿名页回收的方式是通过 Linux 的 Swap 机制，Swap 会把不常访问的内存先写到磁盘中，然后释放这些内存，给其他更需要的进程使用。再次访问这些内存时，重新从磁盘读入内存就可以了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;接下来，通过两个实验，看看申请的物理内存超过物理内存会怎样？&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;实验一：没有开启 Swap 机制&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;实验二：有开启 Swap 机制&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;实验一：没有开启 Swap 机制&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我的服务器是 64 位操作系统，但是物理内存只有 2 GB，而且没有 Swap 分区：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.13376623376623376&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZcoxxWCYHT1TIPmRm6fc0ecsSSH5gBQibiaJEp0KsPz73icIr17nJmu4hGV9b59QO2Joowz2hm5VXumA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1540&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们改一下前面的代码，使得在申请完 4GB 虚拟内存后，通过 memset 函数访问这个虚拟内存，看看在没有 Swap 分区的情况下，会发生什么？&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;#&lt;span&gt;include&lt;/span&gt; &lt;span&gt;&amp;lt;stdio.h&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;#&lt;span&gt;include&lt;/span&gt; &lt;span&gt;&amp;lt;stdlib.h&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;#&lt;span&gt;include&lt;/span&gt; &lt;span&gt;&amp;lt;string.h&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;#&lt;span&gt;include&lt;/span&gt; &lt;span&gt;&amp;lt;errno.h&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;#&lt;span&gt;define&lt;/span&gt; MEM_SIZE 1024 * 1024 * 1024&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;int&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;char&lt;/span&gt;* addr[&lt;span&gt;4&lt;/span&gt;];&lt;br/&gt;    &lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;;&lt;br/&gt;    &lt;span&gt;for&lt;/span&gt;(i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; &lt;span&gt;4&lt;/span&gt;; ++i) {&lt;br/&gt;        addr[i] = (&lt;span&gt;char&lt;/span&gt;*) &lt;span&gt;malloc&lt;/span&gt;(MEM_SIZE);&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt;(!addr[i]) {&lt;br/&gt;            &lt;span&gt;printf&lt;/span&gt;(&lt;span&gt;&quot;执行 malloc 失败, 错误：%s\n&quot;&lt;/span&gt;,strerror(errno));&lt;br/&gt;            &lt;span&gt;return&lt;/span&gt; &lt;span&gt;-1&lt;/span&gt;;&lt;br/&gt;        }&lt;br/&gt;        &lt;span&gt;printf&lt;/span&gt;(&lt;span&gt;&quot;主线程调用malloc后，申请1gb大小得内存，此内存起始地址：0X%p\n&quot;&lt;/span&gt;, addr[i]);&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;for&lt;/span&gt;(i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; &lt;span&gt;4&lt;/span&gt;; ++i) {&lt;br/&gt;        &lt;span&gt;printf&lt;/span&gt;(&lt;span&gt;&quot;开始访问第 %d 块虚拟内存(每一块虚拟内存为 1 GB)\n&quot;&lt;/span&gt;, i + &lt;span&gt;1&lt;/span&gt;);&lt;br/&gt;        &lt;span&gt;memset&lt;/span&gt;(addr[i], &lt;span&gt;0&lt;/span&gt;, MEM_SIZE);&lt;br/&gt;    }&lt;br/&gt;    &lt;br/&gt;    &lt;span&gt;//输入任意字符后，才结束&lt;/span&gt;&lt;br/&gt;    getchar();&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;运行结果：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.25877192982456143&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZcoxxWCYHT1TIPmRm6fc0ecDyWgvIFI9IYOEGCd371Lw7XbM4C2TnBuUE1IChB9gWo46bicb2iaoKkQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1368&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可以看到，在访问第 2 块虚拟内存（每一块虚拟内存是 1 GB）的时候，因为超过了机器的物理内存（2GB），进程（test）被操作系统杀掉了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;通过查看 message 系统日志，可以发现该进程是被操作系统 OOM killer 机制杀掉了，日志里报错了 Out of memory，也就是发生 OOM（内存溢出错误）。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.07548701298701299&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZcoxxWCYHT1TIPmRm6fc0ecC645GCiaIF6IzVJKbAtSF31O3Lr3Qia07j560ry1jszru1g9Ty3PZzjA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2464&quot; class=&quot;rich_pages wxw-img&quot;/&gt;&lt;/figure&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;什么是 OOM?&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;内存溢出(Out Of Memory，简称OOM)是指应用系统中存在无法回收的内存或使用的内存过多，最终使得程序运行要用到的内存大于能提供的最大内存。此时程序就运行不了，系统会提示内存溢出。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;实验二：有开启 Swap 机制&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我用我的 mac book pro 笔记本做测试，我的笔记本是 64 位操作系统，物理内存是 8 GB， 目前 Swap 分区大小为 1 GB（&lt;em&gt;注意，这个大小不是固定不变的，Swap 分区总大小是会动态变化的，当没有使用 Swap 分区时，Swap 分区总大小是 0；当使用了 Swap 分区，Swap 分区总大小会增加至 1 GB；当 Swap 分区已使用的大小超过 1 GB 时；Swap 分区总大小就会增加到至 2 GB；当 Swap 分区已使用的大小超过 2 GB 时；Swap 分区总大小就增加至 3GB，如此往复。这个估计是 macos 自己实现的，Linux 的分区则是固定大小的，Swap 分区不会根据使用情况而自动增长&lt;/em&gt;）。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.23342175066312998&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZcoxxWCYHT1TIPmRm6fc0ecEbgw4QIicdUBc5T3ge4iaLicqgMiabniaNtuDwZDzCkqHBQsBCmsgU25icFQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;3016&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;为了方便观察磁盘 I/O 情况，我们改进一下前面的代码，分配完 32 GB虚拟内存后（笔记本物理内存是 8 GB），通过一个 while 循环频繁访问虚拟内存，代码如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;#&lt;span&gt;include&lt;/span&gt; &lt;span&gt;&amp;lt;stdio.h&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;#&lt;span&gt;include&lt;/span&gt; &lt;span&gt;&amp;lt;stdlib.h&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;#&lt;span&gt;include&lt;/span&gt; &lt;span&gt;&amp;lt;string.h&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;#&lt;span&gt;define&lt;/span&gt; MEM_SIZE 32 * 1024 * 1024 * 1024&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;int&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;char&lt;/span&gt;* addr = (&lt;span&gt;char&lt;/span&gt;*) &lt;span&gt;malloc&lt;/span&gt;((&lt;span&gt;long&lt;/span&gt;)MEM_SIZE);&lt;br/&gt;    &lt;span&gt;printf&lt;/span&gt;(&lt;span&gt;&quot;主线程调用malloc后，目前共申请了 32gb 的虚拟内存\n&quot;&lt;/span&gt;);&lt;br/&gt;    &lt;br/&gt;    &lt;span&gt;//循环频繁访问虚拟内存&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;while&lt;/span&gt;(&lt;span&gt;1&lt;/span&gt;) {&lt;br/&gt;          &lt;span&gt;printf&lt;/span&gt;(&lt;span&gt;&quot;开始访问 32gb 大小的虚拟内存...\n&quot;&lt;/span&gt;);&lt;br/&gt;          &lt;span&gt;memset&lt;/span&gt;(addr, &lt;span&gt;0&lt;/span&gt;, (&lt;span&gt;long&lt;/span&gt;)MEM_SIZE);&lt;br/&gt;    }&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;运行结果如下：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5410526315789473&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZcoxxWCYHT1TIPmRm6fc0ecib7UYic109Ic6XMx9fpITmtO544tmn2cYibPdaRF8ADArE7KqmjlSpRsQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;950&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可以看到，在有 Swap 分区的情况下，即使笔记本物理内存是 8 GB，申请并使用 32 GB 内存是没问题，程序正常运行了，并没有发生 OOM。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;从下图可以看到，进程的内存显示 32 GB（这个不要理解为占用的物理内存，理解为已被访问的虚拟内存大小，也就是在物理内存呆过的内存大小），系统已使用的 Swap 分区达到 2.3 GB。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.29236641221374043&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZcoxxWCYHT1TIPmRm6fc0ecHiaQiceJVZ70acicnOTco6vaLoqaUOSRwyUO0dGKuVgt71AS03ibWJdGLg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2620&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;此时我的笔记本电脑的磁盘开始出现“沙沙”的声音，通过查看磁盘的 I/O 情况，可以看到磁盘 I/O 达到了一个峰值，非常高：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5122615803814714&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZcoxxWCYHT1TIPmRm6fc0ec6lM9GcZJCoReKtx7lVuSRasic4gvow5tsKhPDuBWEB4hJ7QbLYD2MlA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1468&quot;/&gt;&lt;/figure&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;有了 Swap 分区，是不是意味着进程可以使用的内存是无上限的？&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当然不是。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我把上面的代码改成了申请 64GB 内存后，当进程申请完 64GB 虚拟内存后，使用到 56 GB （这个不要理解为占用的物理内存，理解为已被访问的虚拟内存大小，也就是在物理内存呆过的内存大小）的时候，进程就被系统 kill 掉了，如下图：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.2524719841793013&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZcoxxWCYHT1TIPmRm6fc0eclf5MbcdQAVl8Sw6JPaOwcSXF58agj6XeU8mfRjSFibkUPE6ia4fXc77A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;3034&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当系统多次尝试回收内存，还是无法满足所需使用的内存大小，进程就会被系统 kill 掉了，意味着发生了 OOM。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;总结&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;至此， 验证完成了。简单总结下：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;在 32 位操作系统，因为进程理论上最大能申请 3 GB 大小的虚拟内存，所以直接申请 8G 内存，会申请失败，报错 Cannot allocate memory&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;在 64位 位操作系统，因为进程理论上最大能申请 128 TB 大小的虚拟内存，即使物理内存只有 4GB，申请 8G 内存也是没问题，因为申请的内存是虚拟内存。如果这块虚拟内存被访问了，要看系统有没有 Swap 分区：&lt;/section&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;如果没有 Swap 分区，因为物理空间不够，进程会被操作系统杀掉，原因是 OOM（内存溢出）；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;如果有 Swap 分区，即使物理内存只有 4GB，程序也能正常使用 8GB 的内存，进程可以正常运行；&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;完！&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;溜啦溜啦！&lt;/p&gt;&lt;section&gt;&lt;mp-common-profile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mpprofile&quot; data-weui-theme=&quot;light&quot; data-id=&quot;Mzg3NTY2NDMwMQ==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/iaPU220ia3N7QfHsbKk3mGa1lsrNh9kID5jJsopIGBnric9v4xKcFOv50y6N3A3CVRteuJ9tQI0IAIh37R3dpvGog/0?wx_fmt=png&quot; data-nickname=&quot;程序员田螺&quot; data-alias=&quot;&quot; data-signature=&quot;专注分享后端面试题，包括计算机网络、MySql数据库、Redis缓存、操作系统、Java后端、大厂面试真题等领域。&quot; data-from=&quot;0&quot; data-is_biz_ban=&quot;0&quot;/&gt; &lt;span/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>d537d0e2ff3d4bf0ba2ffe27a11c8543</guid>
<title>一分钟读论文：《基于 ChatGPT、AR 和 Voicebots 的儿童外教软件设计框架》</title>
<link>https://toutiao.io/k/lynpu1m</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;article class=&quot;article-post&quot;&gt;                
&lt;p&gt;ChatGPT 催生了很多教育领域的创业项目，欧盟大约有&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;2600万4到8岁的儿童，美国大约有1700万4到8岁的儿童&lt;/code&gt;，外语软件将服务于数百万家庭。美国的佛罗里达理工大学与南佛罗里达大学合著的论文&lt;a href=&quot;https://dergipark.org.tr/en/download/article-file/2864638&quot;&gt;《Framework for A Foreign Language Teaching Software for Children Utilizing AR, Voicebots and ChatGPT (Large Language Models)》&lt;/a&gt;设计出一个框架，用于利用 AR+Voicebots+ChatGPT 技术开发语言学习软件，框架遵循了⼉童外语教学的设计原则：&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;游戏化、社交互动、惊喜奖励&lt;/code&gt;。利用论文中提到的技术平台，开发人员、研究人员和企业家能够比以往更快地实现产品化，本设计框架和设计原则可以成为开发高效外语教学软件的蓝图。&lt;/p&gt;

&lt;h2 id=&quot;设计框架的构成&quot;&gt;设计框架的构成&lt;/h2&gt;



&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;增强现实 (AR)&lt;/code&gt;：AR 将计算机⽣成的数据（图像、声⾳等）叠加到⽤⼾视图，向其中添加数字信息层来增强⽤⼾对现实世界的感知。可以使⽤多种 AR 框架（例如 ARCore、ARKit 或 Vuforia）将 AR 技术嵌⼊到移动应⽤程序中。&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;语音机器人（Voicebots）&lt;/code&gt;：用于语⾳转⽂本或⽂本转语⾳。可以使用聊天机器⼈平台：Dialogflow、IBM Watson Assistant、Amazon Lex、 ManyChat、Chatfuel 、Wit.ai 、MindMeld、Chatbot 、Azure Bot Service。&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ChatGPT（大型语言模型 AI）&lt;/code&gt;：设计对话是⼀项⾮常重要、具有挑战性且耗时的任务，为了克服内容生成的任务，建议&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;利用 ChatGPT 创建内容&lt;/code&gt;。测试表明 ChatGPT 有助于学习外语的对话。在教授外语时，特别是对于年幼的孩子，一些最初的对话和主题是自我介绍，以及关于动物、食物、车辆、家庭成员、身体部位、车辆、职业等的对话。通过提供对高质量、定制化和个性化语言学习材料的访问，ChatGPT 可能彻底改变语言的教学和学习方式。&lt;/li&gt;
&lt;/ul&gt;



&lt;h2 id=&quot;references&quot;&gt;References&lt;/h2&gt;


                
&lt;/article&gt;


&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>13d1c75e7501b848856e5527eb352593</guid>
<title>vivo 自研 Jenkins 资源调度系统设计与实践</title>
<link>https://toutiao.io/k/rabkeyv</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;作者：vivo 互联网服务器团队- Wu Qinghua&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;本文从目前业界实现Jenkins的高可用的实现方案，分析各方案的优缺点，引入vivo目前使用的Jenkins高可用方案，以及目前Jenkins资源的调度方案的设计实践和目前的落地运行效果。&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;一、前言&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;现在的企业很多都在用Jenkins做持续集成，各个业务端都依靠Jenkins，vivo Devops也是使用Jenkins来进行持续构建，部署Jenkins服务时如何保障服务的高可用变得尤为重要。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;下面是目前Jenkins存在的&lt;strong&gt;一些问题&lt;/strong&gt;。&lt;/p&gt;&lt;ol class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;Jenkins本身是单体的，即只能有一个Jenkins Master。虽然你也可以在多台机器上部署多个Jenkins Master，但这些Master之间没有联系，都是各自把任务交给手下的slave去执行，没有任何交集。&lt;br/&gt;也许某个master下的slave很忙，而另一个master下的slave却很闲，资源得不到充分利用。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt; 当其中一个slave宕机之后，该slave上的运行的job任务没有版本重新进行分配，需要用户重新执行。并且slave节点离线之后没有通知管理员。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt; 当系统业务量比较大的时候业务请求集中在Jenkins Master上，会对Jenkins造成压力，甚至的造成Jenkins服务不可用。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt; 当有job任务在jenkins Master上队列排队的时候，Jenkins Master宕机后，队列任务不可持久化。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;Jenkins Workspace没有自动清理功能，会导致磁盘空间不足，任务执行不了的情况。&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;基于以上情况，vivo Devops对Jenkins的部署架构进行优化搭建，并且配套了一套Jenkins资源调度系统用于管理Jenkins资源。&lt;/p&gt;&lt;/section&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;二、业界实现&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;目前业界也包含一些Jenkins 高可用的设计方式，但是并不能完全的满足解决上述问题，比如：&lt;/p&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;span&gt;2.1 方案一  Gearman + Jenkins&lt;/span&gt;&lt;/p&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;这是OpenStack团队使用的方案。这个方案使用了gearman， gearman是个任务分发框架。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;需要在每个Master上安装好gearman的插件，并配置好能连接到gearman server，同时在每个Master必须建立相同的job。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;之后运行任务的流程如下：&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;ol class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;gearman worker运行在各个Jenkins Master中等待gearman server分发任务；&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;gearman client向gearman server发出运行job的请求；&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;gearman server通知各个gearman worker有任务拉，第一个闲着的worker会接受任务，如果所有的worker都忙，则放入gearman的任务队列，得worker空闲时再分配；&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;gearman worker闲下来后会从任务队列里取job来执行，执行完之后，将结果发回给gearman server;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;gearman server将结果返回给 gearman client。&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;优点：&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;这样各个salver资源可以得到充分利用，某个master挂掉另外的master可以继续服务。&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;弊端：&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;每个master的slave必须配置一致，否则会造成job调度错误，同时会造成一些资源的浪费。当一个master出现问题，该master的任务不会进行自动重新分配。&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;span&gt;2.2 方案二 改造Jenkins的文件存储方式&lt;/span&gt;&lt;/p&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;目前Jenkins的配置文件都是直接在硬盘上以文件形式存储的，你在JENKINS_HOME的个文件夹下能看到各种.xml文件。有些公司在Jenkins上进行二次开发，将Jenkins的数据存储方式改为数据库存储，这样前端可以起多个Jenkins服务，后端连相同的数据库即可。数据库也有比较成熟的高可用方案。&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;优点:   &lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;可以达到Jenkins的高可用也就是某个master挂掉另外的master可以继续服务。&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;弊端：&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;需要对Jenkins进行二次开发，使用数据库会降低读取资源效率下降。&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;span&gt;2.3 方案三 最简单的Jenkins一主一备模式&lt;/span&gt;&lt;/p&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;平时让Jenkins A机器提供服务，并使用SCM Sync configuration plugin保存数据，JenkinsA机器修改配置后触发Jenkins B更新配置，一旦Jenkins A出现问题挂掉后，切换到备机Jenkins B上。&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;优点:   &lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;可以达到Jenkins的高可用，当master宕机后会进行切换到备机上。&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;弊端:   &lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;会有一批Jenkins备机存在资源浪费，切换master时间过长，会导致有段时间Jenkins服务不可用。&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;三、vivo Jenkins Scheduler系统目标&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;由于目前业界的一些实现还不能完全的满足我们目前的需求，所以我们进行了vivo jenkins scheduler系统的设计与实现。该系统需要达到如下的目的：&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;ol class=&quot;list-paddingleft-1&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;提升整个构建服务可靠性时长。&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;保证jenkins集群的高可用，解决目前master-slave的单点问题，保证整个构建服务的可靠性时长。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;降低灾难时服务恢复时长。&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;①提供精准流控方式，在jenkins构建出现请求量过高的时候可以进行流控和持久化操作，减少对目前系统的冲击。&lt;/p&gt;&lt;p&gt;②当系统压力减少后，放开流控可以快速的对堆积的请求进行分配执行。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;有效分配任务至各个子节点，&lt;/strong&gt;保证资源的有效利用。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;能保证灾难时的及时切换任务至可用节点上&lt;/strong&gt;，同时能快速的通知管理员进行处理。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;能进行数据的可视化分析&lt;/strong&gt;，能提供一系列帮助改善开发效率的视图，比如构建时长报表、构建量报表等。&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;/section&gt;&lt;/section&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;四、 vivo Jenkins Scheduler设计&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;该系统我们从两大部分进行了设计，首先，我们不采用原生的Jenkins部署方案，而是采用全master的方式。第二，设计并开发了一套用于管理Jenkins集群的调度系统。&lt;/p&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;五、底层 Jenkins 工具部署方案&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;不采用目前单master的搭建方案，采用多master的搭建方案，master下不进行挂载slave机器，任务直接有master进行处理，master之间的关系、任务分配、离线、插件安装等由调度系统进行管理。这样由于vivo Jenkins Scheduler系统为高可用的，解决了目前Jenkins的单点问题。&lt;/p&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.3152454780361757&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/4g5IMGibSxt5lGq6ANkkk43WQxTP2ZeMOfELzyGicZm3vt3ARysZg4CZvwhRiay4qLgRtyqSK4kL3LIcPVuYCu6nA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1161&quot;/&gt;&lt;/p&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;六、系统架构图&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.8890625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/4g5IMGibSxt5lGq6ANkkk43WQxTP2ZeMOhLWNyqcLItVW8tGPuWasbwADuDc7grPic4d4pS59LSbnKdN3H4OQ4lg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;七、系统说明&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;span&gt;7.1 API-Gateway&lt;/span&gt;&lt;/p&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;主要提供系统的外部请求，网关系统，功能包含：&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;ul class=&quot;list-paddingleft-1&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;权限校验：&lt;/strong&gt;校验用户发送集群管理系统的请求的权限。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;智能路由：&lt;/strong&gt;接收外部一切请求，并转发到后端的外服上去。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;限流：&lt;/strong&gt;与监控线程配合（当构建请求达到某个阈值时），进行限流操作。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;API日志统一收集：&lt;/strong&gt;类似于一个aspect切面，记录接口的进入和出去时的相关日志。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;数据处理：&lt;/strong&gt;对请求的参数进行数据的转换处理。&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/section&gt;&lt;/section&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;span&gt;7.2 事件中心&lt;/span&gt;&lt;/p&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;是整个系统通信调用的主要模块，采用的是Spring的Event机制实现，主要核心事件如下：&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;ol class=&quot;list-paddingleft-1&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;Jenkins注册事件&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;（EVENT_REGIST_JENKINS）&lt;/strong&gt;：&lt;/p&gt;&lt;p&gt;Jenkins启动后，通过自定的插件会向系统发送注册请求时，系统接收到后会触发Jenkins管理模块将Jenkins的信息注册至调度系统中。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;Jenkins宕机事件 &lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;(EVENT_DOWN_JENKINS)  &lt;/strong&gt;  : &lt;/p&gt;&lt;p&gt;监控管理轮询检查Jenkins状态，当发现有Jenkins宕机的情况会触发该事件，Jenkins管理模块处理将Jenkins的信息状态设置为不可用状态，从而是任务不能分配至该台jenkins。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;任务从分配事件  (EVENT_JOB_REDO) &lt;/strong&gt;: &lt;/p&gt;&lt;p&gt;当Jenkins宕机后，如果该台jenkins上存在未执行完的任务时候，由job监控模块触发，job管理莫管处理，会对该Jenkins上未执行的job进行重新分配。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;任务接受事件  (EVENT_JOB_RECIVE) &lt;/strong&gt;:&lt;/p&gt;&lt;p&gt;当job管理模块接受到创建请求，会触发该事件，由job管理模块放入Redis执行队列。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;任务执行事件  (EVENT_JOB_EXECUTE)&lt;/strong&gt; : &lt;/p&gt;&lt;p&gt;job管理模块中的执行线程(10s执行一次，会从Redis队列中弹出任务)，弹出任务后触发该事件，由调度中心选取合适的jenkins进行执行。&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;/section&gt;&lt;/section&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;span&gt;7.3 调度中心&lt;/span&gt;&lt;/p&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;是整个系统的核心模块，主要的功能是进行执行job时候能选取合适的jenkins进行处理任务，包含两个核心算法：&lt;/p&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;strong&gt;7.3.1 Jenkins分组算法&lt;/strong&gt;&lt;/p&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;每台jenkins都可以使用标签的方式，打上多个标签，比如jenkins可以构建java程序，使用的构建工具可以是maven和gradle，这个时候我们就可以给其打上java、maven、gradle三个标签。&lt;/p&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;标签的维度主要有以下几个：&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;ul class=&quot;list-paddingleft-1&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;标签配置：&lt;/strong&gt; 判断构建配置是否配置了标签，根据标签选择对应标签的Jenkins，比如配置了（docker等）。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;构建语言：&lt;/strong&gt; 根据构建配置的语言，比如Java、C++、Python、Go等。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;构建工具和版本：&lt;/strong&gt; 比如Maven、gradle、Ant，Cmark、Blade等。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;JDK版本：&lt;/strong&gt;比如JDK7、JDK8等。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;Go语言版本：&lt;/strong&gt;比如1.15.x.、1.16.x等。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;GCC版本：&lt;/strong&gt;如6.x、4.x等。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;Python版本：&lt;/strong&gt;2.x、3.x等。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;是否存活：&lt;/strong&gt;判断Jenkins是否存活，如果宕机直接过滤。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;（可选策略）选择执行过该job的Jenkins，减少下载代码的过程：&lt;/strong&gt;（第一次构建还是会比较慢，可以采用预执行的方式，在配置构建配置的时候，就预先执行一次，这样在用户执行的时候就使用该job执行过得workspace，减少代码下载的时间）。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;（可选策略）根据job的构建的平均构建时长&lt;/strong&gt;，如果构建时长达到某个配置阈值时，优先选择构建器空闲多的Jenkins进行执行，并指出Jenkins的锁定功能。其他的job不允许分配上来。&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/section&gt;&lt;/section&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;如果我们给Jenkins打上标签，那么我们就可以使用标签为维度将Jenkins进行分组，并且存入至Redis中缓存，方便后续选取Jenkins用来执行任务：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.7863974495217854&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/4g5IMGibSxt5lGq6ANkkk43WQxTP2ZeMOdrvAxTSUEbLHP3891voKcP7UF4RWC3Ucb2dDPQOkd70aWHbiaAW9RlA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;941&quot;/&gt;&lt;/p&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;strong&gt;7.3.2 Jenkins选取算法&lt;/strong&gt;&lt;/p&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;当Jenkins分组好了后，我们接受到执行的job的信息就可以使用Jenkins选取算法进行快速的选取合适的Jenkins进行处理job，如下图所示。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;其中label子线程、语言子线程……就是我们上面的Jenkins分组的维度，有多少维度，那么这里就会有多少子线程处理。&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;构建任务进入主线程，然后主线程会按照分组维度分组操作并进行过滤，然后获取到每个分组中合适的Jenkins，再进行取交集（这个时候就获取到可以执行该构建任务的Jenkins了），在判断是否需要经过可选策略，最终得到Jenkins。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.3453125&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/4g5IMGibSxt5lGq6ANkkk43WQxTP2ZeMOeIPanOVOWBVIZfj97lzFZIQNOr8VVsCXk2Pzpy4NfFZSEyOkH7iaffA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;span&gt;7.4 流控管理&amp;amp;队列管理&lt;/span&gt;&lt;/p&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;调度系统中的的任务接受采用的是队列的方式实现，当系统请求量达到阀后，系统将不会进入Redis队列，会将请求持久化至MySQL。后续如果有请求过来，job管理模块会检查数据库MySQL中是否有请求，如果有请求，会将请求放入Redis队列，如果没有请求就会将当前请求放入Redis队列，具体流程如下:&lt;/p&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.6336633663366337&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/4g5IMGibSxt5lGq6ANkkk43WQxTP2ZeMO8I13p8QEzY9cSevRhQlH75KYVSfhdQeyONdJ7picFMfpDc6Kb5DibBNA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;909&quot;/&gt;&lt;/p&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;其中基于Redis实现的消息队列的时序图如下:&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.7989371124889283&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/4g5IMGibSxt5lGq6ANkkk43WQxTP2ZeMOBZ2OgtE2H2PGXkpFSetfLpmI5EGdwZiatqciaVC1xNoj1bZh4C4cHCiaw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1129&quot;/&gt;&lt;/p&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;span&gt;7.5 回调中心&lt;/span&gt;&lt;/p&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;该模块主要是监控任务的状态，当任务开始执行、中断执行、执行成功、执行失败的时候进行通知业务并存储数据，用于保存构建记录，方便后续数据的统计，用来完成数据的可视化。&lt;/p&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;八、实施效果&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;目前该系统已经投入生产环境运行，Jenkins任务已采用调度系统进行调度执行，运行稳定，运行效果。&lt;/p&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.2859375&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/4g5IMGibSxt5lGq6ANkkk43WQxTP2ZeMOhAQENsicRlYaYuYC4QfkUsQQYnUVMDYkDHfYXe4KskRtJgic3bpvrHug/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.24140625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/4g5IMGibSxt5lGq6ANkkk43WQxTP2ZeMOX8YZCZeoGicNYgKS8E31sQ6GkF8gdibaM583vLNicNswehTRIpwDqiaRibw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;九、后续展望&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;随着vivo Jenkins 调度系统的功能慢慢完善，Jenkins的机器也越来越多，目前还大多数运行在虚拟机上，从资源利用率和业务发布效率来看，未来的业务发布形态将会是以容器为主。目前公司也在大力发展k8s的容器生态建设，&lt;/p&gt;&lt;p&gt;所以我们希望将Jenkins工具后期进行容器化、池化，在提高资源利用率和发布效率的同时也可以为用户提供可靠的、简洁的、稳定调度执行。&lt;/p&gt;&lt;/section&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;END&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;span title=&quot;&quot; opera-tn-ra-cell=&quot;_$.pages:0.layers:0.comps:104.title1&quot;&gt;&lt;p&gt;猜你喜欢&lt;/p&gt;&lt;/span&gt; &lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;section&gt;&lt;mp-common-profile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mpprofile&quot; data-weui-theme=&quot;light&quot; data-id=&quot;MzI4NjY4MTU5Nw==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/4g5IMGibSxt45QXJZicZ9gaNU2mRSlvqhQd94MJ7oQh4QFj1ibPV66xnUiaKoicSatwaGXepL5sBDSDLEckicX1ttibHg/0?wx_fmt=png&quot; data-nickname=&quot;vivo互联网技术&quot; data-alias=&quot;vivoVMIC&quot; data-signature=&quot;分享 vivo 互联网技术干货与沙龙活动，推荐最新行业动态与热门会议。&quot; data-from=&quot;0&quot; data-is_biz_ban=&quot;0&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>