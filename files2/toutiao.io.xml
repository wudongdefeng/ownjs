<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>83bb711977ba61d026d9a9924fab4094</guid>
<title>Mybatis 源码解析之执行 SQL 语句</title>
<link>https://toutiao.io/k/nigmnmf</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;RichText ztext Post-RichText css-4em6pe&quot; options=&quot;[object Object]&quot;&gt;&lt;h2 data-first-child=&quot;&quot;&gt;mybatis 操作数据库的过程&lt;/h2&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;// 第一步：读取mybatis-config.xml配置文件
InputStream inputStream = Resources.getResourceAsStream(&quot;mybatis-config.xml&quot;);
// 第二步：构建SqlSessionFactory(框架初始化)
SqlSessionFactory sqlSessionFactory = new  SqlSessionFactoryBuilder().bulid();
// 第三步：打开sqlSession
SqlSession session = sqlSessionFactory.openSession();
// 第四步：获取Mapper接口对象（底层是动态代理）
AccountMapper accountMapper = session.getMapper(AccountMapper.class);
// 第五步：调用Mapper接口对象的方法操作数据库;
Account account = accountMapper.selectByPrimaryKey(1);&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p data-pid=&quot;VMjL_AT7&quot;&gt;通过调用 session.getMapper (AccountMapper.class) 所得到的 AccountMapper 是一个动态代理对象，所以执行&lt;br/&gt;accountMapper.selectByPrimaryKey (1) 方法前，都会被 invoke () 拦截，先执行 invoke () 中的逻辑。&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
    try {
        //  要执行的方法所在的类如果是Object,直接调用，不做拦截处理
        if (Object.class.equals(method.getDeclaringClass())) {
            return method.invoke(this, args);
            //如果是默认方法，也就是java8中的default方法
        } else if (isDefaultMethod(method)) {
            // 直接执行default方法
            return invokeDefaultMethod(proxy, method, args);
        }
    } catch (Throwable t) {
        throw ExceptionUtil.unwrapThrowable(t);
    } 
    // 从缓存中获取MapperMethod
    final MapperMethod mapperMethod = cachedMapperMethod(method);
    return mapperMethod.execute(sqlSession, args);
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p data-pid=&quot;nPvwxgBB&quot;&gt;&lt;b&gt;从 methodCache 获取对应 DAO 方法的 MapperMethod&lt;/b&gt;&lt;/p&gt;&lt;p data-pid=&quot;iMS4X_W8&quot;&gt;MapperMethod 的主要功能是执行 SQL 语句的相关操作，在初始化的时候会实例化两个对象：SqlCommand（Sql 命令）和 MethodSignature（方法签名）。&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;/**
   * 根据Mapper接口类型、接口方法、核心配置对象 构造MapperMethod对象
   * @param mapperInterface
   * @param method
   * @param config
   */
  public MapperMethod(Class&amp;lt;?&amp;gt; mapperInterface, Method method, Configuration config) {
    this.command = new SqlCommand(config, mapperInterface, method);
    // 将Mapper接口中的数据库操作方法(如Account selectById(Integer id);)封装成方法签名MethodSignature
    this.method = new MethodSignature(config, mapperInterface, method);
  }&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p data-pid=&quot;xkx-qY4P&quot;&gt;&lt;b&gt;new SqlCommand（）调用 SqlCommand 类构造方法：&lt;/b&gt;&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;public SqlCommand(Configuration configuration, Class&amp;lt;?&amp;gt; mapperInterface, Method method) {
      // 获取Mapper接口中要执行的某个方法的方法名
      // 如accountMapper.selectByPrimaryKey(1)
      final String methodName = method.getName();
      // 获取方法所在的类
      final Class&amp;lt;?&amp;gt; declaringClass = method.getDeclaringClass();
      // 解析得到Mapper语句对象(对配置文件中的&amp;lt;mapper&amp;gt;&amp;lt;/mapper&amp;gt;中的sql语句进行封装)
      MappedStatement ms = resolveMappedStatement(mapperInterface, methodName, declaringClass,
          configuration);
      if (ms == null) {
        if (method.getAnnotation(Flush.class) != null) {
          name = null;
          type = SqlCommandType.FLUSH;
        } else {
          throw new BindingException(&quot;Invalid bound statement (not found): &quot;
              + mapperInterface.getName() + &quot;.&quot; + methodName);
        }
      } else {
        // 如com.bjpowernode.mapper.AccountMapper.selectByPrimaryKey
        name = ms.getId();
        // SQL类型：增 删 改 查
        type = ms.getSqlCommandType();
        if (type == SqlCommandType.UNKNOWN) {
          throw new BindingException(&quot;Unknown execution method for: &quot; + name);
        }
      }
    }
private MapperMethod cachedMapperMethod(Method method) {
     MapperMethod mapperMethod = (MapperMethod)this.methodCache.get(method);
     if (mapperMethod == null) {
         mapperMethod = new MapperMethod(this.mapperInterface, method, this.sqlSession.getConfiguration());
         this.methodCache.put(method, mapperMethod);
     }
     return mapperMethod;
 }&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p data-pid=&quot;q1s5Th9V&quot;&gt;&lt;b&gt;调用 mapperMethod.execute (sqlSession, args)&lt;/b&gt;&lt;/p&gt;&lt;p data-pid=&quot;_xCHRh5N&quot;&gt;在 mapperMethod.execute () 方法中，我们可以看到：mybatis 定义了 5 种 SQL 操作类型：&lt;br/&gt;insert/update/delete/select/flush。其中，select 操作类型又可以分为五类，这五类的返回结果都不同，分别对应：&lt;/p&gt;&lt;p data-pid=&quot;qgnpI4gk&quot;&gt;・返回参数为空：executeWithResultHandler ()；&lt;/p&gt;&lt;p data-pid=&quot;qjt1glL9&quot;&gt;・查询多条记录：executeForMany ()，返回对象为 JavaBean&lt;/p&gt;&lt;p data-pid=&quot;nsh-zzUy&quot;&gt;・返参对象为 map：executeForMap ()， 通过该方法查询数据库，最终的返回结果不是 JavaBean，而是 Map&lt;/p&gt;&lt;p data-pid=&quot;Tn70HQcE&quot;&gt;・游标查询：executeForCursor ()；关于什么是游标查询，自行百度哈；&lt;/p&gt;&lt;p data-pid=&quot;e-eV3cTz&quot;&gt;・查询单条记录： sqlSession.selectOne ()，通过该查询方法，最终只会返回一条结果；&lt;/p&gt;&lt;p data-pid=&quot;nWMmChWC&quot;&gt;通过源码追踪我们可以不难发现：当调用 mapperMethod.execute () 执行 SQL 语句的时候，无论是&lt;br/&gt;insert/update/delete/flush，还是 select（包括 5 种不同的 select）, 本质上时通过 sqlSession 调用的。在 SELECT 操作中，虽然调用了 MapperMethod 中的方法，但本质上仍是通过 Sqlsession 下的 select (), selectList (), selectCursor (), selectMap () 等方法实现的。&lt;/p&gt;&lt;p data-pid=&quot;TO0wVZi9&quot;&gt;而 SqlSession 的内部实现，最终是调用执行器 Executor（后面会细说）。这里，我们可以先大概看一下 mybatis 在执行 SQL 语句的时候的调用过程：&lt;/p&gt;&lt;p class=&quot;ztext-empty-paragraph&quot;&gt;&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-8b38085659c0b595710e67a50ccc42ea_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;640&quot; data-rawheight=&quot;111&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic3.zhimg.com/v2-8b38085659c0b595710e67a50ccc42ea_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;640&quot; data-rawheight=&quot;111&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic3.zhimg.com/v2-8b38085659c0b595710e67a50ccc42ea_r.jpg&quot; data-actualsrc=&quot;https://pic3.zhimg.com/v2-8b38085659c0b595710e67a50ccc42ea_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p data-pid=&quot;dydgNar5&quot;&gt;&lt;b&gt;以accountMapper.selectByPrimaryKey (1) 为例：&lt;/b&gt;&lt;/p&gt;&lt;p data-pid=&quot;r1Q7hlMo&quot;&gt;・调用 SqlSession.getMapper ()：得到 xxxMapper (如 UserMapper) 的动态代理对象；&lt;/p&gt;&lt;p data-pid=&quot;o-qBPplp&quot;&gt;・调用&lt;br/&gt;accountMapper.selectByPrimaryKey (1)：在 xxxMapper 动态代理内部，会根据要执行的 SQL 语句类型 (insert/update/delete/select/flush) 来调用 SqlSession 对应的不同方法，如 sqlSession.insert ()；&lt;/p&gt;&lt;p data-pid=&quot;-SQ3iXqx&quot;&gt;・在 sqlSession.insert () 方法的实现逻辑中，又会转交给 executor.query () 进行查询；&lt;/p&gt;&lt;p data-pid=&quot;zqf4pnFg&quot;&gt;・executor.query () 又最终会转交给 statement 类进行操作，到这里就是 jdbc 操作了。&lt;/p&gt;&lt;p data-pid=&quot;4D_QrrV5&quot;&gt;有人会好奇，为什么要通过不断的转交，SqlSession-&amp;gt;Executor-&amp;gt;Statement，而不是直接调用 Statement 执行 SQL 语句呢？因为在调用 Statement 之前，会处理一些共性的逻辑，如在 Executor 的实现类 BaseExecutor 会有一级缓存相关的逻辑，在 CachingExecutor 中会有二级缓存的相关逻辑。如果直接调用 Statement 执行 SQL 语句，那么在每个 Statement 的实现类中，都要写一套一级缓存和二级缓存的逻辑，就显得冗余了。这一块后面会细讲。&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;// SQL命令（在解析mybatis-config.xml配置文件的时候生成的）
  private final SqlCommand command;
  
  public Object execute(SqlSession sqlSession, Object[] args) {
    Object result;
    // 从command对象中获取要执行操作的SQL语句的类型，如INSERT/UPDATE/DELETE/SELECT
    switch (command.getType()) {
      // 插入
      case INSERT: {
        // 把接口方法里的参数转换成sql能识别的参数
        // 如：accountMapper.selectByPrimaryKey(1)
        // 把其中的参数&quot;1&quot;转化为sql能够识别的参数
        Object param = method.convertArgsToSqlCommandParam(args);
        // sqlSession.insert(): 调用SqlSession执行插入操作
        // rowCountResult(): 获取SQL语句的执行结果
        result = rowCountResult(sqlSession.insert(command.getName(), param));
        break;
      }
      // 更新
      case UPDATE: {
        Object param = method.convertArgsToSqlCommandParam(args);
        // sqlSession.insert(): 调用SqlSession执行更新操作
        // rowCountResult(): 获取SQL语句的执行结果
        result = rowCountResult(sqlSession.update(command.getName(), param));
        break;
      }
      // 删除
      case DELETE: {
        Object param = method.convertArgsToSqlCommandParam(args);
        // sqlSession.insert(): 调用SqlSession执行更新操作
        // rowCountResult(): 获取SQL语句的执行结果
        result = rowCountResult(sqlSession.delete(command.getName(), param));
        break;
      }
      // 查询
      case SELECT:
        // method.returnsVoid(): 返参是否为void
        // method.hasResultHandler(): 是否有对应的结果处理器
        if (method.returnsVoid() &amp;amp;&amp;amp; method.hasResultHandler()) {
          executeWithResultHandler(sqlSession, args);
          result = null;
        } else if (method.returnsMany()) { // 查询多条记录
          result = executeForMany(sqlSession, args);
        } else if (method.returnsMap()) { // 查询结果返参为Map
          result = executeForMap(sqlSession, args);
        } else if (method.returnsCursor()) { // 以游标的方式进行查询
          result = executeForCursor(sqlSession, args);
        } else {
          // 参数转换 转成sqlCommand参数
          Object param = method.convertArgsToSqlCommandParam(args);
          // 执行查询 查询单条数据
          result = sqlSession.selectOne(command.getName(), param);
          if (method.returnsOptional()
              &amp;amp;&amp;amp; (result == null || !method.getReturnType().equals(result.getClass()))) {
            result = Optional.ofNullable(result);
          }
        }
        break;
      case FLUSH: // 执行清除操作
        result = sqlSession.flushStatements();
        break;
      default:
        throw new BindingException(&quot;Unknown execution method for: &quot; + command.getName());
    }
    if (result == null &amp;amp;&amp;amp; method.getReturnType().isPrimitive() &amp;amp;&amp;amp; !method.returnsVoid()) {
      throw new BindingException(&quot;Mapper method &#x27;&quot; + command.getName()
          + &quot; attempted to return null from a method with a primitive return type (&quot; + method.getReturnType() + &quot;).&quot;);
    }
    return result;
  }&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p data-pid=&quot;jVF-0zkL&quot;&gt;在上面，有多处出现这样一行代码：&lt;br/&gt;method.convertArgsToSqlCommandParam (args)，该方法的作用就是将方法参数转换为 SqlCommandParam；具体交由&lt;br/&gt;paramNameResolver.getNamedParams () 实现。在看 paramNameResolver.getNamedParams () 之前，我们先来看下 paramNameResolver 是什么东西？&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;public Object convertArgsToSqlCommandParam(Object[] args) {
      return paramNameResolver.getNamedParams(args);
    }&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p data-pid=&quot;Ms-GDXyy&quot;&gt;在前面，我们在实例化 MethodSignature 对象 (new MethodSignature) 的时候，在其构造方法中，会实例化 ParamNameResolver 对象，该对象主要用来处理接口形式的参数，最后会把参数处放在一个 map（即属性 names）中。map 的 key 为参数的位置，value 为参数的名字。&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;public MethodSignature(Configuration configuration, Class&amp;lt;?&amp;gt; mapperInterface, Method method) {
  ...
  this.paramNameResolver = new ParamNameResolver(configuration, method);
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p data-pid=&quot;dldZ902t&quot;&gt;&lt;b&gt;对 names 字段的解释：&lt;/b&gt;&lt;/p&gt;&lt;p data-pid=&quot;kW1twmBG&quot;&gt;假设在 xxxMapper 中有这么一个接口方法 selectByIdAndName ()&lt;/p&gt;&lt;p data-pid=&quot;-aR3MM2Y&quot;&gt;・selectByIdAndName (@Param (&quot;id&quot;) String id, @Param (&quot;name&quot;) String name) 转化为 map 为 {{0, &quot;id&quot;}, {1, &quot;name&quot;}}&lt;/p&gt;&lt;p data-pid=&quot;_82xh_Yd&quot;&gt;・selectByIdAndName (String id, String name) 转化为 map 为 {{0, &quot;0&quot;}, {1, &quot;1&quot;}}&lt;/p&gt;&lt;p data-pid=&quot;i4i3aOPU&quot;&gt;・selectByIdAndName (int a, RowBounds rb, int b) 转化为 map 为 {{0, &quot;0&quot;}, {2, &quot;1&quot;}}&lt;/p&gt;&lt;p data-pid=&quot;DFcou70X&quot;&gt;&lt;b&gt;构造方法的会经历如下的步骤&lt;/b&gt;&lt;/p&gt;&lt;p data-pid=&quot;u5E_e-1t&quot;&gt;1. 通过反射得到方法的参数类型和方法的参数注解注解，&lt;br/&gt;method.getParameterAnnotations () 方法返回的是注解的二维数组，每一个方法的参数包含一个注解数组。&lt;/p&gt;&lt;p data-pid=&quot;rhrFkQkq&quot;&gt;2. 遍历所有的参数&lt;/p&gt;&lt;p data-pid=&quot;EcrZgR2j&quot;&gt;- 首先判断这个参数的类型是否是特殊类型，RowBounds 和 ResultHandler，是的话跳过，咱不处理&lt;/p&gt;&lt;p data-pid=&quot;vNcXckFd&quot;&gt;- 判断这个参数是否是用来 Param 注解，如果使用的话 name 就是 Param 注解的值，并把 name 放到 map 中，键为参数在方法中的位置，value 为 Param 的值&lt;/p&gt;&lt;p data-pid=&quot;ASSeaZAJ&quot;&gt;- 如果没有使用 Param 注解，判断是否开启了 UseActualParamName，如果开启了，则使用 java8 的反射得到方法的名字，此处容易造成异常，&lt;/p&gt;&lt;p data-pid=&quot;esidoiEM&quot;&gt;具体原因参考上一篇博文.&lt;/p&gt;&lt;p data-pid=&quot;Rif1MRy9&quot;&gt;- 如果以上条件都不满足的话，则这个参数的名字为参数的下标&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;// 通用key前缀，因为key有param1，param2，param3等；
  public static final String GENERIC_NAME_PREFIX = &quot;param&quot;;
  // 存放参数的位置和对应的参数名
  private final SortedMap&amp;lt;Integer, String&amp;gt; names;
  // 是否使用@Param注解
  private boolean hasParamAnnotation;

  public ParamNameResolver(Configuration config, Method method) {
    // 通过注解得到方法的参数类型数组
    final Class&amp;lt;?&amp;gt;[] paramTypes = method.getParameterTypes();
    // 通过反射得到方法的参数注解数组
    final Annotation[][] paramAnnotations = method.getParameterAnnotations();
    // 用于存储所有参数名的SortedMap对象
    final SortedMap&amp;lt;Integer, String&amp;gt; map = new TreeMap&amp;lt;&amp;gt;();
    // 参数注解数组长度，即方法入参中有几个地方使用了@Param
    // 如selectByIdAndName(@Param(&quot;id&quot;) String id, @Param(&quot;name&quot;) String name)中，paramCount=2
    int paramCount = paramAnnotations.length;
    // 遍历所有的参数
    for (int paramIndex = 0; paramIndex &amp;lt; paramCount; paramIndex++) {
      // 判断这个参数的类型是否是特殊类型,RowBounds和ResultHandler，是的话跳过
      if (isSpecialParameter(paramTypes[paramIndex])) {
        continue;
      }
      String name = null;
      for (Annotation annotation : paramAnnotations[paramIndex]) {
        // 判断这个参数是否使用了@Param注解
        if (annotation instanceof Param) {
          // 标记当前方法使用了Param注解
          hasParamAnnotation = true;
          // 如果使用的话name就是Param注解的值
          name = ((Param) annotation).value();
          break;
        }
      }
      // 如果经过上面处理，参数名还是null，则说明当前参数没有指定@Param注解
      if (name == null) {
        // 判断是否开启了UseActualParamName
        if (config.isUseActualParamName()) {
          // 如果开启了，则使用java8的反射得到该参数对应的属性名
          name = getActualParamName(method, paramIndex);
        }
        // 如果name还是为null
        if (name == null) {
          // use the parameter index as the name (&quot;0&quot;, &quot;1&quot;, ...)
          // 使用参数在map中的下标作为参数的name，如 (&quot;0&quot;, &quot;1&quot;, ...)
          name = String.valueOf(map.size());
        }
      }
      // 把参数放入到map中，key为参数在方法中的位置，value为参数的name(@Param的value值/参数对应的属性名/参数在map中的位置下标)
      map.put(paramIndex, name);
    }
    // 最后使用Collections工具类的静态方法将结果map变为一个不可修改类型
    names = Collections.unmodifiableSortedMap(map);
  }&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p data-pid=&quot;Aks9rmYt&quot;&gt;getNamedParams(): 该方法会将参数名和参数值对应起来，并且还会额外保存一份以 param 开头加参数顺序数字的值&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;public Object getNamedParams(Object[] args) {
    // 这里的names就是ParamNameResolver中的names，在构造ParamNameResolver对象的时候，创建了该Map
    // 获取方法参数个数
    final int paramCount = names.size();
    // 没有参数
    if (args == null || paramCount == 0) {
      return null;
    // 只有一个参数，并且没有使用@Param注解。
    } else if (!hasParamAnnotation &amp;amp;&amp;amp; paramCount == 1) {
      // 直接返回，不做任务处理
      return args[names.firstKey()];
    } else {
      // 包装成ParamMap对象。这个对象继承了HashMap，重写了get方法。
      final Map&amp;lt;String, Object&amp;gt; param = new ParamMap&amp;lt;&amp;gt;();
      int i = 0;
      // 遍历names中的所有键值对
      for (Map.Entry&amp;lt;Integer, String&amp;gt; entry : names.entrySet()) {
        // 将参数名作为key, 对应的参数值作为value，放入结果param对象中
        param.put(entry.getValue(), args[entry.getKey()]);
        // 用于添加通用的参数名称，按顺序命名(param1, param2, ...)
        final String genericParamName = GENERIC_NAME_PREFIX + (i + 1);
        // 确保不覆盖以@Param 命名的参数
        if (!names.containsValue(genericParamName)) {
          param.put(genericParamName, args[entry.getKey()]);
        }
        i++;
      }
      return param;
    }
  }
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p data-pid=&quot;GGOwweBh&quot;&gt;&lt;b&gt;getNamedParams () 总结：&lt;/b&gt;&lt;/p&gt;&lt;p data-pid=&quot;udTt4ZKA&quot;&gt;1. 当只有一个参数的时候，直接返回，不做任务处理；&lt;/p&gt;&lt;p data-pid=&quot;glbbwpD5&quot;&gt;2. 否则，存入 Map 中，键值对形式为：paramName=paramValue&lt;/p&gt;&lt;p data-pid=&quot;2LrHf3Q0&quot;&gt;・selectByIdAndName (@Param (&quot;id&quot;) String id, @Param (&quot;name&quot;) String name)： 传入的参数是 [&quot;1&quot;, &quot;张三&quot;]，最后解析出来的 map 为：{“id”:”1”,”“name”:” 张三”}&lt;/p&gt;&lt;p data-pid=&quot;NAYhrzEu&quot;&gt;・selectByIdAndName (String id, @Param (&quot;name&quot;) String name)： 传入的参数是 [&quot;1&quot;, &quot;张三&quot;]，最后解析出来的 map 为：{“param1”:”1”,”“name”:” 张三”}&lt;/p&gt;&lt;p data-pid=&quot;xM6TKer3&quot;&gt;假设执行的 SQL 语句是 select 类型，继续往下看代码&lt;/p&gt;&lt;p data-pid=&quot;3hvXHiyq&quot;&gt;在 mapperMethod.execute (), 当&lt;br/&gt;convertArgsToSqlCommandParam () 方法处理完方法参数后，假设我们此时调用的是查询单条记录，那么接下来会执行 sqlSession.selectOne () 方法。&lt;/p&gt;&lt;p data-pid=&quot;mWBwq6Qd&quot;&gt;&lt;b&gt;sqlSession.selectOne () 源码分析：&lt;/b&gt;&lt;/p&gt;&lt;p data-pid=&quot;NQFGI2EV&quot;&gt;sqlSession.selectOne () 也是调的 sqlSession.selectList () 方法，只不过只返回 list 中的第一条数据。当 list 中有多条数据时，抛异常。&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;@Override
public &amp;lt;T&amp;gt; T selectOne(String statement, Object parameter) {
  // 调用当前类的selectList方法
  List&amp;lt;T&amp;gt; list = this.selectList(statement, parameter);
  if (list.size() == 1) {
    return list.get(0);
  } else if (list.size() &amp;gt; 1) {
    throw new TooManyResultsException(&quot;Expected one result (or null) to be returned by selectOne(), but found: &quot; + list.size());
  } else {
    return null;
  }
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p data-pid=&quot;6PI_Rx0W&quot;&gt;&lt;b&gt;sqlSession.selectList () 方法&lt;/b&gt;&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;@Override
  public &amp;lt;E&amp;gt; List&amp;lt;E&amp;gt; selectList(String statement, Object parameter) {
    return this.selectList(statement, parameter, RowBounds.DEFAULT);
  }&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p data-pid=&quot;DReXtXAw&quot;&gt;&lt;b&gt;继续看：&lt;/b&gt;&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;@Override
  public &amp;lt;E&amp;gt; List&amp;lt;E&amp;gt; selectList(String statement, Object parameter, RowBounds rowBounds) {
    try {
      // 从Configuration里的mappedStatements里根据key(id的全路径)获取MappedStatement对象
      MappedStatement ms = configuration.getMappedStatement(statement);
      // 调用Executor的实现类BaseExecutor的query()方法
      return executor.query(ms, wrapCollection(parameter), rowBounds, Executor.NO_RESULT_HANDLER);
    } catch (Exception e) {
      throw ExceptionFactory.wrapException(&quot;Error querying database.  Cause: &quot; + e, e);
    } finally {
      ErrorContext.instance().reset();
    }
  }&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p data-pid=&quot;qZaac23g&quot;&gt;在 sqlSession.selectList () 方法中，我们可以看到调用了 executor.query ()，假设我们开启了二级缓存，那么 executor.query () 调用的是 executor 的实现类 CachingExecutor 中的 query ()，二级缓存的逻辑就是在 CachingExecutor 这个类中实现的。&lt;/p&gt;&lt;p data-pid=&quot;5FELkQ1F&quot;&gt;&lt;b&gt;关于 mybatis 二级缓存：&lt;/b&gt;&lt;/p&gt;&lt;p data-pid=&quot;gdoQYgse&quot;&gt;二级缓存默认是不开启的，需要手动开启二级缓存，实现二级缓存的时候，MyBatis 要求返回的 POJO 必须是可序列化的。缓存中存储的是序列化之后的，所以不同的会话操作对象不会改变缓存。&lt;/p&gt;&lt;p data-pid=&quot;wkMUv936&quot;&gt;&lt;b&gt;怎么开启二级缓存：&lt;/b&gt;&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;&amp;lt;settings&amp;gt;
    &amp;lt;setting name = &quot;cacheEnabled&quot; value = &quot;true&quot; /&amp;gt;
&amp;lt;/settings&amp;gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p data-pid=&quot;fBQtYB-E&quot;&gt;&lt;b&gt;怎么使用二级缓存？&lt;/b&gt;&lt;/p&gt;&lt;p data-pid=&quot;VJ5Ftlwn&quot;&gt;1. 首先肯定是要开启二级缓存啦～&lt;/p&gt;&lt;p data-pid=&quot;bIEhP8jh&quot;&gt;2. 除此之外，要使用二级缓存还要满足以下条件：&lt;/p&gt;&lt;p data-pid=&quot;sG7al5KX&quot;&gt;・当会话提交之后才会填充二级缓存（为什么？后面会解释）&lt;/p&gt;&lt;p data-pid=&quot;LAJt3W40&quot;&gt;・SQL 语句相同，参数相同&lt;/p&gt;&lt;p data-pid=&quot;j_7kZbmq&quot;&gt;・相同的 statementID&lt;/p&gt;&lt;p data-pid=&quot;ATd8pi7L&quot;&gt;・RowBounds 相同&lt;/p&gt;&lt;p data-pid=&quot;YCA7rK7n&quot;&gt;&lt;b&gt;为什么要会话提交后才会填充二级缓存？&lt;/b&gt;&lt;/p&gt;&lt;p data-pid=&quot;JhZcuJWz&quot;&gt;首先，我们知道，与一级缓存（会话级缓存）不同的是，二级缓存是跨线程使用的，也就是多个会话可以一起使用同一个二级缓存。假设现在不用提交便可以填充二级缓存，我们看看会存在什么问题？&lt;/p&gt;&lt;p data-pid=&quot;YkpI-nzJ&quot;&gt;假设会话二现在对数据库进行了修改操作，修改完进行了查询操纵，如果不用提交就会填充二级缓存的话，这时候查询操作会把刚才修改的数据填充到二级缓存中，如果此时刚好会话一执行了查询操作，便会查询到二级缓存中的数据。如果会话二最终回滚了刚才的修改操作，那么会话一就相当于发生了脏读。&lt;/p&gt;&lt;p class=&quot;ztext-empty-paragraph&quot;&gt;&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-8c74fa12d93dbcbbb385f153237628c3_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;640&quot; data-rawheight=&quot;335&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic4.zhimg.com/v2-8c74fa12d93dbcbbb385f153237628c3_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;640&quot; data-rawheight=&quot;335&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic4.zhimg.com/v2-8c74fa12d93dbcbbb385f153237628c3_r.jpg&quot; data-actualsrc=&quot;https://pic4.zhimg.com/v2-8c74fa12d93dbcbbb385f153237628c3_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p data-pid=&quot;bWhTXBsZ&quot;&gt;实际上，查询的时候会填充缓存，只不过此时是填充在暂存区，而不是填充在真正的二级缓存区中。而上面所说的要会话提交后才会填充二级缓存，指的是将暂存区中的缓存刷到真正的二级缓存中。啊？？？那不对呀，填充在暂存区，那此时会话一来查询，岂不是还会从暂存区中取到缓存，从而导致脏读？别急，接着往下看。&lt;/p&gt;&lt;p data-pid=&quot;cEsR6B4H&quot;&gt;对于查询操作，每次取缓存都是从真正的二级缓存中取缓存，而不是从暂存区中取缓存。&lt;/p&gt;&lt;p data-pid=&quot;xm2DHMHj&quot;&gt;好了，我们接着看源码～&lt;/p&gt;&lt;p data-pid=&quot;vc3Q67XI&quot;&gt;&lt;b&gt;CachingExecutor.query () 源码：&lt;/b&gt;&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;@Override
  public &amp;lt;E&amp;gt; List&amp;lt;E&amp;gt; query(MappedStatement ms, Object parameterObject, RowBounds rowBounds, ResultHandler resultHandler) throws SQLException {
    // 获取要执行的sql语句 sql语句在解析xml的时候就已经解析好了
    BoundSql boundSql = ms.getBoundSql(parameterObject);
    // 生成二级缓存key
    CacheKey key = createCacheKey(ms, parameterObject, rowBounds, boundSql);
    // 调用重载方法
    return query(ms, parameterObject, rowBounds, resultHandler, key, boundSql);
  }&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p data-pid=&quot;sKofQuMk&quot;&gt;&lt;b&gt;调用重载方法：query ()&lt;/b&gt;&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;@Override
  public &amp;lt;E&amp;gt; List&amp;lt;E&amp;gt; query(MappedStatement ms, Object parameterObject, RowBounds rowBounds, ResultHandler resultHandler, CacheKey key, BoundSql boundSql)
      throws SQLException {
    // 获取mybatis的二级缓存配置&amp;lt;cache&amp;gt;
    Cache cache = ms.getCache();
    // 如果配置了二级缓存
    if (cache != null) {
      // 是否要刷新缓存，是否手动设置了需要清空缓存
      flushCacheIfRequired(ms);
      if (ms.isUseCache() &amp;amp;&amp;amp; resultHandler == null) {
        ensureNoOutParams(ms, boundSql);
        @SuppressWarnings(&quot;unchecked&quot;)
        // 从二级缓存中获取值
        List&amp;lt;E&amp;gt; list = (List&amp;lt;E&amp;gt;) tcm.getObject(cache, key);
        // 从二级缓存中取不到值
        if (list == null) {
          // 交由delegate查询 这里的delegate指向的是BaseExecutor
          // BaseExecutor中实现了一级缓存的相关逻辑
          // 也就是说，当在二级缓存中获取不到值的时候，会从一级缓存中获取，一级缓存要是还是获取不到
          // 才会去查询数据库
          list = delegate.query(ms, parameterObject, rowBounds, resultHandler, key, boundSql);
          // 将查询结果存放在暂存区中，只有会话提交后才会将数据刷到二级缓存，避免脏读问题
          tcm.putObject(cache, key, list); // issue #578 and #116
        }
        return list;
      }
    }
    return delegate.query(ms, parameterObject, rowBounds, resultHandler, key, boundSql);
  }&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p data-pid=&quot;-Bb_DzAg&quot;&gt;&lt;b&gt;接着，我们看下 BaseExecutor.query () 是怎么实现一级缓存逻辑的：&lt;/b&gt;&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;@SuppressWarnings(&quot;unchecked&quot;)
  @Override
  public &amp;lt;E&amp;gt; List&amp;lt;E&amp;gt; query(MappedStatement ms, Object parameter, RowBounds rowBounds, ResultHandler resultHandler, CacheKey key, BoundSql boundSql) throws SQLException {
    ErrorContext.instance().resource(ms.getResource()).activity(&quot;executing a query&quot;).object(ms.getId());
    if (closed) {
      throw new ExecutorException(&quot;Executor was closed.&quot;);
    }
    if (queryStack == 0 &amp;amp;&amp;amp; ms.isFlushCacheRequired()) {
      clearLocalCache();
    }
    List&amp;lt;E&amp;gt; list;
    try {
      queryStack++;
      // 尝试从缓存中获取结果 一级缓存
      list = resultHandler == null ? (List&amp;lt;E&amp;gt;) localCache.getObject(key) : null;
      if (list != null) {
        handleLocallyCachedOutputParameters(ms, key, parameter, boundSql);
      } else {// 从缓存中获取不到结果时
        // 从数据库中查询数据
        list = queryFromDatabase(ms, parameter, rowBounds, resultHandler, key, boundSql);
      }
    } finally {
      queryStack--;
    }
    if (queryStack == 0) { // 回到主查询
      // 遍历延迟加载中的数据
      for (DeferredLoad deferredLoad : deferredLoads) {
        // 把延迟加载的数据加载到结果集中
        deferredLoad.load();
      }
      // issue #601
      deferredLoads.clear();
      if (configuration.getLocalCacheScope() == LocalCacheScope.STATEMENT) {
        // issue #482
        clearLocalCache();
      }
    }
    return list;
  }&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p data-pid=&quot;ldsTUHBY&quot;&gt;&lt;b&gt;当从一级缓存中获取不到数据时，会查数据库：&lt;/b&gt;&lt;/p&gt;&lt;p data-pid=&quot;-o_ASU14&quot;&gt;调用&lt;br/&gt;BaseExecutor.queryFromDatabase()&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;private &amp;lt;E&amp;gt; List&amp;lt;E&amp;gt; queryFromDatabase(MappedStatement ms, Object parameter, RowBounds rowBounds, ResultHandler resultHandler, CacheKey key, BoundSql boundSql) throws SQLException {
    List&amp;lt;E&amp;gt; list;
    // 占位符 （解决循环依赖问题）
    localCache.putObject(key, EXECUTION_PLACEHOLDER);
    try {
      // 执行查询操作
      list = doQuery(ms, parameter, rowBounds, resultHandler, boundSql);
    } finally {
      // 将占位符从缓存中移除
      localCache.removeObject(key);
    }
    // 将查询结果放入到一级缓存中
    localCache.putObject(key, list);
    if (ms.getStatementType() == StatementType.CALLABLE) {
      localOutputParameterCache.putObject(key, parameter);
    }
    return list;
  }&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p data-pid=&quot;NySdf1QQ&quot;&gt;&lt;b&gt;调用 BaseExecutor.doQuery ()：在 BaseExecutor 中，doQuery () 只是个抽象方法，具体交由子类实现：&lt;/b&gt;&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;protected abstract &amp;lt;E&amp;gt; List&amp;lt;E&amp;gt; doQuery(MappedStatement ms, Object parameter, RowBounds rowBounds, ResultHandler resultHandler, BoundSql boundSql)
      throws SQLException;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p data-pid=&quot;9XzFJ5zd&quot;&gt;&lt;b&gt;从前面的流程中可知，在每次执行 CURD 的时候，都需要获取 SqlSession 这个对象，接口如下：&lt;/b&gt;&lt;/p&gt;&lt;p data-pid=&quot;w9mRlTmi&quot;&gt;&lt;b&gt;可以看出来这个接口主要定义类关于 CRUD、数据库事务、数据库刷新等相关操作。下面看它的默认实现类：&lt;/b&gt;&lt;/p&gt;&lt;p class=&quot;ztext-empty-paragraph&quot;&gt;&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-91b27ea6268e559b6cd7c36c6c779108_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;640&quot; data-rawheight=&quot;284&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic1.zhimg.com/v2-91b27ea6268e559b6cd7c36c6c779108_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;640&quot; data-rawheight=&quot;284&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic1.zhimg.com/v2-91b27ea6268e559b6cd7c36c6c779108_r.jpg&quot; data-actualsrc=&quot;https://pic1.zhimg.com/v2-91b27ea6268e559b6cd7c36c6c779108_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p data-pid=&quot;aXSaooSq&quot;&gt;可以看到 DefaultSqlSession 实现了 SqlSession 中的方法，（其实我们自己也可根据需要去实现）。而在 DefaultSqlSession 类中有一个很重要的属性，就是 Mybatis 的执行器（Executor）。&lt;/p&gt;&lt;p data-pid=&quot;YUDcZmWb&quot;&gt;&lt;b&gt;Executor 介绍：&lt;/b&gt;&lt;/p&gt;&lt;p data-pid=&quot;jSVsHsqJ&quot;&gt;Executor 执行器，是 mybatis 中执行查询的主要代码，Executor 分为三种：&lt;/p&gt;&lt;p data-pid=&quot;QjxKkolI&quot;&gt;・简单执行器 SimpleExecutor&lt;/p&gt;&lt;p data-pid=&quot;W7zRnY0V&quot;&gt;・可重用执行器 ReuseExecutor&lt;/p&gt;&lt;p data-pid=&quot;Vv1w5482&quot;&gt;・批量执行器 BatchExecutor&lt;/p&gt;&lt;p data-pid=&quot;p5YYT9pu&quot;&gt;默认使用的执行器是 SimpleExecutor，可以在 mybatis 的配置文件中设置使用哪种执行器&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;public class Configuration {
    protected ExecutorType defaultExecutorType = ExecutorType.SIMPLE;
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p data-pid=&quot;ULVoFdyh&quot;&gt;&lt;b&gt;Executor 类图：&lt;/b&gt;&lt;/p&gt;&lt;p class=&quot;ztext-empty-paragraph&quot;&gt;&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-a20319bf21b8716337c007fd8d6544d7_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;640&quot; data-rawheight=&quot;206&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic4.zhimg.com/v2-a20319bf21b8716337c007fd8d6544d7_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;640&quot; data-rawheight=&quot;206&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic4.zhimg.com/v2-a20319bf21b8716337c007fd8d6544d7_r.jpg&quot; data-actualsrc=&quot;https://pic4.zhimg.com/v2-a20319bf21b8716337c007fd8d6544d7_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p data-pid=&quot;Fh3sbLm7&quot;&gt;﻿假设我们使用的就是默认的执行器，SimpleExecutor。我们来看下 SimpleExecutor.doQuery ()&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;@Override
  public &amp;lt;E&amp;gt; List&amp;lt;E&amp;gt; doQuery(MappedStatement ms, Object parameter, RowBounds rowBounds, ResultHandler resultHandler, BoundSql boundSql) throws SQLException {
    // 这里就进入jdbc了
    Statement stmt = null;
    try {
      // 获取核心配置对象
      Configuration configuration = ms.getConfiguration();
      StatementHandler handler = configuration.newStatementHandler(wrapper, ms, parameter, rowBounds, resultHandler, boundSql);
      //预编译SQL语句
      stmt = prepareStatement(handler, ms.getStatementLog());
      // 执行查询
      return handler.query(stmt, resultHandler);
    } finally {
      closeStatement(stmt);
    }
  }
private Statement prepareStatement(StatementHandler handler, Log statementLog) throws SQLException {
    Statement stmt;
    // 获取连接 这里的连接是代理连接
    Connection connection = getConnection(statementLog);
    // 预编译
    stmt = handler.prepare(connection, transaction.getTimeout());
    // 给预编译sql语句设置参数
    handler.parameterize(stmt);
    return stmt;
  }&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p data-pid=&quot;XJ04pFbR&quot;&gt;在上面的源码中，我们可以看到 StatementHandler，它是用来干嘛的？&lt;/p&gt;&lt;p data-pid=&quot;e-HkIjp0&quot;&gt;在 mybatis 中，通过 StatementHandler 来处理与 JDBC 的交互，我们看下 StatementHandler 的类图：&lt;/p&gt;&lt;p class=&quot;ztext-empty-paragraph&quot;&gt;&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-7926b47a1f4841c1bb985c19f627732d_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;640&quot; data-rawheight=&quot;179&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic2.zhimg.com/v2-7926b47a1f4841c1bb985c19f627732d_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;640&quot; data-rawheight=&quot;179&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic2.zhimg.com/v2-7926b47a1f4841c1bb985c19f627732d_r.jpg&quot; data-actualsrc=&quot;https://pic2.zhimg.com/v2-7926b47a1f4841c1bb985c19f627732d_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p data-pid=&quot;72Hhn3Z7&quot;&gt;可以看出，跟 Executor 的继承实现很像，都有一个 Base，Base 下面又有几个具体实现子类，很明显，采用了&lt;b&gt;模板模式&lt;/b&gt;。不同于 CacheExecutor 用于二级缓存之类的实际作用，这里的 RoutingStatementHandler 仅用于维护三个 Base 子类的创建与调用。&lt;/p&gt;&lt;p data-pid=&quot;CkryUZcy&quot;&gt;•BaseStatementHandler&lt;/p&gt;&lt;p data-pid=&quot;cPV6WaZt&quot;&gt;・SimpleStatementHandler：JDBC 中的 Statement 接口，处理简单 SQL 的&lt;/p&gt;&lt;p data-pid=&quot;eAv9pVoG&quot;&gt;・CallableStatementHandler：JDBC 中的 PreparedStatement，预编译 SQL 的接口&lt;/p&gt;&lt;p data-pid=&quot;1F_dy7Cj&quot;&gt;・PreparedStatementHandler：JDBC 中的 CallableStatement，用于执行存储过程相关的接口&lt;/p&gt;&lt;p data-pid=&quot;ROUNSt-E&quot;&gt;・RoutingStatementHandler：路由三个 Base 子类，负责其创建及调用&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;public RoutingStatementHandler(Executor executor, MappedStatement ms, Object parameter, RowBounds rowBounds, ResultHandler resultHandler, BoundSql boundSql) {
    switch (ms.getStatementType()) {
      // 策略模式：根据不同语句类型 选用不同的策略实现类
      case STATEMENT:
        delegate = new SimpleStatementHandler(executor, ms, parameter, rowBounds, resultHandler, boundSql);
        break;
      case PREPARED:
        delegate = new PreparedStatementHandler(executor, ms, parameter, rowBounds, resultHandler, boundSql);
        break;
      case CALLABLE:
        delegate = new CallableStatementHandler(executor, ms, parameter, rowBounds, resultHandler, boundSql);
        break;
      default:
        throw new ExecutorException(&quot;Unknown statement type: &quot; + ms.getStatementType());
    }
  }&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p data-pid=&quot;wW2gX6ID&quot;&gt;嗯，很眼熟的策略模式，按照 statementType 的值来决定返回哪种 StatementHandler。&lt;/p&gt;&lt;p data-pid=&quot;ZVAhy1s8&quot;&gt;那这里的 statementType 是在哪里赋值的呢？我们看下 MappedStatement 的构造方法：&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;public Builder(Configuration configuration, String id, SqlSource sqlSource, SqlCommandType sqlCommandType) {
      ...
      // 构造方法中默认取值为PREPARED
      mappedStatement.statementType = StatementType.PREPARED;
      ...
    }&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p data-pid=&quot;8jl-x87m&quot;&gt;&lt;b&gt;如果不想使用的 StatementType.PREPARED，怎么自定义呢？&lt;/b&gt;&lt;/p&gt;&lt;p data-pid=&quot;Vd70YEpf&quot;&gt;(1) 在 xxxMapper.xml 中：可以通过 &amp;lt;select /&amp;gt; 的 statementType 属性指定&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;&amp;lt;select id=&quot;getAll&quot; resultType=&quot;Student2&quot; statementType=&quot;CALLABLE&quot;&amp;gt;
    SELECT * FROM Student
&amp;lt;/select&amp;gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p data-pid=&quot;unnFxrI6&quot;&gt;(2) 如果采用的是注解开发：通过 @SelectKey 的 statementType 属性指定&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;@SelectKey(keyProperty = &quot;account&quot;, 
        before = false, 
        statementType = StatementType.STATEMENT, 
        statement = &quot;select * from account where id = #{id}&quot;, 
        resultType = Account.class)
Account selectByPrimaryKey(@Param(&quot;id&quot;) Integer id);&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p data-pid=&quot;aImcn6Ci&quot;&gt;到此，select 类型的 SQL 语句就基本执行完毕了，我们来总结一下 mybatis&lt;/p&gt;&lt;p data-pid=&quot;Ogon1OxV&quot;&gt;&lt;b&gt;MyBatis 的主要的核心部件有以下几个：&lt;/b&gt;&lt;/p&gt;&lt;p data-pid=&quot;oOnvWiaS&quot;&gt;&lt;b&gt;SqlSession：&lt;/b&gt;作为 MyBatis 工作的主要顶层 API，表示和数据库交互的会话，完成必要数据库增删改查功能；&lt;/p&gt;&lt;p data-pid=&quot;NGGLqJKb&quot;&gt;&lt;b&gt;Executor：&lt;/b&gt;MyBatis 执行器，是 MyBatis 调度的核心，负责 SQL 语句的生成和查询缓存的维护；&lt;/p&gt;&lt;p data-pid=&quot;7xKbfCat&quot;&gt;&lt;b&gt;StatementHandler：&lt;/b&gt;封装了 JDBC Statement 操作，负责对 JDBC statement 的操作，如设置参数、将 Statement 结果集转换成 List 集合。&lt;/p&gt;&lt;p data-pid=&quot;0rVgOOaU&quot;&gt;&lt;b&gt;ParameterHandler：&lt;/b&gt;负责对用户传递的参数转换成 JDBC Statement 所需要的参数；&lt;/p&gt;&lt;p data-pid=&quot;ZJ38kV7L&quot;&gt;&lt;b&gt;ResultSetHandler：&lt;/b&gt;负责将 JDBC 返回的 ResultSet 结果集对象转换成 List 类型的集合；&lt;/p&gt;&lt;p data-pid=&quot;c97hiosu&quot;&gt;&lt;b&gt;TypeHandler：&lt;/b&gt;负责 java 数据类型和 jdbc 数据类型之间的映射和转换；&lt;/p&gt;&lt;p data-pid=&quot;o7DNN-R6&quot;&gt;&lt;b&gt;MappedStatement：&lt;/b&gt;MappedStatement 维护了一条 &amp;lt;select|update|delete|insert&amp;gt; 节点的封装；&lt;/p&gt;&lt;p data-pid=&quot;XBKIK4tR&quot;&gt;&lt;b&gt;SqlSource：&lt;/b&gt;负责根据用户传递的 parameterObject，动态地生成 SQL 语句，将信息封装到 BoundSql 对象中，并返回；&lt;/p&gt;&lt;p data-pid=&quot;LNrLv9mT&quot;&gt;&lt;b&gt;BoundSql：&lt;/b&gt;表示动态生成的 SQL 语句以及相应的参数信息；&lt;/p&gt;&lt;p data-pid=&quot;F_d-bMWU&quot;&gt;&lt;b&gt;Configuration：&lt;/b&gt;MyBatis 所有的配置信息都维持在 Configuration 对象之中；&lt;/p&gt;&lt;p class=&quot;ztext-empty-paragraph&quot;&gt;&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-7fed5d073db13c8e2eda76b1730f5eaa_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;640&quot; data-rawheight=&quot;486&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic3.zhimg.com/v2-7fed5d073db13c8e2eda76b1730f5eaa_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;640&quot; data-rawheight=&quot;486&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic3.zhimg.com/v2-7fed5d073db13c8e2eda76b1730f5eaa_r.jpg&quot; data-actualsrc=&quot;https://pic3.zhimg.com/v2-7fed5d073db13c8e2eda76b1730f5eaa_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p class=&quot;ztext-empty-paragraph&quot;&gt;&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-52ce664ad3a0bec85190676c97fc2925_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;640&quot; data-rawheight=&quot;720&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic2.zhimg.com/v2-52ce664ad3a0bec85190676c97fc2925_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;640&quot; data-rawheight=&quot;720&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic2.zhimg.com/v2-52ce664ad3a0bec85190676c97fc2925_r.jpg&quot; data-actualsrc=&quot;https://pic2.zhimg.com/v2-52ce664ad3a0bec85190676c97fc2925_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;hr/&gt;&lt;p data-pid=&quot;RCfgNQCn&quot;&gt;&lt;b&gt;欢迎来京东云开发者社区交流技术，原文作者：郑志杰&lt;/b&gt;&lt;br/&gt; &lt;/p&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>ad949fa237ad887776f7ec68711b7c91</guid>
<title>看完这篇还不懂 MySQL 的 MVCC 机制算我输</title>
<link>https://toutiao.io/k/b0np8xn</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;markdown编辑器&quot; data-website=&quot;https://markdown.com.cn/editor&quot;&gt;&lt;h2 data-tool=&quot;markdown.com.cn编辑器&quot;&gt;&lt;span&gt;前言&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;markdown.com.cn编辑器&quot;&gt;MySQL中大名鼎鼎的MVCC机制想必大家都有所耳闻吧，虽然在平时MySQL使用过程中基本上用不到，但是面试中出场率十分高，而且作为架构师的你也是需要知道它的工作机制。那么你对MVCC机制了解多少呢？MVCC机制是用来干嘛的呢？底层的工作原理是怎么样的呢？本文就带你一探究竟。&lt;/p&gt;&lt;h2 data-tool=&quot;markdown.com.cn编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;MVCC机制是什么?&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;markdown.com.cn编辑器&quot;&gt;MVCC，英文全称&lt;code&gt;Multiversion Concurrency Control&lt;/code&gt;，多版本并发控制。简单理解，就是相当于给我们的MySQL数据库拍个“&lt;strong&gt;快照&lt;/strong&gt;”，定格某个时刻数据库的状态。&lt;/p&gt;&lt;p data-tool=&quot;markdown.com.cn编辑器&quot;&gt;&lt;strong&gt;那你可能问为什么要拍个“快照”，也就是MVCC机制？&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;markdown.com.cn编辑器&quot;&gt;还记得事务的一大特性就是隔离性，一共有4个隔离级别，读未提交，读已提交，可重复读，串行化。&lt;/p&gt;&lt;figure data-tool=&quot;markdown.com.cn编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.17562254259501967&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/oH5VKTC5sLjzmWMXvaNtlS9tOU8LZTtbY4HtL2PUoxlibvQTqvhHz2qrPUdhZlbMliaBbMbN5qg6DVLibzynQ7siag/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1526&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;markdown.com.cn编辑器&quot;&gt;以&lt;code&gt;MySQL InnoDB&lt;/code&gt; 引擎的默认隔离级别可重复读为例，可重复读指一个事务执行过程中看到的数据，一直跟这个事务启动时看到的数据是一致的。&lt;/p&gt;&lt;blockquote data-tool=&quot;markdown.com.cn编辑器&quot;&gt;&lt;span&gt;★&lt;/span&gt;&lt;p&gt;关于事务的基本特性请移步一文带你理解MySQL事务核心知识点&lt;/p&gt;&lt;span&gt;”&lt;/span&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;markdown.com.cn编辑器&quot;&gt;为了保证事务启动到结束整个生命周期看到的数据是一致的, 一般有两种方案：&lt;/p&gt;&lt;ol data-tool=&quot;markdown.com.cn编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;MySQL对数据“读-写”的时候，加锁，其他事务写这条数据时加上锁，其他事务读取的时候阻塞。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;MySQL可以对事务启动的时候，对数据库拍个“快照”，那么事务运行过程中读取都从这个快照读取，不也是保证数据一致么。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;markdown.com.cn编辑器&quot;&gt;第一种方案存在明显的问题，加锁会引发阻塞，从而降低数据库性能。而MySQL设计者们采用第二种，也就是大名鼎鼎的MVCC，它不仅能够解决&lt;strong&gt;不可重复读&lt;/strong&gt;，还一定程度解决&lt;strong&gt;幻读&lt;/strong&gt;的问题，因为你整个数据库快照都有了，你就知道那个时刻的数据了。&lt;/p&gt;&lt;blockquote data-tool=&quot;markdown.com.cn编辑器&quot;&gt;&lt;span&gt;★&lt;/span&gt;&lt;p&gt;虽然说SQL标准定义中可重复读隔离级别下会存在幻读的现象，但是不同的数据库厂商可以基于SQL标准下有不同的实现，那么不同隔离级别下发生的现象也会有出入，就拿MySQL的可重复读隔离级别就可以一定程度保证幻读。&lt;/p&gt;&lt;span&gt;”&lt;/span&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;markdown.com.cn编辑器&quot;&gt;&lt;strong&gt;小结一下：&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;markdown.com.cn编辑器&quot;&gt;MVCC在&lt;code&gt;MySQL InnoDB&lt;/code&gt;中的实现主要是为了提高数据库并发性能，用更好的方式去处理&lt;strong&gt;读-写&lt;/strong&gt;冲突 ，做到即使有读写冲突时，也能做到&lt;strong&gt;不加锁&lt;/strong&gt; ， &lt;strong&gt;非阻塞并发读&lt;/strong&gt;，而这个读指的就是&lt;strong&gt;快照读&lt;/strong&gt; , 而非&lt;strong&gt;当前读&lt;/strong&gt;。&lt;/p&gt;&lt;h2 data-tool=&quot;markdown.com.cn编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;什么是快照读和当前读？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;markdown.com.cn编辑器&quot;&gt;前面提到了快照读和当前读，这又有什么不一样呢，什么样的sql语句算是快照读，什么样的又算是当前读呢？&lt;/p&gt;&lt;h3 data-tool=&quot;markdown.com.cn编辑器&quot;&gt;&lt;span/&gt;快照读&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;markdown.com.cn编辑器&quot;&gt;快照读又叫普通读，也就是利用MVCC机制读取快照中的数据。&lt;strong&gt;不加锁的简单的SELECT 都属于快照读&lt;/strong&gt;，比如这样：&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;SELECT * FROM user WHERE ...&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;ul data-tool=&quot;markdown.com.cn编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;快照读是基于MVCC实现的，提高了并发的性能，降低开销&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;大部分业务代码中的读取都属于快照读&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3 data-tool=&quot;markdown.com.cn编辑器&quot;&gt;&lt;span/&gt;当前读&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;markdown.com.cn编辑器&quot;&gt;当前读读取的是记录的最新版本，读取时会对读取的记录进行加锁, 其他事务就有可能阻塞。&lt;strong&gt;加锁的 SELECT，或者对数据进行增删改都会进行当前读&lt;/strong&gt;。比如：&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;SELECT * FROM user LOCK IN SHARE MODE; # 共享锁&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;SELECT * FROM user FOR UPDATE; # 排他锁&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;INSERT INTO user values ... # 排他锁&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;DELETE FROM user WHERE ... # 排他锁&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;UPDATE user SET ... # 排他锁&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;ul data-tool=&quot;markdown.com.cn编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;update、delete、insert&lt;/code&gt;语句虽然没有&lt;code&gt;select&lt;/code&gt;, 但是它们也会先进行读取，而且只能读取最新版本。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;markdown.com.cn编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;MVCC机制是咋工作的呢？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;markdown.com.cn编辑器&quot;&gt;前面打个比方说MVCC机制相当于是基于整个数据库“拍了个快照”，这时，你会说这看上去不太现实啊。如果一个库有 100G，那么我启动一个事务，MySQL 就要保存 100G 的数据出来，这个过程得多慢啊，而且也很占用空间啊，根本就不能支持几个事务啊。别急，我们现在来讲解下MVCC机制是如何工作的。&lt;/p&gt;&lt;h3 data-tool=&quot;markdown.com.cn编辑器&quot;&gt;&lt;span/&gt;数据的多个版本&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;markdown.com.cn编辑器&quot;&gt;首先MySQL &lt;code&gt;innoDB&lt;/code&gt;存储引擎需要支持一条数据可以保留多个历史版本。怎么保留呢？还记得事务日志&lt;code&gt;undo log&lt;/code&gt;吗？&lt;/p&gt;&lt;blockquote data-tool=&quot;markdown.com.cn编辑器&quot;&gt;&lt;span&gt;★&lt;/span&gt;&lt;p&gt;undo log保存了数据的各个历史版本，用于数据的回滚，保证事务的一致性。详情查看详解MySQL事务日志——undo log&lt;/p&gt;&lt;span&gt;”&lt;/span&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;markdown.com.cn编辑器&quot;&gt;对于使用 &lt;code&gt;InnoDB&lt;/code&gt; 存储引擎的数据库表，它的聚簇索引记录中都包含下面两个隐藏列：&lt;/p&gt;&lt;ul data-tool=&quot;markdown.com.cn编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;trx_id&lt;/code&gt;，当一个事务对某条聚簇索引记录进行改动时，就会把&lt;strong&gt;该事务的事务 id 记录在&lt;/strong&gt; &lt;code&gt;trx_id&lt;/code&gt; &lt;strong&gt;隐藏列里&lt;/strong&gt;；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;roll_pointer&lt;/code&gt;，每次对某条聚簇索引记录进行改动时，都会&lt;strong&gt;把旧版本的记录写入到 undo 日志中，然后这个隐藏列是个指针，指向每一个旧版本记录&lt;/strong&gt;，于是就可以通过它找到修改前的记录。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;markdown.com.cn编辑器&quot;&gt;InnoDB 里面每个事务有一个唯一的事务 ID，叫作 transaction id。它是在事务开始的时候向 InnoDB 的事务系统申请的，是按申请顺序严格递增的。&lt;/p&gt;&lt;figure data-tool=&quot;markdown.com.cn编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.2814265536723164&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/oH5VKTC5sLjzmWMXvaNtlS9tOU8LZTtbWfSTedYGfE82vusnZHv4ywLia3pOF5Xy00gJwiajY3OYMXqQmd6cexXQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;2832&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;markdown.com.cn编辑器&quot;&gt;如上图所示，针对&lt;code&gt;id=1&lt;/code&gt;的这条数据，都会将旧值放到一条undo日志中，就算是该记录的一个旧版本，随着更新次数的增多，所有的版本都会被 &lt;code&gt;roll_pointer&lt;/code&gt; 属性连接成一个链表，我们把这个链表称之为&lt;strong&gt;版本链&lt;/strong&gt;，根据版本链就可以找到这条数据历史的版本。&lt;/p&gt;&lt;h3 data-tool=&quot;markdown.com.cn编辑器&quot;&gt;&lt;span/&gt;一致性视图ReadView&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;markdown.com.cn编辑器&quot;&gt;利用&lt;code&gt;undo log&lt;/code&gt;日志我们已经保留下了数据的各个版本，那么现在关键的问题是要读取哪个版本的数据呢？&lt;/p&gt;&lt;p data-tool=&quot;markdown.com.cn编辑器&quot;&gt;这时就需要用到&lt;code&gt;ReadView&lt;/code&gt;了，&lt;code&gt;ReadView&lt;/code&gt;就是事务在使用&lt;code&gt;MVCC&lt;/code&gt;机制进行快照读操作时产生的一致性视图, 比如针对可重复读隔离级别，是在事务启动的时候，创建一个&lt;code&gt;ReadView&lt;/code&gt;, 那&lt;code&gt;ReadView&lt;/code&gt;种都有哪些关键信息呢？&lt;/p&gt;&lt;ul data-tool=&quot;markdown.com.cn编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;trx_ids&lt;/code&gt;: 指的是在创建 &lt;code&gt;ReadView&lt;/code&gt; 时，当前数据库中「活跃事务」的事务 id 列表，注意是一个列表， &lt;strong&gt;“活跃事务”指的就是，启动了但还没提交的事务&lt;/strong&gt;。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;min_trx_id&lt;/code&gt;: 指的是在创建 &lt;code&gt;ReadView&lt;/code&gt; 时，&lt;strong&gt;当前数据库中「活跃事务」中事务 id 最小的事务&lt;/strong&gt;，也就是 m_ids 的最小值。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;max_trx_id&lt;/code&gt;：这个并不是 &lt;code&gt;m_ids&lt;/code&gt; 的最大值，而是&lt;strong&gt;创建&lt;/strong&gt; &lt;code&gt;ReadView&lt;/code&gt; &lt;strong&gt;时当前数据库中应该给下一个事务的 id 值，也就是全局事务中最大的事务 id 值 + 1&lt;/strong&gt;；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;creator_trx_id&lt;/code&gt; ：指的是创建该 &lt;code&gt;ReadView&lt;/code&gt; 的事务的事务 id, 只有在对表中的记录做改动时（执行&lt;code&gt;INSERT、DELETE、UPDATE&lt;/code&gt;这些语句时）才会为 事务分配事务id，否则在一个只读事务中的事务id值都默认为0。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;figure data-tool=&quot;markdown.com.cn编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.4185667752442997&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/oH5VKTC5sLjzmWMXvaNtlS9tOU8LZTtbzvlxbl88iaTbOdjptWOSq7J8ehRPguE5wuVXzic5ZwIFvXqEuqQ1m6Wg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1228&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;markdown.com.cn编辑器&quot;&gt;对于当前事务的启动瞬间来说，读取的一个数据版本的trx_id，有以下几种可能：&lt;/p&gt;&lt;ul data-tool=&quot;markdown.com.cn编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;如果被访问版本的&lt;code&gt;trx_id&lt;/code&gt;属性值与&lt;code&gt;ReadView&lt;/code&gt;中的 &lt;code&gt;creator_trx_id&lt;/code&gt; 值相同，意味着当前事务在访问它自己修改过的记录，所以该版本可以被当前事务访问。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;如果落在绿色部分，表示这个版本是已提交的事务或者是当前事务自己生成的，这个数据是可见的；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;如果落在红色部分，表示这个版本是由将来启动的事务生成的，是肯定不可见的；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;如果落在黄色部分，那就包括两种情况&lt;/section&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;若 数据的&lt;code&gt;trx_id&lt;/code&gt;在&lt;code&gt;trx_ids&lt;/code&gt;数组中，表示这个版本是由还没提交的事务生成的，不可见, 去读取这条数据的历史版本，这条数据的历史版本中都包含了事务id信息，去查找第一个不在活跃事务数组的版本记录。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;若 数据的&lt;code&gt;trx_id&lt;/code&gt;不在&lt;code&gt;trx_ids&lt;/code&gt;数组中，表示这个版本是已经提交了的事务生成的，可见。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/ul&gt;&lt;p data-tool=&quot;markdown.com.cn编辑器&quot;&gt;这种通过&lt;strong&gt;版本链 + 一致性视图&lt;/strong&gt; 来控制并发事务访问同一个记录时的行为就叫 MVCC（多版本并发控制），现在你明白MySQL如何实现了“秒级创建快照”的能力了吧。&lt;/p&gt;&lt;h2 data-tool=&quot;markdown.com.cn编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;还是不懂？举例说明&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;markdown.com.cn编辑器&quot;&gt;如果你对MVCC机制的整个流程还是比较模糊，我们现在举例来说明下。&lt;/p&gt;&lt;p data-tool=&quot;markdown.com.cn编辑器&quot;&gt;比如&lt;code&gt;student&lt;/code&gt;表中有一个事务id为8的插入记录：&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;insert into student(id, name, class) values(1, &#x27;张三&#x27;, &#x27;一班&#x27;)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p data-tool=&quot;markdown.com.cn编辑器&quot;&gt;我们现在在MySQL的读已提交和可重复读隔离级别下，MVCC机制的整个工作流程。&lt;/p&gt;&lt;p data-tool=&quot;markdown.com.cn编辑器&quot;&gt;MySQL中的读未提交和序列化并不需要MVCC机制，读未提交，直接读取别人未提交的数据，而序列化全程用加锁的方式，也用不上MVCC, 大家体会下。&lt;/p&gt;&lt;h3 data-tool=&quot;markdown.com.cn编辑器&quot;&gt;&lt;span/&gt;可重复读隔离级别下&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;markdown.com.cn编辑器&quot;&gt;可重复读&lt;code&gt;REPEATABLE READ&lt;/code&gt;隔离级别的事务来说，只会在第一次执行查询语句时生成一个 &lt;code&gt;ReadView&lt;/code&gt; ，之后的查询就不会重复生成了。&lt;/p&gt;&lt;blockquote data-tool=&quot;markdown.com.cn编辑器&quot;&gt;&lt;span&gt;★&lt;/span&gt;&lt;p&gt;begin/start transaction 命令并不是一个事务的起点，在执行到它们之后的第一个操作 InnoDB 表的语句，事务才真正启动。如果你想要马上启动一个事务，可以使用 start transaction with consistent snapshot 这个命令。&lt;/p&gt;&lt;span&gt;”&lt;/span&gt;&lt;/blockquote&gt;&lt;table data-tool=&quot;markdown.com.cn编辑器&quot;&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;事务10&lt;/th&gt;&lt;th&gt;事务20&lt;/th&gt;&lt;th&gt;事务30&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;beginUPDATE student SET name=&quot;李四&quot; WHERE id=1;UPDATE student SET name=&quot;王五&quot; WHERE id=1;&lt;/td&gt;&lt;td&gt;&lt;br/&gt;&lt;/td&gt;&lt;td&gt;&lt;br/&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;br/&gt;&lt;/td&gt;&lt;td&gt;begin更新了一些其他表的数据&lt;/td&gt;&lt;td&gt;&lt;br/&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;br/&gt;&lt;/td&gt;&lt;td&gt;&lt;br/&gt;&lt;/td&gt;&lt;td&gt;beginSELECT * FROM student WHERE id = 1;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;figure data-tool=&quot;markdown.com.cn编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.23506988564167725&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/oH5VKTC5sLjzmWMXvaNtlS9tOU8LZTtb8GGN6Q7kkJjoMtibmd4ibiaeKDzb3icu3oLptMpu7FJYrmiaic6S8Ro1QUsA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1574&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;markdown.com.cn编辑器&quot;&gt;事务10和20均为提交，现在事务30执行&lt;code&gt;select&lt;/code&gt;, 那么得到的结果是什么呢？&lt;/p&gt;&lt;ol data-tool=&quot;markdown.com.cn编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;在执行&lt;code&gt;select&lt;/code&gt;语句时会先生成一个&lt;code&gt;ReadView&lt;/code&gt;，ReadView的&lt;code&gt;trx_ids&lt;/code&gt;列表的内容就是&lt;code&gt;[10, 20]&lt;/code&gt;，&lt;code&gt;min_trx_id&lt;/code&gt;为10，&lt;code&gt;max_trx_id&lt;/code&gt;为21，&lt;code&gt;creator_trx_id&lt;/code&gt;为0。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;然后从版本链中挑选可见的记录，从图中看出，最新版本的列name的内容是&lt;code&gt;&#x27;王五&#x27;&lt;/code&gt;，该版本的trx_id值为10，在&lt;code&gt;trx_ids&lt;/code&gt;列表内，所以不符合可见性要求，根据&lt;code&gt;roll_pointer&lt;/code&gt;跳到下一个版本。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;下一个版本的列&lt;code&gt;name&lt;/code&gt;的内容是&lt;code&gt;&#x27;李四&#x27;&lt;/code&gt;，该版本的&lt;code&gt;trx_id&lt;/code&gt;值也为10，也在&lt;code&gt;trx_ids&lt;/code&gt;列表内，所以也不符合要求，继续跳到下一个版本。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;下一个版本的列&lt;code&gt;name&lt;/code&gt;的内容是&#x27;&lt;code&gt;张三&lt;/code&gt;&#x27;，该版本的&lt;code&gt;trx_id&lt;/code&gt;值为8，小于&lt;code&gt;ReadView&lt;/code&gt;中的&lt;code&gt;min_trx_id&lt;/code&gt;值10，说明已经提交了，那么最终返回&lt;code&gt;&#x27;张三&#x27;&lt;/code&gt;。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h3 data-tool=&quot;markdown.com.cn编辑器&quot;&gt;&lt;span/&gt;读已提交隔离级别下&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;markdown.com.cn编辑器&quot;&gt;读已提交&lt;code&gt;READ COMMITTED&lt;/code&gt;是每次读取数据前都生成一个&lt;code&gt;ReadView&lt;/code&gt;。基本的规则和流程与可重复读隔离级别一致，这里不做重复赘叙。&lt;/p&gt;&lt;h2 data-tool=&quot;markdown.com.cn编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;总结&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;markdown.com.cn编辑器&quot;&gt;本问重点介绍了MVCC机制，以及 MVCC 在 &lt;code&gt;READ COMMITTD&lt;/code&gt;、 &lt;code&gt;REPEATABLE READ&lt;/code&gt;这两种隔离级别的事务在执行快照读操作时访问记录的版本链的过程。这样使不同事务的 读-写 、 写-读 操作并发执行，从而提升系统性能。&lt;/p&gt;&lt;ul data-tool=&quot;markdown.com.cn编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;READ COMMITTD&lt;/code&gt; 在每一次进行普通&lt;code&gt;SELECT&lt;/code&gt;操作前都会生成一个&lt;code&gt;ReadView&lt;/code&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;REPEATABLE READ&lt;/code&gt;只在第一次进行普通&lt;code&gt;SELECT&lt;/code&gt;操作前生成一个&lt;code&gt;ReadView&lt;/code&gt;，之后的查询操作都重复使用这个&lt;code&gt;ReadView&lt;/code&gt;就好了。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;section&gt;&lt;mp-common-profile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mpprofile&quot; data-weui-theme=&quot;light&quot; data-id=&quot;MzkzMDI1NjcyOQ==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/EoJib2tNvVtf7icAmS0BQH6oDVG37Q8NzcfdguS5qAqOhfxvZyIKqmuX5BbnDjynrBbZzktp1EiaeFLzapp1nHysw/0?wx_fmt=png&quot; data-nickname=&quot;码哥字节&quot; data-alias=&quot;MageByte&quot; data-signature=&quot;拥抱硬核技术和对象，面向人民币编程。&quot; data-from=&quot;0&quot; data-is_biz_ban=&quot;0&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;blockquote data-tool=&quot;markdown.com.cn编辑器&quot;&gt;&lt;span&gt;★&lt;/span&gt;&lt;p&gt;如果本文对你有帮助的话，请留下一个赞吧&lt;/p&gt;&lt;span&gt;”&lt;/span&gt;&lt;/blockquote&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>5ca3bbc74f762c67b42c59f3482e4af2</guid>
<title>打工人的困境</title>
<link>https://toutiao.io/k/ex31nt3</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;entry-content&quot; itemprop=&quot;articleBody&quot;&gt;&amp;#13;
&lt;p&gt;近期在公司内部QE社区举办了一场研讨会，主题是《QA角色职业发展机遇讨论》。收集到以下观点，觉得挺有意思，又不局限于特定角色，于是用XX代替QA。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;无论是在公司内部还是外部，XX都是单独作战居多，从他人身上学习的机会较少。&lt;/li&gt;
&lt;li&gt;XX最终的发展，技术或管理，技术就一定需要代码能力很强吗？&lt;/li&gt;
&lt;li&gt;如果XX一直走技术路线，能达到什么高度？&lt;/li&gt;
&lt;li&gt;XX行业上升通道天花板比其他角色低。&lt;/li&gt;
&lt;li&gt;据传XX行业萎缩，门槛低，管道压力大。&lt;/li&gt;
&lt;li&gt;发展方向很多，不容易选择。&lt;/li&gt;
&lt;li&gt;工作本身已经失去了成长价值。&lt;/li&gt;
&lt;li&gt;想推动一些优秀实践，但推不动或者效果不好，怎么办？&lt;/li&gt;
&lt;/ol&gt;
&lt;h2&gt;打工人的发展困境&lt;/h2&gt;
&lt;p&gt;从观点中可以看出，不少伙伴对自己未来的职业发展充满了困惑，主要集中在以下几个方面：价值感缺失、晋升通道不明朗、干系人不满意，下面我们来展开详细的讨论。&lt;/p&gt;
&lt;h3&gt;价值感缺失&lt;/h3&gt;
&lt;p&gt;价值感缺失，正常又普遍。我们所做的大部分重复性事务，都很难说有多高的价值。喜欢的音乐，设置成闹铃后就会厌倦；美味的食物，反复吃就味同嚼蜡；你爱谈天我爱笑，也会从一往情深走到相看两厌。&lt;/p&gt;
&lt;p&gt;并不是事物本身发生了变化，而是体验者心境变了，人性本就厌恶重复。不仅大量重复的手动测试会造成价值感缺失，大量重复的写自动化测试、写业务代码、写需求卡片，都一样会厌倦。究其根本，不断重复会提升熟练程度，由最初的思考产生决策变为依赖经验主义，逐渐失去挑战、步入舒适区，不再汲取新的东西，没有新的收获，也就体会不到价值。&lt;/p&gt;
&lt;p&gt;这不是某单一角色特有的问题，从普通而又琐碎的日常中寻找价值，是每个人都需要面临的问题。&lt;/p&gt;
&lt;h3&gt;晋升通道不明朗&lt;/h3&gt;
&lt;p&gt;传统的人才结构中，有“双通道职业发展体系”，不管是走管理路线，还是走技术路线，发展通道都是明确的，我们都有光明的未来。在这个体系中的每个人，都知道自己可能的发展方向和晋升通道。但那是以前。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://insights.thoughtworks.cn/wp-content/uploads/2022/12/image4.png&quot;&gt;&lt;img src=&quot;https://insights.thoughtworks.cn/wp-content/uploads/2022/12/image4.png&quot; alt=&quot;双通道职业发展体系&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;现在面临的一些具体的职业发展问题，已经无法简单的用这两个晋升通道解决了。比如：晋升困难怎么办？想转换角色，该怎么转、该学什么？如果这两边都不想走，还有没有第三条路？我想做的事情在现有环境里没有对应角色，怎么处理？&lt;/p&gt;
&lt;p&gt;晋升通道不明朗，或者干脆就没有，这也不是某单一角色特有的问题，每个职场人在某些特定的环境或阶段，都会面临这个问题。&lt;/p&gt;
&lt;h3&gt;干系人不满意&lt;/h3&gt;
&lt;p&gt;“我想要一个苹果，你却给了我一车梨。” 难的是遇见理解。&lt;/p&gt;
&lt;p&gt;相互理解实在太难，如果不具备超好的洞察力，难免牵涉自身产生情绪波动。他何以絮絮叨叨，眉头紧皱，他又为什么低头沉默，暴跳如雷？面对责难，转念想想也许他不是针对你，他只是在表达他自己。你需要做的可能是看到现象、确认问题和剥离情绪，一边解决情绪，一边解决问题。&lt;/p&gt;
&lt;p&gt;干系人不满意，原因可能有很多：给的并非他想要，没及时响应，表达欠佳等。当然也可能是对方的原因，理解不充分，期望过高，或者干脆心情不好。但凡是对方的原因，其实也都能转化成我们的能力缺失。向内归因有益于持续进步，毕竟我们能掌控的只有自身，其他外界因素都可以归为对外部风险的把控能力。&lt;/p&gt;
&lt;h2&gt;可能有效的尝试&lt;/h2&gt;
&lt;h3&gt;获得认同&lt;/h3&gt;
&lt;p&gt;当改进推动不利时，需要分析一下是过程把控不足，还是影响力不够。如果是过程把控不足，可以采用一些现成的工具来加强过程管理。如果是影响力不够，就需要考虑如何增加影响力。&lt;/p&gt;
&lt;p&gt;影响力的具体体现是什么？别人对你的认同感。可以是认同你的某些观点，你对外体现出的专业度，或者干脆是对你整个人都很认同。这样一来，提升影响力就转化成了寻求认同。以下是几个有效获得认同的小技巧：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;真诚&lt;/li&gt;
&lt;li&gt;微笑、眼神交流&lt;/li&gt;
&lt;li&gt;全神贯注&lt;/li&gt;
&lt;li&gt;具有同理心&lt;/li&gt;
&lt;li&gt;体现专业度&lt;/li&gt;
&lt;li&gt;展示共同点&lt;/li&gt;
&lt;li&gt;表情管理&lt;/li&gt;
&lt;li&gt;形象管理&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;当然，技巧只是辅助，人与人之间也有相互的场域。是这个人整体对外展现的独特气质让你如沐春风或如坐针毡，而非一时一事的得与失。因此，我们是寻求认同而非强求认同，强求认同是病是灾难，得治，求大同而存小异，方得太平。&lt;/p&gt;
&lt;h3&gt;过程管理&lt;/h3&gt;
&lt;p&gt;团队合作难免驱动他人或被他人所驱动，推进过程大都磕磕绊绊并不顺利。你有张良计，我有过墙梯，玩着玩着就打回原形了。&lt;/p&gt;
&lt;p&gt;当团队已达成共识但推进仍受阻时，可进行过程拆解或参考一些既有的框架进行归因分析。如下图：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://insights.thoughtworks.cn/wp-content/uploads/2022/12/image5.png&quot;&gt;&lt;img src=&quot;https://insights.thoughtworks.cn/wp-content/uploads/2022/12/image5-1024x812.png&quot; alt=&quot;问题受阻的自检清单&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p/&gt;&lt;center&gt;问题受阻的自检清单&lt;/center&gt;
&lt;h3&gt;寻求支持&lt;/h3&gt;
&lt;p&gt;责任心过强的人事必躬亲，往往深陷于具体的执行细节，持续焦虑，进退两难。此时，再多的纠结也无益，不如向外寻求支持。&lt;/p&gt;
&lt;p&gt;一个具体的场景：当我们需要进行质量改进时，难免给团队内的其他角色带来“额外”的工作量，当改进行动项受阻时，我们难免感到沮丧。那么在此时，我们是否获得了关键干系人如项目经理、研发经理的支持？关于改进方案，我们是否与团队内所有成员对齐并达成共识？有时可能并不是大家不支持我们的工作，而是不清楚我们到底要做什么，以及该如何配合我们。&lt;/p&gt;
&lt;p&gt;当工作受阻时，闷声吃瘪不如大方沟通，充分调动外部资源的支持，事半功倍。&lt;/p&gt;
&lt;h3&gt;培养持续胜任力&lt;/h3&gt;
&lt;p&gt;以前我们讲 “不怕千招会，就怕一招灵”，“学遍数理化，走遍天下都不怕”。而在现今社会能够脱颖而出的，一定是一个生动立体的人，而不是某个特定的标签角色。&lt;/p&gt;
&lt;p&gt;我刚入行时，测试人员会做自动化测试是加分项，而现在这只是一项基本技能。胜任力不再一成不变，而是随着时代的推移在持续变化。&lt;strong&gt;当下的胜任力不再说明任何问题，&lt;/strong&gt;我们需要找到能够以不变应万变的元技能，以培养持续胜任力。每个人基于自己的情况可能会定义出不同的元技能模型。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://insights.thoughtworks.cn/wp-content/uploads/2022/12/image7.png&quot;&gt;&lt;img src=&quot;https://insights.thoughtworks.cn/wp-content/uploads/2022/12/image7.png&quot; alt=&quot;元技能模型示例&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p/&gt;&lt;center&gt;元技能模型示例&lt;/center&gt;
&lt;h2&gt;思维层面的转变&lt;/h2&gt;
&lt;h3&gt;主动规划&lt;/h3&gt;
&lt;p&gt;人人都是产品经理，此言不虚。就算不做软件，也都规划着自己的人生。不妨自问一些问题，帮助自己找到个人定位：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;我感兴趣的工作是什么？&lt;/li&gt;
&lt;li&gt;我擅长做什么？不擅长做什么？&lt;/li&gt;
&lt;li&gt;我为哪些人提供服务？&lt;/li&gt;
&lt;li&gt;我提供什么样的服务？&lt;/li&gt;
&lt;li&gt;我喜欢和谁一起工作？&lt;/li&gt;
&lt;li&gt;我喜欢什么样的领导？&lt;/li&gt;
&lt;li&gt;相比于其他同类角色，我独有的优势是什么？&lt;/li&gt;
&lt;li&gt;怎么能持续保持自己的优势？&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;当自我认知清晰后，就可以参考业内的通用成长路径，去考虑如何适配自己的情况了。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://insights.thoughtworks.cn/wp-content/uploads/2022/12/image1.png&quot;&gt;&lt;img src=&quot;https://insights.thoughtworks.cn/wp-content/uploads/2022/12/image1-1024x519.png&quot; alt=&quot;通用成长路径&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;张弛有度&lt;/h3&gt;
&lt;p&gt;当你在强迫性的进行苦思冥想、严重内耗时，身体状态会变差，自我察觉会变低，对外界的反馈会更迟钝。这将使自己置身于一个危险的境地，看不清周遭的环境，驱不动疲惫的身心，进而“鬼使神差”地做出错误的判断。&lt;/p&gt;
&lt;p&gt;察觉到自己处在这样的状态，需要立刻停止钻牛角尖，投入到另一件事中去。可以是理发、洗澡、睡觉、吃大餐……减少或停止信息输入，给自己一小段时间清除内存，彻底躺平，调整心情并重启，也许就柳暗花明了。&lt;/p&gt;
&lt;p&gt;然后能明白，我就是困了累了，需要休息。一张一弛才是文武之道。&lt;/p&gt;
&lt;h3&gt;专注所长&lt;/h3&gt;
&lt;p&gt;“人的存在要以具体的行动融入到时间里。”&lt;/p&gt;
&lt;p&gt;
——张凯峰&lt;/p&gt;
&lt;p&gt;各行各业佼佼者甚少，几乎每个人都是平凡的大多数。天资所限，在某些方面，特定个人注定难有建树。我们都擅长一些事情，同时也不擅长着另一些事情。&lt;/p&gt;
&lt;p&gt;取我之所短比人之所长，肯定不会乐观。扬长补短是个伪命题，对三观稳定的成人来说，扬长避短或许才是经济的做法。把自己不擅长的事情“外包”给专业人士，每个人奔着相同的愿景，以最大程度贡献专长，才能获得整体合力的最大化。&lt;/p&gt;
&lt;p&gt;对于个人来讲，只在自己所长之处持续发力，维持一定的节奏即可。个人注定还是不会偏离既定的轨道，这条路上没有别人，只有自己。何以抵抗虚无？唯有以具体的行为坚持不懈的努力，其他交给时间就好。&lt;/p&gt;
&amp;#13;
&lt;/div&gt;&amp;#13;
&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>59d305600d93d84d9ac77f46839a043f</guid>
<title>Raft 中日志的一致性检查貌似会导致日志复制的串行化，这个在实际工程实践中有什么优化方案？</title>
<link>https://toutiao.io/k/u4dnd17</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content js_underline_content             autoTypeSetting24psection&amp;#10;            &quot; id=&quot;js_content&quot;&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.4781456953642384&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Xxt327ybUOXklK2xB50CYFO3Xo6kI7eyzjx7T87ImuuibeXUiaC0EBvaWR3J7LgdntjicrWMriaKdusyl3KrAP9PXw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;755&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;这个问题也太好了，涉及到Paxos和Raft的原理以及优化。&lt;/p&gt;&lt;p&gt;先肯定题主的理解，是正确的。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;既然这里是为了证明Paxos的并行协商不一定优于Raft的串行协商，所以这里不讨论采用串行协商带来的坏处，和并行协商的好处，另外这些也不难总结。&lt;span/&gt;&lt;/p&gt;&lt;section&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section data-role=&quot;outer&quot; label=&quot;Powered by 135editor.com&quot;&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;1&quot;&gt;&lt;section data-custom=&quot;#59c3f9&quot;&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;Raft的串行协商好处&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;但是以上两点并不代表Paxos的并行协商效率优于Raft串行协商效率。Raft的串行协商，带来了很多好处，例如：&lt;/span&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;将协商优化为“一阶段”提交，“提交阶段”通过心跳或者下一次来完整。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;检查差异性，检查两个成员之间的一段日志是否一致，不必通过checksum等机制来完成，只需要比较最大的日志项的term是否一致即可。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;读请求优化，保证线性一致性读，通常需要read log来完成。但是Raft是串行协商的，并且引入了Leader，可以有很多优化方案，例如：Leader Read，Follower Read，Lease Read。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;这里不讨论采用串行协商带来的坏处，但是可以简单提一提：引入Leader，降低了可用性；Leader成为性能瓶颈；浪费大量的计算资源（单个协商，一定是吃不满所有的资源的）....&lt;span/&gt;&lt;/p&gt;&lt;section&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section data-role=&quot;outer&quot; label=&quot;Powered by 135editor.com&quot;&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;1&quot;&gt;&lt;section data-custom=&quot;#59c3f9&quot;&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;Paxos的并行协商坏处&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;并行协商确实给Paxos带来很多好处，例如，灵活性，优于Raft的可用性。但是单从协商效率来说，Paxos真不一定比得过Raft，有以下几个原因：&lt;/span&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;活锁，是指多个Proposer同时争夺某个key的写权限，陷入循环之中。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;协商阶段较多，Paxos协商就需要两个阶段（prepare+accept），另外需要一个提交阶段（confirm），当然可以优化prepare阶段。但是优化prepare阶段的条件，依旧是执行prepare阶段。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;数据对齐，新成员上线或者要明确两个成员之间数据是否一致，需要对所有的key都执行一次paxos协商。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;读请求，暂时只知道通过read log来实现。Leader Read，Follower Read，Lease Read是否能应用于Paxos，暂时还没有思考，可能能应用的条件也是需要引入一个中央权威成员吧。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section data-role=&quot;outer&quot; label=&quot;Powered by 135editor.com&quot;&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;1&quot;&gt;&lt;section data-custom=&quot;#59c3f9&quot;&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;Raft的串行协商是否能够优化？&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;题主其实无需苦恼&lt;/span&gt;&lt;span&gt;串行协商，Raft本身就是一个优化后的算法，协商效率很高了，如果担心资源浪费，可以部署多个Raft组，让他们服务不同业务，使得达到并行协商的目的。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;另外如果执着于并行协商，当然也有一些优化方案，例如：Parallel Raft。&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;mp-style-type data-value=&quot;3&quot;/&gt;&lt;/p&gt;&lt;/div&gt;

          
        &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>0d99c324f0e3cc1ab94122b39de1f486</guid>
<title>SpringBoot 中使用 Spring-Retry 重试框架（第 454 篇）</title>
<link>https://toutiao.io/k/2bmrfmg</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content js_underline_content             autoTypeSetting24psection&amp;#10;            &quot; id=&quot;js_content&quot;&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.38832997987927564&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/P13HW4Fm1HW79QW7PvMXd0lf8ticWZeibBjrEDeQXw39ZUlia3dW5mRxD9UVpZm4mgG1qQwsaavpbKzEmU1Kcxbkw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1988&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;悟纤：最近我看到自己之前的&lt;span lang=&quot;EN-US&quot;&gt;try/catch&lt;/span&gt;、&lt;span lang=&quot;EN-US&quot;&gt;while&lt;/span&gt;代码进行请求的重试，看着很不舒服。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.41184971098265893&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/P13HW4Fm1HW79QW7PvMXd0lf8ticWZeibBSEeibbTGia9ku0G0gJAC17RO3cfuCIynUnNEpda3jFQpZV7AWd0zKJWA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1384&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;师傅：确实了，为师以前也是写出过这样的一堆难看的代码。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.5063025210084033&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/P13HW4Fm1HW79QW7PvMXd0lf8ticWZeibBHeqj3zicB3ibUXSib8vTFwMCUTsDb4TVk1c8nbcMK1aia79ibagnG7VA3CQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;952&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;悟纤：那师傅这个事情有解吗？&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;师傅：徒儿，你只要记住一个问题，但凡一个问题是普遍的问题，那么一定会有解决方案的。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;悟纤：还能这么思考，棒极了。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;师傅：那你去找找解决方案，输出文章让大家一起学习下呗。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;悟纤：好勒，马上行动起来&lt;span lang=&quot;EN-US&quot;&gt;~~~&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.4791889007470651&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/P13HW4Fm1HW79QW7PvMXd0lf8ticWZeibBmqkUsWfSmHJegR6c7asDU5W0hZLlTtPj9eiaDFAQryL0o3T5FckMI5A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1874&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span lang=&quot;EN-US&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;导读&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;不小心看到很久很久的历史代码：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.7783132530120482&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/P13HW4Fm1HW79QW7PvMXd0lf8ticWZeibBV1ic09DeX9SWyZ82Ydk1KggrF7ia962V87aNVYcdcSFtIXEVA7FicwugQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;830&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;这个代码逻辑实现了网络异常或者没有获取到想要的状态，就根据一定的策略进行重试。&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;如果代码中很多地方都有这样的代码，那将是一场灾难。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;对于上面的场景&lt;span lang=&quot;EN-US&quot;&gt;Spring-Retry&lt;/span&gt;就能轻松的搞定。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;一、何为&lt;span lang=&quot;EN-US&quot;&gt;Spring-Retry&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在实际工作中，重处理是一个非常常见的场景。通常来说，会用&lt;span lang=&quot;EN-US&quot;&gt;try/catch&lt;/span&gt;，&lt;span lang=&quot;EN-US&quot;&gt;while&lt;/span&gt;循环之类的语法来进行重处理，但是这样的做法缺乏统一性，并且不是很方便，要多写很多代码。然而&lt;span lang=&quot;EN-US&quot;&gt;spring-retry&lt;/span&gt;却可以通过注解，在不入侵原有业务逻辑代码的方式下，优雅的实现重处理功能。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span lang=&quot;EN-US&quot;&gt;1.1 &lt;/span&gt;&lt;/strong&gt;&lt;strong&gt;&lt;span&gt;使用场景&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;重处理场景很多，比如：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;（&lt;span lang=&quot;EN-US&quot;&gt;1&lt;/span&gt;）发送消息失败。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;（&lt;span lang=&quot;EN-US&quot;&gt;2&lt;/span&gt;）调用远程服务失败。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;（&lt;span lang=&quot;EN-US&quot;&gt;3&lt;/span&gt;）争抢锁失败。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span lang=&quot;EN-US&quot;&gt;1.2 Spring-Retry&lt;/span&gt;&lt;/strong&gt;&lt;strong&gt;&lt;span&gt;是什么？&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span lang=&quot;EN-US&quot;&gt;spring-retry&lt;/span&gt;&lt;span&gt;是是&lt;span lang=&quot;EN-US&quot;&gt;spring&lt;/span&gt;提供的一个重试框架，原本自己实现的重试机制，现在&lt;span lang=&quot;EN-US&quot;&gt;spring&lt;/span&gt;帮封装好提供更加好的编码体验。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;二、&lt;span lang=&quot;EN-US&quot;&gt;Spring-Retry&lt;/span&gt;基本使用&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span lang=&quot;EN-US&quot;&gt;2.1 &lt;/span&gt;&lt;/strong&gt;&lt;strong&gt;&lt;span&gt;基本使用&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;基本思路是引入&lt;span lang=&quot;EN-US&quot;&gt;spring-retry&lt;/span&gt;，由于&lt;span lang=&quot;EN-US&quot;&gt;spring-retry&lt;/span&gt;使用到了&lt;span lang=&quot;EN-US&quot;&gt;aop&lt;/span&gt;，所以也要把&lt;span lang=&quot;EN-US&quot;&gt;aop&lt;/span&gt;的依赖进行添加。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;大体使用步骤：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;（&lt;span lang=&quot;EN-US&quot;&gt;1&lt;/span&gt;）创建一个项目&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;（&lt;span lang=&quot;EN-US&quot;&gt;2&lt;/span&gt;）添加依赖&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;（&lt;span lang=&quot;EN-US&quot;&gt;3&lt;/span&gt;）启用&lt;span lang=&quot;EN-US&quot;&gt;Spring-Retry&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;（&lt;span lang=&quot;EN-US&quot;&gt;4&lt;/span&gt;）使用&lt;span lang=&quot;EN-US&quot;&gt;@Retryable&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;（&lt;span lang=&quot;EN-US&quot;&gt;5&lt;/span&gt;）测试&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span lang=&quot;EN-US&quot;&gt;2.1 &lt;/span&gt;&lt;/strong&gt;&lt;strong&gt;&lt;span&gt;创建一个项目&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;使用&lt;span lang=&quot;EN-US&quot;&gt;idea&lt;/span&gt;创建项目&lt;span lang=&quot;EN-US&quot;&gt;springboot-retry-demo&lt;/span&gt;。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span lang=&quot;EN-US&quot;&gt;2.2 &lt;/span&gt;&lt;/strong&gt;&lt;strong&gt;&lt;span&gt;添加依赖&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在&lt;span lang=&quot;EN-US&quot;&gt;pom.xml&lt;/span&gt;文件中添加依赖：&lt;/span&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;xml&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__meta&quot;&gt;&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__tag&quot;&gt;&amp;lt;&lt;span class=&quot;code-snippet__name&quot;&gt;project&lt;/span&gt; &lt;span class=&quot;code-snippet__attr&quot;&gt;xmlns&lt;/span&gt;=&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;http://maven.apache.org/POM/4.0.0&quot;&lt;/span&gt; &lt;span class=&quot;code-snippet__attr&quot;&gt;xmlns:xsi&lt;/span&gt;=&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;http://www.w3.org/2001/XMLSchema-instance&quot;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;         &lt;span class=&quot;code-snippet__attr&quot;&gt;xsi:schemaLocation&lt;/span&gt;=&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__tag&quot;&gt;&amp;lt;&lt;span class=&quot;code-snippet__name&quot;&gt;modelVersion&lt;/span&gt;&amp;gt;&lt;/span&gt;4.0.0&lt;span class=&quot;code-snippet__tag&quot;&gt;&amp;lt;/&lt;span class=&quot;code-snippet__name&quot;&gt;modelVersion&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__tag&quot;&gt;&amp;lt;&lt;span class=&quot;code-snippet__name&quot;&gt;parent&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__tag&quot;&gt;&amp;lt;&lt;span class=&quot;code-snippet__name&quot;&gt;groupId&lt;/span&gt;&amp;gt;&lt;/span&gt;org.springframework.boot&lt;span class=&quot;code-snippet__tag&quot;&gt;&amp;lt;/&lt;span class=&quot;code-snippet__name&quot;&gt;groupId&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__tag&quot;&gt;&amp;lt;&lt;span class=&quot;code-snippet__name&quot;&gt;artifactId&lt;/span&gt;&amp;gt;&lt;/span&gt;spring-boot-starter-parent&lt;span class=&quot;code-snippet__tag&quot;&gt;&amp;lt;/&lt;span class=&quot;code-snippet__name&quot;&gt;artifactId&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__tag&quot;&gt;&amp;lt;&lt;span class=&quot;code-snippet__name&quot;&gt;version&lt;/span&gt;&amp;gt;&lt;/span&gt;2.7.6&lt;span class=&quot;code-snippet__tag&quot;&gt;&amp;lt;/&lt;span class=&quot;code-snippet__name&quot;&gt;version&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__tag&quot;&gt;&amp;lt;&lt;span class=&quot;code-snippet__name&quot;&gt;relativePath&lt;/span&gt;/&amp;gt;&lt;/span&gt; &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__tag&quot;&gt;&amp;lt;/&lt;span class=&quot;code-snippet__name&quot;&gt;parent&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__tag&quot;&gt;&amp;lt;&lt;span class=&quot;code-snippet__name&quot;&gt;groupId&lt;/span&gt;&amp;gt;&lt;/span&gt;com.kfit&lt;span class=&quot;code-snippet__tag&quot;&gt;&amp;lt;/&lt;span class=&quot;code-snippet__name&quot;&gt;groupId&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__tag&quot;&gt;&amp;lt;&lt;span class=&quot;code-snippet__name&quot;&gt;artifactId&lt;/span&gt;&amp;gt;&lt;/span&gt;springboot-retry-demo&lt;span class=&quot;code-snippet__tag&quot;&gt;&amp;lt;/&lt;span class=&quot;code-snippet__name&quot;&gt;artifactId&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__tag&quot;&gt;&amp;lt;&lt;span class=&quot;code-snippet__name&quot;&gt;version&lt;/span&gt;&amp;gt;&lt;/span&gt;0.0.1-SNAPSHOT&lt;span class=&quot;code-snippet__tag&quot;&gt;&amp;lt;/&lt;span class=&quot;code-snippet__name&quot;&gt;version&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__tag&quot;&gt;&amp;lt;&lt;span class=&quot;code-snippet__name&quot;&gt;name&lt;/span&gt;&amp;gt;&lt;/span&gt;springboot-retry-demo&lt;span class=&quot;code-snippet__tag&quot;&gt;&amp;lt;/&lt;span class=&quot;code-snippet__name&quot;&gt;name&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__tag&quot;&gt;&amp;lt;&lt;span class=&quot;code-snippet__name&quot;&gt;description&lt;/span&gt;&amp;gt;&lt;/span&gt;springboot-retry-demo&lt;span class=&quot;code-snippet__tag&quot;&gt;&amp;lt;/&lt;span class=&quot;code-snippet__name&quot;&gt;description&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__tag&quot;&gt;&amp;lt;&lt;span class=&quot;code-snippet__name&quot;&gt;properties&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__tag&quot;&gt;&amp;lt;&lt;span class=&quot;code-snippet__name&quot;&gt;java.version&lt;/span&gt;&amp;gt;&lt;/span&gt;1.8&lt;span class=&quot;code-snippet__tag&quot;&gt;&amp;lt;/&lt;span class=&quot;code-snippet__name&quot;&gt;java.version&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__tag&quot;&gt;&amp;lt;/&lt;span class=&quot;code-snippet__name&quot;&gt;properties&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__tag&quot;&gt;&amp;lt;&lt;span class=&quot;code-snippet__name&quot;&gt;dependencies&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__tag&quot;&gt;&amp;lt;&lt;span class=&quot;code-snippet__name&quot;&gt;dependency&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            &lt;span class=&quot;code-snippet__tag&quot;&gt;&amp;lt;&lt;span class=&quot;code-snippet__name&quot;&gt;groupId&lt;/span&gt;&amp;gt;&lt;/span&gt;org.springframework.boot&lt;span class=&quot;code-snippet__tag&quot;&gt;&amp;lt;/&lt;span class=&quot;code-snippet__name&quot;&gt;groupId&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            &lt;span class=&quot;code-snippet__tag&quot;&gt;&amp;lt;&lt;span class=&quot;code-snippet__name&quot;&gt;artifactId&lt;/span&gt;&amp;gt;&lt;/span&gt;spring-boot-starter-web&lt;span class=&quot;code-snippet__tag&quot;&gt;&amp;lt;/&lt;span class=&quot;code-snippet__name&quot;&gt;artifactId&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__tag&quot;&gt;&amp;lt;/&lt;span class=&quot;code-snippet__name&quot;&gt;dependency&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__tag&quot;&gt;&amp;lt;&lt;span class=&quot;code-snippet__name&quot;&gt;dependency&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            &lt;span class=&quot;code-snippet__tag&quot;&gt;&amp;lt;&lt;span class=&quot;code-snippet__name&quot;&gt;groupId&lt;/span&gt;&amp;gt;&lt;/span&gt;org.springframework.retry&lt;span class=&quot;code-snippet__tag&quot;&gt;&amp;lt;/&lt;span class=&quot;code-snippet__name&quot;&gt;groupId&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            &lt;span class=&quot;code-snippet__tag&quot;&gt;&amp;lt;&lt;span class=&quot;code-snippet__name&quot;&gt;artifactId&lt;/span&gt;&amp;gt;&lt;/span&gt;spring-retry&lt;span class=&quot;code-snippet__tag&quot;&gt;&amp;lt;/&lt;span class=&quot;code-snippet__name&quot;&gt;artifactId&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__tag&quot;&gt;&amp;lt;/&lt;span class=&quot;code-snippet__name&quot;&gt;dependency&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__tag&quot;&gt;&amp;lt;&lt;span class=&quot;code-snippet__name&quot;&gt;dependency&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            &lt;span class=&quot;code-snippet__tag&quot;&gt;&amp;lt;&lt;span class=&quot;code-snippet__name&quot;&gt;groupId&lt;/span&gt;&amp;gt;&lt;/span&gt;org.springframework.boot&lt;span class=&quot;code-snippet__tag&quot;&gt;&amp;lt;/&lt;span class=&quot;code-snippet__name&quot;&gt;groupId&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            &lt;span class=&quot;code-snippet__tag&quot;&gt;&amp;lt;&lt;span class=&quot;code-snippet__name&quot;&gt;artifactId&lt;/span&gt;&amp;gt;&lt;/span&gt;spring-boot-starter-aop&lt;span class=&quot;code-snippet__tag&quot;&gt;&amp;lt;/&lt;span class=&quot;code-snippet__name&quot;&gt;artifactId&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__tag&quot;&gt;&amp;lt;/&lt;span class=&quot;code-snippet__name&quot;&gt;dependency&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__tag&quot;&gt;&amp;lt;&lt;span class=&quot;code-snippet__name&quot;&gt;dependency&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            &lt;span class=&quot;code-snippet__tag&quot;&gt;&amp;lt;&lt;span class=&quot;code-snippet__name&quot;&gt;groupId&lt;/span&gt;&amp;gt;&lt;/span&gt;org.springframework.boot&lt;span class=&quot;code-snippet__tag&quot;&gt;&amp;lt;/&lt;span class=&quot;code-snippet__name&quot;&gt;groupId&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            &lt;span class=&quot;code-snippet__tag&quot;&gt;&amp;lt;&lt;span class=&quot;code-snippet__name&quot;&gt;artifactId&lt;/span&gt;&amp;gt;&lt;/span&gt;spring-boot-starter-test&lt;span class=&quot;code-snippet__tag&quot;&gt;&amp;lt;/&lt;span class=&quot;code-snippet__name&quot;&gt;artifactId&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            &lt;span class=&quot;code-snippet__tag&quot;&gt;&amp;lt;&lt;span class=&quot;code-snippet__name&quot;&gt;scope&lt;/span&gt;&amp;gt;&lt;/span&gt;test&lt;span class=&quot;code-snippet__tag&quot;&gt;&amp;lt;/&lt;span class=&quot;code-snippet__name&quot;&gt;scope&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__tag&quot;&gt;&amp;lt;/&lt;span class=&quot;code-snippet__name&quot;&gt;dependency&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__tag&quot;&gt;&amp;lt;/&lt;span class=&quot;code-snippet__name&quot;&gt;dependencies&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__tag&quot;&gt;&amp;lt;&lt;span class=&quot;code-snippet__name&quot;&gt;build&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__tag&quot;&gt;&amp;lt;&lt;span class=&quot;code-snippet__name&quot;&gt;plugins&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            &lt;span class=&quot;code-snippet__tag&quot;&gt;&amp;lt;&lt;span class=&quot;code-snippet__name&quot;&gt;plugin&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                &lt;span class=&quot;code-snippet__tag&quot;&gt;&amp;lt;&lt;span class=&quot;code-snippet__name&quot;&gt;groupId&lt;/span&gt;&amp;gt;&lt;/span&gt;org.springframework.boot&lt;span class=&quot;code-snippet__tag&quot;&gt;&amp;lt;/&lt;span class=&quot;code-snippet__name&quot;&gt;groupId&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                &lt;span class=&quot;code-snippet__tag&quot;&gt;&amp;lt;&lt;span class=&quot;code-snippet__name&quot;&gt;artifactId&lt;/span&gt;&amp;gt;&lt;/span&gt;spring-boot-maven-plugin&lt;span class=&quot;code-snippet__tag&quot;&gt;&amp;lt;/&lt;span class=&quot;code-snippet__name&quot;&gt;artifactId&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            &lt;span class=&quot;code-snippet__tag&quot;&gt;&amp;lt;/&lt;span class=&quot;code-snippet__name&quot;&gt;plugin&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__tag&quot;&gt;&amp;lt;/&lt;span class=&quot;code-snippet__name&quot;&gt;plugins&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__tag&quot;&gt;&amp;lt;/&lt;span class=&quot;code-snippet__name&quot;&gt;build&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__tag&quot;&gt;&amp;lt;/&lt;span class=&quot;code-snippet__name&quot;&gt;project&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span lang=&quot;EN-US&quot;&gt;2.3 &lt;/span&gt;&lt;/strong&gt;&lt;strong&gt;&lt;span&gt;启用&lt;span lang=&quot;EN-US&quot;&gt;Spring-Retry&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在启动类添加注解&lt;span lang=&quot;EN-US&quot;&gt;@EnableRetry&lt;/span&gt;启用&lt;span lang=&quot;EN-US&quot;&gt;Spring-Retry&lt;/span&gt;：&lt;/span&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;java&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__meta&quot;&gt;@SpringBootApplication&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__meta&quot;&gt;@EnableRetry&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;code-snippet__class&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;SpringbootRetryDemoApplication&lt;/span&gt; &lt;/span&gt;{&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;code-snippet__params&quot;&gt;(String[] args)&lt;/span&gt; &lt;/span&gt;{&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        SpringApplication.run(SpringbootRetryDemoApplication.class, args);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span lang=&quot;EN-US&quot;&gt;2.4 &lt;/span&gt;&lt;/strong&gt;&lt;strong&gt;&lt;span&gt;使用&lt;span lang=&quot;EN-US&quot;&gt;@Retryable&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在需要重试的方法添加&lt;span lang=&quot;EN-US&quot;&gt;@Retryable&lt;/span&gt;注解：&lt;/span&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;css&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__selector-tag&quot;&gt;package&lt;/span&gt; &lt;span class=&quot;code-snippet__selector-tag&quot;&gt;com&lt;/span&gt;&lt;span class=&quot;code-snippet__selector-class&quot;&gt;.kfit&lt;/span&gt;&lt;span class=&quot;code-snippet__selector-class&quot;&gt;.demo&lt;/span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__selector-tag&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;code-snippet__selector-tag&quot;&gt;org&lt;/span&gt;&lt;span class=&quot;code-snippet__selector-class&quot;&gt;.springframework&lt;/span&gt;&lt;span class=&quot;code-snippet__selector-class&quot;&gt;.retry&lt;/span&gt;&lt;span class=&quot;code-snippet__selector-class&quot;&gt;.annotation&lt;/span&gt;&lt;span class=&quot;code-snippet__selector-class&quot;&gt;.Retryable&lt;/span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__selector-tag&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;code-snippet__selector-tag&quot;&gt;org&lt;/span&gt;&lt;span class=&quot;code-snippet__selector-class&quot;&gt;.springframework&lt;/span&gt;&lt;span class=&quot;code-snippet__selector-class&quot;&gt;.stereotype&lt;/span&gt;&lt;span class=&quot;code-snippet__selector-class&quot;&gt;.Service&lt;/span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__selector-tag&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;code-snippet__selector-tag&quot;&gt;java&lt;/span&gt;&lt;span class=&quot;code-snippet__selector-class&quot;&gt;.util&lt;/span&gt;&lt;span class=&quot;code-snippet__selector-class&quot;&gt;.Date&lt;/span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;@&lt;span class=&quot;code-snippet__keyword&quot;&gt;Service&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;public class Demo1Service {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    @&lt;span class=&quot;code-snippet__keyword&quot;&gt;Retryable&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    public void call() {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__selector-tag&quot;&gt;System&lt;/span&gt;&lt;span class=&quot;code-snippet__selector-class&quot;&gt;.out&lt;/span&gt;&lt;span class=&quot;code-snippet__selector-class&quot;&gt;.println&lt;/span&gt;(&quot;准备发起&lt;span class=&quot;code-snippet__selector-tag&quot;&gt;RPC&lt;/span&gt;调用...&quot;+&lt;span class=&quot;code-snippet__selector-tag&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;code-snippet__selector-tag&quot;&gt;Date&lt;/span&gt;());&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__selector-tag&quot;&gt;throw&lt;/span&gt; &lt;span class=&quot;code-snippet__selector-tag&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;code-snippet__selector-tag&quot;&gt;RuntimeException&lt;/span&gt;(&quot;&lt;span class=&quot;code-snippet__selector-tag&quot;&gt;RPC&lt;/span&gt;调用异常&quot;);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span lang=&quot;EN-US&quot;&gt;2.5 &lt;/span&gt;&lt;/strong&gt;&lt;strong&gt;&lt;span&gt;测试&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;编写测试类或者在&lt;span lang=&quot;EN-US&quot;&gt;controller&lt;/span&gt;调用&lt;span lang=&quot;EN-US&quot;&gt;service&lt;/span&gt;进行测试，可以在控制台看到结果：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.26024096385542167&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/P13HW4Fm1HW79QW7PvMXd0lf8ticWZeibBWxoiawtMVM5tqokS7yVKEicqxSib5ibEYH3dzeEtFViaqpKOpQaZiaicAYibQQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;830&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;基本使用是不是很简单&lt;span lang=&quot;EN-US&quot;&gt;~ &lt;/span&gt;从这里可以看出最大重试次数为&lt;span lang=&quot;EN-US&quot;&gt;3&lt;/span&gt;次。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;三、&lt;span lang=&quot;EN-US&quot;&gt;Spring-Retry&lt;/span&gt;进阶使用&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;基本使用很简单，实际项目中需要思考的会更多，所以需要了解&lt;span lang=&quot;EN-US&quot;&gt;@Retryable&lt;/span&gt;可以配置的属性。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span lang=&quot;EN-US&quot;&gt;3.1 &lt;/span&gt;&lt;/strong&gt;&lt;strong&gt;&lt;span&gt;常用属性&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;看下常见的属性：&lt;/span&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;java&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__comment&quot;&gt; * multiplier（指定延迟倍数）默认为0，表示固定暂停1秒后进行重试，如果把multiplier设置为1.5，则第一次重试为2秒，第二次为3秒，第三次为4.5秒。&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__comment&quot;&gt; * &lt;span class=&quot;code-snippet__doctag&quot;&gt;@return&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__comment&quot;&gt; */&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__meta&quot;&gt;@Retryable&lt;/span&gt;(value = Exception.class,maxAttempts = &lt;span class=&quot;code-snippet__number&quot;&gt;3&lt;/span&gt;,backoff = &lt;span class=&quot;code-snippet__meta&quot;&gt;@Backoff&lt;/span&gt;(delay = &lt;span class=&quot;code-snippet__number&quot;&gt;2000&lt;/span&gt;,multiplier = &lt;span class=&quot;code-snippet__number&quot;&gt;1.5&lt;/span&gt;))&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;call&lt;/span&gt;&lt;span class=&quot;code-snippet__params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    System.out.println(&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;准备发起RPC调用...&quot;&lt;/span&gt;+&lt;span class=&quot;code-snippet__keyword&quot;&gt;new&lt;/span&gt; Date());&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;throw&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;new&lt;/span&gt; RuntimeException(&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;RPC调用异常&quot;&lt;/span&gt;);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;span lang=&quot;EN-US&quot;&gt;* value&lt;/span&gt;&lt;span&gt;：抛出指定异常才会重试&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span lang=&quot;EN-US&quot;&gt;* include&lt;/span&gt;&lt;span&gt;：和&lt;span lang=&quot;EN-US&quot;&gt;value&lt;/span&gt;一样，默认为空，当&lt;span lang=&quot;EN-US&quot;&gt;exclude&lt;/span&gt;也为空时，默认所有异常&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span lang=&quot;EN-US&quot;&gt;* exclude&lt;/span&gt;&lt;span&gt;：指定不处理的异常&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span lang=&quot;EN-US&quot;&gt;* maxAttempts&lt;/span&gt;&lt;span&gt;：最大重试次数，默认&lt;span lang=&quot;EN-US&quot;&gt;3&lt;/span&gt;次&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span lang=&quot;EN-US&quot;&gt;* backoff&lt;/span&gt;&lt;span&gt;：重试等待策略，&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span lang=&quot;EN-US&quot;&gt;* &lt;/span&gt;&lt;span&gt;默认使用&lt;span lang=&quot;EN-US&quot;&gt;@Backoff&lt;/span&gt;，&lt;span lang=&quot;EN-US&quot;&gt;@Backoff&lt;/span&gt;的&lt;span lang=&quot;EN-US&quot;&gt;value&lt;/span&gt;默认为&lt;span lang=&quot;EN-US&quot;&gt;1000L&lt;/span&gt;，我们设置为&lt;span lang=&quot;EN-US&quot;&gt;2000&lt;/span&gt;； 以毫秒为单位的延迟（默认&lt;span lang=&quot;EN-US&quot;&gt; 1000&lt;/span&gt;）&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span lang=&quot;EN-US&quot;&gt;* multiplier&lt;/span&gt;&lt;span&gt;（指定延迟倍数）默认为&lt;span lang=&quot;EN-US&quot;&gt;0&lt;/span&gt;，表示固定暂停&lt;span lang=&quot;EN-US&quot;&gt;1&lt;/span&gt;秒后进行重试，如果把&lt;span lang=&quot;EN-US&quot;&gt;multiplier&lt;/span&gt;设置为&lt;span lang=&quot;EN-US&quot;&gt;1.5&lt;/span&gt;，则第一次重试为&lt;span lang=&quot;EN-US&quot;&gt;2&lt;/span&gt;秒，第二次为&lt;span lang=&quot;EN-US&quot;&gt;3&lt;/span&gt;秒，第三次为&lt;span lang=&quot;EN-US&quot;&gt;4.5&lt;/span&gt;秒。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span lang=&quot;EN-US&quot;&gt;3.2 &lt;/span&gt;&lt;/strong&gt;&lt;strong&gt;&lt;span&gt;重试耗尽回调&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;当重试耗尽时，&lt;span lang=&quot;EN-US&quot;&gt;RetryOperations&lt;/span&gt;可以将控制传递给另一个回调，即&lt;span lang=&quot;EN-US&quot;&gt;RecoveryCallback&lt;/span&gt;。&lt;span lang=&quot;EN-US&quot;&gt;Spring-Retry&lt;/span&gt;还提供了&lt;span lang=&quot;EN-US&quot;&gt;@Recover&lt;/span&gt;注解，用于&lt;span lang=&quot;EN-US&quot;&gt;@Retryable&lt;/span&gt;重试失败后处理方法。如果不需要回调方法，可以直接不写回调方法，那么实现的效果是，重试次数完了后，如果还是没成功没符合业务判断，就抛出异常。&lt;/span&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;cs&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;@Retryable(&lt;span class=&quot;code-snippet__keyword&quot;&gt;value&lt;/span&gt; = Exception.class,maxAttempts = &lt;span class=&quot;code-snippet__number&quot;&gt;3&lt;/span&gt;,backoff = @Backoff(delay = &lt;span class=&quot;code-snippet__number&quot;&gt;2000&lt;/span&gt;,multiplier = &lt;span class=&quot;code-snippet__number&quot;&gt;1.5&lt;/span&gt;),recover = &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;recover&quot;&lt;/span&gt;)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;call&lt;/span&gt;(&lt;span class=&quot;code-snippet__params&quot;/&gt;)&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    System.&lt;span class=&quot;code-snippet__keyword&quot;&gt;out&lt;/span&gt;.println(&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;准备发起RPC调用...&quot;&lt;/span&gt;+&lt;span class=&quot;code-snippet__keyword&quot;&gt;new&lt;/span&gt; Date());&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;throw&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;new&lt;/span&gt; RuntimeException(&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;RPC调用异常&quot;&lt;/span&gt;);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;@&lt;span class=&quot;code-snippet__function&quot;&gt;Recover&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;recover&lt;/span&gt;(&lt;span class=&quot;code-snippet__params&quot;&gt;Exception e&lt;/span&gt;)&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    System.&lt;span class=&quot;code-snippet__keyword&quot;&gt;out&lt;/span&gt;.println(&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;recover--&amp;gt;记日志到数据库 或者调用其余的方法&quot;&lt;/span&gt;);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;当有多个的时候，可以通过属性&lt;span lang=&quot;EN-US&quot;&gt;recover&lt;/span&gt;来指定要回调的方法，执行结果如下：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.21445783132530122&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/P13HW4Fm1HW79QW7PvMXd0lf8ticWZeibBGz5W9kFMNtl77YHvYWCMTxfDlcYqFtiaeDqTA8DGeQeibwNWEc18Hic6w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;830&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;这里会发现如果定义了回调方法，那么就不会抛出“&lt;span lang=&quot;EN-US&quot;&gt;RPC&lt;/span&gt;调用异常”信息了。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span lang=&quot;EN-US&quot;&gt;3.3 RetryTemplate&lt;/span&gt;&lt;/strong&gt;&lt;strong&gt;&lt;span&gt;的使用&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span lang=&quot;EN-US&quot;&gt;Spring-Retry&lt;/span&gt;&lt;span&gt;也提供了编码的方式&lt;span lang=&quot;EN-US&quot;&gt;RetryTemplate&lt;/span&gt;，先注入这个类：&lt;/span&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;java&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__meta&quot;&gt;@Bean&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;public&lt;/span&gt; RetryTemplate &lt;span class=&quot;code-snippet__title&quot;&gt;retryTemplate&lt;/span&gt;&lt;span class=&quot;code-snippet__params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    RetryTemplate retryTemplate = &lt;span class=&quot;code-snippet__keyword&quot;&gt;new&lt;/span&gt; RetryTemplate();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    SimpleRetryPolicy retryPolicy = &lt;span class=&quot;code-snippet__keyword&quot;&gt;new&lt;/span&gt; SimpleRetryPolicy(); &lt;span class=&quot;code-snippet__comment&quot;&gt;//设置重试策略&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    retryPolicy.setMaxAttempts(&lt;span class=&quot;code-snippet__number&quot;&gt;3&lt;/span&gt;);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    retryTemplate.setRetryPolicy(retryPolicy);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    FixedBackOffPolicy fixedBackOffPolicy = &lt;span class=&quot;code-snippet__keyword&quot;&gt;new&lt;/span&gt; FixedBackOffPolicy(); &lt;span class=&quot;code-snippet__comment&quot;&gt;//设置退避策略&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    fixedBackOffPolicy.setBackOffPeriod(&lt;span class=&quot;code-snippet__number&quot;&gt;2000L&lt;/span&gt;);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    retryTemplate.setBackOffPolicy(fixedBackOffPolicy);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;return&lt;/span&gt; retryTemplate;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;然后进行使用：&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;typescript&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;code-snippet__built_in&quot;&gt;void&lt;/span&gt; call(){&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;try&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        retryTemplate.execute(&lt;span class=&quot;code-snippet__keyword&quot;&gt;new&lt;/span&gt; RetryCallback&amp;lt;&lt;span class=&quot;code-snippet__built_in&quot;&gt;Object&lt;/span&gt;, IllegalAccessException&amp;gt;() {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            &lt;span class=&quot;code-snippet__meta&quot;&gt;@Override&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            &lt;span class=&quot;code-snippet__keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;code-snippet__built_in&quot;&gt;Object&lt;/span&gt; doWithRetry(RetryContext context) throws IllegalAccessException {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                System.out.println(&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;准备发起RPC调用...&quot;&lt;/span&gt;+&lt;span class=&quot;code-snippet__keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;code-snippet__built_in&quot;&gt;Date&lt;/span&gt;());&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                &lt;span class=&quot;code-snippet__keyword&quot;&gt;throw&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;new&lt;/span&gt; RuntimeException(&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;RPC调用异常&quot;&lt;/span&gt;);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                &lt;span class=&quot;code-snippet__comment&quot;&gt;//return null;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        });&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    } &lt;span class=&quot;code-snippet__keyword&quot;&gt;catch&lt;/span&gt; (IllegalAccessException e) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__keyword&quot;&gt;throw&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;new&lt;/span&gt; RuntimeException(e);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;总结&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span lang=&quot;EN-US&quot;&gt;spring-retry&lt;/span&gt;&lt;span&gt;通过注解，在不入侵原有业务逻辑代码的方式下，优雅的实现重处理功能。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;如果重试多次失败之后，尽量进行回调处理，将这一次的失败信息进行记录，方便后续跟进和优化代码。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;mp-style-type data-value=&quot;3&quot;/&gt;&lt;/p&gt;&lt;/div&gt;

          
        &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>