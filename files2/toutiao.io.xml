<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>fef5b221976559534753e8c11c445566</guid>
<title>一台不容错过的 Java 单元测试代码 “永动机”</title>
<link>https://toutiao.io/k/fihjlfi</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;preview&quot;&gt;&lt;p&gt;作者：京东零售 陈志良&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;作为一名京东的软件匠人，我们开发的软件支撑着数亿的用户，责任是重大的，因此我们深深地敬畏每一行代码，那如何将我们的失误降到最低呢？那就是单元测试，它会让我们树立对代码的自信心。为此我们期望能打造一台生产Java单元测试代码的“永动机”，源源不断地为开发者生产代码，辅助大家高效地做好单元测试，节省精力能投入到更多的业务创新中去。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h1&gt;一、开发者对代码的自信心来自哪里？&lt;/h1&gt;

&lt;p&gt;京东随着业务高速发展，我们缔造的、承载着数亿用户的、功能强大的系统，在经过十多年的打磨，也变得日益复杂。作为JD软件开发者，我们是自豪的，但我们承担的责任也是重大的。我们每一次的创新，就像打造一座下图这样的过山车。我们在为客户带来如此顶级体验的同时，更重要的是保障每一次的旅行都可以安全地着陆。所以我们深深敬畏每一行代码，努力将我们的失误降到最低，为业务保驾护航。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://p3-sign.toutiaoimg.com/tos-cn-i-qvj2lq49k0/82024ed7ae0243749adf551bcb93e36a%7Enoop.image?_iz=58558&amp;amp;from=article.pc_detail&amp;amp;x-expires=1677548791&amp;amp;x-signature=EKYNeHepBkihtejA4%2F6ErugaKdA%3D&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;然而，业务的迭代速度之快，交付压力之大，作为“过山车”的缔造者，你是否有以下的经历？&lt;/p&gt;

&lt;p&gt;1）每一次上线也像坐了一次过山车呢？&lt;/p&gt;

&lt;p&gt;2）你亲手打造的“过山车”，自己是否亲身体验过呢？&lt;/p&gt;

&lt;p&gt;3）你是否曾对测试同学说，“你们先上去坐坐看，遇到了问题再下来找我”？&lt;/p&gt;

&lt;p&gt;如果你的答案是：每一次上线也像坐了一次过山车，我们自己打造的“过山车”自己不敢坐，我们的代码要靠测试同学兜底，那么就说明我们对自己的代码是缺乏信心的，我们的工作还有待提升的空间；反之则说明，作为一个开发者你已经相当优秀了。&lt;/p&gt;

&lt;p&gt;那么如何让我们开发者建立对自己代码的信心呢，一般来说有两种方式：&lt;/p&gt;

&lt;p&gt;1）对“过山车”的每个零件都进行充分的测试，保证每一部分在各种场景下都可以正常工作，对所有的异常也能够处理得当，这即是单元测试。&lt;/p&gt;

&lt;p&gt;2）对“过山车”启动前做好充分“检查”，这即是代码评审，我们邀请其他大佬帮我们把关，及时发现问题。&lt;/p&gt;

&lt;p&gt;这两部分工作在开发阶段都是必要的工作，二者缺一不可。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;代码评审是借助了外力，单元测试则是内功，靠自己，靠开发者自测来增强对代码的信心&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;本文主要和大家一起探讨单元测试，如何把这单元测试的内功练好。&lt;/p&gt;

&lt;h1&gt;二、做好单测，慢即是快&lt;/h1&gt;

&lt;p&gt;对于单元测试的看法，业界同仁理解多有不同，尤其是在业务变化快速的互联网行业，通常的问题主要有，必须要做吗？做到多少合适？现在没做不也挺好的吗？甚至一些大佬们也是存在不同的看法。我们如下先看一组数字：&lt;/p&gt;

&lt;p&gt;“在 STICKYMINDS 网站上的一篇名为 《 The Shift-Left Approach to Software Testing 》 的文章中提到，假如在编码阶段发现的缺陷只需要 1 分钟就能解决，那么单元测试阶段需要 4 分钟，功能测试阶段需要 10 分钟，系统测试阶段需要 40 分钟，而到了发布之后可能就需要 640 分钟来修复。”——来自知乎网站节选&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://p3-sign.toutiaoimg.com/tos-cn-i-qvj2lq49k0/7148c9f8b5224aa8ac344f36edfb5f0f%7Enoop.image?_iz=58558&amp;amp;from=article.pc_detail&amp;amp;x-expires=1677548791&amp;amp;x-signature=MALYy2a9NWqGeznLom9FgHgvbnw%3D&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;对于这些数字的准确性我们暂且持保留意见。大家可以想想我们实际中遇到的线上问题大概需要消耗多少工时，除了要快速找到bug，修复bug上线，还要修复因为bug引发的数据问题，最后还要复盘，看后续如何能避免线上问题，这样下来保守估计应该不止几人日吧。所以这篇文章作者所做的调研数据可信度还是很高的，&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;缺陷发现越到交付流程的后端，其修复成本就越高&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;有人说写单测太耗费时间了，会延长交付时间，其实不然：&lt;/p&gt;

&lt;p&gt;1）研测同学大量的往返交互比编写单测的时间要长的多，集成测试的时间被拖长。&lt;/p&gt;

&lt;p&gt;2）没经过单测的代码bug会多，开发同学忙于修复各种bug，对代码debug跟踪调试找问题，也要消耗很多精力。&lt;/p&gt;

&lt;p&gt;3）后期的线上问题也会需要大量的精力去弥补。&lt;/p&gt;

&lt;p&gt;如果有了单元测试的代码，且能实现一个较高的行覆盖率，则可以将问题尽可能消灭在开发阶段。同时有了单测代码的积累，每次代码改动后可以提前发现这次改动引发的其他关联问题，上线也更加放心。单测虽然使提测变慢了一些，软件质量更加有保障，从而节省了后续同学的精力，从整体看其实效率更高。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;所以做好单测，慢即是快。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;我们集团技术委员会大佬们从去年开始也在倡议大家做单元测试，&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;做为一名开发者我们需要对自己的代码质量负责，&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;也更能体现我们大厂开发者的工匠精神。&lt;/strong&gt;&lt;/p&gt;

&lt;h1&gt;三、如何编写单元测试&lt;/h1&gt;

&lt;h1&gt;1、单元测试的主流框架及核心思想&lt;/h1&gt;

&lt;p&gt;以下我们先通过一个案例介绍下主流框架的思想。下图为一个简单的函数执行逻辑，在函数体内直接调用了函数1、函数2、函数3，间接调用了函数2.1，其中1和2分别是普通函数，2.1和3涉及到外部系统调用，例如JSF、Redis、MySQL等操作，最后返回结果。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://p3-sign.toutiaoimg.com/tos-cn-i-qvj2lq49k0/d3439794db2e4b3b9992d5062032a32a%7Enoop.image?_iz=58558&amp;amp;from=article.pc_detail&amp;amp;x-expires=1677548791&amp;amp;x-signature=pXb1c6C8v65Lf047kQgQv5VQeXI%3D&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;代码大致如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public class MyObject {
    @Autowired
    private RedisHelper redisHelper;


    public MyResult myFunction(InputParam inputParam){


        MyResult myResult = new MyResult();


//普通代码块


        if(inputParam.isFlag()) {
            //如果标记flag为true，则执行函数1
            String f1 = invokeFunction1();
            //调用函数3，函数3封装了redis中间件操作
            String f3 = redisHelper.get(f1);


            myResult.setResult(f3);


        } else {
            //调用函数2，在函数2内部又调用远程服务接口2.1
            String f2 = invokeFunction2();
            myResult.setResult(f2);
        }


        return myResult;
    }  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在当下微服务时代，系统间的交互变得更加日益复杂，以上图例只是简化的例子，实际系统中的上下游外部依赖多达十几个，甚至几十个。&lt;/p&gt;

&lt;p&gt;在这种情况下，如果过度依赖外部服务就很难保障每次用例执行成功，会影响到单元测试的执行效果。&lt;/p&gt;

&lt;p&gt;所以，当前主流的单元测试框架大都采用了mock技术，来屏蔽对外部服务的依赖，例如：mockito、powermock、Spock等。&lt;/p&gt;

&lt;p&gt;图例中2.1和3即是对外部系统的调用，单元测试代码中需要将其API进行mock，在用例运行时运用mock技术模拟外部API接口的返回值，具体写法此处不作举例。&lt;/p&gt;

&lt;p&gt;要注意的是，使用Mock技术的框架需要注意两个前提：&lt;/p&gt;

&lt;p&gt;1）接口契约是相对稳定的（例如redis的api暂时不会发生变化），否则就需要调整测试用例代码以适应最新的接口契约，如果不调整则此单元测试用例代码是无效的。&lt;/p&gt;

&lt;p&gt;2）接口调用是幂等的，同样的入参需要返回相同的结果，否则用例中的断言会失败或者需要对断言进行特殊的处理，例如比较时忽略某些变化的内容（如id、时间等）。&lt;/p&gt;

&lt;h1&gt;2、第1种单元测试用例的编写方案&lt;/h1&gt;

&lt;p&gt;接下来写一段基于mockito框架的测试代码，下图中的做法是，开发者编写了一个用例，对外部函数2.1和3进行了mock，然后在测试用例中调用待测函数，再对返回值进行断言。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://p3-sign.toutiaoimg.com/tos-cn-i-qvj2lq49k0/2650cfa7230f402aa9230db28da5fe73%7Enoop.image?_iz=58558&amp;amp;from=article.pc_detail&amp;amp;x-expires=1677548791&amp;amp;x-signature=tf6Tkd0%2BFsn%2BtnpzjKhGpjjWYeg%3D&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;示意代码如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    //创建函数2.1的mock对象
    @MockBean
    private JSFService myJSFService;


    //创建函数3的mock对象
    @MockBean
    private RedisHelper redisHelper;


    @Autowired
    MyObject myObject;


    @Test
    public void testMyFunction(InputParameter parameter)  {


        //根据入参mock返回数据
        when(myJSFService.invoke(parameter.getX())).thenReturn(X);
        when(redisHelper.get(parameter.getY())).thenReturn(Y);


        //期望结果
        MyResult expect = new Result(XXX);


        //实际调用被测试函数，返回结果
        MyResult actual = vmyObject.myFunction(parameter);


        //断言
        Assert.assertEquals(actual.toString(), expect.toString());
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;运行该用例后，除了待测函数，连带函数1、2一起都被测试到了，在实际中调用链路会更加复杂，那么这种写法如何呢？我们做个简要的分析：&lt;/p&gt;

&lt;p&gt;1）优点：用例的编码量较少，实现速度快，一个用例覆盖了3个函数，整个业务执行路径也都被测试到了，另外单测覆盖率的指标不受影响，只要执行过的代码都会被统计到。&lt;/p&gt;

&lt;p&gt;2）缺点：如果用例失败，那么去定位问题会较慢，实际项目中链路会更加复杂，因此排查问题的时间会大幅度增加，假设问题发生在函数1或2中，那么就需要通过debug跟踪逐步排查。&lt;/p&gt;

&lt;p&gt;那么这样的做法究竟如何？到这里如果测试的同学看到肯定会有疑问，这样做的用例跟集成测试阶段的自动化用例有啥区别？是的，从效果上看是一样的，只不过将运行转移到了开发阶段。对于排查和定位问题仍然比较困难，所以从真正的效果出发，不建议只是这样做，请往下看。&lt;/p&gt;

&lt;h1&gt;3、第2种单元测试用例的编写方案&lt;/h1&gt;

&lt;p&gt;第2种方案是对每一个方法都写用例代码，每个方法是独立的功能单元，隔离该被测方法的全部依赖，将外部依赖的调用都做好mock。大致的做法类似下图：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://p3-sign.toutiaoimg.com/tos-cn-i-qvj2lq49k0/196c96c2b31f4f7380e6dfe125506248%7Enoop.image?_iz=58558&amp;amp;from=article.pc_detail&amp;amp;x-expires=1677548791&amp;amp;x-signature=S2bkgIWGGCxHPQ1S%2FTSbsEx6dZ0%3D&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;待测函数的测试用例中会涉及到3个mock，分别是函数1、2、3；函数1、函数2也都有自己的测试用例，这样做出来的单元测试效果会更好。在Java中方法是一个最小存在的可测试单元，所以对每个方法进行独立的充分测试，那么组装后就可以充分保障代码的整体质量，同时也能快速的定位问题，实现快速交付。&lt;/p&gt;

&lt;p&gt;目前，业界开发者大多采用第一种偏集成测试的写法，因其工作量相对较小，在交付压力较大的时候，甚至会放弃单元测试,这种情况在互联网行业尤为普遍。在单元测试不足的情况下，则需要靠增强测试人员的人力来缓解质量问题，但当前业务增长压力渐渐显现，各大公司都聚焦于内部提效，人力成本控制更加严格。打铁还需自身硬，当下我们每一位开发者都需要加强自身的内功修炼。&lt;/p&gt;

&lt;p&gt;综合以上两种方案，小结如下：&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;1）为每个方法写单元测试的测试用例，本方法外部调用均为mock。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;2）编写一小部分集成测试用例，对整体功能进行部分验证，集成测试主要工作还是交给测试同学。&lt;/strong&gt;&lt;/p&gt;

&lt;h1&gt;四、单元测试应遵循的一些原则&lt;/h1&gt;

&lt;p&gt;目前行业比较流行的有FIRST原则，整理如下&lt;/p&gt;

&lt;h1&gt;1）Fast，快速&lt;/h1&gt;

&lt;p&gt;单元测试用例是执行一个特定任务的一小段代码。与集成测试不同的是，单元测试很小很轻，尽量做到没有网络通信，不执行数据库操作，不启动web容器等耗时操作，使它们能快速执行。开发者在实现应用程序功能时，或者调试bug时，需要频繁去运行单元测试验证结果是否正确。如果单元测试足够快速，就可以省去不必要浪费的时间，提高工作效率。&lt;/p&gt;

&lt;h1&gt;2）Independent/Isolated，独立/隔离&lt;/h1&gt;

&lt;p&gt;单元测试的用例需要是相互独立的。一个单元测试不要依赖其它单元测试所产生的结果，因为在大多数情况下，单元测试是以随机的顺序运行的。另外，用例代码也不应该依赖和修改外部数据或服务等共享资源，做到测试前后共享资源数据一致，可以用mock或stub的方式对依赖项进行模拟，屏蔽这些依赖项的不确定性，确保单元测试结果的准确性。&lt;/p&gt;

&lt;h1&gt;3）Repeatable，可重复&lt;/h1&gt;

&lt;p&gt;单元测试需要保持运行稳定，在不同的计算机、不同的时间点多次运行，都应该产生相同的结果，如果间歇性的失败，会导致我们不断的去查看这个测试，不可靠的测试也就失去了意义。&lt;/p&gt;

&lt;h1&gt;4）Self-Validating，自我验证&lt;/h1&gt;

&lt;p&gt;单元测试需要采用Assert相关断言函数等进行自我验证，即当单元测试执行完毕之后就可得知测试结果，全程无需人工介入，不应该在测试完成后做任何额外的人工检查。注意在单元测试中不要添加任何打印日志的语句，避免通过打印出日志才能判断单元测试是否通过。&lt;/p&gt;

&lt;h1&gt;5）Thorough/Timely，彻底/及时&lt;/h1&gt;

&lt;p&gt;在测试一个功能时，我们除了考虑主要逻辑路径以外，还要关注边界或异常场景。因此在多数时候，我们除了要创建一个具有有效入参的单元测试，还需要准备其他使用了无效入参的单元测试。例如被测方法入参有一个范围，从MIN到MAX，那么应该创建额外的单元测试来测试输入为MIN和MAX时是否能正确处理。另外就是及时性，等代码稳定运行再来补齐单元测试可能是低效的，最有效的方式是在写好功能函数接口后（实现函数功能前）进行单元测试。&lt;/p&gt;

&lt;h1&gt;五、单元测试的现状及痛点&lt;/h1&gt;

&lt;h1&gt;1、我们通过对行业现状进行调研后，有以下发现：&lt;/h1&gt;

&lt;p&gt;1）从行业特点看：传统行业软件（ERP、CRM等）单测覆盖率至少达到80%以上，互联网行业软件较低，一般低于50%，大部分没有。&lt;/p&gt;

&lt;p&gt;2）从软件特点看：用户量较大的软件（工具类、中间件等）基础软件覆盖率相对较高，至少80%以上，需求变化快的业务类软件相对较低。&lt;/p&gt;

&lt;p&gt;3）从开发习惯看：国外开发的软件较高，更加重视软件的质量，大多数开源软件覆盖率至少都在60%以上。国内开发者多数未养成习惯。&lt;/p&gt;

&lt;h1&gt;2、单元测试这么重要的事情，为什么在企业中实际中却很难做好呢，主要有以下几个痛点：&lt;/h1&gt;

&lt;p&gt;1）开发者需要投入更多的工作量：一个应用系统的单元测试代码行数与应用功能代码行数比至少为1:1，复杂应用则更高。通常来说每提升1%的单测行覆盖率，则需要编写业务代码1%的测试代码，所以开发者需要付出更多工作量。随着单元测试覆盖率的提升，每提升1%，都需要编写大量的用例，因为后续的用例至少有80%，甚至是90%以上的代码运行路径是重叠的，最坏的情况是增加了一个用例，只多了一行的覆盖。&lt;/p&gt;

&lt;p&gt;2）存量代码数量庞大：我们目前关注的指标还只是核心系统的覆盖率，全量代码覆盖率提升更加困难，经年积累的应用中保持代码活跃的数量依然很庞大，要做现有代码的单元测试编码需要消耗大量人力。&lt;/p&gt;

&lt;p&gt;3）单元测试代码容易失效：单元测试的代码需要持续维护，新业务需求引发的代码变更会导致原有的单测代码失效，在业务高速迭代的情况下，没有额外精力投入，要么忽略，要么删除，在这种情况下，很难持续维持一个较高的覆盖率指标。&lt;/p&gt;

&lt;p&gt;归根结底，单元测试最大的困难就是成本问题，做好单元测试，我们的开发者需要持续投入大量的精力，而在业务需求高速迭代的情况下，我们该如何破局？答案就是：&lt;strong&gt;自动化技术&lt;/strong&gt;&lt;/p&gt;

&lt;h1&gt;六、单元测试自动化调研&lt;/h1&gt;

&lt;p&gt;其实，单测自动化技术的发展至少已有15年以上的历史，目前主流的技术是静态代码分析技术，它是指无需运行被测代码，仅通过分析或检查源程序的语法、结构、过程、接口等来检查程序的正确性，找出代码隐藏的错误和缺陷。主要的代表产品有：&lt;strong&gt;EvoSuite、Squaretest等。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://p3-sign.toutiaoimg.com/tos-cn-i-qvj2lq49k0/cf6e229319104021a649cb55786d0e1a%7Enoop.image?_iz=58558&amp;amp;from=article.pc_detail&amp;amp;x-expires=1677548791&amp;amp;x-signature=TQCvs7OcYFjkJz6PCydUNNyfuWo%3D&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;上图是EvoSuite工具根据现有被测代码自动生成的测试代码，目前这类产品生成的单测代码的行覆盖率一般可以达到&lt;strong&gt;30%&lt;/strong&gt;左右，代码越复杂效果越差，它们可以作为简单业务场景的单测代码生成方案。&lt;/p&gt;

&lt;p&gt;主要的优点有：纯客户端工具，安装即可使用，不需复杂配置。支持多种开发平台：支持idea、eclipse、命令行等多种工具。&lt;/p&gt;

&lt;p&gt;主要的不足：生成代码质量不高、单测覆盖率较低：受限于代码分析技术和现实技术框架的复杂多样，生成的代码质量不高，单测覆盖率较低，只能适用于简单业务场景，且生成的代码需要人工判断有效性。例如订单sendpay这样的标记包含了丰富的业务语义，则很难通过静态分析生成有效的用例代码。&lt;/p&gt;

&lt;h1&gt;七、我们的一些想法与技术突破&lt;/h1&gt;

&lt;h1&gt;1、将录制的数据转化为单元测试用例&lt;/h1&gt;

&lt;p&gt;基于静态代码分析局限性，我们需要寻找一个新的方向，那么如何能够获得更加丰富的业务数据呢，而不是通过一些策略生产数据，前年咱们零售交易研发创新了月光宝盒，完全可以将数据录制下来，于是我们就想到是否可以利用宝盒录制到的数据，反向生成测试用例呢，以此来实现快速生产单元测试的用例代码。大致的方案思路如下：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://p3-sign.toutiaoimg.com/tos-cn-i-qvj2lq49k0/863761d6345c4c9ebb2df47262b878b0%7Enoop.image?_iz=58558&amp;amp;from=article.pc_detail&amp;amp;x-expires=1677548791&amp;amp;x-signature=g4Y03RUOwtFZTV4w2Bm%2F5G7gSiY%3D&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h1&gt;2、标杆验证的效果给了我们信心&lt;/h1&gt;

&lt;p&gt;乍一听这个想法有点疯狂，我们针对这个想法做了效果验证，虽然还没有达到奇效，但整体思路得到了检验，事实证明，这个方案虽然很难，但是是可行的，以下为Y侧做的标杆案例的尝试。通过4个标杆的试运行情况分析，接入一周内，生成代码2.3万行，单测行覆盖率提升幅度均在30%以上。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://p3-sign.toutiaoimg.com/tos-cn-i-qvj2lq49k0/d8cedc823a3e424896cc184ab57356ae%7Enoop.image?_iz=58558&amp;amp;from=article.pc_detail&amp;amp;x-expires=1677548791&amp;amp;x-signature=vhJZ9SaXtnsWAK4des7qxdMfOlk%3D&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h1&gt;3、然而，该方案还并不完美，我们还有些建议&lt;/h1&gt;

&lt;p&gt;如果你仔细看过前面提到的单元测试原则，针对该方案一定会有疑问，没错，它违反了及时性原则，我们应该在写代码时或者提测前完成啊，测试阶段再录制生成已经晚了。的确，该方案不是完美的，为此我们给出的建议是：&lt;/p&gt;

&lt;p&gt;1）针对存量代码，由于目前我们的存量代码数量较大，该方案将会产生较大的效果，开发者只要将录制工具集成到被测应用即可，接入成功后，如果测试同学能帮忙跑一次全量回归测试最佳，则可以快速生成大量的用例代码，如果测试同学时间不充足，则借助测试同学的日常测试逐渐积累数据，经过一两周后也能获得大量用例代码。&lt;/p&gt;

&lt;p&gt;2）对于新开发代码，在开发者完成编码后的自测阶段，由开发者自己本地运行程序进行自测、录制，也能帮助我们生成一大批用例，然后可以基于生成的用例，再通过复制、手工调整进行快速扩充用例，从而保证单元测测的及时性。&lt;/p&gt;

&lt;p&gt;3）特殊业务场景处理，对于边界或异常用例很难录制到，则可以通过手工复制用例，再修改用例数据，来扩充用例，这种方式比纯手工编写还是快很多，尤其是mock对象非常复杂的时候，用该方案可以在1分钟内即可基于已有用例扩展一个新用例。&lt;/p&gt;

&lt;h1&gt;4、生成的单元测试用例是什么样子&lt;/h1&gt;

&lt;p&gt;下面举一个生成单元测试用例代码的实际例子，该例子基于Mockito框架，每一个用例方法对应一个JSON文件，JSON文件中存储着用例运行时需要的出入参、全部外部调用的数据，用例代码和数据全部由工具自动生成，生成的大部分代码都是在帮助开发者将录制的数据组装Mock对象，这部分工作量在实际开发中是最大的，因此可以大幅度减小开发者自己纯手工编码工作。当需要手工扩充用例时，只需要将用例方法和数据文件复制一份，再对用例数据做出调整即可制作出新的用例。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://p3-sign.toutiaoimg.com/tos-cn-i-qvj2lq49k0/0b2c43a894b64224a76525949cce9bd2%7Enoop.image?_iz=58558&amp;amp;from=article.pc_detail&amp;amp;x-expires=1677548791&amp;amp;x-signature=NrjU%2Bxv7cCrQ9iRNgm5cmvQiCGY%3D&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;数据文件样例：&lt;br/&gt;
/artt/StockStatusReOccupySplitServiceImpl1#HpCm.json&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://p3-sign.toutiaoimg.com/tos-cn-i-qvj2lq49k0/27e185524ad54327b33eee13b7fb408d%7Enoop.image?_iz=58558&amp;amp;from=article.pc_detail&amp;amp;x-expires=1677548791&amp;amp;x-signature=cl0X4s%2FkaN2zzGYI5YY9hrST2sU%3D&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h1&gt;5、我们所遇到的技术挑战&lt;/h1&gt;

&lt;p&gt;我们遇到了很多技术难点，由于基于宝盒录制的数据在还原代码时信息还不足，需要增加更多的录制信息与特殊应用场景处理，主要难点有：&lt;/p&gt;

&lt;p&gt;1）结构化数据的录制与还原，复杂泛型的还原、复杂对象的序列化和反序列化&lt;/p&gt;

&lt;p&gt;2）基于动态代理技术实现代码的特殊处理，如mybatis、JSF&lt;/p&gt;

&lt;p&gt;3）用例的采样控制，重复用例的识别与剔除，&lt;/p&gt;

&lt;p&gt;4）用例结果断言的多样性，需要丰富的比对策略&lt;/p&gt;

&lt;p&gt;期间涉及到了大量的底层技术研究，截至目前我们仍然有很多技术点需要攻克。例如，我们正在做的应用接入提升，将Spring AOP的方式用agent+ASM方式进行替换，实现代码增强在不重启服务的情况下动态挂载、卸载，也进一步降低接入成本，减少对应用的入侵。&lt;/p&gt;

&lt;h1&gt;八、单测自动化平台的架构&lt;/h1&gt;

&lt;p&gt;&lt;img src=&quot;https://p3-sign.toutiaoimg.com/tos-cn-i-qvj2lq49k0/81461e6c3fd74360b53be28630de56e5%7Enoop.image?_iz=58558&amp;amp;from=article.pc_detail&amp;amp;x-expires=1677548791&amp;amp;x-signature=pUnCucy%2FCHFNtS3EBE%2BYt3QlUgk%3D&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;整体分为三部分：&lt;/p&gt;

&lt;p&gt;1）录制端，采用月光宝盒为基座，基于Spring AOP和ASM字节码增强agent技术，开发者在应用内部进行集成，同时在应用启动中增加agent代理脚本设置。&lt;/p&gt;

&lt;p&gt;2）平台端，采集到的数据将被发往平台端，平台端主要负责应用注册、录制用例的统一管理等，并为生成端提供用例抽取服务。&lt;/p&gt;

&lt;p&gt;3）生成端，以idea插件、命令行脚本的形式，为用户的应用生成代码，并且按照每个用例覆盖业务代码的行号进行去重。最终生成的代码提交到代码库，bamboo集成获取代码进行单测运行与指标的采集。&lt;/p&gt;

&lt;h1&gt;九、单测平台的共建与接入&lt;/h1&gt;

&lt;p&gt;单元测试自动化技术是当今软件领域的一个难题，行业的开发者也都在积极寻求突破&lt;/p&gt;

&lt;p&gt;我们愿意做一只啄木鸟&lt;/p&gt;

&lt;p&gt;帮助开发者找到代码里的虫子&lt;/p&gt;

&lt;p&gt;通过自动化技术建立单测的信心&lt;/p&gt;

&lt;p&gt;但啄木鸟还做不到全面自动化&lt;/p&gt;

&lt;p&gt;大家不要因为它的存在而变得懈怠&lt;/p&gt;

&lt;p&gt;每位开发者仍然要发扬：&lt;/p&gt;

&lt;p&gt;工匠精神，以人为本，工具为辅&lt;/p&gt;

&lt;p&gt;在提测前轻松做好单元测试&lt;/p&gt;
&lt;/div&gt;
  &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>c145026b6c7a13dddd0117695e0dd1d7</guid>
<title>分布式事务解决方案</title>
<link>https://toutiao.io/k/q1wtxyi</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content js_underline_content             autoTypeSetting24psection&amp;#10;            &quot; id=&quot;js_content&quot;&gt;&lt;blockquote&gt;&lt;p&gt;数据不会无缘无故丢失，也不会莫名其妙增加&lt;/p&gt;&lt;/blockquote&gt;&lt;h1&gt;&lt;span&gt;一、概述&lt;/span&gt;&lt;/h1&gt;&lt;p&gt;1、曾几何时，知了在一家小公司做项目的时候，都是一个服务打天下，所以涉及到数据一致性的问题，都是直接用本地事务处理。&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.7170111287758346&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/uUIibyNXbAvAcuySlyD998aESorKvpoReiaehwAWfbks2A2F5jp5JEWtEOsTbYT7JYnY9ZUNgRdy2toFObYoWwqw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1258&quot;/&gt;&lt;/p&gt;&lt;p&gt;2、随着时间的推移，用户量增大了，发现一个Java服务扛不住了，于是技术大佬决定对于系统进行升级。根据系统的业务对于单体的一个服务进行拆分，然后对于开发人员也进行划分，一个开发人员只开发和维护一个或几个服务中的问题，大家各司其职，分工合作。&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.7047244094488189&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/uUIibyNXbAvAcuySlyD998aESorKvpoRenfibdibabiczic4gbJgXmxjeOI8ftQR6p5hPwAhRxqCJ72CSibT5EoMsvicg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1524&quot;/&gt;&lt;/p&gt;&lt;p&gt;3、当然服务拆分不是一蹴而就的，这是一个耗时耗力的庞大工程，大多数系统都是进行多轮拆分，而后慢慢形成一个稳定的系统。&lt;/p&gt;&lt;p&gt;遵守一个核心思想：&lt;strong&gt;先按总体业务进行一轮拆分，后面再根据拆分后的服务模块，进行一个细致的拆分。&lt;/strong&gt;&lt;/p&gt;&lt;p&gt; 4、随着服务拆分之后，用户量是抗住了，但是发现数据都在不同的服务中存取，这就引出了一个新的问题：&lt;strong&gt;跨服务器，如何保证数据的一致性？&lt;/strong&gt;当然，跨服务的分布式系统中不仅仅这个问题，还有其他的一些列问题，如：服务可用性、服务容错性、服务间调用的网络问题等等，这里只讨论数据一致性问题。&lt;/p&gt;&lt;p&gt;5、说到数据一致性，大致分为三种：强一致性、弱一致性、最终一致性。&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;强一致性&lt;/strong&gt;：数据一旦写入，在任一时刻都能读取到最新的值。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;弱一致性&lt;/strong&gt;：当写入一个数据的时候，其他地方去读这些数据，可能查到的数据不是最新的&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;最终一致性&lt;/strong&gt;：它是弱一致性的一个变种，不追求系统任意时刻数据要达到一致，但是在一定时间后，数据最终要达到一致。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;从这三种一致型的模型上来说，我们可以看到，弱一致性和最终一致性一般来说是异步冗余的，而强一致性是同步冗余的，异步处理带来了更好的性能，但也需要处理数据的补偿。同步意味着简单，但也必然会降低系统的性能。&lt;/p&gt;&lt;h1&gt;&lt;span&gt;二、理论&lt;/span&gt;&lt;span/&gt;&lt;/h1&gt;&lt;p&gt;上述说的数据一致性问题，其实也就是在说分布式事务的问题，现在有一些解决方案，相信大家多多少少都看到过，这里带大家回顾下。&lt;/p&gt;&lt;h2&gt;&lt;span&gt;2.1、二阶段提交&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p&gt;2PC是一种强一致性设计方案，通过引入一个&lt;strong&gt;事务协调器&lt;/strong&gt;来协调各个本地事务（也称为事务参与者）的提交和回滚。2PC主要分为2个阶段：&lt;/p&gt;&lt;p&gt; &lt;strong&gt;1、第一阶段&lt;/strong&gt;：事务协调器会向每个事务参与者发起一个开启事务的命令，每个事务参与者执行准备操作，然后再向事务协调器回复是否准备完成。但是&lt;strong&gt;不会提交本地事务，&lt;/strong&gt;但是这个阶段资源是需要被锁住的。 &lt;/p&gt;&lt;p&gt;&lt;strong&gt;2、第二阶段：&lt;/strong&gt;事务协调器收到每个事务参与者的回复后，统计每个参与者的回复，如果每个参与者都回复“可以提交”，那么事务协调器会发送提交命令，参与者正式提交本地事务，释放所有资源，结束全局事务。但是有一个参与者回复“拒绝提交”，那么事务协调器发送回滚命令，所有参与者都回滚本地事务，待全部回滚完成，释放资源，取消全局事务。事务提交流程&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5937873357228196&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/uUIibyNXbAvAcuySlyD998aESorKvpoReWtvuXialQepKajwXibic8VLlgOt6saic3z9vwt3nJXIkv6FDQNicyhNsWTA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1674&quot;/&gt;&lt;/p&gt;&lt;p&gt;事务回滚流程&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5937873357228196&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/uUIibyNXbAvAcuySlyD998aESorKvpoRefQFJGzBbE4ku2cyBXlYX2IQYRYw8fibFGA2awgzfxKDsu6MYicLCZib3g/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1674&quot;/&gt;&lt;/p&gt;&lt;p&gt;当然2PC存在的问题这里也提一下，一个是&lt;strong&gt;同步阻塞&lt;/strong&gt;，这个会消耗性能。另一个是&lt;strong&gt;协调器故障&lt;/strong&gt;问题，一旦协调器发生故障，那么所有的参与者处理资源锁定状态，那么所有参与者都会被阻塞。&lt;/p&gt;&lt;h2&gt;&lt;span&gt;2.2、三阶段提交&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p&gt;3PC主要是在2PC的基础上做了改进，主要为了解决2PC的阻塞问题。它主要是将2PC的第一阶段分为2个步骤，先准备，再锁定资源，并且引入了超时机制（这也意味着会造成数据不一致）。&lt;/p&gt;&lt;p&gt;3PC的三个阶段包括：&lt;code&gt;CanCommit&lt;/code&gt;、&lt;code&gt;PreCommit &lt;/code&gt;和 &lt;code&gt;DoCommit&lt;/code&gt; 具体细节就不展开赘述了，就一个核心观点：&lt;strong&gt;在CanCommit的时候并不锁定资源，除非所有参与者都同意了，才开始锁资源&lt;/strong&gt;。&lt;/p&gt;&lt;h2&gt;&lt;span&gt;2.3、TCC柔性事务&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p&gt;相比较前面的2PC和3PC，TCC和那哥俩的本质区别就是它是业务层面的分布式事务，而2PC和3PC是数据库层面的。&lt;/p&gt;&lt;p&gt;TCC是三个单词的缩写：&lt;code&gt;Try&lt;/code&gt;、&lt;code&gt;Confirm&lt;/code&gt;、&lt;code&gt;Cancel&lt;/code&gt;，也分为这三个流程。 &lt;/p&gt;&lt;p&gt;Try：尝试，即尝试预留资源，锁定资源 &lt;/p&gt;&lt;p&gt;Confirm：确认，即执行预留的资源，如果执行失败会重试 &lt;/p&gt;&lt;p&gt;Cancel：取消，撤销预留的资源，如果执行失败会重试&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.4937694704049844&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/uUIibyNXbAvAcuySlyD998aESorKvpoReiaOPoebP68Fq683cKFhzRvzicQNUomAfNHu4YumbOSOPZzzGZUsaia6Yw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1926&quot;/&gt;&lt;/p&gt;&lt;p&gt;从上图可知，TCC对于业务的侵入是很大的，而且紧紧的耦合在一起。TCC相比较2PC和3PC，试用范围更广，可实现跨库，跨不同系统去实现分布式事务。缺点是要在业务代码中去开发大量的逻辑实现这三个步骤，需要和代码耦合在一起，提高开发成本。 &lt;/p&gt;&lt;p&gt;&lt;strong&gt;事务日志&lt;/strong&gt;：在TCC模式中，事务发起者和事务参与者都会去记录事务日志（事务状态、信息等）。这个事务日志是整个分布式事务出现意外情况（宕机、重启、网络中断等），实现提交和回滚的关键。 &lt;/p&gt;&lt;p&gt;&lt;strong&gt;幂等性&lt;/strong&gt;：在TCC第二阶段，confirm或者cancel的时候，这两个操作都需要保证幂等性。一旦由于网络等原因导致执行失败，就会发起不断重试。 &lt;/p&gt;&lt;p&gt;&lt;strong&gt;防悬挂&lt;/strong&gt;：由于网络的不可靠性，有异常情况的时候，try请求可能比cancel请求更晚到达。cancel可能会执行空回滚，但是try请求被执行的时候也不会预留资源。&lt;/p&gt;&lt;h2&gt;&lt;span&gt;2.4、Seata&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p&gt;关于seata这里就不多提了，用的最多的是AT模式，上回知了逐步分析过，配置完后只需要在事务发起的方法上添加&lt;code&gt;@GlobalTransactional&lt;/code&gt;注解就可以开启全局事务，对于业务无侵入，低耦合。感兴趣的话请参考之前讨论Seata的内容。&lt;/p&gt;&lt;h1&gt;&lt;span&gt;三、应用场景&lt;/span&gt;&lt;span/&gt;&lt;/h1&gt;&lt;p&gt;知了之前在一家公司遇到过这样的业务场景；用户通过页面投保，提交一笔订单过来，这个订单通过上游服务，处理保单相关的业务逻辑，最后流入下游服务，处理业绩、人员晋升、分润处理等等业务。对于这个场景，两边处理的业务逻辑不在同一个服务中，接入的是不同的数据库。涉及到数据一致性问题，需要用到分布式事务。&lt;/p&gt;&lt;p&gt;对于上面介绍的几种方案，只是讨论了理论和思路，下面我来总结下这个业务场景中运用的一种实现方案。采用了本地消息表+MQ异步消息的方案实现了事务最终一致性，也符合当时的业务场景，相对强一致性，实现的性能较高。下面是该方案的思路图&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.525&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/uUIibyNXbAvAcuySlyD998aESorKvpoReUx9AxAYZiciaqgGvDFvNl0IwnOxEqkwEWhl2f9wfefKJcDTG2gnSeBPg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2160&quot;/&gt;&lt;/p&gt;&lt;ol class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;真实业务处理的状态可能会有多种，因此需要明确哪种状态需要定时任务补偿&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;假如某条单据一直无法处理结束，定时任务也不能无限制下发，所以本地消息表需要增加轮次的概念，重试多少次后告警，人工介入处理&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;因为MQ和定时任务的存在，难免会出现重复请求，因此下游要做好幂等防重，否则会出现重复数据，导致数据不一致&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;对于落地实现，话不多说，直接上代码。先定义两张表tb_order和tb_notice_message，分别存订单信息和本地事务信息&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;CREATE&lt;/span&gt; &lt;span&gt;TABLE&lt;/span&gt; &lt;span&gt;`tb_order`&lt;/span&gt; (&lt;br/&gt;  &lt;span&gt;`id`&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;(&lt;span&gt;11&lt;/span&gt;) &lt;span&gt;NOT&lt;/span&gt; &lt;span&gt;NULL&lt;/span&gt; AUTO_INCREMENT &lt;span&gt;COMMENT&lt;/span&gt; &lt;span&gt;&#x27;主键id&#x27;&lt;/span&gt;,&lt;br/&gt;  &lt;span&gt;`user_id`&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;(&lt;span&gt;11&lt;/span&gt;) &lt;span&gt;NOT&lt;/span&gt; &lt;span&gt;NULL&lt;/span&gt; &lt;span&gt;COMMENT&lt;/span&gt; &lt;span&gt;&#x27;下单人id&#x27;&lt;/span&gt;,&lt;br/&gt;  &lt;span&gt;`order_no`&lt;/span&gt; &lt;span&gt;varchar&lt;/span&gt;(&lt;span&gt;255&lt;/span&gt;) &lt;span&gt;CHARACTER&lt;/span&gt; &lt;span&gt;SET&lt;/span&gt; latin1 &lt;span&gt;NOT&lt;/span&gt; &lt;span&gt;NULL&lt;/span&gt; &lt;span&gt;COMMENT&lt;/span&gt; &lt;span&gt;&#x27;订单编号&#x27;&lt;/span&gt;,&lt;br/&gt;  &lt;span&gt;`insurance_amount`&lt;/span&gt; &lt;span&gt;decimal&lt;/span&gt;(&lt;span&gt;16&lt;/span&gt;,&lt;span&gt;2&lt;/span&gt;) &lt;span&gt;NOT&lt;/span&gt; &lt;span&gt;NULL&lt;/span&gt; &lt;span&gt;COMMENT&lt;/span&gt; &lt;span&gt;&#x27;保额&#x27;&lt;/span&gt;,&lt;br/&gt;  &lt;span&gt;`order_amount`&lt;/span&gt; &lt;span&gt;decimal&lt;/span&gt;(&lt;span&gt;16&lt;/span&gt;,&lt;span&gt;2&lt;/span&gt;) &lt;span&gt;DEFAULT&lt;/span&gt; &lt;span&gt;NULL&lt;/span&gt; &lt;span&gt;COMMENT&lt;/span&gt; &lt;span&gt;&#x27;保费&#x27;&lt;/span&gt;,&lt;br/&gt;  &lt;span&gt;`create_time`&lt;/span&gt; datetime &lt;span&gt;DEFAULT&lt;/span&gt; &lt;span&gt;NULL&lt;/span&gt; &lt;span&gt;COMMENT&lt;/span&gt; &lt;span&gt;&#x27;创建时间&#x27;&lt;/span&gt;,&lt;br/&gt;  &lt;span&gt;`update_time`&lt;/span&gt; datetime &lt;span&gt;DEFAULT&lt;/span&gt; &lt;span&gt;NULL&lt;/span&gt; &lt;span&gt;ON&lt;/span&gt; &lt;span&gt;UPDATE&lt;/span&gt; &lt;span&gt;CURRENT_TIMESTAMP&lt;/span&gt; &lt;span&gt;COMMENT&lt;/span&gt; &lt;span&gt;&#x27;更新时间&#x27;&lt;/span&gt;,&lt;br/&gt;  &lt;span&gt;`is_delete`&lt;/span&gt; &lt;span&gt;tinyint&lt;/span&gt;(&lt;span&gt;4&lt;/span&gt;) &lt;span&gt;DEFAULT&lt;/span&gt; &lt;span&gt;&#x27;0&#x27;&lt;/span&gt; &lt;span&gt;COMMENT&lt;/span&gt; &lt;span&gt;&#x27;删除标识：0-不删除；1-删除&#x27;&lt;/span&gt;,&lt;br/&gt;  PRIMARY &lt;span&gt;KEY&lt;/span&gt; (&lt;span&gt;`id`&lt;/span&gt;)&lt;br/&gt;) &lt;span&gt;ENGINE&lt;/span&gt;=&lt;span&gt;InnoDB&lt;/span&gt; AUTO_INCREMENT=&lt;span&gt;0&lt;/span&gt; &lt;span&gt;DEFAULT&lt;/span&gt; &lt;span&gt;CHARSET&lt;/span&gt;=utf8mb4;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;CREATE&lt;/span&gt; &lt;span&gt;TABLE&lt;/span&gt; &lt;span&gt;`tb_notice_message`&lt;/span&gt; (&lt;br/&gt;  &lt;span&gt;`id`&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;(&lt;span&gt;11&lt;/span&gt;) &lt;span&gt;NOT&lt;/span&gt; &lt;span&gt;NULL&lt;/span&gt; AUTO_INCREMENT &lt;span&gt;COMMENT&lt;/span&gt; &lt;span&gt;&#x27;主键id&#x27;&lt;/span&gt;,&lt;br/&gt;  &lt;span&gt;`type`&lt;/span&gt; &lt;span&gt;tinyint&lt;/span&gt;(&lt;span&gt;4&lt;/span&gt;) &lt;span&gt;NOT&lt;/span&gt; &lt;span&gt;NULL&lt;/span&gt; &lt;span&gt;COMMENT&lt;/span&gt; &lt;span&gt;&#x27;业务类型：1-下单&#x27;&lt;/span&gt;,&lt;br/&gt;  &lt;span&gt;`status`&lt;/span&gt; &lt;span&gt;tinyint&lt;/span&gt;(&lt;span&gt;4&lt;/span&gt;) &lt;span&gt;NOT&lt;/span&gt; &lt;span&gt;NULL&lt;/span&gt; &lt;span&gt;DEFAULT&lt;/span&gt; &lt;span&gt;&#x27;1&#x27;&lt;/span&gt; &lt;span&gt;COMMENT&lt;/span&gt; &lt;span&gt;&#x27;状态：1-待处理，2-已处理，3-预警&#x27;&lt;/span&gt;,&lt;br/&gt;  &lt;span&gt;`data`&lt;/span&gt; &lt;span&gt;varchar&lt;/span&gt;(&lt;span&gt;255&lt;/span&gt;) &lt;span&gt;NOT&lt;/span&gt; &lt;span&gt;NULL&lt;/span&gt; &lt;span&gt;COMMENT&lt;/span&gt; &lt;span&gt;&#x27;信息&#x27;&lt;/span&gt;,&lt;br/&gt;  &lt;span&gt;`retry_count`&lt;/span&gt; &lt;span&gt;tinyint&lt;/span&gt;(&lt;span&gt;4&lt;/span&gt;) &lt;span&gt;DEFAULT&lt;/span&gt; &lt;span&gt;&#x27;0&#x27;&lt;/span&gt; &lt;span&gt;COMMENT&lt;/span&gt; &lt;span&gt;&#x27;重试次数&#x27;&lt;/span&gt;,&lt;br/&gt;  &lt;span&gt;`create_time`&lt;/span&gt; datetime &lt;span&gt;NOT&lt;/span&gt; &lt;span&gt;NULL&lt;/span&gt; &lt;span&gt;COMMENT&lt;/span&gt; &lt;span&gt;&#x27;创建时间&#x27;&lt;/span&gt;,&lt;br/&gt;  &lt;span&gt;`update_time`&lt;/span&gt; datetime &lt;span&gt;DEFAULT&lt;/span&gt; &lt;span&gt;NULL&lt;/span&gt; &lt;span&gt;ON&lt;/span&gt; &lt;span&gt;UPDATE&lt;/span&gt; &lt;span&gt;CURRENT_TIMESTAMP&lt;/span&gt; &lt;span&gt;COMMENT&lt;/span&gt; &lt;span&gt;&#x27;更新时间&#x27;&lt;/span&gt;,&lt;br/&gt;  &lt;span&gt;`is_delete`&lt;/span&gt; &lt;span&gt;tinyint&lt;/span&gt;(&lt;span&gt;4&lt;/span&gt;) &lt;span&gt;NOT&lt;/span&gt; &lt;span&gt;NULL&lt;/span&gt; &lt;span&gt;DEFAULT&lt;/span&gt; &lt;span&gt;&#x27;0&#x27;&lt;/span&gt; &lt;span&gt;COMMENT&lt;/span&gt; &lt;span&gt;&#x27;删除标识：0-不删除；1-删除&#x27;&lt;/span&gt;,&lt;br/&gt;  PRIMARY &lt;span&gt;KEY&lt;/span&gt; (&lt;span&gt;`id`&lt;/span&gt;)&lt;br/&gt;) &lt;span&gt;ENGINE&lt;/span&gt;=&lt;span&gt;InnoDB&lt;/span&gt; AUTO_INCREMENT=&lt;span&gt;0&lt;/span&gt; &lt;span&gt;DEFAULT&lt;/span&gt; &lt;span&gt;CHARSET&lt;/span&gt;=utf8mb4;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;处理订单service，这里可以用到我们之前说过的&lt;strong&gt;装饰器模式&lt;/strong&gt;，去装饰这个service。把保存本地事务，发送mq消息，交给装饰器类去做，而service只需要关心业务逻辑即可，也符合&lt;strong&gt;开闭原则&lt;/strong&gt;。&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;/**&lt;br/&gt; * &lt;span&gt;@author&lt;/span&gt; 往事如风&lt;br/&gt; * &lt;span&gt;@version&lt;/span&gt; 1.0&lt;br/&gt; * &lt;span&gt;@date&lt;/span&gt; 2022/12/13 10:58&lt;br/&gt; * &lt;span&gt;@description&lt;/span&gt;&lt;br/&gt; */&lt;/span&gt;&lt;br/&gt;&lt;span&gt;@Service&lt;/span&gt;&lt;br/&gt;&lt;span&gt;@Slf&lt;/span&gt;4j&lt;br/&gt;&lt;span&gt;@AllArgsConstructor&lt;/span&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;OrderService&lt;/span&gt; &lt;span&gt;implements&lt;/span&gt; &lt;span&gt;BaseHandler&lt;/span&gt;&amp;lt;&lt;span&gt;Object&lt;/span&gt;, &lt;span&gt;Order&lt;/span&gt;&amp;gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; OrderMapper orderMapper;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;/**&lt;br/&gt;     * 订单处理方法：只处理订单关联逻辑&lt;br/&gt;     * &lt;span&gt;@param&lt;/span&gt; o&lt;br/&gt;     * &lt;span&gt;@return&lt;/span&gt;&lt;br/&gt;     */&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; Order &lt;span&gt;handle&lt;/span&gt;&lt;span&gt;(Object o)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;// 订单信息&lt;/span&gt;&lt;br/&gt;        Order order = Order.builder()&lt;br/&gt;                .orderNo(&lt;span&gt;&quot;2345678&quot;&lt;/span&gt;)&lt;br/&gt;                .createTime(LocalDateTime.now())&lt;br/&gt;                .userId(&lt;span&gt;1&lt;/span&gt;)&lt;br/&gt;                .insuranceAmount(&lt;span&gt;new&lt;/span&gt; BigDecimal(&lt;span&gt;2000000&lt;/span&gt;))&lt;br/&gt;                .orderAmount(&lt;span&gt;new&lt;/span&gt; BigDecimal(&lt;span&gt;5000&lt;/span&gt;))&lt;br/&gt;                .build();&lt;br/&gt;        orderMapper.insert(order);&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; order;&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;新增&lt;code&gt;OrderService&lt;/code&gt;的装饰类&lt;code&gt;OrderServiceDecorate&lt;/code&gt;，负责对订单逻辑的扩展，这里是添加本地事务消息，以及发送MQ信息，扩展方法添加了&lt;code&gt;Transactional&lt;/code&gt;注解，确保订单逻辑和本地事务消息的数据在同一个事务中进行，确保原子性。其中事务消息标记处理中，待下游服务处理完业务逻辑，再更新处理完成。&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;/**&lt;br/&gt; * &lt;span&gt;@author&lt;/span&gt; 往事如风&lt;br/&gt; * &lt;span&gt;@version&lt;/span&gt; 1.0&lt;br/&gt; * &lt;span&gt;@date&lt;/span&gt; 2022/12/14 18:48&lt;br/&gt; * &lt;span&gt;@description&lt;/span&gt;&lt;br/&gt; */&lt;/span&gt;&lt;br/&gt;&lt;span&gt;@Slf&lt;/span&gt;4j&lt;br/&gt;&lt;span&gt;@AllArgsConstructor&lt;/span&gt;&lt;br/&gt;&lt;span&gt;@Decorate&lt;/span&gt;(scene = SceneConstants.ORDER, type = DecorateConstants.CREATE_ORDER)&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;OrderServiceDecorate&lt;/span&gt; &lt;span&gt;extends&lt;/span&gt; &lt;span&gt;AbstractHandler&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; NoticeMessageMapper noticeMessageMapper;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; RabbitTemplate rabbitTemplate;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;/**&lt;br/&gt;     * 装饰方法：对订单处理逻辑进行扩展&lt;br/&gt;     * &lt;span&gt;@param&lt;/span&gt; o&lt;br/&gt;     * &lt;span&gt;@return&lt;/span&gt;&lt;br/&gt;     */&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;@Transactional&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; Object &lt;span&gt;handle&lt;/span&gt;&lt;span&gt;(Object o)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;// 调用service方法，实现保单逻辑&lt;/span&gt;&lt;br/&gt;        Order order = (Order) service.handle(o);&lt;br/&gt;        &lt;span&gt;// 扩展：1、保存事务消息，2、发送MQ消息&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;// 本地事务消息&lt;/span&gt;&lt;br/&gt;        String data = &lt;span&gt;&quot;{\&quot;orderNo\&quot;:\&quot;2345678\&quot;, \&quot;userId\&quot;:1, \&quot;insuranceAmount\&quot;:2000000, \&quot;orderAmount\&quot;:5000}&quot;&lt;/span&gt;;&lt;br/&gt;        NoticeMessage noticeMessage = NoticeMessage.builder()&lt;br/&gt;                .retryCount(&lt;span&gt;0&lt;/span&gt;)&lt;br/&gt;                .data(data)&lt;br/&gt;                .status(&lt;span&gt;1&lt;/span&gt;)&lt;br/&gt;                .type(&lt;span&gt;1&lt;/span&gt;)&lt;br/&gt;                .createTime(LocalDateTime.now())&lt;br/&gt;                .build();&lt;br/&gt;        noticeMessageMapper.insert(noticeMessage);&lt;br/&gt;        &lt;span&gt;// 发送mq消息&lt;/span&gt;&lt;br/&gt;        log.info(&lt;span&gt;&quot;发送mq消息....&quot;&lt;/span&gt;);&lt;br/&gt;        rabbitTemplate.convertAndSend(&lt;span&gt;&quot;trans&quot;&lt;/span&gt;, &lt;span&gt;&quot;trans.queue.key&quot;&lt;/span&gt;, JSONUtil.toJsonStr(noticeMessage));&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;;&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;关于这个装饰者模式，之前有讲到过，可以看下之前发布的内容。&lt;/p&gt;&lt;p&gt;下游服务监听消息，处理完自己的业务逻辑后（如：业绩、分润、晋升等），需要发送MQ，上游服务监听消息，更新本地事务状态为已处理。这需要注意的是下游服务需要做幂等处理，防止异常情况下，上游服务数据的重试。&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;/**&lt;br/&gt; * &lt;span&gt;@author&lt;/span&gt; 往事如风&lt;br/&gt; * &lt;span&gt;@version&lt;/span&gt; 1.0&lt;br/&gt; * &lt;span&gt;@date&lt;/span&gt; 2022/12/13 18:07&lt;br/&gt; * &lt;span&gt;@description&lt;/span&gt;&lt;br/&gt; */&lt;/span&gt;&lt;br/&gt;&lt;span&gt;@Component&lt;/span&gt;&lt;br/&gt;&lt;span&gt;@Slf&lt;/span&gt;4j&lt;br/&gt;&lt;span&gt;@RabbitListener&lt;/span&gt;(queues = &lt;span&gt;&quot;trans.queue&quot;&lt;/span&gt;)&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;FenRunListener&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@Autowired&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; RabbitTemplate rabbitTemplate;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@RabbitHandler&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;orderHandler&lt;/span&gt;&lt;span&gt;(String msg)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        log.info(&lt;span&gt;&quot;监听到订单消息:{}&quot;&lt;/span&gt;, msg);&lt;br/&gt;        &lt;span&gt;// 需要注意幂等，幂等逻辑&lt;/span&gt;&lt;br/&gt;        log.info(&lt;span&gt;&quot;下游服务业务逻辑。。。。。&quot;&lt;/span&gt;);&lt;br/&gt;        JSONObject json = JSONUtil.parseObj(msg);&lt;br/&gt;        rabbitTemplate.convertAndSend(&lt;span&gt;&quot;trans&quot;&lt;/span&gt;, &lt;span&gt;&quot;trans.update.order.queue.key&quot;&lt;/span&gt;, json.getInt(&lt;span&gt;&quot;id&quot;&lt;/span&gt;));&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这里插个题外话，关于幂等的处理，我这里大致有两种思路 1、比如根据订单号查一下记录是否存在，存在就直接返回成功。2、redis存一个唯一的请求号，处理完再删除，不存在请求号的直接返回成功，可以写个AOP去处理，与业务隔离。言归正传，上游服务消息监听，下游发送MQ消息，更新本地事务消息为已处理，分布式事务流程结束。&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;/**&lt;br/&gt; * &lt;span&gt;@author&lt;/span&gt; 往事如风&lt;br/&gt; * &lt;span&gt;@version&lt;/span&gt; 1.0&lt;br/&gt; * &lt;span&gt;@date&lt;/span&gt; 2022/12/13 18:29&lt;br/&gt; * &lt;span&gt;@description&lt;/span&gt;&lt;br/&gt; */&lt;/span&gt;&lt;br/&gt;&lt;span&gt;@Component&lt;/span&gt;&lt;br/&gt;&lt;span&gt;@Slf&lt;/span&gt;4j&lt;br/&gt;&lt;span&gt;@RabbitListener&lt;/span&gt;(queues = &lt;span&gt;&quot;trans.update.order.queue&quot;&lt;/span&gt;)&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;OrderListener&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@Autowired&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; NoticeMessageMapper noticeMessageMapper;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@RabbitHandler&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;updateOrder&lt;/span&gt;&lt;span&gt;(Integer msgId)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        log.info(&lt;span&gt;&quot;监听消息，更新本地事务消息，消息id:{}&quot;&lt;/span&gt;, msgId);&lt;br/&gt;        NoticeMessage msg = NoticeMessage.builder().status(&lt;span&gt;2&lt;/span&gt;).id(msgId).updateTime(LocalDateTime.now()).build();&lt;br/&gt;        noticeMessageMapper.updateById(msg);&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;存在异常情况时，会通过定时任务，轮询的往MQ中发送消息，尽最大努力去让下游服务达到数据一致，当然重试也要设置上限；若达到上限以后还一直是失败，那不得不考虑是下游服务自身存在问题了（有可能就是代码逻辑存在问题）。&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;/**&lt;br/&gt; * &lt;span&gt;@author&lt;/span&gt; 往事如风&lt;br/&gt; * &lt;span&gt;@version&lt;/span&gt; 1.0&lt;br/&gt; * &lt;span&gt;@date&lt;/span&gt; 2022/12/14 10:25&lt;br/&gt; * &lt;span&gt;@description&lt;/span&gt;&lt;br/&gt; */&lt;/span&gt;&lt;br/&gt;&lt;span&gt;@Configuration&lt;/span&gt;&lt;br/&gt;&lt;span&gt;@EnableScheduling&lt;/span&gt;&lt;br/&gt;&lt;span&gt;@AllArgsConstructor&lt;/span&gt;&lt;br/&gt;&lt;span&gt;@Slf&lt;/span&gt;4j&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;RetryOrderJob&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; RabbitTemplate rabbitTemplate;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; NoticeMessageMapper noticeMessageMapper;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;/**&lt;br/&gt;     * 最大自动重试次数&lt;br/&gt;     */&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; Integer MAX_RETRY_COUNT = &lt;span&gt;5&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@Scheduled&lt;/span&gt;(cron = &lt;span&gt;&quot;0/20 * * * * ? &quot;&lt;/span&gt;)&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;retry&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        log.info(&lt;span&gt;&quot;定时任务，重试异常订单&quot;&lt;/span&gt;);&lt;br/&gt;        LambdaQueryWrapper&amp;lt;NoticeMessage&amp;gt; wrapper = Wrappers.lambdaQuery(NoticeMessage&lt;span&gt;.&lt;span&gt;class&lt;/span&gt;)&lt;/span&gt;;&lt;br/&gt;        wrapper.eq(NoticeMessage::getStatus, &lt;span&gt;1&lt;/span&gt;);&lt;br/&gt;        List&amp;lt;NoticeMessage&amp;gt; noticeMessages = noticeMessageMapper.selectList(wrapper);&lt;br/&gt;        &lt;span&gt;for&lt;/span&gt; (NoticeMessage noticeMessage : noticeMessages) {&lt;br/&gt;            &lt;span&gt;// 重新发送mq消息&lt;/span&gt;&lt;br/&gt;            rabbitTemplate.convertAndSend(&lt;span&gt;&quot;trans&quot;&lt;/span&gt;, &lt;span&gt;&quot;trans.queue.key&quot;&lt;/span&gt;, JSONUtil.toJsonStr(noticeMessage));&lt;br/&gt;            &lt;span&gt;// 重试次数+1&lt;/span&gt;&lt;br/&gt;            noticeMessage.setRetryCount(noticeMessage.getRetryCount() + &lt;span&gt;1&lt;/span&gt;);&lt;br/&gt;            noticeMessageMapper.updateById(noticeMessage);&lt;br/&gt;            &lt;span&gt;// 判断重试次数，等于最长限制次数，直接更新为报警状态&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;if&lt;/span&gt; (MAX_RETRY_COUNT.equals(noticeMessage.getRetryCount())) {&lt;br/&gt;                noticeMessage.setStatus(&lt;span&gt;3&lt;/span&gt;);&lt;br/&gt;                noticeMessageMapper.updateById(noticeMessage);&lt;br/&gt;                &lt;span&gt;// 发送告警，通知对应人员&lt;/span&gt;&lt;br/&gt;                &lt;span&gt;// 告警逻辑（短信、邮件、企微群，等等）....&lt;/span&gt;&lt;br/&gt;            }&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;其实这里有个问题，一个上游服务对应多个下游服务的时候。这个时候往往不能存一条本地消息记录。&lt;/p&gt;&lt;ol class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;这里可以在消息表多加个字段next_server_count，表示一个订单发起方，需要调用的下游服务数量。上游服务监听的时候，每次会与下游的回调都减去1，直到数值是0的时候，再更新状态是已处理。但是要控制并发，这个字段是被多个下游服务共享的。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;还有一种处理方案是为每个下游服务，都记录一条事务消息，用type字段去区分，标记类型。实现上游和下游对于事务消息的一对一关系。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;最后，达到最大重试次数以后，可以将消息加入到一个告警列表，这个告警列表可以展示在管理后台或其他监控系统中，展示一些必要的信息，去供公司内部人员去人工介入，处理这种异常的数据，使得数据达到最终一致性。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h1&gt;&lt;span&gt;四、总结&lt;/span&gt;&lt;span/&gt;&lt;/h1&gt;&lt;p&gt;其实分布式事务没有一个完美的处理方案，只能说是尽量去满足业务需求，满足数据一致。如果程序不能处理了，最后由人工去兜底，做数据的补偿方案。&lt;/p&gt;&lt;h1&gt;&lt;span&gt;五、参考源码&lt;/span&gt;&lt;span/&gt;&lt;/h1&gt;&lt;pre&gt;&lt;code&gt;编程文档：&lt;br/&gt;https://gitee.com/cicadasmile/butte-java-note&lt;br/&gt;&lt;br/&gt;应用仓库：&lt;br/&gt;https://gitee.com/cicadasmile/butte-flyer-parent&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;END&lt;/strong&gt;&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section data-support=&quot;96编辑器&quot; data-style-id=&quot;30792&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;97816&quot; data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;section data-role=&quot;outer&quot; label=&quot;Powered by 135editor.com&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;mp-style-type data-value=&quot;3&quot;/&gt;&lt;/p&gt;&lt;/div&gt;

          
        &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>f298a70eee036055e7fbc4c16e57f63a</guid>
<title>分布式夺命 12 连问</title>
<link>https://toutiao.io/k/zt40fyg</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content js_underline_content             autoTypeSetting24psection&amp;#10;            &quot; id=&quot;js_content&quot;&gt;&lt;p data-tool=&quot;mdnice编辑器&quot; data-mpa-powered-by=&quot;yiban.io&quot;&gt;大家好，我是苏三，欢迎大家到我的知识星球【&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzkwNjMwMTgzMQ==&amp;amp;mid=2247501201&amp;amp;idx=2&amp;amp;sn=1b0e0b12f313f94c503a0aa3b565fedb&amp;amp;chksm=c0e81d79f79f946f49e53e03390c13e30d321a865cfd0e8b1a4ea37c498041398132e03db091&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;Java突击队&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;&lt;strong&gt;Java突击队&lt;/strong&gt;&lt;/span&gt;&lt;/a&gt;】，一起学习，一起进步。&lt;/p&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;分布式理论&lt;/span&gt;&lt;/h1&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;1. 说说CAP原则？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;CAP原则又称CAP定理，指的是在一个分布式系统中，Consistency（一致性）、 Availability（可用性）、Partition tolerance（分区容错性）这3个基本需求，最多只能同时满足其中的2个。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.8474945533769063&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWcP0zQGiaUvTrZEyBtkUL4MCdZmfO7KVowmD2tush38epucvYsPvW6O5E2NX3q61wgGqZwtNXoicICQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;918&quot;/&gt;&lt;figcaption&gt;CAP原则&lt;/figcaption&gt;&lt;/figure&gt;&lt;section data-tool=&quot;mdnice编辑器&quot;&gt;&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;选项&lt;/th&gt;&lt;th&gt;描述&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;Consistency（一致性）&lt;/td&gt;&lt;td&gt;指数据在多个副本之间能够保持一致的特性（严格的一致性）&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;Availability（可用性）&lt;/td&gt;&lt;td&gt;指系统提供的服务必须一直处于可用的状态，每次请求都能获取到非错的响应（不保证获取的数据为最新数据）&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;Partition tolerance（分区容错性）&lt;/td&gt;&lt;td&gt;分布式系统在遇到任何网络分区故障的时候，仍然能够对外提供满足一致性和可用性的服务，除非整个网络环境都发生了故障&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/section&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;2. 为什么CAP不可兼得呢？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;首先对于分布式系统，分区是必然存在的，所谓分区指的是分布式系统可能出现的字区域网络不通，成为孤立区域的的情况。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.3501628664495114&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWcP0zQGiaUvTrZEyBtkUL4MC69TMFQdSvLOPnrI2APAgNgfcicqIBNQjkgpE1xMXRWHk1eglE2XqOyg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1228&quot;/&gt;&lt;figcaption&gt;分区&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那么分区容错性（&lt;strong&gt;P&lt;/strong&gt;）就必须要满足，因为如果要牺牲分区容错性，就得把服务和资源放到一个机器，或者一个“同生共死”的集群，那就违背了分布式的初衷。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那么满足分区容错的基础上，能不能同时满足&lt;code&gt;一致性&lt;/code&gt;和&lt;code&gt;可用性&lt;/code&gt;？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;假如现在有两个分区&lt;code&gt;N1&lt;/code&gt;和&lt;code&gt;N2&lt;/code&gt;，N1和N2分别有不同的分区存储D1和D2，以及不同的服务S1和S2。&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;在满足&lt;code&gt;一致性&lt;/code&gt; 的时候，N1和N2的数据要求值一样的，D1=D2。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;在满足&lt;code&gt;可用性&lt;/code&gt;的时候，无论访问N1还是N2，都能获取及时的响应。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6223404255319149&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWcP0zQGiaUvTrZEyBtkUL4MC9182SeVyibhTFU28bLicsBKFvZRu2Mmj6vmmJQ6RjPpY4fLLdbiclup2Q/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1128&quot;/&gt;&lt;figcaption&gt;分区的服务&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;假如现在有这样的场景：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;用户访问了N1，修改了D1的数据。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;用户再次访问，请求落在了N2。此时D1和D2的数据不一致。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;接下来：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;保证&lt;code&gt;一致性&lt;/code&gt;：此时D1和D2数据不一致，要保证一致性就不能返回不一致的数据，&lt;code&gt;可用性&lt;/code&gt;无法保证。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;保证&lt;code&gt;可用性&lt;/code&gt;：立即响应，可用性得到了保证，但是此时响应的数据和D1不一致，&lt;code&gt;一致性&lt;/code&gt;无法保证。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以，可以看出，分区容错的前提下，&lt;code&gt;一致性&lt;/code&gt;和&lt;code&gt;可用性&lt;/code&gt;是矛盾的。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;3. CAP对应的模型和应用？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;CA without P&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;理论上放弃P（分区容错性），则C（强一致性）和A（可用性）是可以保证的。实际上分区是不可避免的，严格上CA指的是允许分区后各子系统依然保持CA。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;CA模型的常见应用：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;CP without A&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;放弃A（可用），相当于每个请求都需要在Server之间强一致，而P（分区）会导致同步时间无限延长，如此CP也是可以保证的。很多传统的数据库分布式事务都属于这种模式。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;CP模型的常见应用：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;AP wihtout C&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;要高可用并允许分区，则需放弃一致性。一旦分区发生，节点之间可能会失去联系，为了高可用，每个节点只能用本地数据提供服务，而这样会导致全局数据的不一致性。现在众多的NoSQL都属于此类。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;AP模型常见应用：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;举个大家更熟悉的例子，像我们熟悉的注册中心&lt;code&gt;ZooKeeper&lt;/code&gt;、&lt;code&gt;Eureka&lt;/code&gt;、&lt;code&gt;Nacos&lt;/code&gt;中：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;ZooKeeper 保证的是 CP&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Eureka 保证的则是 AP&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Nacos 不仅支持 CP 也支持 AP&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;4. BASE理论了解吗？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;BASE（Basically Available、Soft state、Eventual consistency）是基于CAP理论逐步演化而来的，核心思想是即便不能达到强一致性（Strong consistency），也可以根据应用特点采用适当的方式来达到最终一致性（Eventual consistency）的效果。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.58&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWcP0zQGiaUvTrZEyBtkUL4MC9toQL797XV4y2AGVhD7UOHHEib1ygHjloS5KSHEYK4P2HkFvpzIocvQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;650&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;BASE的主要含义：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;Basically Available（基本可用）&lt;/strong&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;什么是基本可用呢？假设系统出现了不可预知的故障，但还是能用，只是相比较正常的系统而言，可能会有响应时间上的损失，或者功能上的降级。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;什么是硬状态呢？要求多个节点的数据副本都是一致的，这是一种“硬状态”。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;软状态也称为弱状态，相比较硬状态而言，允许系统中的数据存在中间状态，并认为该状态不影响系统的整体可用性，即允许系统在多个不同节点的数据副本存在数据延时。&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;Eventually Consistent（最终一致性）&lt;/strong&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上面说了软状态，但是不应该一直都是软状态。在一定时间后，应该到达一个最终的状态，保证所有副本保持数据一致性，从而达到数据的最终一致性。这个时间取决于网络延时、系统负载、数据复制方案设计等等因素。&lt;/p&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;分布式锁&lt;/span&gt;&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;单体时代，可以直接用本地锁来实现对竞争资源的加锁，分布式环境下就要用到分布式锁了。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;5. 有哪些分布式锁的实现方案呢？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;常见的分布式锁实现方案有三种：&lt;code&gt;MySQL分布式锁&lt;/code&gt;、&lt;code&gt;ZooKepper分布式锁&lt;/code&gt;、&lt;code&gt;Redis分布式锁&lt;/code&gt;。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.7482837528604119&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWcP0zQGiaUvTrZEyBtkUL4MCfRw8QqtbDZB9RB1Os7MmGzBhXxE1drUbMl2pbxZn1vqxP5bZqX93Fw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;874&quot;/&gt;&lt;figcaption&gt;分布式锁&lt;/figcaption&gt;&lt;/figure&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;5.1 MySQL分布式锁如何实现呢？&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;用数据库实现分布式锁比较简单，就是创建一张锁表，数据库对字段作唯一性约束。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;加锁的时候，在锁表中增加一条记录即可；释放锁的时候删除记录就行。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果有并发请求同时提交到数据库，数据库会保证只有一个请求能够得到锁。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这种属于数据库 IO 操作，效率不高，而且频繁操作会增大数据库的开销，因此这种方式在高并发、高性能的场景中用的不多。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;5.2 ZooKeeper如何实现分布式锁？&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;ZooKeeper也是常见分布式锁实现方法。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;ZooKeeper的数据节点和文件目录类似，例如有一个lock节点，在此节点下建立子节点是可以保证先后顺序的，即便是两个进程同时申请新建节点，也会按照先后顺序建立两个节点。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5525114155251142&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWcP0zQGiaUvTrZEyBtkUL4MCv1TKIEPVp52wTlFr6vCr7cMGCTGTIAofxBwKaiboVPZKLVcXQNwkm4Q/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1314&quot;/&gt;&lt;figcaption&gt;ZooKeeper如何实现分布式锁&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以我们可以用此特性实现分布式锁。以某个资源为目录，然后这个目录下面的节点就是我们需要获取锁的客户端，每个服务在目录下创建节点，如果它的节点，序号在目录下最小，那么就获取到锁，否则等待。释放锁，就是删除服务创建的节点。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;ZK实际上是一个比较重的分布式组件，实际上应用没那么多了，所以用ZK实现分布式锁，其实相对也比较少。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;5.3 Redis怎么实现分布式锁？&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Redis实现分布式锁，是当前应用最广泛的分布式锁实现方式。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Redis执行命令是单线程的，Redis实现分布式锁就是利用这个特性。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;实现分布式锁最简单的一个命令：setNx(set if not exist)，如果不存在则更新：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;setNx resourceName value&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;加锁了之后如果机器宕机，那我这个锁就无法释放，所以需要加入过期时间，而且过期时间需要和setNx同一个原子操作，在Redis2.8之前需要用lua脚本，但是redis2.8之后redis支持nx和ex操作是同一原子操作。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;set resourceName value ex &lt;span&gt;5&lt;/span&gt; nx&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当然，一般生产中都是使用Redission客户端，非常良好地封装了分布式锁的api，而且支持RedLock。&lt;/p&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;分布式事务&lt;/span&gt;&lt;/h1&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;6.什么是分布式事务?&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;分布式事务是相对本地事务而言的，对于本地事务，利用数据库本身的事务机制，就可以保证事务的ACID特性。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.8005540166204986&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWcP0zQGiaUvTrZEyBtkUL4MCyeZVemywLKVAuI42E12yhB4jyedlbXuF01qYmaM9hSbicwiaJ4GfJsOg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;722&quot;/&gt;&lt;figcaption&gt;ACID&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;而在分布式环境下，会涉及到多个数据库。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6409774436090225&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWcP0zQGiaUvTrZEyBtkUL4MCKbkl09899pNe48rJsRw1dLgB7emJnzZUb5TQ7icibJibdly43ibfhDDzEA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1064&quot;/&gt;&lt;figcaption&gt;多数据库&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;分布式事务其实就是将对同一库事务的概念扩大到了对多个库的事务。目的是为了保证分布式系统中的数据一致性。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;分布式事务处理的关键是：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;需要记录事务在任何节点所做的所有动作；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;事务进行的所有操作要么全部提交，要么全部回滚。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;7.分布式事务有哪些常见的实现方案？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;分布式常见的实现方案有 &lt;strong&gt;2PC&lt;/strong&gt;、&lt;strong&gt;3PC&lt;/strong&gt;、&lt;strong&gt;TCC&lt;/strong&gt;、&lt;strong&gt;本地消息表&lt;/strong&gt;、&lt;strong&gt;MQ消息事务&lt;/strong&gt;、&lt;strong&gt;最大努力通知&lt;/strong&gt;、&lt;strong&gt;SAGA事务&lt;/strong&gt; 等等。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;7.1 说说2PC两阶段提交？&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;说到2PC，就不得先说分布式事务中的 XA 协议。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在这个协议里，有三个角色：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;AP（Application）&lt;/strong&gt;：应用系统（服务）&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;TM（Transaction Manager）&lt;/strong&gt;：事务管理器（全局事务管理）&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;RM（Resource Manager）&lt;/strong&gt;：资源管理器（数据库）&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5456989247311828&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWcP0zQGiaUvTrZEyBtkUL4MCQNdeHlplNMIPlchYPOocNxqe4oDRPaK0YPOIAcdlg6g6WaEx0ojdNw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;744&quot;/&gt;&lt;figcaption&gt;XA协议&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;XA协议采用&lt;strong&gt;两阶段提交&lt;/strong&gt;方式来管理分布式事务。XA接口提供资源管理器与事务管理器之间进行通信的标准接口。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;两阶段提交的思路可以概括为：参与者将操作成败通知协调者，再由协调者根据所有参与者的反馈情况决定各参与者是否要提交操作还是回滚操作。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.46131805157593125&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWcP0zQGiaUvTrZEyBtkUL4MChicdkhOibkoWpwFibtZXoIjCiaRgibU8X3MB6mUobcz2AVicuvfsnlDRcYOA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1396&quot;/&gt;&lt;figcaption&gt;2PC&lt;/figcaption&gt;&lt;/figure&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;准备阶段：事务管理器要求每个涉及到事务的数据库预提交(precommit)此操作，并反映是否可以提交&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;提交阶段：事务协调器要求每个数据库提交数据，或者回滚数据。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;优点：尽量保证了数据的强一致，实现成本较低，在各大主流数据库都有自己实现，对于MySQL是从5.5开始支持。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;缺点:&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;单点问题：事务管理器在整个流程中扮演的角色很关键，如果其宕机，比如在第一阶段已经完成，在第二阶段正准备提交的时候事务管理器宕机，资源管理器就会一直阻塞，导致数据库无法使用。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;同步阻塞：在准备就绪之后，资源管理器中的资源一直处于阻塞，直到提交完成，释放资源。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;数据不一致：两阶段提交协议虽然为分布式数据强一致性所设计，但仍然存在数据不一致性的可能，比如在第二阶段中，假设协调者发出了事务commit的通知，但是因为网络问题该通知仅被一部分参与者所收到并执行了commit操作，其余的参与者则因为没有收到通知一直处于阻塞状态，这时候就产生了数据的不一致性。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;7.2 3PC（三阶段提交）了解吗？&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;三阶段提交（&lt;code&gt;3PC&lt;/code&gt;）是二阶段提交（&lt;code&gt;2PC&lt;/code&gt;）的一种改进版本 ，为解决两阶段提交协议的单点故障和同步阻塞问题。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;三阶段提交有这么三个阶段：&lt;code&gt;CanCommit&lt;/code&gt;，&lt;code&gt;PreCommit&lt;/code&gt;，&lt;code&gt;DoCommit&lt;/code&gt;三个阶段&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.392018779342723&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWcP0zQGiaUvTrZEyBtkUL4MCJNxY9Pw2qkBgXf9Y3ABbxLy8gAJmVLArFHicbmzvKQKwWnZo6nvsCnw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1704&quot;/&gt;&lt;figcaption&gt;3PC&lt;/figcaption&gt;&lt;/figure&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;CanCommit&lt;/strong&gt;：准备阶段。协调者向参与者发送commit请求，参与者如果可以提交就返回Yes响应，否则返回No响应。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;PreCommit&lt;/strong&gt;：预提交阶段。协调者根据参与者在&lt;strong&gt;准备阶段&lt;/strong&gt;的响应判断是否执行事务还是中断事务，参与者执行完操作之后返回ACK响应，同时开始等待最终指令。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;DoCommit&lt;/strong&gt;：提交阶段。协调者根据参与者在&lt;strong&gt;准备阶段&lt;/strong&gt;的响应判断是否执行事务还是中断事务：&lt;/section&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;如果所有参与者都返回正确的&lt;code&gt;ACK&lt;/code&gt;响应，则提交事务&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;如果参与者有一个或多个参与者收到错误的&lt;code&gt;ACK&lt;/code&gt;响应或者超时，则中断事务&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;如果参与者无法及时接收到来自协调者的提交或者中断事务请求时，在等待超时之后，会继续进行事务提交&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可以看出，三阶段提交解决的只是两阶段提交中&lt;strong&gt;单体故障&lt;/strong&gt;和&lt;strong&gt;同步阻塞&lt;/strong&gt;的问题，因为加入了超时机制，这里的超时的机制作用于 &lt;strong&gt;预提交阶段&lt;/strong&gt; 和 &lt;strong&gt;提交阶段&lt;/strong&gt;。如果等待 &lt;strong&gt;预提交请求&lt;/strong&gt; 超时，参与者直接回到准备阶段之前。如果等到&lt;strong&gt;提交请求&lt;/strong&gt;超时，那参与者就会提交事务了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;无论是2PC还是3PC都不能保证分布式系统中的数据100%一致&lt;/strong&gt;。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;7.3 TCC了解吗？&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;TCC（Try Confirm Cancel）&lt;/strong&gt; ，是两阶段提交的一个变种，针对每个操作，都需要有一个其对应的确认和取消操作，当操作成功时调用确认操作，当操作失败时调用取消操作，类似于二阶段提交，只不过是这里的提交和回滚是针对业务上的，所以基于TCC实现的分布式事务也可以看做是对业务的一种补偿机制。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5908440629470673&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWcP0zQGiaUvTrZEyBtkUL4MCVtsmNAqhSRicSPu9JGo4UWy9icFqqA6jrwXbEtlp52iaKm0cUzO3Lj1Vw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1398&quot;/&gt;&lt;figcaption&gt;TCC下单减库存&lt;/figcaption&gt;&lt;/figure&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;Try&lt;/strong&gt;：尝试待执行的业务。订单系统将当前订单状态设置为支付中，库存系统校验当前剩余库存数量是否大于1，然后将可用库存数量设置为库存剩余数量-1，。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;Confirm&lt;/strong&gt;：确认执行业务，如果Try阶段执行成功，接着执行Confirm 阶段，将订单状态修改为支付成功，库存剩余数量修改为可用库存数量。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;Cancel&lt;/strong&gt;：取消待执行的业务，如果Try阶段执行失败，执行Cancel 阶段，将订单状态修改为支付失败，可用库存数量修改为库存剩余数量。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;TCC&lt;/strong&gt; 是业务层面的分布式事务，保证最终一致性，不会一直持有资源的锁。&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;优点：&lt;/strong&gt; 把数据库层的二阶段提交交给应用层来实现，规避了数据库的 2PC 性能低下问题&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;缺点&lt;/strong&gt;：TCC 的 Try、Confirm 和 Cancel 操作功能需业务提供，开发成本高。TCC 对业务的侵入较大和业务紧耦合，需要根据特定的场景和业务逻辑来设计相应的操作&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;7.4 本地消息表了解吗？&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;本地消息表的核心思想是将分布式事务拆分成本地事务进行处理。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;例如，可以在订单库新增一个消息表，将新增订单和新增消息放到一个事务里完成，然后通过轮询的方式去查询消息表，将消息推送到MQ，库存服务去消费MQ。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.2906641000962464&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWcP0zQGiaUvTrZEyBtkUL4MCSMFChxIWDYQORqnBwd9N6EciaHusQnDknyRWMyjcicNWjRMxc0t7KuXQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2078&quot;/&gt;&lt;figcaption&gt;本地消息表&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;执行流程：&lt;/strong&gt;&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;订单服务，添加一条订单和一条消息，在一个事务里提交&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;订单服务，使用定时任务轮询查询状态为未同步的消息表，发送到MQ，如果发送失败，就重试发送&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;库存服务，接收MQ消息，修改库存表，需要保证幂等操作&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;如果修改成功，调用rpc接口修改订单系统消息表的状态为已完成或者直接删除这条消息&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;如果修改失败，可以不做处理，等待重试&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;订单服务中的消息有可能由于业务问题会一直重复发送，所以为了避免这种情况可以记录一下发送次数，当达到次数限制之后报警，人工接入处理；库存服务需要保证幂等，避免同一条消息被多次消费造成数据不一致。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;本地消息表这种方案实现了最终一致性，需要在业务系统里增加消息表，业务逻辑中多一次插入的DB操作，所以性能会有损耗，而且最终一致性的间隔主要有定时任务的间隔时间决定&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;7.5 MQ消息事务了解吗？&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;消息事务的原理是&lt;strong&gt;将两个事务通过消息中间件进行异步解耦&lt;/strong&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;订单服务执行自己的本地事务，并发送MQ消息，库存服务接收消息，执行自己的本地事务，乍一看，好像跟本地消息表的实现方案类似，只是省去 了对本地消息表的操作和轮询发送MQ的操作，但实际上两种方案的实现是不一样的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;消息事务一定要保证业务操作与消息发送的一致性，如果业务操作成功，这条消息也一定投递成功。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6930835734870316&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWcP0zQGiaUvTrZEyBtkUL4MCVyh3LENJicib1lcNtd0GcvFbg7oABZWlwVpDxfAf5oJlrSCJ1mkJbyDQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1388&quot;/&gt;&lt;figcaption&gt;MQ消息事务&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;执行流程：&lt;/strong&gt;&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;发送prepare消息到消息中间件&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;发送成功后，执行本地事务&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;如果事务执行成功，则commit，消息中间件将消息下发至消费端&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;如果事务执行失败，则回滚，消息中间件将这条prepare消息删除&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;消费端接收到消息进行消费，如果消费失败，则不断重试&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;消息事务依赖于消息中间件的事务消息，例如我们熟悉的RocketMQ就支持事务消息（半消息），也就是只有收到发送方确定才会正常投递的消息。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这种方案也是实现了最终一致性，对比本地消息表实现方案，不需要再建消息表，对性能的损耗和业务的入侵更小。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;7.6 最大努力通知了解吗？&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;最大努力通知相比实现会简单一些，适用于一些对最终一致性实时性要求没那么高的业务，比如支付通知，短信通知。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;以支付通知为例，业务系统调用支付平台进行支付，支付平台进行支付，进行操作支付之后支付平台会去同步通知业务系统支付操作是否成功，如果不成功，会一直异步重试，但是会有一个最大通知次数，如果超过这个次数后还是通知失败，就不再通知，业务系统自行调用支付平台提供一个查询接口，供业务系统进行查询支付操作是否成功。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5104166666666666&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWcP0zQGiaUvTrZEyBtkUL4MCeEoiat9IoCYklLtW4SCtQ8icjFg0mtFNjB0bk2Ribibo1BDdwXbuGoa2MA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1152&quot;/&gt;&lt;figcaption&gt;最大努力通知&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;执行流程：&lt;/strong&gt;&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;业务系统调用支付平台支付接口， 并在本地进行记录，支付状态为支付中&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;支付平台进行支付操作之后，无论成功还是失败，同步给业务系统一个结果通知&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;如果通知一直失败则根据重试规则异步进行重试，达到最大通知次数后，不再通知&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;支付平台提供查询订单支付操作结果接口&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;业务系统根据一定业务规则去支付平台查询支付结果&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;8.你们用什么？能说一下Seata吗？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们用比较常用的是Seata——自己去实现分布式事务调度还是比较麻烦的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;Seata&lt;/strong&gt; 的设计目标是对业务无侵入，因此它是从业务无侵入的两阶段提交（全局事务）着手，在传统的两阶段上进行改进，他把一个分布式事务理解成一个包含了若干分支事务的全局事务。而全局事务的职责是协调它管理的分支事务达成一致性，要么一起成功提交，要么一起失败回滚。也就是一荣俱荣一损俱损~&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5545286506469501&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWcP0zQGiaUvTrZEyBtkUL4MCStkr8lx7ALaVmhVcKuCene0WRiaZ4I9p39z6Fa48y5U8z8gOMXzZFgw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1082&quot;/&gt;&lt;figcaption&gt;全局事务和分支事务&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;Seata&lt;/strong&gt; 中存在这么几种重要角色：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;TC（Transaction Coordinator）&lt;/strong&gt;：事务协调者。管理全局的分支事务的状态，用于全局性事务的提交和回滚。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;TM（Transaction Manager）&lt;/strong&gt;：事务管理者。用于开启、提交或回滚事务。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;RM（Resource Manager）&lt;/strong&gt;：资源管理器。用于分支事务上的资源管理，向 &lt;strong&gt;TC&lt;/strong&gt; 注册分支事务，上报分支事务的状态，接收 &lt;strong&gt;TC&lt;/strong&gt; 的命令来提交或者回滚分支事务。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.9057187017001546&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWcP0zQGiaUvTrZEyBtkUL4MCK9IOBB6kGgV9gwwlWabcf6EAuEHy6ZNlp4MXTjcH2uN6PkOYFyTVlQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1294&quot;/&gt;&lt;figcaption&gt;Seata工作流程&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;S&#x27;eata整体执行流程：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;服务A中的 &lt;strong&gt;TM&lt;/strong&gt; 向 &lt;strong&gt;TC&lt;/strong&gt; 申请开启一个全局事务，&lt;strong&gt;TC&lt;/strong&gt; 就会创建一个全局事务并返回一个唯一的 &lt;strong&gt;XID&lt;/strong&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;服务A中的 &lt;strong&gt;RM&lt;/strong&gt; 向 &lt;strong&gt;TC&lt;/strong&gt; 注册分支事务，然后将这个分支事务纳入 &lt;strong&gt;XID&lt;/strong&gt; 对应的全局事务管辖中&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;服务A开始执行分支事务&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;服务A开始远程调用B服务，此时 &lt;strong&gt;XID&lt;/strong&gt; 会根据调用链传播&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;服务B中的 &lt;strong&gt;RM&lt;/strong&gt; 也向 &lt;strong&gt;TC&lt;/strong&gt; 注册分支事务，然后将这个分支事务纳入 &lt;strong&gt;XID&lt;/strong&gt; 对应的全局事务管辖中&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;服务B开始执行分支事务&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;全局事务调用处理结束后，&lt;strong&gt;TM&lt;/strong&gt; 会根据有误异常情况，向 &lt;strong&gt;TC&lt;/strong&gt; 发起全局事务的提交或回滚&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;TC&lt;/strong&gt; 协调其管辖之下的所有分支事务，决定是提交还是回滚&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;分布式一致性算法&lt;/span&gt;&lt;/h1&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;9.分布式算法paxos了解么 ？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;Paxos&lt;/code&gt; 有点类似前面说的 &lt;code&gt;2PC&lt;/code&gt;，&lt;code&gt;3PC&lt;/code&gt;，但比这两种算法更加完善。在很多多大厂都得到了工程实践，比如阿里的 &lt;code&gt;OceanBase&lt;/code&gt; 的 &lt;strong&gt;分布式数据库&lt;/strong&gt;， &lt;code&gt;Google&lt;/code&gt; 的 &lt;code&gt;chubby&lt;/code&gt; &lt;strong&gt;分布式锁&lt;/strong&gt; 。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;Paxos算法是什么？&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;Paxos&lt;/code&gt; 算法是 &lt;strong&gt;基于消息传递&lt;/strong&gt; 且具有 &lt;strong&gt;高效容错特性&lt;/strong&gt; 的一致性算法，目前公认的解决 &lt;strong&gt;分布式一致性问题&lt;/strong&gt; 最有效的算法之一。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;Paxos算法的工作流程？&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;角色&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在Paxos中有这么几个角色：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;Proposer（提议者）&lt;/strong&gt; : 提议者提出提案，用于投票表决。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;Accecptor（接受者）&lt;/strong&gt; : 对提案进行投票，并接受达成共识的提案。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;Learner（学习者）&lt;/strong&gt; : 被告知投票的结果，接受达成共识的提案。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在实际中，一个节点可以同时充当不同角色。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.7800925925925926&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWcP0zQGiaUvTrZEyBtkUL4MCINLhLsU3n0BwlHYRlKMC3UlWrtaJls9Vwibv7gbta5hR1Y1Hgw4WXEA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;864&quot;/&gt;&lt;figcaption&gt;Paxos的三种角色&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;提议者提出提案，提案=编号+value，可以表示为[M,V]，每个提案都有唯一编号，而且编号的大小是趋势递增的。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;算法流程&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Paxos算法包含两个阶段，第一阶段**Prepare(准备)&lt;strong&gt;、第二阶段&lt;/strong&gt;Accept(接受)**。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5741687979539642&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWcP0zQGiaUvTrZEyBtkUL4MCCmIxuMtW7xfXdQ0GkOLKSyAcU2NlJj469fSYHAnhrCKREFQficprrvA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1564&quot;/&gt;&lt;figcaption&gt;Paxos算法流程&lt;/figcaption&gt;&lt;/figure&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;Prepare(准备)阶段&lt;span/&gt;&lt;/h5&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;提议者提议一个新的提案 P[Mn,?]，然后向接受者的某个超过半数的子集成员发送编号为Mn的准备请求&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;如果一个接受者收到一个编号为Mn的准备请求，并且编号Mn大于它已经响应的所有准备请求的编号，那么它就会将它已经批准过的最大编号的提案作为响应反馈给提议者，同时该接受者会承诺不会再批准任何编号小于Mn的提案。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;总结一下，接受者在收到提案后，会给与提议者&lt;strong&gt;两个承诺&lt;/strong&gt;与&lt;strong&gt;一个应答&lt;/strong&gt;：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;两个承诺：&lt;/section&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;承诺不会再接受提案号小于或等于 Mn 的 Prepare 请求&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;承诺不会再接受提案号小于Mn 的 Accept 请求&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;li&gt;&lt;section&gt;一个应答：&lt;/section&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;不违背以前作出的承诺的前提下，回复已经通过的提案中提案号最大的那个提案所设定的值和提案号Mmax，如果这个值从来没有被任何提案设定过，则返回空值。如果不满足已经做出的承诺，即收到的提案号并不是决策节点收到过的最大的，那允许直接对此 Prepare 请求不予理会。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/ul&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;Accept(接受)阶段&lt;span/&gt;&lt;/h5&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;如果提议者收到来自半数以上的接受者对于它发出的编号为Mn的准备请求的响应，那么它就会发送一个针对[Mn,Vn]的接受请求给接受者，注意Vn的值就是收到的响应中编号最大的提案的值，如果响应中不包含任何提案，那么它可以随意选定一个值。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;如果接受者收到这个针对[Mn,Vn]提案的接受请求，只要该接受者尚未对编号大于Mn的准备请求做出响应，它就可以通过这个提案。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当提议者收到了多数接受者的接受应答后，协商结束，共识决议形成，将形成的决议发送给所有学习节点进行学习。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以Paxos算法的整体详细流程如下：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.7406914893617021&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWcP0zQGiaUvTrZEyBtkUL4MCnuGcR8nVJDQffhFoW0icUg2NxkmYXia0sHuLicEhicPD37HEibP75Mhx6tA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1504&quot;/&gt;&lt;figcaption&gt;Paxos详细流程&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;算法的流程模拟，可以查看参考[13]。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;Paxos算法有什么缺点吗？怎么优化？&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;前面描述的可以称之为Basic Paxos 算法，在单提议者的前提下是没有问题的，但是假如有多个提议者互不相让，那么就可能导致整个提议的过程进入了死循环。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Lamport 提出了 Multi Paxos 的算法思想。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Multi Paxos算法思想，简单说就是在多个提议者的情况下，选出一个Leader（领导者），由领导者作为唯一的提议者，这样就可以解决提议者冲突的问题。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;10.说说Raft算法？&lt;/span&gt;&lt;/h2&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;Raft算法是什么？&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;Raft&lt;/code&gt; 也是一个 &lt;strong&gt;一致性算法&lt;/strong&gt;，和 &lt;code&gt;Paxos&lt;/code&gt; 目标相同。但它还有另一个名字 - &lt;strong&gt;易于理解的一致性算法&lt;/strong&gt;。&lt;code&gt;Paxos&lt;/code&gt; 和 &lt;code&gt;Raft&lt;/code&gt; 都是为了实现 &lt;strong&gt;一致性&lt;/strong&gt; 产生的。这个过程如同选举一样，&lt;strong&gt;参选者&lt;/strong&gt; 需要说服 &lt;strong&gt;大多数选民&lt;/strong&gt; (Server) 投票给他，一旦选定后就跟随其操作。&lt;code&gt;Paxos&lt;/code&gt; 和 &lt;code&gt;Raft&lt;/code&gt; 的区别在于选举的 &lt;strong&gt;具体过程&lt;/strong&gt; 不同。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;Raft算法的工作流程？&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;Raft算法的角色&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;Raft&lt;/code&gt; 协议将 &lt;code&gt;Server&lt;/code&gt; 进程分为三种角色：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;Leader（领导者）&lt;/strong&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;Follower（跟随者）&lt;/strong&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;Candidate（候选人）&lt;/strong&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;就像一个民主社会，领导者由跟随者投票选出。刚开始没有 &lt;strong&gt;领导者&lt;/strong&gt;，所有集群中的 &lt;strong&gt;参与者&lt;/strong&gt; 都是 &lt;strong&gt;跟随者&lt;/strong&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那么首先开启一轮大选。在大选期间 &lt;strong&gt;所有跟随者&lt;/strong&gt; 都能参与竞选，这时所有跟随者的角色就变成了 &lt;strong&gt;候选人&lt;/strong&gt;，民主投票选出领袖后就开始了这届领袖的任期，然后选举结束，所有除 &lt;strong&gt;领导者&lt;/strong&gt; 的 &lt;strong&gt;候选人&lt;/strong&gt; 又变回 &lt;strong&gt;跟随者&lt;/strong&gt; 服从领导者领导。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里提到一个概念 &lt;strong&gt;「任期」&lt;/strong&gt;，用术语 &lt;code&gt;Term&lt;/code&gt; 表达。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;三类角色的变迁图如下：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.4234527687296417&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWcP0zQGiaUvTrZEyBtkUL4MCmoPDbguBaRHyhCZhmCeX38FxMUd0Qtd69viapR6SjZ99AMLmZ3chbdg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1228&quot;/&gt;&lt;figcaption&gt;Raft三种角色变迁图&lt;/figcaption&gt;&lt;/figure&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;Leader选举过程&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Raft 使用心跳（heartbeat）触发Leader选举。当Server启动时，初始化为Follower。Leader向所有Followers周期性发送heartbeat。如果Follower在选举超时时间内没有收到Leader的heartbeat，就会等待一段随机的时间后发起一次Leader选举。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Follower将其当前term加一然后转换为Candidate。它首先给自己投票并且给集群中的其他服务器发送 RequestVote RPC 。结果有以下三种情况：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;赢得了多数（超过1/2）的选票，成功选举为Leader；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;收到了Leader的消息，表示有其它服务器已经抢先当选了Leader；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;没有Server赢得多数的选票，Leader选举失败，等待选举时间超时（&lt;code&gt;Election Timeout&lt;/code&gt;）后发起下一次选举。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.8346333853354134&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWcP0zQGiaUvTrZEyBtkUL4MC53m1S1v9v7OQMNDuLZjFgkOCkThu2GK7cOYmsbTgjeY0w10Kux3RZQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1282&quot;/&gt;&lt;figcaption&gt;Leader选举&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;选出 &lt;code&gt;Leader&lt;/code&gt; 后，&lt;code&gt;Leader&lt;/code&gt; 通过 &lt;strong&gt;定期&lt;/strong&gt; 向所有 &lt;code&gt;Follower&lt;/code&gt; 发送 &lt;strong&gt;心跳信息&lt;/strong&gt; 维持其统治。若 &lt;code&gt;Follower&lt;/code&gt; 一段时间未收到 &lt;code&gt;Leader&lt;/code&gt; 的 &lt;strong&gt;心跳&lt;/strong&gt;，则认为 &lt;code&gt;Leader&lt;/code&gt; 可能已经挂了，然后再次发起 &lt;strong&gt;选举&lt;/strong&gt; 过程。&lt;/p&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;分布式设计&lt;/span&gt;&lt;/h1&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;11.说说什么是幂等性？&lt;/span&gt;&lt;/h2&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;什么是幂等性？&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;幂等性是一个数学概念，用在接口上：用在接口上就可以理解为：&lt;strong&gt;同一个接口，多次发出同一个请求，请求的结果是一致的。&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;简单说，就是多次调用如一次。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;什么是幂等性问题？&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在系统的运行中，可能会出现这样的问题：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;用户在填写某些&lt;code&gt;form表单&lt;/code&gt;时，保存按钮不小心快速点了两次，表中竟然产生了两条重复的数据，只是id不一样。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;开发人员在项目中为了解决&lt;code&gt;接口超时&lt;/code&gt;问题，通常会引入了&lt;code&gt;重试机制&lt;/code&gt;。第一次请求接口超时了，请求方没能及时获取返回结果（此时有可能已经成功了），于是会对该请求重试几次，这样也会产生重复的数据。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;mq消费者在读取消息时，有时候会读取到&lt;code&gt;重复消息&lt;/code&gt;，也会产生重复的数据。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这些都是常见的幂等性问题。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在分布式系统里，只要下游服务有写（保存、更新）的操作，都有可能会产生幂等性问题。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;PS:幂等和防重有些不同，防重强调的防止数据重复，幂等强调的是多次调用如一次，防重包含幂等。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;怎么保证接口幂等性？&lt;/span&gt;&lt;/h2&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.3338557993730408&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWcP0zQGiaUvTrZEyBtkUL4MC37tGRA4fGNibDiaSIZ8Ozj9b5ng2yaDRSkonSd389kkcYppsm7kDamTg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1276&quot;/&gt;&lt;figcaption&gt;接口幂等性&lt;/figcaption&gt;&lt;/figure&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;insert前先select&lt;/p&gt;&lt;p&gt;在保存数据的接口中，在&lt;code&gt;insert&lt;/code&gt;前，先根据&lt;code&gt;requestId&lt;/code&gt;等字段先&lt;code&gt;select&lt;/code&gt;一下数据。如果该数据已存在，则直接返回，如果不存在，才执行  &lt;code&gt;insert&lt;/code&gt;操作。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;加唯一索引&lt;/p&gt;&lt;p&gt;加唯一索引是个非常简单但很有效的办法，如果重复插入数据的话，就会抛出异常，为了保证幂等性，一般需要捕获这个异常。&lt;/p&gt;&lt;p&gt;如果是&lt;code&gt;java&lt;/code&gt;程序需要捕获：&lt;code&gt;DuplicateKeyException&lt;/code&gt;异常，如果使用了&lt;code&gt;spring&lt;/code&gt;框架还需要捕获：&lt;code&gt;MySQLIntegrityConstraintViolationException&lt;/code&gt;异常。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;加悲观锁&lt;/p&gt;&lt;p&gt;更新逻辑，比如更新用户账户余额，可以加悲观锁，把对应用户的哪一行数据锁住。同一时刻只允许一个请求获得锁，其他请求则等待。&lt;/p&gt;&lt;pre&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;select&lt;/span&gt; * &lt;span&gt;from&lt;/span&gt; &lt;span&gt;user&lt;/span&gt; &lt;span&gt;id&lt;/span&gt;=&lt;span&gt;123&lt;/span&gt; &lt;span&gt;for&lt;/span&gt; &lt;span&gt;update&lt;/span&gt;;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这种方式有一个缺点，获取不到锁的请求一般只能报失败，比较难保证接口返回相同值。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;加乐观锁&lt;/p&gt;&lt;p&gt;更新逻辑，也可以用乐观锁，性能更好。可以在表中增加一个&lt;code&gt;timestamp&lt;/code&gt;或者&lt;code&gt;version&lt;/code&gt;字段，例如&lt;code&gt;version&lt;/code&gt;:&lt;/p&gt;&lt;p&gt;在更新前，先查询一下数据，将version也作为更新的条件，同时也更新version：&lt;/p&gt;&lt;pre&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;update&lt;/span&gt; &lt;span&gt;user&lt;/span&gt; &lt;span&gt;set&lt;/span&gt; amount=amount+&lt;span&gt;100&lt;/span&gt;,&lt;span&gt;version&lt;/span&gt;=&lt;span&gt;version&lt;/span&gt;+&lt;span&gt;1&lt;/span&gt; &lt;span&gt;where&lt;/span&gt; &lt;span&gt;id&lt;/span&gt;=&lt;span&gt;123&lt;/span&gt; &lt;span&gt;and&lt;/span&gt; &lt;span&gt;version&lt;/span&gt;=&lt;span&gt;1&lt;/span&gt;;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;更新成功后，version增加，重复更新请求进来就无法更新了。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;建防重表&lt;/p&gt;&lt;p&gt;有时候表中并非所有的场景都不允许产生重复的数据，只有某些特定场景才不允许。这时候，就可以使用防重表的方式。&lt;/p&gt;&lt;p&gt;例如消息消费中，创建防重表，存储消息的唯一ID，消费时先去查询是否已经消费，已经消费直接返回成功。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;状态机&lt;/p&gt;&lt;p&gt;有些业务表是有状态的，比如订单表中有：1-下单、2-已支付、3-完成、4-撤销等状态，可以通过限制状态的流动来完成幂等。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;分布式锁&lt;/p&gt;&lt;p&gt;直接在数据库上加锁的做法性能不够友好，可以使用分布式锁的方式，目前最流行的分布式锁实现是通过Redis，具体实现一般都是使用Redission框架。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;token机制&lt;/p&gt;&lt;p&gt;请求接口之前，需要先获取一个唯一的token，再带着这个token去完成业务操作，服务端根据这个token是否存在，来判断是否是重复的请求。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;分布式限流&lt;/span&gt;&lt;/h1&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;12.你了解哪些限流算法？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;计数器比较简单粗暴，比如我们要限制1s能够通过的请求数，实现的思路就是从第一个请求进来开始计时，在接下来的1s内，每个请求进来请求数就+1，超过最大请求数的请求会被拒绝，等到1s结束后计数清零，重新开始计数。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这种方式有个很大的弊端：比如前10ms已经通过了最大的请求数，那么后面的990ms的请求只能拒绝，这种现象叫做“突刺现象”。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;就是桶底出水的速度恒定，进水的速度可能快慢不一，但是当进水量大于出水量的时候，水会被装在桶里，不会直接被丢弃；但是桶也是有容量限制的，当桶装满水后溢出的部分还是会被丢弃的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;算法实现&lt;/strong&gt;：可以准备一个队列来保存暂时处理不了的请求，然后通过一个线程池定期从队列中获取请求来执行。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1.015695067264574&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWcP0zQGiaUvTrZEyBtkUL4MCR0L7zzzIv7CCCwDJ2hqb4O8pKXe6Poqe6mSE9kcE1koXgnxWYmicd2w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;892&quot;/&gt;&lt;figcaption&gt;漏桶算法&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;令牌桶就是生产访问令牌的一个地方，生产的速度恒定，用户访问的时候当桶中有令牌时就可以访问，否则将触发限流。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;实现方案&lt;/strong&gt;：Guava RateLimiter限流&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Guava RateLimiter是一个谷歌提供的限流，其基于令牌桶算法，比较适用于单实例的系统。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.971830985915493&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWcP0zQGiaUvTrZEyBtkUL4MCGKIOJr3OlZLffQvVic6lgNqAgT50RxKCeHJWVNvnWR7aLV2trA5JHjQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;852&quot;/&gt;&lt;figcaption&gt;令牌桶算法&lt;/figcaption&gt;&lt;/figure&gt;&lt;hr data-tool=&quot;mdnice编辑器&quot;/&gt;&lt;p&gt;这一期的分布式面试题就整理到这里了，主要是偏理论的一些问题，分布式其实是个很大的类型，比如分布式调用、分布式治理……&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以，这篇文章只是个开始，后面还会有分布式调用（RPC）、微服务相关的主题文章，敬请期待。&lt;/p&gt;&lt;p&gt;&lt;br data-tool=&quot;mdnice编辑器&quot;/&gt;&lt;/p&gt;&lt;hr data-tool=&quot;mdnice编辑器&quot;/&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;参考：&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;[1] . 《从Paxos到Zookeeper 分布式一致性原理与实践》&lt;br/&gt;[2]. 分布式理论(一) - CAP定理：https://juejin.cn/post/6844903621490901006&lt;br/&gt;[3]. 分布式理论(二) - BASE理论 ：https://juejin.cn/post/6844903621495095304&lt;br/&gt;[4]. 分布式理论(三) - 2PC协议：https://juejin.cn/post/6844903621495095309&lt;br/&gt;[5] . CAP和BASE理论了解么？可以结合实际案例说下不：https://juejin.cn/post/6898288789371027470&lt;br/&gt;[6] 从分布式事务解决到Seata使用，一梭子给你整明白了：https://juejin.cn/post/6944882663148748807&lt;br/&gt;[7]. 高并发下如何保证接口的幂等性?：https://juejin.cn/post/6944559294939398158)&lt;br/&gt;[8]. 分布式理论(三) - 2PC协议 ：https://juejin.cn/post/6844903621495095309&lt;br/&gt;[9]. 再有人问你分布式锁，这篇文章扔给他：https://juejin.cn/post/6844903688088059912)&lt;br/&gt;[10]. 分布式理论(五) - 一致性算法Paxos ：https://juejin.cn/post/6844903621499289613)&lt;br/&gt;[11]. 《分布式系统技术及其案例分析》&lt;br/&gt;[12].不就是分布式事务，这下彻底清楚了😎：https://juejin.cn/post/7008939082579443748)&lt;br/&gt;[13].诸葛亮 VS 庞统，拿下 Paxos 共识算法：http://www.passjava.cn/#/03.Distributed/05.诸葛VS庞统，拿下Paxos?id=诸葛亮-vs-庞统，拿下-paxos-共识算法&lt;br/&gt;[14].http://icyfenix.cn/distribution/consensus/paxos.html&lt;/span&gt;&lt;/p&gt;&lt;hr data-tool=&quot;mdnice编辑器&quot;/&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;figcaption&gt;&lt;br/&gt;&lt;/figcaption&gt;&lt;pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;最近苏三的知识星球&lt;span&gt;【&lt;/span&gt;&lt;strong&gt;Java突击队&lt;/strong&gt;&lt;span&gt;】&lt;/span&gt;，每天都会更新很多干货内容。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;很多独家的干货内容，比如：Java后端学习路线，分享实战项目，源码分析，百万级系统设计，系统上线的一些坑，MQ专题，真实面试题，每天都会回答大家提出的问题。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这几天星球开通了3个优质专栏：痛点问题、高频面试题 和 性能优化。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;每一个专栏都是大家非常关心，和非常有价值的话题，我相信在专栏中你会学到很多东西，值回票价。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;券后只需&lt;span&gt;84&lt;/span&gt;元，随着干货内容越来越多，而且&lt;span&gt;苏三的&lt;/span&gt;demo项目上线了，价值越来越大。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;1.215625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ibJZVicC7nz5g5ep6NvvuxWia1grH3iaiccuMSFKTTQicVWicDLwN21Bb7ibL00MYAFXzZCrMs1fibkS6H3f0kEdjyrSNCA/640?wx_fmt=png&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; data-type=&quot;png&quot; data-w=&quot;640&quot;/&gt;&lt;/p&gt;&lt;p&gt;过几天还会涨价，目前这批优惠券还剩15张了，要上车&lt;/p&gt;&lt;p&gt;的小伙伴抓紧时间。&lt;/p&gt;&lt;/pre&gt;&lt;figcaption&gt;&lt;br/&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;&lt;mp-style-type data-value=&quot;3&quot;/&gt;&lt;/p&gt;&lt;/div&gt;

          
        &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>14c3e60f05c331b25ab77bd792ce9136</guid>
<title>凹语言版本 yacc 简介：以表达式解析为例</title>
<link>https://toutiao.io/k/d2kyge9</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;main data-v-87eea512=&quot;&quot;&gt;&lt;p&gt;yacc 是用于生成语法解析器的程序，是编译器爱好者的工具。凹语言的 yacc 从 goyacc 移植而来，目前可以初步支持输出 凹语言 版本解析器代码。本文以以表达式解析为例展示下用法。&lt;/p&gt;&lt;p&gt;完整的例子可以参考（这里使用的是&lt;code&gt;expr&lt;/code&gt;前缀）：https://gitee.com/wa-lang/wa/blob/master/_examples/expr/expr.y。&lt;/p&gt;&lt;p&gt;如果对 yacc 不太了解可以先参考以下图书：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1.5&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/QAncwTWS4GrRbSqDnPoPxxwALaKD24MZPC3QzN7170qbraKpSAdKwKYYDMoK6v1HE1JSxljCmth0SV59Gmia2CQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;474&quot;/&gt;&lt;/p&gt;&lt;h2 tabindex=&quot;-1&quot;&gt;1. yacc 文件结构简介&lt;/h2&gt;&lt;p&gt;yacc 文件一般以 &lt;code&gt;*.y&lt;/code&gt; 格式命名，其格式如下：&lt;/p&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;// *.y 文件本身的注释&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;%{&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;// 生成解析器代码的头部，一般是 import 等语句&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;%}&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;// yacc 语法对应的词法类似、语法树节点等&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;%%&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;// BNF 语法定义&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;%%&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;// 生成解析器代码的尾部&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;简单来说，y 文件由两个 &lt;code&gt;%%&lt;/code&gt; 行分隔为三个部分（类似文章的凤头、猪肚、豹尾）：&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;凤头：对应生成的解析器的头部，其中&lt;code&gt;%{ ... %}&lt;/code&gt; 包含的部分为原样输出，其他部分是 yacc 语法定义的词法类型和语法树节点等&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;猪肚：是 yacc 文件等核心，通过 BNF 语法定义了语法结构，这里主要是针对 &lt;code&gt;LALR(1)&lt;/code&gt; 语法&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;豹尾：如果是独立的程序，可以在这个部分引入词法解析器和 main 函数；如果是 package 则是可以省略的&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 tabindex=&quot;-1&quot;&gt;2. 定义&lt;code&gt;expr.y&lt;/code&gt;文件 - 凤头部分&lt;/h2&gt;&lt;p&gt;创建表达式语法文件如下：&lt;/p&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;// 版权 @2023 凹语言 作者。保留所有权利。&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;%{&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;// 这是 凹语言 yacc 的例子, 用于对表达式进行解析, 为了简化词法部分暂时通过手工录入.&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;%}&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;%union {&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;num :int&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;}&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;%type  &amp;lt;num&amp;gt; expr expr1 expr2 expr3&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;%token &#x27;+&#x27; &#x27;-&#x27; &#x27;*&#x27; &#x27;/&#x27; &#x27;(&#x27; &#x27;)&#x27;&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;%token &amp;lt;num&amp;gt; NUM&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;%%&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;其中&lt;code&gt;%union&lt;/code&gt;定义了词法和语法解析器对接的结构体类型。&lt;code&gt;%type&lt;/code&gt;语句定义了&lt;code&gt;expr expr1 expr2 expr3&lt;/code&gt;几种语法节点，都是对应&lt;code&gt;&amp;lt;num&amp;gt;&lt;/code&gt;类型值，而数字的值需要填充到&lt;code&gt;%union&lt;/code&gt;定义的&lt;code&gt;num&lt;/code&gt;属性部分。&lt;code&gt;%token&lt;/code&gt;语句定义的运算符和&lt;code&gt;NUM&lt;/code&gt;类型的数字。&lt;/p&gt;&lt;h2 tabindex=&quot;-1&quot;&gt;3. 定义&lt;code&gt;expr.y&lt;/code&gt;文件 - 猪肚部分&lt;/h2&gt;&lt;p&gt;猪肚部分对应表达式的语法结构：&lt;/p&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;%%&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;top:&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;expr { println($1) }&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;expr:&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;expr1&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;| &#x27;+&#x27; expr { $$ = $2 }&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;| &#x27;-&#x27; expr { $$ = -$2 }&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;expr1:&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;expr2&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;| expr1 &#x27;+&#x27; expr2 { $$ = $1 + $3 }&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;| expr1 &#x27;-&#x27; expr2 { $$ = $1 - $3 }&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;expr2:&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;expr3&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;| expr2 &#x27;*&#x27; expr3 { $$ = $1 * $3 }&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;| expr2 &#x27;/&#x27; expr3 { $$ = $1 / $3 }&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;expr3:&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;NUM&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;| &#x27;(&#x27; expr &#x27;)&#x27; { $$ = $2 }&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;%%&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;当遇到&lt;code&gt;expr&lt;/code&gt;语法规则是直接输出结果，&lt;code&gt;expr1&lt;/code&gt;表示加减法、&lt;code&gt;expr2&lt;/code&gt;表示乘除法、&lt;code&gt;expr3&lt;/code&gt;表示数字或小括弧。在每个最终后面的&lt;code&gt;{}&lt;/code&gt;中包含的是动作代码，它们根据不同的语法规则选择不同的计算方式得到结果，结果赋值给&lt;code&gt;$$&lt;/code&gt;（也就是对应&lt;code&gt;%type &amp;lt;num&amp;gt; expr expr1 expr2 expr3&lt;/code&gt;语句中的&lt;code&gt;&amp;lt;num&amp;gt;&lt;/code&gt;部分类型，也对应&lt;code&gt;%union&lt;/code&gt;定义的&lt;code&gt;num&lt;/code&gt;成员）。&lt;/p&gt;&lt;h2 tabindex=&quot;-1&quot;&gt;4. 定义&lt;code&gt;expr.y&lt;/code&gt;文件 - 豹尾部分 - 01&lt;/h2&gt;&lt;p&gt;有了凤头和猪肚部分，yacc就可以生成必要的解析器代码了。默认后生成以下格式的解析器函数&lt;code&gt;yyParse&lt;/code&gt;：&lt;/p&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;func yyParse(yylex: *yyLexer) =&amp;gt; int {&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;return yyNewParser().Parse(yylex)&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;}&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;而&lt;code&gt;yyLexer&lt;/code&gt;词法解析器则是用户需要自行实现的（词法解析实现相对简单），主要包含以下2个方法：&lt;/p&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;type yyLexer struct {}&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func yyLexer.Lex(yylval *yySymType) =&amp;gt; int {&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;// 返回 Token 类型, 并且将对应的值填充到 yylval 相应的属性中&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;}&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func yyLexer.Error(s string) {&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;// 遇到错误&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;}&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;code&gt;yyLexer.Lex&lt;/code&gt; 返回 Token 类型，并且将对应的值填充到 &lt;code&gt;yylval&lt;/code&gt; 相应的属性中，遇到文件结尾时返回&lt;code&gt;0&lt;/code&gt;表示文件结束。方法参数对应的&lt;code&gt;yySymType&lt;/code&gt;类型由yacc工具生成，对应如下的代码：&lt;/p&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;type yySymType struct {&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;yys :int&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;num :int&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;}&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;其中&lt;code&gt;num&lt;/code&gt;对应对应&lt;code&gt;%union&lt;/code&gt;定义的属性，也就是数字的值。&lt;/p&gt;&lt;h2 tabindex=&quot;-1&quot;&gt;5. 定义&lt;code&gt;expr.y&lt;/code&gt;文件 - 豹尾部分 - 02&lt;/h2&gt;&lt;p&gt;为了简化演示代码，我们先手工构造词法序列，然后通过&lt;code&gt;yyLexer.Lex&lt;/code&gt; 返回。&lt;/p&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;// Lex 结束标志&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;const eof = 0&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;type yyToken struct {&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;Kind  :int&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;Value :int&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;}&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;type yyLexer struct {&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;tokens :[]yyToken&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;pos    :int &lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;}&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func yyLexer.Lex(yylval *yySymType) =&amp;gt; int {&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;if this.pos &amp;gt;= len(this.tokens) {&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;return eof&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;}&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;tok := this.tokens[this.pos]&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;this.pos++&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;yylval.num = tok.Value&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;return tok.Kind&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;}&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func yyLexer.Error(s string) {&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;println(&quot;ERROR:&quot;, s)&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;}&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;首先定义&lt;code&gt;yyToken&lt;/code&gt;，对应token的类型和值信息。然后&lt;code&gt;yyLexer&lt;/code&gt;定义全部的token列表和当前的pos信息。&lt;code&gt;yyLexer.Lex&lt;/code&gt;方法每次从&lt;code&gt;this.tokens&lt;/code&gt;列表对应的&lt;code&gt;this.pos&lt;/code&gt;位置返回一个token，如果是结束则返回&lt;code&gt;eof&lt;/code&gt;。&lt;/p&gt;&lt;p&gt;然后就可以构造main函数启动了：&lt;/p&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;func main {&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;print(&quot;1+2*3 = &quot;)&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;yyParse(&amp;amp;yyLexer{&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;tokens: []exprToken{&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;{Kind: NUM, Value: 1},&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;{Kind: &#x27;+&#x27;},&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;{Kind: NUM, Value: 2},&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;{Kind: &#x27;*&#x27;},&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;{Kind: NUM, Value: 3},&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;},&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;})&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;}&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 tabindex=&quot;-1&quot;&gt;6. 生成解析器代码&lt;/h2&gt;&lt;p&gt;在生成解析器代码前再准备一个&lt;code&gt;copyright.txt&lt;/code&gt;文件，比如“保留所有权利”或者“自由使用”之类的。然后通过以下命令生成解析器代码：&lt;/p&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;$ wa yacc -l -p=yy -c=&quot;copyright.txt&quot; -o=&quot;y.wa&quot; expr.y&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;其中&lt;code&gt;-l&lt;/code&gt;表示生成的代码禁止映射到&lt;code&gt;*.y&lt;/code&gt;文件行列号（用生成代码的位置），&lt;code&gt;-p=yy&lt;/code&gt;表示生成的解析器函数和类型等用&lt;code&gt;yy&lt;/code&gt;前缀（这也是默认值），&lt;code&gt;-c=&quot;copyright.txt&quot;&lt;/code&gt;为生成代码指定版权信息，&lt;code&gt;-o=&quot;y.wa&quot;&lt;/code&gt;指定输出文件，最后的&lt;code&gt;expr.y&lt;/code&gt;对熟人的yacc规则文件。&lt;/p&gt;&lt;p&gt;生成代码成功之后可以执行：&lt;/p&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;$ wa y.wa&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;1+2*3 = 7&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 tabindex=&quot;-1&quot;&gt;7. 下一步&lt;/h2&gt;&lt;p&gt;目前的凹语言版 yacc 工具还是Go语言实现的，只是输出的解析器是凹语言代码。我们希望下一步可以将 yacc 工具本身移植到凹语言实现，最终可以通过 wasm 模块执行。&lt;/p&gt;&lt;/main&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>a3b71db8c0fb5294deac5121cc2f73e2</guid>
<title>设计模式 - 谈谈我对设计原则的理解</title>
<link>https://toutiao.io/k/jeqhj0d</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;设计原则是什么&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;KISS/YAGNI&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;SOLID&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;DRY&lt;/p&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;代码逻辑重复&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;代码语义重复&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;代码执行重复&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;Rule of Three&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;li&gt;&lt;p&gt;LoD&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;结语&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;设计原则是什么&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;不知道各位程序员在写代码的时候有没有这样的困惑：在自己编写一些简单的 Demo 或者是小型玩具程序时总是得心应手，很快就能完成自己既定的目标。可是一旦需要参与一个较大项目的开发，或者是慢慢将这个玩具程序扩展成功能更加丰富的项目时，就会力不从心。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;出现上述问题的一种可能原因是，没有很好地将设计原则理解透彻。对于自己编写的代码比较随意，想到哪儿写到哪儿。一旦项目需要扩展，或者接手一个复杂项目，就茫然无措。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;设计原则是一些&lt;span&gt;设计经验&lt;/span&gt;的总结，它的定义看起来比较宽泛和模糊。而且每个人对于同一个设计原则的理解也可能大相径庭。但其实我们抽丝剥茧，将设计原则作为自己修炼代码的&lt;span&gt;心法&lt;/span&gt;，在项目中灵活运用，或者是对已有的项目带着问题去思考，定将事半功倍。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;下面将会从我认为的优先级，介绍设计原则的具体内容。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;KISS/YAGNI&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;KISS（Keep It Simple and Stupid）&lt;/span&gt;原则，这个原则说的是，我们应该用尽量简单的代码实现功能。举一个简单的例子，如何在&lt;em&gt;代码比赛&lt;/em&gt;中用&lt;em&gt;最快&lt;/em&gt;的方式打印交换后的两个整型变量的值。对于这个问题最直观的方式是用一个临时变量作跳板，交换两个变量。进阶一点可能会想到用异或的方式交换两个变量。但这都不是最快的：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;int&lt;/span&gt; a = &lt;span&gt;5&lt;/span&gt;, b = &lt;span&gt;4&lt;/span&gt;;&lt;br/&gt;&lt;span&gt;// 1 临时变量&lt;/span&gt;&lt;br/&gt;&lt;span&gt;int&lt;/span&gt; temp = a; a = b; b = temp;&lt;br/&gt;&lt;span&gt;// 2 异或&lt;/span&gt;&lt;br/&gt;a ^= b ^= a ^= b;&lt;br/&gt;&lt;span&gt;// 3 最快&lt;/span&gt;&lt;br/&gt;&lt;span&gt;cout&lt;/span&gt; &amp;lt;&amp;lt; &lt;span&gt;&quot;a = &quot;&lt;/span&gt; &amp;lt;&amp;lt; b &amp;lt;&amp;lt; &lt;span&gt;&quot;, b = &quot;&lt;/span&gt; &amp;lt;&amp;lt; a &amp;lt;&amp;lt; &lt;span&gt;endl&lt;/span&gt;;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;注意到这个背景是在&lt;em&gt;代码比赛&lt;/em&gt;中，所以我们采取&lt;span&gt;方法 3&lt;/span&gt;能够最快打印出值，我们只需要这个&lt;span&gt;值&lt;/span&gt;。但如果在工程实践中，为了保持代码良好的可读性，我们应该采取&lt;span&gt;方法 1&lt;/span&gt;。&lt;span&gt;方法 2&lt;/span&gt;不仅复杂而且难懂，是一个 KISS 原则的反例，需要在工程实践中尽量避免。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;遵循 KISS 原则能够使得我们的代码保持&lt;em&gt;可读性&lt;/em&gt;和&lt;em&gt;可维护性&lt;/em&gt;。另外这里补充一个&lt;span&gt;YAGNI（You Ain&#x27;t Gonna Need It）&lt;/span&gt;原则，它和描述&lt;em&gt;怎么做&lt;/em&gt;的 KISS 原则不同，主要说的是&lt;em&gt;要不要做&lt;/em&gt;。它的核心思想是&lt;em&gt;不要多做&lt;/em&gt;。有一个段子是说，如果你在网上发帖问需不需要购买苹果 Mac 系列笔记本，那就说明你不需要。其实也就是不要把问题复杂化，专注于当前的业务功能，这样能够提高我们的工作效率。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;SOLID&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里的 SOLID 实际指的是 5&lt;em&gt; &lt;/em&gt;个原则的首字母缩写。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;SRP&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;单一职责（Single Responsibility Principle，SRP）&lt;/span&gt;原则，指的是一个类或者一个方法应该只完成一项职责。比如有一个场景，我们需要修改用户信息。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;enum&lt;/span&gt; OperationType {&lt;br/&gt;    UPDATE_USER_NAME;&lt;br/&gt;    UPDATE_USER_PASSWORD;&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;public &lt;/span&gt;&lt;span&gt;&lt;span&gt;interface&lt;/span&gt; &lt;span&gt;IUserOperation&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;&lt;span&gt;void&lt;/span&gt; &lt;span&gt;updateUserInfo&lt;/span&gt;&lt;span&gt;(OperationType type, User user)&lt;/span&gt;&lt;/span&gt;;&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;public &lt;/span&gt;&lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;UserOperationImpl&lt;/span&gt; &lt;span&gt;implements&lt;/span&gt; &lt;span&gt;IUserOperation&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;updateUserInfo&lt;/span&gt;&lt;span&gt;(OperationType type, User user)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;// 修改用户名的逻辑&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (type == OperationType.UPDATE_USER_NAME) {...)&lt;br/&gt;        &lt;span&gt;// 修改密码的逻辑&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;else &lt;/span&gt;&lt;span&gt;if &lt;/span&gt;(type == OperationType.UPDATE_USER_PASSWORD) {...}&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果只需要修改用户名和密码，以后也不会修改或者扩展这个类，那么这个写法是没有问题的，这体现了&lt;em&gt;KISS/YAGNI&lt;/em&gt;原则。但是如果需要修改的信息会随着业务发展越来越多，那么我们就不能将所有操作都放在一起，而是需要将用户名和用户密码两个方法分开，分别放入接口中，这样才能方便之后&lt;span&gt;扩展&lt;/span&gt;更多的功能。改动后的代码如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;public &lt;/span&gt;&lt;span&gt;&lt;span&gt;interface&lt;/span&gt; &lt;span&gt;IUserOperation&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;&lt;span&gt;void&lt;/span&gt; &lt;span&gt;updateUserName&lt;/span&gt;&lt;span&gt;(User user)&lt;/span&gt;&lt;/span&gt;;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;void&lt;/span&gt; &lt;span&gt;updateUserPassword&lt;/span&gt;&lt;span&gt;(User user)&lt;/span&gt;&lt;/span&gt;;&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;public &lt;/span&gt;&lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;UserOperationImpl&lt;/span&gt; &lt;span&gt;implements&lt;/span&gt; &lt;span&gt;IUserOperation&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;@Override&lt;/span&gt;&lt;span&gt;// 修改用户名的逻辑&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;updateUserName&lt;/span&gt;&lt;span&gt;(User user)&lt;/span&gt; &lt;/span&gt;{...}&lt;br/&gt;    &lt;br/&gt;    &lt;span&gt;@Override&lt;/span&gt;&lt;span&gt;// 修改密码的逻辑&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;updateUserPassword&lt;/span&gt;&lt;span&gt;(User user)&lt;/span&gt; &lt;/span&gt;{...}&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在生产实践中，我们应该小心谨慎的将职责合理分解，降低类和方法的复杂度。这样能够提升代码的&lt;em&gt;可读性&lt;/em&gt;、&lt;em&gt;可扩展性&lt;/em&gt;、&lt;em&gt;复用性&lt;/em&gt;和&lt;em&gt;可维护性&lt;/em&gt;，可以将改动代码的风险降低。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;OCP&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;开闭（Open Closed Principle，OCP）&lt;/span&gt;原则指的是，对扩展开放、对修改关闭。意思是说对软件添加新的功能，应该在原有代码的基础上扩展代码，实现功能，而不是修改原来的代码添加功能。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;举一个简单的例子，假定我们有一家水果摊，水果摊中有各种各样的水果：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;public &lt;/span&gt;&lt;span&gt;&lt;span&gt;interface&lt;/span&gt; &lt;span&gt;Fruit&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;String &lt;span&gt;getName&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt;;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;double&lt;/span&gt; &lt;span&gt;getPrice&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt;;&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;public &lt;/span&gt;&lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;Apple&lt;/span&gt; &lt;span&gt;implements&lt;/span&gt; &lt;span&gt;Fruit&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; String &lt;span&gt;getName&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{...}&lt;br/&gt;    &lt;br/&gt;    &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;double&lt;/span&gt; &lt;span&gt;getPrice&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{...}&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;public &lt;/span&gt;&lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;Orange&lt;/span&gt; &lt;span&gt;implements&lt;/span&gt; &lt;span&gt;Fruit&lt;/span&gt; &lt;/span&gt;{...}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;现在季节更替，我们为了加快销售，决定搞活动，给苹果打折。如果我们直接对水果接口进行修改添加打折代码：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;public &lt;/span&gt;&lt;span&gt;&lt;span&gt;interface&lt;/span&gt; &lt;span&gt;Fruit&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    ...&lt;br/&gt;    &lt;span&gt;&lt;span&gt;double&lt;/span&gt; &lt;span&gt;getOnSalePrice&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt;;&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;public &lt;/span&gt;&lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;Apple&lt;/span&gt; &lt;span&gt;implements&lt;/span&gt; &lt;span&gt;Fruit&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    ...&lt;br/&gt;    &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;double&lt;/span&gt; &lt;span&gt;getOnSalePrice&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{...}&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这样的话就会存在两个问题，第一接口作为&lt;span&gt;合约（Contract）&lt;/span&gt;，不应该随意修改，否则失去了约束力，导致其他实现接口的类都必须全部修改以满足接口中的方法的定义。也就是说本来橘子不需要打折的，但也需要做相应修改；第二由于接口发生修改，对应这个接口编写的&lt;span&gt;单元测试&lt;/span&gt;都会失效，需要添加新的单元测试，可能会有错误或者遗漏。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那我们应该怎么实现这个打折的方法呢，正确做法是给苹果类添加一个&lt;em&gt;打折子类&lt;/em&gt;并增加获取价格的方法，然后用新的子类&lt;em&gt;替换&lt;/em&gt;掉父类：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;AppleOnSale&lt;/span&gt; &lt;span&gt;extends&lt;/span&gt; &lt;span&gt;Apple&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt;&lt;span&gt;double&lt;/span&gt; discount = &lt;span&gt;0.95&lt;/span&gt;;&lt;br/&gt;    &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;double&lt;/span&gt; &lt;span&gt;&lt;span&gt;getPrice&lt;/span&gt;&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;return &lt;/span&gt;&lt;span&gt;super&lt;/span&gt;.&lt;span&gt;getPrice&lt;/span&gt;() * discount;&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;有的人可能会问，是不是只要对类或者方法进行了&lt;span&gt;修改&lt;/span&gt;就会违背开闭原则呢。答案当然是&lt;span&gt;否&lt;/span&gt;，我们要做的是将这个修改集中在&lt;em&gt;应用层代码&lt;/em&gt;，使&lt;em&gt;底层代码&lt;/em&gt;保持稳定，运用&lt;em&gt;抽象&lt;/em&gt;思维，将&lt;em&gt;通用&lt;/em&gt;的部分提取出来。同时，我们也应该牢记&lt;em&gt;YAGNI&lt;/em&gt;原则，不要进行过度设计，如果需求发生变化，再在重构代码的同时留下&lt;em&gt;扩展点&lt;/em&gt;。需要我们在充分理解业务的基础上，深度挖掘扩展点，调研代码将如何被使用。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;LSP&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;里氏替换（Liskov Substitution Principle，LSP）&lt;/span&gt;原则指的是，一个子类对象能够完全&lt;em&gt;替代&lt;/em&gt;父类对象，而不会影响代码运行。举个例子，在 Java 中，&lt;code&gt;ArrayList&lt;/code&gt;和&lt;code&gt;LinkedList&lt;/code&gt;是&lt;code&gt;List&lt;/code&gt;的一个实现类，那么在代码中我们可以将所有&lt;code&gt;List&lt;/code&gt;对象用&lt;code&gt;ArrayList&lt;/code&gt;或&lt;code&gt;LinkedList&lt;/code&gt;对象替换：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; String &lt;span&gt;getFisrt&lt;/span&gt;&lt;span&gt;(List&amp;lt;String&amp;gt; list)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; list.get(&lt;span&gt;0&lt;/span&gt;);&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// It&#x27;s OK&lt;/span&gt;&lt;br/&gt;ArrayList&amp;lt;String&amp;gt; values = &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;&amp;gt;();&lt;br/&gt;values.add(&lt;span&gt;&quot;Hello, World!&quot;&lt;/span&gt;);&lt;br/&gt;System.out.println(getFisrt(values)); &lt;span&gt;// Hello, World!&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// It&#x27;s also OK&lt;/span&gt;&lt;br/&gt;LinkedList&amp;lt;String&amp;gt; values = &lt;span&gt;new&lt;/span&gt; LinkedList&amp;lt;&amp;gt;();&lt;br/&gt;values.add(&lt;span&gt;&quot;Hello, World!&quot;&lt;/span&gt;);&lt;br/&gt;System.out.println(getFisrt(values)); &lt;span&gt;// Hello, World!&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;里氏替换原则要求我们：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;子类实现父类的抽象方法，不重载（Override）父类的非抽象方法&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;子类方法的参数可以是重载的父类方法参数的父类，子类方法返回值可以是重载方法对应的子类，子类方法的异常应该与重载的父类方法相同&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;子类应该遵循父类的注释以及参数检查声明&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其中&lt;span&gt;第 2 点&lt;/span&gt;比较难理解，我们还是以上面的代码示例说明，如果一个子类继承了拥有&lt;code&gt;getFirst()&lt;/code&gt;方法的父类，并重载了&lt;code&gt;getFirst()&lt;/code&gt;方法，但是使用了&lt;code&gt;ArrayList&lt;/code&gt;作为参数。那么在子类的方法中如果使用了&lt;code&gt;ArrayList&lt;/code&gt;类&lt;em&gt;独有&lt;/em&gt;的方法，子类的方法将不能替代父类，这就违背了里氏替换原则。但反过来，如果父类的&lt;code&gt;getFirst()&lt;/code&gt;方法使用&lt;code&gt;ArrayList&lt;/code&gt;对象作为参数，子类使用&lt;code&gt;List&lt;/code&gt;对象作为参数，子类方法中使用的任何&lt;code&gt;List&lt;/code&gt;对象的方法一定可以由父类的&lt;code&gt;ArrayList&lt;/code&gt;对象实现。返回值解释类似，就不多赘述。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;ISP&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;接口隔离（Interface Segregation Principle，ISP）&lt;/span&gt;原则指的是客户端不应该被强迫依赖它不需要的接口。意思是我们应该合理设计接口，确保客户端在实现功能的前提下不依赖不需要的接口。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;比如说，在公司架构中，级别越高的权限越高。如果我们将所有操作都放在一个接口，是&lt;span&gt;违背&lt;/span&gt;接口隔离原则的：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;public &lt;/span&gt;&lt;span&gt;&lt;span&gt;interface&lt;/span&gt; &lt;span&gt;Service&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;&lt;span&gt;void&lt;/span&gt; &lt;span&gt;setCompanyPolicy&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt;;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;void&lt;/span&gt; &lt;span&gt;setDepartmentPolicy&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt;;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;double&lt;/span&gt; &lt;span&gt;getSalary&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt;;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;int&lt;/span&gt; &lt;span&gt;getID&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt;;&lt;br/&gt;    ...&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;public &lt;/span&gt;&lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;CEO&lt;/span&gt; &lt;span&gt;implements&lt;/span&gt; &lt;span&gt;Service&lt;/span&gt; &lt;/span&gt;{...}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;public &lt;/span&gt;&lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;Manager&lt;/span&gt; &lt;span&gt;implements&lt;/span&gt; &lt;span&gt;Service&lt;/span&gt; &lt;/span&gt;{...}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;public &lt;/span&gt;&lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;Employee&lt;/span&gt; &lt;span&gt;implements&lt;/span&gt; &lt;span&gt;Service&lt;/span&gt; &lt;/span&gt;{...}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;公司里 CEO 的权限最大，可以设定整个公司的发展策略，部门经理可以设定部门的发展策略，而普通员工只可以查看自己的薪水或者工号等。如果每个员工都有权限设置公司的发展策略，公司将群龙无首，管理混乱。所以我们需要将服务接口拆分开，通过&lt;em&gt;鉴权&lt;/em&gt;的方式赋予每个角色不同的权限，方便管理：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;public &lt;/span&gt;&lt;span&gt;&lt;span&gt;interface&lt;/span&gt; &lt;span&gt;CompanyService&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;&lt;span&gt;void&lt;/span&gt; &lt;span&gt;setCompanyPolicy&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt;;&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;public &lt;/span&gt;&lt;span&gt;&lt;span&gt;interface&lt;/span&gt; &lt;span&gt;DepartmentService&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;&lt;span&gt;void&lt;/span&gt; &lt;span&gt;setDepartmentPolicy&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt;;&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;public &lt;/span&gt;&lt;span&gt;&lt;span&gt;interface&lt;/span&gt; &lt;span&gt;EmployeeService&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;&lt;span&gt;double&lt;/span&gt; &lt;span&gt;getSalary&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt;;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;int&lt;/span&gt; &lt;span&gt;getID&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt;;&lt;br/&gt;    ...&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;public &lt;/span&gt;&lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;CEO&lt;/span&gt; &lt;span&gt;implements&lt;/span&gt; &lt;span&gt;CompanyService&lt;/span&gt;, &lt;span&gt;DepartmentService&lt;/span&gt;, &lt;span&gt;EmployeeService&lt;/span&gt;  &lt;/span&gt;{...}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;public &lt;/span&gt;&lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;Manager&lt;/span&gt; &lt;span&gt;implements&lt;/span&gt; &lt;span&gt;DepartmentService&lt;/span&gt;, &lt;span&gt;EmployeeService&lt;/span&gt; &lt;/span&gt;{...}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;public &lt;/span&gt;&lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;Employee&lt;/span&gt; &lt;span&gt;implements&lt;/span&gt; &lt;span&gt;EmployeeService&lt;/span&gt; &lt;/span&gt;{...}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们需要合理设计接口的大小，既不要暴露过多的方法给客户端，这样做不仅会做很多&lt;em&gt;无用功&lt;/em&gt;也会带来&lt;em&gt;安全隐患&lt;/em&gt;；也不要将接口拆分的过细，会导致接口数量过多，实现变得&lt;em&gt;复杂&lt;/em&gt;。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;DIP&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;依赖反转（Dependency Inversion Principle，DIP）&lt;/span&gt;原则，指的是高层模块不要依赖低层模块，应该通过抽象互相依赖，抽象不依赖具体实现&lt;span&gt;细节（detail）&lt;/span&gt;，具体实现细节依赖抽象。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;举个例子，有一个商人，他开始是卖苹果的：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;public &lt;/span&gt;&lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;Merchant&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; Apple apple;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;sellApple&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        apple.sell();&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;public &lt;/span&gt;&lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;Apple&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;sell&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        System.out.println(&lt;span&gt;&quot;Red Apple&quot;&lt;/span&gt;);&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;后来他的苹果生意越做越大，他发现卖橘子也有很大的利润，于是他决定也卖橘子，但是我们没提供卖橘子的方法，只能修改商人类加上卖橘子的方法。这违反了&lt;span&gt;开闭原则&lt;/span&gt;。由于橘子和苹果都是水果，我们可以设计一个水果接口，来满足要求。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;public &lt;/span&gt;&lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;Merchant&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; Fruit fruit;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;sell&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        fruit.sell();&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;public &lt;/span&gt;&lt;span&gt;&lt;span&gt;interface&lt;/span&gt; &lt;span&gt;Fruit&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;sell&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt;;&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;public &lt;/span&gt;&lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;Apple&lt;/span&gt; &lt;span&gt;implements&lt;/span&gt; &lt;span&gt;Fruit&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;sell&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        System.out.println(&lt;span&gt;&quot;Red Apple&quot;&lt;/span&gt;);&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;public &lt;/span&gt;&lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;Orange&lt;/span&gt; &lt;span&gt;implements&lt;/span&gt; &lt;span&gt;Fruit&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;sell&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        System.out.println(&lt;span&gt;&quot;Orange Orange&quot;&lt;/span&gt;);&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这样使用&lt;span&gt;依赖注入（Dependency Injection，DI）&lt;/span&gt;的方式将水果&lt;em&gt;传递&lt;/em&gt;给商人类，完成了商人贩卖的扩展。另外还有一种方式是&lt;span&gt;使用控制反转（Inversion of Control，IoC）&lt;/span&gt;，指的是调用者将业务代码填充进框架的骨架中，使用&lt;em&gt;框架&lt;/em&gt;推进整个流程，也就是说将程序的&lt;em&gt;执行权&lt;/em&gt;交给了框架。常见的有&lt;em&gt;单元测试&lt;/em&gt;框架等。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;DRY&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;DRY（Don&#x27;t Repeat Yourself）&lt;/span&gt;原则指的是，不要重复编写代码。这里的不要重复并不是单纯指的两段相同的代码，而是指的代码逻辑、语义和执行的重复。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;代码逻辑重复&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;比如说刚开始搭建网站时，我们需要检查用户注册的用户名和密码的有效性。即使两个检查的内容是相同的，我们也应该避免将两个检查放在同一个方法中进行。因为如果之后需求发生了变化，比如对密码的强度做了要求，需要大小写和特殊字符，那么这个检查将不再适用于用户名。所以当代码逻辑重复但是&lt;span&gt;语义&lt;/span&gt;不同时，我们可以认为这段代码&lt;em&gt;不是重复&lt;/em&gt;的。当然我们可以将两段代码中相同的代码比如检查字符串是否非空等方法提取出来放在一个&lt;code&gt;Util&lt;/code&gt;类中调用。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;代码语义重复&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;代码的语义其实就是指的代码的&lt;span&gt;功能&lt;/span&gt;。在日常开发的过程中，有可能有两个工程师编写了名称不同但是功能相同的代码。这些代码我们就可以认为是&lt;em&gt;重复&lt;/em&gt;编写的代码，需要避免。因为很有可能其他的调用者分别使用了这两个方法来实现相同的功能，但是随着业务发展，可能对这段代码需要进行修改，如果只改动了其中的一个方法的实现，将会造成一些难以发现的 bug。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;代码执行重复&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;比如说，一个很简单的例子，在使用&lt;code&gt;for&lt;/code&gt;循环的时候，我们需要比较下标是否超过了列表的边界：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; list.size(); i++) {...}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这段代码的问题在于每次循环的时候都会执行一次求取 &lt;code&gt;list.size()&lt;/code&gt; 的操作（现代编译器可以优化这个操作）。那么我们如何避免呢，只要在&lt;code&gt;for&lt;/code&gt;循环的外面计算好这个值就可以了：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;int&lt;/span&gt; n = list.size();&lt;br/&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; n; i++) {...}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可以考虑如果是每次循环都去数据库获取（或者其他的 I/O 操作）将会非常耗时，需要在代码中减少此类操作。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;Rule of Three&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那我们如何编写可复用的代码呢？如果为了暂时不需要的需求，强行编写可复用的代码，是违反&lt;span&gt;YAGNI&lt;/span&gt;原则的。这里有一个很好的判断方法：&lt;span&gt;Rule of Three&lt;/span&gt;原则，&lt;em&gt;第一次&lt;/em&gt;编写代码的时候可以不用考虑复用性，当之后需求发生变化时，再进行重构，使之具有复用性即可。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;LoD&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;迪米特（Law of Demeter，LoD）&lt;/span&gt;法则，指的是我们的代码需要具有&lt;em&gt;高内聚/低耦合&lt;/em&gt;的特性。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;高内聚&lt;/span&gt;指的是&lt;em&gt;相近&lt;/em&gt;的功能应该放到同一个类中，因为这些功能将很有会被同时修改。比如在前端编写字符串常量的时候，也可以将相同页面的字符串放在一起，方便同时修改或者&lt;em&gt;本地化&lt;/em&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;低耦合&lt;/span&gt;指的是类的&lt;em&gt;依赖&lt;/em&gt;关系应该清晰，一个类的改动会尽可能少的依赖或者引起另一个类的改动。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上面的水果商人的例子就可以比较好的说明迪米特法则，不需要依赖的两个类之间不要有依赖，如果两个类之间要有依赖需要通过&lt;span&gt;接口&lt;/span&gt;进行通信。水果商人的例子中，我们可以直接使用水果商人而不需要管水果接口的改动。这样做使得代码结构清晰，&lt;em&gt;可读性&lt;/em&gt;，&lt;em&gt;可扩展性&lt;/em&gt;都能得到了保证。&lt;/p&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>