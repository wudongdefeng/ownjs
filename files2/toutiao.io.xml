<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>b38d018b071ddf6f5539d0bd7166e141</guid>
<title>优质网站同好者周刊（第 093 期）</title>
<link>https://toutiao.io/k/lxvhagy</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;content&quot;&gt;&lt;p&gt;&lt;a href=&quot;https://nicelinks.site/?utm_source=weekly&quot;&gt;倾城之链&lt;/a&gt;作为一个开放平台，旨在云集全球&lt;strong&gt;优秀网站&lt;/strong&gt;，探索互联网中更广阔的世界。此周刊，将汇聚过去一周&lt;a href=&quot;https://nicelinks.site/?utm_source=weekly&quot;&gt;倾城&lt;/a&gt;所收录的内容，以飨同好；欢迎推荐或自荐（仅限有独立域名的网站，可以是二级域名）。您如果要了解收录要求，请参见&lt;a href=&quot;https://nicelinks.site/about?utm_source=weekly&quot;&gt;关于倾城&lt;/a&gt;。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;备注&lt;/strong&gt;：本周刊&lt;strong&gt;每周五&lt;/strong&gt;生成，首发于个人微信公众号&lt;a href=&quot;https://mp.weixin.qq.com/mp/appmsgalbum?__biz=MzI5MDIwMzM2Mg==&amp;amp;action=getalbum&amp;amp;album_id=1530765143352082433&amp;amp;scene=173&amp;amp;from_msgid=2650641087&amp;amp;from_itemidx=1&amp;amp;count=3#wechat_redirect&quot;&gt;晚晴幽草轩&lt;/a&gt;、博客&lt;a href=&quot;https://www.jeffjade.com&quot;&gt;晚晴幽草轩&lt;/a&gt;，以及&lt;a href=&quot;https://forum.lovejade.cn/&quot;&gt;悠然宜想亭&lt;/a&gt;社区；此一键生成脚本基于 &lt;a href=&quot;https://nicelinks.site/post/602d30aad099ff5688618591&quot;&gt;Deno&lt;/a&gt; 编写，并在 Github 开源：&lt;a href=&quot;https://github.com/nicejade/nicelinks-weekly&quot;&gt;nicejade/nicelinks-weekly&lt;/a&gt;。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;标签&lt;/strong&gt;：&lt;a href=&quot;https://nicelinks.site/tags/%E5%8D%8F%E4%BD%9C&quot;&gt;&lt;code&gt;协作&lt;/code&gt;&lt;/a&gt; · &lt;a href=&quot;https://nicelinks.site/tags/%E7%9F%A5%E8%AF%86%E7%AE%A1%E7%90%86&quot;&gt;&lt;code&gt;知识管理&lt;/code&gt;&lt;/a&gt; · &lt;a href=&quot;https://nicelinks.site/tags/%E8%87%AA%E6%89%98%E7%AE%A1&quot;&gt;&lt;code&gt;自托管&lt;/code&gt;&lt;/a&gt;&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;An open-source, self-hosted memo hub with knowledge management and collaboration.&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;img src=&quot;https://oss.nicelinks.site/usememos.com.png?x-oss-process=style/png2jpg&quot; alt=&quot;倾城之链 - Memos - 具有知识管理和协作功能的开源自托管备忘录中心&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;推荐语&lt;/strong&gt;：&lt;a href=&quot;https://nicelinks.site/redirect?url=https://usememos.com/&quot;&gt;Memos&lt;/a&gt; ，具有 &lt;a href=&quot;https://nicelinks.site/tags/%E7%9F%A5%E8%AF%86%E7%AE%A1%E7%90%86&quot;&gt;知识管理&lt;/a&gt; 和 &lt;a href=&quot;https://nicelinks.site/tags/%E5%8D%8F%E4%BD%9C&quot;&gt;协作&lt;/a&gt; 功能的开源&lt;strong&gt;自托管&lt;/strong&gt;备忘录中心；基于 &lt;a href=&quot;https://nicelinks.site/post/606aa86a00d67605dca7de5c&quot;&gt;Go&lt;/a&gt; 、TypeScript、 &lt;a href=&quot;https://nicelinks.site/post/5b1294b5e93ed2618cfac134&quot;&gt;React&lt;/a&gt; 、Less、 &lt;a href=&quot;https://nicelinks.site/post/5fd20cb4c06d6302c1907ec7&quot;&gt;Tailwind CSS&lt;/a&gt; HTML 等编写；该团队在 Github 上有介绍到它具备以下功能：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;🦄 开源并永久免费。&lt;/li&gt;&lt;li&gt;🚀 支持在几秒钟内用 Docker、docker-compose 进行自我托管。&lt;/li&gt;&lt;li&gt;📜 首先是普通文本区，并支持一些有用的 markdown 语法。&lt;/li&gt;&lt;li&gt;👥 协作并与你的队友分享。&lt;/li&gt;&lt;li&gt;🧑💻 用于自助服务的 RESTful API。&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;仅简单这么介绍，在笔者看来并不完备。在笔者看来，&lt;a href=&quot;https://nicelinks.site/redirect?url=https://usememos.com/&quot;&gt;Memos&lt;/a&gt; 是理想中的「随笔/知识管理工具/个人微博」应用。主要因为以下几点：设计简洁、打开即写（类推特）；支持&lt;strong&gt;自托管&lt;/strong&gt;，且操作方便；满足&lt;strong&gt;个性化定制&lt;/strong&gt;设置；良好的内置搜索体验；可开启其他人注册 ®️；拥有类 Github Contribution 格子记录 📝；支持创建快捷方式（Filter Shortcut，即根据标签、文本、展示时间等创建的过滤规则）......虽然存在些待优化点，如暂不支持设置标题（Title）、图标（ICON） 以及评论，注入 GA 统计需要额外编写 loadScript 函数，页面直出是 SPA 等，但瑕不掩瑜，Memos 已然成为业余文字阵地的新宠（已于 2022 年 11 月 22 日晚，迫不及待搭建了 &lt;a href=&quot;https://memo.lovejade.cn/&quot;&gt;半缘修道舫&lt;/a&gt; ，感兴趣朋友可前往以查看效果）。如果您也有欲构建属于个人的微博或知识管理工具，Memos 值得考虑。&lt;/p&gt;&lt;p&gt;── 出自&lt;a href=&quot;https://nicelinks.site/post/637e1ebc984fb92197ab0f73&quot;&gt;倾城之链 - Memos - 具有知识管理和协作功能的开源自托管备忘录中心&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;标签&lt;/strong&gt;：&lt;a href=&quot;https://nicelinks.site/tags/%E5%AD%A6%E4%B9%A0&quot;&gt;&lt;code&gt;学习&lt;/code&gt;&lt;/a&gt; · &lt;a href=&quot;https://nicelinks.site/tags/%E6%95%99%E8%82%B2&quot;&gt;&lt;code&gt;教育&lt;/code&gt;&lt;/a&gt; · &lt;a href=&quot;https://nicelinks.site/tags/%E4%B9%A6%E7%B1%8D&quot;&gt;&lt;code&gt;书籍&lt;/code&gt;&lt;/a&gt;&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;CS 自学指南（计算机自学指南），Everyone should enjoy CS if you have a good teacher to teach you a good course.&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;img src=&quot;https://oss.nicelinks.site/csdiy.wiki.png?x-oss-process=style/png2jpg&quot; alt=&quot;倾城之链 - CS 自学指南&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;推荐语&lt;/strong&gt;：&lt;a href=&quot;https://nicelinks.site/redirect?url=https://csdiy.wiki/&quot;&gt;CS 自学指南&lt;/a&gt; ，一本计算机科学自学指南（&lt;code&gt;CS&lt;/code&gt;：Computer Science 的缩写），主要由北京大学一名同学编写（贡献者颇多），也是作者对自己大学三年自学生涯的一个纪念。该课程支持&lt;strong&gt;免费在线&lt;/strong&gt;阅读，并在 Github 开源，截止 2022 年 11 月，已有 14K Star。作者认为：如果你有一位好老师教你一门好课程，每个人都应该喜欢 CS（计算机科学），深有同感。&lt;/p&gt;&lt;h3 id=&quot;项目初衷&quot;&gt;&lt;a href=&quot;#%E9%A1%B9%E7%9B%AE%E5%88%9D%E8%A1%B7&quot; aria-label=&quot;项目初衷 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; version=&quot;1.1&quot; viewbox=&quot;0 0 16 16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;/&gt;&lt;/svg&gt;&lt;/a&gt;项目初衷&lt;/h3&gt;&lt;p&gt;新冠肆虐，网课当道，CS 爆火，这一系列的事件都让自学计算机成为了一种潮流。&lt;/p&gt;&lt;p&gt;随着欧美众多名校将质量极高的计算机课程全部开源，自学 CS（计算机科学） 成了一件可操作性极强的事情。毫不夸张地说，只要你有毅力和兴趣，自学的成果完全不亚于你在国内任何一所大学受到的本科 CS 教育（当然，这里单指计算机专业领域，大学带给你的显然不止是专业知识）。&lt;/p&gt;&lt;p&gt;作者非常庆幸在自己大一的时候就选择了自学 CS 这条路，它让我爱上了计算机这门学科，也无比丰富了我的视野。但同时，自学这条路也有很多困难和阻力：课程繁多不知如何选择，资料零散甚至残缺，作业难度不知深浅，课内任务还需要花时间应付······这些主客观因素叠加到一起，使得好课虽多，却只能在收藏夹里吃灰。&lt;/p&gt;&lt;p&gt;在大学的第四个年头，作者想把这一路自学走来的经验和教训，把那些让我受益终身的课程记录下来，分享给大家，形成了这本 &lt;a href=&quot;https://nicelinks.site/redirect?url=https://csdiy.wiki/&quot;&gt;CS 自学指南&lt;/a&gt; ，以期能给所有想自学计算机的朋友一点帮助。&lt;/p&gt;&lt;h3 id=&quot;课程目标&quot;&gt;&lt;a href=&quot;#%E8%AF%BE%E7%A8%8B%E7%9B%AE%E6%A0%87&quot; aria-label=&quot;课程目标 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; version=&quot;1.1&quot; viewbox=&quot;0 0 16 16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;/&gt;&lt;/svg&gt;&lt;/a&gt;课程目标&lt;/h3&gt;&lt;p&gt;作者目标是让一个刚刚接触计算机的小白，可以完全凭借这些开源社区的优质资源，少走弯路，在 2-3 年内成长为一个有扎实的数学功底和代码能力，经历过数十个千行代码量的 Project 的洗礼，掌握至少 C / C++ / Java / JS / Python / Go / Rust 等主流语言，对算法、电路、体系、网络、操统、编译、人工智能、 &lt;a href=&quot;https://nicelinks.site/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0&quot;&gt;机器学习&lt;/a&gt; 、计算机视觉、自然语言处理、强化学习、密码学、信息论、博弈论、数值分析、统计学、分布式、数据库、图形学、 &lt;a href=&quot;https://nicelinks.site/tags/Web%E5%BC%80%E5%8F%91&quot;&gt;Web 开发&lt;/a&gt; 、云服务、超算等等方面均有所涉猎的全能程序员。此后，无论是选择科研还是就业，相信你都会有相当的竞争力。&lt;/p&gt;&lt;p&gt;关乎 &lt;a href=&quot;https://nicelinks.site/redirect?url=https://csdiy.wiki/&quot;&gt;CS 自学指南&lt;/a&gt; 背后更多故事，作者在&lt;strong&gt;前言&lt;/strong&gt;部分有做阐述，诸如：梦开始的地方 —— CS61A、为什么写这本书、自学的好处与坏处、及书籍适合哪些人群等。其中绝大部分观点，深表认同，如数学与英文的重要性、学会提问、必备工具、自学所存在好处与缺陷等等。&lt;/p&gt;&lt;p&gt;正如作者在前言里所谈，任何有志于&lt;strong&gt;自学计算机&lt;/strong&gt;的朋友，都可以参考 &lt;a href=&quot;https://nicelinks.site/redirect?url=https://csdiy.wiki/&quot;&gt;CS 自学指南&lt;/a&gt; 这本书。如果你已经有了一定的计算机基础，只是对某个特定的领域感兴趣，可以选择性地挑选你感兴趣的内容进行学习，相信会有所收获。但，大致翻阅其中内容，更多是国外优质课程的&lt;code&gt;目录&lt;/code&gt;（视频或网站地址），意在解决“想学好、但不知道怎么学”的问题，能帮助有自学之心和毅力朋友少走些弯路，选择性地挑选感兴趣内容进行参考学习即可，不必奉为圭臬。毕竟，能否学到，更大程度取决于&lt;strong&gt;个人求知欲&lt;/strong&gt;、&lt;strong&gt;自律&lt;/strong&gt;及&lt;strong&gt;英文阅读能力&lt;/strong&gt;等。&lt;/p&gt;&lt;p&gt;── 出自&lt;a href=&quot;https://nicelinks.site/post/6379dc24049fa51046c4b83c&quot;&gt;倾城之链 - CS 自学指南&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;标签&lt;/strong&gt;：&lt;a href=&quot;https://nicelinks.site/tags/%E6%95%88%E7%8E%87&quot;&gt;&lt;code&gt;效率&lt;/code&gt;&lt;/a&gt; · &lt;a href=&quot;https://nicelinks.site/tags/Mac&quot;&gt;&lt;code&gt;Mac&lt;/code&gt;&lt;/a&gt; · &lt;a href=&quot;https://nicelinks.site/tags/%E8%BD%AF%E4%BB%B6&quot;&gt;&lt;code&gt;软件&lt;/code&gt;&lt;/a&gt;&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;Limitless productivity in a productivity-less world.&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;img src=&quot;https://oss.nicelinks.site/www.raycast.com.png?x-oss-process=style/png2jpg&quot; alt=&quot;倾城之链 - Raycast - Supercharged productivity&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;推荐语&lt;/strong&gt;：&lt;a href=&quot;https://nicelinks.site/redirect?url=https://www.raycast.com/&quot;&gt;Raycast&lt;/a&gt; 是一款速度极快、完全可扩展的发射器。它可以让您完成任务、计算、共享常用链接等。与其功能类似的产品有：macOS 的「聚焦（Spotlight）」、&lt;a href=&quot;https://nicelinks.site/post/5ae926e67b44827edbc5c69a&quot;&gt;Alfred&lt;/a&gt; 等；Raycast 堪称是为开发人员定制的生产力工具，它具有以下功能特性：&lt;/p&gt;&lt;h3 id=&quot;提高您的生产力&quot;&gt;&lt;a href=&quot;#%E6%8F%90%E9%AB%98%E6%82%A8%E7%9A%84%E7%94%9F%E4%BA%A7%E5%8A%9B&quot; aria-label=&quot;提高您的生产力 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; version=&quot;1.1&quot; viewbox=&quot;0 0 16 16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;/&gt;&lt;/svg&gt;&lt;/a&gt;提高您的生产力&lt;/h3&gt;&lt;p&gt;在已经内置的核心 &lt;strong&gt;Raycast 扩展&lt;/strong&gt;之上，您可以安装由社区开发人员构建的扩展。您所要求的一切，都集中在一个地方。搜索和浏览您的工具、操作等的扩展。 &lt;a href=&quot;https://www.raycast.com/store&quot;&gt;浏览扩展&lt;/a&gt; 。&lt;/p&gt;&lt;h3 id=&quot;轻巧活泼&quot;&gt;&lt;a href=&quot;#%E8%BD%BB%E5%B7%A7%E6%B4%BB%E6%B3%BC&quot; aria-label=&quot;轻巧活泼 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; version=&quot;1.1&quot; viewbox=&quot;0 0 16 16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;/&gt;&lt;/svg&gt;&lt;/a&gt;轻巧活泼&lt;/h3&gt;&lt;p&gt;旨在无缝和即时，使用非常方便。查看扩展并点击  &lt;code&gt;↵&lt;/code&gt;  以在几毫秒内简单地安装它。&lt;/p&gt;&lt;h3 id=&quot;一个不断增长的收藏&quot;&gt;&lt;a href=&quot;#%E4%B8%80%E4%B8%AA%E4%B8%8D%E6%96%AD%E5%A2%9E%E9%95%BF%E7%9A%84%E6%94%B6%E8%97%8F&quot; aria-label=&quot;一个不断增长的收藏 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; version=&quot;1.1&quot; viewbox=&quot;0 0 16 16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;/&gt;&lt;/svg&gt;&lt;/a&gt;一个不断增长的收藏&lt;/h3&gt;&lt;p&gt;只需按一下按钮即可控制 Spotify 或 Apple Music。在 Figma、Notion 和 Xcode 中搜索。无需浏览器即可查看您的网速和天气，甚至可以玩贪吃蛇游戏。&lt;/p&gt;&lt;h3 id=&quot;构建您一直想要的&quot;&gt;&lt;a href=&quot;#%E6%9E%84%E5%BB%BA%E6%82%A8%E4%B8%80%E7%9B%B4%E6%83%B3%E8%A6%81%E7%9A%84&quot; aria-label=&quot;构建您一直想要的 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; version=&quot;1.1&quot; viewbox=&quot;0 0 16 16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;/&gt;&lt;/svg&gt;&lt;/a&gt;构建您一直想要的&lt;/h3&gt;&lt;p&gt;你的 Raycast，你的游乐场。每个人的生产力都是独一无二的。个性化是关键。以您想要的方式扩展 Raycast，并使用 API 为您和您的团队构建工具。&lt;/p&gt;&lt;p&gt;开始使用 Raycast API 构建您的完美工具，并简化您的工作流程。轻松创建扩展并直接无缝发布到 Raycast Store。开始使用 Raycast 中的集成开发人员工具，立即构建您的第一个扩展。 &lt;a href=&quot;https://www.raycast.com/developers&quot;&gt;学到更多&lt;/a&gt; 。&lt;/p&gt;&lt;h3 id=&quot;节省日常任务的时间&quot;&gt;&lt;a href=&quot;#%E8%8A%82%E7%9C%81%E6%97%A5%E5%B8%B8%E4%BB%BB%E5%8A%A1%E7%9A%84%E6%97%B6%E9%97%B4&quot; aria-label=&quot;节省日常任务的时间 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; version=&quot;1.1&quot; viewbox=&quot;0 0 16 16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;/&gt;&lt;/svg&gt;&lt;/a&gt;节省日常任务的时间&lt;/h3&gt;&lt;p&gt;Raycast 不仅仅是个人的工具。它也是一种工具，&lt;strong&gt;专为共享而设计&lt;/strong&gt;。从自定义扩展到快速链接和代码段。您的团队需要完成什么，我们提供了一个非常丰富的工具包来快速完成，并且与您的整个组织和谐相处。&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;strong&gt;共享命令&lt;/strong&gt;：使用 &lt;a href=&quot;https://nicelinks.site/post/5b1294b5e93ed2618cfac134&quot;&gt;React&lt;/a&gt; 和 TypeScript 构建自定义工具，使组织内的团队能够快速完成最佳工作。在您的私人扩展商店中分享它们。&lt;/li&gt;&lt;li&gt;&lt;strong&gt;共享快速链接&lt;/strong&gt;：毫不费力地与您的团队共享公共链接，例如概念中的项目文档、GitHub 存储库、线性项目和数据仪表板 - 所有这些都带有快速链接。&lt;/li&gt;&lt;li&gt;&lt;strong&gt;共享片段&lt;/strong&gt;：与保存的支持响应、电子邮件或地址等常用文本保持一致，并使用动态占位符进行智能关键字扩展。&lt;/li&gt;&lt;/ul&gt;&lt;h3 id=&quot;生产力更上一层楼&quot;&gt;&lt;a href=&quot;#%E7%94%9F%E4%BA%A7%E5%8A%9B%E6%9B%B4%E4%B8%8A%E4%B8%80%E5%B1%82%E6%A5%BC&quot; aria-label=&quot;生产力更上一层楼 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; version=&quot;1.1&quot; viewbox=&quot;0 0 16 16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;/&gt;&lt;/svg&gt;&lt;/a&gt;生产力更上一层楼&lt;/h3&gt;&lt;ul&gt;&lt;li&gt;&lt;strong&gt;脚本命令&lt;/strong&gt;：使用您最喜欢的编程语言编写脚本以连接到 Web API、控制应用程序、工具等。&lt;/li&gt;&lt;li&gt;&lt;strong&gt;捷径&lt;/strong&gt;：直接从 Raycast 搜索并运行您的 macOS 快捷方式。将所有内容保存在一个地方以便快速访问。&lt;/li&gt;&lt;li&gt;&lt;strong&gt;文件搜索&lt;/strong&gt;：以简单的方式搜索文件和文件夹、查看元数据并执行常见操作。&lt;/li&gt;&lt;li&gt;&lt;strong&gt;系统命令&lt;/strong&gt;：使用 20 多个内置系统命令控制您的 Mac。从调高或调低音量，到清空垃圾箱、睡眠或重新启动系统，等等。&lt;/li&gt;&lt;li&gt;&lt;strong&gt;快速链接&lt;/strong&gt;：在浏览器中打开链接，在终端中打开文件夹或在任何文本编辑器中打开项目。并更有效地搜索网络。使用查询在 Google、Dribbble 或其他网站上执行搜索，如下所示。&lt;/li&gt;&lt;li&gt;&lt;strong&gt;快速链接&lt;/strong&gt;在浏览器中打开链接，在终端中打开文件夹或在任何文本编辑器中打开项目。并更有效地搜索网络。使用查询在 Google、Dribbble 或其他网站上执行搜索，如下所示。&lt;/li&gt;&lt;li&gt;&lt;strong&gt;浮动笔记&lt;/strong&gt;：是一种在处理其他事情时记下想法的快速方法。在您需要时总是得心应手。&lt;/li&gt;&lt;li&gt;&lt;strong&gt;计算器&lt;/strong&gt;：解决简单的数学表达式、转换单位、检查时区、计算日、月和年之间的差异，以及用自然语言做更多事情。将答案复制到剪贴板以继续您之前的操作。&lt;/li&gt;&lt;li&gt;&lt;strong&gt;窗口管理&lt;/strong&gt;：使用方便的命令清理您的窗口混乱，以便即时整理您的桌面和调整应用程序窗口的大小。&lt;/li&gt;&lt;li&gt;&lt;strong&gt;启动应用程序&lt;/strong&gt;：只需敲击几下即可启动和切换应用程序窗口。退出运行、复制详细信息、搜索菜单项等。&lt;/li&gt;&lt;li&gt;&lt;strong&gt;剪贴板历史&lt;/strong&gt;：搜索您之前复制的文本、图像、文件、链接和颜色，然后再次粘贴。固定您经常使用的项目以更快地访问它们。&lt;/li&gt;&lt;li&gt;&lt;strong&gt;文本片段&lt;/strong&gt;：通过插入常用文本（例如固定电子邮件、代码段等）来加快书写速度。使用关键字就地自动扩展代码段。&lt;/li&gt;&lt;li&gt;&lt;strong&gt;我的日程表&lt;/strong&gt;：绝不会错过任何一次会议。加入 Zoom、Google Meet、Around 会议等，无需四处寻找链接并直接进入通话。检查您即将到来的日程安排，安排专注时间或了解您的日常计划。&lt;/li&gt;&lt;/ul&gt;&lt;h3 id=&quot;更专注减少混乱&quot;&gt;&lt;a href=&quot;#%E6%9B%B4%E4%B8%93%E6%B3%A8%E5%87%8F%E5%B0%91%E6%B7%B7%E4%B9%B1&quot; aria-label=&quot;更专注减少混乱 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; version=&quot;1.1&quot; viewbox=&quot;0 0 16 16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;/&gt;&lt;/svg&gt;&lt;/a&gt;更专注，减少混乱。&lt;/h3&gt;&lt;p&gt;让您的工作空间集中、干净、整洁。设计时考虑到性能和您的隐私。&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;strong&gt;默认安全&lt;/strong&gt;，始终 所有内容都以加密方式存储在您的本地磁盘上，不会跟踪任何敏感信息。您和您的个人数据保持匿名。&lt;/li&gt;&lt;li&gt;&lt;strong&gt;做你自己的，为你量身定做&lt;/strong&gt;：启用内置扩展以提高初始生产力。使用脚本命令和我们的 API 构建自定义扩展以优化您的工作流程。&lt;/li&gt;&lt;li&gt;&lt;strong&gt;一次学习，永远记住&lt;/strong&gt;：受命令行界面的启发，您的工具统一为命令，并遵循相同的结构以提高您的工作效率。&lt;/li&gt;&lt;li&gt;&lt;strong&gt;在几秒钟内完成任务&lt;/strong&gt;：Raycast 是为更快、更轻量级和更高效而原生构建的。每个动作都针对速度和可访问性进行了优化。&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;a href=&quot;https://nicelinks.site/redirect?url=https://www.raycast.com/&quot;&gt;Raycast&lt;/a&gt; 和 Alfred、Spotlight（个人极少使用） 存在很多相似之处，但 Raycast 似乎对第三方服务的整合更加彻底，包括操作视图、信息展示更详细，除了本身涵盖的一些系统快捷设置之外，还可以通过命令脚本扩展，并提供了 扩展 Raycast 所需的一切： &lt;a href=&quot;https://github.com/raycast/extensions&quot;&gt;Raycast Extensions&lt;/a&gt; ，使其可玩性极大增强。目前，仅支持 MacOS，于 Windows、Linux 用户，尚需等待。就个人初步学习、体验来看，Raycast 有足够的潜力成为下一个&lt;strong&gt;效率神器&lt;/strong&gt;，让我等极客爱好者拭目以待。另外值得一提的是，&lt;strong&gt;创建和分享&lt;/strong&gt;源代码美丽图像的小工具： &lt;a href=&quot;https://nicelinks.site/post/609d1c43a0289c0663f94dc4&quot;&gt;ray.so&lt;/a&gt; 、图标制造工具： &lt;a href=&quot;https://icon.ray.so/&quot;&gt;icon.ray.so&lt;/a&gt; 也都是出自该团队。&lt;/p&gt;&lt;p&gt;── 出自&lt;a href=&quot;https://nicelinks.site/post/6378d324049fa51046c4ac75&quot;&gt;倾城之链 - Raycast - Supercharged productivity&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;标签&lt;/strong&gt;：&lt;a href=&quot;https://nicelinks.site/tags/WebAssembly&quot;&gt;&lt;code&gt;WebAssembly&lt;/code&gt;&lt;/a&gt; · &lt;a href=&quot;https://nicelinks.site/tags/%E8%B7%A8%E5%B9%B3%E5%8F%B0&quot;&gt;&lt;code&gt;跨平台&lt;/code&gt;&lt;/a&gt; · &lt;a href=&quot;https://nicelinks.site/tags/%E5%BC%80%E6%BA%90&quot;&gt;&lt;code&gt;开源&lt;/code&gt;&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;关键字&lt;/strong&gt;：webassembly, wasm, heroku, cloudflare, docker&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;Wasmer - The Universal WebAssembly Runtime&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;img src=&quot;https://oss.nicelinks.site/wasmer.io.png?x-oss-process=style/png2jpg&quot; alt=&quot;倾城之链 - Wasmer - The Universal WebAssembly Runtime&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;推荐语&lt;/strong&gt;： &lt;a href=&quot;https://nicelinks.site/redirect?url=https://wasmer.io/&quot;&gt;Wasmer&lt;/a&gt; 🚀 支持 WASI 和 Emscripten 的领先 WebAssembly 运行时。它提供基于 &lt;a href=&quot;https://nicelinks.site/tags/WebAssembly&quot;&gt;WebAssembly&lt;/a&gt; 的超轻量级容器，使得可以在任何地方运行：从桌面到云、以及 IoT 设备，并且也能嵌入到 &lt;a href=&quot;https://github.com/wasmerio/wasmer#language-integrations&quot;&gt;任何编程语言&lt;/a&gt; 中。它具有以下功能特性：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;strong&gt;快速又安全&lt;/strong&gt;. Wasmer 在完全沙盒化的环境中以“接近本机”的速度运行 WebAssembly。&lt;/li&gt;&lt;li&gt;&lt;strong&gt;可插拔&lt;/strong&gt;. Wasmer 可以根据你的需求支持不同的编译框架 (LLVM，Cranelift ...)。&lt;/li&gt;&lt;li&gt;&lt;strong&gt;通用的&lt;/strong&gt;. 你可以在&lt;strong&gt;任何平台&lt;/strong&gt;(macOS, Linux and Windows) 和芯片组运行 Wasmer。&lt;/li&gt;&lt;li&gt;&lt;strong&gt;符合标准&lt;/strong&gt;. 运行时通过了 &lt;a href=&quot;https://github.com/WebAssembly/testsuite&quot;&gt;官方 WebAssembly 测试集&lt;/a&gt; 支持 &lt;a href=&quot;https://github.com/WebAssembly/WASI&quot;&gt;WASI&lt;/a&gt; 和 &lt;a href=&quot;https://emscripten.org/&quot;&gt;Emscripten&lt;/a&gt; 。&lt;/li&gt;&lt;/ul&gt;&lt;h3 id=&quot;如何快速开始&quot;&gt;&lt;a href=&quot;#%E5%A6%82%E4%BD%95%E5%BF%AB%E9%80%9F%E5%BC%80%E5%A7%8B&quot; aria-label=&quot;如何快速开始 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; version=&quot;1.1&quot; viewbox=&quot;0 0 16 16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;/&gt;&lt;/svg&gt;&lt;/a&gt;如何快速开始？&lt;/h3&gt;&lt;h4 id=&quot;安装-wasmer--wapm&quot;&gt;&lt;a href=&quot;#%E5%AE%89%E8%A3%85-wasmer--wapm&quot; aria-label=&quot;安装 wasmer  wapm permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; version=&quot;1.1&quot; viewbox=&quot;0 0 16 16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;/&gt;&lt;/svg&gt;&lt;/a&gt;安装 wasmer &amp;amp; wapm&lt;/h4&gt;&lt;p&gt;Wasmer 不需要安装其他依赖， 你可以在终端运行如下命令进行安装:&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;curl https://get.wasmer.io -sSfL | sh
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;运行如上命令，在你下次打开终端时，wasmer 和 wapm 将可用。如果你想让这两个命令现在就可用，按照提示执行 &lt;code&gt;source&lt;/code&gt; 命令即可。&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;&lt;strong&gt;check&lt;/strong&gt;: wasmer 2.3.0 installed successfully ✓&lt;br/&gt;wasmer &amp;amp; wapm will be available the next time you open the terminal.&lt;br/&gt;If you want to have the commands available now please execute:&lt;/p&gt;&lt;p&gt;source /Users/[UserName]/.wasmer/wasmer.sh&lt;/p&gt;&lt;/blockquote&gt;&lt;h4 id=&quot;使用-wasmer--wapm&quot;&gt;&lt;a href=&quot;#%E4%BD%BF%E7%94%A8-wasmer--wapm&quot; aria-label=&quot;使用 wasmer  wapm permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; version=&quot;1.1&quot; viewbox=&quot;0 0 16 16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;/&gt;&lt;/svg&gt;&lt;/a&gt;使用 wasmer &amp;amp; wapm&lt;/h4&gt;&lt;p&gt;&lt;strong&gt;WAPM&lt;/strong&gt;，WebAssembly 包管理器。类似于 &lt;a href=&quot;https://nicelinks.site/post/6216392f2d17f22050cf1a2b&quot;&gt;npm&lt;/a&gt; 之于 Node.js。wapm 安装工具包，在其目录下会产生：&lt;code&gt;wapm_packages&lt;/code&gt;目录和 &lt;code&gt;wapm.lock&lt;/code&gt;。非常类似于前端项目 &lt;code&gt;node_modules&lt;/code&gt; 和 &lt;code&gt;-lock.json&lt;/code&gt;。您可以从运行 &lt;a href=&quot;https://wapm.io/saghul/quickjs&quot;&gt;QuickJS&lt;/a&gt; 开始，它是一个编译为 WebAssembly 模块 ( &lt;code&gt;qjs.wasm&lt;/code&gt; ) 的小型可嵌入 Javascript 引擎：&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;# 通过 wasmer 执行 WebAssembly 文件
wasmer qjs.wasm

# 通过 wapm 安装己编译好的 wasm 工具包
wapm install cowsay
# 通过 wapm 调用 cowsay 程序
wapm run cowsay &#x27;倾城之链&#x27;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;使用 WebAssembly 和 Wasmer，在任何客户端上运行任何代码。使用您熟悉的工具和您喜欢的语言，将所有内容编译为 WebAssembly。 在任何操作系统上运行它或将其嵌入到其他语言中。值得一提的是，&lt;a href=&quot;https://github.com/wasmerio/wasmer&quot;&gt;Wasmer 在 Github 开源&lt;/a&gt;，如果您对 WebAssembly 或 Wasmer 感兴趣，可前往从而了解更多。&lt;/p&gt;&lt;p&gt;── 出自&lt;a href=&quot;https://nicelinks.site/post/63789f3c049fa51046c4a8f3&quot;&gt;倾城之链 - Wasmer - The Universal WebAssembly Runtime&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;标签&lt;/strong&gt;：&lt;a href=&quot;https://nicelinks.site/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0&quot;&gt;&lt;code&gt;深度学习&lt;/code&gt;&lt;/a&gt; · &lt;a href=&quot;https://nicelinks.site/tags/TensorFlow&quot;&gt;&lt;code&gt;TensorFlow&lt;/code&gt;&lt;/a&gt; · &lt;a href=&quot;https://nicelinks.site/tags/Python&quot;&gt;&lt;code&gt;Python&lt;/code&gt;&lt;/a&gt;&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;Deep Learning for humans. Keras documentation.&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;img src=&quot;https://oss.nicelinks.site/keras.io.png?x-oss-process=style/png2jpg&quot; alt=&quot;倾城之链 - Keras: the Python deep learning API&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;推荐语&lt;/strong&gt;：&lt;a href=&quot;https://nicelinks.site/redirect?url=http://keras.io/&quot;&gt;Keras&lt;/a&gt; 是一个用 Python 编写的开源神经网路库，从 2021 年 8 月的版本 2.6 开始，它是在 &lt;a href=&quot;https://nicelinks.site/tags/TensorFlow&quot;&gt;TensorFlow 2&lt;/a&gt; 上建立的高层 API；在版本 2.4 及以前能够在 TensorFlow、Microsoft Cognitive Toolkit、Theano 或 PlaidML 多个后端之上执行。Keras 旨在&lt;strong&gt;快速实现深度神经网路，专注于使用者友好、模组化和可延伸性&lt;/strong&gt;，是 ONEIROS（开放式神经电子智慧机器人作业系统）专案研究工作的部分产物，主要作者和维护者是 Google 工程师 François Chollet (弗朗索瓦·肖莱，也是 XCeption 深度神经网路模型的作者)。Keras 主要特征是：&lt;strong&gt;简单&lt;/strong&gt;、&lt;strong&gt;灵活&lt;/strong&gt;、&lt;strong&gt;强大&lt;/strong&gt;。除此之外，它还具有以下特色：&lt;/p&gt;&lt;h3 id=&quot;人类的深度学习&quot;&gt;&lt;a href=&quot;#%E4%BA%BA%E7%B1%BB%E7%9A%84%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0&quot; aria-label=&quot;人类的深度学习 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; version=&quot;1.1&quot; viewbox=&quot;0 0 16 16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;/&gt;&lt;/svg&gt;&lt;/a&gt;人类的深度学习&lt;/h3&gt;&lt;p&gt;Keras 是为人类而非机器设计的 API。Keras 遵循减少认知负荷的最佳实践：它提供一致且简单的 API，最大限度地减少常见用例所需的用户操作数量，并提供清晰且可操作的错误消息。它还具有广泛的文档和开发人员指南。&lt;/p&gt;&lt;h3 id=&quot;以思想的速度迭代&quot;&gt;&lt;a href=&quot;#%E4%BB%A5%E6%80%9D%E6%83%B3%E7%9A%84%E9%80%9F%E5%BA%A6%E8%BF%AD%E4%BB%A3&quot; aria-label=&quot;以思想的速度迭代 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; version=&quot;1.1&quot; viewbox=&quot;0 0 16 16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;/&gt;&lt;/svg&gt;&lt;/a&gt;以思想的速度迭代&lt;/h3&gt;&lt;p&gt;Keras 是 &lt;a href=&quot;https://www.kaggle.com/&quot;&gt;Kaggle&lt;/a&gt; 前 5 名获胜团队中使用最多的深度学习框架。因为 Keras 使运行新实验变得更容易，它使您能够比竞争对手更快地尝试更多的想法。这就是您获胜的方式。&lt;/p&gt;&lt;h3 id=&quot;百万亿级机器学习&quot;&gt;&lt;a href=&quot;#%E7%99%BE%E4%B8%87%E4%BA%BF%E7%BA%A7%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0&quot; aria-label=&quot;百万亿级机器学习 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; version=&quot;1.1&quot; viewbox=&quot;0 0 16 16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;/&gt;&lt;/svg&gt;&lt;/a&gt;百万亿级机器学习&lt;/h3&gt;&lt;p&gt;Keras 建立在 TensorFlow 2 之上，是一个行业实力框架，可以扩展到大型 GPU 集群或整个 TPU pod。这不仅是可能的；这很简单。&lt;/p&gt;&lt;h3 id=&quot;部署在任何地方&quot;&gt;&lt;a href=&quot;#%E9%83%A8%E7%BD%B2%E5%9C%A8%E4%BB%BB%E4%BD%95%E5%9C%B0%E6%96%B9&quot; aria-label=&quot;部署在任何地方 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; version=&quot;1.1&quot; viewbox=&quot;0 0 16 16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;/&gt;&lt;/svg&gt;&lt;/a&gt;部署在任何地方&lt;/h3&gt;&lt;p&gt;利用 TensorFlow 平台的完整部署功能。您可以将 Keras 模型导出为 JavaScript 以直接在浏览器中运行，也可以导出为 TF Lite 以在 iOS、Android 和嵌入式设备上运行。通过 Web API 为 Keras 模型提供服务也很容易。&lt;/p&gt;&lt;h3 id=&quot;广阔的生态系统&quot;&gt;&lt;a href=&quot;#%E5%B9%BF%E9%98%94%E7%9A%84%E7%94%9F%E6%80%81%E7%B3%BB%E7%BB%9F&quot; aria-label=&quot;广阔的生态系统 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; version=&quot;1.1&quot; viewbox=&quot;0 0 16 16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;/&gt;&lt;/svg&gt;&lt;/a&gt;广阔的生态系统&lt;/h3&gt;&lt;p&gt;Keras 是紧密相连的 TensorFlow 2 生态系统的核心部分，涵盖机器学习工作流程的每一步，从数据管理到超参数训练再到部署解决方案。&lt;/p&gt;&lt;h3 id=&quot;最先进的研究&quot;&gt;&lt;a href=&quot;#%E6%9C%80%E5%85%88%E8%BF%9B%E7%9A%84%E7%A0%94%E7%A9%B6&quot; aria-label=&quot;最先进的研究 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; version=&quot;1.1&quot; viewbox=&quot;0 0 16 16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;/&gt;&lt;/svg&gt;&lt;/a&gt;最先进的研究&lt;/h3&gt;&lt;p&gt;CERN、NASA、NIH 和世界上更多的科学组织都在使用 Keras（是的，LHC 也使用了 Keras）。Keras 具有实现任意研究想法的低级灵活性，同时提供可选的高级便利功能以加快实验周期。&lt;/p&gt;&lt;p&gt;Keras，&lt;strong&gt;人类的深度学习&lt;/strong&gt;。由于其易用性和对用户体验的关注，Keras 成为许多大学课程的首选深度学习解决方案。它被广泛推荐为学习深度学习的最佳方法之一。值得一提的是，Keras 在 &lt;a href=&quot;https://github.com/keras-team/keras&quot;&gt;Github 开源&lt;/a&gt;，如果您对机器学习、深度学习感兴趣，可以前往以了解更多。&lt;/p&gt;&lt;p&gt;── 出自&lt;a href=&quot;https://nicelinks.site/post/6378946e049fa51046c4a72e&quot;&gt;倾城之链 - Keras: the Python deep learning API&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;标签&lt;/strong&gt;：&lt;a href=&quot;https://nicelinks.site/tags/%E6%A1%86%E6%9E%B6&quot;&gt;&lt;code&gt;框架&lt;/code&gt;&lt;/a&gt; · &lt;a href=&quot;https://nicelinks.site/tags/%E7%BD%91%E7%AB%99%E7%94%9F%E6%88%90%E5%99%A8&quot;&gt;&lt;code&gt;网站生成器&lt;/code&gt;&lt;/a&gt; · &lt;a href=&quot;https://nicelinks.site/tags/Web%E5%BC%80%E5%8F%91&quot;&gt;&lt;code&gt;Web开发&lt;/code&gt;&lt;/a&gt;&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;Pull content from anywhere and serve it fast with Astro&#x27;s next-gen island architecture. Astro is the web framework that you&#x27;ll enjoy using.&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;img src=&quot;https://oss.nicelinks.site/astro.build.png?x-oss-process=style/png2jpg&quot; alt=&quot;倾城之链 - Astro | Build faster websites&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;推荐语&lt;/strong&gt;：&lt;a href=&quot;https://nicelinks.site/redirect?url=https://astro.build/&quot;&gt;Astro&lt;/a&gt; ，是现代网络的网站构建工具：强大的开发者体验满足轻量级输出。从任何地方提取内容并使用 Astro 的下一代岛式架构快速提供内容，受到超过 30,000 名开发人员和世界级团队的信赖。它具有以下功能特征：&lt;/p&gt;&lt;h3 id=&quot;专为速度而设计&quot;&gt;&lt;a href=&quot;#%E4%B8%93%E4%B8%BA%E9%80%9F%E5%BA%A6%E8%80%8C%E8%AE%BE%E8%AE%A1&quot; aria-label=&quot;专为速度而设计 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; version=&quot;1.1&quot; viewbox=&quot;0 0 16 16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;/&gt;&lt;/svg&gt;&lt;/a&gt;专为速度而设计&lt;/h3&gt;&lt;p&gt;Astro Islands 代表了前端 Web 架构的领先范式转变。Astro 将您的 UI 提取到页面上更小、独立的组件中。未使用的 JavaScript 被轻量级 HTML 取代，保证更快的加载和交互时间 (TTI)。&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;strong&gt;零 JavaScript 运行时&lt;/strong&gt;：Astro 在服务器上呈现 HTML 并去除任何剩余的、未使用的 JavaScript。&lt;/li&gt;&lt;li&gt;&lt;strong&gt;岛屿的力量&lt;/strong&gt;：需要交互式用户界面？并行加载单独的、非阻塞的组件岛（component islands）。&lt;/li&gt;&lt;li&gt;&lt;strong&gt;懒加载孤岛&lt;/strong&gt;（Lazy-Loading Islands）：组件只有在滚动到视图中时才会渲染。如果您没有看到它，Astro 将不会加载它。&lt;/li&gt;&lt;/ul&gt;&lt;h3 id=&quot;为内容而设计&quot;&gt;&lt;a href=&quot;#%E4%B8%BA%E5%86%85%E5%AE%B9%E8%80%8C%E8%AE%BE%E8%AE%A1&quot; aria-label=&quot;为内容而设计 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; version=&quot;1.1&quot; viewbox=&quot;0 0 16 16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;/&gt;&lt;/svg&gt;&lt;/a&gt;为内容而设计&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;你的内容，你的方式&lt;/strong&gt;。Astro 与您最喜欢的内容源一起工作。从文件系统中提取内容或从您最喜欢的 CMS（内容管理系统）、Markdown、MDX、数据库或 API 远程获取内容。Astro 支持静态输出 (SSG) 和实时服务器输出 (SSR)，可以按需呈现您的内容。&lt;/p&gt;&lt;h3 id=&quot;旨在让您感到熟悉&quot;&gt;&lt;a href=&quot;#%E6%97%A8%E5%9C%A8%E8%AE%A9%E6%82%A8%E6%84%9F%E5%88%B0%E7%86%9F%E6%82%89&quot; aria-label=&quot;旨在让您感到熟悉 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; version=&quot;1.1&quot; viewbox=&quot;0 0 16 16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;/&gt;&lt;/svg&gt;&lt;/a&gt;旨在让您感到熟悉&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;使用您已经喜爱的工具&lt;/strong&gt;。自带组件框架。Astro 为 &lt;a href=&quot;https://nicelinks.site/post/6329ab4f36feb75b35987e2a&quot;&gt;Solid&lt;/a&gt; 、 &lt;a href=&quot;https://nicelinks.site/post/5b1294b5e93ed2618cfac134&quot;&gt;React&lt;/a&gt; 、 &lt;a href=&quot;https://nicelinks.site/post/5b1a221c0526c920d6dfaada&quot;&gt;Vue&lt;/a&gt; 、 &lt;a href=&quot;https://nicelinks.site/post/62a9c2ad90509e23cea772c0&quot;&gt;Svelte&lt;/a&gt; 和 &lt;a href=&quot;https://nicelinks.site/post/5fd20cb4c06d6302c1907ec7&quot;&gt;Tailwind CSS&lt;/a&gt; 、Scss、TS、Markdown 等前端工具提供一流的支持。避免混淆配置并在几秒钟内开始：只需键入 &lt;code&gt;astro add&lt;/code&gt;.&lt;/p&gt;&lt;h3 id=&quot;按比例设计&quot;&gt;&lt;a href=&quot;#%E6%8C%89%E6%AF%94%E4%BE%8B%E8%AE%BE%E8%AE%A1&quot; aria-label=&quot;按比例设计 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; version=&quot;1.1&quot; viewbox=&quot;0 0 16 16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;/&gt;&lt;/svg&gt;&lt;/a&gt;按比例设计&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;部署到任何地方，甚至是边缘&lt;/strong&gt;（edge）。Astro 支持静态输出 (SSG) 和实时服务器输出 (SSR)。无论您选择构建什么，Astro 灵活的适配器系统都能让部署设置和配置变得轻而易举。您可以选择 cloudflare、 &lt;a href=&quot;https://nicelinks.site/post/602d30aad099ff5688618591&quot;&gt;Deno&lt;/a&gt; 、 &lt;a href=&quot;https://nicelinks.site/post/59ba80d93df6765c75b77911&quot;&gt;Github&lt;/a&gt; 、netlify、Node.js、Google Cloud、AWS 等平台进行部署。&lt;/p&gt;&lt;h3 id=&quot;旨在与您一起成长&quot;&gt;&lt;a href=&quot;#%E6%97%A8%E5%9C%A8%E4%B8%8E%E6%82%A8%E4%B8%80%E8%B5%B7%E6%88%90%E9%95%BF&quot; aria-label=&quot;旨在与您一起成长 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; version=&quot;1.1&quot; viewbox=&quot;0 0 16 16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;/&gt;&lt;/svg&gt;&lt;/a&gt;旨在与您一起成长&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;探索 Astro 的生态系统&lt;/strong&gt;。借助包含 100 多个集成和主题的生态系统，充分利用 Astro。社区包可以轻松地向您的项目添加新功能，以提高性能、SEO、分析、可访问性等。&lt;/p&gt;&lt;h3 id=&quot;专为所有人设计&quot;&gt;&lt;a href=&quot;#%E4%B8%93%E4%B8%BA%E6%89%80%E6%9C%89%E4%BA%BA%E8%AE%BE%E8%AE%A1&quot; aria-label=&quot;专为所有人设计 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; version=&quot;1.1&quot; viewbox=&quot;0 0 16 16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;/&gt;&lt;/svg&gt;&lt;/a&gt;专为所有人设计&lt;/h3&gt;&lt;p&gt;Astro 社区很棒。Astro 最好的地方在于它的社区。Astro Discord 包含 5000 多个构建器，随时准备帮助您解决问题、寻找灵感，并在您使用 Astro 进行探索时获得乐趣。我们的开放治理模型允许任何人贡献并参与 Astro 的发展和维护。欢迎所有经验水平！&lt;/p&gt;&lt;p&gt;Astro 是一个&lt;strong&gt;一体化的&lt;/strong&gt; &lt;strong&gt;网络框架&lt;/strong&gt;，用于构建&lt;strong&gt;快速、以&lt;/strong&gt; &lt;strong&gt;内容为中心的网站&lt;/strong&gt;。为什么选择 Astro 而不是其他 Web 框架？这里有五个核心设计原则，可帮助解释构建 Astro 的原因、它要解决的问题，以及为什么 Astro 可能是您的项目或团队的最佳选择。&lt;/p&gt;&lt;ol&gt;&lt;li&gt;&lt;strong&gt;以内容为中心&lt;/strong&gt;：Astro 专为内容丰富的网站而设计。&lt;/li&gt;&lt;li&gt;&lt;strong&gt;服务器优先&lt;/strong&gt;：网站在服务器上呈现 HTML 时运行速度更快。&lt;/li&gt;&lt;li&gt;&lt;strong&gt;极速访问&lt;/strong&gt; : 应该不可能在 Astro 中建立一个缓慢的网站。&lt;/li&gt;&lt;li&gt;&lt;strong&gt;易于使用&lt;/strong&gt;：您无需成为专家即可使用 Astro 构建东西。&lt;/li&gt;&lt;li&gt;&lt;strong&gt;功能齐全但灵活&lt;/strong&gt;：超过 100 多种 Astro 集成可供选择。&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;Astro 在 Github 开源，通过 &lt;a href=&quot;https://nicelinks.site/post/6216392f2d17f22050cf1a2b&quot;&gt;npm&lt;/a&gt; 、 &lt;a href=&quot;https://nicelinks.site/post/62989af00f40a860b1599de2&quot;&gt;pnpm&lt;/a&gt; 或 yarn 来安装，即可在本地启动并运行一个新的 Astro 项目。如果您从事前端开发，或意欲构建&lt;strong&gt;内容丰富的网站&lt;/strong&gt;，建议移步 &lt;a href=&quot;https://docs.astro.build/en/getting-started/&quot;&gt;Astro 入门教程&lt;/a&gt; ，从而了解更多。&lt;/p&gt;&lt;p&gt;── 出自&lt;a href=&quot;https://nicelinks.site/post/63788ad1049fa51046c4a5bd&quot;&gt;倾城之链 - Astro | Build faster websites&lt;/a&gt;&lt;/p&gt;&lt;p&gt;对倾城之链感兴趣的朋友，可通过 Web，小程序，快应用等渠道进行访问(后续将支持更多，如 VsCode 插件，Chrome 扩展等)。您有任何问题，欢迎随时向我们反馈（您可以通过官网反馈渠道，或添加如下客服微信），🤲 。&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;https://image.nicelinks.site/%E5%80%BE%E5%9F%8E%E4%B9%8B%E9%93%BE-%E5%BE%AE%E4%BF%A1-mini.jpeg&quot; alt=&quot;倾城之链 - 客服微信&quot;/&gt;&lt;/p&gt;&lt;h2 id=&quot;本期文末寄语&quot;&gt;&lt;a href=&quot;#%E6%9C%AC%E6%9C%9F%E6%96%87%E6%9C%AB%E5%AF%84%E8%AF%AD&quot; aria-label=&quot;本期文末寄语 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; version=&quot;1.1&quot; viewbox=&quot;0 0 16 16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;/&gt;&lt;/svg&gt;&lt;/a&gt;本期文末寄语&lt;/h2&gt;&lt;p&gt;将欲取天下而为之，吾见其不得已。天下神器，不可为也，不可执也。为者败之，执者失之。是以圣人无为，故无败，故无失。夫物或行或随；或觑或吹；或强或羸；或载或隳。是以圣人去甚、去奢、去泰。── 春秋末期人 · 老子李耳《道德经》第二十九章&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;&lt;a href=&quot;https://nicelinks.site/?utm_source=weekly&quot;&gt;倾城之链&lt;/a&gt;作为一个开放平台，旨在云集全球&lt;strong&gt;优秀网站&lt;/strong&gt;，探索互联网中更广阔的世界；在这里，你可以轻松发现、学习、分享更多有用或有趣的事物。&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;img src=&quot;https://image.nicelinks.site/nicelinks-miniprogram-code.jpeg?imageView2/1/w/250/h/250/interlace/1/ignore-error/1&quot; alt=&quot;小程序码 - 倾城之链&quot;/&gt;&lt;/p&gt;&lt;h2 id=&quot;您可能感兴趣的文章&quot;&gt;&lt;a href=&quot;#%E6%82%A8%E5%8F%AF%E8%83%BD%E6%84%9F%E5%85%B4%E8%B6%A3%E7%9A%84%E6%96%87%E7%AB%A0&quot; aria-label=&quot;您可能感兴趣的文章 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; version=&quot;1.1&quot; viewbox=&quot;0 0 16 16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;/&gt;&lt;/svg&gt;&lt;/a&gt;您可能感兴趣的文章&lt;/h2&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>8996ce078a932b6dc5edea93daf14f93</guid>
<title>重塑认识 Java 编译器的执行过程（消除数组边界检查 + 公共子表达式）</title>
<link>https://toutiao.io/k/ixhipj5</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div id=&quot;content_views&quot; class=&quot;markdown_views prism-tomorrow-night&quot;&gt;
                    &lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot;&gt;
                        &lt;path stroke-linecap=&quot;round&quot; d=&quot;M5,0 0,2.5 5,5z&quot; id=&quot;raphael-marker-block&quot;/&gt;
                    &lt;/svg&gt;
                    &lt;h2&gt;&lt;a id=&quot;_0&quot;/&gt;前提概要&lt;/h2&gt; 
&lt;p&gt;Java的class字节码并不是机器语言，要想让机器能够执行，还需要把字节码翻译成机器指令。这个过程是Java虚拟机做的，这个过程也叫编译。是更深层次的编译。&lt;/p&gt; 
&lt;p&gt;在编译原理中，把源代码翻译成机器指令，一般要经过以下几个重要步骤：&lt;/p&gt; 
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/img_convert/3112940a532e8df1a143064fad3ae5fe.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt; 
&lt;p&gt;根据完成任务不同，可以将编译器的组成部分划分为前端（Front End）与后端（Back End）。&lt;/p&gt; 
&lt;blockquote&gt; 
 &lt;p&gt;&lt;strong&gt;前端编译主要指与源语言有关但与目标机无关的部分，包括词法分析、语法分析、语义分析与中间代码生成。&lt;/strong&gt;&lt;/p&gt; 
 &lt;p&gt;&lt;strong&gt;后端编译主要指与目标机有关的部分，包括代码优化和目标代码生成等。&lt;/strong&gt;&lt;/p&gt; 
&lt;/blockquote&gt; 
&lt;p&gt;&lt;strong&gt;我们可以把将&lt;code&gt;.java&lt;/code&gt;文件编译成&lt;code&gt;.class&lt;/code&gt;的编译过程称之为前端编译。把将&lt;code&gt;.class&lt;/code&gt;文件翻译成机器指令的编译过程称之为后端编译。&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/img_convert/d9e0fcd631ff75cbbfddecc05fa1355a.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt; 
&lt;h2&gt;&lt;a id=&quot;Java_18&quot;/&gt;Java中的前端编译&lt;/h2&gt; 
 
&lt;h3&gt;&lt;a id=&quot;_24&quot;/&gt;词法分析&lt;/h3&gt; 
 
&lt;h3&gt;&lt;a id=&quot;_30&quot;/&gt;语法分析&lt;/h3&gt; 
&lt;blockquote&gt; 
 &lt;p&gt;&lt;strong&gt;语法分析的任务是在词法分析的基础上将单词序列组合成各类语法短语，如“程序”，“语句”，“表达式”等等，语法分析程序判断源程序在结构上是否正确。源程序的结构由上下文无关文法描述。&lt;/strong&gt;&lt;/p&gt; 
&lt;/blockquote&gt; 
&lt;h3&gt;&lt;a id=&quot;_34&quot;/&gt;语义分析&lt;/h3&gt; 
 
&lt;h3&gt;&lt;a id=&quot;_40&quot;/&gt;中间代码生成&lt;/h3&gt; 
&lt;p&gt;在源程序的语法分析和语义分析完成之后，很多编译器生成一个明确的低级的或类机器语言的中间表示。该中间表示有两个重要的性质： 1.易于生成； 2.能够轻松地翻译为目标机器上的语言。&lt;/p&gt; 
&lt;p&gt;在Java中，&lt;code&gt;javac&lt;/code&gt;执行的结果就是得到一个字节码，而这个字节码其实就是一种中间代码。&lt;/p&gt; 
&lt;blockquote&gt; 
 &lt;p&gt;&lt;strong&gt;著名的解语法糖操作，也是在javac中完成的。&lt;/strong&gt;&lt;/p&gt; 
&lt;/blockquote&gt; 
&lt;h2&gt;&lt;a id=&quot;Java_48&quot;/&gt;Java中的后端编译&lt;/h2&gt; 
&lt;p&gt;首先，我们大家都知道，通常通过 &lt;code&gt;javac&lt;/code&gt; 将程序源代码编译，转换成 java 字节码，JVM 通过解释字节码将其翻译成对应的机器指令，逐条读入，逐条解释翻译。很显然，经过解释执行，其执行速度必然会比可执行的二进制字节码程序慢很多。这就是传统的JVM的**解释器（Interpreter）**的功能。为了解决这种效率问题，引入了 &lt;strong&gt;JIT&lt;/strong&gt; 技术。&lt;/p&gt; 
&lt;p&gt;JAVA程序还是通过解释器进行解释执行，当JVM发现某个方法或代码块运行特别频繁的时候，就会认为这是“热点代码”（Hot Spot Code)。然后JIT会把部分“热点代码”&lt;strong&gt;翻译&lt;/strong&gt;成本地机器相关的机器码，并进行&lt;strong&gt;优化&lt;/strong&gt;，然后再把翻译后的机器码&lt;strong&gt;缓存&lt;/strong&gt;起来，以备下次使用。&lt;/p&gt; 
&lt;p&gt;HotSpot虚拟机中内置了两个JIT编译器：Client Complier和Server Complier，分别用在客户端和服务端，目前主流的HotSpot虚拟机中默认是采用解释器与其中一个编译器直接配合的方式工作。&lt;/p&gt; 
&lt;p&gt;当 JVM 执行代码时，它并不立即开始编译代码。首先，如果这段代码本身在将来只会被执行一次，那么从本质上看，编译就是在浪费精力。因为将代码翻译成 java 字节码相对于编译这段代码并执行代码来说，要快很多。第二个原因是最优化，当 JVM 执行某一方法或遍历循环的次数越多，就会更加了解代码结构，那么 JVM 在编译代码的时候就做出相应的优化。&lt;/p&gt; 
&lt;h3&gt;&lt;a id=&quot;_58&quot;/&gt;热点检测&lt;/h3&gt; 
&lt;p&gt;上面我们说过，要想触发JIT，首先需要识别出热点代码。目前主要的热点代码识别方式是热点探测（Hot Spot Detection），有以下两种：&lt;/p&gt; 
&lt;ol&gt;&lt;li&gt; &lt;p&gt;基于采样的方式探测（Sample Based Hot Spot Detection) ：周期性检测各个线程的栈顶，发现某个方法经常出险在栈顶，就认为是热点方法。好处就是简单，缺点就是无法精确确认一个方法的热度。容易受线程阻塞或别的原因干扰热点探测。&lt;/p&gt; &lt;/li&gt;&lt;li&gt; &lt;p&gt;基于计数器的热点探测（Counter Based Hot Spot Detection)。采用这种方法的虚拟机会为每个方法，甚至是代码块建立计数器，统计方法的执行次数，某个方法超过阀值就认为是热点方法，触发JIT编译。&lt;/p&gt; &lt;/li&gt;&lt;/ol&gt; 
&lt;p&gt;在HotSpot虚拟机中使用的是第二种——基于计数器的热点探测方法，因此它为每个方法准备了两个计数器：方法调用计数器和回边计数器。&lt;/p&gt; 
 
&lt;h3&gt;&lt;a id=&quot;_72&quot;/&gt;编译优化&lt;/h3&gt; 
&lt;p&gt;前面提到过，JIT除了具有缓存的功能外，还会对代码做各种优化。说到这里，不得不佩服HotSpot的开发者，他们在JIT中对于代码优化真的算是面面俱到了。&lt;/p&gt; 
&lt;p&gt;这里简答提及几个我觉得比较重要的优化技术，并不准备直接展开，读者感兴趣的话，我后面再写文章单独介绍。&lt;/p&gt; 
&lt;blockquote&gt; 
 &lt;p&gt;&lt;strong&gt;逃逸分析、 锁消除、 锁膨胀、 方法内联、 空值检查消除、 类型检测消除、 公共子表达式消除&lt;/strong&gt;&lt;/p&gt; 
&lt;/blockquote&gt; 
&lt;h4&gt;&lt;a id=&quot;_80&quot;/&gt;公共子表达式消除&lt;/h4&gt; 
&lt;blockquote&gt; 
 &lt;p&gt;&lt;strong&gt;公共子表达式消除是一项非常经典的、普遍应用于各种编译器的优化技术，它的含义是： 如果一个表达式E之前已经被计算过了，并且从先前的计算到现在E中所有变量的值都没有发生变化，那么E的这次出现就称为公共子表达式。&lt;/strong&gt;&lt;/p&gt; 
&lt;/blockquote&gt; 
 
&lt;h5&gt;&lt;a id=&quot;_88&quot;/&gt;如下代码：&lt;/h5&gt; 
&lt;pre&gt;&lt;code class=&quot;prism language-java&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;int&lt;/span&gt; d &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt; c &lt;span class=&quot;token operator&quot;&gt;*&lt;/span&gt; b &lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;12&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;+&lt;/span&gt; a &lt;span class=&quot;token operator&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt; a &lt;span class=&quot;token operator&quot;&gt;+&lt;/span&gt; b &lt;span class=&quot;token operator&quot;&gt;*&lt;/span&gt; c &lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt; 
&lt;p&gt;如果这段代码交给 Javac 编译器则不会进行优化，那么生成的代码将如下所示：&lt;/p&gt; 
&lt;pre&gt;&lt;code&gt;iload_2        // b
imul           // 计算 b * c
bipush 12      // 推入 12
imul           // 计算 ( c * b ) * 12
iload_1        // a
iadd           // 计算 ( c * b ) * 12 + a
iload_1        // a
iload_2        // b
iload_3        // c
imul           // 计算 b * c
iadd           // 计算 a + b * c
iadd           // 计算 ( c * b ) * 12 + a + a + b * c
istore 4
&lt;/code&gt;&lt;/pre&gt; 
&lt;blockquote&gt; 
 &lt;p&gt;&lt;strong&gt;是完全按照遵照 Java 源码的写法直译而成的。&lt;/strong&gt;&lt;/p&gt; 
&lt;/blockquote&gt; 
&lt;blockquote&gt; 
 &lt;p&gt;&lt;strong&gt;当这段代码进人虚拟机即时编译器后，它将进行如下优化：编译器检测到 c * b 与 b * c 是一样的表达式， 而且在计算期间 b 与 c 的值是不变的。&lt;/strong&gt;&lt;/p&gt; 
&lt;/blockquote&gt; 
&lt;h5&gt;&lt;a id=&quot;_115&quot;/&gt;因此这条表达式就可能被视为:&lt;/h5&gt; 
&lt;pre&gt;&lt;code class=&quot;prism language-java&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;int&lt;/span&gt; d &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;E&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;12&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;+&lt;/span&gt; a &lt;span class=&quot;token operator&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt; a &lt;span class=&quot;token operator&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;E&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt; 
&lt;blockquote&gt; 
 &lt;p&gt;&lt;strong&gt;这时候、编译器还可能(取决于哪种虚拟机的编译器以及具体的上下文而定)进行另外一种优化——代数化简 (Algebraic Simplification) ， 在E本来就有乘法运算的前提下， 把表达式变为:&lt;/strong&gt;&lt;/p&gt; 
&lt;/blockquote&gt; 
&lt;pre&gt;&lt;code class=&quot;prism language-java&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;int&lt;/span&gt; d &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;E&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;13&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;+&lt;/span&gt; a &lt;span class=&quot;token operator&quot;&gt;+&lt;/span&gt; a&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt; 
&lt;blockquote&gt; 
 &lt;p&gt;&lt;strong&gt;表达式进行变换之后，再计算起来就可以节省一些时间了。&lt;/strong&gt;&lt;/p&gt; 
&lt;/blockquote&gt; 
&lt;h4&gt;&lt;a id=&quot;_129&quot;/&gt;数组边界检查消除&lt;/h4&gt; 
&lt;blockquote&gt; 
 &lt;p&gt;&lt;strong&gt;数组边界检查消除 ( Array Bounds Checking Elimination) 是即时编译器中的一项语言相关的经典优化技术。我们知道Java语言是一门动态安全的语言，对数组的读写访问也不像 C、C++ 那样实质上就是裸指针操作。&lt;/strong&gt;&lt;/p&gt; 
&lt;/blockquote&gt; 
&lt;ul&gt;&lt;li&gt; &lt;p&gt;&lt;strong&gt;如果有一个数组 a[]，在Java语言中访问数组元素 foo[i] 的时候系统将会自动进行上下界的范围检查，即 i 必须满足 &quot; i &amp;gt;= 0 &amp;amp;&amp;amp; i &amp;lt; a.length &quot; 的访问条件，否则将抛出一个运行时异常: java.lang.ArrayIndexOutOfBondsException&lt;/strong&gt;。&lt;/p&gt; &lt;/li&gt;&lt;li&gt; &lt;p&gt;&lt;strong&gt;这对软件开发者来说是一件很友好的事情，即使程序员没有专门编写防御代码，也能够避免大多数的溢出攻击。但是对于虚拟机的执行子系统来说，每次数组元素的读写都带有一次隐含的条件判定操作，对于拥有大量数组访问的程序代码，这必定是一种性能负担&lt;/strong&gt;。&lt;/p&gt; &lt;/li&gt;&lt;/ul&gt; 
&lt;p&gt;无论如何，为了安全，数组边界检查肯定是要做的，但数组边界检查是不是必须在运行期间一次不漏地进行则是可以 “商量” 的事情。例如下面这个简单的情况: 数组下标是一个常量，如 a[3]，只要在编译期根据数据流分析来确定 foo.length 的值，并判断下标 “3” 没有越界，执行的时候就无须判断了。更加常见的情况是，数组访问发生在循环之中，并且使用循环变量来进行数组的访问。&lt;/p&gt; 
&lt;blockquote&gt; 
 &lt;p&gt;&lt;strong&gt;如果编译器只要通过数据流分析就可以判定循环变量的取值范围永远在区间 [ 0，a.length ) 之内，那么在循环中就可以把整个数组的上下界检查消除掉，这可以节省很多次的条件判断操作。&lt;/strong&gt;&lt;/p&gt; 
&lt;/blockquote&gt; 
&lt;ul&gt;&lt;li&gt; &lt;p&gt;把这个数组边界检查的例子放在更高的视角来看，大量的安全检查使编写 Java 程序比编写 C 和 C++ 程序容易了很多，比如: 数组越界会得到ArrayIndexOutfBoundsExcepion 异常；空指针访问会得到 NullPointExceptioen 异常；除数为零会得到 ArithmeticExceptinon 异常…在和C++程序中出现类似的问题，一个不小心就会出现 Segment Fault 信号或者 Windows 编程中常见的 “XXX内存不能为 Read/Write” 之类的提示，处理不好程序就直接崩溃退出了。&lt;/p&gt; &lt;/li&gt;&lt;li&gt; &lt;p&gt;但这些安全检查也导致出现相同的程序，从而使 Java 比 C 和 C++ 要做更多的事情(各种检查判断)，这些事情就会导致一些隐式开销， 如果不处理好它们，就很可能成为一项 “ Java语言天生就比较慢” 的原罪。为了消除这些隐式开销，除了如数组边界检查优化这种尽可能把运行期检查提前到编译期完成的思路之外、还有一种避开的处理思路——隐式异常处理， Java中空指针检查和算术运算中除数为零的检查都采用了这种方案。&lt;/p&gt; &lt;/li&gt;&lt;/ul&gt; 
&lt;blockquote&gt; 
 &lt;p&gt;&lt;strong&gt;举个例子，程序中访问一个对象(假设对象叫 a )的某个属性(假设属性叫 value )，那以 Java 伪代码来表示虚拟机访问 a.value 的过程为:&lt;/strong&gt;&lt;/p&gt; 
&lt;/blockquote&gt; 
&lt;pre&gt;&lt;code class=&quot;prism language-java&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;foo &lt;span class=&quot;token operator&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;return&lt;/span&gt; foo&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;value&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token keyword&quot;&gt;else&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;throw&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;NullPointException&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt; 
&lt;blockquote&gt; 
 &lt;p&gt;&lt;strong&gt;在使用隐式异常优化之后，虚拟机会把上面的伪代码所表示的访问过程变为如下伪代码:&lt;/strong&gt;&lt;/p&gt; 
&lt;/blockquote&gt; 
&lt;pre&gt;&lt;code class=&quot;prism language-java&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;try&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;return&lt;/span&gt; foo&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;value&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;catch&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;segment_fault&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
uncommon_ &lt;span class=&quot;token function&quot;&gt;trap&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt; 
&lt;ul&gt;&lt;li&gt; &lt;p&gt;虚拟机会注册一个 Segment Fault 信号的异常处理器 ( 伪代码中的uncommon_trap()，务必注意这里是指进程层面的异常处理器，并非真的 Java 的 try-catch 语句的异常处理器)，这样当 a 不为空的时候，对 value 的访问是不会有任何额外对 a 判空的开销的，而代价就是当 a 真的为空时，必须转到异常处理器中恢复中断并抛出 NullPointException 异常。&lt;/p&gt; &lt;/li&gt;&lt;li&gt; &lt;p&gt;进人异常处理器的过程涉及进程从用户态转到内核态中处理的过程，结束后会再回到用户态，速度远比一次判空检查要慢得多。&lt;/p&gt; &lt;/li&gt;&lt;li&gt; &lt;p&gt;当 foo 极少为空的时候，隐式异常优化是值得的，但假如 foo 经常为空，这样的优化反而会让程序更慢。幸好 HotSpot 虚拟机足够聪明，它会根据运行期收集到的性能监控信息自动选择最合适的方案。&lt;/p&gt; &lt;/li&gt;&lt;/ul&gt;
                &lt;/div&gt;
                
                
        &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>9752fc3d3f7f8b21f1b6b3a96c4765bb</guid>
<title>干货！用大白话告诉你什么是 Mock 测试</title>
<link>https://toutiao.io/k/jaz776u</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;/&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;作为一个动词，&lt;code&gt;mock&lt;/code&gt;是模拟、模仿的意思；作为一个名词，&lt;code&gt;mock&lt;/code&gt;是能够模仿真实对象行为的模拟对象。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在软件测试中，mock所模拟的对象是什么呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;它一定不是我们所测试的对象，而是 SUT 的依赖（dependency）。换句话说，mock 的作用是模拟 SUT 依赖对象的行为。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;测试的对象一般称之为&lt;code&gt;SUT(Software Under Test)&lt;/code&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;文字不好理解，我们画个图，如下图所示，被测试对象是 A，A 依赖的是B，B 依赖的是 C。而我们要 mock 的是 B 的行为。图中 A 就是 SUT。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-cropselx1=&quot;0&quot; data-cropselx2=&quot;300&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;181&quot; data-ratio=&quot;0.6047058823529412&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/RXvHpViaz3EoWW98ZaJgrfic2JCjFKhWicyib3ul5U3tutWsPAp9d3ewq4zgEO9R7sfjzudbCN3h7NghlVXYu74Low/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;850&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;为什么需要模拟 B 的行为呢？&lt;/strong&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;（1）提高 A 的测试覆盖率。A 依赖 B，本质上依赖的是 B 的返回结果，也就是说 B 的返回结果会影响 A 的行为。通过 mock B 我们可以构造各种正常和异常的来自 B 的返回结果，从而更充分测试 A 的行为。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;（2）避免 B 的因素从而对 A 产生影响。依赖真实的 B 去测试 A 可能有很多问题：B 的开发没有完成时无法测试 A；B 有阻塞性bug 时无法测试 A；B 的依赖 C 有阻塞性 bug 时无法测试 A；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;（3）提高 A 的测试效率。B 的真实行为可能很慢，而 B 的模拟行为是非常快的，因此可以加快 A 的测试执行速度。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;mock 种族&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;常见的 mock 类型如下图所示：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-cropselx1=&quot;0&quot; data-cropselx2=&quot;300&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;283&quot; data-ratio=&quot;0.9441340782122905&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/RXvHpViaz3EoWW98ZaJgrfic2JCjFKhWicyTeZXrZW5lbNsXMYpu1HvsRBx1Ir6gL128V3s56fvUBnhb1g83wafew/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;716&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;从下往上依次解释一下：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;（1）&lt;code&gt;方法级别 mock&lt;/code&gt;：mock 的对象是一个函数调用，例如获取系统环境变量。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;（2）&lt;code&gt;类级别 mock&lt;/code&gt;：mock 的对象是一个类，例如一个 HTTP server。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;（3）&lt;code&gt;接口级别 mock&lt;/code&gt;：mock 的对象是一个 API 接口。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;（4）&lt;code&gt;服务级别 mock&lt;/code&gt;：mock 的对象是整个服务。比如前端工程师自测试时，可以讲后端整个服务都 mock 掉，这其实等同于将后端的所有接口都 mock。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;接口mock注入的五种方式&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在使用 mock 进行接口测试时，一般要做两件事情，即&lt;code&gt;打桩&lt;/code&gt;和&lt;code&gt;调桩&lt;/code&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其实&lt;code&gt;打桩&lt;/code&gt;就是创建mock 桩，指定 API 请求内容及其映射的 mock 响应内容；所谓&lt;code&gt;调桩&lt;/code&gt;就是被测服务来请求 mock 桩并接收 mock 响应。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;事实上，在&lt;code&gt;打桩&lt;/code&gt;和&lt;code&gt;调桩&lt;/code&gt;之间还隐藏着一件不显山露水、但是及其重要的事情，那就是 mock 桩的注入（mock injection）。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;什么是 mock 注入？&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;mock 的本质就是用&lt;code&gt;模拟桩&lt;/code&gt;来替换&lt;code&gt;真实的依赖&lt;/code&gt;。所谓 &lt;code&gt;mock 桩注入&lt;/code&gt;就是阻断被测服务与真实服务之间的链路，建立被测服务与 mock 之间的链路过程。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-cropselx1=&quot;0&quot; data-cropselx2=&quot;400&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;195&quot; data-ratio=&quot;0.4879120879120879&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/RXvHpViaz3EoWW98ZaJgrfic2JCjFKhWicynmQuHDTQhqNjQrtiaeVPyIN4Zwb35KmugmOtwUAdnphibSA5rp6oJ01A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;910&quot;/&gt;&lt;/figure&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;如何注入 mock？&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;总的来说 mock 桩的注入方式与架构、被测服务的架构等因素相关，在实际中常见的 mock 桩注入方式包括但不限于以下五种。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;（1）API 请求构造&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在 mock 接口中被测服务是 API 的请求方，即客户端；依赖服务是 API 的响应方，即服务端。根据 mock 工作的位置，mock 可以分为&lt;code&gt;客户端 mock&lt;/code&gt; 和&lt;code&gt;服务端 mock&lt;/code&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;客户端 mock&lt;/code&gt;：mock 在被测服务内部工作，直接拦截被测服务的 API 请求方法（比如 HTTP Client方法），在被测服务调用 API 请求方法时，直接从方法内部返回预定义的 mock 响应。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;服务端 mock&lt;/code&gt;：mock 在被测服务外部工作，作为 HTTP 服务器接收被测服务发送的 API 请求，并返回预定义的 mock 响应。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;客户端 mock 的注入其实就是改造被测服务的 API 请求方法，即在 API 请求方法中加入 mock 处理逻辑。当满足某些条件时执行 mock 分支，不满足时执行真实分支。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可以通过两种方式实现，&lt;code&gt;一种是直接改造源代码&lt;/code&gt;，&lt;code&gt;另一种是利用字节码增强技术对字节码进行改造（Java 语言）&lt;/code&gt;。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-cropselx1=&quot;0&quot; data-cropselx2=&quot;400&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;167&quot; data-ratio=&quot;0.4173387096774194&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/RXvHpViaz3EoWW98ZaJgrfic2JCjFKhWicy1r3wzS4XnoEVqiaHmLDFZAdWcGx3HWMOACeqQcVBQonX5V3UPdCjQ5Q/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;992&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;API 请求改造这种注入方式适用于客户端 mock，其优势性能极好，其不足是实现成本较高。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;（2）本地配置&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;对于服务端 mock，打桩之后会生成唯一的 mock 桩地址。被测服务要想调用这个桩需要知道桩地址，如何让被测服务知道桩地址呢？一种最直接的方法就是被测服务提供一个依赖服务地址配置项，在需要使用 mock 时将依赖服务地址修改成 mock 地址。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;本地配置的优势是实现简单，不足之处是修改配置项&lt;code&gt;需要重启&lt;/code&gt;被测服务，在需要进行 mock 服务与真实服务切换时不方便。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-cropselx1=&quot;0&quot; data-cropselx2=&quot;400&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;181&quot; data-ratio=&quot;0.45286885245901637&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/RXvHpViaz3EoWW98ZaJgrfic2JCjFKhWicyt0ugVBwOLzmBYY6AwnVSKd2PbGAOZFD2oRNBmBGBxGJBhvG0xSgh9w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;976&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;（3）配置中心&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在服务端 mock 中，为了避免修改依赖服务地址配置项导致被测服务重启，可以采用配置中心（如 Spring Cloud Config Server）存储和管理依赖服务地址配置，或者使用注册中心（如 Spring Cloud Eureka）记录服务与服务地址的映射关系。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;使用配置或者注册中心时，mock 注入的方法是修改配置中心，将依赖服务地址改成 mock 地址。这种注入方法不需要重启被测服务，但是从配置改变到配置生效可以&lt;code&gt;存在一定的延时&lt;/code&gt;。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-cropselx1=&quot;0&quot; data-cropselx2=&quot;400&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;224&quot; data-ratio=&quot;0.5612244897959183&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/RXvHpViaz3EoWW98ZaJgrfic2JCjFKhWicycInn9lZIqjnJM1icfR4IMtcia0u9Licibib9B23U0ic7WpAiazd8JcibhticJ8A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;980&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;（4）反向代理&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在微服务架构下，被测服务与依赖服务之间可能不是直连的，而是经过了一层反向代理，例如 API 网关。在这种情况下，被测服务是通过调用 API 网关来间接调用依赖服务的接口。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在 API 网关模式下，mock 注入的具体做法就是修改 API 网关配置，将依赖服务 API 网关接口绑定的地址改成 mock 地址。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这种注入的优势是对被测服务&lt;code&gt;无侵入&lt;/code&gt;，并且实现更细粒度（接口级）的 mock。当然，根据 API 网关的实现不同，仍然可能&lt;code&gt;存在一定的时延&lt;/code&gt;。亚马逊 AWS 的 API 网关就是采用这种方式进行 mock。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-cropselx1=&quot;0&quot; data-cropselx2=&quot;450&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;148&quot; data-ratio=&quot;0.3286118980169972&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/RXvHpViaz3EoWW98ZaJgrfic2JCjFKhWicytSAGGbUKPmpHmSk3LkjOvRA9vkIiaAAqNDd9R0QuVyUpygIFmhyrPCQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1412&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;（5）前向代理&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;服务端 mock 除了作为 HTTP 服务器，还可以兼备 HTTP 代理的功能，这种架构又叫做 &lt;code&gt;mock 代理&lt;/code&gt;，例如 &lt;code&gt;mock server proxy&lt;/code&gt;。对于 mock 代理来说，它不仅能够返回 mock 响应，而且能够在需要的时候将 API 请求转发给依赖服务，并将依赖服务的真实响应返回给被测服务。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;使用前向代理模式，mock 注入的方式是将被测服务的依赖地址或网络代理修改为 mock 地址，这种注入方法&lt;code&gt;需要重启被测服务&lt;/code&gt;，其优势是能够实现细粒度的 mock，并且能够根据录制的真实响应自动生成 mock。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-cropselx1=&quot;0&quot; data-cropselx2=&quot;400&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;104&quot; data-ratio=&quot;0.260932944606414&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/RXvHpViaz3EoWW98ZaJgrfic2JCjFKhWicy8oJu3Rsnrnwib9Jr78QIibJBkria9ickIkpZA4haaQdcQRmNBUNQwnWibpQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1372&quot;/&gt;&lt;/figure&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;五种注入方式对比&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;一张表格总结一下&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-cropselx1=&quot;0&quot; data-cropselx2=&quot;400&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;169&quot; data-ratio=&quot;0.4227353463587922&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/RXvHpViaz3EoWW98ZaJgrfic2JCjFKhWicygdbqRicIL7UicibOJzjqIM8WalMmmgbjHxTepM8K2oziabrdyyM7nPVW8Q/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1126&quot;/&gt;&lt;/figure&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;不可忽视的mock两大功能&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;关于 mock，经常容易被误解的是：认为 mock 只是模拟返回的结果而已。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;实际上 mock 还可以提供两大功能：（1）记录真实的调用信息；（2）生成模拟的返回信息；&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-cropselx1=&quot;0&quot; data-cropselx2=&quot;500&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;190&quot; data-ratio=&quot;0.3797250859106529&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/RXvHpViaz3EoWW98ZaJgrfic2JCjFKhWicyykCYMYey1jAG2tiaRgqgLOmr8YfdCLLeLKY4sjibnyKQw57ThBpmmvOg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1164&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;对于测试用例来说，我们不仅关心 mock 是否返回了期望的结果，还需要关心 SUT 是否以期望的方式调用了 mock 对象。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果 SUT 没有以期望的方式调用，比如：没有传参或者参数不对，那么 SUT 就存在问题。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;mock 需要详细记录来自SUT 的调用信息，并提供给用例来校验。比如 &lt;code&gt;Java mockito&lt;/code&gt; 就提供了此类校验功能：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;List&amp;lt;String&amp;gt; mockedList = mock(MyList&lt;span&gt;.&lt;span&gt;class&lt;/span&gt;)&lt;/span&gt;;&lt;br/&gt;mockedList.size();&lt;br/&gt;&lt;span&gt;// 校验 size 函数调用且只调用了1次&lt;/span&gt;&lt;br/&gt;verify(mockedList, times(&lt;span&gt;1&lt;/span&gt;)).size();&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;常用 mock 工具&lt;/h1&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;单元测试级别&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个级别的mock工具有easymock、jMock、Mockito、Unitils Mock、PowerMock、JMockit等，关于各自优劣势大家可以上网查询。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;接口测试级别&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;接口级别的mock工具完成的主要功能是对一个用户的请求，模拟server返回一个接口的响应数据。常用的有：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;Wiremock&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Mockserver&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Moco&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Mock.js&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;RAP&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;mock 不是银弹&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;说了这么多 mock 的好处，实际上 mock 也有很多不足，比如：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;（1）mock 可能导致问题遗漏。mock 的模拟行为与真实行为可能存在 GAP，导致基于 mock 的测试虽然通过了，但是基于真实对象的测试却失败了，这意味着问题被遗漏了。mock 很难模拟所有的真实情况。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;（2）mock 带来较高的维护成本。基于 mock 的测试用例结构比较复杂，实现和维护都不容易，后期被测代码有变动时需要适配 mock 代码。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;简单一句话：mock 不是银弹。&lt;/p&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;有态度的总结&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;mock 不是银弹，mock 是有利有弊的，一张图总结一下：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-cropselx1=&quot;0&quot; data-cropselx2=&quot;400&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;186&quot; data-ratio=&quot;0.46459412780656306&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/RXvHpViaz3EoWW98ZaJgrfic2JCjFKhWicyzajBH6pmLkVvsFMFvYDgaAXJxInS1WRSWsOIia8jRzuiclz23BSd2Cew/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1158&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;说了这么多，在工作中如何正确使用 mock 呢？这里提两点建议，敲黑板啦。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;（1）不要过度使用 mock。测试用例中掌握好使用 mock 的度。在涉及网络访问、数据库读写、操作系统交互等系统级调用，优先使用 mock。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;（2）不要过度依赖基于 mock 的测试结果。基于 mock 的测试无论多么充分，这都不能保证不出现问题的遗漏。一个完整的测试策略一定是由基于 mock 的测试和基于非 mock 的测试共同组成的，二者相辅相成缺一不可。&lt;/p&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>b9ecfcb0d867e4e3349d9e683015cf1f</guid>
<title>独立开发变现周刊（第81期）：开发一个应用来减少屏幕使用时间，月收入 2 万美元</title>
<link>https://toutiao.io/k/wzlxohy</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;markdown-body-box nuxt-content&quot;&gt;&lt;h1 id=&quot;独立开发变现周刊第81期开发一个应用来减少屏幕使用时间月收入2万美元&quot;&gt;&lt;a href=&quot;#%E7%8B%AC%E7%AB%8B%E5%BC%80%E5%8F%91%E5%8F%98%E7%8E%B0%E5%91%A8%E5%88%8A%E7%AC%AC81%E6%9C%9F%E5%BC%80%E5%8F%91%E4%B8%80%E4%B8%AA%E5%BA%94%E7%94%A8%E6%9D%A5%E5%87%8F%E5%B0%91%E5%B1%8F%E5%B9%95%E4%BD%BF%E7%94%A8%E6%97%B6%E9%97%B4%E6%9C%88%E6%94%B6%E5%85%A52%E4%B8%87%E7%BE%8E%E5%85%83&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;span class=&quot;icon icon-link&quot;/&gt;&lt;/a&gt;独立开发变现周刊（第81期）：开发一个应用来减少屏幕使用时间，月收入2万美元&lt;/h1&gt;
&lt;p&gt;分享独立开发、产品变现相关内容，每周五发布。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;目录&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;1、组件世界 WidgetStore：一个丰富、强大的嵌入式小组件库&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;2、Distill Web Monitor: 监控网页任意区域变化，并发出实时提醒的工具&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;3、Water Hero: 饮水追踪和提醒&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;4、Guidde: 快速创建工作流教程视频&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;5、开发一个应用来减少屏幕使用时间，月收入达到2万美元&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;一个服务于 Notion 类产品、双链笔记类产品、代码托管平台「GitHub 等」、博客系统「WordPress」以及为知笔记等文本编辑器的可嵌入式小组件库。辅助用户建立个性化、可视化的仪表盘或者知识库的工具。&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;https://tva1.sinaimg.cn/large/008vxvgGly1h8fyosup96j30v10k3myz.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;目前已经有接近 40 个基础组件。包括基础组件、动态图标、动态背景、可视化图表、Notion 汉化 等多种服务，可以为笔记用户提供适用于时间管理、任务管理、资讯管理、习惯养成、学习等多种使用场景的解决方案。比如，在基础组件中包括天气、时钟、番茄钟、倒计时、日历、纪念日、习惯打卡、访客统计、白噪音、热力图、微博热搜、百度统计埋点等多种类型等小组件。&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;https://tva1.sinaimg.cn/large/008vxvgGly1h8fyosqvgcj31wg0q6q7t.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://cn.widgetstore.net/&quot; rel=&quot;nofollow noopener noreferrer&quot; target=&quot;_blank&quot;&gt;组件世界官网体验&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;2distill-web-monitor-监控网页任意区域变化并发出实时提醒的工具&quot;&gt;&lt;a href=&quot;#2distill-web-monitor-%E7%9B%91%E6%8E%A7%E7%BD%91%E9%A1%B5%E4%BB%BB%E6%84%8F%E5%8C%BA%E5%9F%9F%E5%8F%98%E5%8C%96%E5%B9%B6%E5%8F%91%E5%87%BA%E5%AE%9E%E6%97%B6%E6%8F%90%E9%86%92%E7%9A%84%E5%B7%A5%E5%85%B7&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;span class=&quot;icon icon-link&quot;/&gt;&lt;/a&gt;2、Distill Web Monitor: 监控网页任意区域变化，并发出实时提醒的工具&lt;/h2&gt;
&lt;p&gt;是一款专门用来监控网页任意区域变化，并发出实时提醒的工具，有浏览器扩展的支持 Chrome、Firefox、Opear，以及拥有 Android 与 iOS 客户端。&lt;/p&gt;
&lt;p&gt;可以在本地运行，也可以在云端运行（付费），浏览器端通过扩展，实时（最低5秒）将变化告知用户。&lt;/p&gt;
&lt;p&gt;3步操作即可。&lt;/p&gt;
&lt;p&gt;1、通过 XPath、JavaScript、CSS Selector 三种方式来选择区域。&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;https://tva1.sinaimg.cn/large/008vxvgGly1h8fyosl0ekj31rh0u0jw1.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;2、可以设定条件&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;https://tva1.sinaimg.cn/large/008vxvgGly1h8fyosfjvzj31wi0lsaco.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;3、将变化通知到各个端，还集成了第三方的平台，Slack和Discord的集成。webhook与任何其他平台集成。&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;https://tva1.sinaimg.cn/large/008vxvgGly1h8fyosbdirj30v40gawga.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://distill.io/&quot; rel=&quot;nofollow noopener noreferrer&quot; target=&quot;_blank&quot;&gt;Distill官网&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;3water-hero-饮水追踪和提醒&quot;&gt;&lt;a href=&quot;#3water-hero-%E9%A5%AE%E6%B0%B4%E8%BF%BD%E8%B8%AA%E5%92%8C%E6%8F%90%E9%86%92&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;span class=&quot;icon icon-link&quot;/&gt;&lt;/a&gt;3、Water Hero: 饮水追踪和提醒&lt;/h2&gt;
&lt;p&gt;冬天到了，得多喝热水，保持温暖。Water Hero 帮助您保持水分。计算每日饮水量并设置推送通知提醒。这是一款Android上的应用。&lt;/p&gt;
&lt;p&gt;一些主要特点是：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;记录水的简单方法。只需向上滑动玻璃，就会记录所需的数量。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;你有 2 个选择用于记录水。分步输入，可以在其中添加最多 5 个收件人尺寸或 FreeFlow。设置想要使用的时间间隔，每次滑动到正确的水平&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;摇动以在 20 秒内取消最后一次喝水。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;推送通知 - 设置推送通知的自定义时间表。还可以选择 30 分钟到 3 小时的饮用间隔。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;计算您的每日摄入量目标。Water Hero 可以帮助估计每日水合作用需求。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;设置自定义每日摄入量目标&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;https://tva1.sinaimg.cn/large/008vxvgGly1h8fyos7ac6j31tc0q60wc.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://play.google.com/store/apps/details?id=ro.holdone.waterly&quot; rel=&quot;nofollow noopener noreferrer&quot; target=&quot;_blank&quot;&gt;Water Hero的谷歌应用商店&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;4guidde-快速创建工作流教程视频&quot;&gt;&lt;a href=&quot;#4guidde-%E5%BF%AB%E9%80%9F%E5%88%9B%E5%BB%BA%E5%B7%A5%E4%BD%9C%E6%B5%81%E6%95%99%E7%A8%8B%E8%A7%86%E9%A2%91&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;span class=&quot;icon icon-link&quot;/&gt;&lt;/a&gt;4、Guidde: 快速创建工作流教程视频&lt;/h2&gt;
&lt;p&gt;guidde是让创建工作流教程视频更简单。这是一个浏览器扩展插件，不需要设计或视频编辑技能。任何人都可以创建漂亮的软件如何制作视频，这些视频可以在60秒或更短的时间内传递你想要传递的信息的主旨。
在你的流程中发现你的团队创建的视频，而不离开你当前使用的工具。重复使用和回收视频可以节省你大量的时间。你甚至可以一起编辑和设计视频!&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;https://tva1.sinaimg.cn/large/008vxvgGly1h8fyoryvj1j31tw0q80wz.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.guidde.com/&quot; rel=&quot;nofollow noopener noreferrer&quot; target=&quot;_blank&quot;&gt;Guidde官网视频&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;5开发一个应用来减少屏幕使用时间月收入达到2万美元&quot;&gt;&lt;a href=&quot;#5%E5%BC%80%E5%8F%91%E4%B8%80%E4%B8%AA%E5%BA%94%E7%94%A8%E6%9D%A5%E5%87%8F%E5%B0%91%E5%B1%8F%E5%B9%95%E4%BD%BF%E7%94%A8%E6%97%B6%E9%97%B4%E6%9C%88%E6%94%B6%E5%85%A5%E8%BE%BE%E5%88%B02%E4%B8%87%E7%BE%8E%E5%85%83&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;span class=&quot;icon icon-link&quot;/&gt;&lt;/a&gt;5、开发一个应用来减少屏幕使用时间，月收入达到2万美元&lt;/h2&gt;
&lt;p&gt;大家好，我的名字是Martin，我是minimalist phone的开发者。这款手机应用允许人们通过温和地减少屏幕时间来优先考虑自己的心理健康。&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;https://tva1.sinaimg.cn/large/008vxvgGly1h8fz9vfa2mj30b40b474k.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我们的客户是那些花太多时间在社交媒体上的人，他们希望改善他们耗时的模式。这尤其适用于那些想要提高工作效率、戒掉社交媒体/智能手机瘾的人。&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;https://tva1.sinaimg.cn/large/008vxvgGly1h8fyort1gej30nm0da75o.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;最初的投资只有100美元用于谷歌Play开发者许可，3000美元开发了一个主页，从这些投资中，我们现在平均每月产生2万美元的收入 —— 大部分收入又花在了付费广告上。我们在谷歌Play上的下载量很快就会达到50万次，这是一个了不起的里程碑。&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;https://tva1.sinaimg.cn/large/008vxvgGly1h8fyorol2pj30rk0rqjtm.jpg&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;你是怎么想到这个想法的&quot;&gt;&lt;a href=&quot;#%E4%BD%A0%E6%98%AF%E6%80%8E%E4%B9%88%E6%83%B3%E5%88%B0%E8%BF%99%E4%B8%AA%E6%83%B3%E6%B3%95%E7%9A%84&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;span class=&quot;icon icon-link&quot;/&gt;&lt;/a&gt;你是怎么想到这个想法的?&lt;/h3&gt;
&lt;p&gt;2020年冠状病毒病爆发时，世界各地的人们采取了前所未有的社交距离和隔离措施。我们之间保持联系的唯一方式就是通过互联网。不幸的是，这只是加速了一个现有的趋势:许多人过度使用社交媒体。这些习惯导致使用者患上抑郁症和其他心理健康问题。&lt;/p&gt;
&lt;p&gt;疫情期间，我停止了自由职业的工作，找到了一份上班的工作。&lt;/p&gt;
&lt;p&gt;因为我有了很多新的空闲时间，所以我一直在玩智能手机。我注意到这很耗时——你很容易失去注意力。手机本质上是在重新训练我们的大脑:当你受到参与(点赞、评论等)的“奖励”时，会释放出化学物质(比如多巴胺)，手机正在影响我们的感知能力、表现和生产力。我最终找到了一份新工作，但这段经历决定了我如何看待花在手机上的“dead time”。&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;https://tva1.sinaimg.cn/large/008vxvgGly1h8fyorhow4j30nm0xstag.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在意识到社交媒体消费带来的所有这些问题后，我决定要解决这个问题。我喜欢编程，我想把这种热情和一些有用的东西联系起来一些可以帮助社会的东西。这时，minimalist phone的想法诞生了。&lt;/p&gt;
&lt;p&gt;我的大学背景让我接触到了心理学和机器学习。在学习软件工程时，我对计算机图形学的关注导致我开始研究彩色图像和滤镜如何影响用户，并最终让他们继续使用应用程序。了解到这一点，我基本上逆转了体验，定制了极简手机的UI为黑白。它不像颜色那样吸引眼球，所以我们没有动力花时间点击图标和滚动。&lt;/p&gt;
&lt;p&gt;&quot;最好是在朝九晚五工作之外的空闲时间工作，这样你就有了灵活性。&quot;&lt;/p&gt;
&lt;h3 id=&quot;介绍下第一个产品的设计原型和制造过程&quot;&gt;&lt;a href=&quot;#%E4%BB%8B%E7%BB%8D%E4%B8%8B%E7%AC%AC%E4%B8%80%E4%B8%AA%E4%BA%A7%E5%93%81%E7%9A%84%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%9E%8B%E5%92%8C%E5%88%B6%E9%80%A0%E8%BF%87%E7%A8%8B&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;span class=&quot;icon icon-link&quot;/&gt;&lt;/a&gt;介绍下第一个产品的设计、原型和制造过程。&lt;/h3&gt;
&lt;p&gt;首先，我们进行了开发前的用户研究。它包括问卷调查和面对面访谈，以更好地了解用户的需求。我还考虑了以前的学术研究(例如心理学)，以建立理论基础。&lt;/p&gt;
&lt;p&gt;用户研究参与者被问到的一些问题是&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;想象一下，你需要为你的手机选择一个新的主屏幕。你会选哪一个?&lt;/li&gt;
&lt;li&gt;你为什么选择这个选择?&lt;/li&gt;
&lt;li&gt;你喜欢它什么?&lt;/li&gt;
&lt;li&gt;你认为你花在手机上的时间太多了吗?&lt;/li&gt;
&lt;li&gt;你认为像这样的主屏幕能帮助你花更少的时间在手机上吗?&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;https://tva1.sinaimg.cn/large/008vxvgGly1h8fyord3qtj30nm0vi3zn.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;https://tva1.sinaimg.cn/large/008vxvgGly1h8fyor8lrmj30nm0vhq6r.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在这些截图中，你还可以看到一些从未投入生产的minimalist phone的替代设计。&lt;/p&gt;
&lt;p&gt;最初的版本在8周内就准备好了。我从这次经历中得到的教训是:专注于早期的MVP交付。你的产品不必是完美的，因为很多改进都是在发布和使用一段时间后发生的。我们很幸运，拥有一批反应积极的观众。在发布后，我们在3天的使用后收到了早期的客户反馈，我们得到了令人满意的结果。(93%的人表示，他们通过使用minimalist phone减少了花在智能手机上的时间。)&lt;/p&gt;
&lt;p&gt;我们还通过电子邮件收到了很多反馈。自首次发布以来已经两年多了，我们仍然在收到关于如何改进这款应用的建议。我们Reddit社区的见解真的很有帮助。所以:改进不是有限的，改进的过程应该是无止境的。&lt;/p&gt;
&lt;p&gt;由于用户的反馈，我们已经完成了很多改变，例如在可视化(默认字体和字体大小)方面的改进。&lt;/p&gt;
&lt;p&gt;为了不分散人们的注意力，这款应用完全没有广告。&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;https://tva1.sinaimg.cn/large/008vxvgGly1h8fyoqypjtj30nm0crab5.jpg&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;描述下启动业务的过程&quot;&gt;&lt;a href=&quot;#%E6%8F%8F%E8%BF%B0%E4%B8%8B%E5%90%AF%E5%8A%A8%E4%B8%9A%E5%8A%A1%E7%9A%84%E8%BF%87%E7%A8%8B&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;span class=&quot;icon icon-link&quot;/&gt;&lt;/a&gt;描述下启动业务的过程。&lt;/h3&gt;
&lt;p&gt;首先，应用程序发布在谷歌Play Store。付费广告在几个月后才开始出现，起初规模很小。&lt;/p&gt;
&lt;p&gt;花了两个月的时间才获得第一个付费客户。我说:“终于!”这正是你等待的“哇”时刻。&lt;/p&gt;
&lt;p&gt;你知道那种感觉吗?当你慢慢忘记为什么开始的时候。你开始感到失落，想要放弃。这就像是一次复兴。这激励着我继续下去。&lt;/p&gt;
&lt;p&gt;有一个专业的网站是必要的。虽然我是一名软件工程师和网页开发人员，但我把这项任务交给了来自乌克兰的专业设计师。他们做了很棒的工作!网站项目的价格大约是3000美元。&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;https://tva1.sinaimg.cn/large/008vxvgGly1h8fyoqt0roj31220rsag3.jpg&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;是什么有效地吸引和留住了客户&quot;&gt;&lt;a href=&quot;#%E6%98%AF%E4%BB%80%E4%B9%88%E6%9C%89%E6%95%88%E5%9C%B0%E5%90%B8%E5%BC%95%E5%92%8C%E7%95%99%E4%BD%8F%E4%BA%86%E5%AE%A2%E6%88%B7&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;span class=&quot;icon icon-link&quot;/&gt;&lt;/a&gt;是什么有效地吸引和留住了客户?&lt;/h3&gt;
&lt;p&gt;下载后，应用程序立即解释手机使用如何影响人类大脑，这有助于人们更好地理解产品的价值。最初，新手教程的内容更侧重于解释如何使用这款应用，但这款教程的用户留存率要低得多，在我们决定将所有人切换到新版本之前，我们使用了AB测试来测试两个版本的新手教程。&lt;/p&gt;
&lt;p&gt;另一个重要的工具是短回复时间的优质客户服务。这对于要求退款尤其重要——应用程序中有一个试用期，人们可以在试用期内要求退款一次性购买的产品。&lt;/p&gt;
&lt;p&gt;我们还在社交媒体平台上建立社区，比如Reddit、Instagram和Twitter，这里仅举几个例子。谷歌Play的评论、奖状和投票都是有价值的营销工具。我们与有影响力的人和youtuber合作，使用联属营销，创造我们自己的内容和新闻稿等。&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;https://tva1.sinaimg.cn/large/008vxvgGly1h8fyoqid9qj30nm0fqq4a.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我们接受了几次采访。除此之外，我们在维基百科上也有一篇文章，一个免费的百科全书。&lt;/p&gt;
&lt;p&gt;我们在应用发布6个月后开始尝试付费广告，因为在这个阶段，我们觉得应用已经准备好进行额外推广了。所有的广告活动都只在谷歌上播放，最初把人们带到minimalist phone主页上——这不是最好的主意，后来把人们直接从广告活动带到Play Store上——这比通过下载按钮进入主页要好得多。&lt;/p&gt;
&lt;p&gt;我们自己管理了半年的活动，活动进行得还不错——略有盈利，但他们的支出不足以产生显著的影响。随着时间的推移，我们意识到建立和维护一个活动是一个非常复杂的话题，额外的经验可能会带来很大的不同。我们已经决定寻找外部广告活动管理，我们已经与爱沙尼亚数字营销机构epc Digital签约。在8个月内，谷歌广告支出增长了29倍，收入增长了15倍，总ROAS(广告支出回报率)达到200%。&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;https://tva1.sinaimg.cn/large/008vxvgGly1h8fyoqdidcj30nm0k3wfg.jpg&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;你未来的机会是什么样的&quot;&gt;&lt;a href=&quot;#%E4%BD%A0%E6%9C%AA%E6%9D%A5%E7%9A%84%E6%9C%BA%E4%BC%9A%E6%98%AF%E4%BB%80%E4%B9%88%E6%A0%B7%E7%9A%84&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;span class=&quot;icon icon-link&quot;/&gt;&lt;/a&gt;你未来的机会是什么样的?&lt;/h3&gt;
&lt;p&gt;目前我们每个月的收入约为2万美元，我们将其中的65%投入到付费广告中，平均每月利润约为6500美元。最近几个月，每月的下载量增长了20 - 40%(总下载量-还不包括付费用户)。&lt;/p&gt;
&lt;p&gt;目前该应用的月下载量为5万次，总下载量近50万次。&lt;/p&gt;
&lt;p&gt;分销只能通过谷歌Play store -它高度依赖谷歌搜索和Play store发现。&lt;/p&gt;
&lt;p&gt;目前，团队有1名创始人和开发人员(我)+ 5名兼职外部人员(执行各种营销活动)。&lt;/p&gt;
&lt;p&gt;没有其他产品的计划。我认为这将分散我们发现该产品的全部潜力的注意力。我们正在新的国家开展宣传活动。目前，我们主要瞄准北美和欧洲市场。&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;https://tva1.sinaimg.cn/large/008vxvgGly1h8fyoq9hacj30nm0ayaau.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;https://tva1.sinaimg.cn/large/008vxvgGly1h8fyoq4avjj30nm0fq404.jpg&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;对其他想要起步或刚刚起步的开发者有什么建议&quot;&gt;&lt;a href=&quot;#%E5%AF%B9%E5%85%B6%E4%BB%96%E6%83%B3%E8%A6%81%E8%B5%B7%E6%AD%A5%E6%88%96%E5%88%9A%E5%88%9A%E8%B5%B7%E6%AD%A5%E7%9A%84%E5%BC%80%E5%8F%91%E8%80%85%E6%9C%89%E4%BB%80%E4%B9%88%E5%BB%BA%E8%AE%AE&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;span class=&quot;icon icon-link&quot;/&gt;&lt;/a&gt;对其他想要起步或刚刚起步的开发者有什么建议?&lt;/h3&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;https://tva1.sinaimg.cn/large/008vxvgGly1h8fyopupbsj31920u0tg1.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;对于启动项目，确保你有足够的时间来完成你的想法，并且你尝试它的“窗口”不会太短。例如，如果你辞职去实现自己的想法，但只有12个月的储蓄，那么你可能需要超过12个月的时间才能实现盈利。minimalist phone手机，它花了24个月才实现盈利。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;最好是在朝九晚五工作之外的空闲时间工作，这样你就有了灵活性。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;本次周刊结束，欢迎大家联系我推荐自己的产品，我们下周见！&lt;/p&gt;&lt;/div&gt; &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>d9107fc453ba4a56e91ee94f6c7a5125</guid>
<title>深入解读 Raft 算法与 etcd 工程实现</title>
<link>https://toutiao.io/k/7ci5xy4</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot; data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.1575&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/j3gficicyOvasIjZpiaTNIPReJVWEJf7UGpmokI3LL4NbQDb8fO48fYROmYPXUhXFN8IdDqPcI1gA6OfSLsQHxB4w/640?wx_fmt=gif&quot; data-type=&quot;gif&quot; data-w=&quot;400&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;作者：jettchen，腾讯 IEG 后台开发工程师&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;本文不对 raft 算法从头到尾细细讲解，而是以 raft 算法论文为起点，逐步解读 raft 算法的理论，帮助读者理解 raft 算法的正确性。然后，etcd 不仅是 raft 算法最为热门的工程实现，同时也是云原生 kubernetes 的核心存储，本文也对 etcd 的底层实现进行剖析，让读者在使用 etcd 组件的过程中能够做到心中有数。对 raft 算法足够熟悉的同学，也可以直接阅读 etcd 工程实现那块内容。&lt;/p&gt;&lt;/blockquote&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;1. raft 算法的简单介绍&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在 raft 算法中，每个机器节点的状态包含三种：leader、follower、candidate。系统在时间上被划分为一系列连续的任期 term，每个 term 的 leader 可以产生连续的 log，如下图所示。每个任期 term 可以选举出一个 leader，该 term 的 leader 选举出来后可以产生日志。异常情况下，一些任期 term 可能选举 leader 会失败而直接进入下一个 term，或者 leader 没有产生任何日志就超时从而进入下一个选举周期。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.35372848948374763&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/j3gficicyOvatnhl3sxFBiblZPd2r6eEjOqBzwVXgaGxXXqTbb7pkfdzIJ2oR4ricgoBn4sZoUkUhZM5ibj3dKrV1jA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1046&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;leader 节点需要将其产生的 log 复制给其他节点，当多数派节点收到 log 则表明该 log 可提交。对于集群机器更换或者扩缩容，leader 节点生成配置变更日志并且复制给其他节点来达成一致。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;从上面对 raft 算法的介绍中，可以得出 raft 需要解决以下三个问题。后续章节将围绕这三个问题剖析 raft 算法的实现。&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;raft 如何安全地选举出一个 leader？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;leader 如何将 log 安全地复制到其他节点？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;集群如何安全地变更机器节点？&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;2. leader 选举以及选举安全性&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;2.1 leader 的选举流程&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;下图是 leader 选举的流程图。节点初始化的时候，首先进入到 follower 状态，一段时间内没有收到 leader 节点的心跳就会切换到 candidate 状态去竞选 leader。节点进入到 candidate 状态后，首先将自身任期 term 加一，然后给自己投票，并且向其他节点广播 RequestVote 投票请求。candidate 竞选 leader 的结果有三种：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;拿到多数派投票，切换为 leader。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;发现其他节点已经是 leader（其任期 term 不小于自身 term），则切换为 follower。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;选举超时后重来一遍选举流程（比如多个 candidate 同时参与竞选 leader 导致每个 candidate 都拿不到多数派投票）。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.41678726483357453&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/j3gficicyOvatnhl3sxFBiblZPd2r6eEjOq0sHKOjzgOXJPFnficYX0l8gtDe6es30X7TWVyE3PrXkPAAxx0zuSejA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1382&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;candidate 每次选举时都会设置随机的选举超时时间，避免一直有多个 candidate 同时参与竞选。candidate 竞选成为 leader 后，就不停地向其他节点广播心跳请求，以维持自己的 leader 状态同时也为了阻止其他节点切换为 candidate 去竞选 leader。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;另外有一种异常情况，比如某个机器网络故障导致它一直收不到 leader 的心跳消息，那它就会切换到 candidate 状态，并且会一直选举超时，那它就会一直增加自身的任期 term，当网络恢复正常的时候，原有 leader 就会收到较高任期 term 的请求从而被迫切换到 follower 状态，这样就会影响到整个集群的稳定性。因此在工程实现的时候，candidate 都会增加一个 preVote 预投票阶段。在预投票阶段，candidate 不增加自身 term 而只会广播投票请求，只有拿到多数派投票后才进入正式投票阶段，这样就可以避免由于网络分区导致集群的 term 不断增大进而影响集群的稳定性。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;最后，因为日志复制只会从 leader 复制到其他节点，所以在选举的时候，必须确保新 leader 包含之前任期所有提交的日志。接下来我们来看 raft 是如何保证新 leader 一定包含之前任期所有提交的日志。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;2.2 leader 选举的安全性&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;下图描述的是 leader 选举过程中，候选者 candidate 发出的投票请求协议。投票请求会带上候选者自身的任期 term、memberId、最新日志的任期 term 和 index，其他节点收到请求后如果发现候选者的任期 &amp;gt;= 自身任期 并且 候选者的最新日志 &amp;gt;= 自身的最新日志，则回复同意。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.7600281491907108&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/j3gficicyOvatnhl3sxFBiblZPd2r6eEjOqIVNLjGh6zxoibjbbI87XxPsQxkj4DH7ynjtuyWRTZnuXGKVTR2nYjzw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1421&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;每条日志的元数据包括任期 term 以及一个自增的日志索引。日志大小的比较规则是：先比较日志的任期 term，term 相同则再比较日志的 logIndex。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.09554140127388536&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/j3gficicyOvatnhl3sxFBiblZPd2r6eEjOqJpxKhm2qv6GmZCH3gibqV84dTZxYkwcVlS7TvQIjELUD8XjecoBPSVA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;628&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;下面用个例子来证明 leader 选举的安全性。比如有 5 台机器，多数派机器拥有最新提交的日志，如果此时有 1 台机器拿到了多数派投票成为 leader，因为两个多数派必然存在交集，所以被选出来的 leader，其日志必然 &amp;gt;= 最新提交的日志。因此可以得出 1 个结论：新 leader 节点一定包含最新提交的日志。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.3229665071770335&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/j3gficicyOvatnhl3sxFBiblZPd2r6eEjOqib0JkvmFot8FjBnIribyaTdiav1xlB0LHhktwkTonHl2feZ1zgxa2j97Q/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;836&quot;/&gt;&lt;/figure&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;br/&gt;&lt;/figure&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;3. raft 的日志复制以及日志安全性&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;3.1 raft 的日志复制请求&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;下图描述的是 leader 处理写请求过程中，向其他节点发出的日志复制请求协议。请求会带上 leader 自己的任期 term、memberId、本次待复制的日志列表、上一条日志的 prevLogIndex 和 prevLogTerm、已达到多数派一致而提交的最大日志索引 commitIndex。其他节点收到请求后，如果发现 leader 的任期 &amp;gt;= 自身任期 并且 日志一致性检查通过，则用请求中待复制的日志列表直接覆盖本地的日志，并且更新本地的 commitIndex。日志一致性检查的逻辑是：自身节点已存在的日志列表中如果包含请求中指定 prevLogIndex、prevLogTerm 的日志，则检查通过。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1.25&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/j3gficicyOvatnhl3sxFBiblZPd2r6eEjOq4pN8ibcqvk0j6hAvEZqT4vFjTOSTzhVSzuWIQxibD4f1Gf0CwExm4ickw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1080&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;接下来用下图这个例子来讲解日志复制的过程。机器节点 d 作为 term 7 的 leader 节点，产生两条日志后发生异常，之后其中一台机器在 term 8 成功竞选成为 leader 并生成了一条新日志，这条新日志的 logTerm 为 8，logIndex 为 11。这个新任 leader 在将这条新日志复制给其他节点的时候，会带上前一条日志的元数据，也就是 prevLogTerm 为 6，prevLogIndex 为 10。刚开始由于只有节点 c 和 d 包含这个前一条日志而复制成功，其他节点则会拒绝复制。leader 节点收到复制失败的回包后，需要往前移动待复制的日志列表然后重新发送日志复制请求。例如 leader 节点能够成功向节点 b 复制日志的请求，该请求体的内容为：前一条日志的 prevLogTerm 为 4，prevLogIndex 为 4，而待复制的日志列表则包含从 logIndex 为 5 开始的所有日志。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.533195020746888&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/j3gficicyOvatnhl3sxFBiblZPd2r6eEjOqksic8CJDNXf4xW06SccHticiaGQP2Mej9rP6y0fcG3Via0qKtHemibZDA7Q/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;964&quot;/&gt;&lt;/figure&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;3.2 raft 的日志匹配性质&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;日志复制到其他节点后，不同节点上的日志会满足一个匹配性质。不同节点上的两个日志条目，如果 logTerm 、logIndex 都相同，则有：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;由于 leader 节点对于给定的任期 term、给定的 logIndex 至多创建 1 个日志条目，那么这两条日志必然包含相同的状态机输入。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;因为存在日志复制请求的一致性检查，所以这两个节点上，位于这条相同日志之前的所有日志条目必然也会相同。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.7346938775510204&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/j3gficicyOvatnhl3sxFBiblZPd2r6eEjOqLCFHMuIE3NuYCgW1zd1A8SKAUagrVV3iclhrBj22uic6jOlnia0uAZpkw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1470&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;通过这个日志匹配性质，就可以总结出：&lt;strong&gt;所有节点都会拥有一致的状态机输入序列。这样，各个节点就可以通过一致的初始状态 + 一致的状态机输入序列 从而 得到一致的最终状态&lt;/strong&gt;。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;3.3 raft 日志的提交安全性&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;日志成功复制给多数派节点，就可以提交，进而 apply 到业务状态机。但日志提交的时候存在一个限制：不能直接提交之前任期 term 的日志，只能提交当前任期下的日志。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;以下面这个图为例子，在集群处于状态 c 的时候，节点 S1 在 term 4 成为 leader，并且已经将 term 2 的日志复制给多数派，此时节点 S1 将 term 2 的日志 commit 后宕机。之后集群进入到状态 d，此时节点 S5 成为 leader 并且将 term 3 的日志复制给其他节点，这样就会导致之前已 commit 的 term 2 日志被回滚覆盖。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;因此为了避免这个问题，之前节点 S1 在任期 term 4 的时候，不能直接 commit 之前任期 term 的日志，只能通过将自己任期 term 4 的日志复制给多数派从而 commit 自己任期内的日志，如图中状态 e 所示。而一旦自己任期 term 内的日志得到 commit，那么由于日志一致性检查的存在，那么之前任期 term 下的日志必然也达到了多数派一致，因此之前任期 term 的日志此时也可以安全地 commit。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5467775467775468&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/j3gficicyOvatnhl3sxFBiblZPd2r6eEjOqAZ3lXcKYwHBdMUYWnZKQRob1Cby5xdznzrxmP3icNjBjf1EVLMvw8qA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;962&quot;/&gt;&lt;/figure&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;4. raft 的集群成员变更&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;4.1 集群成员变更的问题&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;集群在扩缩容或者机器节点发生故障的时候，我们需要对集群的成员进行变更。以下图为例，如果我们直接将集群的节点配置切换到新配置，由于无法将所有节点的配置同时切换到新配置，因此存在某一个时刻，server 1 和 server 2 可以形成老配置的多数派，server 3、server 4 和 server 5 可以形成新配置的多数派，这样在同一个任期 term 内就可以选举出两个 leader，使得集群产生脑裂。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.3675496688741722&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/j3gficicyOvatnhl3sxFBiblZPd2r6eEjOqUu4V1O2uPknbG3ZNSgz4ZZk0icmGBweth7J1ZWOh6Wib70HIYzY9wZrg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1812&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那么如何解决这种成员变更的问题呢？有两种方式：1. 联合共识。2. 单成员变更。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;4.2 联合共识-解决集群成员变更问题&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如下图所示的联合共识中，集群分为三个阶段。&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;集群还在采用 Cold 配置，此时 Cold 配置中的多数派达成一致就可以做出决议。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;向集群写入一个 Cold,new 的配置后，集群进入联合共识状态，此时需要 Cold 配置中的多数派与 Cnew 配置中的多数派同时达成一致才可以做出决议。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;向集群写入一个 Cnew 的配置，集群进入最终状态，此时 Cnew 配置中的多数派达成一致就可以做出决议。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5046296296296297&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/j3gficicyOvatnhl3sxFBiblZPd2r6eEjOqky35B9hrBaol0K4Zb26p53iaicaCNLsvicRKicl6HdomvziafkMbibFyeDdA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1728&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在上面三个阶段中，下面两个条件必然成立。因此在联合共识的成员变更过程中，任何时刻都不会选举出两个 leader。&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;阶段一的多数派和阶段二的多数派一定存在交集。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;阶段二的多数派和阶段三的多数派一定存在交集。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;4.3 单成员变更-解决集群成员变更问题&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;单成员变更的意思就是集群每次只变更一个节点。如下图所示，在单成员变更的方式中，变更前后的两个多数派一定存在交集，也就是变更过程中不可能产生两个 leader，因此采用单成员变更的方式，集群不需要引入联合共识的过渡状态。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.4283154121863799&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/j3gficicyOvatnhl3sxFBiblZPd2r6eEjOqS6XfoXIib0VqvI0OmbUgpf9aTIicR2Scvny4b82iaS1Pdt8KnbIgb8qNA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;2232&quot;/&gt;&lt;/figure&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;5. raft 的开源项目&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;etcd 作为云原生 kubernetes 中的核心存储，也是 raft 算法实现中最火热的开源项目，接下来向大家介绍下 etcd 的工程实现。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.3465346534653465&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/j3gficicyOvatnhl3sxFBiblZPd2r6eEjOq58anoBqr2L3mjjGYhTt5yJTL7dYGJ6SbgtHSZ6sbmpQfEXGlPcSGkw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1414&quot;/&gt;&lt;/figure&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;6. etcd 的架构&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;etcd 的架构如下图所示。api 接口支持 http 协议和 grpc 协议，node 主要负责 raft 算法的实现，storage 主要负责 raft 日志以及 snap 快照文件的存储，transport 主要负责集群节点间的通信。kvstore 分为 v2 和 v3 两个版本数据库，主要负责业务数据的存储，其中 v3 版本数据库的实现采用 lboltdb 和 keyIndex，支持 mvcc 机制。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5868673050615595&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/j3gficicyOvatnhl3sxFBiblZPd2r6eEjOq8TD0JGt0erBgMibWib8q8CVWiaXnicvrLib3fWFPkHOYu3kiab6TatIAHzBA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1462&quot;/&gt;&lt;/figure&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;7. etcd 的 raft 日志模块&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;7.1 etcd 的 raft 日志存储&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;从前面 raft 算法理论的学习中，可以得出有两类数据需要刷盘：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;raft 日志：协议交互流程中的一种承诺，一个节点一旦告诉其他节点自己已接收某条日志，则这条日志就不能丢失。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;节点的状态：包括当前的任期 term、当前的投票目标 vote、可提交的最大日志索引 commit 三个字段。前两个字段是 leader 选举流程中的承诺，第三个字段是节点在重启恢复时用来控制日志回放到哪一条日志。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;etcd 采用 wal 文件来保存上面两种数据的，保存的格式如下图所示。第一个 wal 文件在文件开头首先写入 0 值的 crc32 记录，之后每一个 raft 日志或者节点状态的记录，其 crc32 值 = calc(pre_crc32， 本记录的二进制值)。而对于第二个及之后的 wal 文件，文件开头的初始 crc32 值 = 上一个 wal 文件最后一条记录的 crc32 值。可以看到：所有 wal 文件，其所有记录的 crc32 值可以形成一个可进行强校验的链表。这样在重启恢复的时候，etcd 就可以对 wal 文件的内容进行精细化的校验。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.47058823529411764&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/j3gficicyOvatnhl3sxFBiblZPd2r6eEjOqrE5cjGr9DQVPzfk60PLxqJkPeoG9tY7OiasYPibka1FkpSGZUUbDYRiaQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;2295&quot;/&gt;&lt;/figure&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;7.2 etcd 的 raft 日志压缩&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果不对 raft 日志进行压缩的，那 wal 文件占用的磁盘空间就会越来越大，所以需要一个日志压缩机制，接下来通过下面这个图来讲述日志压缩机制。在 raft 日志中，首先定义几个概念：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;log_index：最新的日志位置索引。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;commit_index：已达成多数派一致，可提交的最大日志位置索引。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;apply_index：已应用到业务状态机的最大日志位置索引。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;compact_index：raft 日志清理的临界位置索引，在该索引之前的所有 raft 日志，都可以清掉。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;last_snap_index：上一个 snap 快照文件的日志索引，代表 snap 快照文件生成时刻的 apply_index。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.26763803680981596&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/j3gficicyOvatnhl3sxFBiblZPd2r6eEjOqq1buZZ4QTPe7dVTkClooNuk2rLOZ5o6dMAmibPV19920UYbPXEib434A/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;2608&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当 apply_index - last_snap_index &amp;gt; Cfg.SnapshotCount（默认值为 10w）时，会触发 snap 快照文件的生成，etcd 将数据库当前的快照数据写入 snap 文件的同时，也会在 wal 文件中追加一个 snapshotType 的记录（该记录包含此时的任期 term 和 apply_index）。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;理论上讲此时 apply_index 之前的所有 raft 日志都可以清掉了，但是在生产环境中其他 follower 节点的日志复制进度可能比较落后，还在学习 apply_index 之前的日志，如果此时 apply_index 之前的日志都被清掉了，那么 leader 节点必须发送 snap 文件 + apply_index 之后的 raft 日志，而发送 snap 文件是一个非常耗性能的操作，因此为了避免频繁发生这种 snap 文件的发送操作，在清理 raft 日志的时候，一般在 apply_index 前面保留 Cfg.SnapshotCatchUpEntries（默认值为 5000）个 raft 日志。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;7.3 etcd 重启时如何根据 raft 日志恢复数据&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;从前面可以知道，etcd 在运行过程中会不断生成 wal 文件和 sanp 文件，那 etcd 在重启时是如何恢复数据的呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;以下图为例来讲解恢复流程。首先，介绍下 wal 文件和 snap 文件的命名规则。wal 文件的命名包含一个递增的 seq、本 wal 文件中的起始日志索引 log_index。snap 文件的命名包含生成快照时刻的任期 term、应用到状态机的 apply_index。恢复流程的具体步骤为：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;读取所有 wal 文件，从 wal 文件中拿到所有的 snap 文件名，前面讲过每次日志压缩生成 snap 文件时都会往 wal 文件中写一条 snapshotType 记录（根据该记录可以拿到 snap 文件名）。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;从所有 snap 文件中选择一个最新且未被损坏的 snap 文件来恢复存储数据，在该例子中则会选中 0000000000000001-0000000000024000.snap 文件。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;根据 0000000000000001-0000000000024000.snap 文件筛选出所需要的 wal 文件列表，此时只需要读取 24000 之后的 raft 日志，所以只需要筛选出 0000000000000002-0000000000020000.wal 和 0000000000000003-0000000000030000.wal 两个文件，然后读取这两个 wal 文件恢复 HardState 状态，并且在 snap 文件的基础上做日志回放。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6732673267326733&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/j3gficicyOvatnhl3sxFBiblZPd2r6eEjOqTfIGlDtiaiapWojSncxUrqiaB0j3UTJibuaEUsDoW3hyS0UB9LPoOrowibA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1010&quot;/&gt;&lt;/figure&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;7.4 etcd 如何优化 raft 日志的读写&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;外部的每一个写请求都会生成一条 raft 日志，而 raft 日志是需要刷盘的。如果每生成一条 raft 日志就刷盘一次，那 etcd 的写入性能必然很低，因此 etcd 采用异步批量刷盘的方式来优化写入性能，如下图所示。&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;外部的写入请求先由 go routine 1 写入到 propc 通道。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;go routine 2 消费 propc 通道中的请求，将其转化为 unstable_log（保存在内存中，表示尚未达成多数派一致的 raft 日志），也会在待发送消息的缓冲区中生成日志复制请求。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;go routine 3 会将 unstable_log、待发送的日志复制请求打包成一个 ready 结构，写入道 readyc 通道。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;go routine 4 消费 readyc 中的数据，将 raft 日志刷盘到 wal 文件以及追加到 stable_log（保存在内存中，可理解为 wal 文件中的 raft 日志在内存中的副本），同时将日志复制请求发送给 follower 节点。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;对于已达成多数派一致的那些日志，unstable_log 缓冲区就可以清理掉了。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.804953560371517&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/j3gficicyOvatnhl3sxFBiblZPd2r6eEjOqQec96IEuvc9QUJPm4CO4pHx0UAEibBibXp9JSs8QMubaMGvO6NVWEdibQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;646&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;etcd 通过这种日志处理方式，不仅将多次写请求合并为一次刷盘优化了写入性能，而且通过在 stable_log 内存缓冲区中额外维护一份 wal 文件中 raft 日志的副本，从而优化了 raft 日志的读取性能。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;8. etcd 的 mvcc 机制&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;8.1 etcd 为什么要引入 mvcc？&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;etcd 之前的 v2 版本数据库是一个树型的内存数据库，整个数据库拥有一个大的 RWLock，写锁和读锁相互阻塞，影响读写性能。另外，etcd v2 数据库不会保存历史版本数据，在 v2 版本的 watch 机制中，v2 版本基于滑动窗口最多保留最近的 1000 条历史事件，当 etcd server 遇到写请求较多、网络波动等场景时，很容易出现事件丢失问题，进而触发 client 全量拉取数据，产生大量 expensive request，甚至导致 etcd 雪崩。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;因此 etcd 并发性能问题导致 Kubernetes 集群规模受限，而 watch 机制可靠性问题又直接影响到 Kubernetes controller 的正常运行。解决并发问题的方法有很多，而 mvcc 在解决并发问题的同时，还能通过存储多版本数据来解决 watch 机制可靠性问题。所以，etcd v3 版本果断选择了基于 mvcc 来实现多版本并发控制。mvcc 能最大化地实现高效地读写并发，尤其是高效地读，非常适合读多写少的场景。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;8.2 etcd 如何存储数据以支持 mvcc 机制&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如下图所示，etcd 采用 B 树存储 key 的历史版本号数据，并且通过 keyIndex 结构来构建整个 B 树，这个 keyIndex 存储了某一个 key 的历史版本号数据。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.3923705722070845&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/j3gficicyOvatnhl3sxFBiblZPd2r6eEjOqArdqc4U9icrGXNkPVO108GUxeLuPkp23enFDkR9RwhfK5KdmuSEaxqw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;2202&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;keyIndex 的结构如下所示，其中的每个 generation 代表 key 的一次创建到删除的版本号变更流水。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;// generation contains multiple revisions of a key.&lt;br/&gt;&lt;span&gt;type&lt;/span&gt; generation struct {&lt;br/&gt;    ver     int64 // 修改次数&lt;br/&gt;    created revision // when the generation is created (put &lt;span&gt;in&lt;/span&gt; first revision).&lt;br/&gt;    revs    []revision  // 修改版本号列表&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;type&lt;/span&gt; keyIndex struct {&lt;br/&gt;    key         []byte  // key的值&lt;br/&gt;    modified    revision // the main rev of the last modification&lt;br/&gt;    generations []generation  // 生命周期数组，每个generation代表key的一次创建到删除的版本号变更流水&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;8.3 etcd 如何维护 key 的版本号数据&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;接下来以下图为例讲解 keyIndex 的变更过程，进而说明 etcd 是如何维护版本号数据的。版本号由 main version 和 sub version 构成，每开启一个写事务则 main version 加 1，而在同一个写事务中，每进行一次写操作则 sub version 加 1。在该例子中，key 为 12345，第一次写入该 key 时，版本号为 101:0，此时会创建第 0 代 generation。第二次写入时，keyIndex 的修改版本号变成 102:0，并且会往第 0 代 generation 中 append 一个 102:0 的版本号。之后删除该 key，会往第 0 代 generation 中 append 一个 103:0 的版本号，并且新创建一个空的第 1 代 generation。最后在 main version 为 106 时再次写入该 key，则会往第 1 代 generation 中 append 一个 106:0 的版本号。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.782041998551774&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/j3gficicyOvatnhl3sxFBiblZPd2r6eEjOqicCwWAia4TaVCJRwlohyQoVX1mmB7uWtzAAS5YjU0YqqEYKQQDibRkiaEQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1381&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这种 keyIndex 结构设计的优点是：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;通过引入 generation 结构，存储的时候不用区分修改版本号与删除版本号，这两类版本号在数据结构上是同构的。在判断 key 是否存在时，我们只需要判断 keyIndex 是否存在或者其最后一代 generation 是否为空。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;在查找 key 的指定版本号数据时，可以先查找 generation，然后再在 generation 中查找具体的 version，相当于将一个大数组的查找划分为两个小数组的查找，加快了查找速度。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;8.4 etcd 如何存储每个版本号的数据&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;etcd 底层默认采用 boltdb 来存储每个版本号对应的 value，boltdb 是采用 B+树来存储数据的，如下图所示。boltdb 实现的几个关键点有：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;元信息页 metaPage 中存储了整个 db 根节点的 page_id。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;每个 key-value 键值对必须存储在 bucket 桶中，每一个 bucket 桶的数据都由一个独立的 B+树来维护。bucket 桶类似于命名空间的概念。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;boltdb 支持创建多个 bucket 桶，并且 bucket 桶支持嵌套创建子 bucket 桶。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.4280618311533888&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/j3gficicyOvatnhl3sxFBiblZPd2r6eEjOqZyLos62Cyd3Dt5LgMjz8z6v2fLODgZEUB3nb3fecbNibxIYSKZDhvJg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;2523&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;boltdb 支持多 bucket 桶的设计，使业务数据可以按功能分类，不同类别的数据互不影响，占较小存储空间的 bucket 数据，其读写性能不会因为 db 存在占较大存储空间的 bucket 而降低。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;8.5 etcd 的历史版本号数据压缩清理&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;由于 etcd v3 版本数据库会保存 key 的所有版本号数据，如果不进行定期压缩清理的话，那数据库占用的空间将越来越大，因此 etcd 实现了两种数据压缩方式。&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;第一种方式：保存过去一段时间内的版本号数据，如下图所示。etcd 支持配置一个压缩周期，而采样周期 = 压缩周期 / 10，然后每个采样周期都获取下当前的 db 版本号，并将这个版本号 push 到一个队列中，当队列满时 pop 出一个 version 然后开启第一次压缩，压缩时该 version 之前的历史版本号数据就可以清理掉了。之后每间隔一个压缩周期，都执行一次压缩逻辑。&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.23587570621468926&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/j3gficicyOvasdxGu5MJV9exgvoWWJj0xOMBVFLk6kwAAd1HtlAk0UztV4z75iarZ9LEsSia8E4h87jddJwZV7hF4w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1416&quot;/&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;/&gt;&lt;ol start=&quot;2&quot; data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;第二种方式：保存指定数量的历史版本号数据，如下图所示。etcd 每间隔一个压缩周期就执行一次压缩，压缩时的压缩 version = 当前 db 的 version - 配置文件指定的保留版本号数量。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.20695102685624012&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/j3gficicyOvatnhl3sxFBiblZPd2r6eEjOqGNpcyxtgh5n9dibeMdoTibOSCLbBcRibyGT8kq7NP9sjv0bZA436cCMng/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1266&quot;/&gt;&lt;/figure&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;9. etcd 的 watch 机制&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;etcd 允许客户端监听某个 key 或者某段 key 范围区间的变化。如果监听范围内的某个 key，其数据发生变化，则 watch 的客户端会立刻收到通知。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;9.1 etcd 的 watch 架构&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;etcd 的 watch 架构如下图所示。watch 客户端发出 watch 请求后，server 端首先创建一个 serverWatchStream，该 serverWatchStream 会创建一个 recv loop 协程和 send loop 协程。recv loop 协程负责监听客户端对具体 key 的 watch 请求，一旦收到 watch 请求就创建一个 watcher 并存储在 watchableStore 的 synced watchers 中，如果客户端指定从过去的历史版本号开始监听变化，则 watcher 会被存储在 unsynced watchers 中（表示该 watcher 需要追赶监听进度）。synced watchers 和 unsynced watchers 通过访问拥有 mvcc 机制的数据层将相关事件通过 serverWatchStream 的 send loop 协程发送给客户端。另外，synced watchers 和 unsynced watchers 有两类数据结构存储 watcher，map 结构负责存储只 watch 一个 key 的 watcher，interval tree 负责存储 watch 一段 key 范围区间的 watcher。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.9090909090909091&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/j3gficicyOvatnhl3sxFBiblZPd2r6eEjOqbLApnP3MyAfvv1Q1mInbUMkQ8Z4ACicshsdbtzkgTVtX6Iz2PehhAzA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1188&quot;/&gt;&lt;/figure&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;9.2 etcd 中落后的 watcher 如何追赶进度&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;前面提到 unsynced watchers 中存储的 watcher，其监听版本号是小于当前数据库版本号的，这些 watcher 需要一个机制去追赶数据库版本进度。etcd 在 watchableStore 初始化的时候，会创建一个 syncWatchersLoop 协程，这个协程的工作逻辑如下图所示：它会获取 unsynced watchers 中的最小监听版本号，然后根据这个版本号获取相关的 event 事件并发送给客户端。如果发送成功且监听版本号已达到数据库当前版本号，则将这些 watcher 移动到 synced watchers 中；如果发送失败，则将这些 event 事件放入 victims 缓冲区，有一个 syncVictimsLoop 协程专门对 victims 中之前发送失败的 event 事件进行重试。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.7258064516129032&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/j3gficicyOvatnhl3sxFBiblZPd2r6eEjOqmm3RlCaPjiaicMSIgFOtT2wGGibgeK0maj90GYg5FlsGgjzk7tOeLVecQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1488&quot;/&gt;&lt;/figure&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;9.3 etcd 中新的变更如何通知给 watcher&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;synced watchers 中存储的 watcher，其监听版本号虽然没有落后于当前数据库版本号，但数据库的最新 event 事件依然需要通知给这些 watcher，具体的工作逻辑如下图所示。其中部分逻辑与 syncWatchersLoop 协程的逻辑一致，这里不再详细讲解。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6143344709897611&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/j3gficicyOvatnhl3sxFBiblZPd2r6eEjOqmCzHf8DnqRHce6tWksJianzYH4JHzPK0gj7ulwj8hMWIupibxicP5fsdg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1758&quot;/&gt;&lt;/figure&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;10. etcd 的租约机制&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;10.1 etcd 租约的实现架构&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;etcd 租约实现的架构如下图所示。lease api 层提供租约接口，其中 grant / revoke 负责处理创建、销毁租约的请求，renew 负责续期租约的请求，attatch / detach 负责处理将 key 关联或者取消关联租约的请求。在 lessor 模块中：leaseExpiredNotifierHeap 采用最小堆实现，用来检测租约是否过期，checkpointHeap 采用最小堆实现，用来定时刷新每一个租约的剩余 TTL，itemMap 负责维护每一个 key 关联的租约信息，leaseMap 负责维护每一个租约 ID 的具体信息。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;另外，这些涉及租约数据变化的 api 接口，都会走一轮 raft 算法，这样各个节点的租约数据才会一致。租约的续期和过期处理稍微特殊一点，这两类操作统一由 leader 节点触发。对于续期操作，续期成功后，follower 节点上租约的剩余 TTL 依赖租约的 checkpoint 机制刷新；对于过期处理，leader 节点判断租约过期后，会在 raft 算法层提议一个 revoke 撤销租约的请求。etcd v3 版本中，如果不同 key 的 TTL 相同，则可以复用同一个租约 ID，这样就显著减少了租约数量。最后，租约数据会持久化到 boltdb。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.7401215805471124&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/j3gficicyOvatnhl3sxFBiblZPd2r6eEjOqGLJicQJC874BTRTtRE8upbSKfibccUEEVBp45yZroF3DgE9TYibxrqgXg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;658&quot;/&gt;&lt;/figure&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;10.2 如何理解租约的 checkpoint 机制&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;此 checkpoint 机制并不是生成租约数据的快照，而是 leader 节点为每个租约，每间隔 cfg.CheckpointInterval（默认值为 5min）时间就设置一个 checkpoint 时间点，然后 leader 节点每 500ms 为那些已到 checkpoint 时间点的所有租约生成一个 pb.LeaseCheckpointRequest 请求，该请求会通过 raft 算法提议，提议通过后在 apply 到状态机的时候刷新租约的剩余 TTL。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个 checkpoint 机制是为了解决一个问题：leader 发生切换的时候，follower 节点升为 leader 后会根据租约过期时间重建 leaseExpiredNotifierHeap 最小堆，如果 follower 节点之前一直不刷新剩余 TTL 的话，那重建的时候就会采用创建租约时的总 TTL 时间（相当于自动进行了一次续期）。如果 leader 频繁发生切换，切换时间小于租约的 TTL，这就会导致租约永远无法删除，导致 etcd 大量 key 堆积从而引发 db 大小超过配额等异常。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;10.3 etcd 重启时的租约恢复&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;grant api 接口创建租约的时候，会将租约数据（包括租约 ID、租约的总 TTL、租约的剩余 TTL）持久化到 boltdb 的 leaseBucket 桶中，如下所示。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;leaseBucketName = []byte(&lt;span&gt;&quot;lease&quot;&lt;/span&gt;)&lt;br/&gt;func (l *Lease) persistTo(b backend.Backend, ci cindex.ConsistentIndexer) {&lt;br/&gt;    key := int64ToBytes(int64(l.ID))&lt;br/&gt;    lpb := leasepb.Lease{ID: int64(l.ID), TTL: l.ttl, RemainingTTL: l.remainingTTL}&lt;br/&gt;    val, err := lpb.Marshal()&lt;br/&gt;&lt;br/&gt;    b.BatchTx().Lock()&lt;br/&gt; // 租约数据写入boltdb&lt;br/&gt;    b.BatchTx().UnsafePut(leaseBucketName, key, val)&lt;br/&gt;    b.BatchTx().Unlock()&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;另外，key-value 键值对写入 boltdb 的 keyBucket 桶时，value 存储的结构如下所示，包含了 key 关联的租约 ID。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;keyBucketName  = []byte(&lt;span&gt;&quot;key&quot;&lt;/span&gt;)&lt;br/&gt;kv := mvccpb.KeyValue{&lt;br/&gt;        Key:            key,&lt;br/&gt;        Value:          value,&lt;br/&gt;        CreateRevision: c,&lt;br/&gt;        ModRevision:    rev,&lt;br/&gt;        Version:        ver,&lt;br/&gt;        Lease:          int64(leaseID),  // key关联的租约ID&lt;br/&gt;    }&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这样 etcd 重启的时候，通过遍历 leaseBucket 桶来恢复所有的租约数据，然后再遍历 keyBucket 桶来恢复数据 key 与租约 ID 的映射关系。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;11. etcd 实现的一些关键总结&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;为什么 etcd v3 版本的 KeyIndex 使用 B-tree 而不使用哈希表、平衡二叉树？答：从功能特性上分析， 因 etcd 需要支持范围查询，因此保存索引的数据结构也必须支持范围查询才行。所以哈希表不适合，而 B-tree 支持范围查询。从性能上分析，平横二叉树每个节点只能容纳一个数据、导致树的高度较高，而 B-tree 每个节点可以容纳多个数据，树的高度更低，更扁平，涉及的查找次数更少，具有优越的增、删、改、查性能。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;etcd v3 版本数据是采用 boltdb 存储的，boltdb 对于每一个写事务都会进行一次刷盘，那 etcd 为了优化写入性能，做了什么样的处理？答：采用批量提交的，也就是用底层 boltdb 的单个写事务来处理上层业务 api 接口的多次写入请求。&lt;strong&gt;etcd 批量提交的代码实现如下：&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;// 写入key-value对的时候，并不会开启一个新的写事务，还是沿用之前的t.tx写入数据，然后将t.pending加1.&lt;br/&gt;func (t *batchTx) unsafePut(bucketName []byte, key []byte, value []byte, seq bool) {&lt;br/&gt;    bucket := t.tx.Bucket(bucketName)&lt;br/&gt; // 省略若干代码&lt;br/&gt;    bucket.Put(key, value)&lt;br/&gt;    t.pending++&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;// 在业务释放batchTx的锁时，如果t.pending达到一定值时，提交事务&lt;br/&gt;func (t *batchTx) &lt;span&gt;&lt;span&gt;Unlock&lt;/span&gt;&lt;/span&gt;() {&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; t.pending &amp;gt;= t.backend.batchLimit {&lt;br/&gt;        t.commit(&lt;span&gt;false&lt;/span&gt;)&lt;br/&gt;    }&lt;br/&gt;    t.Mutex.Unlock()&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;// 提交上一个boltdb事务，然后再开一个新事务供后续数据写入&lt;br/&gt;func (t *batchTx) commit(stop bool) {&lt;br/&gt;    // commit the last tx&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; t.tx != nil {&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; t.pending == 0 &amp;amp;&amp;amp; !stop {&lt;br/&gt;            &lt;span&gt;return&lt;/span&gt;&lt;br/&gt;        }&lt;br/&gt;  t.tx.Commit()&lt;br/&gt;        t.pending = 0&lt;br/&gt;    }&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; !stop {&lt;br/&gt;  // 进程没有收到stop信号，则立即开启一个新的boltdb写事务用于接下来的写入请求&lt;br/&gt;        t.tx = t.backend.begin(&lt;span&gt;true&lt;/span&gt;)&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;// 每隔b.batchInterval时间，就检查是否有待提交的写入数据，如果有则提交下。&lt;br/&gt;func (b *backend) &lt;span&gt;&lt;span&gt;run&lt;/span&gt;&lt;/span&gt;() {&lt;br/&gt;    defer close(b.donec)&lt;br/&gt;    t := time.NewTimer(b.batchInterval)&lt;br/&gt;    defer t.Stop()&lt;br/&gt;    &lt;span&gt;for&lt;/span&gt; {&lt;br/&gt;        select {&lt;br/&gt;        &lt;span&gt;case&lt;/span&gt; &amp;lt;-t.C:&lt;br/&gt;        &lt;span&gt;case&lt;/span&gt; &amp;lt;-b.stopc:&lt;br/&gt;            b.batchTx.CommitAndStop()&lt;br/&gt;            &lt;span&gt;return&lt;/span&gt;&lt;br/&gt;        }&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; b.batchTx.safePending() != 0 {&lt;br/&gt;            b.batchTx.Commit()&lt;br/&gt;        }&lt;br/&gt;        t.Reset(b.batchInterval)&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;ol start=&quot;3&quot; data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;采用批量提交，在尚未达到提交条件而系统宕机，会不会导致 v3 版本的部分数据丢失呢？答：不会，因为宕机后重启恢复的时候，可以通过回放 raft 日志来恢复数据，而 v3 版本的存储数据是支持 raft 日志可重入回放的，在将 raft 日志应用到 v3 版本数据的时候，会更新 consistentIndex，而这个 consistentIndex 在批量提交的时候也会 commit 到 boltdb 中。在系统宕机时，consistentIndex 的值也没有刷盘，boltdb 底层保存的还是旧的 consistentIndex，这样宕机后就可以通过重启后的日志回放来恢复数据。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;// 保证日志回放幂等性的consistentIndex也保存到底层boltdb&lt;br/&gt;func (ci *consistentIndex) UnsafeSave(tx backend.BatchTx) {&lt;br/&gt;    bs := ci.bytesBuf8&lt;br/&gt;    binary.BigEndian.PutUint64(bs, ci.consistentIndex)&lt;br/&gt;    // put the index into the underlying backend&lt;br/&gt;    // tx has been locked &lt;span&gt;in&lt;/span&gt; TxnBegin, so there is no need to lock it again&lt;br/&gt;    tx.UnsafePut(metaBucketName, consistentIndexKeyName, bs)&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;// 将raft日志应用到v3版本数据的，只有日志index大于consistentIndex（这个值代表已应用到v3版本数据的raft日志索引）时，才会apply到v3存储，保证幂等性。&lt;br/&gt;func (s *EtcdServer) applyEntryNormal(e *raftpb.Entry) {&lt;br/&gt;    shouldApplyV3 := &lt;span&gt;false&lt;/span&gt;&lt;br/&gt;    index := s.consistIndex.ConsistentIndex()&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; e.Index &amp;gt; index {&lt;br/&gt;        // &lt;span&gt;set&lt;/span&gt; the consistent index of current executing entry&lt;br/&gt;        s.consistIndex.SetConsistentIndex(e.Index)&lt;br/&gt;        shouldApplyV3 = &lt;span&gt;true&lt;/span&gt;&lt;br/&gt;    }&lt;br/&gt; // 省略若干代码&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;ol start=&quot;4&quot; data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;采用批量提交，在尚未达到提交条件时，boltdb 底层的读事务是读不到这些数据的，那 etcd 是怎么处理的？答：etcd 业务 api 接口开启写事务写数据时，除写一份到 boltdb 外，还写一份数据到 txWriteBuffer，然后 api 接口在结束事务时将 txWriteBuffer 内存合并到 txReadBuffer。etcd 业务 api 读接口会优先读取 txReadBuffer 中的内容，然后再读底层 boltdb 的数据。整个过程的代码逻辑如下：&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;// 写入数据前，通过这个函数开启一个写事务&lt;br/&gt;func (s *store) Write(trace *traceutil.Trace) TxnWrite {&lt;br/&gt;    s.mu.RLock()&lt;br/&gt;    tx := s.b.BatchTx()&lt;br/&gt;    tx.Lock()&lt;br/&gt;    tw := &amp;amp;storeTxnWrite{&lt;br/&gt;        storeTxnRead: storeTxnRead{s, tx, 0, 0, trace},&lt;br/&gt;        tx:           tx,&lt;br/&gt;        beginRev:     s.currentRev,&lt;br/&gt;        changes:      make([]mvccpb.KeyValue, 0, 4),&lt;br/&gt;    }&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; newMetricsTxnWrite(tw)&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;// 数据写入boltdb（此时不一定会进行事务提交）后，同时写入txWriteBuffer&lt;br/&gt;func (t *batchTxBuffered) UnsafeSeqPut(bucketName []byte, key []byte, value []byte) {&lt;br/&gt;    t.batchTx.UnsafeSeqPut(bucketName, key, value)&lt;br/&gt;    t.buf.putSeq(bucketName, key, value)&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;func (txw *txWriteBuffer) putSeq(bucket, k, v []byte) {&lt;br/&gt;    b, ok := txw.buckets[string(bucket)]&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; !ok {&lt;br/&gt;        b = newBucketBuffer()&lt;br/&gt;        txw.buckets[string(bucket)] = b&lt;br/&gt;    }&lt;br/&gt;    b.add(k, v)&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;// 上层业务api写请求的接口，写入key-value键值对后，会调用func (tw *metricsTxnWrite) End()函数&lt;br/&gt;func (tw *metricsTxnWrite) &lt;span&gt;&lt;span&gt;End&lt;/span&gt;&lt;/span&gt;() {&lt;br/&gt;    defer tw.TxnWrite.End()   // 调用func (tw *storeTxnWrite) End()&lt;br/&gt; // 省略若干代码&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;func (tw *storeTxnWrite) &lt;span&gt;&lt;span&gt;End&lt;/span&gt;&lt;/span&gt;() {&lt;br/&gt;    // only update index &lt;span&gt;if&lt;/span&gt; the txn modifies the mvcc state.&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; len(tw.changes) != 0 {&lt;br/&gt;        tw.s.saveIndex(tw.tx)&lt;br/&gt;        // hold revMu lock to prevent new &lt;span&gt;read&lt;/span&gt; txns from opening until writeback.&lt;br/&gt;        tw.s.revMu.Lock()&lt;br/&gt;        tw.s.currentRev++&lt;br/&gt;    }&lt;br/&gt;    tw.tx.Unlock()  // 调用func (t *batchTxBuffered) Unlock()&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; len(tw.changes) != 0 {&lt;br/&gt;        tw.s.revMu.Unlock()&lt;br/&gt;    }&lt;br/&gt;    tw.s.mu.RUnlock()&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;func (t *batchTxBuffered) &lt;span&gt;&lt;span&gt;Unlock&lt;/span&gt;&lt;/span&gt;() {&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; t.pending != 0 {&lt;br/&gt;        t.backend.readTx.Lock() // blocks txReadBuffer &lt;span&gt;for&lt;/span&gt; writing.&lt;br/&gt;        t.buf.writeback(&amp;amp;t.backend.readTx.buf)  //调用func (txw *txWriteBuffer) writeback(txr *txReadBuffer)函数&lt;br/&gt;        t.backend.readTx.Unlock()&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; t.pending &amp;gt;= t.backend.batchLimit {&lt;br/&gt;            t.commit(&lt;span&gt;false&lt;/span&gt;)  // 写请求达到批量提交条件时提交boltdb写事务，这个函数也会等待所有业务api读请求结束后然后将txReadBuffer清掉，最后再开启一个新的boltdb读事务以供api读请求使用。此时，下一个业务api读请求必须要等待该boltdb写事务刷盘结束后才能开始&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;    t.batchTx.Unlock()&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;// 将本次写入的数据合并到txReadBuffer中，以提供读请求读取&lt;br/&gt;func (txw *txWriteBuffer) writeback(txr *txReadBuffer) {&lt;br/&gt;    &lt;span&gt;for&lt;/span&gt; k, wb := range txw.buckets {&lt;br/&gt;        rb, ok := txr.buckets[k]&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; !ok {&lt;br/&gt;            delete(txw.buckets, k)&lt;br/&gt;            txr.buckets[k] = wb&lt;br/&gt;            &lt;span&gt;continue&lt;/span&gt;&lt;br/&gt;        }&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; !txw.seq &amp;amp;&amp;amp; wb.used &amp;gt; 1 {&lt;br/&gt;            // assume no duplicate keys&lt;br/&gt;            sort.Sort(wb)&lt;br/&gt;        }&lt;br/&gt;        rb.merge(wb)&lt;br/&gt;    }&lt;br/&gt;    txw.reset()&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;// 结合txReadBuffer和底层boltdb，读取数据&lt;br/&gt;func (rt *concurrentReadTx) UnsafeRange(bucketName, key, endKey []byte, &lt;span&gt;limit&lt;/span&gt; int64) ([][]byte, [][]byte)&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;ol start=&quot;5&quot; data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;keyIndex 结构中的 generation 结构为什么要存储创建版本号？答：对于指定 key，创建其第 N 代生命周期的 generation 时，该 generation 的创建版本号与第一个修改版本号必然一样，这样看似乎创建版本号是冗余的。但其实不然，因为 keyIndex 有压缩逻辑（清理太久之前的版本号数据），压缩后该 generation 修改版本号列表中的第一个版本号就不是创建版本号了。因此，如果要获取 key 的创建版本号，那 generation 就必须存储一个创建版本号。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;// generation contains multiple revisions of a key.&lt;br/&gt;&lt;span&gt;type&lt;/span&gt; generation struct {&lt;br/&gt;    ver     int64 // 修改次数&lt;br/&gt;    created revision // when the generation is created (put &lt;span&gt;in&lt;/span&gt; first revision).&lt;br/&gt;    revs    []revision  // 修改版本号列表&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;type&lt;/span&gt; keyIndex struct {&lt;br/&gt;    key         []byte  // key的值&lt;br/&gt;    modified    revision // the main rev of the last modification&lt;br/&gt;    generations []generation  // 生命周期数组，每个generation代表key的一次创建到删除的版本号变更流水&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;ol start=&quot;6&quot; data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;etcd 为了压缩 raft 日志，需要定时生成 snapshot 文件，然后清掉过期的 raft 日志，那么生成 snapshot 文件会不会很耗性能？答：对于 v3 版本数据，底层 boltdb 保存了当前 apply 到数据库的最大 raft 日志 index，因此一般情况下 v3 版本的数据不需要生成 snapshot 文件，boltdb 自身的数据本身就存储在磁盘文件上（进程通过 mmap 机制进行读写），在重启恢复的时候，v3 版本的数据可以直接加载 boltdb 的数据库文件，然后通过回放 raft 日志（v3 数据的日志回放有幂等性保证）来恢复数据。&lt;/section&gt;&lt;section&gt;但有一种场景 leader 需要将 v3 版本的 boltdb 文件发送给 follower，比如：如果 follower 节点进度太落后，其所需的 raft 日志已被 leader 节点压缩清理掉。这种场景，leader 将 v2 版本的 snapshot 数据 + 当前 boltdb 的文件 合并成一个 MergedSnapshot 发送给 follower。follower 节点收到后依次恢复 v2 和 v3 版本的数据，此时 v2 和 v3 版本数据的进度存在不一致（v3 版本的数据比较新），随后 v2 版本的数据通过日志回放追赶上，而 v3 版本的数据通过 boltdb 中的 consistentIndex 确保日志回放的幂等性。&lt;code&gt;在发送boltdb文件的时候，首先开启一个boltdb的读事务，然后创建一个pipe管道，读事务每次最多从boltdb文件读取32K写入到pipe的write端，另一个协程则与读事务协程交替着读取、写入pipe，读取pipe内容后，通过http的流式传输发送给follower&lt;/code&gt; 。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;// 用boltdb保存当前apply到数据库的最大raft日志index&lt;br/&gt;func (ci *consistentIndex) UnsafeSave(tx backend.BatchTx) {&lt;br/&gt;    bs := ci.bytesBuf8&lt;br/&gt;    binary.BigEndian.PutUint64(bs, ci.consistentIndex)&lt;br/&gt;    // put the index into the underlying backend&lt;br/&gt;    // tx has been locked &lt;span&gt;in&lt;/span&gt; TxnBegin, so there is no need to lock it again&lt;br/&gt;    tx.UnsafePut(metaBucketName, consistentIndexKeyName, bs)&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;func (s *EtcdServer) applyEntryNormal(e *raftpb.Entry) {&lt;br/&gt;    shouldApplyV3 := &lt;span&gt;false&lt;/span&gt;&lt;br/&gt;    index := s.consistIndex.ConsistentIndex()&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; e.Index &amp;gt; index {&lt;br/&gt;        // 保证幂等性，v3版本数据库支持raft日志的重复回放，对于重复的raft日志会忽略掉&lt;br/&gt;        // &lt;span&gt;set&lt;/span&gt; the consistent index of current executing entry&lt;br/&gt;        s.consistIndex.SetConsistentIndex(e.Index)&lt;br/&gt;        shouldApplyV3 = &lt;span&gt;true&lt;/span&gt;&lt;br/&gt;    }&lt;br/&gt; // 省略若干代码&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;ol start=&quot;7&quot; data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;集群成员节点变更流程种，从代码上看 Cnew 配置生效的时间节点与 raft 论文不一样，怎么理解，不会影响到正确性吗？答：下面这个图是 raft 论文中的，论文中 Cnew 日志产生开始就可以 make dicision alone。看 etcd 的代码，第一阶段是只需要 Cold 多数派达成一致就进入 Cold 和 Cnew 的联合一致状态 join consensus，第二阶段是需要 Cold 和 Cnew 两个多数派达成一致才实现最终 Cnew 配置（因为 etcd 的代码实现，集群节点配置都是日志 apply 的时候才生效）。&lt;/section&gt;&lt;section&gt;这样来看 Cnew 配置生效的时间节点与 raft 论文不一样，但不会影响算法的正确性，理由是：raft 论文中描述的是 Cold 可以单独做多数派决定的最晚时间点以及 Cnew 可以单独做多数派决定的的最早时间点，也就是 join consensus 的最小生命周期。而在工程实现中，join consensus 生命周期只要包含那个最小生命周期就可以了，实际上只要保证 Cold 中的多数派在用 Cold 配置 以及 Cnew 中的多数派在用 Cnew 配置 这两种情况不会同时发生就可以。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5046296296296297&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/j3gficicyOvatnhl3sxFBiblZPd2r6eEjOqky35B9hrBaol0K4Zb26p53iaicaCNLsvicRKicl6HdomvziafkMbibFyeDdA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1728&quot;/&gt;&lt;/figure&gt;&lt;ol start=&quot;8&quot; data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;etcd 是如何实现线性一致性读的？答：因为在网上查到讲得比较好的文章，这里就不再细讲。感兴趣的同学可以参考下面两篇文章。&lt;a href=&quot;https://zhuanlan.zhihu.com/p/31050303&quot; data-linktype=&quot;2&quot;&gt;etcd-raft 的线性一致读方法一：ReadIndex&lt;/a&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/31118381&quot; data-linktype=&quot;2&quot;&gt;etcd-raft 的线性一致读方法二：LeaseRead&lt;/a&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;参考文章&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/359206808&quot; data-linktype=&quot;2&quot;&gt;Raft 成员变更的工程实践&lt;/a&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;section class=&quot;channels_iframe_wrp&quot;&gt;&lt;mpvideosnap class=&quot;js_uneditable custom_select_card channels_iframe videosnap_video_iframe&quot; data-pluginname=&quot;videosnap&quot; data-id=&quot;export/UzFfAgtgekIEAQAAAAAAi-4ZREEgXQAAAAstQy6ubaLX4KHWvLEZgBPE9aIwAwlpIs2BzNPgMItDtZUMiv9j8pALjjyE7CCG&quot; data-url=&quot;https://findermp.video.qq.com/251/20304/stodownload?encfilekey=rjD5jyTuFrIpZ2ibE8T7Ym3K77SEULgkia2TdBhfia706WDHUXlzA9eDahdw521Aja5k7NLBQRiahyhaskicgE3BGJWZnib2RWlQKfLJNRsbsodE3fMSZfE2Aaow&amp;amp;adaptivelytrans=0&amp;amp;bizid=1023&amp;amp;dotrans=0&amp;amp;hy=SZ&amp;amp;idx=1&amp;amp;m=&amp;amp;scene=0&amp;amp;token=AxricY7RBHdVvrFQZBFhZvfTLRw8bE9REEm4AAK1tMib6p4wh4X8VU07Cj4iahKyWozrf80TRmh2To&quot; data-headimgurl=&quot;http://wx.qlogo.cn/finderhead/I7awtksbibjQe7RZAy84xESOBAfIZ8xQ9ApXt4uTe8po/0&quot; data-username=&quot;v2_060000231003b20faec8c6e08e1ac1d4cf06ea31b07760a16cba92d83444bd9a5d9d55ffaede@finder&quot; data-nickname=&quot;腾讯程序员&quot; data-desc=&quot;产品经理说：调酒和做产品一样不容易&quot; data-nonceid=&quot;18021675388342415944&quot; data-type=&quot;video&quot; data-authiconurl=&quot;https://dldir1v6.qq.com/weixin/checkresupdate/icons_filled_channels_authentication_enterprise_a2658032368245639e666fb11533a600.png&quot; data-width=&quot;1920&quot; data-height=&quot;1080&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;抽奖红包封面&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1.2055555555555555&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/j3gficicyOvav94uOctNEdjFIaJORnOrUaYo5zibJtxZrd1093aankWOOcGsljyqTfeRLACTVibJczpibb6J62jYsgA/640?wx_fmt=png&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; data-w=&quot;1080&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;进入公众号回复：&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;&lt;strong&gt;1024 &lt;/strong&gt;&lt;/span&gt;&lt;span&gt;&lt;strong&gt;参与&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;&lt;/section&gt;&lt;section class=&quot;mp_profile_iframe_wrp&quot;&gt;&lt;mp-common-profile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mpprofile&quot; data-id=&quot;MjM5ODYwMjI2MA==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/j3gficicyOvasvpPfMrktl2xvC9A325p8Qa9dFeEzxZmZ2O1XuFGsVXyQhG9Dia8J8nTXVtzNcHozr0umH3R4iboXg/0?wx_fmt=png&quot; data-nickname=&quot;腾讯技术工程&quot; data-alias=&quot;Tencent_TEG&quot; data-signature=&quot;腾讯技术官方号。腾讯技术创新、前沿领域发布解读平台。&quot; data-from=&quot;0&quot; data-is_biz_ban=&quot;0&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>