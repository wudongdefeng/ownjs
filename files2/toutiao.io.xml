<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>904b293dc9cac15f5f766ffb53e479f2</guid>
<title>Python中关闭文件很重要</title>
<link>https://toutiao.io/k/8r3kcz7</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;post-body&quot; itemprop=&quot;articleBody&quot;&gt;

      
      

      
        &lt;h2 id=&quot;引言&quot;&gt;&lt;a href=&quot;#引言&quot; class=&quot;headerlink&quot; title=&quot;引言&quot;/&gt;引言&lt;/h2&gt;&lt;p&gt;在使用 Python 操作文件时，很多人会使用上下文管理器来操作。例如：&lt;br/&gt;&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br/&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;with&lt;/span&gt; open(&lt;span class=&quot;string&quot;&gt;&quot;xx.txt&quot;&lt;/span&gt;, mode=&lt;span class=&quot;string&quot;&gt;&quot;w&quot;&lt;/span&gt;) &lt;span class=&quot;keyword&quot;&gt;as&lt;/span&gt; f:&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;    f.write(&lt;span class=&quot;string&quot;&gt;&quot;Hello, World!&quot;&lt;/span&gt;)&lt;/span&gt;&lt;br/&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;该with语句启动上下文管理器。在此示例中，只要上下文处于活动状态，上下文管理器就会打开文件xx.txt并管理文件资源。通常，缩进块结束或引发异常，文件将关闭。可能很多初学者都会被建议这样用，可是为什么要这样写程序才更健壮？或者说为什么一定要关闭文件？&lt;/p&gt;
&lt;a id=&quot;more&quot;/&gt;
&lt;h2 id=&quot;从系统的角度看&quot;&gt;&lt;a href=&quot;#从系统的角度看&quot; class=&quot;headerlink&quot; title=&quot;从系统的角度看&quot;/&gt;从系统的角度看&lt;/h2&gt;&lt;h3 id=&quot;系统限制进程打开的文件数&quot;&gt;&lt;a href=&quot;#系统限制进程打开的文件数&quot; class=&quot;headerlink&quot; title=&quot;系统限制进程打开的文件数&quot;/&gt;系统限制进程打开的文件数&lt;/h3&gt;&lt;p&gt;调用open()打开文件时，会对操作系统进行系统调用，硬盘驱动器找到该文件并为读取或写入做好准备。然后，操作系统将返回一个无符号整数n， Python 进程进行系统调用并获取整数 n 作为文件句柄获得与文件关联的编号后，就可以进行读取或写入操作了。&lt;br/&gt;操作系统限制任何单个进程可以拥有的打开文件的数量，这个可以使用工具 ulimit 查看， 或者直接修改 /etc/security/limits.conf 改变文件数限制。&lt;/p&gt;
&lt;h3 id=&quot;为什么限制？突破限制会怎样&quot;&gt;&lt;a href=&quot;#为什么限制？突破限制会怎样&quot; class=&quot;headerlink&quot; title=&quot;为什么限制？突破限制会怎样&quot;/&gt;为什么限制？突破限制会怎样&lt;/h3&gt;&lt;p&gt;从操作系统的角度来看，任何达到限制的进程都可能会泄漏文件句柄以及其他资源。资源泄漏可能是由于不良的编程习惯或试图攻击系统的恶意程序造成的，操作系统为了保护系统的稳定而采取限制措施。另外，对于大多数应用程序来说，打开这么多文件是没有意义的。在一个硬盘驱动器上最多只能同时进行一次读取或写入操作。&lt;/p&gt;
&lt;p&gt;比如你写了一个简单的文件上传服务，在服务中你需要将用户上传的文件保存在服务器上，如果你没有在写完文件后关闭文件，随着服务的时间变长，服务开启的文件会越来越多，最后你会得到这个报错， OSError: [Errno 24] Too many open files。&lt;/p&gt;
&lt;p&gt;那能不能突破这个文件限制呢？那肯定是可以的，当然你必须知道你的服务为什么要开启这么多的文件，比如对于一个长连接服务，他可能要求单个实例要支撑数万的tcp链接(Linux中套接字也是文件)，那这时候如果还采取默认的单进程开启文件数量限制可能就不合适了，你就需要修正 /etc/security/limits.conf 配置文件。&lt;/p&gt;
&lt;h2 id=&quot;从稳定性的角度看&quot;&gt;&lt;a href=&quot;#从稳定性的角度看&quot; class=&quot;headerlink&quot; title=&quot;从稳定性的角度看&quot;/&gt;从稳定性的角度看&lt;/h2&gt;&lt;p&gt;我们每次操作文件都去使用with来管理上下文，with封装了 try…except…finally 编码范式，能在任何情况下(当然不包括断电)极大限度的帮你关闭文件。&lt;/p&gt;
&lt;p&gt;但是如果我们不关闭文件，将会面临什么？比如下边的代码&lt;br/&gt;&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br/&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;import&lt;/span&gt; os&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;f = open(&lt;span class=&quot;string&quot;&gt;&quot;xxx.txt&quot;&lt;/span&gt;, mode=&lt;span class=&quot;string&quot;&gt;&quot;w&quot;&lt;/span&gt;)&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;f.write(&lt;span class=&quot;string&quot;&gt;&quot;Hello, world!&quot;&lt;/span&gt;)&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;os._exit(&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;)  &lt;span class=&quot;comment&quot;&gt;# 模拟程序异常退出&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;这段代码你确实可以找到 xxx.txt 文件，但是文件里边没有Hello, world!内容。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;为每个写操作都去操作磁盘是很昂贵。出于这个原因，Python 默认是使用一个缓冲区来收集写操作。当缓冲区满时，或者文件被显式关闭时，缓冲区被刷新，写操作完成，这时候才会写入磁盘。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Python 进程完成后，操作系统会执行自己的清理，关闭进程打开的所有文件描述符。崩溃可能发生在多个级别，并会干扰操作系统的清理，使文件句柄悬空。在 Windows 上，悬空文件句柄可能会出现问题，打开文件的进程也会锁定它，另一个进程在关闭之前无法打开该文件。Windows 用户可能熟悉不允许您打开或删除文件的恶意进程。文件句柄泄漏和缓冲区中的内容丢失已经够糟糕的了，但是中断文件操作的崩溃也可能导致文件损坏。&lt;/p&gt;
&lt;h2 id=&quot;总结&quot;&gt;&lt;a href=&quot;#总结&quot; class=&quot;headerlink&quot; title=&quot;总结&quot;/&gt;总结&lt;/h2&gt;&lt;p&gt;首先因为受系统的限制，我们不管用哪种语言编程，都要把不在使用的文件描述符关闭，一来避免因开启文件过多导致服务异常，二来及时关闭不用的文件描述符也能节约资源。&lt;/p&gt;
&lt;p&gt;另外我们永远无法完全避免崩溃的影响，但是我们可以通过使用上下文管理器来减少崩溃带来的影响。&lt;/p&gt;

      
    &lt;/div&gt;

    
      


    

    
    
    

    
      &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>152466dcf8a5a6c4d331d085df506b2c</guid>
<title>Redis碎片整理原理解析与实践</title>
<link>https://toutiao.io/k/wmkid6f</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;span&gt;说实话，我当时脑子的瞬间想法是：&lt;/span&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;业务应该指的是删除期间耗时涨了？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;删除后Redis端的耗时不会涨吧？AOF和RDB也没开，感觉业务那边描述有问题。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;业务服务有异常？判断标准，当时瞄了一眼主调服务有20个，其中只有3个可用性下降。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;带着疑问快速过了下相关指标，得到以下结论：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;确实是删除数据后，耗时上涨了3倍（avg:1ms-&amp;gt;3ms），删除期间整体还好（&lt;strong&gt;略诡异&lt;/strong&gt;，脑子瞬间想到碎片整理，但这个集群的碎片整理cpu参数控制在10%-20%）&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;主调机器确实有异常，但是之前也有问题（可排除）&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Redis Server cpu消耗涨了3倍，但是max=24%，依据经验是没问题的，除非业务对耗时极度敏感。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;综合看，流量无上涨、主调方无变动、删除大量数据、CPU上涨但可容忍（但业务可能不容忍），立刻做了关掉碎片整理的决定，服务瞬间恢复。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;ps: 上述是3分钟内完成的^_^&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;自认为对碎片率、已经相关实践有所了解，但还是出了个问题，于是准备仔细研究下，同时也分享给大家。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;二、什么是Redis内存碎片&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;内存分配器为了更好地管理和重复利用内存，分配策略一般采用固定范围的内存块进行分配。Redis默认使用的是jemalloc在64位系统中将内存空间划分为：小、大、巨大三个范围，每个范围内又划分为多个小的内存块单位：&lt;/p&gt;&lt;section data-tool=&quot;mdnice编辑器&quot;&gt;&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;类型&lt;/th&gt;&lt;th&gt;空间&lt;/th&gt;&lt;th&gt;值&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;小&lt;/td&gt;&lt;td&gt;8&lt;/td&gt;&lt;td&gt;[8]&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;br/&gt;&lt;/td&gt;&lt;td&gt;16&lt;/td&gt;&lt;td&gt;[16，32，48，...，128]&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;br/&gt;&lt;/td&gt;&lt;td&gt;32&lt;/td&gt;&lt;td&gt;[160, 192, 224, 256]&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;br/&gt;&lt;/td&gt;&lt;td&gt;64&lt;/td&gt;&lt;td&gt;[320, 384, 448, 512]&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;br/&gt;&lt;/td&gt;&lt;td&gt;128&lt;/td&gt;&lt;td&gt;[640, 768, 896, 1024]&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;br/&gt;&lt;/td&gt;&lt;td&gt;256&lt;/td&gt;&lt;td&gt;[1280, 1536, 1792, 2048]&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;br/&gt;&lt;/td&gt;&lt;td&gt;512&lt;/td&gt;&lt;td&gt;[2560, 3072, 3584]&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;大&lt;/td&gt;&lt;td&gt;4KB&lt;/td&gt;&lt;td&gt;[4KB，8KB，12KB，...，4072KB]&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;巨&lt;/td&gt;&lt;td&gt;4MB&lt;/td&gt;&lt;td&gt;[4MB，8MB，12MB，...]&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;也就是如果申请一个20字节，那jemalloc会直接申请32字节的空间，这种分配策略必然会有一个问题，有一些散碎的小空间分配不出去（内存碎片），例如(演示需要)&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;(1)  从0开始申请6字节、3字节、3字节、3字节，从图中可以看到，开辟了3*8个字节，但实际使用了(6+3+3+3)字节，空闲了9字节（即为碎片，当然如果有后面有继续申请可能会填满）&lt;/p&gt;&lt;span&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.49513513513513513&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ZULLb8I10cwI9vnic3c981ENdqz9kAXIrP5uwLm1CyhfryDiaL0o88pCd2p2LdI6da1BalhHQD1X3dgxicJWGr3fg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1850&quot;/&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;(2) 开始是填满的，但是删除后空出了一些小空间，后续就无法使用了：&lt;/span&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.46275395033860045&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ZULLb8I10cwI9vnic3c981ENdqz9kAXIr7Paicj6Qw13liaYrOqECARic8cqagRjibMFLQxnWgLl5M6mibzFV2hhiaPdg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1772&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;通常如下情况可能会产生较多的内存碎片：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;大量删除：主动删除(比如上述工单)、被动删除(过期、逐出等)后产生大量内存碎片，导致碎片率上升。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;频繁更新：例如对已经存在的字符串类型键值做append、set扩容（触发sds扩容）操作。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;例如第一节提到的数据删除后，碎片率猛增&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.31564625850340133&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ZULLb8I10cwI9vnic3c981ENdqz9kAXIrgiaFb2jcFMQXMFUyX9wxdvAlpnrIZmxeMhzHuhA6M6pEAV6nibQv2Icw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2940&quot;/&gt;&lt;/figure&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;三、内存碎片的危害&lt;span/&gt;&lt;/h3&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;1. 碎片率&amp;lt;1&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这种情况一般出现在操作系统把Redis内存交换(Swap)到硬盘导致，一定要密切监控这种情况，Redis性能会急剧下降，甚至hang死。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;正确的做法的是，关闭掉swap(&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=Mzg2NTEyNzE0OA==&amp;amp;mid=2247483828&amp;amp;idx=1&amp;amp;sn=cf3381916c0ceead671b0eff32908b25&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;Redis在Linux系统的配置优化&lt;/a&gt;)，大多数看，真死比hang死要好很多。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;2. 碎片率&amp;gt;1&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这种情况说明内存并没有被充分利用，碎片率越高，说明浪费越严重（💰，考虑下1个集群和1万个集群的区别），我们假设有一个日常满的100GB（一主一从）集群，不同碎片率的表现如下：&lt;/p&gt;&lt;section data-tool=&quot;mdnice编辑器&quot;&gt;&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;碎片率&lt;/th&gt;&lt;th&gt;容量&lt;/th&gt;&lt;th&gt;实际占用内存量&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;1.05&lt;/td&gt;&lt;td&gt;100GB * 2&lt;/td&gt;&lt;td&gt;100GB * 2*1.05 = 210GB&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;1.1&lt;/td&gt;&lt;td&gt;100GB * 2&lt;/td&gt;&lt;td&gt;100GB * 2*1.1 = 220GB&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;1.2&lt;/td&gt;&lt;td&gt;100GB * 2&lt;/td&gt;&lt;td&gt;100GB * 2*1.2 = 240GB&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;1.3&lt;/td&gt;&lt;td&gt;100GB * 2&lt;/td&gt;&lt;td&gt;100GB * 2*1.3 = 260GB&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;1.4&lt;/td&gt;&lt;td&gt;100GB * 2&lt;/td&gt;&lt;td&gt;100GB * 2*1.4 = 280GB&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;1.5&lt;/td&gt;&lt;td&gt;100GB * 2&lt;/td&gt;&lt;td&gt;100GB * 2*1.5 = 300GB&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;2&lt;/td&gt;&lt;td&gt;100GB * 2&lt;/td&gt;&lt;td&gt;100GB * 2*2 = 400GB&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;从Redis的内存分配模型看，碎片率是一定存在，但碎片率高到什么程度需要治理，是具体情况具体分析，本文最后会给出一些”最佳实践“&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;四、如何监控Redis内存碎片&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Redis提供info memory命令查看相关内存情况:&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;127.0.0.1&amp;gt; info memory&lt;br/&gt;&lt;span&gt;# Memory&lt;/span&gt;&lt;br/&gt;used_memory:     4285839160&lt;br/&gt;used_memory_rss: 4349640704&lt;br/&gt;mem_fragmentation_ratio:1.01&lt;br/&gt;mem_allocator:jemalloc-5.1.0&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其中有三条指标可以描述碎片率，各自含义如下&lt;/p&gt;&lt;section data-tool=&quot;mdnice编辑器&quot;&gt;&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;指标名&lt;/th&gt;&lt;th&gt;含义&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;used_memory&lt;/td&gt;&lt;td&gt;从Redis角度，Redis占用的内存用量&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;used_memory_rss&lt;/td&gt;&lt;td&gt;从操作系统角度，Redis占用的内存用量&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;mem_fragmentation_ratio&lt;/td&gt;&lt;td&gt;used_memory_rss/used_memory，表示内存碎片率&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/section&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;五、怎么解决内存碎片(Redis版本小于4.0)&lt;span/&gt;&lt;/h3&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;数据对齐：保持键值尽量使用较为固定的长度，说实话这个对业务来说很难做到。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;安全重启&lt;/section&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;slave节点：如无流量，可以重启（一主一从的情况要谨慎，万一重启期间，master挂了。）&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;master节点：如果当前架构可主从切换（例如redis sentinel、redis cluster等），可以尝试（但通常来说主从切换对业务100%有损）&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;li&gt;&lt;section&gt;切换到新集群：新建一个集群，将老集群群整体迁移到新集群（但新集群不久后也会碎片率高）&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;总结：上述方法要不不合实际，要不治标不治本。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;六、怎么解决内存碎片(Redis版本大于等于4.0)&lt;span/&gt;&lt;/h3&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;1. 碎片整理功能：(仅jemalloc支持)&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Redis 4.0 release后，提供了碎片整理功能&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;4.0 RC3&lt;br/&gt;New major feature: Memory de-fragmentation. This feature, contributed by Oran Agra, allows Redis to perform &lt;span&gt;&quot;online defragmentation&quot;&lt;/span&gt; of memory &lt;span&gt;if&lt;/span&gt; the Jemalloc allocator is used. &lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;一图胜过千言万语：经过整理后24字节变为了16字节&lt;/p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.4887940234791889&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ZULLb8I10cwI9vnic3c981ENdqz9kAXIrJYqoVLPx770ViaDTytmZEHN7LicYRrJrOlHjN8EsUzicAdkYGeb99xEpQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1874&quot;/&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;2. 如何开启&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Redis提供了activedefrag配置实现对碎片整理的开启（默认关闭）&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;(1) 启动Redis前添加配置&lt;span/&gt;&lt;/h5&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;activedefrag yes&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;(2) 动态开启&lt;span/&gt;&lt;/h5&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;config &lt;span&gt;set&lt;/span&gt; activedefrag yes (关闭)&lt;br/&gt;config &lt;span&gt;set&lt;/span&gt; activedefrag no (关闭)&lt;br/&gt;config rewrite (记得配置落盘)&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;(3) 动态参数开启(用于测试)&lt;span/&gt;&lt;/h5&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;./redis-server --activedefrag yes&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;3. 相关配置解析&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;为了更好的控制和管理Redis做碎片整理，还提供了多个参数&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;(1)  开启阈值&lt;span/&gt;&lt;/h5&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;active-defrag-ignore-bytes 100mb (默认值)&lt;br/&gt;active-defrag-threshold-lower 10 (默认值)&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;三个条件同时满足：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;activedefrag = yes&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;碎片率大于active-defrag-threshold-lower&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;碎片量大于active-defrag-ignore-bytes&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;if&lt;/span&gt;(frag_pct &amp;lt; server.active_defrag_threshold_lower || frag_bytes &amp;lt; server.active_defrag_ignore_bytes){&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt;;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;(2) 增强系数&lt;span/&gt;&lt;/h5&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;active_defrag_threshold_upper 100（默认值）&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个参数很有迷惑性，好像相对于active-defrag-threshold-lower是碎片整理的上限，其实不是，它是一个增强系数：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;size_t frag_bytes;&lt;br/&gt;//获取碎片率和碎片量&lt;br/&gt;&lt;span&gt;float&lt;/span&gt; frag_pct = getAllocatorFragmentation(&amp;amp;frag_bytes);&lt;br/&gt;int cpu_pct = INTERPOLATE(frag_pct,&lt;br/&gt;                server.active_defrag_threshold_lower,&lt;br/&gt;                server.active_defrag_threshold_upper,&lt;br/&gt;                server.active_defrag_cycle_min,&lt;br/&gt;                server.active_defrag_cycle_max);&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;INTERPOLATE的定义如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;#define INTERPOLATE(x, x1, x2, y1, y2) ( (y1) + ((x)-(x1)) * ((y2)-(y1)) / ((x2)-(x1)) )&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;把公式整理下如下：&lt;/p&gt;&lt;span data-tool=&quot;mdnice编辑器&quot;&gt;&lt;section role=&quot;presentation&quot; data-formula=&quot;y1 + \frac{(x-x1)}{(x2-x1)}*(y2-y1)&amp;#10;&quot; data-formula-type=&quot;block-equation&quot;&gt;&lt;embed src=&quot;https://mmbiz.qpic.cn/mmbiz_svg/X6Ucic5kYIBOO3CzbOEgf4lk6VsBxm8KAwo2gYErt0icKJVJtjld5KZUr5es4pVo1CdfPv0POiacmr0iaFIuOa1YvoNw6RKDHMqU/0?wx_fmt=svg&quot; data-type=&quot;svg+xml&quot;/&gt;&lt;/section&gt;&lt;/span&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;套用公式：&lt;/p&gt;&lt;span data-tool=&quot;mdnice编辑器&quot;&gt;&lt;section role=&quot;presentation&quot; data-formula=&quot;active\_defrag\_cycle\_min + \frac{(frag\_pct-active\_defrag\_threshold\_lower)}{(active\_defrag\_threshold\_upper-active\_defrag\_threshold\_lower)}*(active\_defrag\_cycle\_max-active\_defrag\_cycle\_min)&amp;#10;&quot; data-formula-type=&quot;block-equation&quot;&gt;&lt;embed src=&quot;https://mmbiz.qpic.cn/mmbiz_svg/X6Ucic5kYIBOO3CzbOEgf4lk6VsBxm8KA0tA5tsvTqVPee0Vm9XiatYQbsibheqON6uETn1HG9vibKjSus2qgNB8jCXQ8XJu7Qwt/0?wx_fmt=svg&quot; data-type=&quot;svg+xml&quot;/&gt;&lt;/section&gt;&lt;/span&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可以看到active_defrag_threshold_upper越大，整个值越小，这个值就是用来碎片整理的预估CPU值。&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;(3) 整理粒度&lt;span/&gt;&lt;/h5&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;# active-defrag-cycle-min 25&lt;/span&gt;&lt;br/&gt;&lt;span&gt;# active-defrag-cycle-max 75&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;active-defrag-cycle-min和active-defrag-cycle-max就是每次碎片整理的最小CPU时间和最大CPU时间，上述公式计算得到的cpu_pct还是会被这两个参数限制：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;cpu_pct = LIMIT(cpu_pct, server.active_defrag_cycle_min, server.active_defrag_cycle_max)&lt;br/&gt;&lt;span&gt;#define LIMIT(y, min, max) ((y)&amp;lt;(min)? min: ((y)&amp;gt;(max)? max: (y)))            &lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;需要注意的是，这两个参数在不同版本的Redis默认值不太一样：&lt;/p&gt;&lt;section data-tool=&quot;mdnice编辑器&quot;&gt;&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;参数&lt;/th&gt;&lt;th&gt;4.0.14&lt;/th&gt;&lt;th&gt;5.0.14&lt;/th&gt;&lt;th&gt;6.0.16&lt;/th&gt;&lt;th&gt;6.2.7&lt;/th&gt;&lt;th&gt;7.0.4&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;active-defrag-cycle-min&lt;/td&gt;&lt;td&gt;25&lt;/td&gt;&lt;td&gt;5&lt;/td&gt;&lt;td&gt;1&lt;/td&gt;&lt;td&gt;1&lt;/td&gt;&lt;td&gt;1&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;active-defrag-cycle-max&lt;/td&gt;&lt;td&gt;75&lt;/td&gt;&lt;td&gt;75&lt;/td&gt;&lt;td&gt;25&lt;/td&gt;&lt;td&gt;25&lt;/td&gt;&lt;td&gt;25&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/section&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;(4) 大key优化 (since 5.0.0)&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;碎片整理需要对Redis字典scan，如果在进行中发现set/hash/zset/list/stream的元素个数超过1000，则把这些键值放到一个单独的队列之后进行处理，这样做主要是为了防止碎片整理超时（如果一次scan中包含了很多大的键值，可能在内部已经超时了。）。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;# Maximum number of set/hash/zset/list fields that will be processed from the main dictionary scan&lt;/span&gt;&lt;br/&gt;&lt;span&gt;#active-defrag-max-scan-fields 1000&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;相关代码：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;long defragQuicklist(redisDb *db, dictEntry *kde) {&lt;br/&gt;    robj *ob = dictGetVal(kde);&lt;br/&gt;    quicklist *ql = ob-&amp;gt;ptr;&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (ql-&amp;gt;len &amp;gt; server.active_defrag_max_scan_fields)&lt;br/&gt;        defragLater(db, kde);&lt;br/&gt;    ....&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;long defragZsetSkiplist(redisDb *db, dictEntry *kde) {&lt;br/&gt;    robj *ob = dictGetVal(kde);&lt;br/&gt;    zset *zs = (zset*)ob-&amp;gt;ptr;&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (dictSize(zs-&amp;gt;dict) &amp;gt; server.active_defrag_max_scan_fields)&lt;br/&gt;        defragLater(db, kde);&lt;br/&gt;    ....&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;long defragHash(redisDb *db, dictEntry *kde) {&lt;br/&gt; &lt;span&gt;if&lt;/span&gt; (dictSize(d) &amp;gt; server.active_defrag_max_scan_fields)&lt;br/&gt;        defragLater(db, kde);&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;long defragStream(redisDb *db, dictEntry *kde) {&lt;br/&gt;  ....&lt;br/&gt;    defragLater(db, kde);&lt;br/&gt;    .....&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;long defragSet(redisDb *db, dictEntry *kde) {&lt;br/&gt;  ....&lt;br/&gt;    defragLater(db, kde);&lt;br/&gt;    .....&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;defragLater:&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;//list *defrag_later;&lt;br/&gt;void defragLater(redisDb *db, dictEntry *kde) {&lt;br/&gt;    sds key = sdsdup(dictGetKey(kde));&lt;br/&gt;    listAddNodeTail(db-&amp;gt;defrag_later, key);&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;六、Redis碎片整理原理解析&lt;span/&gt;&lt;/h3&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;1. 什么时候执行&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;碎片整理(activeExpireCycle)在Redis的时间事件中执行，具体路径：serverCron-&amp;gt;databasesCron-&amp;gt;activeExpireCycle&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;serverCron&lt;br/&gt; clientsCron();&lt;br/&gt; .....&lt;br/&gt; databasesCron();&lt;br/&gt;  activeExpireCycle(ACTIVE_EXPIRE_CYCLE_SLOW)&lt;br/&gt;  activeDefragCycle();&lt;br/&gt;  ......&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;相关代码：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;if&lt;/span&gt; (server.active_defrag_enabled)&lt;br/&gt;  activeDefragCycle();&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;2. 执行频率&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;和hz是同步的，默认1秒钟执行十次。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;3. 怎么整理 （以Redis 4代码为例子，Redis 6稍有变化）&lt;span/&gt;&lt;/h4&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;(1) 定期(每秒钟)更新任务超时参数server.active_defrag_running&lt;span/&gt;&lt;/h5&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;run_with_period(1000) {&lt;br/&gt;    size_t frag_bytes;&lt;br/&gt;    &lt;span&gt;float&lt;/span&gt; frag_pct = getAllocatorFragmentation(&amp;amp;frag_bytes);&lt;br/&gt;    &lt;br/&gt;    //前文已经说明&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (!server.active_defrag_running) {&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt;(frag_pct &amp;lt; server.active_defrag_threshold_lower || frag_bytes &amp;lt; server.active_defrag_ignore_bytes)&lt;br/&gt;            &lt;span&gt;return&lt;/span&gt;;&lt;br/&gt;    }&lt;br/&gt;    //前文已经说明&lt;br/&gt;    int cpu_pct = INTERPOLATE(frag_pct, server.active_defrag_threshold_lower, server.active_defrag_threshold_upper, server.active_defrag_cycle_min, server.active_defrag_cycle_max);&lt;br/&gt;    cpu_pct = LIMIT(cpu_pct, server.active_defrag_cycle_min, server.active_defrag_cycle_max);&lt;br/&gt;&lt;br/&gt;  //server.active_defrag_running是执行限定时间的重要因素&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (!server.active_defrag_running || cpu_pct &amp;gt; server.active_defrag_running)&lt;br/&gt;        server.active_defrag_running = cpu_pct;&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;//任务超时时间：争分夺秒&lt;br/&gt;timelimit = 1000000*server.active_defrag_running/server.hz/100;&lt;br/&gt;&lt;span&gt;if&lt;/span&gt; (timelimit &amp;lt;= 0) timelimit = 1;&lt;br/&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;(2) 开始整理&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;针对每一个db进行scan，进行如下回调：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;defragDictBucketCallback：针对每个bucket进行碎片整理&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;defragScanCallback：针对每个dictEntry进行碎片整理&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;timelimit = 1000000*server.active_defrag_running/server.hz/100;&lt;br/&gt;&lt;span&gt;if&lt;/span&gt; (timelimit &amp;lt;= 0) timelimit = 1;&lt;br/&gt;&lt;span&gt;do&lt;/span&gt; {&lt;br/&gt;    cursor = dictScan(db-&amp;gt;dict, cursor, defragScanCallback, defragDictBucketCallback, db);&lt;br/&gt;    //检查是否超时&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (cursor &amp;amp;&amp;amp; (++iterations &amp;gt; 16 || server.stat_active_defrag_hits - defragged &amp;gt; 1000)) {&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; ((ustime() - start) &amp;gt; timelimit) {&lt;br/&gt;            &lt;span&gt;return&lt;/span&gt;;&lt;br/&gt;        }&lt;br/&gt;        iterations = 0;&lt;br/&gt;        defragged = server.stat_active_defrag_hits;&lt;br/&gt;    }&lt;br/&gt;} &lt;span&gt;while&lt;/span&gt;(cursor);&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;defragDictBucketCallback的逻辑：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;void defragDictBucketCallback(void *privdata, dictEntry **bucketref) {&lt;br/&gt;    UNUSED(privdata);&lt;br/&gt;    &lt;span&gt;while&lt;/span&gt;(*bucketref) {&lt;br/&gt;        dictEntry *de = *bucketref, *newde;&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; ((newde = activeDefragAlloc(de))) {&lt;br/&gt;            *bucketref = newde;&lt;br/&gt;        }&lt;br/&gt;        bucketref = &amp;amp;(*bucketref)-&amp;gt;next;&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;defragScanCallback的逻辑&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;void defragScanCallback(void *privdata, const dictEntry *de) {&lt;br/&gt;    int defragged = defragKey((redisDb*)privdata, (dictEntry*)de);&lt;br/&gt;    server.stat_active_defrag_hits += defragged;&lt;br/&gt;    if(defragged)&lt;br/&gt;        server.stat_active_defrag_key_hits++;&lt;br/&gt;    else&lt;br/&gt;        server.stat_active_defrag_key_misses++;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;defragKey对dictEntry中sds key和各个类型的value进行整理(复杂类型就是for循环整理)&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;int defragKey(redisDb *db, dictEntry *de) {&lt;br/&gt;    sds keysds = dictGetKey(de);&lt;br/&gt;&lt;br/&gt;    //整理key sds&lt;br/&gt;    newsds = activeDefragSds(keysds);&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (newsds)&lt;br/&gt;        defragged++, de-&amp;gt;key = newsds;&lt;br/&gt;   ....&lt;br/&gt;&lt;br/&gt;  //整理value robj&lt;br/&gt;    ob = dictGetVal(de);&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; ((newob = activeDefragStringOb(ob, &amp;amp;defragged))) {&lt;br/&gt;        de-&amp;gt;v.val = newob;&lt;br/&gt;        ob = newob;&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (ob-&amp;gt;&lt;span&gt;type&lt;/span&gt; == OBJ_STRING) {&lt;br/&gt;        /* Already handled &lt;span&gt;in&lt;/span&gt; activeDefragStringOb. */&lt;br/&gt;    } &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (ob-&amp;gt;&lt;span&gt;type&lt;/span&gt; == OBJ_LIST) {&lt;br/&gt;        //循环整理quicklist或者ziplist的每个元素 &lt;br/&gt;    } &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (ob-&amp;gt;&lt;span&gt;type&lt;/span&gt; == OBJ_SET) {&lt;br/&gt;        //循环整理&lt;span&gt;hash&lt;/span&gt;或者intset的每个元素 &lt;br/&gt;    } &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (ob-&amp;gt;&lt;span&gt;type&lt;/span&gt; == OBJ_ZSET) {&lt;br/&gt;        //循环整理skiplist或者ziplist的每个元素 &lt;br/&gt;    } &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (ob-&amp;gt;&lt;span&gt;type&lt;/span&gt; == OBJ_HASH) {&lt;br/&gt;        //循环整理&lt;span&gt;hash&lt;/span&gt;或者ziplist的每个元素 &lt;br/&gt;    } &lt;br/&gt;    ....&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; defragged;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;activeDefragSds针对sds可能的碎片进行整理&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;sds activeDefragSds(sds sdsptr) {&lt;br/&gt;    void* ptr = sdsAllocPtr(sdsptr);&lt;br/&gt;    void* newptr = activeDefragAlloc(ptr);&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (newptr) {&lt;br/&gt;        size_t offset = sdsptr - (char*)ptr;&lt;br/&gt;        sdsptr = (char*)newptr + offset;&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; sdsptr;&lt;br/&gt;    }&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; NULL;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;activeDefragAlloc是核心方法，其调用jemalloc相关函数判断是否有整理价值，如需要则重新整理(生成new 释放old)&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;void* activeDefragAlloc(void *ptr) {&lt;br/&gt;    int bin_util, run_util;&lt;br/&gt;    size_t size;&lt;br/&gt;    void *newptr;&lt;br/&gt;    //不值得整理&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt;(!je_get_defrag_hint(ptr, &amp;amp;bin_util, &amp;amp;run_util)) {&lt;br/&gt;        server.stat_active_defrag_misses++;&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; NULL;&lt;br/&gt;    }&lt;br/&gt;    //不值得整理&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (run_util &amp;gt; bin_util || run_util == 1&amp;lt;&amp;lt;16) {&lt;br/&gt;        server.stat_active_defrag_misses++;&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; NULL;&lt;br/&gt;    }&lt;br/&gt;    &lt;br/&gt;    //分配新区域，丢掉老的&lt;br/&gt;    size = zmalloc_size(ptr);&lt;br/&gt;    newptr = zmalloc_no_tcache(size);&lt;br/&gt;    memcpy(newptr, ptr, size);&lt;br/&gt;    zfree_no_tcache(ptr);&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; newptr;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其中int je_get_defrag_hint(void* ptr, int *bin_util, int *run_util)是jemalloc库函数用于判断是否值得整理。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;/* this method was added to jemalloc &lt;span&gt;in&lt;/span&gt; order to &lt;span&gt;help&lt;/span&gt; us understand &lt;span&gt;which&lt;/span&gt;&lt;br/&gt; * pointers are worthwhile moving and &lt;span&gt;which&lt;/span&gt; aren&lt;span&gt;&#x27;t */&lt;br/&gt;int je_get_defrag_hint(void* ptr, int *bin_util, int *run_util);&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;七、核心监控参数和&lt;span/&gt;&lt;/h3&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;1. active_defrag_running&lt;span/&gt;&lt;/h5&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;2. active_defrag_key_hits和active_defrag_key_misses&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;站在每个key的角度看，是否命中碎片整理。&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;3. active_defrag_hits和active_defrag_misses&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;站在每个key-values(如果是复杂数据结构，就可能多次)，是否命中碎片整理。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;例如一个hash键值对，有200个元素，其中有元素要做碎片整理：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;active_defrag_key_hits = 1&lt;br/&gt;active_defrag_hits &amp;gt; 1&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;七、最佳实践&lt;span/&gt;&lt;/h3&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;1. 开不开&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;最“佳”实践&lt;/span&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;如果规模不大、碎片率不高、没专职维护建议关闭，ROI低。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;如果规模大（比如我司100万+个节点），碎片整理的成本效果很明显，”成本优化，降本增效~“&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;img data-ratio=&quot;1.2317073170731707&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ZULLb8I10cwI9vnic3c981ENdqz9kAXIrWcljaglaC6r0m4fAfKVribw2zNe3suN633Kaugz2FbZzvXB6EoGlXwQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;656&quot;/&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;2. 怎么配置&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里重点说下active-defrag-cycle-min和active-defrag-cycle-max，因为设置不当的话可能会影响Redis的性能或者可用性。&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;选择大于4.0版本的Redis，该版本碎片整理处于试验阶段(比如大key问题，但不用惊慌没有大问题(线上数十万实例开启))&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;不要用默认值，建议根据业务场景进行调节，例如本文提到的业务超敏感型业务，可以直接调低或者关掉。Redis的工作线程是非常忙的：各种cron。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;需要注意的是，这两个参数在不同版本的Redis默认值不太一样：&lt;/p&gt;&lt;section data-tool=&quot;mdnice编辑器&quot;&gt;&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;参数&lt;/th&gt;&lt;th&gt;4.0.14&lt;/th&gt;&lt;th&gt;5.0.14&lt;/th&gt;&lt;th&gt;6.0.16&lt;/th&gt;&lt;th&gt;6.2.7&lt;/th&gt;&lt;th&gt;7.0.4&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;active-defrag-cycle-min&lt;/td&gt;&lt;td&gt;25&lt;/td&gt;&lt;td&gt;5&lt;/td&gt;&lt;td&gt;1&lt;/td&gt;&lt;td&gt;1&lt;/td&gt;&lt;td&gt;1&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;active-defrag-cycle-max&lt;/td&gt;&lt;td&gt;75&lt;/td&gt;&lt;td&gt;75&lt;/td&gt;&lt;td&gt;25&lt;/td&gt;&lt;td&gt;25&lt;/td&gt;&lt;td&gt;25&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;最“佳”实践(一定不要用默认值)&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我的线上配置是Redis 6+、active-defrag-cycle-min：5、active-defrag-cycle-max：10&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;3. 怎么开&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;最“佳”实践&lt;/span&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;低峰开：一般是夜间(和业务场景有关，比如海外业务可能就不适合)，但需要配合一定调度能力，Redis并没有提供按时间段开启功能。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;暴力开：降低active-defrag-cycle-min和active-defrag-cycle-max，提高安全系数。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;4.版本选择&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;(1) Redis 4：试验版本，除了大key问题，整体还好，如果用了也不用过渡担心它的稳定性&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;########################### ACTIVE DEFRAGMENTATION #######################&lt;/span&gt;&lt;br/&gt;&lt;span&gt;#&lt;/span&gt;&lt;br/&gt;&lt;span&gt;# WARNING THIS FEATURE IS EXPERIMENTAL. However it was stress tested&lt;/span&gt;&lt;br/&gt;&lt;span&gt;# even in production and manually tested by multiple engineers for some&lt;/span&gt;&lt;br/&gt;&lt;span&gt;# time.&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;(2) Redis5：是碎片整理的第二个版本(例如解决了大key问题)，&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;release note: Active defragmentation version 2&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但它还是试验版本：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;########################### ACTIVE DEFRAGMENTATION #######################&lt;/span&gt;&lt;br/&gt;&lt;span&gt;#&lt;/span&gt;&lt;br/&gt;&lt;span&gt;# WARNING THIS FEATURE IS EXPERIMENTAL. However it was stress tested&lt;/span&gt;&lt;br/&gt;&lt;span&gt;# even in production and manually tested by multiple engineers for some&lt;/span&gt;&lt;br/&gt;&lt;span&gt;# time.&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;(3) 大于Redis 6：正式版&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;没了EXPERIMENTAL的标识&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;最“佳”实践&lt;/span&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;最好选择Redis 6以上版本，毕竟是正式版。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;如果选择了Redis 4、5版本，也不用过渡惊慌，基本还好。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;在整体碎片率上，Redis 6确实高于Redis 3、4，下面是一组数据：&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;section data-tool=&quot;mdnice编辑器&quot;&gt;&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;&lt;br/&gt;&lt;/th&gt;&lt;th&gt;实例数&lt;/th&gt;&lt;th&gt;平均碎片率&lt;/th&gt;&lt;th&gt;jemalloc版本&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;Redis 3.0.5&lt;/td&gt;&lt;td&gt;2235&lt;/td&gt;&lt;td&gt;1.28&lt;/td&gt;&lt;td&gt;jemalloc-3.6.0&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;Redis 4.0.14&lt;/td&gt;&lt;td&gt;451361&lt;/td&gt;&lt;td&gt;1.156&lt;/td&gt;&lt;td&gt;jemalloc-4.0.3&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;Redis 6.0.15&lt;/td&gt;&lt;td&gt;623632&lt;/td&gt;&lt;td&gt;1.112&lt;/td&gt;&lt;td&gt;jemalloc-5.1.0&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;(1) Redis 3采样较少，可以忽略&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;(2) Redis 4、6如无特殊均开启碎片整理&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;(3) Redis 6的碎片率比Redis 4确实低了一丢丢&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;(4) 不同版本的jemalloc不同，猜测肯定越来越优秀(这块了解不多，正在学习，请了解的大佬指教)&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;5. 怎么监控&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;最“佳”实践&lt;/span&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;实例、集群、全局数据收集、监控图、报警策略：active_defrag_running、active_defrag_key_hits|misses、active_defrag_hits|misses&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;”时刻“监控used_cpu_*&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;核心日志：但注意对于Redis来说打印太多日志不是什么好事情&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;6. memory purge命令清理&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;除了碎片整理配置，也可以通过如下命令实现&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;127.0&lt;/span&gt;&lt;span&gt;.0&lt;/span&gt;&lt;span&gt;.1&lt;/span&gt;:&lt;span&gt;6379&lt;/span&gt;&amp;gt; memory purge&lt;br/&gt;OK&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但需要注意的是，他和defrag不同的是，它们的不是作用在同一块内存，memory purge主要用于清理脏页：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;int &lt;span&gt;&lt;span&gt;jemalloc_purge&lt;/span&gt;&lt;/span&gt;() {&lt;br/&gt;    /* &lt;span&gt;return&lt;/span&gt; all unused (reserved) pages to the OS */&lt;br/&gt;    char tmp[32];&lt;br/&gt;    unsigned narenas = 0;&lt;br/&gt;    size_t sz = sizeof(unsigned);&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (!je_mallctl(&lt;span&gt;&quot;arenas.narenas&quot;&lt;/span&gt;, &amp;amp;narenas, &amp;amp;sz, NULL, 0)) {&lt;br/&gt;        sprintf(tmp, &lt;span&gt;&quot;arena.%d.purge&quot;&lt;/span&gt;, narenas);&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (!je_mallctl(tmp, NULL, 0, NULL, 0))&lt;br/&gt;            &lt;span&gt;return&lt;/span&gt; 0;&lt;br/&gt;    }&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; -1;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;通过原理以及实际场景看，memory purge的整理效果是没有defrag明显的，如果有需要可以结合使用。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;7. 一些“谣言”和&quot;错误&quot;&lt;span/&gt;&lt;/h4&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;(1) 1 &amp;lt; mem_fragmentation_ratio &amp;lt; 1.5 ,可以认为是合理的，无需处理&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个和规模有关，如果规模较大，你能视而不见吗？&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;(2) active-defrag-max-scan-fields配置的含义&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;错误：直译&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;# 碎片整理期间，对于 List/Set/Hash/ZSet 类型元素一次 Scan 的数量&lt;/span&gt;&lt;br/&gt;&lt;span&gt;# Maximum number of set/hash/zset/list fields that will be processed from the main dictionary scan&lt;/span&gt;&lt;br/&gt;&lt;span&gt;# active-defrag-max-scan-fields 1000&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;正确：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;对于List/Set/Hash/ZSet类型元素数量大于XX，则不在scan dict中完成，通过上文我们知道有一个单独的队列，防止超时。&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;(3) active_defrag_threshold_upper配置的含义&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个参数很有迷惑性，好像相对于active-defrag-threshold-lower是碎片整理的上限，其实不是，它是一个增强系数，这个网上好多解释有问题。&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;(4)  frag_pct 等同于 mem_fragmentation_ratio？&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;错误：它两是一回事&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;正确：它们不完全相等，可以看下源码中的描述，&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;float&lt;/span&gt; getAllocatorFragmentation(size_t *out_frag_bytes) {&lt;br/&gt;    size_t epoch = 1, allocated = 0, resident = 0, active = 0, sz = sizeof(size_t);&lt;br/&gt;    ......&lt;br/&gt;    //stats.resident与操作系统的RSS不同，它不包含共享库和other non heap mappings&lt;br/&gt;    je_mallctl(&lt;span&gt;&quot;stats.resident&quot;&lt;/span&gt;, &amp;amp;resident, &amp;amp;sz, NULL, 0);&lt;br/&gt;    &lt;br/&gt;    //stats.active和stats.resident 不同，它不包含jemalloc保留以供重用的页面&lt;br/&gt;    je_mallctl(&lt;span&gt;&quot;stats.active&quot;&lt;/span&gt;, &amp;amp;active, &amp;amp;sz, NULL, 0);&lt;br/&gt;    &lt;br/&gt;    //stats.allocated与zmalloc_used_memory 不同，它通过考虑此进程完成的所有分配&lt;br/&gt;    je_mallctl(&lt;span&gt;&quot;stats.allocated&quot;&lt;/span&gt;, &amp;amp;allocated, &amp;amp;sz, NULL, 0);&lt;br/&gt;    &lt;span&gt;float&lt;/span&gt; frag_pct = ((&lt;span&gt;float&lt;/span&gt;)active / allocated)*100 - 100;&lt;br/&gt;    size_t frag_bytes = active - allocated;&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; frag_pct;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>d9d28e32114a5b870f5fc4df184d91b7</guid>
<title>万星开源项目强势回归「GitHub 热点速览 v.22.38」</title>
<link>https://toutiao.io/k/xj6pyxs</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5624414903576109&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/xBgIbW1vdNMibPQ8veKibgNNGqdhGO2h03ibgDfbTJta8EBDYOZIxicZa9E5nS6whNUjsnbpQTTh5xgWSibicPQk5xIQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;5341&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;作者：HelloGitHub-小鱼干&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;本周霸榜的 GitHub 项目多为老项目，比如：老面孔的 theatre 凭借极其优秀的动画功底连续三天霸榜 TypeScript 类目。借 Figma 被 Adobe 收购之风，又出现在 GitHub Trending 的设计协作项目 penpot，连接多种数据源和应用的工作流自动工 n8bn，支持多种存储的文件分享工具 alist，都是开源许久的项目，重新回归趋势。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;同样的，ReadME Podcast is back。断更 9 个月之后，开源作者的故事重新开始，官方播客恢复更新。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;最后，不要错过本周新上线的 2 位小将——Facebook 开源的 JS 测试工具 memlab 以及从零开始学神经网络的 nn-zero-to-hero。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;以下内容摘录自微博&lt;/span&gt;&lt;span&gt;@HelloGitHub&lt;/span&gt;&lt;span&gt; 的 GitHub Trending 及 Hacker News 热帖（简称 HN 热帖），选项标准：&lt;/span&gt;&lt;code&gt;&lt;span&gt;新发布&lt;/span&gt;&lt;/code&gt;&lt;span&gt; | &lt;/span&gt;&lt;code&gt;&lt;span&gt;实用&lt;/span&gt;&lt;/code&gt;&lt;span&gt; | &lt;/span&gt;&lt;code&gt;&lt;span&gt;有趣&lt;/span&gt;&lt;/code&gt;&lt;span&gt;，根据项目 release 时间分类，发布时间不超过 14 day 的项目会标注 &lt;/span&gt;&lt;code&gt;&lt;span&gt;New&lt;/span&gt;&lt;/code&gt;&lt;span&gt;，无该标志则说明项目 release 超过半月。由于本文篇幅有限，还有部分项目未能在本文展示，望周知 🌝&lt;/span&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6749311294765841&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/xBgIbW1vdNMibPQ8veKibgNNGqdhGO2h03XExwBTCYiaYwthx6PRxgGavmoGP06Ym4UCx7Qy53C4Ll3ABjtTHyDIA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1452&quot;/&gt;&lt;/figure&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;News 快读&lt;/span&gt;&lt;/h2&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;社区·ReadME Podcast 回归&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;ReadME Podcast 是 GitHub 官方主导的专注于开源项目、项目发起人的播客。官方最新发布的消息，新一期的播客将在 9 月 21 日上线。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;值得一提的是，大家熟悉的 Vue.js 作者尤雨溪曾在第 2 期播客中担任嘉宾。而本期（第 21 期）播客也是 ReadME Podcast 断更近 9 个月之后再次开播。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;如果你想知道这些开源项目背后发生的故事，不妨订阅下 ReadME Podcast。英文听力不好的小伙伴别担心，每期播客配有相关的英文文稿方便你阅读，以往播客可查看&lt;/span&gt;&lt;span&gt;https://github.com/readme/podcast&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.525&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/xBgIbW1vdNMibPQ8veKibgNNGqdhGO2h03VAaF2fibxNPkPYZc9lOyynDHYFPadtxmldPJepzoOriatBIIA6fzAPFA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;680&quot;/&gt;&lt;/figure&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;1. 本周特推&lt;/span&gt;&lt;/h2&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;1.1 设计协作：penpot&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;主语言：Clojure&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;Penpot 是一个开源的设计、原型绘制平台，支持跨部门合作。它不依赖操作系统，纯基于 Web 和 SVG，所以你只要有一个浏览器便可和他人共同完成设计。作为 Sketch 长期用户，个人觉得 Penpot 使用起来用户体验不如 Sketch 和 Figma，比如参考线不够明显。但如果你想自托管一个设计工具，且做一些简单的原型设计不妨试试 Penpot，在线体验地址 &lt;/span&gt;&lt;span&gt;https://penpot.app/&lt;/span&gt;&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;GitHub 地址→https://github.com/penpot/penpot&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.5625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/xBgIbW1vdNMibPQ8veKibgNNGqdhGO2h03mNZbK82gD6R9iaogwOltIXicPd557ECicmox8djBx1oafhmvkyWIvbsFQ/640?wx_fmt=gif&quot; data-type=&quot;gif&quot; data-w=&quot;720&quot;/&gt;&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;1.2 从零开始学神经网络：nn-zero-to-hero&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;主语言：Jupyter Notebook&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;New&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 保姆级视频教程带你入门神经网络，除了视频教程之外项目还配有相关的 Neural Networks 练习。&lt;/span&gt;&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;GitHub 地址→https://github.com/karpathy/nn-zero-to-hero&lt;/p&gt;&lt;/blockquote&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5635792778649922&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/xBgIbW1vdNMibPQ8veKibgNNGqdhGO2h03k5vc5qk3SU9eUVdmpFzL5CdcWxuzW0aXWfxPu9uXib9CUlGicxAWiaDXA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1274&quot;/&gt;&lt;/figure&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;2. GitHub Trending 周榜&lt;/span&gt;&lt;/h2&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;2.1 E2E 测试框架：memlab&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;本周 star 增长数：1,850+&lt;strong&gt;，&lt;/strong&gt;主语言：TypeScript&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;New&lt;/span&gt;&lt;/code&gt;&lt;span&gt; memlab Facebook 开源的端到端测试、分析框架，可用来找寻 JavaScript 内存泄漏及优化点。特性：&lt;/span&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;浏览器内存泄漏检测&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;面向对象的堆遍历 API&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;内存 CLI 工具箱&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;Node.js 内存断言&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;GitHub 地址→https://github.com/facebookincubator/memlab&lt;/p&gt;&lt;/blockquote&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5411214953271029&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/xBgIbW1vdNMibPQ8veKibgNNGqdhGO2h03ygfgpibboCBRqibIUrbbLzBJMibxmvOhe77oXricx4kVicuKjlHNv8rWSuA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2140&quot;/&gt;&lt;/figure&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;2.2 动画库：theatre&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;本周 star 增长数：800+&lt;strong&gt;，&lt;/strong&gt;主语言：TypeScript&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;Theatre.js 可用来制作高质量的动画，复杂的运动也不在话下。比如，你可以用它结合 Three.js 之类的 3D 库来绘制 3D 图形；或是用 React 实现 HTML/SVG 制作，也支持微交互设计。当然，动画 JavaScript 变量不在话下。&lt;/span&gt;&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;GitHub 地址→https://github.com/theatre-js/theatre&lt;/p&gt;&lt;/blockquote&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6860687022900763&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/xBgIbW1vdNMibPQ8veKibgNNGqdhGO2h03jbNtyWXQ9b6XrmxWcdBGEurR5HyD7XBlaBz8dXPKpxBcAAQ8ubNWew/640?wx_fmt=gif&quot; data-type=&quot;gif&quot; data-w=&quot;1048&quot;/&gt;&lt;/figure&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;2.3 工作流自动化：n8n&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;本周 star 增长数：800+&lt;strong&gt;，&lt;/strong&gt;主语言：TypeScript&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;一个可扩展的工作流自动化工具。通过 n8n 你可以连接各类节点，让他们进行数据通信。目前 n8n 支持 300+ 类节点，可快速在不同应用和数据库之间进行数据转换，不用烦恼去读 API 文档及排查 CORS 错误。&lt;/span&gt;&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;GitHub 地址→https://github.com/n8n-io/n8n&lt;/p&gt;&lt;/blockquote&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5991525423728814&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/xBgIbW1vdNMibPQ8veKibgNNGqdhGO2h03J5mSRzfK5F3BsEHxYicVETPKPCibFiccQqgouLLvuiaTY3WCFDaichp5XMg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1180&quot;/&gt;&lt;/figure&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;2.4 轻量笔记工具：notes&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;本周 star 增长数：950+&lt;strong&gt;，&lt;/strong&gt;主语言：C++&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;一款极简笔记工具用来记录你的灵光一闪。notes 具有低内存占用、原生、多主题模式、支持跨平台、可用 Markdown 等特性。&lt;/span&gt;&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;GitHub 地址→https://github.com/nuttyartist/notes&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.66015625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/xBgIbW1vdNMibPQ8veKibgNNGqdhGO2h0333yr55SnaIromZoN3OvjOMdhVad5InVBxzALugJL9PE32duQIvacxA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;2.5 文件分享：alist&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;本周 star 增长数：400+&lt;strong&gt;，&lt;/strong&gt;主语言：Go&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;一个使用 Gin 和 SolidJS 实现的文件分享工具，借助 alist 可快速分享文件。alist 支持多种存储方式，本地存储、阿里云、S3、百度云盘等主流方式都支持。&lt;/span&gt;&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;GitHub 地址→https://github.com/alist-org/alist&lt;/p&gt;&lt;/blockquote&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.627906976744186&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/xBgIbW1vdNMibPQ8veKibgNNGqdhGO2h039GiaftBbc2xFSgzd7BTdu8NtIEzLU2rvKHWugqzvLoiaMe3dKSk2PeKg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1290&quot;/&gt;&lt;/figure&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;3. 往期回顾&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;往期回顾：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;以上为 2022 年第 38 个工作周的 GitHub Trending 🎉如果你 Pick 其他好玩、实用的 GitHub 项目，记得来 HelloGitHub issue 区和我们分享下哟 🌝&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;最后，记得你在本文留言区留下你想看的主题 Repo（限公众号），例如：AI 换头。👀 和之前的送书活动类似，留言点赞 Top3 的小伙伴(&lt;span&gt;棒&lt;/span&gt;），小鱼干会努力去找 Repo 的^^&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;HelloGitHub 交流群现已全面开放，添加微信号：HelloGitHub001 为好友入群，可同前端、Java、Go 等各界大佬谈笑风生、切磋技术~&lt;/p&gt;&lt;/blockquote&gt;&lt;span&gt;- END -&lt;/span&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>f237fb32d66f333f3fbf4e37073d712c</guid>
<title>论文精读 | Processor Microarchitecture - Decode</title>
<link>https://toutiao.io/k/0tlc06k</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content                           autoTypeSetting24psection&amp;#10;                          &quot; id=&quot;js_content&quot;&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot; data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;&lt;span&gt;《Processor Microarchitecture: An Implementation Perspective》对微架构中的缓存、取指、解码、寄存器分配、指令 &lt;/span&gt;&lt;span&gt;issue、指令执行、指令提交等环节，从硬件实现的角度进行了阐述。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;本文为该论文阅读笔记，对应原文第四章「Decode」，主要讲了译码单元的组成和工作原理，强烈推荐&lt;/span&gt;&lt;span&gt;感兴趣的同学去阅读作者的原文。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;578&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;687&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.7223140495867768&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/xNm29D5VjShbGvS67C3uPccR79MHz17cXMLedAT4zkwSdWuctibDQgqYhW0qbuJnhGc37wHb7OEcyPJ1Umaaekw/640?wx_fmt=jpeg&quot; data-type=&quot;png&quot; data-w=&quot;605&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;引言&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.02666666666666667&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/JJtKEey0hPY533fpibxanI0U85VuicLBnicd9oVaZKApEJqUs2UFnKCgRiaNnvOKeq9HkibP18sxDSwNj7f7ffichBMA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;750&quot;/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;「&lt;/span&gt;&lt;span&gt;Processor Microarchitecture: An Implementation Perspective」是由 Antonio González, Fernando Latorre, and Grigorios Magklis 等人于 2011 年发表的 Lecture。&lt;/span&gt;&lt;span/&gt;&lt;/section&gt;&lt;p data-pid=&quot;34hI_W_T&quot;&gt;&lt;span&gt;该文献阐述了微架构中各个部件的作用、实现思路、各个实现方案的原理与优缺点。&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;&lt;p data-pid=&quot;0W1Lmds3&quot;&gt;&lt;span&gt;下文将以 &lt;/span&gt;&lt;strong&gt;&lt;em&gt;&lt;span&gt;斜体 &lt;/span&gt;&lt;/em&gt;&lt;/strong&gt;&lt;span&gt;标注笔者简单的评注，帮助大家区分作者描述的内容与笔者评注内容，&lt;span&gt;希望能对大家的工作与学习有所帮助。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span/&gt;&lt;span/&gt;&lt;/p&gt;&lt;section&gt;&lt;strong&gt;一、译码单元概述&lt;/strong&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.02666666666666667&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/JJtKEey0hPY533fpibxanI0U85VuicLBnicd9oVaZKApEJqUs2UFnKCgRiaNnvOKeq9HkibP18sxDSwNj7f7ffichBMA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;750&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;译码单元主要负责理解指令的语义，将指令翻译成处理器应该进行的操作，主要包括&lt;/span&gt;&lt;span&gt;：&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;翻译指令的类型，例如 控制指令、访存指令、计算指令 等&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;确定指令具体要做什么操作，比如对于计算类指令，译码单元要负责翻译具体是什么 ALU 运算&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;确定指令需要什么资源，比如对于计算类指令，译码单元要负责确定该指令需要读入哪个寄存器，写回哪个寄存器&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot; data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;p data-pid=&quot;smL6VZxw&quot;&gt;&lt;span&gt;一般来说，指令是以二进制字节流 (raw stream) 的形式给到译码单元的。译码单元首先要将字节流进行分段，分成多个独立的指令，然后再对分段的指令进行翻译，生成后续单元的控制信号。&lt;/span&gt;&lt;/p&gt;&lt;p data-pid=&quot;Jr547PeJ&quot;&gt;&lt;span&gt;译码单元的复杂程度跟 ISA 的设计，以及 ISA 中指令的数量有很大的关系。&lt;/span&gt;&lt;/p&gt;&lt;p data-pid=&quot;smL6VZxw&quot;&gt;&lt;span/&gt;&lt;/p&gt;&lt;section&gt;&lt;strong&gt;二、RISC Decoding&lt;/strong&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.02666666666666667&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/JJtKEey0hPY533fpibxanI0U85VuicLBnicd9oVaZKApEJqUs2UFnKCgRiaNnvOKeq9HkibP18sxDSwNj7f7ffichBMA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;750&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;下图是一个超标量 RISC 架构译码单元的结构图：&lt;/span&gt;&lt;/section&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.3804004214963119&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/xNm29D5VjSjkyy7wT4Z09MuZZJad6hzOD2PicbYUp96ZMZGjv79AGbDibh4V7T22ubK8ict6BEiaQLjQ3DQ6oHRemA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;949&quot;/&gt;&lt;/figure&gt;&lt;p data-pid=&quot;uGYOpCBB&quot;&gt;&lt;span&gt;RISC 架构的指令编码一般来说会比较简单，易于译码：&lt;/span&gt;&lt;/p&gt;&lt;p data-pid=&quot;D3T7HsWu&quot;&gt;&lt;span&gt;因此很多高性能的 RISC 架构能够做到单周期完成译码操作。这也正好对应了 RISC 的一个设计初衷：易于译码、控制信号生成简单，有助于实现高性能架构。&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;&lt;p data-pid=&quot;D3T7HsWu&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;strong&gt;三、X86 ISA&lt;/strong&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.02666666666666667&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/JJtKEey0hPY533fpibxanI0U85VuicLBnicd9oVaZKApEJqUs2UFnKCgRiaNnvOKeq9HkibP18sxDSwNj7f7ffichBMA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;750&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;X86 是一个变长 CISC 指令集，其指令编码格式如下图所示：&lt;/span&gt;&lt;br/&gt;&lt;/section&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.3736111111111111&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/xNm29D5VjSjkyy7wT4Z09MuZZJad6hzOcqOvn8xwDurpqA68NadjKcqoZh8lqv5S5DHoamibPyp3wFUg91COYDg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;720&quot;/&gt;&lt;/figure&gt;&lt;p data-pid=&quot;Lg0DXF8O&quot;&gt;&lt;span&gt;由于指令的长度是不确定的，因此在解码时，能否快速计算出指令的长度对性能来说至关重要。但对于 x86 指令集而言，想要计算出指令长度，就必须要先解析 opcode，得知当前指令是什么类型的指令，才能解析后续的字段。然而 x86 ISA 一方面不确定 opcode 字段从哪个字节开始（prefixes 长度为 1~4 Byte），另一方面也不确定 opcode 字段本身有多长（1~3 Byte），因此该过程比较复杂。&lt;/span&gt;&lt;/p&gt;&lt;p data-pid=&quot;R6t22jTb&quot;&gt;&lt;span&gt;另外，由于 x86 的操作数既可以是寄存器，也可以是内存中的地址，而且寄存器还涉及到不同的编码格式，因此译码时确定操作数的过程同样也很复杂。&lt;/span&gt;&lt;/p&gt;&lt;p data-pid=&quot;EiqtU5tx&quot;&gt;&lt;span&gt;因此，x86 指令集的译码是相当复杂的。对于现代 x86 处理器，译码往往要花费数个周期，并为芯片设计引入了很大的复杂度。&lt;/span&gt;&lt;/p&gt;&lt;p data-pid=&quot;EiqtU5tx&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;strong&gt;四、Dynamic Translation&lt;/strong&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.02666666666666667&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/JJtKEey0hPY533fpibxanI0U85VuicLBnicd9oVaZKApEJqUs2UFnKCgRiaNnvOKeq9HkibP18sxDSwNj7f7ffichBMA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;750&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;x86 指令中所包含的信息比较丰富，一条指令往往对应于执行单元中的多个动作。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span/&gt;&lt;span&gt;以加法指令为例，“add [eax], ebx”这一条指令包含了三个动作：&lt;/span&gt;&lt;span&gt;从 eax 所指向的地址中读入数据、将该数据与 ebx 存储的数据相加、再将结果写回到 eax 所指向的地址。&lt;/span&gt;&lt;/section&gt;&lt;p data-pid=&quot;gJZQ7YFj&quot;&gt;&lt;span&gt;对于乱序执行的单元来说，要执行这么大一个粒度的指令，需要设计非常复杂的控制逻辑，才能保证正确执行。另外，这种粗粒度的指令，也不太适合做指令级并行，不利于整体性能的提高。因此对于乱序执行处理器而言，CISC 指令集并不高效。&lt;/span&gt;&lt;/p&gt;&lt;p data-pid=&quot;qjoMREWi&quot;&gt;&lt;span&gt;而对于 RISC 指令集来说，上述操作在编译时就会被翻译为三个简单指令：load、add、store。这些简单指令，能够很轻易的被乱序执行单元处理，不需要特别复杂的控制逻辑。同时这些指令也能够跟其他无依赖的指令并行，有利于性能的提升。&lt;/span&gt;&lt;/p&gt;&lt;p data-pid=&quot;P0CwbJRJ&quot;&gt;&lt;span&gt;因此 x86 处理器在 ISA 层面上保留了 CISC 风格的指令，但在译码时，会将这些指令动态翻译 (dynamic translate) 成 RISC 风格的指令。Intel 将这些 RISC 风格的指令称作微指令 (micro-operations，μops)。&lt;/span&gt;&lt;/p&gt;&lt;p data-pid=&quot;H8W9lexn&quot;&gt;&lt;span&gt;最早的 x86 μops 出现在 AMD K5 和 Intel P6 上。对于 P6 而言，μops 的长度固定为 118 bit——这比很多 RISC 指令集的指令长度还要长，这是因为 μops 并不是为了简单的对标 RISC 指令，而是要对标译码后的 RISC 指令，在 RISC 指令的基础上还要包含一些译码的信息，例如流水线控制信号等等。此外，P6 的 μops 不再以内存地址为操作数，而是直接使用 load/store 模型&lt;/span&gt;&lt;strong&gt;&lt;span&gt;&lt;em&gt;&lt;span&gt;（这里我理解是除了 load/store 指令外，其他指令只以寄存器为操作数）。&lt;/span&gt;&lt;/em&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p data-pid=&quot;H8W9lexn&quot;&gt;&lt;strong&gt;&lt;span&gt;&lt;em&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/em&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;section&gt;&lt;strong&gt;五、High-Performance X86 Decoding&lt;/strong&gt;&lt;/section&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.02666666666666667&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/JJtKEey0hPY533fpibxanI0U85VuicLBnicd9oVaZKApEJqUs2UFnKCgRiaNnvOKeq9HkibP18sxDSwNj7f7ffichBMA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;750&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;下图为 Intel Nehalem 架构的译码单元示意图：&lt;/span&gt;&lt;/section&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.8055555555555556&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/xNm29D5VjSjkyy7wT4Z09MuZZJad6hzObCDr9pBajTHicicj87WebfLRTbbVuADsQibIbxiaK8qnPUFIUUJfW4W84w/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;720&quot;/&gt;&lt;span&gt;可以看到，x86 的译码过程是多周期的。&lt;/span&gt;&lt;/figure&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;span&gt;我们可以以指令队列（instruction queue，IQ）为界，将译码过程分为两部分：指令长度译码器（instruction length decoder，ILD，或者叫 &quot;predecode&quot; phase）和 动态翻译单元（&quot;decode&quot; phase）。&lt;/span&gt;&lt;/figure&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;span&gt;前者将指令字节流分割成多个独立的指令，而后者将这些指令动态翻译成对应的 μops。这两者通过指令队列 IQ 解耦。虽然也可以通过锁存器连接两者，但 IQ 可以允许两者异步操作，例如 ILD 翻译较慢时可以向 IQ 中插气泡，以及后续步骤速度较慢时，ILD 可以先行处理之后的指令。&lt;/span&gt;&lt;span/&gt;&lt;/figure&gt;&lt;h3&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;5.1 &lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;strong&gt;&lt;span&gt;The Instruction Length Decoder&lt;/span&gt;&lt;/strong&gt;&lt;strong&gt;&lt;span/&gt;&lt;/strong&gt;&lt;/h3&gt;&lt;p data-pid=&quot;M0tZjc57&quot;&gt;&lt;span&gt;ILD 不仅要负责计算指令长度，同时也会附加一些额外信息帮助后续过程译码。&lt;/span&gt;&lt;span&gt;由于指令长度计算本身是个串行的任务，因此如果要提升 IPC 的话，这一过程一定要尽可能的快。&lt;/span&gt;&lt;/p&gt;&lt;p data-pid=&quot;Vp4yTyXs&quot;&gt;&lt;span&gt;对于大部分的指令而言，ILD 可以单周期完成指令长度计算的任务。但对于一些复杂指令而言，可能就要花费比较长的时间了。&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;&lt;h3&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;5.2 T&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;strong&gt;&lt;span&gt;he Dynamic Translation Unit&lt;/span&gt;&lt;/strong&gt;&lt;/h3&gt;&lt;h3&gt;&lt;span&gt;动态翻译单元从指令队列 IQ 中取数据，翻译成 μops。&lt;/span&gt;&lt;span&gt;对于大部分 x86 指令，尤其是 register-to-register 指令，往往只需要翻译成一个 μop。&lt;/span&gt;&lt;span&gt;而对于以内存地址为操作数的指令，或者使用了复杂寻址模式的指令，往往会翻译成多个 μops。&lt;/span&gt;&lt;br/&gt;&lt;/h3&gt;&lt;p data-pid=&quot;W3Csjo9W&quot;&gt;&lt;span&gt;Intel Nehalem 架构实现了三个简单译码器和一个复杂译码器。前者负责翻译单 μop 指令，后者负责翻译最多 4 μops 的指令。这种做法能够有效节省功耗、减少设计复杂度，并最大限度的保证译码带宽不受影响。&lt;/span&gt;&lt;/p&gt;&lt;p data-pid=&quot;526FBrl8&quot;&gt;&lt;span&gt;对于一些非常复杂的指令，很有可能需要翻译成超过 4 条 μops 的指令序列。这些指令会被送往复杂译码器，然后停下当前所有的正常译码流程，由 microsequencer (MSROM) unit 来控制后续的译码过程。MSROM 包含一个 sequencer circuit 和一个 ROM 阵列，会输出一个微码 (microcode) 程序来模拟复杂指令。这个微码程序等效于一个预编程的普通 μops 序列。&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-pid=&quot;526FBrl8&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;hr/&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot; data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;▎第二&lt;/span&gt;&lt;/strong&gt;&lt;strong&gt;&lt;span&gt;章 Caches&lt;/span&gt;&lt;/strong&gt;&lt;strong/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot; data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzkzNDI2NjUwMw==&amp;amp;mid=2247485596&amp;amp;idx=1&amp;amp;sn=407ceff9acc93c31d4a3213dd180bc86&amp;amp;chksm=c2be9b74f5c9126246ef54ad4fdbcd559669a93c439d47dc7e83e2ac2d1d77709aefbdd71d76&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;论文精读 | Processor Microarchitecture - Caches&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;论文精读 | Processor Microarchitecture - Caches&lt;/a&gt;&lt;/span&gt;&lt;/strong&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot; data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;▎第&lt;/span&gt;&lt;/strong&gt;&lt;strong&gt;&lt;span&gt;三章 The Instruction Fetch Unit：&lt;/span&gt;&lt;/strong&gt;&lt;strong/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot; data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzkzNDI2NjUwMw==&amp;amp;mid=2247485560&amp;amp;idx=1&amp;amp;sn=8c64d5ca11b1538af040089b3482a2e5&amp;amp;chksm=c2be9b90f5c912866ac8b590910f593de5e4e91bd3b0ca8b3fad0fca87ce28d2f3fbb9fff13d&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;现代中央处理器 (CPU) 是怎样进行分支预测的？&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;现代中央处理器 (CPU) 是怎样进行分支预测的？&lt;/a&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;▎论文链接：&lt;/span&gt;&lt;/strong&gt;&lt;strong/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot; data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;https://www.morganclaypool.com/doi/abs/10.2200/S00309ED1V01Y201011CAC012&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;strong&gt;⭐️ 欢迎 star &lt;/strong&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.02666666666666667&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/JJtKEey0hPY533fpibxanI0U85VuicLBnicd9oVaZKApEJqUs2UFnKCgRiaNnvOKeq9HkibP18sxDSwNj7f7ffichBMA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;750&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;GitHub: &lt;/span&gt;&lt;span&gt;https://github.com/openppl-public&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;span&gt;官网：&lt;/span&gt;&lt;/span&gt;&lt;span&gt;https://openppl.ai&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;span&gt;QQ 群：&lt;/span&gt;&lt;span&gt;627853444&lt;/span&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;202&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;203&quot; data-galleryid=&quot;&quot; data-ratio=&quot;1&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/xNm29D5VjSia6rH8JSrQJCDPCxjKQUibftVk2iaHZXbPy3UmloC8sllmkZ7WJzibFclhF92yRRA61REmJDqb8FeLbw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;962&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;添加小助手微信，进群和大佬交流&lt;/span&gt;&lt;/section&gt;&lt;section class=&quot;mp_profile_iframe_wrp&quot;&gt;&lt;mp-common-profile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-id=&quot;MzkzNDI2NjUwMw==&quot; data-pluginname=&quot;mpprofile&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/xNm29D5VjSia2C0sakZtE9vK0icBhTC8tfN7WWicQJKKKmJ0gTAZ9nD6NNuftngo1Panc3aSOEoMxTSmzpl0I2J3A/0?wx_fmt=png&quot; data-nickname=&quot;OpenPPL&quot; data-alias=&quot;OpenPPL_AI&quot; data-signature=&quot;开源高性能深度学习推理引擎&quot; data-from=&quot;2&quot;/&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.07806691449814127&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/xNm29D5VjSgVkDGs8knfAkmebKG0wtt5GsBPewwzPbgbib8s1ZLTypkJDfmBLqBP24mg17xWrv06tKicyLGYiaFbg/640?wx_fmt=gif&quot; data-type=&quot;gif&quot; data-w=&quot;1076&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;&lt;span/&gt;&lt;/span&gt;&lt;/section&gt;&lt;h2/&gt;&lt;figure data-size=&quot;normal&quot;/&gt;&lt;/div&gt;

          

          
          &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>1dae447415c9ed528125a1673bd75bfd</guid>
<title>从原则、方案、策略及难点阐述分库分表</title>
<link>https://toutiao.io/k/6u20gmf</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content                                       &quot; id=&quot;js_content&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot; data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;img data-ratio=&quot;1.0285714285714285&quot; data-type=&quot;png&quot; data-w=&quot;70&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/9YmUctibIWGRG39U9npALUmvibgRFaqtX7ictTddL5iaCCNJ07CZXoWytE91y43pLcfLdvmIsEqGBMiadOicts5U9D0A/640?wx_fmt=png&quot;/&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p data-mid=&quot;&quot;&gt;点击上方&lt;span data-mid=&quot;&quot;&gt;蓝字&lt;/span&gt;关注我们&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.6666666666666666&quot; data-type=&quot;jpeg&quot; data-w=&quot;960&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/xicWYTSICzRsgbRXe9nDaFh5J0QIAEcTD9W8m3sIaKxl5SPicqnOyGGJmia8bp3Q4AMkZhkAObQmv8LfeHEv0FgBQ/640?wx_fmt=jpeg&quot;/&gt;&lt;/p&gt;&lt;h3&gt;、分库分表原则&lt;/h3&gt;&lt;p&gt;关系型数据库本身比较容易成为系统性能瓶颈，单机存储容量、连接数、处理能力等都很有限，数据库本身的“有状态性”导致了它并不像Web和应用服务器那么容易扩展。在互联网行业海量数据和高并发访问的考验下，聪明的技术人员提出了分库分表技术（有些地方也称为Sharding、分片）。同时，流行的分布式系统中间件（例如MongoDB、ElasticSearch等）均自身友好支持Sharding，其原理和思想都是大同小异的。&lt;/p&gt;&lt;p&gt;目前针对海量数据的优化，其分库分表是MySQL永远的话题，一般情况下认为MySQL是个简单的数据库，在数据量大到一定程度之后处理查询的效率降低，如果需要继续保持高性能运转的话，必须分库或者分表了。关于数据量达到多少大是个极限这个事儿，本文先不讨论，研究源码的同学已经证实MySQL或者Innodb内部的锁粒度太大的问题大大限制了MySQL提供QPS的能力或者处理大规模数据的能力。在这点上，一般的使用者只好坐等官方不断推出的优化版本了。&lt;/p&gt;&lt;p&gt;在一般运维的角度来看，我们什么情况下需要考虑分库分表？&lt;/p&gt;&lt;p&gt;首先说明，这里所说的分库分表是指把数据库数据的物理拆分到多个实例或者多台机器上去，而不是类似分区表的原地切分。&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;原则零：能不分就不分&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;是的，MySQL 是关系数据库，数据库表之间的关系从一定的角度上映射了业务逻辑。任何分库分表的行为都会在某种程度上提升业务逻辑的复杂度，数据库除了承载数据的存储和访问外，协助业务更好的实现需求和逻辑也是其重要工作之一。分库分表会带来数据的合并，查询或者更新条件的分离，事务的分离等等多种后果，业务实现的复杂程度往往会翻倍或者指数级上升。所以，在分库分表之前，不要为分而分，去做其他力所能及的事情吧，例如升级硬件，升级，升级网络，升级数据库版本，读写分离，负载均衡等等。所有分库分表的前提是，这些你已经尽力了。&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;原则一：数据量太大，正常的运维影响正常业务访问&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;这里说的运维，例如：&lt;/p&gt;&lt;p&gt;1）对数据库的备份。如果单表或者单个实例太大，在做备份的时候需要大量的磁盘IO或者网络IO资源。例如1T的数据，网络传输占用50MB的时候，需要20000秒才能传输完毕，在此整个过程中的维护风险都是高于平时的。我们在Qunar的做法是给所有的数据库机器添加第二块网卡，用来做备份，或者SST，Group Communication等等各种内部的数据传输。1T的数据的备份，也会占用大量的磁盘IO，如果是SSD还好，当然这里忽略某些厂商的产品在集中IO的时候会出一些BUG的问题。如果是普通的物理磁盘，则在不限流的情况下去执行xtrabackup，该实例基本不可用。&lt;/p&gt;&lt;p&gt;2）对数据表的修改。如果某个表过大，对此表做DDL的时候，MySQL会锁住全表，这个时间可能很长，在这段时间业务不能访问此表，影响甚大。解决的办法有类似腾讯游戏DBA自己改造的可以在线秒改表，不过他们目前也只是能添加字段而已，对别的DDL还是无效；或者使用pt-online-schema-change，当然在使用过程中，它需要建立触发器和影子表，同时也需要很长很长的时间，在此操作过程中的所有时间，都可以看做是风险时间。把数据表切分，总量减小，有助于改善这种风险。&lt;/p&gt;&lt;p&gt;3）整个表热点，数据访问和更新频繁，经常有锁等待，你又没有能力去修改源码，降低锁的粒度，那么只会把其中的数据物理拆开，用空间换时间，变相降低访问压力。&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;原则二：表设计不合理，需要对某些字段垂直拆分&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;这里举一个例子，如果你有一个用户表，在最初设计的时候可能是这样：&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;properties&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;       &lt;span class=&quot;code-snippet__attr&quot;&gt;id&lt;/span&gt;                   &lt;span class=&quot;code-snippet__string&quot;/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__attr&quot;&gt;bigint&lt;/span&gt; &lt;span class=&quot;code-snippet__string&quot;/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__attr&quot;&gt;name&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__attr&quot;&gt;varchar&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__attr&quot;&gt;last_login_time&lt;/span&gt;      &lt;span class=&quot;code-snippet__string&quot;/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__attr&quot;&gt;datetime&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;       &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__attr&quot;&gt;personal&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__attr&quot;&gt;_info&lt;/span&gt;    &lt;span class=&quot;code-snippet__string&quot;/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__attr&quot;&gt;text&lt;/span&gt;   &lt;span class=&quot;code-snippet__string&quot;/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__attr&quot;&gt;xxxxx&lt;/span&gt;                                 &lt;span class=&quot;code-snippet__string&quot;/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;设想情况一：你的业务中彩了，用户数从100w飙升到10个亿。你为了统计活跃用户，在每个人登录的时候都会记录一下他的最近登录时间。并且的用户活跃得很，不断的去更新这个login_time，搞的你的这个表不断的被update，压力非常大。那么，在这个时候，只要考虑对它进行拆分，站在业务的角度，最好的办法是先把last_login_time拆分出去，我们叫它 user_time。这样做，业务的代码只有在用到这个字段的时候修改一下就行了。如果你不这么做，直接把users表水平切分了，那么，所有访问users表的地方，都要修改。或许你会说，我有proxy，能够动态merge数据。到目前为止我还从没看到谁家的proxy不影响性能的。&lt;/p&gt;&lt;p&gt;设想情况二：personal_info这个字段本来没啥用，你就是让用户注册的时候填一些个人爱好而已，基本不查询。一开始的时候有它没它无所谓。但是到后来发现两个问题，一，这个字段占用了大量的空间，因为是text嘛，有很多人喜欢长篇大论地介绍自己。更糟糕的是二，不知道哪天哪个产品经理心血来潮，说允许个人信息公开吧，以方便让大家更好的相互了解。那么在所有人猎奇窥私心理的影响下，对此字段的访问大幅度增加。数据库压力瞬间抗不住了，这个时候，只好考虑对这个表的垂直拆分了。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;原则三：某些数据表出现了无穷增长&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;例子很好举，各种的评论，消息，日志记录。这个增长不是跟人口成比例的，而是不可控的，例如微博的feed的广播，我发一条消息，会扩散给很多很多人。虽然主体可能只存一份，但不排除一些索引或者路由有这种存储需求。这个时候，增加存储，提升机器配置已经苍白无力了，水平切分是最佳实践。拆分的标准很多，按用户的，按时间的，按用途的，不在一一举例。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;原则四：安全性和可用性的考虑&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;这个很容易理解，鸡蛋不要放在一个篮子里，我不希望我的数据库出问题，但我希望在出问题的时候不要影响到100%的用户，这个影响的比例越少越好，那么，水平切分可以解决这个问题，把用户，库存，订单等等本来同统一的资源切分掉，每个小的数据库实例承担一小部分业务，这样整体的可用性就会提升。这对Qunar这样的业务还是比较合适的，人与人之间，某些库存与库存之间，关联不太大，可以做一些这样的切分。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;原则五：业务耦合性考虑&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;这个跟上面有点类似，主要是站在业务的层面上，我们的火车票业务和烤羊腿业务是完全无关的业务，虽然每个业务的数据量可能不太大，放在一个MySQL实例中完全没问题，但是很可能烤羊腿业务的DBA 或者开发人员水平很差，动不动给你出一些幺蛾子，直接把数据库搞挂。这个时候，火车票业务的人员虽然技术很优秀，工作也很努力，照样被老板打屁股。解决的办法很简单:惹不起，躲得起。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;h3&gt;二、分库分表方案&lt;/h3&gt;&lt;p&gt;垂直拆分常见有垂直分库和垂直分表两种。垂直分表在日常开发和设计中比较常见，通俗的说法叫做“大表拆小表”，拆分是基于关系型数据库中的“列”（字段）进行的。通常情况，某个表中的字段比较多，可以新建立一张“扩展表”，将不经常使用或者长度较大的字段拆分出去放到“扩展表”中，如下图所示：&lt;/p&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.48048780487804876&quot; data-type=&quot;png&quot; data-w=&quot;410&quot; title=&quot;从原则、方案、策略及难点阐述分库分表&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/xicWYTSICzRsgbRXe9nDaFh5J0QIAEcTDN9eYPyn7PNv8hVk4WMozDjxkOaTiaibJsc7oe7FlIJGiaibDvfzC2qMCWA/640?wx_fmt=png&quot;/&gt;&lt;/p&gt;&lt;p&gt;在字段很多的情况下，拆分开确实更便于开发和维护（笔者曾见过某个遗留系统中，一个大表中包含100多列的）。某种意义上也能避免“跨页”的问题（MySQL、MSSQL底层都是通过“数据页”来存储的，“跨页”问题可能会造成额外的性能开销，这里不展开，感兴趣的朋友可以自行查阅相关资料进行研究）。&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;拆分字段的操作建议在数据库设计阶段就做好。如果是在发展过程中拆分，则需要改写以前的查询语句，会额外带来一定的成本和风险，建议谨慎。&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;垂直分库是根据数据库里面的数据表的相关性进行拆分，比如：一个数据库里面既存在用户数据，又存在订单数据，那么垂直拆分可以把用户数据放到用户库、把订单数据放到订单库。垂直分表是对数据表进行垂直拆分的一种方式，常见的是把一个多字段的大表按常用字段和非常用字段进行拆分，每个表里面的数据记录数一般情况下是相同的，只是字段不一样，使用主键关联。&lt;/p&gt;&lt;p&gt;另外，在“微服务”盛行的今天已经非常普及了，按照业务模块来划分出不同的数据库，也是一种垂直拆分。而不是像早期一样将所有的数据表都放到同一个数据库中。如下图：&lt;/p&gt;&lt;p&gt;&lt;img data-ratio=&quot;1.029090909090909&quot; data-type=&quot;jpeg&quot; data-w=&quot;275&quot; title=&quot;从原则、方案、策略及难点阐述分库分表&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/xicWYTSICzRsgbRXe9nDaFh5J0QIAEcTDbD7pOq0vf7WibrjQEACJXKCiavwQ2gVl9VJcLBviaTn9jLfHTr39jjOEQ/640?wx_fmt=jpeg&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;垂直拆分优点：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;垂直拆分缺点：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;垂直拆分小结：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;系统层面的“服务化”拆分操作，能够解决业务系统层面的耦合和性能瓶颈，有利于系统的扩展维护。而数据库层面的拆分，道理也是相通的。与服务的“治理”和“降级”机制类似，我们也能对不同业务类型的数据进行“分级”管理、维护、监控、扩展等。&lt;/p&gt;&lt;p&gt;众所周知，数据库往往最容易成为应用系统的瓶颈，而数据库本身属于“有状态”的，相对于Web和应用服务器来讲，是比较难实现“横向扩展”的。数据库的连接资源比较宝贵且单机处理能力也有限，在高并发场景下，垂直分库一定程度上能够突破IO、连接数及单机硬件资源的瓶颈，是大型分布式系统中优化数据库架构的重要手段。&lt;/p&gt;&lt;p&gt;然后，很多人并没有从根本上搞清楚为什么要拆分，也没有掌握拆分的原则和技巧，只是一味的模仿大厂的做法。导致拆分后遇到很多问题（例如：跨库join，分布式事务等）。&lt;/p&gt;&lt;p&gt;水平拆分是通过某种策略将数据分片来存储，分为库内分表和分库分表两部分，每片数据会分散到不同的MySQL表或库，达到分布式的效果，能够支持非常大的数据量。&lt;/p&gt;&lt;p&gt;库内分表，仅仅是单纯的解决了单一表数据过大的问题，由于没有把表的数据分布到不同的机器上，因此对于减轻 MySQL 服务器的压力来说，并没有太大的作用，大家还是竞争同一个物理机上的 IO、CPU、网络，这个就要通过分库分表来解决。&lt;/p&gt;&lt;p&gt;最常见的方式就是通过主键或者时间等字段进行Hash和取模后拆分。如下图所示：&lt;/p&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.4957983193277311&quot; data-type=&quot;png&quot; data-w=&quot;476&quot; title=&quot;从原则、方案、策略及难点阐述分库分表&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/xicWYTSICzRsgbRXe9nDaFh5J0QIAEcTDMHrcgDklvUJfOknXbibhUl1wicbQxaiatuVjtibkvrlbMWNsaS1ibDHczLg/640?wx_fmt=png&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;当下分表有静态分表和动态分表两种：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;静态分表&lt;/span&gt;：事先估算出表能达到的量，然后根据每一个表需要存多少数据直接算出需要创建表的数量。如：1亿数据每一个表100W条数据那就要建100张表，然后通过一定的hash算法计算每一条数据存放在那张表。其实就有点像是使用partition table一样。静态分表有一个毙命就是当分的那么多表还不满足时，需要再扩展难度和成本就会很高。&lt;/p&gt;&lt;p&gt;&lt;span&gt;动态分表&lt;/span&gt;：同样也是对大数据量的表进行拆分，他可以避免静态分表带来的后遗症。当然也需要在设计上多一些东西（这往往是我们能接受的）。&lt;/p&gt;&lt;p&gt;某种意义上来讲，有些系统中使用的“冷热数据分离”（将一些使用较少的历史数据迁移到其他的数据库中。而在业务功能上，通常默认只提供热点数据的查询），也是类似的实践。在高并发和海量数据的场景下，分库分表能够有效缓解单机和单库的性能瓶颈和压力，突破IO、连接数、硬件资源的瓶颈。当然，投入的硬件成本也会更高。同时，这也会带来一些复杂的技术问题和挑战（例如：跨分片的复杂查询，跨分片事务等）。&lt;/p&gt;&lt;p&gt;&lt;span&gt;水平拆分优点:&lt;/span&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;不存在单库大数据和高并发的性能瓶颈。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;应用端改造较少。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;提高了系统的稳定性和负载能力。&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;span&gt;水平拆分缺点：&lt;/span&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;分片事务一致性难以解决。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;跨节点 Join 性能差，逻辑复杂。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;数据多次扩展难度跟维护量极大。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3&gt;三、分库分表难点&lt;/h3&gt;&lt;p&gt;垂直分库带来的问题和解决思路：&lt;/p&gt;&lt;p&gt;在拆分之前，系统中很多列表和详情页所需的数据是可以通过sql join来完成的。而拆分后，数据库可能是分布式在不同实例和不同的主机上，join将变得非常麻烦。而且基于架构规范，性能，安全性等方面考虑，一般是禁止跨库join的。那该怎么办呢？首先要考虑下垂直分库的设计问题，如果可以调整，那就优先调整。如果无法调整的情况，下面笔者将结合以往的实际经验，总结几种常见的解决思路，并分析其适用场景。&lt;/p&gt;&lt;p&gt;跨库Join的几种解决思路&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;全局表&lt;/span&gt;&lt;/p&gt;&lt;p&gt;所谓全局表，就是有可能系统中所有模块都可能会依赖到的一些表。比较类似我们理解的“数据字典”。为了避免跨库join查询，我们可以将这类表在其他每个数据库中均保存一份。同时，这类数据通常也很少发生修改（甚至几乎不会），所以也不用太担心“一致性”问题。&lt;/p&gt;&lt;p&gt;&lt;span&gt;字段冗余&lt;/span&gt;&lt;/p&gt;&lt;p&gt;这是一种典型的反范式设计，在互联网行业中比较常见，通常是为了性能来避免join查询。&lt;/p&gt;&lt;p&gt;举个电商业务中很简单的场景：“订单表”中保存“卖家Id”的同时，将卖家的“Name”字段也冗余，这样查询订单详情的时候就不需要再去查询“卖家用户表”。&lt;/p&gt;&lt;p&gt;字段冗余能带来便利，是一种“空间换时间”的体现。但其适用场景也比较有限，比较适合依赖字段较少的情况。最复杂的还是数据一致性问题，这点很难保证，可以借助数据库中的触发器或者在业务代码层面去保证。当然，也需要结合实际业务场景来看一致性的要求。就像上面例子，如果卖家修改了Name之后，是否需要在订单信息中同步更新呢？&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;数据同步&lt;/span&gt;&lt;/p&gt;&lt;p&gt;定时A库中的tab_a表和B库中tbl_b有关联，可以定时将指定的表做同步。当然，同步本来会对数据库带来一定的影响，需要性能影响和数据时效性中取得一个平衡。这样来避免复杂的跨库查询。笔者曾经在项目中是通过ETL工具来实施的。&lt;/p&gt;&lt;p&gt;&lt;span&gt;系统层组装&lt;/span&gt;&lt;/p&gt;&lt;p&gt;在系统层面，通过调用不同模块的组件或者服务，获取到数据并进行字段拼装。说起来很容易，但实践起来可真没有这么简单，尤其是数据库设计上存在问题但又无法轻易调整的时候。具体情况通常会比较复杂。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;按业务拆分数据库之后，不可避免的就是“分布式事务”的问题。想要了解分布式事务，就需要了解“XA接口”和“两阶段提交”。值得提到的是，MySQL5.5x和5.6x中的xa支持是存在问题的，会导致主从数据不一致。直到5.7x版本中才得到修复。Java应用程序可以采用Atomikos框架来实现XA事务（J2EE中JTA）。感兴趣的读者可以自行参考《分布式事务一致性解决方案》，链接地址：http://www.infoq.com/cn/articles/solution-of-distributed-system-transaction-consistency&lt;/p&gt;&lt;h3&gt;四、常见分片规则和策略&lt;/h3&gt;&lt;p&gt;在很多中小项目中，我们往往直接使用数据库自增特性来生成主键ID，这样确实比较简单。而在分库分表的环境中，数据分布在不同的分片上，不能再借助数据库自增长特性直接生成，否则会造成不同分片上的数据表主键会重复。简单介绍下使用和了解过的几种ID生成算法。&lt;/p&gt;&lt;p&gt;1. Twitter的Snowflake（又名“雪花算法”）&lt;/p&gt;&lt;p&gt;2. UUID/GUID（一般应用程序和数据库均支持）&lt;/p&gt;&lt;p&gt;3. MongoDB ObjectID（类似UUID的方式）&lt;/p&gt;&lt;p&gt;4. Ticket Server（数据库生存方式，Flickr采用的就是这种方式）&lt;/p&gt;&lt;p&gt;其中，Twitter的Snowflake算法是近几年在分布式系统项目中使用最多的，未发现重复或并发的问题。该算法生成的是64位唯一Id（由41位的timestamp+10位自定义的机器码+13位累加计数器组成）。这里不做过多介绍，感兴趣的读者可自行查阅相关资料。&lt;/p&gt;&lt;p&gt;在开始分片之前，我们首先要确定分片字段（也可称为“片键”）。很多常见的例子和场景中是采用ID或者时间字段进行拆分。这也并不绝对的，我的建议是结合实际业务，通过对系统中执行的sql语句进行统计分析，选择出需要分片的那个表中最频繁被使用，或者最重要的字段来作为分片字段。&lt;/p&gt;&lt;p&gt;常见的分片策略有随机分片和连续分片这两种，如下图所示：&lt;/p&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.506398537477148&quot; data-type=&quot;jpeg&quot; data-w=&quot;547&quot; title=&quot;从原则、方案、策略及难点阐述分库分表&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/xicWYTSICzRsgbRXe9nDaFh5J0QIAEcTDUC3GhVicSfS8yXibNjVFNrbVCanBaqmwMHv76plJuxTiaSWicice8q4oqxQ/640?wx_fmt=jpeg&quot;/&gt;&lt;/p&gt;&lt;p&gt;当需要使用分片字段进行范围查找时，连续分片可以快速定位分片进行高效查询，大多数情况下可以有效避免跨分片查询的问题。后期如果想对整个分片集群扩容时，只需要添加节点即可，无需对其他分片的数据进行迁移。但是，连续分片也有可能存在数据热点的问题，就像图中按时间字段分片的例子，有些节点可能会被频繁查询压力较大，热数据节点就成为了整个集群的瓶颈。而有些节点可能存的是历史数据，很少需要被查询到。&lt;/p&gt;&lt;p&gt;随机分片其实并不是随机的，也遵循一定规则。通常，我们会采用Hash取模的方式进行分片拆分，所以有些时候也被称为离散分片。随机分片的数据相对比较均匀，不容易出现热点和并发访问的瓶颈。但是，后期分片集群扩容起来需要迁移旧的数据。使用一致性Hash算法能够很大程度的避免这个问题，所以很多中间件的分片集群都会采用一致性Hash算法。离散分片也很容易面临跨分片查询的复杂问题。&lt;/p&gt;&lt;p&gt;很少有项目会在初期就开始考虑分片设计的，一般都是在业务高速发展面临性能和存储的瓶颈时才会提前准备。因此，不可避免的就需要考虑历史数据迁移的问题。一般做法就是通过程序先读出历史数据，然后按照指定的分片规则再将数据写入到各个分片节点中。&lt;/p&gt;&lt;p&gt;此外，我们需要根据当前的数据量和QPS等进行容量规划，综合成本因素，推算出大概需要多少分片（一般建议单个分片上的单表数据量不要超过1000W）。&lt;/p&gt;&lt;p&gt;如果是采用随机分片，则需要考虑后期的扩容问题，相对会比较麻烦。如果是采用的范围分片，只需要添加节点就可以自动扩容。&lt;/p&gt;&lt;h3&gt;五、跨分片技术问题&lt;/h3&gt;&lt;p&gt;一般来讲，分页时需要按照指定字段进行排序。当排序字段就是分片字段的时候，我们通过分片规则可以比较容易定位到指定的分片，而当排序字段非分片字段的时候，情况就会变得比较复杂了。为了最终结果的准确性，我们需要在不同的分片节点中将数据进行排序并返回，并将不同分片返回的结果集进行汇总和再次排序，最后再返回给用户。如下图所示：&lt;/p&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.7132987910189983&quot; data-type=&quot;jpeg&quot; data-w=&quot;579&quot; title=&quot;从原则、方案、策略及难点阐述分库分表&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/xicWYTSICzRsgbRXe9nDaFh5J0QIAEcTDSXEBu5MEVia6XQad3S1moMialPJtYMZ38IXNrFCDQcKBdOdthicGtdcqw/640?wx_fmt=jpeg&quot;/&gt;&lt;/p&gt;&lt;p&gt;上面图中所描述的只是最简单的一种情况（取第一页数据），看起来对性能的影响并不大。但是，如果想取出第10页数据，情况又将变得复杂很多，如下图所示：&lt;/p&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.6968085106382979&quot; data-type=&quot;jpeg&quot; data-w=&quot;564&quot; title=&quot;从原则、方案、策略及难点阐述分库分表&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/xicWYTSICzRsgbRXe9nDaFh5J0QIAEcTDLdXh084mBEicGGQQY3eD2cXhEuvgSddibs0JQOSsibbw5f4vDhHQt4pvw/640?wx_fmt=jpeg&quot;/&gt;&lt;/p&gt;&lt;p&gt;有些读者可能并不太理解，为什么不能像获取第一页数据那样简单处理（排序取出前10条再合并、排序）。其实并不难理解，因为各分片节点中的数据可能是随机的，为了排序的准确性，必须把所有分片节点的前N页数据都排序好后做合并，最后再进行整体的排序。很显然，这样的操作是比较消耗资源的，用户越往后翻页，系统性能将会越差。&lt;/p&gt;&lt;p&gt;在使用Max、Min、Sum、Count之类的函数进行统计和计算的时候，需要先在每个分片数据源上执行相应的函数处理，然后再将各个结果集进行二次处理，最终再将处理结果返回。如下图所示：&lt;/p&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.704225352112676&quot; data-type=&quot;jpeg&quot; data-w=&quot;568&quot; title=&quot;从原则、方案、策略及难点阐述分库分表&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/xicWYTSICzRsgbRXe9nDaFh5J0QIAEcTDN42Cn2vIhr32EvyuTEvz0r1x3cTVIRW18ZK0Qibiab1NaqhSqz3XeQuA/640?wx_fmt=jpeg&quot;/&gt;&lt;/p&gt;&lt;section data-recommend-type=&quot;list-title&quot; data-recommend-tid=&quot;8&quot; data-mpa-template=&quot;t&quot; data-mid=&quot;&quot; data-from=&quot;yb-recommend&quot;&gt;&lt;section data-mid=&quot;&quot;&gt;&lt;section data-mid=&quot;&quot;&gt;&lt;section data-mid=&quot;&quot;&gt;&lt;section data-mid=&quot;&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot;&gt;&lt;p data-mid=&quot;&quot;&gt;往期推荐&lt;/p&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; data-recommend-article-type=&quot;list-title&quot; data-recomment-template-id=&quot;8&quot; data-recommend-article-id=&quot;2247486047_1&quot; data-recommend-article-time=&quot;1612135800&quot; data-recommend-article-cover=&quot;http://mmbiz.qpic.cn/mmbiz_jpg/xicWYTSICzRuaItggtTicnNvgdK94EDNzNP5572L0GQXnDiaibU6MAlS6V4qSOMclzZ8kkbRJHuRicFians72Y9SQUvw/0?wx_fmt=jpeg&quot; data-recommend-article-title=&quot;时序数据库InfluxDB引擎浅析&quot; data-recommend-article-content-url=&quot;http://mp.weixin.qq.com/s?__biz=MzU2NDc4MjE2Ng==&amp;amp;mid=2247486047&amp;amp;idx=1&amp;amp;sn=0001f4326790dd93014bfd342c90fb41&amp;amp;chksm=fc44ff66cb337670354c4ed1e0e4bb362e1f97b909c0d2ba27214fcd32de284b1d22e110f48f#rd&quot;&gt;&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzU2NDc4MjE2Ng==&amp;amp;mid=2247486047&amp;amp;idx=1&amp;amp;sn=0001f4326790dd93014bfd342c90fb41&amp;amp;chksm=fc44ff66cb337670354c4ed1e0e4bb362e1f97b909c0d2ba27214fcd32de284b1d22e110f48f&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;&lt;section data-recommend-title=&quot;t&quot; data-mid=&quot;&quot;&gt;&lt;p data-mid=&quot;&quot;&gt;时序数据库InfluxDB引擎浅析&lt;/p&gt;&lt;/section&gt;&lt;/a&gt;&lt;/section&gt;&lt;section data-mpa-template=&quot;t&quot; data-recommend-article-type=&quot;list-title&quot; data-recomment-template-id=&quot;8&quot; data-recommend-article-id=&quot;2247485965_1&quot; data-recommend-article-time=&quot;1612049400&quot; data-recommend-article-cover=&quot;http://mmbiz.qpic.cn/mmbiz_jpg/xicWYTSICzRuw1laYB5sHPMO13k4yQibogNnI8rcuhHwev6FoeKdVdINnM8HZ7icia30pJRFVMhVzf2ry8nEEhLjkg/0?wx_fmt=jpeg&quot; data-recommend-article-title=&quot;精髓！深入浅出剖析12个Zookeeper知识点&quot; data-recommend-article-content-url=&quot;http://mp.weixin.qq.com/s?__biz=MzU2NDc4MjE2Ng==&amp;amp;mid=2247485965&amp;amp;idx=1&amp;amp;sn=98927d2f8845948c18930a639d01c211&amp;amp;chksm=fc44ff34cb337622d4a2ba8c39bb06f3ab4cc4ab32c6fab6dbef6365363b945ef5664820db7c#rd&quot;&gt;&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzU2NDc4MjE2Ng==&amp;amp;mid=2247485965&amp;amp;idx=1&amp;amp;sn=98927d2f8845948c18930a639d01c211&amp;amp;chksm=fc44ff34cb337622d4a2ba8c39bb06f3ab4cc4ab32c6fab6dbef6365363b945ef5664820db7c&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;&lt;section data-recommend-title=&quot;t&quot; data-mid=&quot;&quot;&gt;&lt;p data-mid=&quot;&quot;&gt;精髓！深入浅出剖析12个Zookeeper知识点&lt;/p&gt;&lt;/section&gt;&lt;/a&gt;&lt;/section&gt;&lt;section data-mpa-template=&quot;t&quot; data-recommend-article-type=&quot;list-title&quot; data-recomment-template-id=&quot;8&quot; data-recommend-article-id=&quot;2247485952_1&quot; data-recommend-article-time=&quot;1611963000&quot; data-recommend-article-cover=&quot;http://mmbiz.qpic.cn/mmbiz_jpg/xicWYTSICzRuw1laYB5sHPMO13k4yQibogWjQvedIKwykOr5REqhnaHFUeicptxnssnuod6854H0GhTRSeQOD8dqA/0?wx_fmt=jpeg&quot; data-recommend-article-title=&quot;分不清ARM和X86架构，来看看服务器的产品形态&quot; data-recommend-article-content-url=&quot;http://mp.weixin.qq.com/s?__biz=MzU2NDc4MjE2Ng==&amp;amp;mid=2247485952&amp;amp;idx=1&amp;amp;sn=840512fbd429fae2d6798ecbcee1d43e&amp;amp;chksm=fc44ff39cb33762fb912485cd5a3f94062a4a21f712092caedd6c00989da48cbdad2ee60cb05#rd&quot;&gt;&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzU2NDc4MjE2Ng==&amp;amp;mid=2247485952&amp;amp;idx=1&amp;amp;sn=840512fbd429fae2d6798ecbcee1d43e&amp;amp;chksm=fc44ff39cb33762fb912485cd5a3f94062a4a21f712092caedd6c00989da48cbdad2ee60cb05&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;&lt;section data-recommend-title=&quot;t&quot; data-mid=&quot;&quot;&gt;&lt;p data-mid=&quot;&quot;&gt;分不清ARM和X86架构，来看看服务器的产品形态&lt;/p&gt;&lt;/section&gt;&lt;/a&gt;&lt;/section&gt;&lt;section data-mpa-template=&quot;t&quot; data-recommend-article-type=&quot;list-title&quot; data-recomment-template-id=&quot;8&quot; data-recommend-article-id=&quot;2247485732_1&quot; data-recommend-article-time=&quot;1611876600&quot; data-recommend-article-cover=&quot;http://mmbiz.qpic.cn/mmbiz_jpg/xicWYTSICzRsPwWe9ws9b1eZv1kGseImPMYrrenEhpfSmxicBNR3GFa1JIacnF81eOJDYBb2pe7jRhG6yCWEvTAg/0?wx_fmt=jpeg&quot; data-recommend-article-title=&quot;全面认识OpenStack架构&quot; data-recommend-article-content-url=&quot;http://mp.weixin.qq.com/s?__biz=MzU2NDc4MjE2Ng==&amp;amp;mid=2247485732&amp;amp;idx=1&amp;amp;sn=86b955de280cfee3c22bdd83489b6e5e&amp;amp;chksm=fc44fc1dcb33750b737127bfb2c3846152f27036accb2192fe702bf86c9a5b08854e79608586#rd&quot;&gt;&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzU2NDc4MjE2Ng==&amp;amp;mid=2247485732&amp;amp;idx=1&amp;amp;sn=86b955de280cfee3c22bdd83489b6e5e&amp;amp;chksm=fc44fc1dcb33750b737127bfb2c3846152f27036accb2192fe702bf86c9a5b08854e79608586&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;&lt;section data-recommend-title=&quot;t&quot; data-mid=&quot;&quot;&gt;&lt;p data-mid=&quot;&quot;&gt;全面认识OpenStack架构&lt;/p&gt;&lt;/section&gt;&lt;/a&gt;&lt;/section&gt;&lt;section data-mpa-template=&quot;t&quot; data-recommend-article-type=&quot;list-title&quot; data-recomment-template-id=&quot;8&quot; data-recommend-article-id=&quot;2247485657_1&quot; data-recommend-article-time=&quot;1611790200&quot; data-recommend-article-cover=&quot;http://mmbiz.qpic.cn/mmbiz_jpg/xicWYTSICzRuEo5gyxME0m1UvDjzp5Uibwiamydfnj9dh0vU4hoYvReZSPKPacq9v3iaiciazicfHdCYialtBuVib4fP69g/0?wx_fmt=jpeg&quot; data-recommend-article-title=&quot;MAC认证技术&quot; data-recommend-article-content-url=&quot;http://mp.weixin.qq.com/s?__biz=MzU2NDc4MjE2Ng==&amp;amp;mid=2247485657&amp;amp;idx=1&amp;amp;sn=aa6fb6e87300dfee313677c12828a982&amp;amp;chksm=fc44fde0cb3374f60a3e6c8745be5a87d39fc892177c09cbd5afbd9bf27765a196373a648e75#rd&quot;&gt;&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzU2NDc4MjE2Ng==&amp;amp;mid=2247485657&amp;amp;idx=1&amp;amp;sn=aa6fb6e87300dfee313677c12828a982&amp;amp;chksm=fc44fde0cb3374f60a3e6c8745be5a87d39fc892177c09cbd5afbd9bf27765a196373a648e75&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;&lt;section data-recommend-title=&quot;t&quot; data-mid=&quot;&quot;&gt;&lt;p data-mid=&quot;&quot;&gt;MAC认证技术&lt;/p&gt;&lt;/section&gt;&lt;/a&gt;&lt;/section&gt;&lt;section data-mpa-template=&quot;t&quot; data-recommend-article-type=&quot;list-title&quot; data-recomment-template-id=&quot;8&quot; data-recommend-article-id=&quot;2247485643_1&quot; data-recommend-article-time=&quot;1611757173&quot; data-recommend-article-cover=&quot;http://mmbiz.qpic.cn/mmbiz_jpg/xicWYTSICzRuEo5gyxME0m1UvDjzp5UibwaurF75mBg9grDFg0wExzWDgxN6L31KFk5B3EJFkjvprrq0iaH0asqtA/0?wx_fmt=jpeg&quot; data-recommend-article-title=&quot;接入与身份认证技术概述&quot; data-recommend-article-content-url=&quot;http://mp.weixin.qq.com/s?__biz=MzU2NDc4MjE2Ng==&amp;amp;mid=2247485643&amp;amp;idx=1&amp;amp;sn=88166c4206f884ecb60efd2001432785&amp;amp;chksm=fc44fdf2cb3374e4ee04288c58be76e011f4d73e49021e3a0f8c2d5308073dcb288d1ac97726#rd&quot;&gt;&lt;section data-recommend-title=&quot;t&quot; data-mid=&quot;&quot;&gt;&lt;p data-mid=&quot;&quot;&gt;&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzU2NDc4MjE2Ng==&amp;amp;mid=2247485643&amp;amp;idx=1&amp;amp;sn=88166c4206f884ecb60efd2001432785&amp;amp;chksm=fc44fdf2cb3374e4ee04288c58be76e011f4d73e49021e3a0f8c2d5308073dcb288d1ac97726&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;接入与身份认证技术概述&lt;/a&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;img class=&quot;rich_pages&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;578&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;321&quot; data-ratio=&quot;0.4255555555555556&quot; data-s=&quot;300,640&quot; data-type=&quot;jpeg&quot; data-w=&quot;900&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/xicWYTSICzRvzhdKrMicSPIibg8PEbOka8njc8rEfaKkOXLp2wmprLicBQicX1iauQsXGSL9iaxkxVSotPCavShokSoTw/640?wx_fmt=jpeg&quot;/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mpa-category=&quot;模板&quot; data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;img data-ratio=&quot;1&quot; data-type=&quot;gif&quot; data-w=&quot;92&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/GGTr0OaZf2XsT2qUbElibBOVzt2iajO2wPBFcRSvnBNiat1rmEAxsXC1icuGJgTRtrJ52am2wk5q6SWtef8KNHAoGg/640?wx_fmt=gif&quot;/&gt;&lt;p data-mid=&quot;&quot;&gt;戳这儿&lt;/p&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/div&gt;

          

          
          &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>