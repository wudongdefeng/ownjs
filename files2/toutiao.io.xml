<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>98965bb9896272c595c7b61b5be20e6e</guid>
<title>Chromium + Mitmproxy 组合使用踩坑</title>
<link>https://toutiao.io/k/bz4e46a</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section class=&quot;toc-content post no-image&quot;&gt;
      &lt;h2 id=&quot;%E8%83%8C%E6%99%AF&quot;&gt;背景&lt;/h2&gt;&lt;p&gt;众所周知，Chromium 目前是事实上的地表最强浏览器内核，Mitmproxy 是事实上地表最强的中间人代理工具。二者组合使用可以非常方便的进行控制与数据分离的自动化数据提取。不过在实际生产中大规模使用时，还是会或多或少的遇到了一些难以察觉的坑。。。&lt;/p&gt;&lt;h2 id=&quot;mitmproxy-%E4%BD%8E%E7%89%88%E6%9C%AC%E9%95%BF%E6%9C%9F%E8%BF%90%E8%A1%8C%E6%98%93-oom&quot;&gt;Mitmproxy 低版本长期运行易 OOM&lt;/h2&gt;&lt;h3 id=&quot;%E7%8E%B0%E8%B1%A1&quot;&gt;现象&lt;/h3&gt;&lt;p&gt;在容器中部署 chromium + mitmproxy 后，发现在多次访问某些类型网站时，mitmproxy 经常周期性地出现内存缓慢增长，直到超过 docker 限制而被 OOMKilled。虽然有 docker 的自动重启进程功能，但是总会不可避免的导致业务上网络连接的周期性断开。&lt;/p&gt;&lt;h3 id=&quot;%E5%88%86%E6%9E%90&quot;&gt;分析&lt;/h3&gt;&lt;p&gt;初步怀疑是流量本身过多（chromium 对 mitmproxy 是“多对一”）以及给 mitmproxy 分配的内存过低导致内存不足。于是尝试将 mitmproxy 的内存配额从 200MB 增长到 1G。&lt;/p&gt;&lt;p&gt;但是实际结果却是这只是延长了 OOM 的时间，并没有解决问题。于是考虑是出现了内存泄漏问题，但是业务脚本无论如何也排查不出问题，因此只能暂时用 docker 自动重启进程的功能保持服务的大致可用。&lt;/p&gt;&lt;p&gt;同时发现似乎在 chromium 中增加 &lt;code&gt;--disable-http2&lt;/code&gt; 的启动参数后，内存泄漏的情况会有所缓解。&lt;/p&gt;&lt;h3 id=&quot;%E8%A7%A3%E5%86%B3&quot;&gt;解决&lt;/h3&gt;&lt;p&gt;经过一段时间，偶然回头一看才检索到 mitmproxy 有一个 &lt;a href=&quot;https://github.com/mitmproxy/mitmproxy/issues/4786&quot;&gt;#4786&lt;/a&gt; 的相关 issue。原来在较低版本中（8.0.0及以下），拦截的 HttpFlow 长连接对象的确存在连接泄漏导致内存不断膨胀直至 OOM 的问题。（这样一想强制关闭 http2 长连接的确有概率会降级到短连接，从而缓解长连接的 OOM 问题。）&lt;/p&gt;&lt;p&gt;这个问题终于在 8.1.0 版本得到了修复（&lt;a href=&quot;https://github.com/mitmproxy/mitmproxy/blob/main/CHANGELOG.md&quot;&gt;CHANGELOG&lt;/a&gt;）：&lt;/p&gt;&lt;figure class=&quot;kg-card kg-image-card&quot;&gt;&lt;img src=&quot;https://blog.mythsman.com/content/images/2023/03/image.png&quot; class=&quot;kg-image&quot; alt=&quot;&quot; loading=&quot;lazy&quot; srcset=&quot;https://blog.mythsman.com/content/images/size/w600/2023/03/image.png 600w, https://blog.mythsman.com/content/images/size/w1000/2023/03/image.png 1000w, https://blog.mythsman.com/content/images/size/w1600/2023/03/image.png 1600w, https://blog.mythsman.com/content/images/2023/03/image.png 1754w&quot; sizes=&quot;(min-width: 720px) 720px&quot;/&gt;&lt;/figure&gt;&lt;p&gt;我们要做的就是直接使用最新稳定版的 mitmproxy 即可。不过这件事情也没有想象中的容易。&lt;/p&gt;&lt;p&gt;如果你的系统是 ubuntu:focal (20.04 LTS) 的版本，默认安装的 python3 版本应当是 3.8.x ，这时你会发现无论如何也装不上 mitmproxy@8.1.0 版本：&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;language-shell&quot;&gt;$ lsb_release -a
No LSB modules are available.
Distributor ID: Ubuntu
Description: Ubuntu 20.04.5 LTS
Release: 20.04
Codename: focal

$ python3 --version
Python 3.8.10

$ pip3 install mitmproxy==8.1.0
ERROR: Could not find a version that satisfies the requirement mitmproxy==8.1.0 (from versions: 0.8, 0.8.1, 0.9, 0.9.1, 0.9.2, 0.10, 0.10.1, 0.11, 0.11.1, 0.11.2, 0.11.3, 0.12.0, 0.12.1, 0.13, 0.14.0, 0.15, 0.18.1, 0.18.2, 0.18.3, 1.0.0, 1.0.1, 1.0.2, 2.0.0, 2.0.1, 2.0.2, 3.0.0, 3.0.1, 3.0.2, 3.0.3, 3.0.4, 4.0.0, 4.0.1, 4.0.3, 4.0.4, 5.0.0, 5.0.1, 5.1.0, 5.1.1, 5.2, 5.3.0, 6.0.0, 6.0.1, 6.0.2, 7.0.0, 7.0.1, 7.0.2, 7.0.3, 7.0.4, 8.0.0)
ERROR: No matching distribution found for mitmproxy==8.1.0&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这里的关键是要记得去 &lt;a href=&quot;https://pypi.org/&quot;&gt;pypi&lt;/a&gt; 上去看下 mitmproxy 对不同 python 版本的支持：&lt;a href=&quot;https://pypi.org/project/mitmproxy/8.0.0/&quot;&gt;8.0.0&lt;/a&gt; 的最低支持 python 版本是 3.8；而刚巧修复了 bug 的 &lt;a href=&quot;https://pypi.org/project/mitmproxy/8.1.0/&quot;&gt;8.1.0&lt;/a&gt; 的最低支持 python 版本就跳到了 3.9。于是这里又要继续升级 python3 到 3.9 以上。&lt;/p&gt;&lt;p&gt;这里又有两条路：要么需要在 20.04 的 ubuntu 里增加新的 python3.9 的源，把老的 python3.8 的相关数据清理干净，再安装新的 python3.9 ；要么直接升级到 jammy (22.04 LTS)。&lt;/p&gt;&lt;p&gt;经过一番尝试，发现在老的镜像里升级 python3.9 还是非常麻烦的，处理不好经常会残留一些老版本的库。于是我这里选择了直接将基础镜像换成了 ubuntu:22.04 。&lt;/p&gt;&lt;p&gt;全部升级完成后，正常运行的 mitmproxy 的内存占用基本都会维持在 100MB 左右了，还是非常稳定的。&lt;/p&gt;&lt;h2 id=&quot;chromium-%E5%BF%BD%E7%95%A5%E8%AF%81%E4%B9%A6%E6%A0%A1%E9%AA%8C%E4%BC%9A%E5%AF%BC%E8%87%B4%E7%BC%93%E5%AD%98%E5%A4%B1%E6%95%88&quot;&gt;Chromium 忽略证书校验会导致缓存失效&lt;/h2&gt;&lt;h3 id=&quot;%E7%8E%B0%E8%B1%A1-1&quot;&gt;现象&lt;/h3&gt;&lt;p&gt;原先的系统架构是先启动一个 mitmdump 服务监听 8888 端口，再使用一个基于 chromium 内核的浏览器，通过 &lt;code&gt;--proxy-server=localhost:8888&lt;/code&gt;  将流量指向代理服务，再通过 &lt;code&gt;--ignore-certificate-erros&lt;/code&gt; 参数忽略对 mitmdump 的自签名证书的校验，保证流量器正常访问。&lt;/p&gt;&lt;p&gt;同时为了减少图片、视频等带来的带宽损失，结合具体任务，在 mitmdump 的脚本里将视频、图片等相关的请求 drop 掉，保持对流量的高效利用。&lt;/p&gt;&lt;p&gt;本来这就是一个非常的朴素、透明、易理解的普通架构，线上也稳定运行了多年，没啥大的变动也没人想着改。不过近期业务流量逐渐大了起来，发现出口带宽有点撑不住了。于是增加了个对响应体的 Content-Type 监控，发现流量的大头竟然是 application/javascript 这一类的东西。&lt;/p&gt;&lt;p&gt;这显然不太合理，因为这些 javascript 资源理论上都是走的 cdn，数据都会带 Cache-Control 相关 header 方便浏览器进行本地缓存。在重复执行类似网页的时候，大概率应当会复用之前已经缓存好的 javascript 文件。&lt;/p&gt;&lt;h3 id=&quot;%E5%88%86%E6%9E%90-1&quot;&gt;分析&lt;/h3&gt;&lt;p&gt;仔细审查了一下正常浏览器请求和线上环境下请求的资源请求情况，果然发现了不同点。&lt;/p&gt;&lt;p&gt;本地环境：&lt;/p&gt;&lt;figure class=&quot;kg-card kg-image-card&quot;&gt;&lt;img src=&quot;https://blog.mythsman.com/content/images/2023/03/image-1.png&quot; class=&quot;kg-image&quot; alt=&quot;&quot; loading=&quot;lazy&quot; srcset=&quot;https://blog.mythsman.com/content/images/size/w600/2023/03/image-1.png 600w, https://blog.mythsman.com/content/images/size/w1000/2023/03/image-1.png 1000w, https://blog.mythsman.com/content/images/2023/03/image-1.png 1024w&quot; sizes=&quot;(min-width: 720px) 720px&quot;/&gt;&lt;/figure&gt;&lt;p&gt;线上环境：&lt;/p&gt;&lt;figure class=&quot;kg-card kg-image-card&quot;&gt;&lt;img src=&quot;https://blog.mythsman.com/content/images/2023/03/image-2.png&quot; class=&quot;kg-image&quot; alt=&quot;&quot; loading=&quot;lazy&quot; srcset=&quot;https://blog.mythsman.com/content/images/size/w600/2023/03/image-2.png 600w, https://blog.mythsman.com/content/images/size/w1000/2023/03/image-2.png 1000w, https://blog.mythsman.com/content/images/2023/03/image-2.png 1024w&quot; sizes=&quot;(min-width: 720px) 720px&quot;/&gt;&lt;/figure&gt;&lt;p&gt;可见本地环境的各种 javascript 资源在多次请求时都是要么命中了 memory cache ，要么命中了 disk cache，从而正常节省了流量。而 线上环境的各种 javascript 资源却只会命中 memory cache 而从未命中过 disk cache。&lt;/p&gt;&lt;p&gt;仔细对比了二者的环境下 chromium 的启动参数差别，多次实验后（&lt;strong&gt;需要注意每次实验之间一定要清空用户目录&lt;/strong&gt;）终于发现区别只在于 &lt;strong&gt;本地环境没有使用 mitmproxy 抓包，而线上环境配置了mitmproxy抓包 &lt;/strong&gt;。在本地环境下配置了 mitmproxy 抓包后终于复现了线上场景。&lt;/p&gt;&lt;p&gt;经过一番搜索，竟然在 MicrosoftEdge 的项目 &lt;a href=&quot;https://github.com/MicrosoftEdge/WebView2Feedback/issues/2634&quot;&gt;issue #2634&lt;/a&gt; 里找到了对 chromium 问题的解释，具体原因可以参见 &lt;a href=&quot;https://bugs.chromium.org/p/chromium/issues/detail?id=110649#c8&quot;&gt;chromium&lt;/a&gt; 这里的解释：&lt;/p&gt;&lt;blockquote&gt;&lt;strong&gt;Status:&lt;/strong&gt; WontFix : The rule is actually quite simple: any error with the certificate means the page will not be cached.&lt;/blockquote&gt;&lt;p&gt;没错，chromium 做了这样一个规定：&lt;strong&gt;证书错误的页面不会被持久化缓存&lt;/strong&gt;，即使你配置了忽略证书校验。&lt;/p&gt;&lt;h3 id=&quot;%E8%A7%A3%E5%86%B3-1&quot;&gt;解决&lt;/h3&gt;&lt;p&gt;问题原因发现了，解决起来也就容易了。至少有两种方案可以处理：&lt;/p&gt;&lt;ol&gt;&lt;li&gt;在 mitmproxy 层基于 Http 的 Cache-Control 相关协议，自己实现一层静态资源的持久化缓存。&lt;/li&gt;&lt;li&gt;chromium 不配置 &lt;code&gt;--ignore-certificate-errors&lt;/code&gt; ，而是直接想办法将 mitmproxy 的证书种到 chromium 信任的 CA 里，保证对 TLS 流量的正常解析。&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;实测下来，二者都能很好地优化大并发任务下的网络请求。javascript 相关请求量近似跌零，整体的流量会减少 70% 以上。不过总体看下来，方案二处理起来更加便捷和稳妥。&lt;/p&gt;&lt;h2 id=&quot;chromium-%E9%BB%98%E8%AE%A4%E4%B8%8D%E4%BF%A1%E4%BB%BB-linux-%E4%B8%8B%E7%9A%84%E7%B3%BB%E7%BB%9F%E8%AF%81%E4%B9%A6&quot;&gt;Chromium 默认不信任 Linux 下的系统证书&lt;/h2&gt;&lt;h3 id=&quot;%E7%8E%B0%E8%B1%A1-2&quot;&gt;现象&lt;/h3&gt;&lt;p&gt;话接上一个问题的解决方案二，想将证书种到 chromium 中其实并不简单。一个 Ubuntu 下的通用种 mitmproxy 证书的方法是：&lt;/p&gt;&lt;ol&gt;&lt;li&gt;从 &lt;code&gt;$HOME/.mitmproxy/mitmproxy-ca-cert.pem&lt;/code&gt; 中拿到 mitmproxy 的默认证书；或者自己用 openssl 生成一对证书+私钥，并放在 mitmproxy 的相应位置下。&lt;/li&gt;&lt;li&gt;将上述的 &lt;code&gt;mitmproxy-ca-cert.pem&lt;/code&gt;  复制到 &lt;code&gt;/usr/local/share/ca-certificates&lt;/code&gt; 下，并重命名为 &lt;code&gt;mitm.crt&lt;/code&gt;  （一定要以 crt 为后缀）。&lt;/li&gt;&lt;li&gt;执行 &lt;code&gt;update-ca-certificates&lt;/code&gt; ，会自动将 mitm.crt 按证书信息重命名并软链接到 &lt;code&gt;/etc/ssl/certs&lt;/code&gt; 中。&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;这样搞完，例如 curl wget 等绝大多数应用就都能认得我们自签名的证书了。&lt;/p&gt;&lt;p&gt;可惜 chromium 不是这绝大多数，实测下来依然不信任我们已经种在系统 CA 里的自签名证书。&lt;/p&gt;&lt;h3 id=&quot;%E5%88%86%E6%9E%90-2&quot;&gt;分析&lt;/h3&gt;&lt;p&gt;其实不信任系统默认 CA 证书的事情也很常见，比如很多 App &lt;strong&gt;为了安全考虑&lt;/strong&gt;会自己做 SSL Pinning，不信任用户机器上的证书；或者像 Java 这种工具&lt;strong&gt;为了跨平台的考虑&lt;/strong&gt;也不会使用系统的证书，而是使用自己存储的 keystore。这里 Chromium 可能是也是出于类似考虑，反正也是默认只信任了自己安装时带过来的证书。对于用户新增的证书，也是希望直接通过软件本身的配置进行管理。&lt;/p&gt;&lt;p&gt;官方配置中添加自签名证书的方法是通过 &lt;code&gt;chrome://settings/certificates&lt;/code&gt;  自行导入。&lt;/p&gt;&lt;figure class=&quot;kg-card kg-image-card&quot;&gt;&lt;img src=&quot;https://blog.mythsman.com/content/images/2023/03/image-3.png&quot; class=&quot;kg-image&quot; alt=&quot;&quot; loading=&quot;lazy&quot; srcset=&quot;https://blog.mythsman.com/content/images/size/w600/2023/03/image-3.png 600w, https://blog.mythsman.com/content/images/size/w1000/2023/03/image-3.png 1000w, https://blog.mythsman.com/content/images/2023/03/image-3.png 1024w&quot; sizes=&quot;(min-width: 720px) 720px&quot;/&gt;&lt;/figure&gt;&lt;p&gt;不过显然，这中配置方式对于打镜像并不合适，我们还是要寻找通过配置文件进行配置的方案。&lt;/p&gt;&lt;h3 id=&quot;%E8%A7%A3%E5%86%B3-2&quot;&gt;解决&lt;/h3&gt;&lt;p&gt;一番搜索后，从 &lt;a href=&quot;https://superuser.com/questions/1695693/adding-self-signed-certificate-into-trusted-ca-on-chromium-for-linux&quot;&gt;superuser&lt;/a&gt; 中的这篇文章大概了解了 chromium 对自定义证书的管理方式。官方的说明是在 chromium 的 &lt;a href=&quot;https://chromium.googlesource.com/chromium/src.git/+/refs/heads/main/docs/linux/cert_management.md&quot;&gt;cert_management&lt;/a&gt; 文档中。&lt;/p&gt;&lt;p&gt;简而言之，Linux 下的 Chromium 使用的是公共 nssdb 来管理证书。数据存放在 &lt;code&gt;$HOME/.pki/nssdb&lt;/code&gt; 下。&lt;/p&gt;&lt;p&gt;如果这个目录不存在，那么在第一次打开 Chromium 时会自动创建。不过对于预构建的环境来说，这里还是需要自己事先初始化下的。&lt;/p&gt;&lt;p&gt;具体步骤如下：&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;language-shell&quot;&gt;$ mkdir -p ~/.pki/nssdb                                       # 准备路径和文件夹

$ certutil -d ~/.pki/nssdb -N --empty-password                # 初始化DB环境

$ ls ~/.pki/nssdb/                                            # 查看DB文件
cert9.db  key4.db  pkcs11.txt

$ certutil -d ~/.pki/nssdb -L                                 # 查看证书信息（目前为空）

Certificate Nickname                                         Trust Attributes
                                                             SSL,S/MIME,JAR/XPI

$ certutil -d ~/.pki/nssdb -A -t &quot;C,,&quot; -n mitm -i ~/mitm.crt  # 将准备好的证书导入进 CA

$ certutil -d ~/.pki/nssdb -L                                 # 查看导入后的证书信息

Certificate Nickname                                         Trust Attributes
                                                             SSL,S/MIME,JAR/XPI

mitm                                                         C,,
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;正常情况下，这样处理是没有问题的，不过具体使用时，还是踩了一些坑。&lt;/p&gt;&lt;p&gt;注意到 chromium 文档中给出的所有 nssdb 相关指令的 -d 参数和我上述用的有所不同，多带了一个 &lt;code&gt;sql:&lt;/code&gt; 的前缀：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;$ certutil -d sql:$HOME/.pki/nssdb -L&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这是因为在本地测试时，由于 bash 用习惯了，直接用 ~ 代替了 $HOME 。结果命令敲出来结果就是这样：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;$ certutil -d sql:~/.pki/nssdb -L
certutil: function failed: SEC_ERROR_BAD_DATABASE: security library: bad database.&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;报了一个奇怪的错，想了半天没想明白问题出在哪，随手试了试将 &lt;code&gt;sql:&lt;/code&gt; 前缀干掉，发现一切又都能 work 了，也就是我上述记录的命令。&lt;/p&gt;&lt;p&gt;回头仔细看了下文档：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;       -d [prefix]directory
           Specify the database directory containing the certificate and key database files.

           certutil supports two types of databases: the legacy security databases (cert8.db, key3.db, and secmod.db) and new
           SQLite databases (cert9.db, key4.db, and pkcs11.txt).

           NSS recognizes the following prefixes:

           o   sql: requests the newer database

           o   dbm: requests the legacy database

           If no prefix is specified the default type is retrieved from NSS_DEFAULT_DB_TYPE. If NSS_DEFAULT_DB_TYPE is not set
           then dbm: is the default.&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;原来 nssdb 是有两种模式的，可以通过为 -d 参数加不同前缀指定。但是坑爹的是如果指定了前缀，似乎就无法识别 bash 下的 ~ 。。。因此这里要么不用 ~ 、改用完整路径，要么就不指定 db ，使用默认配置即可。&lt;/p&gt;&lt;p&gt;最后，这个 pki 的文件权限也要注意，开启 chromium 的用户一定要对这个目录有&lt;strong&gt;读写权限&lt;/strong&gt;。一个稳妥的方法就是 &lt;code&gt;chown -R&lt;/code&gt; 一下，保证用户权限没问题。&lt;/p&gt;&lt;p&gt;这样一番配置后，终于可以在 &lt;code&gt;chrome://settings/certificates&lt;/code&gt; 下看到新增的自签名证书了。&lt;/p&gt;
    &lt;/section&gt;
  &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>19bddc1c1a55e1957bd0a1073980a663</guid>
<title>Go 错误处理：100+ 提案全部被拒绝，为何现阶段仍用 if err != nil？</title>
<link>https://toutiao.io/k/qxnnoy8</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content js_underline_content               autoTypeSetting24psection&amp;#10;            &quot; id=&quot;js_content&quot;&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot; data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;大家好，我是煎鱼。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这些年给 Go 提新的错误处理提案的人络绎不绝，挡都挡不住。Ian Lance Taylor 作为历史的亲历者之一特意梳理了《&lt;span&gt;language: Go 2: error handling meta issue&lt;/span&gt;&lt;sup&gt;[1]&lt;/sup&gt;》。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;今天结合我自己写过的内容分享给大家，以后有人再问可以甩给他们，这样他就懂前因后果了。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;背景&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在 2018 年 8 月，现任 Go 核心团队负责人 Russ Cox 给 Go2 的错误处理画了一个大大的蓝图，并介绍了一个未实现的设计草案。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.5185185185185185&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/KVl0giak5ib4h0wTibBUMmh4XfVfKK0pvulNc22qMxiaibtic3LnictWdssau7mic631ZnmDQ2LbEdLvA3wSv5IKVQ5H6Q/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;具体目标如下：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;期望 Go 的错误检查更轻量级，能够减少被大家吐槽的错误检查的程序文本数量。整体上要确保错误处理更加方便，复杂度不能变高。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;错误检查和错误处理都必须保持显式，这意味着在 Go 程序中是可见的。我们不想重复异常处理的陷阱。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;必须保证现有的 Go 代码的兼容性，不能有破坏性升级。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在此之后，也由于 Go 的热浪，许多新的提案作为 Go2 的错误处理变更提交，Go 邮件也有大量的讨论，拥有许多尝试，但&lt;strong&gt;迄今为止没有一个被接受&lt;/strong&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这就是现在 Go 错误处理的背景。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;错误处理合集&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当然，这个合集并不 100% 全面，如果需要全查看一遍，可以自行在 go/issues 库搜索 error-handling 标签就可以了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;以下是一些值得关注的错误处理提案合集：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;画过的大饼 Go2 check/handle 方法&lt;/strong&gt;：&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;常被提起的 try-catch 方法&lt;/strong&gt;：&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;像 Rust 用 ! ? 作为错误检查&lt;/strong&gt;：&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;简化 if err != nil {} 减少代码量&lt;/strong&gt;：&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;使用左侧函数和表达式来替代&lt;/strong&gt;：&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;常见的基本是这几类，有许多雷同的，或被拒绝原因类似的提案，在社区管理上最终都会被指向到一起并关闭。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;你可以通过上述提案的前因后果，可以看到 Go 核心团队的一些衡量标杆。基本就是：&lt;strong&gt;显式、简洁、省心、好用&lt;/strong&gt;。这就是新错误处理提案的要求。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;总结&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Go 的 “新” 错误处理已经经历了 3，5 年了，许多社区友人已经想了许多许多，也提出了许多提案。在 error-handling 标签下共有 100+ 个提案，无一幸免，全部被拒绝。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.4444444444444444&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/KVl0giak5ib4hfv3bRDNIRibReBP0vE3PSpdDpCgcOicphTQqLopUianicNoBAlLftkPlwn8pLZeX2BcvzySKXPnvic8A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;现阶段还是好好的用 if err != nil，也是许多人认可的。或是自己团队内封装一套共识标准，也是可以的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;让风再吹一会。也许不会改变了。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;推荐阅读&lt;span/&gt;&lt;/h4&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;参考资料&lt;/span&gt;&lt;/h3&gt;&lt;section data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;span&gt;[1]&lt;/span&gt;&lt;p&gt;language: Go 2: error handling meta issue: &lt;em&gt;https://github.com/golang/go/issues/40432&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;关注和加煎鱼微信，&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;一手消息和知识，拉你进技术交流群&lt;span&gt;&lt;span&gt;👇&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.9988738738738738&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/KVl0giak5ib4jVkzHVvaqjo3O0BIqDRJKkEyib7SJsryxHBFGsvek0FkdiczfJP6AdbWnK25DvlX3dY8wRObPbVJQg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;888&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.07106598984771574&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/486RHs1WbcgGib6o96dHbvGUGGwPicd8wusUGH1cXR29tM4bO0lNzialzkQhvU6m5ZUdaKibmcF2OQayjMe9Bia6iaXQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;394&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;你好，我是煎鱼，&lt;span&gt;出版过 Go 畅销书《Go 语言编程之旅》，再到获得 GOP（Go 领域最有观点专家）荣誉，&lt;/span&gt;&lt;strong&gt;&lt;span&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzUxMDI4MDc1NA==&amp;amp;mid=2247483854&amp;amp;idx=1&amp;amp;sn=ec422fbf4d846975f2930ddeb5e81373&amp;amp;chksm=f9041493ce739d85a4b987eece14da627206cdad798f645cc770868312e4a22b6df24804f186&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;点击蓝字查看我的出书之路&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;点击蓝字查看我的出书之路&lt;/a&gt;&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;日常分享高质量文章，输出 Go 面试、工作经验、架构设计，&lt;span&gt;加微信拉读者交流群，和大家交流！&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;p&gt;&lt;mp-style-type data-value=&quot;3&quot;/&gt;&lt;/p&gt;&lt;/div&gt;

          
        &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>2f8d13e1bf614c44a0dfd73e8891858a</guid>
<title>线上问题零发生，闲鱼稳定性问题治理与监控优化</title>
<link>https://toutiao.io/k/k8ay7s5</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;86152&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;span data-bgopacity=&quot;40%&quot;/&gt; &lt;span data-bgopacity=&quot;25%&quot;/&gt; &lt;span/&gt;&lt;/section&gt;&lt;section&gt;&lt;section data-brushtype=&quot;text&quot;&gt;&lt;span&gt;&lt;strong&gt;1、灰度&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;安全生产环境是由集团层面为保障线上稳定性的灰度流量生产环境。通过接入层网关的流量控制为环境提供1%线上流量+100%办公网流量，还原线上环境为系统验证提供场所。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;453&quot; data-backw=&quot;541&quot; data-ratio=&quot;0.8373382624768947&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_svg/XxT9TiaJ1ibf3lkuGhR43dNLZ4lZotibVdwUXo1XAMQlcqNkEgnav9GWAf2icB0jD3BnRjAdtqRO1pOvnV9iblbOJiaSx9EwjXSib4W/640?wx_fmt=svg&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; data-w=&quot;541&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;我们以安全生产环境为基础展开一系列治理：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-role=&quot;list&quot;/&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;常规场景下，安全生产流量能保证从入口到后续全链路都在安全生产环境闭环。但在闲鱼消息场景里，强依赖MQ做流量的负载均衡，而安全生产流量经过MQ之后会被均匀打散，逃逸到线上，失去灰度观察能力。针对该问题，我们通过spring的Conditional条件注入能力，将线上和安全生产的MQ bean隔离，从而将线上和安全生产MQ topic隔离，使流量能够在安全生产环境完整闭环。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;128&quot; data-backw=&quot;568&quot; data-ratio=&quot;0.22595830531271016&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_svg/XxT9TiaJ1ibf3lkuGhR43dNLZ4lZotibVdwFvDCWGnY1vodPaenK8QxNvYraI7PiaRVex4ic7L7QgddWia8qhF15F9exHtFOXaDYiak/640?wx_fmt=svg&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; data-w=&quot;1487&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-role=&quot;list&quot;/&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;安全生产环境和生产环境的监控基线不同，告警阈值不同，为了能及时发现灰度问题，我们以安全生产环境的水位单独配置了监控告警。覆盖调用量、RT、错误量、消息延迟等多个指标维度，覆盖发送消息、创建会话等所有核心链路场景。我们将安全生产监控聚合成监控大盘，实时和线上监控水位做对比，不仅能发现变更引起的问题，还能发现变更对性能指标的影响。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-role=&quot;list&quot;/&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;监控告警是实时的异常指标监控，而离线报表是更长时间窗口的指标聚合。我们针对安全生产环境配置独立的离线监控报表，它不仅能发现细微波动的异常指标，也能发现变更对业务指标（例如消息到达率、点击率）的影响。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-role=&quot;list&quot;/&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;自动化回归保障系统的底线，核心场景回归能避免引起严重的问题。我们将自动化回归与CICD集成，当发布到安全生产环境时自动执行自动化回归。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-role=&quot;list&quot;/&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在完善安全生产建设后，如果没有规范去标准化流程，建立行为准则同样达不到保障稳定性的目标。我们结合消息本身的业务特点，约定了消息团队内部的发布规范：发布必须在安全生产停留一晚，第二天灰度放量。确保：1. 覆盖时间相关的代码逻辑。2. 足够久的灰度观测。3. 产出t+1的离线监控报表&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;86152&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;span data-bgopacity=&quot;40%&quot;/&gt; &lt;span data-bgopacity=&quot;25%&quot;/&gt; &lt;span/&gt;&lt;/section&gt;&lt;section&gt;&lt;section data-brushtype=&quot;text&quot;&gt;&lt;span&gt;&lt;strong&gt;2、监控告警&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;监控告警的生命周期可以分为监控数据准备、监控配置、监控验证、告警配置、告警验证五个环节。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;305&quot; data-backw=&quot;568&quot; data-ratio=&quot;0.5368126747437092&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/DUwiayJ0Mj1GdDic1VabvGpFuLJfw0uorMIxXzLCL4JwWIJ1TPYZqVdL6SibKribj8SA3jK6lnqicGmEF3fzAY3JavA/640?wx_fmt=png&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; data-w=&quot;1073&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;监控数据准备环节我们有完善的基础设施。基于这个基础，我们对监控告警进行覆盖率、及时性、有效性治理：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-role=&quot;list&quot;&gt;&lt;section data-role=&quot;list&quot;/&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;治理的第一个目标是要确保监控覆盖全，不遗漏。我们分为三步确保覆盖完整：1. 梳理出系统的核心场景链路，链路上的核心观测指标，查缺补漏监控告警。2. 通用的监控告警作为兜底，覆盖资源水位、接口调用、中间件性能等基础指标。3. 最后，通过监控告警离线报表整体性review监控告警覆盖率。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-role=&quot;list&quot;/&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;治理的第二个目标是能及时发现问题、有效发现问题。告警的及时性与有效性是互斥的关系，为达到告警及时性与有效性的最佳平衡，我们按照从严到松的方式逐步调整告警条件。同时为了持续维持告警及时性有效性，我们建立监控告警离线报表，定期review告警记录，对告警调优。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-role=&quot;list&quot;/&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;监控告警治理需要持续投入，持续保鲜。我们搭建了监控告警离线报表，它包含所有的监控告警配置，告警历史流水，提供告警历史的聚合试图。为我们覆盖率治理、有效性治理提供全局视图，支撑我们定期对监控告警调优。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;691&quot; data-backw=&quot;568&quot; data-ratio=&quot;1.2169625246548323&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/DUwiayJ0Mj1GdDic1VabvGpFuLJfw0uorMgHbTQpgEHuOEUUgn3d5sSjhMldYPVvoKWMWicYCrbI04wh8I89q8yeA/640?wx_fmt=png&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; data-w=&quot;1014&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;86152&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;span data-bgopacity=&quot;40%&quot;/&gt; &lt;span data-bgopacity=&quot;25%&quot;/&gt; &lt;span/&gt;&lt;/section&gt;&lt;section&gt;&lt;section data-brushtype=&quot;text&quot;&gt;&lt;span&gt;&lt;strong&gt;3、自动化回归&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;自动化回归的目标是保障底线，确保核心链路场景的稳定性。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-role=&quot;list&quot;/&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;端到端级别的自动化回归能从真实使用角度去验证稳定性。我们设计端到端的自动化回归用例，覆盖软件从安装、使用、卸载的完整生命周期，覆盖消息核心场景链路。我们将自动化回归与CICD集成，每天定时自动化回归，在发布流程做自动化回归卡口。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;69&quot; data-backw=&quot;568&quot; data-ratio=&quot;0.12115384615384615&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_svg/XxT9TiaJ1ibf3lkuGhR43dNLZ4lZotibVdwD0HL1QlLiaM8IdrVB6yPMDIibPJvKKVYulnRz0Up05ibFBEV2TjhrYGA2icLNw4obcdj/640?wx_fmt=svg&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; data-w=&quot;1040&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;176&quot; data-backw=&quot;568&quot; data-ratio=&quot;0.3101851851851852&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/DUwiayJ0Mj1GdDic1VabvGpFuLJfw0uorMef2e2qLK1Ayibgm7lDTO6YYqj6WF1RvEhiasxRfLvCJCxFUYyiaPdq7pg/640?wx_fmt=png&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; data-w=&quot;1080&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-role=&quot;list&quot;/&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;凤凰回放工具是基于JVMTI实现的流量回放测试工具。我们使用凤凰回放工具录制RPC流量，回放流量，diff结果，验证接口级别的稳定性。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;86152&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;span data-bgopacity=&quot;40%&quot;/&gt; &lt;span data-bgopacity=&quot;25%&quot;/&gt; &lt;span/&gt;&lt;/section&gt;&lt;section&gt;&lt;section data-brushtype=&quot;text&quot;&gt;&lt;span&gt;&lt;strong&gt;4、依赖治理&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;依赖治理的目标是强弱依赖关系合理，并且弱依赖具备降级快恢能力。我们进行了以下治理：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-role=&quot;list&quot;&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;依赖梳理：&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;代码级别review依赖的合理性，review是否具备降级快恢能力&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;依赖改造：&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;对不合理的强依赖降级为弱依赖，完善弱依赖的监控告警，降级快恢预案&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;依赖演练：&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;依赖演练是对依赖治理的验收环节。目的是验证强弱依赖关系和预期一致，避免出现“我以为”但“实际是”的问题，同时验证弱依赖的问题发现能力，降级快恢能力。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>758f624b28d631cf075c2732ada11535</guid>
<title>聊聊「订单」业务的设计与实现</title>
<link>https://toutiao.io/k/gjiunzv</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content js_underline_content               autoTypeSetting24psection&amp;#10;            &quot; id=&quot;js_content&quot;&gt;&lt;blockquote&gt;&lt;p&gt;订单，业务的核心模块；&lt;/p&gt;&lt;/blockquote&gt;&lt;h1&gt;&lt;span&gt;一、背景简介&lt;/span&gt;&lt;span/&gt;&lt;/h1&gt;&lt;p&gt;订单业务一直都是系统研发中的核心模块，订单的产生过程，与系统中的很多模块都会高度关联，比如账户体系、支付中心、运营管理等，即便单看订单本身，也足够的复杂；&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.575&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/uUIibyNXbAvByAaLXcL8ztah8AMC4baEfndlrbMXzljcjc8NxTbcGQIjeZa0NggShL65rUPr8vrE8CU4Q1apHSw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/p&gt;&lt;p&gt;业务在发展的过程中，必然会导致订单量的持续增加，订单自身、数据体量、实现流程，都需要不断的迭代更新，如果在订单流程的研发初期，没有相对全面的考量，那么很有可能导致中后期的重构；&lt;/p&gt;&lt;p&gt;从实践经验上说，围绕订单业务：&lt;strong&gt;建议过度设计，轻量级分步实现&lt;/strong&gt;；&lt;/p&gt;&lt;p&gt;在产品初期先做好全面的设计，场景和流程上做好可扩展性的保留，在数据层面规划好不同体量的应对方案，走在订单业务的前面避免被动，尽量不要被业务的发展和演变甩在身后；&lt;/p&gt;&lt;h1&gt;&lt;span&gt;二、订单业务&lt;/span&gt;&lt;span/&gt;&lt;/h1&gt;&lt;h2&gt;&lt;span&gt;1、订单体系&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p&gt;订单体系从角色上看，主要涉及：用户、商户、平台三个核心参与方，其订单流程的搭建就是围绕三方的交易场景展开；&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;1.05&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/uUIibyNXbAvByAaLXcL8ztah8AMC4baEfn3ochKKtOZNiaUtEJ6llyicjC1HsppGojicsEBR3QOyI6U9OOStsxzroA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/p&gt;&lt;p&gt;这里需要说明一些细节：商户可以是第三方商家，也可以是平台方自己，不影响概念上的划分；商品也存在多种形式，所以用交付来描述，可以覆盖物流的定义；&lt;/p&gt;&lt;p&gt;用户：通过应用端，进行商品的选择和下单；平台：实现订单交易链路和支付能力，以及对整个流程的调度；商户：提供商品和交付能力；&lt;/p&gt;&lt;p&gt;在图中，只是围绕订单体系做一个框架性的宽泛描述，在成熟的订单业务中，其复杂程度远超上图，下面围绕核心节点来细致分析；&lt;/p&gt;&lt;h2&gt;&lt;span&gt;2、流程管理&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;h3&gt;&lt;span&gt;2.1 流程拆分&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;订单的业务属性是极高的，流程本身也比较复杂，从不同的参与方来看，其流程分段策略完全不一样，这里仅站位研发视角，把订单逻辑分为：创建、支付、交付三个阶段；&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.32222222222222224&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/uUIibyNXbAvByAaLXcL8ztah8AMC4baEfwoqh0e5SZibvghyU7D3wplYAIib3g7uGVrRV1lASE7RCibKKE4gxgq8tw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;订单创建：围绕用户的下单路径做管理，从商品的访问点击并选中，到购车下单或者直接下单，从而完成订单的创建；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;订单支付：各种支付渠道的对接是交易场景的基础功能，订单的核心状态即支付成功；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;订单交付：在订单支付完成之后，开始进行商品的交付流程，可能是商家的发货或者服务提供，交付成功即订单完成；&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;如果将整个订单场景统筹起来看的话，还存在很多隐性的流程，与订单衔接的上下游业务还有很多，这里只是专注于订单功能自身的边界做划分；&lt;/p&gt;&lt;h3&gt;&lt;span&gt;2.2 正向流程&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;在理想的状态下，订单从购物车结算下单开始，到交易支付完成，最终到商家完成交付，是非常复杂的流程链路；&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.7777777777777778&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/uUIibyNXbAvByAaLXcL8ztah8AMC4baEfRoV3Fw8ebVeEqoOFX7f6mAQfmyXlfGmFaMlRUCkPBGpteTfV0fRvuA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/p&gt;&lt;p&gt;在实现上，订单的正向流程链路都是分段管理的，比如购物车、订单创建之后、支付完成、交付等诸多关键节点，并不是一个即时的流程；&lt;/p&gt;&lt;h3&gt;&lt;span&gt;2.3 逆向流程&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;对于订单这种极度复杂的流程，导致订单流程逆向的情况，要细致的考虑并且提供相应的解决方案，尽量确保程序可以兜底流程逆向，人工干预的成本和风险都极高；&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.55&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/uUIibyNXbAvByAaLXcL8ztah8AMC4baEfv5wYdxoHGxPVueNYJgRf4FqwbQGzUaB7vh5wGIIVW8h34FGRUE72Dw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;取消动作：用户主动取消订单，发起退款流程等；商户因为交付失败，主动发起流程退回等动作；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;超时情况：订单创建后，指定时间内没有支付；订单支付后，指定时间内商家没有交付等多个超时场景；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;节点异常：系统平台的在订单调度时的业务异常，或者程序异常，又或者支付等第三方渠道异常等；&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;这些常见的异常问题，在一般的场景下可能不会引发效应问题，对于订单这种异步解耦的复杂场景中，需要一个稳定的机制快速执行逆向流程；比如下单后未支付导致持续锁定库存，或者交付超时影响用户体验等；&lt;/p&gt;&lt;h3&gt;&lt;span&gt;2.4 调度与监控&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;订单属于核心流程又兼具复杂的特性，自然依赖系统平台的调度与监控手段，无论是正向还是逆向流程，都依赖调度手段提高订单的完成率，或者促使逆向流程有序执行，在这个过程中需要对订单路径有完整的监控能力；&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.4777777777777778&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/uUIibyNXbAvByAaLXcL8ztah8AMC4baEfUS99VjALSEnotictF65sXicnhXgSlbx55py2pQJiaCzCJ632HicKicGlS9w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;调度机制&lt;/strong&gt;：更侧重订单被动状态的处理，多见于各种超时的场景，用来提前对用户和商户进行消息提醒触达，或者进行订单流程的处理；&lt;/p&gt;&lt;p&gt;&lt;strong&gt;监控策略&lt;/strong&gt;：更侧重对订单的主动干预处理，在发现订单中断或者异常时，可以通过产品层面的入口进行主动修复，或者系统层面的主动重试，当然也不排除最后的手动干预；&lt;/p&gt;&lt;h2&gt;&lt;span&gt;3、结构设计&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p&gt;围绕订单场景，涉及的数据结构非常复杂，不论是商品还是支付，亦或是订单自身的结构，在具体的业务中都会拓展出很多关联表；&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.45740740740740743&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/uUIibyNXbAvByAaLXcL8ztah8AMC4baEfPGrlra4QFDtibl84LxTIwEe96evITwUVfqcD15FJexZ7zcnhlbBLDEA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/p&gt;&lt;p&gt;订单结构的设计和管理，基于场景复杂度考虑，可能要融合商家、仓储货架、用户、渠道和类型等；在订单量增长之后，还需要结合业务场景，进行数据体量层面的拆分处理；&lt;/p&gt;&lt;h1&gt;&lt;span&gt;三、技术方案&lt;/span&gt;&lt;span/&gt;&lt;/h1&gt;&lt;h2&gt;&lt;span&gt;1、订单ID&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p&gt;订单主体的唯一ID标识，在数据体量不大的情况下，使用表的自增ID主键即可，从长期看的话并不友好，如果订单量比较大，可能涉及分库分表的流程，则需要制定ID生成策略；&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;UUID&lt;/strong&gt;：生成唯一字符串识别码，订单ID直接使用即可；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;雪花算法&lt;/strong&gt;：分布式ID生成算法策略，生成的ID遵循时间的顺序；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;自定义ID&lt;/strong&gt;：除了唯一的属性外，在订单ID中添加其他的关键业务标识；&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2&gt;&lt;span&gt;2、并行与异步&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;并行操作&lt;/strong&gt;，在订单详情的加载过程中，涉及到的查询信息非常多，比如：商品、商户、订单、用户等，可以通过并行的方式，提高响应的时间，如果采用串行的方式，则接口性能会差很多；&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.3537037037037037&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/uUIibyNXbAvByAaLXcL8ztah8AMC4baEfcQmIUAA3Mbu8DVM5BYeJGLbk4TgzZLcDFqFG5de4bNVU0hvoNYItEQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;异步操作&lt;/strong&gt;，订单是个复杂的流程，显然不可能在一次流程中完成所有逻辑，流程分段异步常规手段，就是借助MQ消息的方式，同样可以极大的提升服务性能；不论是订单的正逆向流程，都可以基于状态、事件、动作进行异步解耦处理；&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.35833333333333334&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/uUIibyNXbAvByAaLXcL8ztah8AMC4baEfekPdcjlrwKuFeffxibGgoPib5XewZ6mnia7j4dL7LRGnBgNAh2nHgPAZw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/p&gt;&lt;h2&gt;&lt;span&gt;3、超时问题&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p&gt;订单超时问题的本质在于，指定时间段之后需要执行一个动作；比如最经典的场景，下单之后超过&lt;code&gt;15||30&lt;/code&gt;分钟未支付，订单自动取消并且被关闭，释放商品的库存，并通知用户；&lt;/p&gt;&lt;p&gt;实现一个动作延迟执行的方式有很多，比如延期队列，过期监听，消息延时消费等，不过这些方式在复杂的订单系统中并不常见，主流的话还是采用定时任务调度的方式；&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.2972222222222222&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/uUIibyNXbAvByAaLXcL8ztah8AMC4baEf6Yy8lEWqtv1xj5qMOYHXv74639XuXglVXRXKbSETVB6eX5nbRpRibWQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/p&gt;&lt;p&gt;任务调度时，对订单的处理，同样要确保业务流程操作的幂等性，数据层面的一致性等问题，如果出现异常单则进行重试，分析异常原因不断优化流程也同样重要；&lt;/p&gt;&lt;p&gt;&lt;strong&gt;如果订单体量大，任务调度能完成吗？&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;订单体量和订单实时量不是一个概念，系统沉淀的订单量和任务要处理的量不是一个等级，常规的数据体量做好分库分表的设计和查询优化即可，不会成为调度任务的瓶颈问题；&lt;/p&gt;&lt;p&gt;&lt;strong&gt;如果订单数据实时体量大，比如每天超千万的水平？&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;这就更不是应用的问题了，订单体量能达到每日千万的规模，公司会提前很长时间就把数据团队拉到应用团队中，解决这种核心的棘手问题，此前在数据公司搬砖时，每日单量刚过百万，就安排数据团队做解决方案了；&lt;/p&gt;&lt;h2&gt;&lt;span&gt;4、分布式事务&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p&gt;订单涉及支付对接、库存管理、结算对账等各种复杂的流程，自然对数据一致性有极高的要求，如果数据层面出现问题导致异常单出现，难免需要人工介入处理，所以对流程的各阶段做好细致的事务和逻辑管理极其重要；&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.29814814814814816&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/uUIibyNXbAvByAaLXcL8ztah8AMC4baEfmBMkojib1DTInHxBSuMwuw6KTzL7DDyplvibzrDRD1NibM9Uib8CLGFrEQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/p&gt;&lt;p&gt;订单流程是异步解耦的方式推进的，在分布式事务的策略上追求的是最终结果一致性即可，不过这并不妨碍在分段的流程中，进行局部的事务管理，事务成功，流程正向推进，事务失败，流程重试或逆向回滚；&lt;/p&gt;&lt;h1&gt;&lt;span&gt;四、数据方案&lt;/span&gt;&lt;span/&gt;&lt;/h1&gt;&lt;h2&gt;&lt;span&gt;1、转化分析&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p&gt;经典的订单指标体系，用户下单过程的路径统计，从而深度的分析转化率问题，不断的对流程和场景优化，从而提高成交量；&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.4685185185185185&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/uUIibyNXbAvByAaLXcL8ztah8AMC4baEficJsmhLOBibgg7QX5yJvpK1Oa6WoDNKGbHlOkL511lHYIJyD48P03gtg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/p&gt;&lt;p&gt;交易的转化路径分析，是产品和运营重点关注的指标体系，在数据层面，埋点采集的数据通常是上传第三方平台，方便进行用户和业务分析，并且有助于同类客群的营销推广；&lt;/p&gt;&lt;h2&gt;&lt;span&gt;2、分库分表&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p&gt;数据在到达一定体量之后，需要进行分库分表的操作，从而解决各种性能方面的问题；将订单数据按照特定的维度进行计算，从而将数据分流到不同的库表中，解决读和写的瓶颈；&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.4722222222222222&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/uUIibyNXbAvByAaLXcL8ztah8AMC4baEfy6P1a0a1HwlVK1hwp5k4Y1Bl5rGIGuQtqyuIN57FkdjvtfUqCAzVGQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/p&gt;&lt;p&gt;基于订单ID计算拆分的逻辑是最常见的，在特殊情况下，也会基于用户ID或商户ID进行计算，从而将相关的数据堆放在一起，如果有必要，也可以考虑多维度拆分的多写模式；&lt;/p&gt;&lt;h2&gt;&lt;span&gt;3、数据同步&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p&gt;订单数据分库分表虽然解决存储问题，但是也带来了很多查询方面的阻碍，通过搜索引擎来解决查询问题也是常用的技术选型；&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.3296296296296296&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/uUIibyNXbAvByAaLXcL8ztah8AMC4baEf9MEZDxLhIlicGian3GckHsANEb60x6qFykPlpzZhTJT7mr2GBxHZhhicg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/p&gt;&lt;p&gt;订单数据在库和搜索引擎之间同步的方法有很多：同步双写，对数据的实时性要求极高；异步解耦，流程存在轻微的延迟；定时任务，存在明显的时效问题；组件同步，采用第三方数据同步组件；订单场景的话推荐同步双写的方式。&lt;/p&gt;&lt;h1&gt;&lt;span&gt;五、参考源码&lt;/span&gt;&lt;/h1&gt;&lt;pre&gt;&lt;code&gt;编程文档：&lt;br/&gt;https://gitee.com/cicadasmile/butte-java-note&lt;br/&gt;&lt;br/&gt;应用仓库：&lt;br/&gt;https://gitee.com/cicadasmile/butte-flyer-parent&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;END&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section data-support=&quot;96编辑器&quot; data-style-id=&quot;30792&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;97816&quot; data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;section data-role=&quot;outer&quot; label=&quot;Powered by 135editor.com&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;mp-style-type data-value=&quot;3&quot;/&gt;&lt;/p&gt;&lt;/div&gt;

          
        &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>4f1a8fff53002f3c8ad99197c4ba41c8</guid>
<title>如何用一个端口同时暴露 HTTP1/2、gRPC、Dubbo 协议?</title>
<link>https://toutiao.io/k/npos18w</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;86005&quot;&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;本文我们将介绍 Apache Dubbo 灵活的多协议设计原则，基于这一设计，在 Dubbo 框架底层可灵活的选用 HTTP/2、HTTP/REST、TCP、gRPC、JsonRPC、Hessian2 等任一 RPC 通信协议，同时享用统一的 API 与对等的服务治理能力。同时，我们还介绍了 Dubbo 的单端口多协议能力，也就是在单个端口同时监听、处理多个协议，这对于简化多协议同时发布的场景非常有用。&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;不绑定 RPC 协议的设计原则&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Dubbo 框架不绑定任何通信协议，你可以根据业务场景选择 HTTP/2 通信协议，也可以选用 HTTP/REST、TCP（Dubbo2）、gRPC、JsonRPC、Hessian2 等官方支持的通信协议，如果以上协议都不能满足需求，还可以非常方便的通过定制方式接入自定义协议。如果你想在一个应用内使用多个协议，也可以非常容易的做到，比如一个接口使用 HTTP/2 通信，另一个接口使用 TCP 通信，一个应用内发布或调用多个使用不同协议的服务。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.32314814814814813&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/qdzZBE73hWtoZnJC5MHpmibfkJINVjuicZyJibozw7hIwh33ZkdW6HqalSYiaicvNt7lqIhjiagGxia6sic3EEtWfl1Hbw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;通过 Dubbo 框架的多协议支持，你可以做到：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-role=&quot;list&quot;&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;将任意通信协议无缝地接入 Dubbo 服务治理体系。Dubbo 体系下的所有通信协议，都可以享受到 Dubbo 的编程模型、服务发现、流量管控等优势。比如 gRPC over Dubbo 的模式，服务治理、编程 API 都能够零成本接入 Dubbo 体系。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;兼容不同技术栈，业务系统混合使用不同的服务框架、RPC 框架。比如有些服务使用 gRPC 或者 Spring Cloud 开发，有些服务使用 Dubbo 框架开发，通过 Dubbo 的多协议支持可以很好的实现互通。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;让协议迁移变的更简单。通过多协议、注册中心的协调，可以快速满足公司内协议迁移的需求。比如如从自研协议升级到 Dubbo 协议，Dubbo 协议自身升级，从 Dubbo 协议迁移到 gRPC，从 HTTP 迁移到 Dubbo 协议等。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;官方接入的主流协议&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;HTTP/2 (Triple)&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Triple 协议是 Dubbo3 发布的面向云原生时代的通信协议，它基于 HTTP/2 并且完全兼容 gRPC 协议，原生支持 Streaming 通信语义，自 Triple 协议开始，Dubbo 还支持基于 Protobuf 的服务定义与数据传输。Triple 具备更好的网关、代理穿透性，因此非常适合于跨网关、代理通信的部署架构，如服务网格等。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Triple 协议的核心特性如下：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-role=&quot;list&quot;/&gt;&lt;p&gt;&lt;span&gt;在编程与通信模型上，Triple 协议支持如下模式：&lt;/span&gt;&lt;/p&gt;&lt;section data-role=&quot;list&quot;&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;消费端异步请求(Client Side Asynchronous Request-Response)&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;提供端异步执行（Server Side Asynchronous Request-Response）&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;消费端请求流（Request Streaming）&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;提供端响应流（Response Streaming）&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;双向流式通信（Bidirectional Streaming）&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;TCP (Dubbo2)&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Dubbo2 协议是基于 TCP 传输层协议之上构建的一套 RPC 通信协议，由于其紧凑、灵活、高性能的特点，在 Dubbo2 时代取得了非常广泛的应用，是企业构建高性能、大规模微服务集群的关键通信方案。在云原生时代，我们更推荐使用通用性、穿透性更好的 Triple 协议。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;gRPC&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;你可以用 Dubbo 开发和治理微服务，然后设置使用 gRPC 协议进行底层通信。但为什么要这么做那，与直接使用 gRPC 框架对比有什么优势？简单的答案是，这是使用 gRPC 进行微服务开发的常用模式，具体请往下看。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;gRPC 是谷歌开源的基于 HTTP/2 的通信协议，如同我们在产品对比[1]文档中提到的，gRPC 的定位是通信协议与实现，是一款纯粹的 RPC 框架，而 Dubbo 定位是一款微服务框架，为微服务实践提供解决方案。因此，相比于 Dubbo，gRPC 相对欠缺了微服务编程模型、服务治理等能力的抽象。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在 Dubbo 体系下使用 gRPC 协议 (gRPC over Dubbo Framework) 是一个非常高效和轻量的选择，它让你既能使用原生的 gRPC 协议通信，又避免了基于 gRPC 进行二次定制与开发的复杂度 (二次开发与定制 gRPC，是很多企业规模化实践后证实不可避免的环节，Dubbo 框架替开发者完成了这一步，让开发者可以直接以最简单的方式使用 gRPC)。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;REST&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;微服务领域常用的一种通信模式是 HTTP + JSON，包括 Spring Cloud、Microprofile 等一些主流的微服务框架都默认使用的这种通信模式，Dubbo 同样提供了对基于 HTTP 的编程、通信模式的支持。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;其他通信协议&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;除了以上介绍的几种协议之外，你还可以将以下协议运行在 Dubbo 之上。对 Dubbo 而言，只需要修改一行简单的配置，就可以切换底层服务的通信协议，其他外围 API 和治理能力不受影响。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-role=&quot;list&quot;/&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;单端口多协议&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;自 Dubbo 3.2 版本开始，Dubbo 提供了单个端口上的协议复用能力，通过调整 Protocol 配置即可实现。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;比如在开启 HTTP/2 (Triple) 协议 或  gRPC 协议后，如我们同时启动端口复用，还可以在相同的端口上为服务增加 TCP (Dubbo2) 协议、Qos 协议的支持。这些所有流量的入口都在一个统一 port 端口， Dubbo 框架负责在端口之上识别不同的 RPC 协议，并进行处理器分发，从而实现单个端口上的协议复用。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;对于需要处理多个协议的场景，端口复用非常有价值。它可以用于服务的协议迁移，并且可以节约端口以及相关的资源，减少运维的复杂性等。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;实现原理&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;以下是端口复用实现的原理图&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-role=&quot;list&quot;&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;在服务的创建阶段，通过从 Config 层获取到服务导出的协议配置从而创建不同的 Protocol 对象进行导出。在导出的过程中，如果不是第一次创建端口复用的 Server，那么 Exchanger 会将 Protcol 层传递的数据保存到 Server，用于后续处理该协议类型的消息。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;当客户端的消息传递过来后，首先会通过 Server 传递给 ProtocolDetector，如果完成了识别，那么就会标记该客户端为对应的协议。并通过 WireProtocol 配置对应的处理逻辑，最后交给 ChannelOperator 完成底层的 IO 框架和对应的 Dubbo 框架的处理逻辑的绑定。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;以上的协议识别完成之后，Channel 已经确定了如何处理远程的客户端消息，通过对应的 ServerPipeline 进行处理即可（在处理的过程中也会根据配置信息决定消息的处理线程）。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;使用场景&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;以下是几种常见的使用场景。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-role=&quot;list&quot;&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;最常用的是用于服务发现。这允许应用程序通过网络发现服务，然后使用同一端口与它们通信，有助于降低网络通信的复杂性，并使其更易于管理。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;可以用于负载平衡。这允许应用程序在多个远程服务或服务集群之间平衡负载，有助于提高服务的可扩展性、可靠性和可用性。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;可以用于服务监控。这允许应用程序监视远程服务的运行状况，并在服务出现故障或变得不可用时发出警报，有助于确保服务的可用性并减少停机时间。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;&lt;span&gt;参考用例：&lt;br/&gt;https://github.com/apache/dubbo-samples/tree/master/dubbo-samples-port-unification&lt;/span&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;使用方式&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在同一主机上部署多个服务或需要通过负载均衡器访问多个服务。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;&lt;span&gt;关于 Dubbo 支持的配置方式 配置说明[2]&lt;/span&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;/p&gt;&lt;h4&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;服务多协议导出&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h4&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;ext-protocol 参数支持配置多个不同的协议，协议之间通过&quot;,&quot;进行分隔。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;h5&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;xml 配置&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h5&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;&lt;section&gt;&lt;pre&gt;&lt;p&gt;&lt;span&gt;&amp;lt;dubbo:protocol name=&lt;span&gt;&quot;dubbo&quot;&lt;/span&gt; port=&lt;span&gt;&quot;-1&quot;&lt;/span&gt; ext-protocol=&lt;span&gt;&quot;tri,&quot;&lt;/span&gt;/&amp;gt;&lt;br/&gt;&lt;br/&gt;&amp;lt;bean id=&lt;span&gt;&quot;greetingService&quot;&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;=&lt;span&gt;&quot;org.apache.dubbo.demo.provider.GreetingServiceImpl&quot;&lt;/span&gt;/&amp;gt;&lt;br/&gt;&lt;br/&gt;&amp;lt;dubbo:service delay=&lt;span&gt;&quot;5000&quot;&lt;/span&gt; version=&lt;span&gt;&quot;1.0.0&quot;&lt;/span&gt; &lt;span&gt;group&lt;/span&gt;=&lt;span&gt;&quot;greeting&quot;&lt;/span&gt; timeout=&lt;span&gt;&quot;5000&quot;&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt;=&lt;span&gt;&quot;org.apache.dubbo.demo.GreetingService&quot;&lt;/span&gt; &lt;span&gt;ref&lt;/span&gt;=&lt;span&gt;&quot;greetingService&quot;&lt;/span&gt; protocol=&lt;span&gt;&quot;dubbo&quot;&lt;/span&gt;/&amp;gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;/pre&gt;&lt;/section&gt;&lt;h5/&gt;&lt;p&gt;&lt;/p&gt;&lt;h5&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;API 配置&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h5&gt;&lt;section&gt;&lt;section data-role=&quot;list&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;span/&gt;&lt;section&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;ProtocolConfig &lt;span&gt;config&lt;/span&gt; = new ProtocolConfig(CommonConstants.TRIPLE, &lt;span&gt;-1&lt;/span&gt;);&lt;br/&gt;&lt;br/&gt;&lt;span&gt;config&lt;/span&gt;.setExtProtocol(CommonConstants.DUBBO+&lt;span&gt;&quot;,&quot;&lt;/span&gt;);&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;span/&gt;&lt;h5/&gt;&lt;p&gt;&lt;/p&gt;&lt;h5&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;yaml 配置&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h5&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;&lt;section&gt;&lt;pre&gt;&lt;code&gt;dubbo:&lt;br/&gt;  application:&lt;br/&gt;    &lt;span&gt;name&lt;/span&gt;: dubbo-springboot-demo-provider&lt;br/&gt;  protocol:&lt;br/&gt;    &lt;span&gt;name&lt;/span&gt;: tri&lt;br/&gt;    port: -&lt;span&gt;1&lt;/span&gt;&lt;br/&gt;    ext-protocol: dubbo,&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;/span&gt;&lt;h5&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;properties 配置&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h5&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;&lt;section&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;dubbo.protocol.&lt;span&gt;name&lt;/span&gt;=tri&lt;br/&gt;dubbo.protocol.ext-protocol=dubbo,&lt;br/&gt;dubbo.protocol.port=&lt;span&gt;20880&lt;/span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;h4&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;Qos 接入&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h4&gt;&lt;p&gt;&lt;/p&gt;&lt;h5&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;Qos 模块导入&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;strong&gt;&lt;span/&gt;&lt;/strong&gt;&lt;/h5&gt;&lt;section&gt;&lt;section data-role=&quot;list&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;&amp;lt;&lt;span&gt;dependency&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&amp;lt;&lt;span&gt;groupId&lt;/span&gt;&amp;gt;&lt;/span&gt;org.apache.dubbo&lt;span&gt;&amp;lt;/&lt;span&gt;groupId&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&amp;lt;&lt;span&gt;artifactId&lt;/span&gt;&amp;gt;&lt;/span&gt;dubbo-qos&lt;span&gt;&amp;lt;/&lt;span&gt;artifactId&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&amp;lt;/&lt;span&gt;dependency&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;完成 Qos 模块的导入之后，相关的配置项可参考 Qos 操作手册[3]进行配置。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;默认情况下，基于端口复用的 Qos 服务在模块导入后是启动的。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;h4&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;Qos 使用&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h4&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;将 Qos 协议接入到端口复用的场景下，需要在建立连接之后，客户端先向服务端发送消息，对比将 Qos 协议通过单个端口提供服务，端口复用版的 Qos 协议在处理 telnet 连接的情况下需要用户执行一些操作，完成协议识别（二选一）。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;1.直接调用命令&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;直接调用 telnet 支持的命令也可以完成识别，在用户不熟悉的情况下可以调用 help 指令完成识别&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5166130760986066&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/qdzZBE73hWtoZnJC5MHpmibfkJINVjuicZkhe7sxsZOA4TvGvKbUqKD5eibwYAFSxr0SpjIeZ9N4nvCRQIZ5Zf1fQ/640?wx_fmt=png&quot; data-w=&quot;933&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;2. 发送 telnet 命令识别&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;通过 telnet 命令建立连接之后，执行以下几个步骤：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;&lt;section data-role=&quot;list&quot;&gt;&lt;ol class=&quot;list-paddingleft-1&quot;&gt;&lt;section&gt;&lt;section data-role=&quot;list&quot;&gt;&lt;p&gt;&lt;span&gt;a.使用 crtl + &quot;]&quot; 进入到 telnet 交互界面(telnet 默认的 escape character)&lt;/span&gt;&lt;/p&gt;&lt;section data-role=&quot;list&quot;&gt;&lt;p&gt;&lt;span&gt;b.调用 &quot;send ayt&quot; 向服务端发送特殊识别字段(为 telnet 协议的一个特殊字段)&lt;/span&gt;&lt;/p&gt;&lt;section data-role=&quot;list&quot;&gt;&lt;p&gt;&lt;span&gt;c.回车完成消息发送并进入到 dubbo 的交互界面&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/ol&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;h4&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;服务引用&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h4&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;以 dubbo-samples-port-unification[4]中的例子作为基础, 引用不同协议的服务和非端口复用情况下的配置是一致的，下面通过 Consumer 端的 InvokerListener 输出调用过程中的 URL 信息。&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;section data-role=&quot;list&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;ReferenceConfig&amp;lt;GreetingService&amp;gt; reference = &lt;span&gt;new&lt;/span&gt; ReferenceConfig&amp;lt;&amp;gt;();&lt;br/&gt;reference.setInterface(GreetingService.&lt;span&gt;class&lt;/span&gt;);&lt;br/&gt;reference.setListener(&lt;span&gt;&quot;consumer&quot;&lt;/span&gt;);&lt;br/&gt;reference.setProtocol(&lt;span&gt;this&lt;/span&gt;.protocol);&lt;br/&gt;&lt;span&gt;// reference.setProtocol(CommonConstants.DUBBO);&lt;/span&gt;&lt;br/&gt;&lt;span&gt;// reference.setProtocol(CommonConstants.TRIPLE);&lt;/span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.22037037037037038&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/qdzZBE73hWtoZnJC5MHpmibfkJINVjuicZdLQy5WBeTwp752F0gSsxmOBZnDBoO3HuK3lblsEK8lASWVbVQ0gPMA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;总结&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;对于微服务实践中经常会遇到的多协议通信的场景，Dubbo 不绑定协议的设计让用户可以灵活的选择通信协议，整个协议选择过程对上层 API 编码与运维治理完全透明；对于要在一个集群内同时处理多个协议的场景，Dubbo 的多协议支持也可以从容应对，而单端口的多协议复用支持进一步简化了这一过程。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在接下来的一篇文章中，我们将详细介绍如何在 Dubbo 框架中开发 gRPC 协议通信的服务，极大的简化了 gRPC 微服务开发成本，避免了二次开发，为原生 gRPC 提供了统一的编程 API 与开箱即用的服务治理能力。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;相关链接：&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;[1]产品对比&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;https://cn.dubbo.apache.org/zh-cn/overview/what/xyz-difference/&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;[2]配置说明&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;https://cn.dubbo.apache.org/zh-cn/overview/mannual/java-sdk/reference-manual/config/&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;[3]Qos 操作手册&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;https://cn.dubbo.apache.org/zh-cn/overview/mannual/java-sdk/reference-manual/qos/overview/&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;[4]dubbo-samples-port-unification&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;https://github.com/apache/dubbo-samples/tree/master/3-extensions/protocol/dubbo-samples-port-unification&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;mp-common-profile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mpprofile&quot; data-weui-theme=&quot;light&quot; data-id=&quot;MzI0NTE4NjA0OQ==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/tMJtfgIIibWJZdQ8EicOpoDF9lteAE7gGBotfOe7nZWKicaoH7URJUKISmAkBp7SiakzBrEqib5ZeZYrmIUClJUt1vQ/0?wx_fmt=png&quot; data-nickname=&quot;阿里云云栖号&quot; data-alias=&quot;yunqiinsight&quot; data-signature=&quot;阿里云官网内容平台，汇聚阿里云优质内容（入门、文档、案例、最佳实践、直播等）。&quot; data-from=&quot;0&quot; data-is_biz_ban=&quot;0&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>