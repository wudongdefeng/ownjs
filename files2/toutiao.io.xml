<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>d418fe61e16251bad3232ccbc674f9f0</guid>
<title>一文读懂 Go Http Server 原理</title>
<link>https://toutiao.io/k/fyznjk0</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot; data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;hello大家好呀，我是小楼，这是系列文《Go底层原理剖析》的第二篇，依旧是分析 Http 模块，话不多说，开始。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.9090909090909091&quot; data-type=&quot;jpeg&quot; data-w=&quot;187&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_jpg/xacdaKuBM0QicPichPeoibAEibWwDtkBN3pxDXichfkNmSpXqRdGunpibuf8yejmejb0fD0aFu1AFV0DiaUkH4bncWibAQ/640?wx_fmt=jpeg&quot;/&gt;&lt;/figure&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;从一个 Demo 入手&lt;/span&gt;&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;俗话说万事开头难，但用 Go 实现一个 Http Server 真不难，简单到什么程度？起一个 Server，并且能响应请求，算上包名、导入的依赖，甚至空行，也就只要 15 行代码：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;package&lt;/span&gt; main&lt;br/&gt;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; (&lt;br/&gt; &lt;span&gt;&quot;io&quot;&lt;/span&gt;&lt;br/&gt; &lt;span&gt;&quot;net/http&quot;&lt;/span&gt;&lt;br/&gt;)&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; http.HandleFunc(&lt;span&gt;&quot;/hello&quot;&lt;/span&gt;, hello)&lt;br/&gt; http.ListenAndServe(&lt;span&gt;&quot;:81&quot;&lt;/span&gt;, &lt;span&gt;nil&lt;/span&gt;)&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;hello&lt;/span&gt;&lt;span&gt;(response http.ResponseWriter, request *http.Request)&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; io.WriteString(response, &lt;span&gt;&quot;hello world&quot;&lt;/span&gt;)&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这么简单，能与之一战的恐怕只有 Python 了吧，而且 Go 还能编译成可执行的二进制文件，你说牛啤不牛啤？&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.8075&quot; data-type=&quot;jpeg&quot; data-w=&quot;400&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_jpg/xacdaKuBM0QicPichPeoibAEibWwDtkBN3pxhaBzKLxXo8VkLyBFbDIsESrmC8OFFbpJicCiaHNKRJbU4W31X1BX0kgQ/640?wx_fmt=jpeg&quot;/&gt;&lt;/figure&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;Http Server 如何处理连接？&lt;/span&gt;&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们从这一行代码看起&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;http.ListenAndServe(&lt;span&gt;&quot;:81&quot;&lt;/span&gt;, &lt;span&gt;nil&lt;/span&gt;)&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;从命名来看，这个方法干了两件事，监听并且服务，从方法的单一职责上来说，我觉得不ok，一个方法怎么能干两件事？但这是大佬写的代码，就很合理。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;1.0466666666666666&quot; data-type=&quot;jpeg&quot; data-w=&quot;150&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_jpg/xacdaKuBM0QicPichPeoibAEibWwDtkBN3pxd4xU8zIJkDaTsbQByjrX411Spicd9KnbpzMod28L4ZdRrlgic0iahua5Q/640?wx_fmt=jpeg&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;第一个参数&lt;code&gt;Addr&lt;/code&gt;是要监听的地址和端口，第二个参数&lt;code&gt;Handler&lt;/code&gt;一般是&lt;code&gt;nil&lt;/code&gt;，它是真正的逻辑处理，但我们通常用第一行代码那样来注册处理器，这代码一看就感觉是把 path 映射到业务逻辑上，我们先大概了解，待会再来看它&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;http.HandleFunc(&lt;span&gt;&quot;/hello&quot;&lt;/span&gt;, hello)&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果了解过一点网络编程基础，就会知道操作系统提供了&lt;code&gt;bind&lt;/code&gt;、&lt;code&gt;listen&lt;/code&gt;、&lt;code&gt;accept&lt;/code&gt;这样的系统调用，我们只要按顺序发起调用，就能组合出一个 Server。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Go 也是利用这些系统调用，把他们都封装在了&lt;code&gt;ListenAndServe&lt;/code&gt;中。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6968449931412894&quot; data-type=&quot;png&quot; data-w=&quot;1458&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/xacdaKuBM0QicPichPeoibAEibWwDtkBN3pxyoc1ljnibWSG5SU38syl7aCwI1bWxNsuo0oG1aUMwE80sH8WyAdqib4g/640?wx_fmt=png&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;Listen&lt;/code&gt; 往下追究就是系统调用，所以我们重点看 &lt;code&gt;Serve&lt;/code&gt;：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1.0146627565982405&quot; data-type=&quot;png&quot; data-w=&quot;1364&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/xacdaKuBM0QicPichPeoibAEibWwDtkBN3pxI9ZuCaNMibLibicrt02fRNicssF3jL29kafKLhvT8T5ZCLIPOBrQrpKCTg/640?wx_fmt=png&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;把分支代码收起来，只看主干，发现是一个 for 循环里面在不停地 Accept，而这个 Accept 在没有连接时是阻塞的，当有连接时，起一个新的协程来处理。&lt;/p&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;Http Server 如何处理请求？&lt;/span&gt;&lt;/h1&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;一些前置工作&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;处理请求的一行代码是，可以看出是每个连接单开了一个协程处理：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;go&lt;/span&gt; c.serve(connCtx)&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里的 connCtx 代入了当前的 Server 对象：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;ctx := context.WithValue(baseCtx, ServerContextKey, srv)&lt;br/&gt;...&lt;br/&gt;connCtx := ctx&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;而且还提供了修改它的 hook 方法 &lt;code&gt;srv.ConnContext&lt;/code&gt;，可以在每次 Accept 时修改原始的 context&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;if&lt;/span&gt; cc := srv.ConnContext; cc != &lt;span&gt;nil&lt;/span&gt; {&lt;br/&gt; connCtx = cc(connCtx, rw)&lt;br/&gt; &lt;span&gt;if&lt;/span&gt; connCtx == &lt;span&gt;nil&lt;/span&gt; {&lt;br/&gt;  &lt;span&gt;panic&lt;/span&gt;(&lt;span&gt;&quot;ConnContext returned nil&quot;&lt;/span&gt;)&lt;br/&gt; }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;它的定义是：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;// ConnContext optionally specifies a function that modifies&lt;/span&gt;&lt;br/&gt;&lt;span&gt;// the context used for a new connection c. The provided ctx&lt;/span&gt;&lt;br/&gt;&lt;span&gt;// is derived from the base context and has a ServerContextKey&lt;/span&gt;&lt;br/&gt;&lt;span&gt;// value.&lt;/span&gt;&lt;br/&gt;ConnContext &lt;span&gt;&lt;span&gt;func&lt;/span&gt;&lt;span&gt;(ctx context.Context, c net.Conn)&lt;/span&gt; &lt;span&gt;context&lt;/span&gt;.&lt;span&gt;Context&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但是如果按照我开头给的代码，你是没法修改 &lt;code&gt;srv.ConnContext&lt;/code&gt; 的，可以改成这样来自定义：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; http.HandleFunc(&lt;span&gt;&quot;/hello&quot;&lt;/span&gt;, hello)&lt;br/&gt; server := http.Server{&lt;br/&gt;  Addr: &lt;span&gt;&quot;:81&quot;&lt;/span&gt;,&lt;br/&gt;&lt;span&gt;  ConnContext: &lt;span&gt;&lt;span&gt;func(ctx context.Context, c net.Conn)&lt;/span&gt; &lt;span&gt;context&lt;/span&gt;.&lt;span&gt;Context&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;   &lt;span&gt;return&lt;/span&gt; context.WithValue(ctx, &lt;span&gt;&quot;hello&quot;&lt;/span&gt;, &lt;span&gt;&quot;roshi&quot;&lt;/span&gt;)&lt;br/&gt;  },&lt;/span&gt;&lt;br/&gt; }&lt;br/&gt; server.ListenAndServe()&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;同样的 &lt;code&gt;c.setState&lt;/code&gt; 也提供了 hook，可采取如上的方法设置，在每次连接状态改变时执行 hook 方法：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;c.setState(c.rwc, StateNew, runHooks) &lt;span&gt;// before Serve can return&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;// ConnState specifies an optional callback function that is&lt;/span&gt;&lt;br/&gt;&lt;span&gt;// called when a client connection changes state. See the&lt;/span&gt;&lt;br/&gt;&lt;span&gt;// ConnState type and associated constants for details.&lt;/span&gt;&lt;br/&gt;ConnState &lt;span&gt;&lt;span&gt;func&lt;/span&gt;&lt;span&gt;(net.Conn, ConnState)&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;开始真正干活&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;为了能看清楚 Accept 后，serve 方法到底干了什么，我们再简化一下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;(c *conn)&lt;/span&gt; &lt;span&gt;serve&lt;/span&gt;&lt;span&gt;(ctx context.Context)&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; ...&lt;br/&gt; &lt;span&gt;for&lt;/span&gt; {&lt;br/&gt;  w, err := c.readRequest(ctx)&lt;br/&gt;  ...&lt;br/&gt;  serverHandler{c.server}.ServeHTTP(w, w.req)&lt;br/&gt;  ...&lt;br/&gt; }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;serve 也是一个大循环，循环里面主要是读取一个请求，然后将请求交给 Handler 处理。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;为什么是一个大循环呢？因为每个 serve 处理的是一个连接，一个连接可以有多次请求。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;读请求就显得比较枯燥乏味，按照Http协议，读出URL，header，body等信息。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里有个细节是在每次读取了一个请求后，还开了一个协程去读下一个请求，也算是做了优化吧。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;for&lt;/span&gt; {&lt;br/&gt; w, err := c.readRequest(ctx)&lt;br/&gt; ...&lt;br/&gt;&lt;br/&gt; &lt;span&gt;if&lt;/span&gt; requestBodyRemains(req.Body) {&lt;br/&gt;  registerOnHitEOF(req.Body, w.conn.r.startBackgroundRead)&lt;br/&gt; } &lt;span&gt;else&lt;/span&gt; {&lt;br/&gt;&lt;span&gt;  w.conn.r.startBackgroundRead()&lt;br/&gt;&lt;/span&gt; }&lt;br/&gt; ...&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;请求如何路由？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当读取到一个请求后，便进入这一行代码：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;serverHandler{c.server}.ServeHTTP(w, w.req)&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;ServeHTTP 找到我们注册的 Handler 去处理，如果请求的URI 是 &lt;code&gt;*&lt;/code&gt;或请求 Method 是 &lt;code&gt;OPTIONS&lt;/code&gt;，则使用globalOptionsHandler，也就是说这类请求不需要我们手动处理，直接就返回了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;对于我们注册的 Handler 也需要去寻找路由，这个路由的规则还是比较简单，主要由如下三条：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;如果注册了带 host 的路由，则按 host + path 去寻找，如果没注册带 host 的路由，则按 path 寻找&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;路由规则匹配以完全匹配优先，如果注册的路由规则最后一个字符是&lt;code&gt;/&lt;/code&gt;，则除了完全匹配外，还会以前缀查找&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;举几个例子来理解一下：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;注册路由为&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;http.HandleFunc(&lt;span&gt;&quot;/hello&quot;&lt;/span&gt;, hello)&lt;br/&gt;http.HandleFunc(&lt;span&gt;&quot;127.0.0.1/hello&quot;&lt;/span&gt;, hello2)&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;此时如果执行&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;curl &lt;span&gt;&#x27;http://127.0.0.1:81/hello&#x27;&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;则会匹配到 hello2，但如果执行&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;curl &lt;span&gt;&#x27;http://localhost:81/hello&#x27;&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;就匹配的是 hello&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果注册路由为&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;http.HandleFunc(&lt;span&gt;&quot;/hello&quot;&lt;/span&gt;, hello)&lt;br/&gt;http.HandleFunc(&lt;span&gt;&quot;127.0.0.1/hello/&quot;&lt;/span&gt;, hello2)&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;注意第二个最后还有个&lt;code&gt;/&lt;/code&gt;，此时如果执行&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;curl &lt;span&gt;&#x27;http://127.0.0.1:81/hello/roshi&#x27;&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;也能匹配到 hello2，怎么样，是不是理解了？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;找到路由之后就直接调用我们开头注册的方法，如果我们往 Response 中写入数据，就能返回给客户端，这样一个请求就处理完成了。&lt;/p&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;总结&lt;/span&gt;&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;最后我们回忆下 Go Http Server 的要点：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;用 Go 起一个 Http Server 非常简单&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Go Http Server 本质是一个大循环，每当有一个新连接时，会起一个新的协程来处理&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;每个连接的处理也是一个大循环，这个循环里做了读取请求、寻找路由、执行逻辑三件大事&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.8255613126079447&quot; data-type=&quot;png&quot; data-w=&quot;579&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/xacdaKuBM0QicPichPeoibAEibWwDtkBN3px7YxysicCAjmLyd4ykKwm8ESDJL2qkb5iaHAbJyRuUYg2dkZfoOv4rB7g/640?wx_fmt=png&quot;/&gt;&lt;/figure&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;福利时刻&lt;/span&gt;&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;感谢能抽空看到这里，新的一年准备了3本《Go语言从入门到项目实战》送给大家，参与方式是加我微信&lt;code&gt;MrRoshi&lt;/code&gt;，参加朋友圈点赞送书活动即可。&lt;/p&gt;&lt;p&gt;&lt;mpcps class=&quot;js_editor_new_cps&quot; data-templateid=&quot;list&quot; data-traceid=&quot;3e59a237-9b50-4189-aff2-44f805fb4c42&quot; data-goodssouce=&quot;1&quot; data-pid=&quot;101_13329955&quot; data-appuin=&quot;3296160406&quot; data-buffer=&quot;{&amp;quot;category_id&amp;quot;:10,&amp;quot;pid&amp;quot;:&amp;quot;101_13329955&amp;quot;,&amp;quot;biz_uin&amp;quot;:&amp;quot;3296160406&amp;quot;,&amp;quot;trace_id&amp;quot;:&amp;quot;3e59a237-9b50-4189-aff2-44f805fb4c42&amp;quot;,&amp;quot;sku_id&amp;quot;:&amp;quot;101_13329955&amp;quot;,&amp;quot;source_id&amp;quot;:2,&amp;quot;source_name&amp;quot;:&amp;quot;京东&amp;quot;,&amp;quot;audit_state&amp;quot;:1,&amp;quot;main_img&amp;quot;:&amp;quot;https://pcm-img.zhls.qq.com/productcenter-13651fb5--1018824-7367685220822286616/62026160010122022/38b442ea0c38631a8fc025925ef15cb5.jpg&amp;quot;,&amp;quot;product_name&amp;quot;:&amp;quot;Go语言从入门到项目实战（视频版）&amp;quot;,&amp;quot;current_price&amp;quot;:10800,&amp;quot;first_category_id&amp;quot;:&amp;quot;10&amp;quot;,&amp;quot;product_label_name_list&amp;quot;:[&amp;quot;京东配送&amp;quot;],&amp;quot;select_tag_name_list&amp;quot;:[],&amp;quot;templateId&amp;quot;:&amp;quot;card&amp;quot;,&amp;quot;appuin&amp;quot;:&amp;quot;3296160406&amp;quot;,&amp;quot;isNewCpsKOL&amp;quot;:1}&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果你能&lt;code&gt;点赞&lt;/code&gt;、&lt;code&gt;在看&lt;/code&gt;、&lt;code&gt;分享&lt;/code&gt;，我会更加感激不尽~&lt;/p&gt;&lt;hr data-tool=&quot;mdnice编辑器&quot;/&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;搜索关注微信公众号&quot;捉虫大师&quot;，后端技术分享，架构设计、性能优化、源码阅读、问题排查、踩坑实践&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;加我微信&lt;code&gt;MrRoshi&lt;/code&gt;拉你入群，群里各路技术大佬带你飞&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/blockquote&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>aec3324da0b6ac4b9d3894687100a623</guid>
<title>如何用Go快速实现规则引擎</title>
<link>https://toutiao.io/k/4eubwce</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section&gt;&lt;p&gt;&lt;span&gt;作者：wynnliu， 腾讯IEG增长中台 后台开发工程师&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;出师之名&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;提到规则引擎，大部分人都会先想到&lt;/span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;DSL(Domain Specific Language)&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;，进而联想令人生畏的&lt;/span&gt;&lt;strong&gt;&lt;span&gt;编译原理、递归下降、LL或LR&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;。但规则引擎有大有小，它们在不同场景的存在不一样，并不一定都要这么复杂。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;比如在一个小型支付系统的简单风控场景里，产品同学想设置一些规则，避免用户的银行卡被盗刷或者商户被薅羊毛（仅为示例，并不代表现实中也是应用了同样策略）：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;为了快速实现需求，我们开发一个单独的规则类或者库，类里面有不同规则判断函数。规则不断增加，规则函数就不断扩展，这个膨胀的规则类库就是一个微小的规则引擎。虽然在业务调用的地方会有很多switch或者if...else..，但这个微小的规则引擎并不需要引入DSL，一样能好好工作。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;而在另外一些业务系统，比如贷款系统，同样是风控场景，产品同学也会设置一些规则做不同的金额审批决策（仅为示例，并不代表现实中也是应用了同样策略）：&lt;/span&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;征信评分达到650，申请金额2000元以下可以直接审批&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;征信评分达到650，申请金额在5000以下，如果月均消费达到2000块可以直接审批&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;征信评分在550~600之间，申请金额在5000以下的三四线城市用户，如果月均消费达到1000块还需要其他消费评估，如果月收入未达到1万需要工资流水证明&lt;br/&gt;&lt;/span&gt;......&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;span&gt;在这些规则未增多之前，我们发现单单写规则类库，业务方通过调用不同函数判断，就已经痛不欲生。这些风控规则相比上文来说，涉及的用户属性多，判断条件复杂，而且还有不同的优先级。如果没有更好的规则抽象，代码复杂度只会越来越高，这时就需要设计一套DSL来满足更多的规则判断。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;所以，在我们真正要实现一个规则引擎之前，下定决心设计DSL与编译原理拉扯之前，我们首先看简单的规则类库是否就已满足需求。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;h2&gt;&lt;span&gt;需求背景&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;&lt;span&gt;Gopass是一个API网关，作为一个网关，网关必不可少的能力是路由转发，精细化路由更是高频需求。业务需要根据不同需求场景做不同的路由配置，比如灰度发布、A/B 测试、限流、负载均衡等。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Gopass现有的转发规则只能基于请求Method和URL(Host/Path/Query)作简单配置，欠缺根据请求Header、Cookie、CIP(Client IP)/VIP等更多请求属性配置，与及这些属性规则的组合配置，比如业务需要配置API的读写分离，并且灰度测试，就需要配置请求Method和请求Header这样的并集规则。&lt;/span&gt;&lt;/p&gt;&lt;h2&gt;&lt;span&gt;Json实现&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;&lt;span&gt;我最开始没有往DSL的方向想，写几个像下面的简单的规则函数，用json格式定义规则，再用Go的反射库解析json，三下五除二就完成了规则判断。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;不同的规则函数&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;// IRule&lt;/span&gt;&lt;br/&gt;&lt;span&gt;type&lt;/span&gt; IRule &lt;span&gt;interface&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;Match&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;req &lt;span&gt;*&lt;/span&gt;http&lt;span&gt;.&lt;/span&gt;Request&lt;span&gt;)&lt;/span&gt; &lt;span&gt;bool&lt;/span&gt;&lt;br/&gt;&lt;span&gt;}&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// HeaderMatch 匹配header&lt;/span&gt;&lt;br/&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;HeaderMatch&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;key&lt;span&gt;,&lt;/span&gt; value &lt;span&gt;string&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;bool&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;...&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;br/&gt;&lt;span&gt;}&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// CookieMatch 匹配Cookie&lt;/span&gt;&lt;br/&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;CookieMatch&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;key&lt;span&gt;,&lt;/span&gt; value &lt;span&gt;string&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;bool&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;...&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;br/&gt;&lt;span&gt;}&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;...&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;规则定义&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;{&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&quot;op&quot;&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt;&quot;AND&quot;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&quot;matcher&quot;&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt;[&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;&quot;header&quot;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;&quot;cookie&quot;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;]&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&quot;header&quot;&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt;{&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;&quot;key&quot;&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt;&quot;X-APP-ID&quot;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;&quot;value&quot;&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt;&quot;Ves&quot;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;}&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&quot;cookie&quot;&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt;{&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;&quot;name&quot;&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt;&quot;feature&quot;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;&quot;value&quot;&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt;&quot;dev/wynnliu/qualify-rule&quot;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;}&lt;/span&gt;&lt;br/&gt;&lt;span&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;规则解析框架(非反射库版)：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;// 遍历判断规则&lt;/span&gt;&lt;br/&gt;&lt;span&gt;for&lt;/span&gt; &lt;span&gt;_&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; matcher &lt;span&gt;:=&lt;/span&gt; &lt;span&gt;range&lt;/span&gt; matchers &lt;span&gt;{&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;var&lt;/span&gt; m &lt;span&gt;map&lt;/span&gt;&lt;span&gt;[&lt;/span&gt;&lt;span&gt;string&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;&lt;span&gt;interface&lt;/span&gt;&lt;span&gt;{&lt;/span&gt;&lt;span&gt;}&lt;/span&gt;&lt;br/&gt;    err &lt;span&gt;:=&lt;/span&gt; json&lt;span&gt;.&lt;/span&gt;&lt;span&gt;Unmarshal&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;[&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;&lt;span&gt;byte&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;data&lt;span&gt;[&lt;/span&gt;&lt;span&gt;&quot;matcher&quot;&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;&amp;amp;&lt;/span&gt;m&lt;span&gt;)&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; err &lt;span&gt;!=&lt;/span&gt; &lt;span&gt;nil&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;&lt;br/&gt;      log&lt;span&gt;.&lt;/span&gt;&lt;span&gt;Fatal&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;err&lt;span&gt;)&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;}&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;switch&lt;/span&gt; matcher &lt;span&gt;{&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;case&lt;/span&gt; &lt;span&gt;&quot;header&quot;&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;...&lt;/span&gt;&lt;br/&gt;       result&lt;span&gt;[&lt;/span&gt;matcher&lt;span&gt;]&lt;/span&gt; &lt;span&gt;=&lt;/span&gt; &lt;span&gt;HeaderMatch&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;rule&lt;span&gt;.&lt;/span&gt;key&lt;span&gt;,&lt;/span&gt; rule&lt;span&gt;.&lt;/span&gt;Vaule&lt;span&gt;)&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;case&lt;/span&gt; &lt;span&gt;&quot;coolkie&quot;&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;...&lt;/span&gt;&lt;br/&gt;       result&lt;span&gt;[&lt;/span&gt;matcher&lt;span&gt;]&lt;/span&gt; &lt;span&gt;=&lt;/span&gt; &lt;span&gt;CookieMatch&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;rule&lt;span&gt;.&lt;/span&gt;name&lt;span&gt;,&lt;/span&gt; rule&lt;span&gt;.&lt;/span&gt;Vaule&lt;span&gt;)&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;}&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;...&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;}&lt;/span&gt;&lt;br/&gt;&lt;span&gt;...&lt;/span&gt;&lt;br/&gt;&lt;span&gt;// 综合计算规则结果&lt;/span&gt;&lt;br/&gt;&lt;span&gt;switch&lt;/span&gt; op &lt;span&gt;{&lt;/span&gt;&lt;br/&gt;&lt;span&gt;case&lt;/span&gt; &lt;span&gt;&quot;AND&quot;&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;...&lt;/span&gt;&lt;br/&gt;&lt;span&gt;case&lt;/span&gt; &lt;span&gt;&quot;OR&quot;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;...&lt;/span&gt;&lt;br/&gt;&lt;span&gt;}&lt;/span&gt;&lt;br/&gt;&lt;span&gt;...&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;span&gt;上面是一个常见的二元表达式规则，从规则定义到规则解析可以看出，用Json的方式实现非常方便，已经满足简单的规则场景。不好的地方就是解析的代码太灵活，一条龙的switch case，如果加入更多逻辑，复杂度就会上升，维护性也只会越来越差。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;比如，一开始的规则条件只有等值匹配，接着增加范围匹配，非匹配，正则匹配等，后面再在这些基础上加入规则优先级，就得需要引入更多的json定义，规则解析框架也要相应地覆盖更多的抽象维度。&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;那有没有抽象度更高、实现也不复杂的解析实现方式呢？就是说，有没有比Json方式更好地表达这些规则的存在？&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;答案肯定是有的，不然怎么写下去🐶。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;如果仔细分析上面的规则，可以发现这些规则经过一波计算后只需得到一个布尔值，与其他算术表达式、关系表达式不同，这些规则都是&lt;/span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;布尔表达式&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;网上了解到，国内知名Go领域专家曹大(Xargin )在&lt;/span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;基于 Go 的内置 Parser 打造轻量级规则引擎&lt;/span&gt;&lt;span&gt;一文中提到：&lt;/span&gt;&lt;span&gt;&lt;span&gt;Go的ast语法树可以完美表达布尔表达式，使用 Go 的内置 parser 库可以完成一个基本规则引擎的框架。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;于是，我开始尝试使用Go自带的ast库及parser库完成转发规则的解析。&lt;/span&gt;&lt;/p&gt;&lt;h2&gt;&lt;strong&gt;AST实现&lt;/strong&gt;&lt;/h2&gt;&lt;h3&gt;&lt;span&gt;Go的编译过程&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;&lt;span&gt;Go的ast库和parser库都是Go编译过程中的工具库，Go的编译过程跟大部分高级语言的编译过程一样，&lt;/span&gt;&lt;strong&gt;分为6步：词法分析、语法分析、语义分析、中间码生成、代码优化和机器码生成。&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;引用《程序员的自我修养》里面的图，就是下面这一串流程：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5035971223021583&quot; data-type=&quot;png&quot; data-w=&quot;1112&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/G9mz0qib2srCvicwBpmUCrceZOnX2FsgnUg3dNianyD1COHkohSP6bI8LOeQCdscDDSc6pVQyunSYn9XVZgZQpHeg/640?wx_fmt=png&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;每步的输入输出，具体做的事情总体如下表：&lt;/strong&gt;&lt;/p&gt;&lt;figure&gt;&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;&lt;span&gt;输入&lt;/span&gt;&lt;/th&gt;&lt;th&gt;&lt;span&gt;步骤&lt;/span&gt;&lt;/th&gt;&lt;th&gt;&lt;span&gt;输出&lt;/span&gt;&lt;/th&gt;&lt;th&gt;&lt;span&gt;说明&lt;/span&gt;&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;&lt;span&gt;源代码&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span&gt;词法分析&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span&gt;Token&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span&gt;go 文件被输入到扫描(Scanner)，它使用一种类似于有限状态机的算法，将源代码的字符系列分割成一系列的记号(Token)&lt;/span&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;span&gt;Token序列&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span&gt;语法分析&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span&gt;AST&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span&gt;将 Token 转化为AST(抽象语法树)。&lt;/span&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;span&gt;AST&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span&gt;语义分析&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span&gt;正确的AST&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span&gt;对上一步的AST进行类型检查(名称检查、类型推断等)。&lt;/span&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;span&gt;正确的AST&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span&gt;中间码生成&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span&gt;SSA 特性的中间码(IR)&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span&gt;&lt;span&gt;中间码的作用之一是适配不同操作系统，兼容不同平台。&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;静态单赋值（Static Single Assignment、SSA）是中间代码的特性，如果中间代码具有静态单赋值的特性，那么每个变量就只会被赋值一次。&lt;/span&gt;&lt;/span&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;span&gt;SSA 特性的中间码(IR)&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span&gt;代码优化&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span&gt;优化后的中间码&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;br/&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;span&gt;优化后的中间码&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span&gt;机器码生成&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span&gt;汇编代码（Plan9）&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span&gt;对不同系统指令集、CPU架构翻译成不同的机器码。&lt;/span&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/figure&gt;&lt;p&gt;&lt;strong&gt;我们要拿来做规则引擎的就是前面两步的产物：词法分析得到的Token和语法分析的AST。&lt;/strong&gt;&lt;/p&gt;&lt;h3&gt;&lt;strong&gt;Token(记号)&lt;/strong&gt;&lt;/h3&gt;&lt;p&gt;&lt;span&gt;Token是高级语言中最小的词法单元，Go主要有标识符、关键字、运算符和分隔符等Token，更多的token定义参考&lt;/span&gt;&lt;span&gt;&lt;span&gt;token文件&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;比如我们扫描`&lt;/span&gt;&lt;span&gt;&lt;code&gt;println(”Hello World”)`&lt;/code&gt;&lt;span&gt;，得到以下token：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;扫描代码：&lt;/span&gt;&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;package&lt;/span&gt; main&lt;br/&gt;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;&quot;fmt&quot;&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;&quot;go/scanner&quot;&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;&quot;go/token&quot;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;)&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;var&lt;/span&gt; src &lt;span&gt;=&lt;/span&gt; &lt;span&gt;[&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;&lt;span&gt;byte&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;`println(&quot;Hello World!&quot;)`&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;var&lt;/span&gt; fset &lt;span&gt;=&lt;/span&gt; token&lt;span&gt;.&lt;/span&gt;&lt;span&gt;NewFileSet&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;var&lt;/span&gt; file &lt;span&gt;=&lt;/span&gt; fset&lt;span&gt;.&lt;/span&gt;&lt;span&gt;AddFile&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;&quot;hello.go&quot;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; fset&lt;span&gt;.&lt;/span&gt;&lt;span&gt;Base&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;len&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;src&lt;span&gt;)&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;var&lt;/span&gt; s scanner&lt;span&gt;.&lt;/span&gt;Scanner&lt;br/&gt;  s&lt;span&gt;.&lt;/span&gt;&lt;span&gt;Init&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;file&lt;span&gt;,&lt;/span&gt; src&lt;span&gt;,&lt;/span&gt; &lt;span&gt;nil&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; scanner&lt;span&gt;.&lt;/span&gt;ScanComments&lt;span&gt;)&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;for&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;&lt;br/&gt;    pos&lt;span&gt;,&lt;/span&gt; tok&lt;span&gt;,&lt;/span&gt; lit &lt;span&gt;:=&lt;/span&gt; s&lt;span&gt;.&lt;/span&gt;&lt;span&gt;Scan&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; tok &lt;span&gt;==&lt;/span&gt; token&lt;span&gt;.&lt;/span&gt;EOF &lt;span&gt;{&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;break&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;}&lt;/span&gt;&lt;br/&gt;    fmt&lt;span&gt;.&lt;/span&gt;&lt;span&gt;Printf&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;&quot;%s\\t%s\\t%q\\n&quot;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; fset&lt;span&gt;.&lt;/span&gt;&lt;span&gt;Position&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;pos&lt;span&gt;)&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; tok&lt;span&gt;,&lt;/span&gt; lit&lt;span&gt;)&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;}&lt;/span&gt;&lt;br/&gt;&lt;span&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;span&gt;扫描结果：&lt;/span&gt;&lt;/p&gt;&lt;pre&gt;&lt;code&gt;hello&lt;span&gt;.&lt;/span&gt;&lt;span&gt;go&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;  IDENT &lt;span&gt;&quot;println&quot;&lt;/span&gt;&lt;br/&gt;hello&lt;span&gt;.&lt;/span&gt;&lt;span&gt;go&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt;8&lt;/span&gt;  &lt;span&gt;(&lt;/span&gt; &lt;span&gt;&quot;&quot;&lt;/span&gt;&lt;br/&gt;hello&lt;span&gt;.&lt;/span&gt;&lt;span&gt;go&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt;9&lt;/span&gt;  STRING  &lt;span&gt;&quot;\\&quot;&lt;/span&gt;Hello World&lt;span&gt;!&lt;/span&gt;\\&lt;span&gt;&quot;&quot;&lt;/span&gt;&lt;br/&gt;hello&lt;span&gt;.&lt;/span&gt;&lt;span&gt;go&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt;23&lt;/span&gt; &lt;span&gt;)&lt;/span&gt; &lt;span&gt;&quot;&quot;&lt;/span&gt;&lt;br/&gt;hello&lt;span&gt;.&lt;/span&gt;&lt;span&gt;go&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt;24&lt;/span&gt; &lt;span&gt;;&lt;/span&gt; &lt;span&gt;&quot;\\n&quot;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;span&gt;其中`&lt;/span&gt;&lt;span&gt;&lt;code&gt;println`&lt;/code&gt;&lt;span&gt;是标识符(IDENT)Token， `&lt;/span&gt;&lt;code&gt;Hello World`&lt;/code&gt;&lt;span&gt;则是字符串Token。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;h3&gt;&lt;strong&gt;AST(抽象语法树)&lt;/strong&gt;&lt;/h3&gt;&lt;p&gt;&lt;span&gt;有了Scanner扫描出来的Token序列，到语法分析这一步，就可以进一步构造AST，但如果看具体的AST，会发现AST中不止有Token，比如同样是这段`&lt;/span&gt;&lt;span&gt;&lt;code&gt;println(”Hello World”)`&lt;/code&gt;&lt;span&gt;，它的AST如下：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;解析代码：&lt;/span&gt;&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;package&lt;/span&gt; main&lt;br/&gt;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;&quot;go/ast&quot;&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;&quot;go/parser&quot;&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;&quot;go/token&quot;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;)&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;&lt;br/&gt;  src &lt;span&gt;:=&lt;/span&gt; &lt;span&gt;`&lt;br/&gt;package main&lt;br/&gt;func main() {&lt;br/&gt;  println(&quot;Hello, World!&quot;)&lt;br/&gt;}&lt;br/&gt;`&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;// Create the AST by parsing src.&lt;/span&gt;&lt;br/&gt;  fset &lt;span&gt;:=&lt;/span&gt; token&lt;span&gt;.&lt;/span&gt;&lt;span&gt;NewFileSet&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;// positions are relative to fset&lt;/span&gt;&lt;br/&gt;  f&lt;span&gt;,&lt;/span&gt; err &lt;span&gt;:=&lt;/span&gt; parser&lt;span&gt;.&lt;/span&gt;&lt;span&gt;ParseFile&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;fset&lt;span&gt;,&lt;/span&gt; &lt;span&gt;&quot;&quot;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; src&lt;span&gt;,&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;if&lt;/span&gt; err &lt;span&gt;!=&lt;/span&gt; &lt;span&gt;nil&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;panic&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;err&lt;span&gt;)&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;}&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;// Print the AST.&lt;/span&gt;&lt;br/&gt;  ast&lt;span&gt;.&lt;/span&gt;&lt;span&gt;Print&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;fset&lt;span&gt;,&lt;/span&gt; f&lt;span&gt;)&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;}&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt; &lt;span/&gt;&lt;span&gt;解析结果：&lt;/span&gt;&lt;/p&gt;&lt;pre&gt;&lt;code&gt;     &lt;span&gt;0&lt;/span&gt;  &lt;span&gt;*&lt;/span&gt;ast&lt;span&gt;.&lt;/span&gt;File &lt;span&gt;{&lt;/span&gt;&lt;br/&gt;     &lt;span&gt;1&lt;/span&gt;  &lt;span&gt;.&lt;/span&gt;  Package&lt;span&gt;:&lt;/span&gt; &lt;span&gt;2&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;br/&gt;     &lt;span&gt;2&lt;/span&gt;  &lt;span&gt;.&lt;/span&gt;  Name&lt;span&gt;:&lt;/span&gt; &lt;span&gt;*&lt;/span&gt;ast&lt;span&gt;.&lt;/span&gt;Ident &lt;span&gt;{&lt;/span&gt;&lt;br/&gt;     &lt;span&gt;3&lt;/span&gt;  &lt;span&gt;.&lt;/span&gt;  &lt;span&gt;.&lt;/span&gt;  NamePos&lt;span&gt;:&lt;/span&gt; &lt;span&gt;2&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt;9&lt;/span&gt;&lt;br/&gt;     &lt;span&gt;4&lt;/span&gt;  &lt;span&gt;.&lt;/span&gt;  &lt;span&gt;.&lt;/span&gt;  Name&lt;span&gt;:&lt;/span&gt; &lt;span&gt;&quot;main&quot;&lt;/span&gt;&lt;br/&gt;     &lt;span&gt;5&lt;/span&gt;  &lt;span&gt;.&lt;/span&gt;  &lt;span&gt;}&lt;/span&gt;&lt;br/&gt;     &lt;span&gt;6&lt;/span&gt;  &lt;span&gt;.&lt;/span&gt;  Decls&lt;span&gt;:&lt;/span&gt; &lt;span&gt;[&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;ast&lt;span&gt;.&lt;/span&gt;Decl &lt;span&gt;(&lt;/span&gt;&lt;span&gt;len&lt;/span&gt; &lt;span&gt;=&lt;/span&gt; &lt;span&gt;1&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;&lt;br/&gt;     &lt;span&gt;7&lt;/span&gt;  &lt;span&gt;.&lt;/span&gt;  &lt;span&gt;.&lt;/span&gt;  &lt;span&gt;0&lt;/span&gt;&lt;span&gt;:&lt;/span&gt; &lt;span&gt;*&lt;/span&gt;ast&lt;span&gt;.&lt;/span&gt;FuncDecl &lt;span&gt;{&lt;/span&gt;&lt;br/&gt;     &lt;span&gt;8&lt;/span&gt;  &lt;span&gt;.&lt;/span&gt;  &lt;span&gt;.&lt;/span&gt;  &lt;span&gt;.&lt;/span&gt;  Name&lt;span&gt;:&lt;/span&gt; &lt;span&gt;*&lt;/span&gt;ast&lt;span&gt;.&lt;/span&gt;Ident &lt;span&gt;{&lt;/span&gt;&lt;br/&gt;     &lt;span&gt;9&lt;/span&gt;  &lt;span&gt;.&lt;/span&gt;  &lt;span&gt;.&lt;/span&gt;  &lt;span&gt;.&lt;/span&gt;  &lt;span&gt;.&lt;/span&gt;  NamePos&lt;span&gt;:&lt;/span&gt; &lt;span&gt;3&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt;6&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;10&lt;/span&gt;  &lt;span&gt;.&lt;/span&gt;  &lt;span&gt;.&lt;/span&gt;  &lt;span&gt;.&lt;/span&gt;  &lt;span&gt;.&lt;/span&gt;  Name&lt;span&gt;:&lt;/span&gt; &lt;span&gt;&quot;main&quot;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;11&lt;/span&gt;  &lt;span&gt;.&lt;/span&gt;  &lt;span&gt;.&lt;/span&gt;  &lt;span&gt;.&lt;/span&gt;  &lt;span&gt;.&lt;/span&gt;  Obj&lt;span&gt;:&lt;/span&gt; &lt;span&gt;*&lt;/span&gt;ast&lt;span&gt;.&lt;/span&gt;Object &lt;span&gt;{&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;12&lt;/span&gt;  &lt;span&gt;.&lt;/span&gt;  &lt;span&gt;.&lt;/span&gt;  &lt;span&gt;.&lt;/span&gt;  &lt;span&gt;.&lt;/span&gt;  &lt;span&gt;.&lt;/span&gt;  Kind&lt;span&gt;:&lt;/span&gt; &lt;span&gt;func&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;13&lt;/span&gt;  &lt;span&gt;.&lt;/span&gt;  &lt;span&gt;.&lt;/span&gt;  &lt;span&gt;.&lt;/span&gt;  &lt;span&gt;.&lt;/span&gt;  &lt;span&gt;.&lt;/span&gt;  Name&lt;span&gt;:&lt;/span&gt; &lt;span&gt;&quot;main&quot;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;14&lt;/span&gt;  &lt;span&gt;.&lt;/span&gt;  &lt;span&gt;.&lt;/span&gt;  &lt;span&gt;.&lt;/span&gt;  &lt;span&gt;.&lt;/span&gt;  &lt;span&gt;.&lt;/span&gt;  Decl&lt;span&gt;:&lt;/span&gt; &lt;span&gt;*&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;obj @ &lt;span&gt;7&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;15&lt;/span&gt;  &lt;span&gt;.&lt;/span&gt;  &lt;span&gt;.&lt;/span&gt;  &lt;span&gt;.&lt;/span&gt;  &lt;span&gt;.&lt;/span&gt;  &lt;span&gt;}&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;16&lt;/span&gt;  &lt;span&gt;.&lt;/span&gt;  &lt;span&gt;.&lt;/span&gt;  &lt;span&gt;.&lt;/span&gt;  &lt;span&gt;}&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;17&lt;/span&gt;  &lt;span&gt;.&lt;/span&gt;  &lt;span&gt;.&lt;/span&gt;  &lt;span&gt;.&lt;/span&gt;  Type&lt;span&gt;:&lt;/span&gt; &lt;span&gt;*&lt;/span&gt;ast&lt;span&gt;.&lt;/span&gt;FuncType &lt;span&gt;{&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;18&lt;/span&gt;  &lt;span&gt;.&lt;/span&gt;  &lt;span&gt;.&lt;/span&gt;  &lt;span&gt;.&lt;/span&gt;  &lt;span&gt;.&lt;/span&gt;  Func&lt;span&gt;:&lt;/span&gt; &lt;span&gt;3&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;19&lt;/span&gt;  &lt;span&gt;.&lt;/span&gt;  &lt;span&gt;.&lt;/span&gt;  &lt;span&gt;.&lt;/span&gt;  &lt;span&gt;.&lt;/span&gt;  Params&lt;span&gt;:&lt;/span&gt; &lt;span&gt;*&lt;/span&gt;ast&lt;span&gt;.&lt;/span&gt;FieldList &lt;span&gt;{&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;20&lt;/span&gt;  &lt;span&gt;.&lt;/span&gt;  &lt;span&gt;.&lt;/span&gt;  &lt;span&gt;.&lt;/span&gt;  &lt;span&gt;.&lt;/span&gt;  &lt;span&gt;.&lt;/span&gt;  Opening&lt;span&gt;:&lt;/span&gt; &lt;span&gt;3&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;21&lt;/span&gt;  &lt;span&gt;.&lt;/span&gt;  &lt;span&gt;.&lt;/span&gt;  &lt;span&gt;.&lt;/span&gt;  &lt;span&gt;.&lt;/span&gt;  &lt;span&gt;.&lt;/span&gt;  Closing&lt;span&gt;:&lt;/span&gt; &lt;span&gt;3&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;22&lt;/span&gt;  &lt;span&gt;.&lt;/span&gt;  &lt;span&gt;.&lt;/span&gt;  &lt;span&gt;.&lt;/span&gt;  &lt;span&gt;.&lt;/span&gt;  &lt;span&gt;}&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;23&lt;/span&gt;  &lt;span&gt;.&lt;/span&gt;  &lt;span&gt;.&lt;/span&gt;  &lt;span&gt;.&lt;/span&gt;  &lt;span&gt;}&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;24&lt;/span&gt;  &lt;span&gt;.&lt;/span&gt;  &lt;span&gt;.&lt;/span&gt;  &lt;span&gt;.&lt;/span&gt;  Body&lt;span&gt;:&lt;/span&gt; &lt;span&gt;*&lt;/span&gt;ast&lt;span&gt;.&lt;/span&gt;BlockStmt &lt;span&gt;{&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;25&lt;/span&gt;  &lt;span&gt;.&lt;/span&gt;  &lt;span&gt;.&lt;/span&gt;  &lt;span&gt;.&lt;/span&gt;  &lt;span&gt;.&lt;/span&gt;  Lbrace&lt;span&gt;:&lt;/span&gt; &lt;span&gt;3&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;26&lt;/span&gt;  &lt;span&gt;.&lt;/span&gt;  &lt;span&gt;.&lt;/span&gt;  &lt;span&gt;.&lt;/span&gt;  &lt;span&gt;.&lt;/span&gt;  List&lt;span&gt;:&lt;/span&gt; &lt;span&gt;[&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;ast&lt;span&gt;.&lt;/span&gt;Stmt &lt;span&gt;(&lt;/span&gt;&lt;span&gt;len&lt;/span&gt; &lt;span&gt;=&lt;/span&gt; &lt;span&gt;1&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;27&lt;/span&gt;  &lt;span&gt;.&lt;/span&gt;  &lt;span&gt;.&lt;/span&gt;  &lt;span&gt;.&lt;/span&gt;  &lt;span&gt;.&lt;/span&gt;  &lt;span&gt;.&lt;/span&gt;  &lt;span&gt;0&lt;/span&gt;&lt;span&gt;:&lt;/span&gt; &lt;span&gt;*&lt;/span&gt;ast&lt;span&gt;.&lt;/span&gt;ExprStmt &lt;span&gt;{&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;28&lt;/span&gt;  &lt;span&gt;.&lt;/span&gt;  &lt;span&gt;.&lt;/span&gt;  &lt;span&gt;.&lt;/span&gt;  &lt;span&gt;.&lt;/span&gt;  &lt;span&gt;.&lt;/span&gt;  &lt;span&gt;.&lt;/span&gt;  X&lt;span&gt;:&lt;/span&gt; &lt;span&gt;*&lt;/span&gt;ast&lt;span&gt;.&lt;/span&gt;CallExpr &lt;span&gt;{&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;29&lt;/span&gt;  &lt;span&gt;.&lt;/span&gt;  &lt;span&gt;.&lt;/span&gt;  &lt;span&gt;.&lt;/span&gt;  &lt;span&gt;.&lt;/span&gt;  &lt;span&gt;.&lt;/span&gt;  &lt;span&gt;.&lt;/span&gt;  &lt;span&gt;.&lt;/span&gt;  Fun&lt;span&gt;:&lt;/span&gt; &lt;span&gt;*&lt;/span&gt;ast&lt;span&gt;.&lt;/span&gt;Ident &lt;span&gt;{&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;30&lt;/span&gt;  &lt;span&gt;.&lt;/span&gt;  &lt;span&gt;.&lt;/span&gt;  &lt;span&gt;.&lt;/span&gt;  &lt;span&gt;.&lt;/span&gt;  &lt;span&gt;.&lt;/span&gt;  &lt;span&gt;.&lt;/span&gt;  &lt;span&gt;.&lt;/span&gt;  &lt;span&gt;.&lt;/span&gt;  NamePos&lt;span&gt;:&lt;/span&gt; &lt;span&gt;4&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;31&lt;/span&gt;  &lt;span&gt;.&lt;/span&gt;  &lt;span&gt;.&lt;/span&gt;  &lt;span&gt;.&lt;/span&gt;  &lt;span&gt;.&lt;/span&gt;  &lt;span&gt;.&lt;/span&gt;  &lt;span&gt;.&lt;/span&gt;  &lt;span&gt;.&lt;/span&gt;  &lt;span&gt;.&lt;/span&gt;  Name&lt;span&gt;:&lt;/span&gt; &lt;span&gt;&quot;println&quot;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;32&lt;/span&gt;  &lt;span&gt;.&lt;/span&gt;  &lt;span&gt;.&lt;/span&gt;  &lt;span&gt;.&lt;/span&gt;  &lt;span&gt;.&lt;/span&gt;  &lt;span&gt;.&lt;/span&gt;  &lt;span&gt;.&lt;/span&gt;  &lt;span&gt;.&lt;/span&gt;  &lt;span&gt;}&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;33&lt;/span&gt;  &lt;span&gt;.&lt;/span&gt;  &lt;span&gt;.&lt;/span&gt;  &lt;span&gt;.&lt;/span&gt;  &lt;span&gt;.&lt;/span&gt;  &lt;span&gt;.&lt;/span&gt;  &lt;span&gt;.&lt;/span&gt;  &lt;span&gt;.&lt;/span&gt;  Lparen&lt;span&gt;:&lt;/span&gt; &lt;span&gt;4&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt;9&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;34&lt;/span&gt;  &lt;span&gt;.&lt;/span&gt;  &lt;span&gt;.&lt;/span&gt;  &lt;span&gt;.&lt;/span&gt;  &lt;span&gt;.&lt;/span&gt;  &lt;span&gt;.&lt;/span&gt;  &lt;span&gt;.&lt;/span&gt;  &lt;span&gt;.&lt;/span&gt;  Args&lt;span&gt;:&lt;/span&gt; &lt;span&gt;[&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;ast&lt;span&gt;.&lt;/span&gt;Expr &lt;span&gt;(&lt;/span&gt;&lt;span&gt;len&lt;/span&gt; &lt;span&gt;=&lt;/span&gt; &lt;span&gt;1&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;35&lt;/span&gt;  &lt;span&gt;.&lt;/span&gt;  &lt;span&gt;.&lt;/span&gt;  &lt;span&gt;.&lt;/span&gt;  &lt;span&gt;.&lt;/span&gt;  &lt;span&gt;.&lt;/span&gt;  &lt;span&gt;.&lt;/span&gt;  &lt;span&gt;.&lt;/span&gt;  &lt;span&gt;.&lt;/span&gt;  &lt;span&gt;0&lt;/span&gt;&lt;span&gt;:&lt;/span&gt; &lt;span&gt;*&lt;/span&gt;ast&lt;span&gt;.&lt;/span&gt;BasicLit &lt;span&gt;{&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;36&lt;/span&gt;  &lt;span&gt;.&lt;/span&gt;  &lt;span&gt;.&lt;/span&gt;  &lt;span&gt;.&lt;/span&gt;  &lt;span&gt;.&lt;/span&gt;  &lt;span&gt;.&lt;/span&gt;  &lt;span&gt;.&lt;/span&gt;  &lt;span&gt;.&lt;/span&gt;  &lt;span&gt;.&lt;/span&gt;  &lt;span&gt;.&lt;/span&gt;  ValuePos&lt;span&gt;:&lt;/span&gt; &lt;span&gt;4&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;37&lt;/span&gt;  &lt;span&gt;.&lt;/span&gt;  &lt;span&gt;.&lt;/span&gt;  &lt;span&gt;.&lt;/span&gt;  &lt;span&gt;.&lt;/span&gt;  &lt;span&gt;.&lt;/span&gt;  &lt;span&gt;.&lt;/span&gt;  &lt;span&gt;.&lt;/span&gt;  &lt;span&gt;.&lt;/span&gt;  &lt;span&gt;.&lt;/span&gt;  Kind&lt;span&gt;:&lt;/span&gt; STRING&lt;br/&gt;    &lt;span&gt;38&lt;/span&gt;  &lt;span&gt;.&lt;/span&gt;  &lt;span&gt;.&lt;/span&gt;  &lt;span&gt;.&lt;/span&gt;  &lt;span&gt;.&lt;/span&gt;  &lt;span&gt;.&lt;/span&gt;  &lt;span&gt;.&lt;/span&gt;  &lt;span&gt;.&lt;/span&gt;  &lt;span&gt;.&lt;/span&gt;  &lt;span&gt;.&lt;/span&gt;  Value&lt;span&gt;:&lt;/span&gt; &lt;span&gt;&quot;\\&quot;&lt;/span&gt;Hello&lt;span&gt;,&lt;/span&gt; World&lt;span&gt;!&lt;/span&gt;\\&lt;span&gt;&quot;&quot;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;39&lt;/span&gt;  &lt;span&gt;.&lt;/span&gt;  &lt;span&gt;.&lt;/span&gt;  &lt;span&gt;.&lt;/span&gt;  &lt;span&gt;.&lt;/span&gt;  &lt;span&gt;.&lt;/span&gt;  &lt;span&gt;.&lt;/span&gt;  &lt;span&gt;.&lt;/span&gt;  &lt;span&gt;.&lt;/span&gt;  &lt;span&gt;}&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;40&lt;/span&gt;  &lt;span&gt;.&lt;/span&gt;  &lt;span&gt;.&lt;/span&gt;  &lt;span&gt;.&lt;/span&gt;  &lt;span&gt;.&lt;/span&gt;  &lt;span&gt;.&lt;/span&gt;  &lt;span&gt;.&lt;/span&gt;  &lt;span&gt;.&lt;/span&gt;  &lt;span&gt;}&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;41&lt;/span&gt;  &lt;span&gt;.&lt;/span&gt;  &lt;span&gt;.&lt;/span&gt;  &lt;span&gt;.&lt;/span&gt;  &lt;span&gt;.&lt;/span&gt;  &lt;span&gt;.&lt;/span&gt;  &lt;span&gt;.&lt;/span&gt;  &lt;span&gt;.&lt;/span&gt;  Ellipsis&lt;span&gt;:&lt;/span&gt; &lt;span&gt;-&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;42&lt;/span&gt;  &lt;span&gt;.&lt;/span&gt;  &lt;span&gt;.&lt;/span&gt;  &lt;span&gt;.&lt;/span&gt;  &lt;span&gt;.&lt;/span&gt;  &lt;span&gt;.&lt;/span&gt;  &lt;span&gt;.&lt;/span&gt;  &lt;span&gt;.&lt;/span&gt;  Rparen&lt;span&gt;:&lt;/span&gt; &lt;span&gt;4&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt;25&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;43&lt;/span&gt;  &lt;span&gt;.&lt;/span&gt;  &lt;span&gt;.&lt;/span&gt;  &lt;span&gt;.&lt;/span&gt;  &lt;span&gt;.&lt;/span&gt;  &lt;span&gt;.&lt;/span&gt;  &lt;span&gt;.&lt;/span&gt;  &lt;span&gt;}&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;44&lt;/span&gt;  &lt;span&gt;.&lt;/span&gt;  &lt;span&gt;.&lt;/span&gt;  &lt;span&gt;.&lt;/span&gt;  &lt;span&gt;.&lt;/span&gt;  &lt;span&gt;.&lt;/span&gt;  &lt;span&gt;}&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;45&lt;/span&gt;  &lt;span&gt;.&lt;/span&gt;  &lt;span&gt;.&lt;/span&gt;  &lt;span&gt;.&lt;/span&gt;  &lt;span&gt;.&lt;/span&gt;  &lt;span&gt;}&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;46&lt;/span&gt;  &lt;span&gt;.&lt;/span&gt;  &lt;span&gt;.&lt;/span&gt;  &lt;span&gt;.&lt;/span&gt;  &lt;span&gt;.&lt;/span&gt;  Rbrace&lt;span&gt;:&lt;/span&gt; &lt;span&gt;5&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;47&lt;/span&gt;  &lt;span&gt;.&lt;/span&gt;  &lt;span&gt;.&lt;/span&gt;  &lt;span&gt;.&lt;/span&gt;  &lt;span&gt;}&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;48&lt;/span&gt;  &lt;span&gt;.&lt;/span&gt;  &lt;span&gt;.&lt;/span&gt;  &lt;span&gt;}&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;49&lt;/span&gt;  &lt;span&gt;.&lt;/span&gt;  &lt;span&gt;}&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;50&lt;/span&gt;  &lt;span&gt;.&lt;/span&gt;  Scope&lt;span&gt;:&lt;/span&gt; &lt;span&gt;*&lt;/span&gt;ast&lt;span&gt;.&lt;/span&gt;Scope &lt;span&gt;{&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;51&lt;/span&gt;  &lt;span&gt;.&lt;/span&gt;  &lt;span&gt;.&lt;/span&gt;  Objects&lt;span&gt;:&lt;/span&gt; &lt;span&gt;map&lt;/span&gt;&lt;span&gt;[&lt;/span&gt;&lt;span&gt;string&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;&lt;span&gt;*&lt;/span&gt;ast&lt;span&gt;.&lt;/span&gt;Object &lt;span&gt;(&lt;/span&gt;&lt;span&gt;len&lt;/span&gt; &lt;span&gt;=&lt;/span&gt; &lt;span&gt;1&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;52&lt;/span&gt;  &lt;span&gt;.&lt;/span&gt;  &lt;span&gt;.&lt;/span&gt;  &lt;span&gt;.&lt;/span&gt;  &lt;span&gt;&quot;main&quot;&lt;/span&gt;&lt;span&gt;:&lt;/span&gt; &lt;span&gt;*&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;obj @ &lt;span&gt;11&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;53&lt;/span&gt;  &lt;span&gt;.&lt;/span&gt;  &lt;span&gt;.&lt;/span&gt;  &lt;span&gt;}&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;54&lt;/span&gt;  &lt;span&gt;.&lt;/span&gt;  &lt;span&gt;}&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;55&lt;/span&gt;  &lt;span&gt;.&lt;/span&gt;  Unresolved&lt;span&gt;:&lt;/span&gt; &lt;span&gt;[&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;&lt;span&gt;*&lt;/span&gt;ast&lt;span&gt;.&lt;/span&gt;Ident &lt;span&gt;(&lt;/span&gt;&lt;span&gt;len&lt;/span&gt; &lt;span&gt;=&lt;/span&gt; &lt;span&gt;1&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;56&lt;/span&gt;  &lt;span&gt;.&lt;/span&gt;  &lt;span&gt;.&lt;/span&gt;  &lt;span&gt;0&lt;/span&gt;&lt;span&gt;:&lt;/span&gt; &lt;span&gt;*&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;obj @ &lt;span&gt;29&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;57&lt;/span&gt;  &lt;span&gt;.&lt;/span&gt;  &lt;span&gt;}&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;58&lt;/span&gt;  &lt;span&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;pre&gt;&lt;span&gt;整个AST包括Package、Name、Decls、Scope跟Unresolved，其中核心内容在&lt;strong&gt;Decls里边（第6行～49行）&lt;/strong&gt;。&lt;/span&gt;&lt;/pre&gt;&lt;p&gt;&lt;span&gt;Decls是声明declaration的集合，里边有&lt;/span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;FuncDecl(函数声明)&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;，有&lt;/span&gt;&lt;strong&gt;&lt;span&gt;BlockStmt(块语句)&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;，还有&lt;/span&gt;&lt;strong&gt;&lt;span&gt;CallExpr(表达式)&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;等。深入&lt;/span&gt;&lt;span&gt;&lt;span&gt;ast库&lt;/span&gt;&lt;span&gt;，可以发现&lt;/span&gt;&lt;strong&gt;&lt;span&gt;这三个正是AST节点的主要类型，它们都实现了Node(节点)接口&lt;/span&gt;&lt;span&gt;，就是说，AST这颗树挂的都是这三个玩意。&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;// ----------------------------------------------------------------------------&lt;/span&gt;&lt;br/&gt;&lt;span&gt;// Interfaces&lt;/span&gt;&lt;br/&gt;&lt;span&gt;//&lt;/span&gt;&lt;br/&gt;&lt;span&gt;// There are 3 main classes of nodes: Expressions and type nodes,&lt;/span&gt;&lt;br/&gt;&lt;span&gt;// statement nodes, and declaration nodes. The node names usually&lt;/span&gt;&lt;br/&gt;&lt;span&gt;// match the corresponding Go spec production names to which they&lt;/span&gt;&lt;br/&gt;&lt;span&gt;// correspond. The node fields correspond to the individual parts&lt;/span&gt;&lt;br/&gt;&lt;span&gt;// of the respective productions.&lt;/span&gt;&lt;br/&gt;&lt;span&gt;//&lt;/span&gt;&lt;br/&gt;&lt;span&gt;// All nodes contain position information marking the beginning of&lt;/span&gt;&lt;br/&gt;&lt;span&gt;// the corresponding source text segment; it is accessible via the&lt;/span&gt;&lt;br/&gt;&lt;span&gt;// Pos accessor method. Nodes may contain additional position info&lt;/span&gt;&lt;br/&gt;&lt;span&gt;// for language constructs where comments may be found between parts&lt;/span&gt;&lt;br/&gt;&lt;span&gt;// of the construct (typically any larger, parenthesized subpart).&lt;/span&gt;&lt;br/&gt;&lt;span&gt;// That position information is needed to properly position comments&lt;/span&gt;&lt;br/&gt;&lt;span&gt;// when printing the construct.&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// All node types implement the Node interface.&lt;/span&gt;&lt;br/&gt;&lt;span&gt;type&lt;/span&gt; Node &lt;span&gt;interface&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;Pos&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; token&lt;span&gt;.&lt;/span&gt;Pos &lt;span&gt;// position of first character belonging to the node&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;End&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; token&lt;span&gt;.&lt;/span&gt;Pos &lt;span&gt;// position of first character immediately after the node&lt;/span&gt;&lt;br/&gt;&lt;span&gt;}&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// All expression nodes implement the Expr interface.&lt;/span&gt;&lt;br/&gt;&lt;span&gt;type&lt;/span&gt; Expr &lt;span&gt;interface&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;&lt;br/&gt;  Node&lt;br/&gt;  &lt;span&gt;exprNode&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;br/&gt;&lt;span&gt;}&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// All statement nodes implement the Stmt interface.&lt;/span&gt;&lt;br/&gt;&lt;span&gt;type&lt;/span&gt; Stmt &lt;span&gt;interface&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;&lt;br/&gt;  Node&lt;br/&gt;  &lt;span&gt;stmtNode&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;br/&gt;&lt;span&gt;}&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// All declaration nodes implement the Decl interface.&lt;/span&gt;&lt;br/&gt;&lt;span&gt;type&lt;/span&gt; Decl &lt;span&gt;interface&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;&lt;br/&gt;  Node&lt;br/&gt;  &lt;span&gt;declNode&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;br/&gt;&lt;span&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;常见的表达式有：&lt;/strong&gt;&lt;/p&gt;&lt;pre&gt;&lt;code&gt;UnaryExpr 一元表达式&lt;br/&gt;BinaryExpr 二元表达式&lt;br/&gt;ParenExpr 括号表达式&lt;span&gt;,&lt;/span&gt;被括号包裹的表达式&lt;br/&gt;&lt;span&gt;...&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;常见的语句有：&lt;/strong&gt;&lt;/p&gt;&lt;pre&gt;&lt;code&gt;AssignStmt 赋值语句&lt;br/&gt;SwitchStmt &lt;span&gt;switch&lt;/span&gt; 语句&lt;br/&gt;DeferStmt 延迟语句&lt;br/&gt;ForStmt &lt;span&gt;for&lt;/span&gt; 语句&lt;br/&gt;&lt;span&gt;...&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;span&gt;更多定义在&lt;/span&gt;&lt;span&gt;&lt;span&gt;ast文件&lt;/span&gt;&lt;span&gt;中都可以找到，并不难以理解。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;h3&gt;&lt;strong&gt;需求实现&lt;/strong&gt;&lt;/h3&gt;&lt;p&gt;&lt;span&gt;认识了Token跟AST后，我们看怎么简单实现我们的规则解析，还是用上文的例子，要判断http请求header的key/value及cookie的name/value是否满足以下规则：&lt;/span&gt;&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;&quot;header&quot;&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt;{&lt;/span&gt; &lt;span&gt;&quot;key&quot;&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt;&quot;X-APP-ID&quot;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;&quot;value&quot;&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt;&quot;Ves&quot;&lt;/span&gt;&lt;span&gt;}&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&quot;cookie&quot;&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt;{&lt;/span&gt;&lt;span&gt;&quot;name&quot;&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt;&quot;feature&quot;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;&quot;value&quot;&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt;&quot;dev/wynnliu/qualify-rule&quot;&lt;/span&gt;&lt;span&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;span&gt;以header的规则解析AST为例，`&lt;/span&gt;&lt;span&gt;&lt;code&gt;header.key==&quot;X-APP-ID&quot; &amp;amp;&amp;amp; header.value==&quot;Ves&quot;`&lt;/code&gt;&lt;span&gt;，打印的AST如下，&lt;/span&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;AST很清晰地表示这条规则是个BinaryExpr，即二元表达式，二元表达式的左边为X，右边是Y，逻辑运算符为Op&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;     0&lt;/span&gt;  &lt;span&gt;*&lt;/span&gt;ast&lt;span&gt;.&lt;/span&gt;BinaryExpr &lt;span&gt;{&lt;/span&gt;&lt;br/&gt;     &lt;span&gt;1&lt;/span&gt;  &lt;span&gt;.&lt;/span&gt;  X&lt;span&gt;:&lt;/span&gt; &lt;span&gt;*&lt;/span&gt;ast&lt;span&gt;.&lt;/span&gt;BinaryExpr &lt;span&gt;{&lt;/span&gt;&lt;br/&gt;     &lt;span&gt;2&lt;/span&gt;  &lt;span&gt;.&lt;/span&gt;  &lt;span&gt;.&lt;/span&gt;  X&lt;span&gt;:&lt;/span&gt; &lt;span&gt;*&lt;/span&gt;ast&lt;span&gt;.&lt;/span&gt;SelectorExpr &lt;span&gt;{&lt;/span&gt;&lt;br/&gt;     &lt;span&gt;3&lt;/span&gt;  &lt;span&gt;.&lt;/span&gt;  &lt;span&gt;.&lt;/span&gt;  &lt;span&gt;.&lt;/span&gt;  X&lt;span&gt;:&lt;/span&gt; &lt;span&gt;*&lt;/span&gt;ast&lt;span&gt;.&lt;/span&gt;Ident &lt;span&gt;{&lt;/span&gt;&lt;br/&gt;     &lt;span&gt;4&lt;/span&gt;  &lt;span&gt;.&lt;/span&gt;  &lt;span&gt;.&lt;/span&gt;  &lt;span&gt;.&lt;/span&gt;  &lt;span&gt;.&lt;/span&gt;  NamePos&lt;span&gt;:&lt;/span&gt; &lt;span&gt;-&lt;/span&gt;&lt;br/&gt;     &lt;span&gt;5&lt;/span&gt;  &lt;span&gt;.&lt;/span&gt;  &lt;span&gt;.&lt;/span&gt;  &lt;span&gt;.&lt;/span&gt;  &lt;span&gt;.&lt;/span&gt;  Name&lt;span&gt;:&lt;/span&gt; &lt;span&gt;&quot;header&quot;&lt;/span&gt;&lt;br/&gt;     &lt;span&gt;6&lt;/span&gt;  &lt;span&gt;.&lt;/span&gt;  &lt;span&gt;.&lt;/span&gt;  &lt;span&gt;.&lt;/span&gt;  &lt;span&gt;.&lt;/span&gt;  Obj&lt;span&gt;:&lt;/span&gt; &lt;span&gt;*&lt;/span&gt;ast&lt;span&gt;.&lt;/span&gt;Object &lt;span&gt;{&lt;/span&gt;&lt;br/&gt;     &lt;span&gt;7&lt;/span&gt;  &lt;span&gt;.&lt;/span&gt;  &lt;span&gt;.&lt;/span&gt;  &lt;span&gt;.&lt;/span&gt;  &lt;span&gt;.&lt;/span&gt;  &lt;span&gt;.&lt;/span&gt;  Kind&lt;span&gt;:&lt;/span&gt; bad&lt;br/&gt;     &lt;span&gt;8&lt;/span&gt;  &lt;span&gt;.&lt;/span&gt;  &lt;span&gt;.&lt;/span&gt;  &lt;span&gt;.&lt;/span&gt;  &lt;span&gt;.&lt;/span&gt;  &lt;span&gt;.&lt;/span&gt;  Name&lt;span&gt;:&lt;/span&gt; &lt;span&gt;&quot;&quot;&lt;/span&gt;&lt;br/&gt;     &lt;span&gt;9&lt;/span&gt;  &lt;span&gt;.&lt;/span&gt;  &lt;span&gt;.&lt;/span&gt;  &lt;span&gt;.&lt;/span&gt;  &lt;span&gt;.&lt;/span&gt;  &lt;span&gt;}&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;10&lt;/span&gt;  &lt;span&gt;.&lt;/span&gt;  &lt;span&gt;.&lt;/span&gt;  &lt;span&gt;.&lt;/span&gt;  &lt;span&gt;}&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;11&lt;/span&gt;  &lt;span&gt;.&lt;/span&gt;  &lt;span&gt;.&lt;/span&gt;  &lt;span&gt;.&lt;/span&gt;  Sel&lt;span&gt;:&lt;/span&gt; &lt;span&gt;*&lt;/span&gt;ast&lt;span&gt;.&lt;/span&gt;Ident &lt;span&gt;{&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;12&lt;/span&gt;  &lt;span&gt;.&lt;/span&gt;  &lt;span&gt;.&lt;/span&gt;  &lt;span&gt;.&lt;/span&gt;  &lt;span&gt;.&lt;/span&gt;  NamePos&lt;span&gt;:&lt;/span&gt; &lt;span&gt;-&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;13&lt;/span&gt;  &lt;span&gt;.&lt;/span&gt;  &lt;span&gt;.&lt;/span&gt;  &lt;span&gt;.&lt;/span&gt;  &lt;span&gt;.&lt;/span&gt;  Name&lt;span&gt;:&lt;/span&gt; &lt;span&gt;&quot;key&quot;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;14&lt;/span&gt;  &lt;span&gt;.&lt;/span&gt;  &lt;span&gt;.&lt;/span&gt;  &lt;span&gt;.&lt;/span&gt;  &lt;span&gt;}&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;15&lt;/span&gt;  &lt;span&gt;.&lt;/span&gt;  &lt;span&gt;.&lt;/span&gt;  &lt;span&gt;}&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;16&lt;/span&gt;  &lt;span&gt;.&lt;/span&gt;  &lt;span&gt;.&lt;/span&gt;  OpPos&lt;span&gt;:&lt;/span&gt; &lt;span&gt;-&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;17&lt;/span&gt;  &lt;span&gt;.&lt;/span&gt;  &lt;span&gt;.&lt;/span&gt;  Op&lt;span&gt;:&lt;/span&gt; &lt;span&gt;==&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;18&lt;/span&gt;  &lt;span&gt;.&lt;/span&gt;  &lt;span&gt;.&lt;/span&gt;  Y&lt;span&gt;:&lt;/span&gt; &lt;span&gt;*&lt;/span&gt;ast&lt;span&gt;.&lt;/span&gt;BasicLit &lt;span&gt;{&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;19&lt;/span&gt;  &lt;span&gt;.&lt;/span&gt;  &lt;span&gt;.&lt;/span&gt;  &lt;span&gt;.&lt;/span&gt;  ValuePos&lt;span&gt;:&lt;/span&gt; &lt;span&gt;-&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;20&lt;/span&gt;  &lt;span&gt;.&lt;/span&gt;  &lt;span&gt;.&lt;/span&gt;  &lt;span&gt;.&lt;/span&gt;  Kind&lt;span&gt;:&lt;/span&gt; STRING&lt;br/&gt;    &lt;span&gt;21&lt;/span&gt;  &lt;span&gt;.&lt;/span&gt;  &lt;span&gt;.&lt;/span&gt;  &lt;span&gt;.&lt;/span&gt;  Value&lt;span&gt;:&lt;/span&gt; &lt;span&gt;&quot;\\&quot;&lt;/span&gt;X&lt;span&gt;-&lt;/span&gt;APP&lt;span&gt;-&lt;/span&gt;ID\\&lt;span&gt;&quot;&quot;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;22&lt;/span&gt;  &lt;span&gt;.&lt;/span&gt;  &lt;span&gt;.&lt;/span&gt;  &lt;span&gt;}&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;23&lt;/span&gt;  &lt;span&gt;.&lt;/span&gt;  &lt;span&gt;}&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;24&lt;/span&gt;  &lt;span&gt;.&lt;/span&gt;  OpPos&lt;span&gt;:&lt;/span&gt; &lt;span&gt;-&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;25&lt;/span&gt;  &lt;span&gt;.&lt;/span&gt;  Op&lt;span&gt;:&lt;/span&gt; &lt;span&gt;&amp;amp;&amp;amp;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;26&lt;/span&gt;  &lt;span&gt;.&lt;/span&gt;  Y&lt;span&gt;:&lt;/span&gt; &lt;span&gt;*&lt;/span&gt;ast&lt;span&gt;.&lt;/span&gt;BinaryExpr &lt;span&gt;{&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;27&lt;/span&gt;  &lt;span&gt;.&lt;/span&gt;  &lt;span&gt;.&lt;/span&gt;  X&lt;span&gt;:&lt;/span&gt; &lt;span&gt;*&lt;/span&gt;ast&lt;span&gt;.&lt;/span&gt;SelectorExpr &lt;span&gt;{&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;28&lt;/span&gt;  &lt;span&gt;.&lt;/span&gt;  &lt;span&gt;.&lt;/span&gt;  &lt;span&gt;.&lt;/span&gt;  X&lt;span&gt;:&lt;/span&gt; &lt;span&gt;*&lt;/span&gt;ast&lt;span&gt;.&lt;/span&gt;Ident &lt;span&gt;{&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;29&lt;/span&gt;  &lt;span&gt;.&lt;/span&gt;  &lt;span&gt;.&lt;/span&gt;  &lt;span&gt;.&lt;/span&gt;  &lt;span&gt;.&lt;/span&gt;  NamePos&lt;span&gt;:&lt;/span&gt; &lt;span&gt;-&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;30&lt;/span&gt;  &lt;span&gt;.&lt;/span&gt;  &lt;span&gt;.&lt;/span&gt;  &lt;span&gt;.&lt;/span&gt;  &lt;span&gt;.&lt;/span&gt;  Name&lt;span&gt;:&lt;/span&gt; &lt;span&gt;&quot;header&quot;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;31&lt;/span&gt;  &lt;span&gt;.&lt;/span&gt;  &lt;span&gt;.&lt;/span&gt;  &lt;span&gt;.&lt;/span&gt;  &lt;span&gt;.&lt;/span&gt;  Obj&lt;span&gt;:&lt;/span&gt; &lt;span&gt;*&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;obj @ &lt;span&gt;6&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;32&lt;/span&gt;  &lt;span&gt;.&lt;/span&gt;  &lt;span&gt;.&lt;/span&gt;  &lt;span&gt;.&lt;/span&gt;  &lt;span&gt;}&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;33&lt;/span&gt;  &lt;span&gt;.&lt;/span&gt;  &lt;span&gt;.&lt;/span&gt;  &lt;span&gt;.&lt;/span&gt;  Sel&lt;span&gt;:&lt;/span&gt; &lt;span&gt;*&lt;/span&gt;ast&lt;span&gt;.&lt;/span&gt;Ident &lt;span&gt;{&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;34&lt;/span&gt;  &lt;span&gt;.&lt;/span&gt;  &lt;span&gt;.&lt;/span&gt;  &lt;span&gt;.&lt;/span&gt;  &lt;span&gt;.&lt;/span&gt;  NamePos&lt;span&gt;:&lt;/span&gt; &lt;span&gt;-&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;35&lt;/span&gt;  &lt;span&gt;.&lt;/span&gt;  &lt;span&gt;.&lt;/span&gt;  &lt;span&gt;.&lt;/span&gt;  &lt;span&gt;.&lt;/span&gt;  Name&lt;span&gt;:&lt;/span&gt; &lt;span&gt;&quot;value&quot;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;36&lt;/span&gt;  &lt;span&gt;.&lt;/span&gt;  &lt;span&gt;.&lt;/span&gt;  &lt;span&gt;.&lt;/span&gt;  &lt;span&gt;}&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;37&lt;/span&gt;  &lt;span&gt;.&lt;/span&gt;  &lt;span&gt;.&lt;/span&gt;  &lt;span&gt;}&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;38&lt;/span&gt;  &lt;span&gt;.&lt;/span&gt;  &lt;span&gt;.&lt;/span&gt;  OpPos&lt;span&gt;:&lt;/span&gt; &lt;span&gt;-&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;39&lt;/span&gt;  &lt;span&gt;.&lt;/span&gt;  &lt;span&gt;.&lt;/span&gt;  Op&lt;span&gt;:&lt;/span&gt; &lt;span&gt;==&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;40&lt;/span&gt;  &lt;span&gt;.&lt;/span&gt;  &lt;span&gt;.&lt;/span&gt;  Y&lt;span&gt;:&lt;/span&gt; &lt;span&gt;*&lt;/span&gt;ast&lt;span&gt;.&lt;/span&gt;BasicLit &lt;span&gt;{&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;41&lt;/span&gt;  &lt;span&gt;.&lt;/span&gt;  &lt;span&gt;.&lt;/span&gt;  &lt;span&gt;.&lt;/span&gt;  ValuePos&lt;span&gt;:&lt;/span&gt; &lt;span&gt;-&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;42&lt;/span&gt;  &lt;span&gt;.&lt;/span&gt;  &lt;span&gt;.&lt;/span&gt;  &lt;span&gt;.&lt;/span&gt;  Kind&lt;span&gt;:&lt;/span&gt; STRING&lt;br/&gt;    &lt;span&gt;43&lt;/span&gt;  &lt;span&gt;.&lt;/span&gt;  &lt;span&gt;.&lt;/span&gt;  &lt;span&gt;.&lt;/span&gt;  Value&lt;span&gt;:&lt;/span&gt; &lt;span&gt;&quot;\\&quot;&lt;/span&gt;Ves\\&lt;span&gt;&quot;&quot;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;44&lt;/span&gt;  &lt;span&gt;.&lt;/span&gt;  &lt;span&gt;.&lt;/span&gt;  &lt;span&gt;}&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;45&lt;/span&gt;  &lt;span&gt;.&lt;/span&gt;  &lt;span&gt;}&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;46&lt;/span&gt;  &lt;span&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;span&gt;有了AST结构，我们可以&lt;strong&gt;分别获取左边(X)的key值和右边(Y)的值根据逻辑运算符(Op)完成判断&lt;/strong&gt;，如下是简单的判断实现：&lt;/span&gt;&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;// Parse&lt;/span&gt;&lt;br/&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;Parse&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;expr &lt;span&gt;string&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; header http&lt;span&gt;.&lt;/span&gt;Header&lt;span&gt;)&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;&lt;span&gt;bool&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;error&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;&lt;br/&gt;  exprAst&lt;span&gt;,&lt;/span&gt; err &lt;span&gt;:=&lt;/span&gt; parser&lt;span&gt;.&lt;/span&gt;&lt;span&gt;ParseExpr&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;expr&lt;span&gt;)&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;if&lt;/span&gt; err &lt;span&gt;!=&lt;/span&gt; &lt;span&gt;nil&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; err&lt;br/&gt;  &lt;span&gt;}&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;// 打印 ast&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;//fset := token.NewFileSet()&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;//ast.Print(fset, exprAst)&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; &lt;span&gt;judge&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;exprAst&lt;span&gt;,&lt;/span&gt; header&lt;span&gt;)&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;nil&lt;/span&gt;&lt;br/&gt;&lt;span&gt;}&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// 判断&lt;/span&gt;&lt;br/&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;judge&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;bop ast&lt;span&gt;.&lt;/span&gt;Node&lt;span&gt;,&lt;/span&gt; header http&lt;span&gt;.&lt;/span&gt;Header&lt;span&gt;)&lt;/span&gt; &lt;span&gt;bool&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;// 断言成二元表达式&lt;/span&gt;&lt;br/&gt;  expr &lt;span&gt;:=&lt;/span&gt; bop&lt;span&gt;.&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;*&lt;/span&gt;ast&lt;span&gt;.&lt;/span&gt;BinaryExpr&lt;span&gt;)&lt;/span&gt;&lt;br/&gt;  x &lt;span&gt;:=&lt;/span&gt; expr&lt;span&gt;.&lt;/span&gt;X&lt;span&gt;.&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;*&lt;/span&gt;ast&lt;span&gt;.&lt;/span&gt;BinaryExpr&lt;span&gt;)&lt;/span&gt;&lt;br/&gt;  key &lt;span&gt;:=&lt;/span&gt; x&lt;span&gt;.&lt;/span&gt;Y&lt;span&gt;.&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;*&lt;/span&gt;ast&lt;span&gt;.&lt;/span&gt;BasicLit&lt;span&gt;)&lt;/span&gt; &lt;span&gt;// key值&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;  y &lt;span&gt;:=&lt;/span&gt; expr&lt;span&gt;.&lt;/span&gt;Y&lt;span&gt;.&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;*&lt;/span&gt;ast&lt;span&gt;.&lt;/span&gt;BinaryExpr&lt;span&gt;)&lt;/span&gt;&lt;br/&gt;  value &lt;span&gt;:=&lt;/span&gt; y&lt;span&gt;.&lt;/span&gt;Y&lt;span&gt;.&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;*&lt;/span&gt;ast&lt;span&gt;.&lt;/span&gt;BasicLit&lt;span&gt;)&lt;/span&gt; &lt;span&gt;// value值&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;// 等值匹配&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; header&lt;span&gt;.&lt;/span&gt;&lt;span&gt;Get&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;strings&lt;span&gt;.&lt;/span&gt;&lt;span&gt;Trim&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;key&lt;span&gt;.&lt;/span&gt;Value&lt;span&gt;,&lt;/span&gt; &lt;span&gt;`&quot;`&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;==&lt;/span&gt; strings&lt;span&gt;.&lt;/span&gt;&lt;span&gt;Trim&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;value&lt;span&gt;.&lt;/span&gt;Value&lt;span&gt;,&lt;/span&gt; &lt;span&gt;`&quot;`&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;br/&gt;&lt;span&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2&gt;&lt;strong&gt;更进一步&lt;/strong&gt;&lt;/h2&gt;&lt;p&gt;&lt;span&gt;通过以上的简单例子，我们大概可以利用go的ast库和parser库实现个简单的规则引擎。但这可能还不够，如果要覆盖更复杂的规则，不仅仅是只有布尔表达式，就要设计自己的规则原语，比如将`&lt;/span&gt;&lt;span&gt;&lt;code&gt;header.key==&quot;X-APP-ID&quot; &amp;amp;&amp;amp; header.value==&quot;Ves&quot;`&lt;/code&gt;&lt;span&gt;和`&lt;/span&gt;&lt;code&gt;cookie.name==&quot;feature&quot; &amp;amp;&amp;amp; cookie.value==&quot;dev/wynnliu/qualify-rule&quot;`&lt;/code&gt;&lt;span&gt;设计成&lt;/span&gt;&lt;code&gt;`req_header_pair_is(&quot;X-APP-ID&quot;, &quot;VES&quot;) &amp;amp;&amp;amp; req_cookie_contain(&quot;feature&quot;, &quot;dev/wynnliu/qualify-rule&quot;)`&lt;/code&gt;&lt;span&gt;。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;这时就需要引入&lt;/span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;GoYACC&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;，&lt;/span&gt;&lt;span&gt;&lt;span&gt;YACC(Yet Another Compiler Compiler)，是一个经典的生成语法分析器的工具，GoYACC是Golang版本的YACC。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;用GoYACC解析自己设计的BNF/EBNF(巴科斯范式／扩展巴科斯范式，定义语法规则)。GoYACC整体使用原理基本还是上文提到的编译过程，但涉及的细节较多，本文不展开，有兴趣的读者朋友可以参考&lt;/span&gt;&lt;span&gt;&lt;span&gt;TiDB SQL Parser&lt;/span&gt;&lt;span&gt;，了解TiDB的sql解析器如何基于GoYACC设计完成sql解析。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>21f911dcaa8e39ac4e4f4e831c5e3163</guid>
<title>由浅入深，详解 ViewModel 的那些事</title>
<link>https://toutiao.io/k/geggror</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content js_underline_content             autoTypeSetting24psection&amp;#10;            &quot; id=&quot;js_content&quot;&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5629163582531458&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz/yyLvy204xW9B3K7wojhOiaAPQnuepnwwCb3HUWGIaDIDhrSm8XiaXGZOjbrq6A2axxy0EVEnDbcQsxt91GqCx74g/640?wx_fmt=other&quot; data-type=&quot;other&quot; data-w=&quot;2702&quot;/&gt;&lt;/p&gt;&lt;h2 data-id=&quot;heading-0&quot;&gt;引言&lt;/h2&gt;&lt;p&gt;关于 &lt;span&gt;ViewModel&lt;/span&gt; ，Android 开发的小伙伴应该都非常熟悉，无论是新项目还是老项目，基本都会使用到。而 &lt;span&gt;ViewModel&lt;/span&gt; 作为 &lt;code&gt;JetPack&lt;/code&gt; 核心组件，其本身也更是承担着不可或缺的作用。&lt;/p&gt;&lt;p&gt;因此，了解 &lt;span&gt;ViewModel&lt;/span&gt; 的设计思想更是每个应用层开发者必不可缺的基本功。&lt;/p&gt;&lt;p&gt;随着这两年 &lt;code&gt;ViewModel&lt;/code&gt; 的逐步迭代，比如 &lt;span&gt;SaveStateHandle&lt;/span&gt; 的加入等，&lt;span&gt;ViewModel&lt;/span&gt; 也已经不是最初版本的样子。要完全理解其设计体系，往往也要伴随着其他组件的基础，所以并不是特别容易能被开发者吃透。&lt;/p&gt;&lt;p&gt;故本篇将以最新视角开始，与你一起，用力一瞥 &lt;span&gt;ViewModel&lt;/span&gt; 的设计原理。&lt;/p&gt;&lt;p&gt;&lt;span&gt;本文对应的组件版本：&lt;/span&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;em&gt;Activity-ktx-1.5.1&lt;/em&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;em&gt;ViewModel-ktx-2.5.1&lt;/em&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;blockquote&gt;&lt;p&gt;本篇定位中等，将从背景与使用方式开始，再到源码解读。由浅入深，解析 &lt;code&gt;ViewModel&lt;/code&gt; 的方方面面。&lt;/p&gt;&lt;/blockquote&gt;&lt;h2 data-id=&quot;heading-1&quot;&gt;导航&lt;/h2&gt;&lt;p&gt;学完本篇，你将了解或明白以下内容：&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;code&gt;ViewModel&lt;/code&gt; 的使用方式；&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;code&gt;SavedStateHandle&lt;/code&gt; 的使用方式；&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;code&gt;ViewModel&lt;/code&gt; 创建与销毁流程；&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;code&gt;SavedStateHandle&lt;/code&gt; 创建流程；&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;好了，让我们开始吧! 🐊&lt;/p&gt;&lt;h2 data-id=&quot;heading-2&quot;&gt;基础概念&lt;/h2&gt;&lt;p&gt;在开始本篇前，我们先解释一些基础概念，以便更加清晰的了解后续的状态保存相关。&lt;/p&gt;&lt;h3 data-id=&quot;heading-3&quot;&gt;何谓配置变更?&lt;/h3&gt;&lt;p&gt;配置变更指的是，&lt;span&gt;应用在运行时，内置的配置参数变更从而触发的Activity重新创建&lt;/span&gt;。&lt;/p&gt;&lt;p&gt;常见的场景有：旋转屏幕、深色模式切换、屏幕大小变化、更改了默认语言或者时区、更改字体大小或主题颜色等。&lt;/p&gt;&lt;h3 data-id=&quot;heading-4&quot;&gt;何谓异常重建？&lt;/h3&gt;&lt;p&gt;异常重建指的是非配置变更情况下导致的 &lt;code&gt;Activity&lt;/code&gt; 重新创建。&lt;/p&gt;&lt;p&gt;常见场景大多是因为 &lt;span&gt;内存不足，从而导致后台应用被系统回收&lt;/span&gt; ，当我们切换到前台时，从而触发的重建，这个机制在Android中为 &lt;code&gt;Low Memory Killer&lt;/code&gt; 机制，简称 &lt;code&gt;LMK&lt;/code&gt;。&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;可以在开发者模式，限制后台任务数为1，从而测试该效果。&lt;/p&gt;&lt;/blockquote&gt;&lt;h2 data-id=&quot;heading-5&quot;&gt;ViewModel存在之前的世界&lt;/h2&gt;&lt;p&gt;在 &lt;code&gt;ViewModel&lt;/code&gt; 出现之前,对于 &lt;code&gt;View&lt;/code&gt; 逻辑与数据，我们往往都是直接存在 &lt;code&gt;Activity&lt;/code&gt; 或者 &lt;code&gt;Fragment&lt;/code&gt; 中，优雅一点，会细分到具体的单独类中去承载。当配置变更时，无可避免，会触发界面重绘。相应的，我们的数据在没有额外处理的情况下，往往也会被初始化，然后在界面重启时重新加载。&lt;/p&gt;&lt;p&gt;但如果当前页面需要维护某些状态不被丢失呢，比如 选择、上传状态 等等? 此时问题就变得棘手起来。&lt;/p&gt;&lt;p&gt;稍有经验同学会告诉你，&lt;span&gt;在 onSaveInstanceState 中重写，使用bundle去存储相应的状态啊？➡️&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;但状态如果少点还可以，多一点就非常头痛，更别提包含继承关系的状态保存。&lt;/span&gt; 😶‍🌫️&lt;/p&gt;&lt;p&gt;所以，不出意外的话，我们 App 的 &lt;span&gt;Activity-manifest&lt;/span&gt; 中通常默认都是下列写法:&lt;/p&gt;&lt;pre&gt;&lt;code lang=&quot;xml&quot;&gt;android:configChanges=&quot;keyboard|orientation|uiMode|...&quot;&lt;br/&gt;&lt;span&gt;复制代码&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;blockquote&gt;&lt;p&gt;这也是为啥Android程序普遍不支持屏幕旋转的一部分原因，从源头扼杀因部分配置变更导致的状态丢失问题。🐶保命&lt;/p&gt;&lt;/blockquote&gt;&lt;h2 data-id=&quot;heading-6&quot;&gt;VideModel存在之后的世界&lt;/h2&gt;&lt;p&gt;随着 &lt;code&gt;ViewModel&lt;/code&gt; 组件推出之后，上述因配置变更而导致的状态丢失问题就迎刃而解。&lt;/p&gt;&lt;p&gt;&lt;code&gt;ViewModel&lt;/code&gt; 可以做到在配置变更后依然持有状态。所以，在现在的开发中，我们开始将 &lt;span&gt;View数据&lt;/span&gt; 与 逻辑 藏于 &lt;code&gt;ViewModel&lt;/code&gt; 中，然后对外部暴漏观察者，比如我们常常会搭配 &lt;code&gt;LiveData&lt;/code&gt; 一起使用，以此更容易的保持状态同步。&lt;/p&gt;&lt;p&gt;关于 &lt;code&gt;ViewModel&lt;/code&gt; 的生命周期，具体如下图所示：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1.0402298850574712&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz/yyLvy204xW9B3K7wojhOiaAPQnuepnwwC0R17FolXzdJXYyXOsUyIs4y7bcWklO1ZcGYibBVfmyvqAibh9vLXlvjQ/640?wx_fmt=other&quot; data-type=&quot;other&quot; data-w=&quot;522&quot;/&gt;&lt;/p&gt;&lt;p&gt;虽然 &lt;code&gt;ViewModel&lt;/code&gt; 非常好用，但 &lt;code&gt;ViewModel&lt;/code&gt; 也不是万能，其只能避免配置变更时避免状态丢失。比如如果我们的App是因为 &lt;span&gt;内存不足&lt;/span&gt; 而被系统&lt;span&gt;kill&lt;/span&gt; 掉，此时 &lt;code&gt;ViewModel&lt;/code&gt; 也会被清除 🔺 。&lt;/p&gt;&lt;p&gt;不过对于这种情况，仍然有以下三个方法可以依然保存我们的状态:&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;重写 &lt;code&gt;onSaveInstanceState()&lt;/code&gt; 与 &lt;code&gt;onRestoreInstanceState()&lt;/code&gt;;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;使用 &lt;code&gt;SavedState&lt;/code&gt;,本质上其实还是 &lt;code&gt;onSaveInstanceState()&lt;/code&gt; ；&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;使用 &lt;code&gt;SavedStateHandle&lt;/code&gt; ，本质上是依托于 &lt;code&gt;SaveState&lt;/code&gt; 的实现;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;blockquote&gt;&lt;p&gt;上述的后两种都是随着 &lt;span&gt;JetPack&lt;/span&gt; 逐步被推出，可以理解为是对原有的onSavexx的封装简化，从而使其变得更易用。&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;关于这三种方法，我们会在 &lt;code&gt;SavedStateHandle&lt;/code&gt; 流程解析中再进行具体叙述，这里先提出来，留个伏笔。&lt;/p&gt;&lt;h2 data-id=&quot;heading-7&quot;&gt;ViewModel使用方式&lt;/h2&gt;&lt;p&gt;作为文章的开始，我们还是要先聊一聊 &lt;code&gt;ViewModel&lt;/code&gt; 的使用方式，如下例所示:&lt;/p&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.3252032520325203&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz/yyLvy204xW9B3K7wojhOiaAPQnuepnwwCX0iaVwFzs9Y6mxn4seyeMG1lHSnNz6AfYyDVgjYbtupZnGdInRjKriaA/640?wx_fmt=other&quot; data-type=&quot;other&quot; data-w=&quot;1722&quot;/&gt;&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;当然，你也可以选择引入 &lt;span&gt;activity-ktx&lt;/span&gt; ,从而以更简便的写法去写：&lt;/p&gt;&lt;pre&gt;&lt;code lang=&quot;groovy&quot;&gt;implementation &#x27;androidx.activity:activity-ktx:1.5.1&#x27;&lt;br/&gt;&lt;br/&gt;private val mainModel by viewModels&amp;lt;MainViewModel&amp;gt;()&lt;br/&gt;&lt;span&gt;复制代码&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/blockquote&gt;&lt;p&gt;示例比较简单，我们创建了一个 &lt;code&gt;ViewModel&lt;/code&gt; ，如上所示，并在 &lt;code&gt;MainActivity&lt;/code&gt; 的 onCreate() 中进行了初始化。&lt;/p&gt;&lt;p&gt;这也是我们日常的使用方式，具体我们这里就不再做阐述。&lt;/p&gt;&lt;h2 data-id=&quot;heading-8&quot;&gt;SavedStateHandle使用方式&lt;/h2&gt;&lt;p&gt;我们知道，&lt;code&gt;ViewModel&lt;/code&gt; 可以处理因为配置更改而导致的的状态丢失，但并不保证异常终止的情况，而官方的 &lt;code&gt;SavedStateHandle&lt;/code&gt; 正是用于这种情况的解决方式。&lt;/p&gt;&lt;p&gt;&lt;code&gt;SavedStateHandle&lt;/code&gt; ,如名所示，用于保存状态的手柄。再细化点就是，用于保存状态的工具，从而配合 &lt;code&gt;ViewModel&lt;/code&gt; 而使用，其内部使用一个 &lt;span&gt;map&lt;/span&gt; 保存我们要存储的状态，并且其本身使用 &lt;code&gt;operator&lt;/code&gt; 重载了 &lt;span&gt;set()&lt;/span&gt; 与 &lt;span&gt;get()&lt;/span&gt; 方法，所以对于我们来说，可以直接使用 &lt;span&gt;键值对&lt;/span&gt; 的形式去操作我们要保存的状态，这也是官方为什么称 &lt;code&gt;SavedStateHandle&lt;/code&gt; 是一个 &lt;span&gt;具有键值映射Map&lt;/span&gt; 特性的原因。&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;在 Fragment1.2 及 Activity1.1.0 之后, &lt;code&gt;SavedStateHandle&lt;/code&gt; 可以作为 ViewModel 的构造函数，从而反射创建带有 &lt;code&gt;SavedStateHandle&lt;/code&gt; 的 ViewModel 。&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;span&gt;具体使用方式如下：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.634698275862069&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz/yyLvy204xW9B3K7wojhOiaAPQnuepnwwCT8KOKibOjLtuoG3ib7TNNA0aRnicQfBeRcAQicTUxHlxa0uBR2zePlgS6g/640?wx_fmt=other&quot; data-type=&quot;other&quot; data-w=&quot;1856&quot;/&gt;&lt;/p&gt;&lt;p&gt;我们在 &lt;code&gt;MainViewModel&lt;/code&gt; 构造函数中新增了一个参数 &lt;span&gt;state:SavedStateHandle&lt;/span&gt; ,这个参数在 &lt;code&gt;ViewModel&lt;/code&gt; 初始化时，会帮我们自动进行注入。从而我们可以利用 &lt;code&gt;SavedStateHandle&lt;/code&gt; 以key-value的形式去保存一些 &lt;span&gt;自定义状态&lt;/span&gt; ,从而在进程异常终止，Act重建后，也能获取到之前保存的状态。&lt;/p&gt;&lt;p&gt;&lt;span&gt;至于为什么能实现保存状态呢？&lt;/span&gt;&lt;/p&gt;&lt;p&gt;主要是因为 &lt;code&gt;SavedStateHandle&lt;/code&gt; 内部默认有一个 &lt;span&gt;SavedStateRegistry.SavedStateProvider&lt;/span&gt; 状态保存提供者对象，该对象会在我们创建&lt;code&gt;ViewModel&lt;/code&gt; 时绑定到 &lt;span&gt;SavedStateRegistry&lt;/span&gt; 中，从而在我们 &lt;code&gt;Activity&lt;/code&gt; 异常重建时做到状态的 &lt;span&gt;恢复&lt;/span&gt; 与 &lt;span&gt;绑定&lt;/span&gt; (通过重写 &lt;code&gt;onSavexx()&lt;/code&gt; 与 &lt;code&gt;onCreate()&lt;/code&gt; 方法监听)。&lt;/p&gt;&lt;p&gt;关于这部分内容，我们下面的源码解析部分也会再聊到，这里我们只需要知道是这么回事即可。&lt;/p&gt;&lt;h2 data-id=&quot;heading-9&quot;&gt;ViewModel源码解析&lt;/h2&gt;&lt;p&gt;本章节，我们将从 &lt;span&gt;ViewModelProvider()&lt;/span&gt; 开始，理清 &lt;code&gt;ViewModel&lt;/code&gt; 的 &lt;span&gt;创建&lt;/span&gt; 与 &lt;span&gt;销毁&lt;/span&gt; 流程，从而理解其背后的 [魔法]。&lt;/p&gt;&lt;p&gt;不过 ViewModel 的源码其实并不是很复杂，所以别担心😉。&lt;/p&gt;&lt;p&gt;&lt;span&gt;仔细想想，要解析ViewModel的源码，应该从哪里入手呢？&lt;/span&gt;&lt;/p&gt;&lt;pre&gt;&lt;code lang=&quot;kotlin&quot;&gt;ViewModelProvider(&lt;span&gt;this&lt;/span&gt;).&lt;span&gt;get&lt;/span&gt;(MainViewModel::&lt;span&gt;class&lt;/span&gt;.java)&lt;br/&gt;&lt;span&gt;复制代码&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;最简单的方式还是初始化这里，所以我们直接从 &lt;span&gt;ViewModelProvider()&lt;/span&gt; 初始化开始-&amp;gt;&lt;/p&gt;&lt;h3 data-id=&quot;heading-10&quot;&gt;ViewModelProvider(this)&lt;/h3&gt;&lt;pre&gt;&lt;code lang=&quot;kotlin&quot;&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;constructor&lt;/span&gt;(owner: ViewModelStoreOwner)&lt;br/&gt;: &lt;span&gt;this&lt;/span&gt;(owner.viewModelStore, defaultFactory(owner), defaultCreationExtras(owner))&lt;br/&gt;&lt;span&gt;复制代码&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;相应的，这里开始，我们就涉及到了三个方面，即 &lt;span&gt;viewModelStore&lt;/span&gt; 、 &lt;span&gt;Factory&lt;/span&gt;、 &lt;span&gt;Exras&lt;/span&gt; 。所以接下来我们就顺藤摸瓜，分别看看这三处的实现细节。&lt;/p&gt;&lt;h4 data-id=&quot;heading-11&quot;&gt;owner.viewModelStore&lt;/h4&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6541755888650964&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz/yyLvy204xW9B3K7wojhOiaAPQnuepnwwCDLAs3iaJOyIY9BdXB9MA3ElH1QaxIMVrt4ChIBJnY0icJqttPGXGuK7g/640?wx_fmt=other&quot; data-type=&quot;other&quot; data-w=&quot;1868&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;ViewModelStoreOwner&lt;/span&gt; 顾名思义，用于保存 &lt;code&gt;ViewModelStore&lt;/code&gt; 对象。&lt;/p&gt;&lt;p&gt;而 &lt;code&gt;ViewModelStore&lt;/code&gt; 是负责维护我们 &lt;code&gt;ViewModel&lt;/code&gt; 实例的具体类，内部有一个 &lt;span&gt;map&lt;/span&gt; 的合集，用于保存我们创建的所有 &lt;code&gt;ViewModel&lt;/code&gt; ，并对外提供了 &lt;code&gt;clear()&lt;/code&gt; 方法，以 &lt;span&gt;便于非配置变更时清除缓存&lt;/span&gt; 。&lt;/p&gt;&lt;hr/&gt;&lt;h4 data-id=&quot;heading-12&quot;&gt;defaultFactory(owner)&lt;/h4&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.258732212160414&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz/yyLvy204xW9B3K7wojhOiaAPQnuepnwwCTK08gHiad3Ro4PUK4QwoGLKZh9rJzX0QZRZIwbsibCBSKLhQ8jxPOjicQ/640?wx_fmt=other&quot; data-type=&quot;other&quot; data-w=&quot;1546&quot;/&gt;&lt;/p&gt;&lt;p&gt;该方法用于初始化 &lt;code&gt;ViewModel&lt;/code&gt; 默认的创造工厂🏭 。默认有两个实现，前者是 &lt;span&gt;HasDefaultViewModelProviderFactory&lt;/span&gt; ，也是我们 &lt;code&gt;Fragment&lt;/code&gt; 或者 &lt;code&gt;ComponentActivity&lt;/code&gt; 都默认实现的接口，而后者是是指全局 &lt;span&gt;NewInstanceFactory&lt;/span&gt; 。&lt;/p&gt;&lt;p&gt;两者的不同点在于，后者只能创建 &lt;span&gt;空构造函数&lt;/span&gt; 的 &lt;code&gt;ViewModel&lt;/code&gt; ，而前者没有这个限制。&lt;/p&gt;&lt;p&gt;&lt;span&gt;示例源码：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;em&gt;HasDefaultViewModelProviderFactory 在 ComponentActivity 中的实现如下:&lt;/em&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.3771289537712895&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz/yyLvy204xW9B3K7wojhOiaAPQnuepnwwCoQ08hgbvqXyu8Sia0Mo9ibws764NzR09JqwwrOAibsLboZXMp5ZgWJvMA/640?wx_fmt=other&quot; data-type=&quot;other&quot; data-w=&quot;1644&quot;/&gt;&lt;/p&gt;&lt;hr/&gt;&lt;h4 data-id=&quot;heading-13&quot;&gt;defaultCreationExtras(owner)&lt;/h4&gt;&lt;p&gt;用于辅助 &lt;code&gt;ViewModel&lt;/code&gt; 初始化时需要传入的参数，具体源码如下：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.22716627634660422&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz/yyLvy204xW9B3K7wojhOiaAPQnuepnwwCK3PYKrBIgs64MDibSEV3SUBbOulFSawQMDxrQLIiaI0GmPtp8zNvpbqg/640?wx_fmt=other&quot; data-type=&quot;other&quot; data-w=&quot;1708&quot;/&gt;&lt;/p&gt;&lt;p&gt;如上所示，默认有两个实现，前者是 &lt;span&gt;HasDefaultViewModelProviderFactory&lt;/span&gt; ,也就是我们 &lt;code&gt;ComponentActivity&lt;/code&gt; 实现的接口,具体的实现如下：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.35192697768762676&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz/yyLvy204xW9B3K7wojhOiaAPQnuepnwwCP3XZIh4qRtHUqPcrMseIIborwzTXV11qyVy4EOF7IEQDEuZlTfad7w/640?wx_fmt=other&quot; data-type=&quot;other&quot; data-w=&quot;1972&quot;/&gt;&lt;/p&gt;&lt;p&gt;默认会帮我们注入 &lt;code&gt;application&lt;/code&gt; 以及 &lt;code&gt;intent&lt;/code&gt; 等，注意这里还默认使用了 &lt;span&gt;getIntent().getExtras()&lt;/span&gt; 作为 &lt;code&gt;ViewModel&lt;/code&gt; 的 &lt;span&gt;默认状态&lt;/span&gt; ，如果我们 &lt;code&gt;ViewModel&lt;/code&gt; 构造函数中有 &lt;code&gt;SavedStateHandle&lt;/code&gt; 的话。&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;更多关于 &lt;span&gt;CreationExtras&lt;/span&gt; 可以了解这篇 创建 ViewModel 的新方式，CreationExtras 了解一下？&lt;/p&gt;&lt;/blockquote&gt;&lt;hr/&gt;&lt;h3 data-id=&quot;heading-14&quot;&gt;get(ViewModel::xx)&lt;/h3&gt;&lt;p&gt;从缓存中获取现有的 &lt;code&gt;ViewModel&lt;/code&gt; 或者 &lt;span&gt;反射创建&lt;/span&gt; 新的 &lt;code&gt;ViewModel&lt;/code&gt;。&lt;/p&gt;&lt;p&gt;&lt;span&gt;示例源码如下：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.655688622754491&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz/yyLvy204xW9B3K7wojhOiaAPQnuepnwwCmsbWKqOVrxRD8twHtOYIeSr90oaBFzHhib1YcmtGvfQGc2fZUle2wPg/640?wx_fmt=other&quot; data-type=&quot;other&quot; data-w=&quot;2004&quot;/&gt;&lt;/p&gt;&lt;p&gt;当我们使用 &lt;span&gt;get()&lt;/span&gt; 方法获取具体的 &lt;code&gt;ViewModel&lt;/code&gt; 对象时，内部会先利用 &lt;span&gt;当前包名+ViewModel类名&lt;/span&gt; 作为 &lt;code&gt;key&lt;/code&gt; ，然后从 &lt;code&gt;viewModelStore&lt;/code&gt; 中取。如果当前已创建，则直接使用；反之则调用我们的 ViewModel工厂 &lt;span&gt;create()&lt;/span&gt; 方法创建新的 &lt;code&gt;ViewModel&lt;/code&gt;。创建完成后，并将其保存到 &lt;code&gt;ViewModelStore&lt;/code&gt; 中。&lt;/p&gt;&lt;hr/&gt;&lt;h4 data-id=&quot;heading-15&quot;&gt;create(modelClass,extras)&lt;/h4&gt;&lt;p&gt;具体的创造逻辑里，这里的 &lt;span&gt;factory&lt;/span&gt; 正是我们在 &lt;code&gt;ViewModelProvider&lt;/code&gt; 初始化时，默认构造函数 &lt;span&gt;defaultFactory()&lt;/span&gt; 方法中生成的&lt;span&gt;SavedStateViewModelFactory&lt;/span&gt; ，所以我们直接去看这个工厂类即可。&lt;/p&gt;&lt;p&gt;具体源码如下：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1.093655589123867&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz/yyLvy204xW9B3K7wojhOiaAPQnuepnwwCaIdvcWL15ALCzfmiaf5kxel5iasbNHIOGMkMWRogEKFezfoHaPn2442w/640?wx_fmt=other&quot; data-type=&quot;other&quot; data-w=&quot;1986&quot;/&gt;&lt;/p&gt;&lt;hr/&gt;&lt;h4 data-id=&quot;heading-16&quot;&gt;create(key,modelClass)&lt;/h4&gt;&lt;p&gt;兼容旧的版本以及用户操作行为。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.7462981243830207&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz/yyLvy204xW9B3K7wojhOiaAPQnuepnwwCBZDeUvV1FXgeyO1Q9fhtyZjGYcSwpflvicFJhjqNNEl2eiabx4ic74zlA/640?wx_fmt=other&quot; data-type=&quot;other&quot; data-w=&quot;2026&quot;/&gt;&lt;/p&gt;&lt;p&gt;相应的，这里我们还需要再提一下，&lt;span&gt;LegacySavedStateHandleController.create()&lt;/span&gt; 方法：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.41302027748132336&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz/yyLvy204xW9B3K7wojhOiaAPQnuepnwwC181JGsbLfaPM327tl0aicJfRMgeGEKojNiawricR7dwpBRMC90NLvuqvg/640?wx_fmt=other&quot; data-type=&quot;other&quot; data-w=&quot;1874&quot;/&gt;&lt;/p&gt;&lt;p&gt;当我们调用创建 &lt;code&gt;ViewModel&lt;/code&gt; 时，内部会调用具体的 &lt;code&gt;ViewModel&lt;/code&gt; 工厂去创建，如果当前 &lt;code&gt;ViewModel&lt;/code&gt; 已创建，则直接返回，否则调用其 &lt;span&gt;create()&lt;/span&gt; 方法创建新的 &lt;code&gt;ViewModel&lt;/code&gt; 。在具体的创建方法中，需要判断当前构造函数是不是带 &lt;code&gt;application&lt;/code&gt; 或者 &lt;code&gt;SaveStateHandle&lt;/code&gt; ，从而调用合适的 &lt;code&gt;newInstance()&lt;/code&gt; 方法，最后再将创建好的 &lt;code&gt;ViewModel&lt;/code&gt; 添加到 &lt;code&gt;ViewModelStore&lt;/code&gt; 的 &lt;span&gt;缓存&lt;/span&gt; 中。&lt;/p&gt;&lt;hr/&gt;&lt;h3 data-id=&quot;heading-17&quot;&gt;销毁流程&lt;/h3&gt;&lt;p&gt;在初始化 &lt;code&gt;ViewModelProvider&lt;/code&gt; 时，还记得我们需要传递的 &lt;code&gt;ViewModelStoreOwner&lt;/code&gt; 吗？&lt;/p&gt;&lt;p&gt;而这个接口正是被我们的 ComponentActivity 或者 Fragment 各自实现，相应的 &lt;code&gt;ViewModelStore&lt;/code&gt; 也是存在于我们的 ComponentActivity 中，所以我们直接去看示例代码即可：&lt;/p&gt;&lt;p&gt;&lt;span&gt;以ComponentActivity为例，具体的源码如下：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.8501469147894222&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz/yyLvy204xW9B3K7wojhOiaAPQnuepnwwCn2VV9iahsqJh8KcgfO9Gpqk3fDZYoibIajGPt4lEH32mibUHzyPVQc3hg/640?wx_fmt=other&quot; data-type=&quot;other&quot; data-w=&quot;2042&quot;/&gt;&lt;/p&gt;&lt;p&gt;如上所示：在初始化Activity时，内部会使用 &lt;code&gt;lifecycle&lt;/code&gt; 添加一个生命周期观察者，并监听 &lt;span&gt;onDestory()&lt;/span&gt; 通知(Act销毁)，如果当前销毁的原因非配置更改导致，则调用 &lt;span&gt;ViewModeltore.clear()&lt;/span&gt; ，即清空我们的ViewModel缓存列表，从而这也是为什么 &lt;code&gt;ViewModel&lt;/code&gt; 不支持非配置更改的实例保存。&lt;/p&gt;&lt;p&gt;&lt;span&gt;你可能会惊讶，那还怎么借助SavedStateHandle保存状态，viewModel已经被清空了啊🤔?&lt;/span&gt;&lt;/p&gt;&lt;p&gt;如果你记得 &lt;code&gt;Activity&lt;/code&gt; 传统处理状态的方式，此时也就能理解为什么了？因为源头都是一个地方，而 &lt;span&gt;SavedStateHandle&lt;/span&gt; 仅仅只是一个更简便的封装而已。不过关于这个问题具体解析，我们将在下面继续进行探讨，从而理解 &lt;span&gt;SavedStateHandle&lt;/span&gt; 的完整流程。&lt;/p&gt;&lt;h2 data-id=&quot;heading-18&quot;&gt;SavedStateHandle流程解析&lt;/h2&gt;&lt;p&gt;关于 &lt;code&gt;SavedStateHandle&lt;/code&gt; 的使用方法我们在上面已经叙述过了，其相关的 api 使用源码也不是我们所关注的重点，因为并不复杂，而我们主要要探讨的是其整个流程。&lt;/p&gt;&lt;p&gt;要摸清 &lt;code&gt;SavedStateHandle&lt;/code&gt; 的流程，无非就两个方向，即 &lt;span&gt;从何而来&lt;/span&gt; ，又 &lt;span&gt;在哪里进行使用&lt;/span&gt; 🤔。&lt;/p&gt;&lt;p&gt;在上面探索 &lt;code&gt;ViewModel&lt;/code&gt; 创建流程时，我们发现，在 get(ViewModel:xx) 方法内部,最终的 &lt;span&gt;create()&lt;/span&gt; 方法里，存在两个分支:&lt;/p&gt;&lt;blockquote&gt;&lt;ol class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;存在附加参数extras(viewModel2.5.0新增);&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;不存在附加参数extras(兼容历史版本或者用户自定义的行为);&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;/blockquote&gt;&lt;p&gt;相应的，如果 &lt;code&gt;ViewModel&lt;/code&gt; 的构造函数中存在 &lt;span&gt;SavedStateHandle&lt;/span&gt; ，则各自的流程如下所示：&lt;/p&gt;&lt;p&gt;前者使用了 &lt;span&gt;CreationExtras&lt;/span&gt; 的扩展函数 &lt;code&gt;createSavedStateHandle()&lt;/code&gt; ：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.49207920792079207&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz/yyLvy204xW9B3K7wojhOiaAPQnuepnwwCrTUt6koYxGicf1QJsrttziaF0muFskrLhOibQKaG9aIuS3bCEHuln6QMQ/640?wx_fmt=other&quot; data-type=&quot;other&quot; data-w=&quot;2020&quot;/&gt;&lt;/p&gt;&lt;p&gt;而后者使用了 &lt;span&gt;LegacySavedStateHandleController&lt;/span&gt; 控制器去创建：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.30809674027339645&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz/yyLvy204xW9B3K7wojhOiaAPQnuepnwwCKFYfbPtvmp9orBAQxxv69Fmh0O1iceaWtS0kK05n4HrgRRuP9T7ctVw/640?wx_fmt=other&quot; data-type=&quot;other&quot; data-w=&quot;1902&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;总结：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;上述流程中，两者大致是一样的，都需要先调用 &lt;code&gt;consumeRestoredStateForKey(key)&lt;/code&gt; 拿到要还原的 &lt;span&gt;Bundle&lt;/span&gt; , 再调用 &lt;code&gt;SavedStateHandle.createHandle()&lt;/code&gt; 去创建 &lt;code&gt;SavedStateHandle&lt;/code&gt; 。&lt;/p&gt;&lt;p&gt;那 &lt;span&gt;SavedStateRegistry&lt;/span&gt; 又是什么呢？&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;我们的插入点也就在于此开始。&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;我们暂时先不关注如何还原状态，而是先搞清楚 &lt;code&gt;SavedStateRegistry&lt;/code&gt; 是什么，它又是从哪来而传递来的。然后再来看 状态如何被还原，以及 &lt;code&gt;SavedStateHandle&lt;/code&gt; 的创建流程，最后再搞清与 &lt;code&gt;SavedStateRegistry&lt;/code&gt; 又是如何进行关联。&lt;/p&gt;&lt;hr/&gt;&lt;h3 data-id=&quot;heading-19&quot;&gt;SavedStateRegistry&lt;/h3&gt;&lt;p&gt;其是一个用于保存状态的注册表，往往由 &lt;span&gt;SavedStateRegistryOwner&lt;/span&gt; 接口所提供实现，从而以便与拥有生命周期的组件相关联。&lt;/p&gt;&lt;p&gt;比如我们常用的 &lt;code&gt;ComponentActivity&lt;/code&gt; 或者 &lt;code&gt;Fragment&lt;/code&gt; 默认都实现了该接口。&lt;/p&gt;&lt;p&gt;&lt;span&gt;源码如下所示：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1.2616707616707616&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz/yyLvy204xW9B3K7wojhOiaAPQnuepnwwCD7hxAVFC7muxYl2KAKiaKcr39c2ErnNGYTghLouzU0aEFuV57dp5MGQ/640?wx_fmt=other&quot; data-type=&quot;other&quot; data-w=&quot;1628&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.1636828644501279&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz/yyLvy204xW9B3K7wojhOiaAPQnuepnwwCP0m9BDiat5l1msxqHYicJJvUxM1ia2ns8FwmdECYXLE6R0FqoVa5u6ZGw/640?wx_fmt=other&quot; data-type=&quot;other&quot; data-w=&quot;1564&quot;/&gt;&lt;/p&gt;&lt;p&gt;分析上面的代码不难发现，&lt;code&gt;SavedStateRegistry&lt;/code&gt; 本身提供了状态 &lt;span&gt;还原&lt;/span&gt; 与 &lt;span&gt;保存&lt;/span&gt; 的具体能力，并使用一个 &lt;span&gt;map&lt;/span&gt; 保存当前所有的状态提供者，具体的状态提供者由 &lt;span&gt;SavedStateProvider&lt;/span&gt; 接口实现。&lt;/p&gt;&lt;hr/&gt;&lt;h4 data-id=&quot;heading-20&quot;&gt;SavedStateRegistryOwner&lt;/h4&gt;&lt;p&gt;相当于是拥有 &lt;code&gt;SavedStateRegistry&lt;/code&gt; 的具体类，因为本身继承了 &lt;code&gt;LifecycleOwner&lt;/code&gt; 接口，故其也具备 &lt;span&gt;生命感知&lt;/span&gt; 能力，如下所示：&lt;/p&gt;&lt;pre&gt;&lt;code lang=&quot;kotlin&quot;&gt;&lt;span&gt;interface&lt;/span&gt; &lt;span&gt;SavedStateRegistryOwner&lt;/span&gt; : &lt;span&gt;LifecycleOwner&lt;/span&gt; {&lt;br/&gt;    &lt;span&gt;val&lt;/span&gt; savedStateRegistry: SavedStateRegistry&lt;br/&gt;}&lt;br/&gt;&lt;span&gt;复制代码&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;以 &lt;code&gt;ComponentActivity&lt;/code&gt; 为例，我们会发现，&lt;code&gt;ComponentActivity&lt;/code&gt; 默认实现 &lt;span&gt;SavedStateRegistryOwner&lt;/span&gt; 接口。即 &lt;code&gt;SavedStateRegistry&lt;/code&gt; 的创造以及状态的保存，肯定也是 &lt;span&gt;经过我们Activity转发处理&lt;/span&gt;(不然它自己怎么处理呢😅)。&lt;/p&gt;&lt;p&gt;而在上面探索 &lt;span&gt;ViewModel&lt;/span&gt; 初始化时，我们了解到，&lt;code&gt;ComponentActivity&lt;/code&gt; 默认实现了 &lt;code&gt;HasDefaultViewModelProviderFactory&lt;/code&gt; 接口，用于&lt;span&gt;创建ViewModel工厂&lt;/span&gt; 。相应的，其接口方法 &lt;code&gt;getDefaultViewModelProviderFactory()&lt;/code&gt; 默认返回的是 &lt;code&gt;SavedStateViewModelFactory&lt;/code&gt; ,即支持状态保存的ViewModel工厂。而该工厂构造函数中正是需要接受一个 &lt;code&gt;SavedStateRegistry&lt;/code&gt; 变量，也正是我们 &lt;code&gt;ComponentActivity&lt;/code&gt; 中默认保存的实例，所以也不难猜测 &lt;span&gt;ViewModel工厂&lt;/span&gt; 是如何与 &lt;code&gt;SavedStateRegistry&lt;/code&gt; 如何关联的。&lt;/p&gt;&lt;p&gt;以 &lt;code&gt;ComponentActivity&lt;/code&gt; 的实现为例，&lt;span&gt;源码如下：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.9043367346938775&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz/yyLvy204xW9B3K7wojhOiaAPQnuepnwwCFb7htW0SMZW3xZqmX6ygDaQK1mMacibPsKDy0FbIMO3C8CpyS6A4mlA/640?wx_fmt=other&quot; data-type=&quot;other&quot; data-w=&quot;1568&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;code&gt;ComponentActivity&lt;/code&gt; 初始化时，会创建一个 用于保存状态注册表的控制器 &lt;code&gt;SavedStateRegistryController&lt;/code&gt; 对象，见面知意，不难猜出，其是用于控制 &lt;code&gt;SavedStateRegistry&lt;/code&gt; 的具体类。并且该控制器对象会在 &lt;span&gt;onCreate()&lt;/span&gt; 中调用 &lt;span&gt;performRestore()&lt;/span&gt; 还原状态，并在&lt;span&gt;onSaveInstanceState()&lt;/span&gt; 中去保存状态，此时也就解释了为什么 &lt;code&gt;SavedStateRegistry&lt;/code&gt; 能做到状态保存。&lt;/p&gt;&lt;p&gt;相应的，我们还是要再去看看 &lt;span&gt;SavedStateRegistryController&lt;/span&gt; ，以便更好的理解。&lt;/p&gt;&lt;hr/&gt;&lt;h4 data-id=&quot;heading-21&quot;&gt;SavedStateRegistryController&lt;/h4&gt;&lt;p&gt;用于控制 &lt;code&gt;SavedStateRegistry&lt;/code&gt; ,对外提供了 &lt;span&gt;初始化&lt;/span&gt; ，状态 &lt;span&gt;还原&lt;/span&gt;、&lt;span&gt;保存&lt;/span&gt; 等方法，如下所示：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5653669724770642&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz/yyLvy204xW9B3K7wojhOiaAPQnuepnwwCuJXNMqApdM5jLTiaTotvundQY0GFBJ38JiccARvUrmtqBsDltV260uuA/640?wx_fmt=other&quot; data-type=&quot;other&quot; data-w=&quot;1744&quot;/&gt;&lt;/p&gt;&lt;p&gt;简而言之，其主要用于辅助 &lt;span&gt;SavedStateRegistry&lt;/span&gt; 进行状态保存与还原。&lt;/p&gt;&lt;h4 data-id=&quot;heading-22&quot;&gt;小结&lt;/h4&gt;&lt;p&gt;我们再回顾一下上面的步骤，在只关心 &lt;span&gt;SavedStateHandle&lt;/span&gt; 如何被创建这样一个大背景下，我们大致可以梳理出这样的流程：&lt;/p&gt;&lt;p&gt;因为我们的 ComponentActivity 或者 Fragment 默认已经实现了 &lt;code&gt;SavedStateRegistryOwner&lt;/code&gt; 接口，而且默认是由 &lt;code&gt;SavedStateRegistryController&lt;/code&gt; 作为 &lt;code&gt;SavedStateRegistry&lt;/code&gt; 的具体控制，因此具体的状态保存与还原都由该控制器去操作。&lt;/p&gt;&lt;p&gt;当我们的 &lt;code&gt;Activity&lt;/code&gt; 因为异常生命周期重建时，此时会回调 &lt;span&gt;onSaveInstanceState()&lt;/span&gt; 去保存状态，此时 &lt;code&gt;SavedStateRegistryController&lt;/code&gt; 就会调用 &lt;span&gt;performSave()&lt;/span&gt; 去保存当前状态(即将我们ViewModel的状态保存到bundle里)，然后在 Activity 重建时，在 &lt;span&gt;onCreate()&lt;/span&gt; 方法里进行还原(即从bundle里取出我们保存的状态)。&lt;/p&gt;&lt;p&gt;当我们创建 &lt;code&gt;ViewModel&lt;/code&gt; 时，默认使用的 &lt;code&gt;ViewModel&lt;/code&gt; 工厂是支持保存状态的 &lt;code&gt;SavedStateViewModelFactory&lt;/code&gt; 。在初始化该工厂时，需要显式传递 &lt;code&gt;SavedStateRegistryOwner&lt;/code&gt; 接口对象到该工厂中，而该工厂的构造函数内，会将 &lt;code&gt;SavedStateRegistry&lt;/code&gt; 自行保存起来。&lt;/p&gt;&lt;p&gt;最后，如果要创建的 &lt;code&gt;ViewModel&lt;/code&gt; 需要保存状态(&lt;span&gt;即构造函数中存在SavedStateHadnle&lt;/span&gt;)，则使用保存的 &lt;code&gt;SavedStateRegistry&lt;/code&gt; 变量去获取我们将要还原的状态，然后再调用 &lt;code&gt;SavedStateHandle.createHandle()&lt;/code&gt; 去创建具体的 &lt;code&gt;SavedStateHadnle&lt;/code&gt;。&lt;/p&gt;&lt;p&gt;由此结合 &lt;code&gt;ViewModel&lt;/code&gt; 创建的流程，我们可以总结 &lt;code&gt;SavedStateRegistry&lt;/code&gt; 的传递流程伪代码如下：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.425764192139738&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz/yyLvy204xW9B3K7wojhOiaAPQnuepnwwCTKKKXhJhw9At1QstS5LDu4HM5Yqth5vbJSicyhZDZo2CLoJ6R7dNm2g/640?wx_fmt=other&quot; data-type=&quot;other&quot; data-w=&quot;1832&quot;/&gt;&lt;/p&gt;&lt;hr/&gt;&lt;h3 data-id=&quot;heading-23&quot;&gt;SavedStateHandle如何创建&lt;/h3&gt;&lt;p&gt;在上面，我们聊完了 &lt;code&gt;SavedStateRegistry&lt;/code&gt; 是如何被创建以及被传递给我们的 &lt;span&gt;ViewModel工厂&lt;/span&gt; ，而这一小节，我们将要聊聊 &lt;code&gt;SavedStateHandle&lt;/code&gt; 如何被创建，以及状态是如何被还原的。&lt;/p&gt;&lt;p&gt;我们知道，当创建 &lt;code&gt;SavedStateHandle&lt;/code&gt; 前，需要先获取已保存的状态，也即 &lt;code&gt;consumeRestoredStateForKey()&lt;/code&gt; 方法，所以我们本章节的插入点也就是从这里开始。&lt;/p&gt;&lt;p&gt;而与 &lt;code&gt;consumeRestoredStateForKey()&lt;/code&gt; 关联的类有两个, &lt;span&gt;SavedStateHandlesProvider&lt;/span&gt; 与 &lt;span&gt;SavedStateRegistry&lt;/span&gt; 。&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;前者是 &lt;code&gt;viewModel&lt;/code&gt;(2.5.0) 新提供的 &lt;span&gt;创建SavedStateHandle&lt;/span&gt; 的方式，后者则是用于 &lt;span&gt;适配&lt;/span&gt; 2.5.0 之前的方式。&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;以 &lt;span&gt;SavedStateHandlesProvider&lt;/span&gt; 为例，源码如下：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.9393282773564464&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz/yyLvy204xW9B3K7wojhOiaAPQnuepnwwCm1aGsibcoibAIeqBLrGFe8j77nic1FK5DTto2OAkCXN22gf1H3ghS18xg/640?wx_fmt=other&quot; data-type=&quot;other&quot; data-w=&quot;1846&quot;/&gt;&lt;/p&gt;&lt;p&gt;当我们调用 &lt;code&gt;consumeRestoredStateForKey()&lt;/code&gt; 获取具体状态时，内部先会调用 &lt;code&gt;performRestore()&lt;/code&gt; 从 &lt;span&gt;SavedStateRegistry&lt;/span&gt; 获取我们保存的状态集，然后将其保存到 &lt;code&gt;provider&lt;/code&gt; 中。再从这个总的 &lt;span&gt;状态bundle&lt;/span&gt; 中获取我们当前 &lt;code&gt;viewModel&lt;/code&gt; 所对应的状态。&lt;/p&gt;&lt;p&gt;相应的，我们再去看看 &lt;span&gt;SavedStateHandle.createHandle()&lt;/span&gt; 方法，即 &lt;code&gt;SavedStateHandle&lt;/code&gt; 最终被怎么创建出来。&lt;/p&gt;&lt;p&gt;&lt;span&gt;源码如下：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6757940854326396&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz/yyLvy204xW9B3K7wojhOiaAPQnuepnwwCFWupDXBbgDj2s6kgrazfTWH59jAmjyQBicmarURhfSmPq9dZEnibAK7Q/640?wx_fmt=other&quot; data-type=&quot;other&quot; data-w=&quot;1826&quot;/&gt;&lt;/p&gt;&lt;p&gt;上述的逻辑也比较简单，具体如源码中所示，当我们创建 &lt;span&gt;SavedStateHandle&lt;/span&gt; 时，需要先从 &lt;span&gt;SavedStateRegistry&lt;/span&gt; 获取我们的状态Bundle,然后再调用 &lt;code&gt;createHandle()&lt;/code&gt; 方法创建具体的 &lt;span&gt;SavedStateHandle&lt;/span&gt;。并在其 &lt;code&gt;createHandle()&lt;/code&gt; 内将我们传入的 &lt;span&gt;bundle&lt;/span&gt; 转为 &lt;span&gt;Map&lt;/span&gt; 形式，从而传入 &lt;span&gt;SavedStateHandle&lt;/span&gt; 的构造函数中用于初始化。&lt;/p&gt;&lt;h3 data-id=&quot;heading-24&quot;&gt;总结&lt;/h3&gt;&lt;p&gt;在这一章节，我们主要探讨的是 &lt;code&gt;SavedStateHandle&lt;/code&gt; 的创建流程，以 &lt;code&gt;ComponentActivity&lt;/code&gt; 为例：&lt;/p&gt;&lt;p&gt;我们知道 Android 中关于状态的保存与还原，官方建议使用 &lt;span&gt;onSaveInstanceState()&lt;/span&gt; 与 &lt;span&gt;onRestoreInstanceState()&lt;/span&gt; ，但随着JetPack组件库的完善，官方在这两个方法的基础上新增了 &lt;code&gt;SavedState&lt;/code&gt; ,目的是简化状态保存的成本。从原理上，其创建了一个 状态保存的的注册表 &lt;code&gt;SavedStateRegistry&lt;/code&gt; ，内部缓存着具体的 &lt;span&gt;状态提供者合集&lt;/span&gt;(key为string,value为SavedStateProvider)。&lt;/p&gt;&lt;p&gt;当我们 Activity 因为配置更改或者不可控原因需要重建时，系统此时会主动调用 &lt;span&gt;onSaveInstanceState()&lt;/span&gt; 方法，从而触发调用 &lt;code&gt;savedStateRegistry.performSave()&lt;/code&gt; 去保存状态。该方法内部会创建一个新的 &lt;span&gt;Bundle&lt;/span&gt; 对象，用于保存所有状态,然后再调用所有缓存的状态提供者(SavedStateProvider)的 &lt;code&gt;saveState()&lt;/code&gt; 方法，从而将所有需要需要保存的状态以 &lt;span&gt;key-value&lt;/span&gt; 的方式存到 &lt;span&gt;Bundle&lt;/span&gt; 中去。最后再将这个整体的 &lt;span&gt;bundle&lt;/span&gt; 存入 &lt;code&gt;onSaveInstanceState()&lt;/code&gt; 方法参数提供的 &lt;span&gt;bundle&lt;/span&gt; 中。&lt;/p&gt;&lt;p&gt;当我们的 Activity 重建完成后，在 &lt;code&gt;onCreate()&lt;/code&gt; 方法中，再使用 &lt;code&gt;SavedStateRegistry&lt;/code&gt; 还原我们自己保存的状态 &lt;span&gt;restoredState&lt;/span&gt;。&lt;/p&gt;&lt;p&gt;最后当我们创建 &lt;code&gt;ViewModel&lt;/code&gt; 时，因为我们的 &lt;span&gt;ViewModel工厂&lt;/span&gt;(SavedStateViewModelFactory) 持有了 &lt;code&gt;SavedStateRegistry&lt;/code&gt; ，也即持有着我们要还原的状态(如果有)。在创建具体的 &lt;code&gt;ViewModel&lt;/code&gt; 时，如果我们要创建的 &lt;code&gt;ViewModel&lt;/code&gt; 构造函数中存在 &lt;code&gt;SavedStateHandle&lt;/code&gt; 参数，则该 &lt;code&gt;ViewModel&lt;/code&gt; 支持保存状态，所以需要先去使用 &lt;code&gt;SavedStateRegistry&lt;/code&gt; 获取我们保存的状态，最后再调用 &lt;span&gt;SavedStateHandle.create()&lt;/span&gt; 去创建具体 &lt;code&gt;SaveStateHandle&lt;/code&gt; ，从而创建出支持保存状态 &lt;code&gt;ViewModel&lt;/code&gt; 。&lt;/p&gt;&lt;h2 data-id=&quot;heading-25&quot;&gt;结语&lt;/h2&gt;&lt;p&gt;在本篇中，我们从 &lt;code&gt;ViewModel&lt;/code&gt; 的背景开始，再到 &lt;code&gt;ViewModel&lt;/code&gt; 与 &lt;code&gt;SavedStateHandle&lt;/code&gt; 的使用方式，最后又从源码层级分析了两者的具体流程，从而较完整的解析了 &lt;code&gt;ViewModel&lt;/code&gt; 的底层实现与 &lt;code&gt;SavedStateHandle&lt;/code&gt; 的整体创建流程。&lt;/p&gt;&lt;p&gt;至于更加详细的使用方式，这也非本篇要深入探索的细节，具体可参照其他同学的教程即可。&lt;/p&gt;&lt;p&gt;至此，关于 &lt;code&gt;ViewModel&lt;/code&gt; 设计思想 以及 &lt;span&gt;状态保存原理&lt;/span&gt; 到这里就结束了。也相信读过本篇的你也将不会再有所疑惑 &lt;span&gt;:)&lt;/span&gt;&lt;/p&gt;&lt;p&gt;原文链接：https://juejin.cn/post/7186680109384859706#heading-24&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;关注我获取更多知识或者投稿&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg wxw-img&quot; data-ratio=&quot;1&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/yyLvy204xW9Uibw4qQxibOBKL1DicLX10o3w57n09uKDowd4ZDjRIgSMUn9cqY6ia77Ys3VfZjG8LUviacGSr0DFIvw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;258&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.20555555555555555&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/yyLvy204xW9Uibw4qQxibOBKL1DicLX10o3gibpbVwAGtDUV15FZianjGs1whAZ2gg71IV6J7zQpQhtQRcSyHrGJbxg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;180&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;mp-style-type data-value=&quot;3&quot;/&gt;&lt;/p&gt;&lt;/div&gt;

          
        &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>c375d11cb96b32e6f7f3822e9059a428</guid>
<title>窥探Swift源码下的Array</title>
<link>https://toutiao.io/k/vjzjew5</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content js_underline_content             autoTypeSetting24psection&amp;#10;            &quot; id=&quot;js_content&quot;&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.18170426065162906&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/qMicvibdvl7p0KEd3bHYcm99nBiclZbia548oyvliaq8PrrmrcyuT3QS3urMcfaXDPEumnHP9KYcMV3Fad5Pepzic81Q/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;798&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/p&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt; &lt;img class=&quot;__bg_gif rich_pages wxw-img&quot; data-ratio=&quot;0.23416666666666666&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/qMicvibdvl7p0shmw7MKGyutc63KZyibndlEzXkYJiaS1fUicrkRRKdOhPHMOic2dB36fnECUbaN0h6EJNcYU0HuY49g/640?wx_fmt=gif&quot; data-type=&quot;gif&quot; data-w=&quot;1200&quot;/&gt; &lt;/section&gt;&lt;section data-tools=&quot;新媒体排版&quot; data-id=&quot;3335002&quot; data-style-type=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section powered-by=&quot;xiumi.us&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section powered-by=&quot;xiumi.us&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p&gt;&lt;span&gt;本文字数：&lt;/span&gt;&lt;span&gt;&lt;strong&gt;6730&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;字&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;预计阅读时间：&lt;/span&gt;&lt;span&gt;&lt;strong&gt;15 &lt;/strong&gt;&lt;/span&gt;&lt;span&gt;分钟&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;blockquote&gt;&lt;p&gt;用最通俗的语言，描述最难懂的技术&lt;/p&gt;&lt;/blockquote&gt;&lt;h2&gt;&lt;span/&gt;&lt;/h2&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;前情提要&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;我在之前的文章&lt;code&gt;一次遍历导致的崩溃&lt;/code&gt;中提到了，如果有机会会把相关的&lt;code&gt;Swift&lt;/code&gt;集合源码阅读。&lt;/p&gt;&lt;p&gt;首先对自己的开发和知识储备会有进一步的升华，另外也可以洞察苹果是否有其他的🐮操作等，值得借鉴&lt;/p&gt;&lt;p&gt;前几天的时候也在自己的项目中发现了一些关于&lt;code&gt;Array&lt;/code&gt;的崩溃，日志如下&lt;/p&gt;&lt;pre&gt;&lt;code&gt;#&lt;span&gt;0&lt;/span&gt; Thread&lt;br/&gt;&lt;br/&gt;&lt;span&gt;NSGenericException&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;*** Collection &amp;lt;__NSArrayM: &lt;span&gt;0x2836a4120&lt;/span&gt;&amp;gt; was mutated &lt;span&gt;while&lt;/span&gt; being enumerated.&lt;br/&gt;...&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;很显然，一个可变数组在遍历的同时对数组进行了修改，因为&lt;code&gt;Array&lt;/code&gt;是线程不安全的，所以框架就警告我们不允许这么做，直接抛崩溃处理&lt;/p&gt;&lt;p&gt;问题很简单，但是我考虑的是目前的&lt;code&gt;Apple&lt;/code&gt;是如何实现的&lt;code&gt;Array&lt;/code&gt;，如果想知道之前的实现可以看《NSMutableArray原理揭露》&lt;/p&gt;&lt;p&gt;最近恰巧在学习和使用相关的&lt;code&gt;Swift&lt;/code&gt;的一些框架，趁着周末搬完砖，就开始了源码之旅，我们立刻出发&lt;/p&gt;&lt;p&gt;笔者的相关准备&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;⚠️：以下源码都在顶部标注了文件以及出现的行数&lt;/p&gt;&lt;/blockquote&gt;&lt;h2&gt;&lt;span&gt;Array是什么&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p&gt;&lt;code&gt;Array&lt;/code&gt;是&lt;code&gt;Swift&lt;/code&gt;下数组的实现，了解&lt;code&gt;Swfit&lt;/code&gt;的都知道，&lt;code&gt;Swift&lt;/code&gt;下的大多数的对象均是由&lt;code&gt;struct&lt;/code&gt;组成的，我们找到源码中的&lt;code&gt;Array&lt;/code&gt;的定义&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;// File: Array.swift, line: 299&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;@frozen &lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;struct&lt;/span&gt; &lt;span&gt;Array&lt;/span&gt;&amp;lt;Element&amp;gt; :&lt;/span&gt; Swift._DestructorSafeContainer {&lt;br/&gt;  &lt;br/&gt;  &lt;span&gt;// ...&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;所以&lt;code&gt;Array&lt;/code&gt;在&lt;code&gt;Swift&lt;/code&gt;下本质就是&lt;code&gt;Struct&lt;/code&gt;&lt;/p&gt;&lt;h2&gt;&lt;span&gt;Array有什么用&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p&gt;有序的存储一组数据&lt;/p&gt;&lt;h2&gt;&lt;span&gt;Array的底层原理&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p&gt;新建一个项目&lt;/p&gt;&lt;p&gt;&lt;code&gt;Xcode-&amp;gt;File-&amp;gt;New-&amp;gt;Project-&amp;gt;MacOS-&amp;gt;Command Line Tool-Language(Swift) &amp;amp; Product Name&lt;/code&gt;&lt;/p&gt;&lt;p&gt;输入以下代码&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;var&lt;/span&gt; num: &lt;span&gt;Array&lt;/span&gt;&amp;lt;&lt;span&gt;Int&lt;/span&gt;&amp;gt; = [&lt;span&gt;1&lt;/span&gt;, &lt;span&gt;2&lt;/span&gt;, &lt;span&gt;3&lt;/span&gt;]&lt;br/&gt;&lt;span&gt;withUnsafePointer&lt;/span&gt;(to: &amp;amp;num) {&lt;br/&gt;    &lt;span&gt;print&lt;/span&gt;($&lt;span&gt;0&lt;/span&gt;)&lt;br/&gt;}&lt;br/&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;end&quot;&lt;/span&gt;)&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;并在&lt;code&gt;print(&quot;end&quot;)&lt;/code&gt;处打断点&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;1.00078125&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/qMicvibdvl7p2Z6yyGHib8LlMm1yuBcESJmfwN6oxC5ZvuQ9gLG5gyJDpkxOgorX9WIJEa1z7VSITnaqqMiaiaibjzMg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;code&gt;x/8g&lt;/code&gt;是&lt;code&gt;LLDB（Low Level Debugger）&lt;/code&gt;下的调试命令，作用是查看内存地址里的值&lt;/p&gt;&lt;p&gt;从图中可以看到，并没有找到&lt;code&gt;1,2,3&lt;/code&gt;的信息，内存里面只有&lt;code&gt;0x0000000101046c70&lt;/code&gt;，猜测是内存某块区域上的地址，所以现在的疑问也有了&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;Array&lt;/code&gt;保存的地址是什么?&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;Array&lt;/code&gt;保存的数据去哪了？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;Array&lt;/code&gt;的写复制如何实现的？&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;带着这三个疑问我们继续往下探索...&lt;/p&gt;&lt;p&gt;生成&lt;code&gt;Array&lt;/code&gt;的&lt;code&gt;SIL&lt;/code&gt;文件&lt;/p&gt;&lt;p&gt;首先我刚才代码文件修改为如下所示，最简单的初始化，有利于我们阅读&lt;code&gt;SIL&lt;/code&gt;文件&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;var&lt;/span&gt; num: &lt;span&gt;Array&lt;/span&gt;&amp;lt;&lt;span&gt;Int&lt;/span&gt;&amp;gt; = [&lt;span&gt;1&lt;/span&gt;, &lt;span&gt;2&lt;/span&gt;, &lt;span&gt;3&lt;/span&gt;]&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;在终端使用命令&lt;code&gt;swiftc -emit-sil main.swift | xcrun swift-demangle &amp;gt; ./main.sil&lt;/code&gt;生成&lt;code&gt;SIL&lt;/code&gt;文件&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;// 全局标识以@开头，全局变量&lt;/span&gt;&lt;br/&gt;&lt;span&gt;// 局部标识以%开头，局部变量&lt;/span&gt;&lt;br/&gt;&lt;span&gt;// store写入内存&lt;/span&gt;&lt;br/&gt;&lt;span&gt;// load读取内存&lt;/span&gt;&lt;br/&gt;&lt;span&gt;// 具体语法请参考：https://llvm.org/docs/LangRef.html（搜索Intermediate Representation）&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;br/&gt;sil_stage canonical&lt;br/&gt;&lt;span&gt;// 系统内部导入的相关需要的动态库&lt;/span&gt;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; Builtin&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; Swift&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; SwiftShims&lt;br/&gt;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; Foundation&lt;br/&gt;&lt;span&gt;// 对一个存放Int可变数组进行setter和getter的声明&lt;/span&gt;&lt;br/&gt;@_hasStorage @_hasInitialValue &lt;span&gt;var&lt;/span&gt; num: &lt;span&gt;Array&lt;/span&gt;&amp;lt;&lt;span&gt;Int&lt;/span&gt;&amp;gt; { &lt;span&gt;get&lt;/span&gt; &lt;span&gt;set&lt;/span&gt; }&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// num&lt;/span&gt;&lt;br/&gt;sil_global hidden @main.num : [&lt;span&gt;Swift&lt;/span&gt;.&lt;span&gt;Int&lt;/span&gt;] : $&lt;span&gt;Array&lt;/span&gt;&amp;lt;&lt;span&gt;Int&lt;/span&gt;&amp;gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// main&lt;/span&gt;&lt;br/&gt;sil @main : $&lt;span&gt;@convention&lt;/span&gt;(&lt;span&gt;c&lt;/span&gt;) (&lt;span&gt;Int32&lt;/span&gt;, &lt;span&gt;UnsafeMutablePointer&lt;/span&gt;&amp;lt;&lt;span&gt;Optional&lt;/span&gt;&amp;lt;&lt;span&gt;UnsafeMutablePointer&lt;/span&gt;&amp;lt;&lt;span&gt;Int8&lt;/span&gt;&amp;gt;&amp;gt;&amp;gt;) -&amp;gt; &lt;span&gt;Int32&lt;/span&gt; {&lt;br/&gt;bb0(%&lt;span&gt;0&lt;/span&gt; : $&lt;span&gt;Int32&lt;/span&gt;, %&lt;span&gt;1&lt;/span&gt; : $&lt;span&gt;UnsafeMutablePointer&lt;/span&gt;&amp;lt;&lt;span&gt;Optional&lt;/span&gt;&amp;lt;&lt;span&gt;UnsafeMutablePointer&lt;/span&gt;&amp;lt;&lt;span&gt;Int8&lt;/span&gt;&amp;gt;&amp;gt;&amp;gt;):&lt;br/&gt;  alloc_global @main.num : [&lt;span&gt;Swift&lt;/span&gt;.&lt;span&gt;Int&lt;/span&gt;]               &lt;span&gt;// id: %2，在堆上开辟一个空间&lt;/span&gt;&lt;br/&gt;  %&lt;span&gt;3&lt;/span&gt; = global_addr @main.num : [&lt;span&gt;Swift&lt;/span&gt;.&lt;span&gt;Int&lt;/span&gt;] : $*&lt;span&gt;Array&lt;/span&gt;&amp;lt;&lt;span&gt;Int&lt;/span&gt;&amp;gt; &lt;span&gt;// user: %25，创建临时变量%3存放数组首地址&lt;/span&gt;&lt;br/&gt;  %&lt;span&gt;4&lt;/span&gt; = integer_literal $&lt;span&gt;Builtin&lt;/span&gt;.&lt;span&gt;Word&lt;/span&gt;, &lt;span&gt;3&lt;/span&gt;           &lt;span&gt;// user: %6&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;// 初始化数组调用的入口方法，function_ref _allocateUninitializedArray&amp;lt;A&amp;gt;(_:)&lt;/span&gt;&lt;br/&gt;  %&lt;span&gt;5&lt;/span&gt; = function_ref @&lt;span&gt;Swift&lt;/span&gt;._allocateUninitializedArray&amp;lt;&lt;span&gt;A&lt;/span&gt;&amp;gt;(&lt;span&gt;Builtin&lt;/span&gt;.&lt;span&gt;Word&lt;/span&gt;) -&amp;gt; ([&lt;span&gt;A&lt;/span&gt;], &lt;span&gt;Builtin&lt;/span&gt;.&lt;span&gt;RawPointer&lt;/span&gt;) : $&lt;span&gt;@convention&lt;/span&gt;(thin) &amp;lt;τ&lt;span&gt;_0_0&lt;/span&gt;&amp;gt; (&lt;span&gt;Builtin&lt;/span&gt;.&lt;span&gt;Word&lt;/span&gt;) -&amp;gt; (@owned &lt;span&gt;Array&lt;/span&gt;&amp;lt;τ&lt;span&gt;_0_0&lt;/span&gt;&amp;gt;, &lt;span&gt;Builtin&lt;/span&gt;.&lt;span&gt;RawPointer&lt;/span&gt;) &lt;span&gt;// user: %6&lt;/span&gt;&lt;br/&gt;  %&lt;span&gt;6&lt;/span&gt; = apply %&lt;span&gt;5&lt;/span&gt;&amp;lt;&lt;span&gt;Int&lt;/span&gt;&amp;gt;(%&lt;span&gt;4&lt;/span&gt;) : $&lt;span&gt;@convention&lt;/span&gt;(thin) &amp;lt;τ&lt;span&gt;_0_0&lt;/span&gt;&amp;gt; (&lt;span&gt;Builtin&lt;/span&gt;.&lt;span&gt;Word&lt;/span&gt;) -&amp;gt; (@owned &lt;span&gt;Array&lt;/span&gt;&amp;lt;τ&lt;span&gt;_0_0&lt;/span&gt;&amp;gt;, &lt;span&gt;Builtin&lt;/span&gt;.&lt;span&gt;RawPointer&lt;/span&gt;) &lt;span&gt;// users: %8, %7&lt;/span&gt;&lt;br/&gt;  %&lt;span&gt;7&lt;/span&gt; = tuple_extract %&lt;span&gt;6&lt;/span&gt; : $(&lt;span&gt;Array&lt;/span&gt;&amp;lt;&lt;span&gt;Int&lt;/span&gt;&amp;gt;, &lt;span&gt;Builtin&lt;/span&gt;.&lt;span&gt;RawPointer&lt;/span&gt;), &lt;span&gt;0&lt;/span&gt; &lt;span&gt;// user: %24&lt;/span&gt;&lt;br/&gt;  %&lt;span&gt;8&lt;/span&gt; = tuple_extract %&lt;span&gt;6&lt;/span&gt; : $(&lt;span&gt;Array&lt;/span&gt;&amp;lt;&lt;span&gt;Int&lt;/span&gt;&amp;gt;, &lt;span&gt;Builtin&lt;/span&gt;.&lt;span&gt;RawPointer&lt;/span&gt;), &lt;span&gt;1&lt;/span&gt; &lt;span&gt;// user: %9&lt;/span&gt;&lt;br/&gt;  %&lt;span&gt;9&lt;/span&gt; = pointer_to_address %&lt;span&gt;8&lt;/span&gt; : $&lt;span&gt;Builtin&lt;/span&gt;.&lt;span&gt;RawPointer&lt;/span&gt; to [strict] $*&lt;span&gt;Int&lt;/span&gt; &lt;span&gt;// users: %12&lt;/span&gt;&lt;br/&gt;  %&lt;span&gt;10&lt;/span&gt; = integer_literal $&lt;span&gt;Builtin&lt;/span&gt;.&lt;span&gt;Int64&lt;/span&gt;, &lt;span&gt;1&lt;/span&gt;         &lt;span&gt;// user: %11，&lt;/span&gt;&lt;br/&gt;  %&lt;span&gt;11&lt;/span&gt; = &lt;span&gt;&lt;span&gt;struct&lt;/span&gt; &lt;span&gt;$Int&lt;/span&gt; (%10 : &lt;span&gt;$Builtin&lt;/span&gt;.&lt;span&gt;Int64&lt;/span&gt;)        // &lt;span&gt;user&lt;/span&gt;: %12&lt;br/&gt;  &lt;span&gt;store&lt;/span&gt; %11 &lt;span&gt;to&lt;/span&gt; %9 : &lt;span&gt;$&lt;/span&gt;*&lt;span&gt;Int&lt;/span&gt;                         // &lt;span&gt;id&lt;/span&gt;: %12&lt;br/&gt;  %13 = &lt;span&gt;integer_literal&lt;/span&gt; &lt;span&gt;$Builtin&lt;/span&gt;.&lt;span&gt;Word&lt;/span&gt;, 1          // &lt;span&gt;user&lt;/span&gt;: %14&lt;br/&gt;  %14 = &lt;span&gt;index_addr&lt;/span&gt; %9 : &lt;span&gt;$&lt;/span&gt;*&lt;span&gt;Int&lt;/span&gt;, %13 : &lt;span&gt;$Builtin&lt;/span&gt;.&lt;span&gt;Word&lt;/span&gt; // &lt;span&gt;user&lt;/span&gt;: %17&lt;br/&gt;  %15 = &lt;span&gt;integer_literal&lt;/span&gt; &lt;span&gt;$Builtin&lt;/span&gt;.&lt;span&gt;Int64&lt;/span&gt;, 2         // &lt;span&gt;user&lt;/span&gt;: %16&lt;br/&gt;  %16 = &lt;span&gt;struct&lt;/span&gt; &lt;span&gt;$Int&lt;/span&gt; (%15 : &lt;span&gt;$Builtin&lt;/span&gt;.&lt;span&gt;Int64&lt;/span&gt;)        // &lt;span&gt;user&lt;/span&gt;: %17&lt;br/&gt;  &lt;span&gt;store&lt;/span&gt; %16 &lt;span&gt;to&lt;/span&gt; %14 : &lt;span&gt;$&lt;/span&gt;*&lt;span&gt;Int&lt;/span&gt;                        // &lt;span&gt;id&lt;/span&gt;: %17&lt;br/&gt;  %18 = &lt;span&gt;integer_literal&lt;/span&gt; &lt;span&gt;$Builtin&lt;/span&gt;.&lt;span&gt;Word&lt;/span&gt;, 2          // &lt;span&gt;user&lt;/span&gt;: %19&lt;br/&gt;  %19 = &lt;span&gt;index_addr&lt;/span&gt; %9 : &lt;span&gt;$&lt;/span&gt;*&lt;span&gt;Int&lt;/span&gt;, %18 : &lt;span&gt;$Builtin&lt;/span&gt;.&lt;span&gt;Word&lt;/span&gt; // &lt;span&gt;user&lt;/span&gt;: %22&lt;br/&gt;  %20 = &lt;span&gt;integer_literal&lt;/span&gt; &lt;span&gt;$Builtin&lt;/span&gt;.&lt;span&gt;Int64&lt;/span&gt;, 3         // &lt;span&gt;user&lt;/span&gt;: %21&lt;br/&gt;  %21 = &lt;span&gt;struct&lt;/span&gt; &lt;span&gt;$Int&lt;/span&gt; (%20 : &lt;span&gt;$Builtin&lt;/span&gt;.&lt;span&gt;Int64&lt;/span&gt;)        // &lt;span&gt;user&lt;/span&gt;: %22&lt;br/&gt;  &lt;span&gt;store&lt;/span&gt; %21 &lt;span&gt;to&lt;/span&gt; %19 : &lt;span&gt;$&lt;/span&gt;*&lt;span&gt;Int&lt;/span&gt;                        // &lt;span&gt;id&lt;/span&gt;: %22&lt;br/&gt;  // &lt;span&gt;function_ref&lt;/span&gt; &lt;span&gt;_finalizeUninitializedArray&lt;/span&gt;&amp;lt;&lt;span&gt;A&lt;/span&gt;&amp;gt;(&lt;span&gt;_&lt;/span&gt;:)&lt;br/&gt;  %23 = &lt;span&gt;function_ref&lt;/span&gt; @&lt;span&gt;Swift&lt;/span&gt;.&lt;span&gt;_finalizeUninitializedArray&lt;/span&gt;&amp;lt;&lt;span&gt;A&lt;/span&gt;&amp;gt;(&lt;span&gt;__owned&lt;/span&gt; [&lt;span&gt;A&lt;/span&gt;]) -&amp;gt; [&lt;span&gt;A&lt;/span&gt;] : &lt;span&gt;$&lt;/span&gt;@&lt;span&gt;convention&lt;/span&gt;(&lt;span&gt;thin&lt;/span&gt;) &amp;lt;τ&lt;span&gt;_0_0&lt;/span&gt;&amp;gt; (@&lt;span&gt;owned&lt;/span&gt; &lt;span&gt;Array&lt;/span&gt;&amp;lt;τ&lt;span&gt;_0_0&lt;/span&gt;&amp;gt;) -&amp;gt; @&lt;span&gt;owned&lt;/span&gt; &lt;span&gt;Array&lt;/span&gt;&amp;lt;τ&lt;span&gt;_0_0&lt;/span&gt;&amp;gt; // &lt;span&gt;user&lt;/span&gt;: %24&lt;br/&gt;  %24 = &lt;span&gt;apply&lt;/span&gt; %23&amp;lt;&lt;span&gt;Int&lt;/span&gt;&amp;gt;(%7) : &lt;span&gt;$&lt;/span&gt;@&lt;span&gt;convention&lt;/span&gt;(&lt;span&gt;thin&lt;/span&gt;) &amp;lt;τ&lt;span&gt;_0_0&lt;/span&gt;&amp;gt; (@&lt;span&gt;owned&lt;/span&gt; &lt;span&gt;Array&lt;/span&gt;&amp;lt;τ&lt;span&gt;_0_0&lt;/span&gt;&amp;gt;) -&amp;gt; @&lt;span&gt;owned&lt;/span&gt; &lt;span&gt;Array&lt;/span&gt;&amp;lt;τ&lt;span&gt;_0_0&lt;/span&gt;&amp;gt; // &lt;span&gt;user&lt;/span&gt;: %25&lt;br/&gt;  &lt;span&gt;store&lt;/span&gt; %24 &lt;span&gt;to&lt;/span&gt; %3 : &lt;span&gt;$&lt;/span&gt;*&lt;span&gt;Array&lt;/span&gt;&amp;lt;&lt;span&gt;Int&lt;/span&gt;&amp;gt;                  // &lt;span&gt;id&lt;/span&gt;: %25&lt;br/&gt;  %26 = &lt;span&gt;integer_literal&lt;/span&gt; &lt;span&gt;$Builtin&lt;/span&gt;.&lt;span&gt;Int32&lt;/span&gt;, 0         // &lt;span&gt;user&lt;/span&gt;: %27&lt;br/&gt;  %27 = &lt;span&gt;struct&lt;/span&gt; &lt;span&gt;$Int32&lt;/span&gt; (%26 : &lt;span&gt;$Builtin&lt;/span&gt;.&lt;span&gt;Int32&lt;/span&gt;)      // &lt;span&gt;user&lt;/span&gt;: %28&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; %27 : &lt;span&gt;$Int32&lt;/span&gt;                             // &lt;span&gt;id&lt;/span&gt;: %28&lt;br/&gt;} // &lt;span&gt;end&lt;/span&gt; &lt;span&gt;sil&lt;/span&gt; &lt;span&gt;function&lt;/span&gt; &#x27;&lt;span&gt;main&lt;/span&gt;&#x27;&lt;br/&gt;&lt;br/&gt;// &lt;span&gt;_allocateUninitializedArray&lt;/span&gt;&amp;lt;&lt;span&gt;A&lt;/span&gt;&amp;gt;(&lt;span&gt;_&lt;/span&gt;:)&lt;br/&gt;&lt;span&gt;sil&lt;/span&gt; [&lt;span&gt;always_inline&lt;/span&gt;] [&lt;span&gt;_semantics&lt;/span&gt; &quot;&lt;span&gt;array&lt;/span&gt;.&lt;span&gt;uninitialized_intrinsic&lt;/span&gt;&quot;] @&lt;span&gt;Swift&lt;/span&gt;.&lt;span&gt;_allocateUninitializedArray&lt;/span&gt;&amp;lt;&lt;span&gt;A&lt;/span&gt;&amp;gt;(&lt;span&gt;Builtin&lt;/span&gt;.&lt;span&gt;Word&lt;/span&gt;) -&amp;gt; ([&lt;span&gt;A&lt;/span&gt;], &lt;span&gt;Builtin&lt;/span&gt;.&lt;span&gt;RawPointer&lt;/span&gt;) : &lt;span&gt;$&lt;/span&gt;@&lt;span&gt;convention&lt;/span&gt;(&lt;span&gt;thin&lt;/span&gt;) &amp;lt;τ&lt;span&gt;_0_0&lt;/span&gt;&amp;gt; (&lt;span&gt;Builtin&lt;/span&gt;.&lt;span&gt;Word&lt;/span&gt;) -&amp;gt; (@&lt;span&gt;owned&lt;/span&gt; &lt;span&gt;Array&lt;/span&gt;&amp;lt;τ&lt;span&gt;_0_0&lt;/span&gt;&amp;gt;, &lt;span&gt;Builtin&lt;/span&gt;.&lt;span&gt;RawPointer&lt;/span&gt;)&lt;br/&gt;&lt;br/&gt;// &lt;span&gt;Int&lt;/span&gt;.&lt;span&gt;init&lt;/span&gt;(&lt;span&gt;_builtinIntegerLiteral&lt;/span&gt;:)&lt;br/&gt;&lt;span&gt;sil&lt;/span&gt; &lt;span&gt;public_external&lt;/span&gt; [&lt;span&gt;transparent&lt;/span&gt;] @&lt;span&gt;Swift&lt;/span&gt;.&lt;span&gt;Int&lt;/span&gt;.&lt;span&gt;init&lt;/span&gt;(&lt;span&gt;_builtinIntegerLiteral&lt;/span&gt;: &lt;span&gt;Builtin&lt;/span&gt;.&lt;span&gt;IntLiteral&lt;/span&gt;) -&amp;gt; &lt;span&gt;Swift&lt;/span&gt;.&lt;span&gt;Int&lt;/span&gt; : &lt;span&gt;$&lt;/span&gt;@&lt;span&gt;convention&lt;/span&gt;(&lt;span&gt;method&lt;/span&gt;) (&lt;span&gt;Builtin&lt;/span&gt;.&lt;span&gt;IntLiteral&lt;/span&gt;, @&lt;span&gt;thin&lt;/span&gt; &lt;span&gt;Int&lt;/span&gt;.&lt;span&gt;Type&lt;/span&gt;) -&amp;gt; &lt;span&gt;Int&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;span&gt;// %0                                             // user: %2&lt;/span&gt;&lt;br/&gt;bb0(%&lt;span&gt;0&lt;/span&gt; : $&lt;span&gt;Builtin&lt;/span&gt;.&lt;span&gt;IntLiteral&lt;/span&gt;, %&lt;span&gt;1&lt;/span&gt; : $@thin &lt;span&gt;Int&lt;/span&gt;.&lt;span&gt;Type&lt;/span&gt;):&lt;br/&gt;  %&lt;span&gt;2&lt;/span&gt; = builtin &lt;span&gt;&quot;s_to_s_checked_trunc_IntLiteral_Int64&quot;&lt;/span&gt;(%&lt;span&gt;0&lt;/span&gt; : $&lt;span&gt;Builtin&lt;/span&gt;.&lt;span&gt;IntLiteral&lt;/span&gt;) : $(&lt;span&gt;Builtin&lt;/span&gt;.&lt;span&gt;Int64&lt;/span&gt;, &lt;span&gt;Builtin&lt;/span&gt;.&lt;span&gt;Int1&lt;/span&gt;) &lt;span&gt;// user: %3&lt;/span&gt;&lt;br/&gt;  %&lt;span&gt;3&lt;/span&gt; = tuple_extract %&lt;span&gt;2&lt;/span&gt; : $(&lt;span&gt;Builtin&lt;/span&gt;.&lt;span&gt;Int64&lt;/span&gt;, &lt;span&gt;Builtin&lt;/span&gt;.&lt;span&gt;Int1&lt;/span&gt;), &lt;span&gt;0&lt;/span&gt; &lt;span&gt;// user: %4&lt;/span&gt;&lt;br/&gt;  %&lt;span&gt;4&lt;/span&gt; = &lt;span&gt;&lt;span&gt;struct&lt;/span&gt; &lt;span&gt;$Int&lt;/span&gt; (%3 : &lt;span&gt;$Builtin&lt;/span&gt;.&lt;span&gt;Int64&lt;/span&gt;)          // &lt;span&gt;user&lt;/span&gt;: %5&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; %4 : &lt;span&gt;$Int&lt;/span&gt;                                // &lt;span&gt;id&lt;/span&gt;: %5&lt;br/&gt;} // &lt;span&gt;end&lt;/span&gt; &lt;span&gt;sil&lt;/span&gt; &lt;span&gt;function&lt;/span&gt; &#x27;&lt;span&gt;Swift&lt;/span&gt;.&lt;span&gt;Int&lt;/span&gt;.&lt;span&gt;init&lt;/span&gt;(&lt;span&gt;_builtinIntegerLiteral&lt;/span&gt;: &lt;span&gt;Builtin&lt;/span&gt;.&lt;span&gt;IntLiteral&lt;/span&gt;) -&amp;gt; &lt;span&gt;Swift&lt;/span&gt;.&lt;span&gt;Int&lt;/span&gt;&#x27;&lt;br/&gt;&lt;br/&gt;// &lt;span&gt;_finalizeUninitializedArray&lt;/span&gt;&amp;lt;&lt;span&gt;A&lt;/span&gt;&amp;gt;(&lt;span&gt;_&lt;/span&gt;:)&lt;br/&gt;&lt;span&gt;sil&lt;/span&gt; &lt;span&gt;shared_external&lt;/span&gt; [&lt;span&gt;readnone&lt;/span&gt;] [&lt;span&gt;_semantics&lt;/span&gt; &quot;&lt;span&gt;array&lt;/span&gt;.&lt;span&gt;finalize_intrinsic&lt;/span&gt;&quot;] @&lt;span&gt;Swift&lt;/span&gt;.&lt;span&gt;_finalizeUninitializedArray&lt;/span&gt;&amp;lt;&lt;span&gt;A&lt;/span&gt;&amp;gt;(&lt;span&gt;__owned&lt;/span&gt; [&lt;span&gt;A&lt;/span&gt;]) -&amp;gt; [&lt;span&gt;A&lt;/span&gt;] : &lt;span&gt;$&lt;/span&gt;@&lt;span&gt;convention&lt;/span&gt;(&lt;span&gt;thin&lt;/span&gt;) &amp;lt;&lt;span&gt;Element&lt;/span&gt;&amp;gt; (@&lt;span&gt;owned&lt;/span&gt; &lt;span&gt;Array&lt;/span&gt;&amp;lt;&lt;span&gt;Element&lt;/span&gt;&amp;gt;) -&amp;gt; @&lt;span&gt;owned&lt;/span&gt; &lt;span&gt;Array&lt;/span&gt;&amp;lt;&lt;span&gt;Element&lt;/span&gt;&amp;gt; &lt;/span&gt;{&lt;br/&gt;&lt;span&gt;// %0                                             // user: %2&lt;/span&gt;&lt;br/&gt;bb0(%&lt;span&gt;0&lt;/span&gt; : $&lt;span&gt;Array&lt;/span&gt;&amp;lt;&lt;span&gt;Element&lt;/span&gt;&amp;gt;):&lt;br/&gt;  %&lt;span&gt;1&lt;/span&gt; = alloc_stack $&lt;span&gt;Array&lt;/span&gt;&amp;lt;&lt;span&gt;Element&lt;/span&gt;&amp;gt;                &lt;span&gt;// users: %6, %5, %4, %2&lt;/span&gt;&lt;br/&gt;  store %&lt;span&gt;0&lt;/span&gt; to %&lt;span&gt;1&lt;/span&gt; : $*&lt;span&gt;Array&lt;/span&gt;&amp;lt;&lt;span&gt;Element&lt;/span&gt;&amp;gt;               &lt;span&gt;// id: %2&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;// function_ref Array._endMutation()&lt;/span&gt;&lt;br/&gt;  %&lt;span&gt;3&lt;/span&gt; = function_ref @&lt;span&gt;Swift&lt;/span&gt;.&lt;span&gt;Array&lt;/span&gt;._endMutation() -&amp;gt; () : $&lt;span&gt;@convention&lt;/span&gt;(method) &amp;lt;τ&lt;span&gt;_0_0&lt;/span&gt;&amp;gt; (@&lt;span&gt;inout&lt;/span&gt; &lt;span&gt;Array&lt;/span&gt;&amp;lt;τ&lt;span&gt;_0_0&lt;/span&gt;&amp;gt;) -&amp;gt; () &lt;span&gt;// user: %4&lt;/span&gt;&lt;br/&gt;  %&lt;span&gt;4&lt;/span&gt; = apply %&lt;span&gt;3&lt;/span&gt;&amp;lt;&lt;span&gt;Element&lt;/span&gt;&amp;gt;(%&lt;span&gt;1&lt;/span&gt;) : $&lt;span&gt;@convention&lt;/span&gt;(method) &amp;lt;τ&lt;span&gt;_0_0&lt;/span&gt;&amp;gt; (@&lt;span&gt;inout&lt;/span&gt; &lt;span&gt;Array&lt;/span&gt;&amp;lt;τ&lt;span&gt;_0_0&lt;/span&gt;&amp;gt;) -&amp;gt; ()&lt;br/&gt;  %&lt;span&gt;5&lt;/span&gt; = load %&lt;span&gt;1&lt;/span&gt; : $*&lt;span&gt;Array&lt;/span&gt;&amp;lt;&lt;span&gt;Element&lt;/span&gt;&amp;gt;                 &lt;span&gt;// user: %7&lt;/span&gt;&lt;br/&gt;  dealloc_stack %&lt;span&gt;1&lt;/span&gt; : $*&lt;span&gt;Array&lt;/span&gt;&amp;lt;&lt;span&gt;Element&lt;/span&gt;&amp;gt;             &lt;span&gt;// id: %6&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; %&lt;span&gt;5&lt;/span&gt; : $&lt;span&gt;Array&lt;/span&gt;&amp;lt;&lt;span&gt;Element&lt;/span&gt;&amp;gt;                     &lt;span&gt;// id: %7&lt;/span&gt;&lt;br/&gt;} &lt;span&gt;// end sil function &#x27;Swift._finalizeUninitializedArray&amp;lt;A&amp;gt;(__owned [A]) -&amp;gt; [A]&#x27;&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// Array._endMutation()&lt;/span&gt;&lt;br/&gt;sil shared_external [_semantics &lt;span&gt;&quot;array.end_mutation&quot;&lt;/span&gt;] @&lt;span&gt;Swift&lt;/span&gt;.&lt;span&gt;Array&lt;/span&gt;._endMutation() -&amp;gt; () : $&lt;span&gt;@convention&lt;/span&gt;(method) &amp;lt;&lt;span&gt;Element&lt;/span&gt;&amp;gt; (@&lt;span&gt;inout&lt;/span&gt; &lt;span&gt;Array&lt;/span&gt;&amp;lt;&lt;span&gt;Element&lt;/span&gt;&amp;gt;) -&amp;gt; () {&lt;br/&gt;&lt;span&gt;// %0                                             // users: %9, %1&lt;/span&gt;&lt;br/&gt;bb0(%&lt;span&gt;0&lt;/span&gt; : $*&lt;span&gt;Array&lt;/span&gt;&amp;lt;&lt;span&gt;Element&lt;/span&gt;&amp;gt;):&lt;br/&gt;  %&lt;span&gt;1&lt;/span&gt; = struct_element_addr %&lt;span&gt;0&lt;/span&gt; : $*&lt;span&gt;Array&lt;/span&gt;&amp;lt;&lt;span&gt;Element&lt;/span&gt;&amp;gt;, #&lt;span&gt;Array&lt;/span&gt;._buffer &lt;span&gt;// user: %2&lt;/span&gt;&lt;br/&gt;  %&lt;span&gt;2&lt;/span&gt; = struct_element_addr %&lt;span&gt;1&lt;/span&gt; : $*_ArrayBuffer&amp;lt;&lt;span&gt;Element&lt;/span&gt;&amp;gt;, #_ArrayBuffer._storage &lt;span&gt;// user: %3&lt;/span&gt;&lt;br/&gt;  %&lt;span&gt;3&lt;/span&gt; = struct_element_addr %&lt;span&gt;2&lt;/span&gt; : $*_BridgeStorage&amp;lt;__ContiguousArrayStorageBase&amp;gt;, #_BridgeStorage.rawValue &lt;span&gt;// user: %4&lt;/span&gt;&lt;br/&gt;  %&lt;span&gt;4&lt;/span&gt; = load %&lt;span&gt;3&lt;/span&gt; : $*&lt;span&gt;Builtin&lt;/span&gt;.&lt;span&gt;BridgeObject&lt;/span&gt;           &lt;span&gt;// user: %5&lt;/span&gt;&lt;br/&gt;  %&lt;span&gt;5&lt;/span&gt; = end_cow_mutation %&lt;span&gt;4&lt;/span&gt; : $&lt;span&gt;Builtin&lt;/span&gt;.&lt;span&gt;BridgeObject&lt;/span&gt; &lt;span&gt;// user: %6&lt;/span&gt;&lt;br/&gt;  %&lt;span&gt;6&lt;/span&gt; = &lt;span&gt;&lt;span&gt;struct&lt;/span&gt; &lt;span&gt;$_BridgeStorage&lt;/span&gt;&amp;lt;&lt;span&gt;__ContiguousArrayStorageBase&lt;/span&gt;&amp;gt; (%5 : &lt;span&gt;$Builtin&lt;/span&gt;.&lt;span&gt;BridgeObject&lt;/span&gt;) // &lt;span&gt;user&lt;/span&gt;: %7&lt;br/&gt;  %7 = &lt;span&gt;struct&lt;/span&gt; &lt;span&gt;$_ArrayBuffer&lt;/span&gt;&amp;lt;&lt;span&gt;Element&lt;/span&gt;&amp;gt; (%6 : &lt;span&gt;$_BridgeStorage&lt;/span&gt;&amp;lt;&lt;span&gt;__ContiguousArrayStorageBase&lt;/span&gt;&amp;gt;) // &lt;span&gt;user&lt;/span&gt;: %8&lt;br/&gt;  %8 = &lt;span&gt;struct&lt;/span&gt; &lt;span&gt;$Array&lt;/span&gt;&amp;lt;&lt;span&gt;Element&lt;/span&gt;&amp;gt; (%7 : &lt;span&gt;$_ArrayBuffer&lt;/span&gt;&amp;lt;&lt;span&gt;Element&lt;/span&gt;&amp;gt;) // &lt;span&gt;user&lt;/span&gt;: %9&lt;br/&gt;  &lt;span&gt;store&lt;/span&gt; %8 &lt;span&gt;to&lt;/span&gt; %0 : &lt;span&gt;$&lt;/span&gt;*&lt;span&gt;Array&lt;/span&gt;&amp;lt;&lt;span&gt;Element&lt;/span&gt;&amp;gt;               // &lt;span&gt;id&lt;/span&gt;: %9&lt;br/&gt;  %10 = &lt;span&gt;tuple&lt;/span&gt; ()                                  // &lt;span&gt;user&lt;/span&gt;: %11&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; %10 : &lt;span&gt;$&lt;/span&gt;()                                // &lt;span&gt;id&lt;/span&gt;: %11&lt;br/&gt;} // &lt;span&gt;end&lt;/span&gt; &lt;span&gt;sil&lt;/span&gt; &lt;span&gt;function&lt;/span&gt; &#x27;&lt;span&gt;Swift&lt;/span&gt;.&lt;span&gt;Array&lt;/span&gt;.&lt;span&gt;_endMutation&lt;/span&gt;() -&amp;gt; ()&#x27;&lt;br/&gt;&lt;br/&gt;&lt;br/&gt;&lt;br/&gt;// &lt;span&gt;Mappings&lt;/span&gt; &lt;span&gt;from&lt;/span&gt; &#x27;#&lt;span&gt;fileID&lt;/span&gt;&#x27; &lt;span&gt;to&lt;/span&gt; &#x27;#&lt;span&gt;filePath&lt;/span&gt;&#x27;:&lt;br/&gt;//   &#x27;&lt;span&gt;main&lt;/span&gt;/&lt;span&gt;main&lt;/span&gt;.&lt;span&gt;swift&lt;/span&gt;&#x27; =&amp;gt; &#x27;&lt;span&gt;main&lt;/span&gt;.&lt;span&gt;swift&lt;/span&gt;&#x27;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;从&lt;code&gt;SIL&lt;/code&gt;文件可以看出&lt;code&gt;num&lt;/code&gt;的生成调用了&lt;code&gt;@Swift._allocateUninitializedArray&amp;lt;A&amp;gt;()&lt;/code&gt;的方法，该方法的返回值是一个元祖&lt;code&gt;%6&lt;/code&gt;，然后用&lt;code&gt;%7&lt;/code&gt;和&lt;code&gt;%8&lt;/code&gt;把元祖中的值提取出来，&lt;code&gt;%7&lt;/code&gt;给了&lt;code&gt;%3&lt;/code&gt;,也就是&lt;code&gt;num&lt;/code&gt;的位置了，所以我们刚才断点拿到的&lt;code&gt;0x0000000101046c70&lt;/code&gt;就是&lt;code&gt;%7&lt;/code&gt;的值了&lt;/p&gt;&lt;p&gt;&lt;code&gt;Array&lt;/code&gt;保存的数据依次保存到了&lt;code&gt;%9&lt;/code&gt;,&lt;code&gt;%9&lt;/code&gt;又是&lt;code&gt;%8&lt;/code&gt;的地址的指向 ，所以&lt;code&gt;%7&lt;/code&gt;和&lt;code&gt;%8&lt;/code&gt;是什么？&lt;/p&gt;&lt;p&gt;&lt;code&gt;Array&lt;/code&gt;在源码中的定义&lt;/p&gt;&lt;p&gt;因为在&lt;code&gt;SIL&lt;/code&gt;文件找不到答案，那么我们就去源码找&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;// File: Array.swift, line: 299&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;@frozen&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;struct&lt;/span&gt; &lt;span&gt;Array&lt;/span&gt;&amp;lt;Element&amp;gt;:&lt;/span&gt; _DestructorSafeContainer {&lt;br/&gt;  &lt;span&gt;#&lt;span&gt;if&lt;/span&gt; _runtime(_ObjC)&lt;/span&gt;&lt;br/&gt;  @usableFromInline&lt;br/&gt;  internal typealias _Buffer = _ArrayBuffer&amp;lt;Element&amp;gt;&lt;br/&gt;  #&lt;span&gt;else&lt;/span&gt;&lt;br/&gt;  @usableFromInline&lt;br/&gt;  internal typealias _Buffer = _ContiguousArrayBuffer&amp;lt;Element&amp;gt;&lt;br/&gt;  #endif&lt;br/&gt;&lt;br/&gt;  @usableFromInline&lt;br/&gt;  internal var _buffer: _Buffer&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;/// Initialization from an existing buffer does not have &quot;array.init&quot;&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;/// semantics because the caller may retain an alias to buffer.&lt;/span&gt;&lt;br/&gt;  @inlinable&lt;br/&gt;  internal init(_buffer: _Buffer) {&lt;br/&gt;    self._buffer = _buffer&lt;br/&gt;  }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;我们可以看到&lt;code&gt;Array&lt;/code&gt;中只有一个属性&lt;code&gt;_buffer&lt;/code&gt;，&lt;code&gt;_buffer&lt;/code&gt;在&lt;code&gt;_runtime(Objc)&lt;/code&gt;下是&lt;code&gt;_ArrayBuffer&lt;/code&gt;，否则就是&lt;code&gt;_ContiguousArrayBuffer&lt;/code&gt;；在苹果设备下应该都是兼容&lt;code&gt;Objc&lt;/code&gt;,所以这里应该是&lt;code&gt;_ArrayBuffer&lt;/code&gt;&lt;/p&gt;&lt;h3&gt;&lt;span&gt;&lt;code&gt;_allocateUninitializedArray&lt;/code&gt;&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;在源码中搜索这个方法，看到下面的实现&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;// File: ArrayShared.swift, line: 34&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;/// Returns an Array of `_count` uninitialized elements using the&lt;/span&gt;&lt;br/&gt;&lt;span&gt;/// given `storage`, and a pointer to uninitialized memory for the&lt;/span&gt;&lt;br/&gt;&lt;span&gt;/// first element.&lt;/span&gt;&lt;br/&gt;&lt;span&gt;///&lt;/span&gt;&lt;br/&gt;&lt;span&gt;/// This function is referenced by the compiler to allocate array literals.&lt;/span&gt;&lt;br/&gt;&lt;span&gt;///&lt;/span&gt;&lt;br/&gt;&lt;span&gt;/// - Precondition: `storage` is `_ContiguousArrayStorage`.&lt;/span&gt;&lt;br/&gt;@inlinable &lt;span&gt;// FIXME(inline-always)&lt;/span&gt;&lt;br/&gt;@&lt;span&gt;inline&lt;/span&gt;(__always)&lt;br/&gt;@_semantics(&lt;span&gt;&quot;array.uninitialized_intrinsic&quot;&lt;/span&gt;)&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;// COMPILER_INTRINSIC&lt;/span&gt;&lt;br/&gt;func _allocateUninitializedArray&amp;lt;Element&amp;gt;(_  builtinCount: Builtin.Word)&lt;br/&gt;    -&amp;gt; (Array&amp;lt;Element&amp;gt;, Builtin.RawPointer) {&lt;br/&gt;  let count = Int(builtinCount)&lt;br/&gt;  &lt;span&gt;if&lt;/span&gt; count &amp;gt; &lt;span&gt;0&lt;/span&gt; {&lt;br/&gt;    &lt;span&gt;// Doing the actual buffer allocation outside of the array.uninitialized&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;// semantics function enables stack propagation of the buffer.&lt;/span&gt;&lt;br/&gt;    let bufferObject = Builtin.allocWithTailElems_1(&lt;br/&gt;      _ContiguousArrayStorage&amp;lt;Element&amp;gt;.self, builtinCount, Element.self)&lt;br/&gt;&lt;br/&gt;    let (&lt;span&gt;array&lt;/span&gt;, ptr) = Array&amp;lt;Element&amp;gt;._adoptStorage(bufferObject, count: count)&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; (&lt;span&gt;array&lt;/span&gt;, ptr._rawValue)&lt;br/&gt;  }&lt;br/&gt;  &lt;span&gt;// For an empty array no buffer allocation is needed.&lt;/span&gt;&lt;br/&gt;  let (&lt;span&gt;array&lt;/span&gt;, ptr) = Array&amp;lt;Element&amp;gt;._allocateUninitialized(count)&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; (&lt;span&gt;array&lt;/span&gt;, ptr._rawValue)&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这里可以看到判断&lt;code&gt;count&lt;/code&gt;是否大于0，走的不同的方法，但是返回值都是一样的，我们只看其中一个，因为例子中的&lt;code&gt;count&lt;/code&gt;是3，所以直接看大于0的分支&lt;/p&gt;&lt;p&gt;首先看到调用到了&lt;code&gt;allocWithTailElems_1&lt;/code&gt;方法，调用对象是&lt;code&gt;Builtin&lt;/code&gt;,继续走断点调试，进入了&lt;code&gt;swift_allocObject&lt;/code&gt;方法&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;// File: HeapObject.cpp, line: 133&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;HeapObject *&lt;span&gt;swift::swift_allocObject&lt;/span&gt;&lt;span&gt;(HeapMetadata &lt;span&gt;const&lt;/span&gt; *metadata,&lt;br/&gt;                                     &lt;span&gt;size_t&lt;/span&gt; requiredSize,&lt;br/&gt;                                     &lt;span&gt;size_t&lt;/span&gt; requiredAlignmentMask)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;  CALL_IMPL(swift_allocObject, (metadata, requiredSize, requiredAlignmentMask));&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这个方法的作用是向堆申请分配一块内存空间，这也是上文中提到的&lt;code&gt;猜测是内存某块区域&lt;/code&gt;的一个验证，断点显示&lt;code&gt;requiredSize&lt;/code&gt;是56，&lt;code&gt;po&lt;/code&gt;指针&lt;code&gt;metadata&lt;/code&gt;显示的是&lt;code&gt;_TtGCs23_ContiguousArrayStorageSi_$&lt;/code&gt;，这样可以得出&lt;code&gt;allocWithTailElems_1&lt;/code&gt;向堆申请分配一块空间，申请的对象类型是&lt;code&gt;_ContiguousArrayStorage&lt;/code&gt;&lt;/p&gt;&lt;p&gt;申请好空间之后，继续调用了&lt;code&gt;_adoptStorage&lt;/code&gt;方法&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;// File: Array.swift, line: 947&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;/// Returns an Array of `count` uninitialized elements using the&lt;/span&gt;&lt;br/&gt;&lt;span&gt;/// given `storage`, and a pointer to uninitialized memory for the&lt;/span&gt;&lt;br/&gt;&lt;span&gt;/// first element.&lt;/span&gt;&lt;br/&gt;&lt;span&gt;///&lt;/span&gt;&lt;br/&gt;&lt;span&gt;/// - Precondition: `storage is _ContiguousArrayStorage`.&lt;/span&gt;&lt;br/&gt;@inlinable&lt;br/&gt;@_semantics(&lt;span&gt;&quot;array.uninitialized&quot;&lt;/span&gt;)&lt;br/&gt;internal &lt;span&gt;static&lt;/span&gt; func _adoptStorage(&lt;br/&gt;  _ storage: __owned _ContiguousArrayStorage&amp;lt;Element&amp;gt;, count: Int&lt;br/&gt;) -&amp;gt; (Array, UnsafeMutablePointer&amp;lt;Element&amp;gt;) {&lt;br/&gt;&lt;br/&gt;  let innerBuffer = _ContiguousArrayBuffer&amp;lt;Element&amp;gt;(&lt;br/&gt;    count: count,&lt;br/&gt;    storage: storage)&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; (&lt;br/&gt;    Array(&lt;br/&gt;      _buffer: _Buffer(_buffer: innerBuffer, shiftedToStartIndex: &lt;span&gt;0&lt;/span&gt;)),&lt;br/&gt;      innerBuffer.firstElementAddress)&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;可以看出&lt;code&gt;_adoptStorage&lt;/code&gt;的返回值都是跟&lt;code&gt;innerBuffer&lt;/code&gt;相关，返回的是一个元祖，元祖里的内容分别对应了&lt;code&gt;innerBuffer&lt;/code&gt;的什么呢？&lt;/p&gt;&lt;p&gt;&lt;code&gt;innerBuffer&lt;/code&gt;是&lt;code&gt;_ContiguousArrayBuffer&lt;/code&gt;初始化方法生成的，看下&lt;code&gt;_ContiguousArrayBuffer&lt;/code&gt;定义&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;// File: ContiguousArrayBuffer.swift, line: 289&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;/// Initialize using the given uninitialized `storage`.&lt;/span&gt;&lt;br/&gt;&lt;span&gt;/// The storage is assumed to be uninitialized. The returned buffer has the&lt;/span&gt;&lt;br/&gt;&lt;span&gt;/// body part of the storage initialized, but not the elements.&lt;/span&gt;&lt;br/&gt;&lt;span&gt;///&lt;/span&gt;&lt;br/&gt;&lt;span&gt;/// - Warning: The result has uninitialized elements.&lt;/span&gt;&lt;br/&gt;&lt;span&gt;/// &lt;/span&gt;&lt;br/&gt;&lt;span&gt;/// - Warning: storage may have been stack-allocated, so it&#x27;s&lt;/span&gt;&lt;br/&gt;&lt;span&gt;///   crucial not to call, e.g., `malloc_size` on it.&lt;/span&gt;&lt;br/&gt;@&lt;span&gt;inlinable&lt;br/&gt;internal &lt;span&gt;init&lt;/span&gt;&lt;span&gt;(count: Int, storage: _ContiguousArrayStorage&amp;lt;Element&amp;gt;)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;  _storage = storage&lt;br/&gt;&lt;br/&gt;  _initStorageHeader(count: count, capacity: count)&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;@inlinable&lt;br/&gt;internal init(_ storage: __ContiguousArrayStorageBase) {&lt;br/&gt;  _storage = storage&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;/// Initialize the body part of our storage.&lt;/span&gt;&lt;br/&gt;&lt;span&gt;///&lt;/span&gt;&lt;br/&gt;&lt;span&gt;/// - Warning: does not initialize elements&lt;/span&gt;&lt;br/&gt;@inlinable&lt;br/&gt;internal func _initStorageHeader(count: Int, capacity: Int) {&lt;br/&gt;#&lt;span&gt;if&lt;/span&gt; _runtime(_ObjC)&lt;br/&gt;  let verbatim = _isBridgedVerbatimToObjectiveC(Element.self)&lt;br/&gt;#&lt;span&gt;else&lt;/span&gt;&lt;br/&gt;  let verbatim = &lt;span&gt;false&lt;/span&gt;&lt;br/&gt;#endif&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;// We can initialize by assignment because _ArrayBody is a trivial type,&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;// i.e. contains no references.&lt;/span&gt;&lt;br/&gt;  _storage.countAndCapacity = _ArrayBody(&lt;br/&gt;    count: count,&lt;br/&gt;    capacity: capacity,&lt;br/&gt;    elementTypeIsBridgedVerbatim: verbatim)&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;code&gt;_ContiguousArrayBuffer&lt;/code&gt;只有一个属性&lt;code&gt;_storage&lt;/code&gt;，初始化方法&lt;code&gt;init(count: Int, storage: _ContiguousArrayStorage&amp;lt;Element&amp;gt;)&lt;/code&gt;中传进来的&lt;code&gt;storage&lt;/code&gt;是&lt;code&gt;_ContiguousArrayStorage&lt;/code&gt;，&lt;code&gt;__ContiguousArrayStorageBase&lt;/code&gt;是&lt;code&gt;_ContiguousArrayStorage&lt;/code&gt;的父类&lt;/p&gt;&lt;p&gt;&lt;code&gt;_ContiguousArrayStorage&lt;/code&gt;&lt;/p&gt;&lt;p&gt;&lt;code&gt;_ContiguousArrayStorage&lt;/code&gt;是&lt;code&gt;class&lt;/code&gt;，查看源码&lt;code&gt;_ContiguousArrayStorage&lt;/code&gt;的继承链，发现只有在&lt;code&gt;__ContiguousArrayStorageBase&lt;/code&gt;有一个属性&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;// File: SwiftNativeNSArray.swift, line: 452&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;br/&gt;@usableFromInline&lt;br/&gt;&lt;span&gt;final&lt;/span&gt; var countAndCapacity: _ArrayBody&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;code&gt;_ArrayBody&lt;/code&gt;是一个结构体，只有一个属性&lt;code&gt;_storage&lt;/code&gt;&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;// File: ArrayBody.swift, line: 20&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;@frozen&lt;br/&gt;@usableFromInline&lt;br/&gt;internal &lt;span&gt;&lt;span&gt;struct&lt;/span&gt; _&lt;span&gt;ArrayBody&lt;/span&gt; {&lt;/span&gt;&lt;br/&gt;  @usableFromInline&lt;br/&gt;  internal var _storage: _SwiftArrayBodyStorage&lt;br/&gt;    &lt;br/&gt; &lt;span&gt;// ...   &lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;那么&lt;code&gt;_SwiftArrayBodyStorage&lt;/code&gt;又是什么？&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;struct&lt;/span&gt; _&lt;span&gt;SwiftArrayBodyStorage&lt;/span&gt; {&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;__swift_intptr_t&lt;/span&gt; count;&lt;br/&gt;  &lt;span&gt;__swift_uintptr_t&lt;/span&gt; _capacityAndFlags;&lt;br/&gt;};&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;很显然&lt;code&gt;_SwiftArrayBodyStorage&lt;/code&gt;仍然是结构体，&lt;code&gt;count&lt;/code&gt;和&lt;code&gt;_capacityAndFlags&lt;/code&gt;都是&lt;code&gt;Swift&lt;/code&gt;中的指针大小，都是8个字节&lt;/p&gt;&lt;h3&gt;&lt;span&gt;&lt;code&gt;_capacityAndFlags&lt;/code&gt;&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;我们继续回到&lt;code&gt;_ContiguousArrayBuffer&lt;/code&gt;初始化方法，当&lt;code&gt;_storage&lt;/code&gt;赋值完以后就调用了&lt;code&gt;_initStorageHeader(count: count, capacity: count)&lt;/code&gt;，看函数名是在初始化&lt;code&gt;count&lt;/code&gt;和&lt;code&gt;capacity&lt;/code&gt;，在&lt;code&gt;_initStorageHeader&lt;/code&gt;方法中看到核心内容&lt;/p&gt;&lt;pre&gt;&lt;code&gt; _storage.countAndCapacity = _ArrayBody(&lt;br/&gt;      count: count,&lt;br/&gt;      capacity: capacity,&lt;br/&gt;      elementTypeIsBridgedVerbatim: verbatim)&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;其实&lt;code&gt;_initStorageHeader&lt;/code&gt;方法就是给&lt;code&gt;_storage&lt;/code&gt;中的&lt;code&gt;countAndCapacity&lt;/code&gt;属性赋值&lt;/p&gt;&lt;p&gt;接下来看&lt;code&gt;_ArrayBody&lt;/code&gt;是如何初始化的&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;// File: ArrayBody.swift, line: 26&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;br/&gt;@&lt;span&gt;inlinable&lt;br/&gt;internal &lt;span&gt;init&lt;/span&gt;&lt;span&gt;(&lt;br/&gt;  count: Int, capacity: Int, elementTypeIsBridgedVerbatim: Bool = &lt;span&gt;false&lt;/span&gt;&lt;br/&gt;)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;  _internalInvariant(count &amp;gt;= &lt;span&gt;0&lt;/span&gt;)&lt;br/&gt;  _internalInvariant(capacity &amp;gt;= &lt;span&gt;0&lt;/span&gt;)&lt;br/&gt;&lt;br/&gt;  _storage = _SwiftArrayBodyStorage(&lt;br/&gt;    count: count,&lt;br/&gt;    _capacityAndFlags:&lt;br/&gt;      (UInt(truncatingIfNeeded: capacity) &amp;amp;&amp;lt;&amp;lt; &lt;span&gt;1&lt;/span&gt;) |&lt;br/&gt;      (elementTypeIsBridgedVerbatim ? &lt;span&gt;1&lt;/span&gt; : &lt;span&gt;0&lt;/span&gt;))&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;我们可以看到&lt;code&gt;count&lt;/code&gt;就是直接传递赋值了，而&lt;code&gt;capacity&lt;/code&gt;（就是属性&lt;code&gt;_capacityAndFlags&lt;/code&gt;）在内存中并不是直接存储的，而是向左1位偏移，然后在多出来的1位数据记录了一个&lt;code&gt;elementTypeIsBridgedVerbatim&lt;/code&gt;的标识&lt;/p&gt;&lt;p&gt;所以如果在内存中读取&lt;code&gt;capacity&lt;/code&gt;的时候，也需要位移操作，这个在&lt;code&gt;_ArrayBody&lt;/code&gt;也有体现&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;// File: ArrayBody.swift, line: 62&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;/// The number of elements that can be stored in this Array without&lt;/span&gt;&lt;br/&gt;&lt;span&gt;/// reallocation.&lt;/span&gt;&lt;br/&gt;@inlinable&lt;br/&gt;internal var capacity: Int {&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; Int(_capacityAndFlags &amp;amp;&amp;gt;&amp;gt; &lt;span&gt;1&lt;/span&gt;)&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3&gt;&lt;span&gt;&lt;code&gt;_ArrayBuffer&lt;/code&gt;&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;到这里&lt;code&gt;innerBuffer&lt;/code&gt;的初始化就读完了，回到主干返回值的生成&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;return&lt;/span&gt; (&lt;br/&gt;    Array(&lt;br/&gt;      _buffer: _Buffer(_buffer: innerBuffer, shiftedToStartIndex: &lt;span&gt;0&lt;/span&gt;)),&lt;br/&gt;      innerBuffer.firstElementAddress)&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;code&gt;Array(_buffer:)&lt;/code&gt;是结构体默认的初始化方法，&lt;code&gt;_Buffer&lt;/code&gt;上面也提到了是&lt;code&gt;_ArrayBuffer&lt;/code&gt;，现在把&lt;code&gt;_ArrayBuffer&lt;/code&gt;的初始化方法结合起来看&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;// File:ArrayBuffer.swift, line: 25&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;@usableFromInline&lt;br/&gt;internal typealias _ArrayBridgeStorage&lt;br/&gt;= _BridgeStorage&amp;lt;__ContiguousArrayStorageBase&amp;gt;&lt;br/&gt;&lt;br/&gt;@usableFromInline&lt;br/&gt;@frozen&lt;br/&gt;internal struct _ArrayBuffer&amp;lt;Element&amp;gt;: _ArrayBufferProtocol {&lt;br/&gt;&lt;span&gt;// ...&lt;/span&gt;&lt;br/&gt;@usableFromInline&lt;br/&gt;internal var _storage: _ArrayBridgeStorage&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;extension _ArrayBuffer {&lt;br/&gt;&lt;span&gt;/// Adopt the storage of `source`.&lt;/span&gt;&lt;br/&gt;@inlinable&lt;br/&gt;internal init(_buffer source: NativeBuffer, shiftedToStartIndex: Int) {&lt;br/&gt;  _internalInvariant(shiftedToStartIndex == &lt;span&gt;0&lt;/span&gt;, &lt;span&gt;&quot;shiftedToStartIndex must be 0&quot;&lt;/span&gt;)&lt;br/&gt;  _storage = _ArrayBridgeStorage(native: source._storage)&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;/// `true`, if the array is native and does not need a deferred type check.&lt;/span&gt;&lt;br/&gt;@inlinable&lt;br/&gt;internal var arrayPropertyIsNativeTypeChecked: Bool {&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; _isNativeTypeChecked&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// File: BridgeStorage.swift, line: 57&lt;/span&gt;&lt;br/&gt;@frozen&lt;br/&gt;@usableFromInline&lt;br/&gt;internal struct _BridgeStorage&amp;lt;NativeClass: AnyObject&amp;gt; {&lt;br/&gt;  @inlinable&lt;br/&gt;  @&lt;span&gt;inline&lt;/span&gt;(__always)&lt;br/&gt;  internal init(objC: ObjC) {&lt;br/&gt;    _internalInvariant(_usesNativeSwiftReferenceCounting(NativeClass.self))&lt;br/&gt;    rawValue = _makeObjCBridgeObject(objC)&lt;br/&gt;  }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;从代码看就是结构体只有一个属性，然后就是属性赋值操作，&lt;code&gt;shiftedToStartIndex&lt;/code&gt;传入的0对我们的查找需求也没有影响就是一个简单判断&lt;/p&gt;&lt;p&gt;所以总结就是&lt;code&gt;%7&lt;/code&gt;就是&lt;code&gt;_ArrayBuffer&lt;/code&gt;的结构体，里面的属性存放了&lt;code&gt;_ContiguousArrayStorage&lt;/code&gt;的实例类对象&lt;/p&gt;&lt;p&gt;&lt;code&gt;firstElementAddress&lt;/code&gt;&lt;/p&gt;&lt;p&gt;现在继续查&lt;code&gt;SIL&lt;/code&gt;文件下的&lt;code&gt;%8&lt;/code&gt;，也就是&lt;code&gt;innerBuffer.firstElementAddress&lt;/code&gt;&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;// File: ContigyousArrayBuffer.swift&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;/// A pointer to the first element.&lt;/span&gt;&lt;br/&gt;@inlinable&lt;br/&gt;internal var firstElementAddress: UnsafeMutablePointer&amp;lt;Element&amp;gt; {&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; UnsafeMutablePointer(Builtin.projectTailElems(_storage,&lt;br/&gt;                                                       Element.self))&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;code&gt;Builtin&lt;/code&gt;是编译器内置命令的调用，不好查看，我们看下注释&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;// File: Builtins.def, line: 465&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;/// projectTailElems : &amp;lt;C,E&amp;gt; (C) -&amp;gt; Builtin.RawPointer&lt;/span&gt;&lt;br/&gt;&lt;span&gt;///&lt;/span&gt;&lt;br/&gt;&lt;span&gt;/// Projects the first tail-allocated element of type E from a class C.&lt;/span&gt;&lt;br/&gt;BUILTIN_SIL_OPERATION(ProjectTailElems, &lt;span&gt;&quot;projectTailElems&quot;&lt;/span&gt;, Special)&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;所以&lt;code&gt;projectTailElems&lt;/code&gt;方法的作用是返回&lt;code&gt;_storage&lt;/code&gt;分配空间的尾部元素第一个地址，这样推测下来，数组的元素的存储位置就在&lt;code&gt;_ContiguousArrayStorage&lt;/code&gt;内容的后面&lt;/p&gt;&lt;p&gt;验证&lt;code&gt;Array&lt;/code&gt;的底层结构&lt;/p&gt;&lt;p&gt;还是文章开头的代码&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;var&lt;/span&gt; num: &lt;span&gt;Array&lt;/span&gt;&amp;lt;&lt;span&gt;Int&lt;/span&gt;&amp;gt; = [&lt;span&gt;1&lt;/span&gt;, &lt;span&gt;2&lt;/span&gt;, &lt;span&gt;3&lt;/span&gt;]&lt;br/&gt;&lt;span&gt;withUnsafePointer&lt;/span&gt;(to: &amp;amp;num) {&lt;br/&gt;    &lt;span&gt;print&lt;/span&gt;($&lt;span&gt;0&lt;/span&gt;)&lt;br/&gt;}&lt;br/&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;end&quot;&lt;/span&gt;)&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;在&lt;code&gt;print(&quot;end&quot;)&lt;/code&gt;打上断点，输出下&lt;code&gt;num&lt;/code&gt;的内存&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;0x0000000100008060&lt;/span&gt;&lt;br/&gt;(lldb) x/&lt;span&gt;8&lt;/span&gt;g &lt;span&gt;0x0000000100008060&lt;/span&gt;&lt;br/&gt;&lt;span&gt;0x100008060&lt;/span&gt;: &lt;span&gt;0x000000010064b8d0&lt;/span&gt; &lt;span&gt;0x0000000000000000&lt;/span&gt;&lt;br/&gt;&lt;span&gt;0x100008070&lt;/span&gt;: &lt;span&gt;0x0000000000000000&lt;/span&gt; &lt;span&gt;0x0000000000000000&lt;/span&gt;&lt;br/&gt;&lt;span&gt;0x100008080&lt;/span&gt;: &lt;span&gt;0x0000000000000000&lt;/span&gt; &lt;span&gt;0x0000000000000000&lt;/span&gt;&lt;br/&gt;&lt;span&gt;0x100008090&lt;/span&gt;: &lt;span&gt;0x0000000000000000&lt;/span&gt; &lt;span&gt;0x0000000000000000&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;code&gt;0x000000010064b8d0&lt;/code&gt;就是&lt;code&gt;_ContiguousArrayStorage&lt;/code&gt;的引用，再继续输出&lt;code&gt;0x000000010064b8d0&lt;/code&gt;的内存&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;0x0000000100008060&lt;/span&gt;&lt;br/&gt;(lldb) x/&lt;span&gt;8&lt;/span&gt;g &lt;span&gt;0x0000000100008060&lt;/span&gt;&lt;br/&gt;&lt;span&gt;0x100008060&lt;/span&gt;: &lt;span&gt;0x000000010064b8d0&lt;/span&gt; &lt;span&gt;0x0000000000000000&lt;/span&gt;&lt;br/&gt;&lt;span&gt;0x100008070&lt;/span&gt;: &lt;span&gt;0x0000000000000000&lt;/span&gt; &lt;span&gt;0x0000000000000000&lt;/span&gt;&lt;br/&gt;&lt;span&gt;0x100008080&lt;/span&gt;: &lt;span&gt;0x0000000000000000&lt;/span&gt; &lt;span&gt;0x0000000000000000&lt;/span&gt;&lt;br/&gt;&lt;span&gt;0x100008090&lt;/span&gt;: &lt;span&gt;0x0000000000000000&lt;/span&gt; &lt;span&gt;0x0000000000000000&lt;/span&gt;&lt;br/&gt;(lldb) x/&lt;span&gt;8&lt;/span&gt;g &lt;span&gt;0x000000010064b8d0&lt;/span&gt;&lt;br/&gt;&lt;span&gt;0x10064b8d0&lt;/span&gt;: &lt;span&gt;0x000000020dfaf140&lt;/span&gt; &lt;span&gt;0x0000000000000003&lt;/span&gt;&lt;br/&gt;&lt;span&gt;0x10064b8e0&lt;/span&gt;: &lt;span&gt;0x0000000000000003&lt;/span&gt; &lt;span&gt;0x0000000000000006&lt;/span&gt;&lt;br/&gt;&lt;span&gt;0x10064b8f0&lt;/span&gt;: &lt;span&gt;0x0000000000000001&lt;/span&gt; &lt;span&gt;0x0000000000000002&lt;/span&gt;&lt;br/&gt;&lt;span&gt;0x10064b900&lt;/span&gt;: &lt;span&gt;0x0000000000000003&lt;/span&gt; &lt;span&gt;0x0000000000000000&lt;/span&gt;&lt;br/&gt;(lldb) &lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;验证成功✅&lt;/p&gt;&lt;h2&gt;&lt;span&gt;扩展&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;h3&gt;&lt;span&gt;&lt;code&gt;Array&lt;/code&gt;的写时复制&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;写时复制：只有需要改变的时候，才会对变量进行复制，如果不改变，数据共用一个内存&lt;/p&gt;&lt;p&gt;在&lt;code&gt;Swift&lt;/code&gt;标注库中，像集合类对象&lt;code&gt;Array&lt;/code&gt;,&lt;code&gt;Dictionary&lt;/code&gt;和&lt;code&gt;Set&lt;/code&gt;时通过写时复制&lt;code&gt;copy-on-write&lt;/code&gt;的技术实现的&lt;/p&gt;&lt;p&gt;我们查看下源码，依然是写测试代码&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;var&lt;/span&gt; num: &lt;span&gt;Array&lt;/span&gt;&amp;lt;&lt;span&gt;Int&lt;/span&gt;&amp;gt; = [&lt;span&gt;1&lt;/span&gt;, &lt;span&gt;2&lt;/span&gt;, &lt;span&gt;3&lt;/span&gt;]&lt;br/&gt;&lt;span&gt;var&lt;/span&gt; copyNum = num&lt;br/&gt;num.append(&lt;span&gt;4&lt;/span&gt;)&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;然后在&lt;code&gt;append&lt;/code&gt;处打上断点&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;// File: ArraySlice.swift, line: 919&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;br/&gt;@inlinable&lt;br/&gt;@_semantics(&lt;span&gt;&quot;array.append_element&quot;&lt;/span&gt;)&lt;br/&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; mutating func &lt;span&gt;append&lt;/span&gt;&lt;span&gt;(_ newElement: __owned Element)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;  _makeUniqueAndReserveCapacityIfNotUnique()&lt;br/&gt;  let oldCount = _getCount()&lt;br/&gt;  _reserveCapacityAssumingUniqueBuffer(oldCount: oldCount)&lt;br/&gt;  _appendElementAssumeUniqueAndCapacity(oldCount, newElement: newElement)&lt;br/&gt;  _endMutation()&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;一共调用了3个方法，我们依次看下&lt;/p&gt;&lt;p&gt;&lt;code&gt;_makeUniqueAndReserveCapacityIfNotUnique()&lt;/code&gt;，直接翻译函数名，如果该数组不是唯一的，那么使得成为唯一并且保留容量，那么这个唯一是什么意思？，这里断点深，只看关键代码&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;// File: RefCount.h, line: 606&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// Compiler is clever enough to optimize this.&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt;&lt;br/&gt;    !getUseSlowRC() &amp;amp;&amp;amp; !getIsDeiniting() &amp;amp;&amp;amp; getStrongExtraRefCount() == &lt;span&gt;0&lt;/span&gt;;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这些都是引用计数的判断，最主要的是&lt;code&gt;getStrongExtraRefCount&lt;/code&gt;强引用计数是否为0，如果不是0的话不是唯一的，所以这里的唯一是指对这块空间的唯一引用；如果不唯一会如何处理&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;// File: Array.swift, line: 1099&lt;/span&gt;&lt;br/&gt;  @inlinable&lt;br/&gt;  @_semantics(&lt;span&gt;&quot;array.make_mutable&quot;&lt;/span&gt;)&lt;br/&gt;  internal mutating func _makeUniqueAndReserveCapacityIfNotUnique() {&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; _slowPath(!_buffer.beginCOWMutation()) {&lt;br/&gt;      _createNewBuffer(bufferIsUnique: &lt;span&gt;false&lt;/span&gt;,&lt;br/&gt;                       minimumCapacity: count + &lt;span&gt;1&lt;/span&gt;,&lt;br/&gt;                       growForAppend: &lt;span&gt;true&lt;/span&gt;)&lt;br/&gt;    }&lt;br/&gt;  }&lt;br/&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// File: Array.swift, line: 1069&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;/// Creates a new buffer, replacing the current buffer.&lt;/span&gt;&lt;br/&gt;&lt;span&gt;///&lt;/span&gt;&lt;br/&gt;&lt;span&gt;/// If `bufferIsUnique` is true, the buffer is assumed to be uniquely&lt;/span&gt;&lt;br/&gt;&lt;span&gt;/// referenced by this array and the elements are moved - instead of copied -&lt;/span&gt;&lt;br/&gt;&lt;span&gt;/// to the new buffer.&lt;/span&gt;&lt;br/&gt;&lt;span&gt;/// The `minimumCapacity` is the lower bound for the new capacity.&lt;/span&gt;&lt;br/&gt;&lt;span&gt;/// If `growForAppend` is true, the new capacity is calculated using&lt;/span&gt;&lt;br/&gt;&lt;span&gt;/// `_growArrayCapacity`, but at least kept at `minimumCapacity`.&lt;/span&gt;&lt;br/&gt;@_alwaysEmitIntoClient&lt;br/&gt;internal mutating func _createNewBuffer(&lt;br/&gt;  bufferIsUnique: Bool, minimumCapacity: Int, growForAppend: Bool&lt;br/&gt;) {&lt;br/&gt;  _internalInvariant(!bufferIsUnique || _buffer.isUniquelyReferenced())&lt;br/&gt;  _buffer = _buffer._consumeAndCreateNew(bufferIsUnique: bufferIsUnique,&lt;br/&gt;                                         minimumCapacity: minimumCapacity,&lt;br/&gt;                                         growForAppend: growForAppend)&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// File: ArrayBuffer.swift, line: 162&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;/// Creates and returns a new uniquely referenced buffer which is a copy of&lt;/span&gt;&lt;br/&gt;&lt;span&gt;/// this buffer.&lt;/span&gt;&lt;br/&gt;&lt;span&gt;///&lt;/span&gt;&lt;br/&gt;&lt;span&gt;/// This buffer is consumed, i.e. it&#x27;s released.&lt;/span&gt;&lt;br/&gt;@_alwaysEmitIntoClient&lt;br/&gt;@&lt;span&gt;inline&lt;/span&gt;(never)&lt;br/&gt;@_semantics(&lt;span&gt;&quot;optimize.sil.specialize.owned2guarantee.never&quot;&lt;/span&gt;)&lt;br/&gt;internal __consuming func _consumeAndCreateNew() -&amp;gt; _ArrayBuffer {&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; _consumeAndCreateNew(bufferIsUnique: &lt;span&gt;false&lt;/span&gt;,&lt;br/&gt;                              minimumCapacity: count,&lt;br/&gt;                              growForAppend: &lt;span&gt;false&lt;/span&gt;)&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;/// Creates and returns a new uniquely referenced buffer which is a copy of&lt;/span&gt;&lt;br/&gt;&lt;span&gt;/// this buffer.&lt;/span&gt;&lt;br/&gt;&lt;span&gt;///&lt;/span&gt;&lt;br/&gt;&lt;span&gt;/// If `bufferIsUnique` is true, the buffer is assumed to be uniquely&lt;/span&gt;&lt;br/&gt;&lt;span&gt;/// referenced and the elements are moved - instead of copied - to the new&lt;/span&gt;&lt;br/&gt;&lt;span&gt;/// buffer.&lt;/span&gt;&lt;br/&gt;&lt;span&gt;/// The `minimumCapacity` is the lower bound for the new capacity.&lt;/span&gt;&lt;br/&gt;&lt;span&gt;/// If `growForAppend` is true, the new capacity is calculated using&lt;/span&gt;&lt;br/&gt;&lt;span&gt;/// `_growArrayCapacity`, but at least kept at `minimumCapacity`.&lt;/span&gt;&lt;br/&gt;&lt;span&gt;///&lt;/span&gt;&lt;br/&gt;&lt;span&gt;/// This buffer is consumed, i.e. it&#x27;s released.&lt;/span&gt;&lt;br/&gt;@_alwaysEmitIntoClient&lt;br/&gt;@&lt;span&gt;inline&lt;/span&gt;(never)&lt;br/&gt;@_semantics(&lt;span&gt;&quot;optimize.sil.specialize.owned2guarantee.never&quot;&lt;/span&gt;)&lt;br/&gt;internal __consuming func _consumeAndCreateNew(&lt;br/&gt;  bufferIsUnique: Bool, minimumCapacity: Int, growForAppend: Bool&lt;br/&gt;) -&amp;gt; _ArrayBuffer {&lt;br/&gt;  let newCapacity = _growArrayCapacity(oldCapacity: capacity,&lt;br/&gt;                                       minimumCapacity: minimumCapacity,&lt;br/&gt;                                       growForAppend: growForAppend)&lt;br/&gt;  let c = count&lt;br/&gt;  _internalInvariant(newCapacity &amp;gt;= c)&lt;br/&gt;&lt;br/&gt;  let newBuffer = _ContiguousArrayBuffer&amp;lt;Element&amp;gt;(&lt;br/&gt;    _uninitializedCount: c, minimumCapacity: newCapacity)&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;if&lt;/span&gt; bufferIsUnique {&lt;br/&gt;    &lt;span&gt;// As an optimization, if the original buffer is unique, we can just move&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;// the elements instead of copying.&lt;/span&gt;&lt;br/&gt;    let dest = newBuffer.firstElementAddress&lt;br/&gt;    dest.moveInitialize(from: mutableFirstElementAddress,&lt;br/&gt;                        count: c)&lt;br/&gt;    _native.mutableCount = &lt;span&gt;0&lt;/span&gt;&lt;br/&gt;  } &lt;span&gt;else&lt;/span&gt; {&lt;br/&gt;    _copyContents(&lt;br/&gt;      subRange: &lt;span&gt;0.&lt;/span&gt;.&amp;lt;c,&lt;br/&gt;      initializing: newBuffer.mutableFirstElementAddress)&lt;br/&gt;  }&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; _ArrayBuffer(_buffer: newBuffer, shiftedToStartIndex: &lt;span&gt;0&lt;/span&gt;)&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;我们可以清楚地看到会调用&lt;code&gt;_createNewBuffer&lt;/code&gt;方法，而&lt;code&gt;_createNewBuffer&lt;/code&gt;方法根据一个条件判断去调用&lt;code&gt;_buffer&lt;/code&gt;的&lt;code&gt;_consumeAndCreateNew&lt;/code&gt;方法，这个方法就会生成一个新的&lt;code&gt;buffer&lt;/code&gt;&lt;/p&gt;&lt;pre&gt;&lt;code&gt;let newBuffer = _ContiguousArrayBuffer&amp;lt;Element&amp;gt;(&lt;br/&gt;    _uninitializedCount: c, minimumCapacity: newCapacity)&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;相当于开辟了一个新的堆空间用于被修改后的数组，所以写时复制的本质就是查看&lt;code&gt;_ContiguousArrayStorage&lt;/code&gt;的强引用计数&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;新创建一个数组&lt;code&gt;num&lt;/code&gt;，&lt;code&gt;_ContiguousArrayStorage&lt;/code&gt;强引用计数是0&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;此刻&lt;code&gt;num&lt;/code&gt;添加元素，发现&lt;code&gt;_ContiguousArrayStorage&lt;/code&gt;的强引用计数是0，说明自己时唯一的引用，所以直接空间末尾添加元素就行&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;当用&lt;code&gt;copyNum&lt;/code&gt;复制数组&lt;code&gt;num&lt;/code&gt;时，不过是把&lt;code&gt;num&lt;/code&gt;的&lt;code&gt;_ContiguousArrayStorage&lt;/code&gt;复制给了&lt;code&gt;copyNum&lt;/code&gt;，&lt;code&gt;copyNum&lt;/code&gt;的&lt;code&gt;_ContiguousArrayStorage&lt;/code&gt;与&lt;code&gt;num&lt;/code&gt;的&lt;code&gt;_ContiguousArrayStorage&lt;/code&gt;的是同一个，不过&lt;code&gt;_ContiguousArrayStorage&lt;/code&gt;的强引用计数变为1了，因为这里没有开辟新的空间，非常节省空间&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;此刻数组&lt;code&gt;num&lt;/code&gt;再次添加元素，发现&lt;code&gt;_ContiguousArrayStorage&lt;/code&gt;的强引用计数为1，不为0，说明自己不是唯一引用，开辟新的空间，新建一个&lt;code&gt;_ContiguousArrayStorage&lt;/code&gt;，复制原有数组内容到新的空间&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;验证结论，输入以下代码&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;var&lt;/span&gt; num: &lt;span&gt;Array&lt;/span&gt;&amp;lt;&lt;span&gt;Int&lt;/span&gt;&amp;gt; = [&lt;span&gt;1&lt;/span&gt;, &lt;span&gt;2&lt;/span&gt;, &lt;span&gt;3&lt;/span&gt;]&lt;br/&gt;&lt;span&gt;withUnsafePointer&lt;/span&gt;(to: &amp;amp;num) {&lt;br/&gt;    &lt;span&gt;print&lt;/span&gt;($&lt;span&gt;0&lt;/span&gt;)&lt;br/&gt;}&lt;br/&gt;&lt;span&gt;var&lt;/span&gt; copyNum = num&lt;br/&gt;num.append(&lt;span&gt;4&lt;/span&gt;)&lt;br/&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;end&quot;&lt;/span&gt;)&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;分别在&lt;code&gt;var copyNum = num&lt;/code&gt;，&lt;code&gt;num.append(4)&lt;/code&gt;和&lt;code&gt;print(&quot;end&quot;)&lt;/code&gt;打上断点&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.7171875&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/qMicvibdvl7p2Z6yyGHib8LlMm1yuBcESJmv5SUBqef0CcdZl8d7ricGKXEibnAhdRDxcicwGBgcSfibITzWJubOQB7HA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;figure&gt;&lt;br/&gt;&lt;/figure&gt;&lt;h3&gt;&lt;span&gt;总结&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;&lt;code&gt;Swift&lt;/code&gt;的数组虽然是&lt;code&gt;Struct&lt;/code&gt;类型，但是数组的存放还是在堆空间&lt;/p&gt;&lt;p&gt;&lt;code&gt;Swift&lt;/code&gt;的数组的写时复制特性是根据堆空间的强引用计数是否唯一，而唯一的判断强引用计数是否等于0，如果不等于0才会去开辟新的空间进行存储&lt;/p&gt;&lt;h2&gt;&lt;span&gt;参考文档&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;NSMutableArray原理揭露：http://blog.joyingx.me/2015/05/03/NSMutableArray%20%E5%8E%9F%E7%90%86%E6%8F%AD%E9%9C%B2/)&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;探索Swift中Array的底层实现：https://juejin.cn/post/6931236309176418311&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;453&quot; data-backw=&quot;1080&quot; data-ratio=&quot;0.41944444444444445&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/qMicvibdvl7p3cD9ODoZjicUHhYiaoa7JwAVxibNKVTL7VfFNiatt4icU6ic0v19QGNk3KGiaib92CYhIjH05ZX8NDfUSWgQ/640?wx_fmt=jpegwxfrom=5wx_lazy=1wx_co=1&quot; data-type=&quot;jpegwxfrom=5wx_lazy=1wx_co=1&quot; data-w=&quot;1080&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;mp-style-type data-value=&quot;3&quot;/&gt;&lt;/p&gt;&lt;/div&gt;

          
        &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>1856818b93a96c0e6715c0c8706d4a4f</guid>
<title>MySQL 主从模式采用 GTID 的实践</title>
<link>https://toutiao.io/k/owbwcqm</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;你好，我是悟空。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;本文主要内容如下：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.3470319634703196&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/SfAHMuUxqJ0y0kbmE8yz1AjZ9Z2rFCbibQxxhoQjg1QXxBm0NRoM7Oozxb3NIoHNAbxbHVd401nO6xGhw2Nna9g/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1752&quot;/&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;一、背景&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;为了保证高可用，之前在测试环境部署了一套 MySQL 双主模式，当一个主库服务出现异常，可以将流量切到另外一个主库，两个主库之间相互同步数据。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;双主模式&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;双主模式的原理图如下：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1.1875&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/SfAHMuUxqJ34ZChbvlXiakQocdWlE76ddF3osUryJ4DMh6KfMBrXxoPtxVkTV0BibypzY8P9lZCampKTKzeuSYNg/640?wx_fmt=png&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; data-type=&quot;png&quot; data-w=&quot;896&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但是经常出现数据冲突的问题，于是我们又把&lt;code&gt;双主模式&lt;/code&gt;改为了&lt;code&gt;主从读写分离模式&lt;/code&gt;。主库作为读写库，再加上一个从库用来做 &lt;span&gt;I/O 密集型&lt;/span&gt;的任务（如大量的数据统计操作）。如下图所示：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.4051094890510949&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/SfAHMuUxqJ0tibFY1Ml1mCQQQ5mABVZtGE5bL9H5OvrBjC7OWkVbgvTSXxcJ4lGcKRy1riaMQ4uKMDic4AlDibZyLQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1096&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;另外从库复制的模式采用&lt;code&gt;位点&lt;/code&gt;的方式：指定 binlog 文件和 binlog 位置，这样从库就知道了复制的起始位置。(下文会讲解这种方式）&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;虽然改为了主从模式，但依旧遇到了些问题：&lt;/span&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;问题 1&lt;/span&gt;：从库 B 复制数据时，出现了主键冲突问题，导致同步失败，从库停止复制。猜测因主库配置的 binlog 日志的格式为 &lt;code&gt;mixed&lt;/code&gt;，从库同步时出现不一致的情况。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;问题 2&lt;/span&gt;：从库 B 停止复制后，导致很多数据未同步到从库，出现主从大量数据不一致的情况。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;问题 3&lt;/span&gt;：从库 B 想要恢复复制，必须先解决同步失败的问题才能恢复。排查难度较大，耗时。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;问题 4&lt;/span&gt;：从库 B 恢复时，必须知道同步&lt;span&gt;位点&lt;/span&gt;，也就是从哪个 binlog 文件和 binlog 位置断开复制的，且即使找到了位点，也不是精确的。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;问题 5&lt;/span&gt;：从库 B 因同步异常导致停止复制到恢复复制这段期间，主库 A 自动清理了几天前的 binlog 日志，而这些日志从库 B 还未来得及同步，进而导致再次同步失败。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;问题 6&lt;/span&gt;：主从存在同步延迟。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这篇我们来探讨下问题 4 和问题 6。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其中&lt;strong&gt;问题 4&lt;/strong&gt; 是一个比较头疼的问题，我们一般是通过查看从库 B 当前的同步状态拿到同步位点，然后设置同步位点后。但是重新启动同步的时候又会出现同步异常，比如从库 B 可能会出现 Duplicate entry ‘id_of_R’ for key ‘PRIMARY’ 错误，提示出现了主键冲突，然后停止同步。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;为了减少位点同步引入的复杂度，我们切换成了 GTID 模式。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;对于&lt;strong&gt;问题 6&lt;/strong&gt;，本篇也仅限于探讨如何观察延迟，对于如何减少延迟不在本篇探讨范围之内。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;接下来我们来展开看下位点同步的痛点。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;二、位点同步的痛点&lt;/span&gt;&lt;/h2&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;2.1 通过位点同步的原理图&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;为了更清晰地理解主从采用位点同步的原理，这里有一个原理图：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1.0513761467889908&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/SfAHMuUxqJ0y0kbmE8yz1AjZ9Z2rFCbib8mmtZuLRkFYYKNz1P8IZtvL06ogsl4rxTDicPkfeibS3ZUZqH5AJO6PA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1090&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;1、&lt;/strong&gt;主库会生成多个 binlog 日志文件。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;2、&lt;/strong&gt;从库的I/O 线程请求指定文件和指定位置的 binlog 日志文件（位点）。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;3、&lt;/strong&gt;主库 dump 线程获取指定位点的 binlog 日志。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;4、&lt;/strong&gt;主库按照从库发送给来的位点信息读取 binlog，然后推送 binlog 给从库。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;5、&lt;/strong&gt;从库将得到的 binlog 写到本地的 relay log (中继日志) 文件中。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;6、&lt;/strong&gt;从库的 SQL 线程读取和解析 relay log 文件。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;7、&lt;/strong&gt;从库的 SQL 线程重放 relay log 中的命令。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当我们使用位点同步的方式时，两种场景下的操作步骤比较复杂。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;2.2 痛点&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;痛点1：首次开启主从复制的步骤复杂&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;第一次开启主从同步时，要求从库和主库是一致的。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;找到主库的 binlog 位点。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;设置从库的 binlog 位点。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;开启从库的复制线程。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;痛点2：恢复主从复制的步骤复杂&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;找到从库复制线程停止时的位点。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;解决复制异常的事务。无法解决时就需要手动跳过指定类型的错误，比如通过设置slave_skip_errors=1032,1062。当然这个前提条件是跳过这类错误是无损的。（1062 错误是插入数据时唯一键冲突；1032 错误是删除数据时找不到行）&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;不论是首次开启同步时需要找位点和设置位点，还是恢复主从复制时，设置位点和忽略错误，&lt;span&gt;这些步骤都显得过于复杂，而且容易出错&lt;/span&gt;。所以 MySQL 5.6 版本引入了 GTID，彻底解决了这个困难。&lt;/p&gt;&lt;/blockquote&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;三、GTID 方案&lt;/span&gt;&lt;/h2&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;3.1 GTID 是什么？&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;GTID 的全称是 Global Transaction Identifier，全局事务 ID，当一个事务提交时，就会生成一个 GTID，相当于事务的唯一标识。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;GTID 长这样：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;c5d74746-d7ec-11ec-bf8f-0242ac110002:1&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;结构：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;GTID=server_uuid:gno&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;server_uuid 是一个实例第一次启动时自动生成的，是一个全局唯一的值；&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;gno 是一个整数，初始值是 1，每次提交事务的时候分配给这个事务，并加 1。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;每个 MySQL 实例都维护了一个 GTID 集合，用来对应“这个实例执行过的所有事务”。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;3.2 GTID 的优势&lt;/span&gt;&lt;/h3&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;1、更简单的实现 failover，不用以前那样在需要找位点（log_file 和 log_pos）。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;2、更简单的搭建主从复制。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;3、比传统的复制更加安全。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;4、GTID是连续的没有空洞的，保证数据的一致性，零丢失。&lt;span/&gt;&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/section&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;3.3 如何启用 GTID&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;修改主库和从库的配置文件：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;#GTID:&lt;/span&gt;&lt;br/&gt;gtid_mode=on&lt;br/&gt;enforce_gtid_consistency=on&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;从库配置同步的参数：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;CHANGE MASTER TO &lt;br/&gt;MASTER_HOST=&lt;span&gt;$host_name&lt;/span&gt; &lt;br/&gt;MASTER_PORT=&lt;span&gt;$port&lt;/span&gt; &lt;br/&gt;MASTER_USER=&lt;span&gt;$user_name&lt;/span&gt; &lt;br/&gt;MASTER_PASSWORD=&lt;span&gt;$password&lt;/span&gt; &lt;br/&gt;master_auto_position=1 &lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其中 master_auto_position 标识主从关系使用的 GTID 协议。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;相比之前的配置，&lt;span&gt;MASTER_LOG_FILE 和 MASTER_LOG_POS 参数已经不需要了&lt;/span&gt;。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;3.4 GTID 同步方案&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;GTID 同步的原理图。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;&lt;span&gt;GTID 方案&lt;/span&gt;：主库计算主库 GTID 集合和从库 GTID 的集合的差集，主库推送差集 binlog 给从库。&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当从库设置完同步参数后，主库 A 的GTID 集合记为集合 x，从库 B 的 GTID 集合记为 y。从库同步的逻辑如下：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1.0510046367851622&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/SfAHMuUxqJ0y0kbmE8yz1AjZ9Z2rFCbibxMMj4P6OqEVX92vsZbLcMf8iacasnU9sZxh5mY8iaWwRGAdZQ4NVrPzA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1294&quot;/&gt;&lt;/figure&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;从库 B 指定主库 A，基于主备协议简历连接。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;从库 B 把集合 y 发给主库 A。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;主库 A 计算出集合 x 和集合 y 的差集，也就是集合 x 中存在，集合 y 中不存在的 GTID 集合。比如集合 x 是 1~100，集合 y 是 1~90，那么这个差集就是 91~100。这里会判断集合 x 是不是包含有集合 y 的所有 GTID，如果不是则说明主库 A 删除了从库 B 需要的 binlog，主库 A 直接返回错误。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;主库 A 从自己的 binlog 文件里面，找到第一个不在集合 y 中的事务 GTID，也就是找到了 91。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;主库 A 从 GTID = 91 的事务开始，往后读 binlog 文件，按顺序取 binlog，然后发给 B。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;从库 B 的 I/O 线程读取 binlog 文件生成 relay log，SQL 线程解析 relay log，然后执行 SQL 语句。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;GTID 同步方案和位点同步的方案区别是：&lt;/strong&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;位点同步方案是通过人工在从库上指定哪个位点，主库就发哪个位点，不做日志的完整性判断。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;而 GTID 方案是通过主库来自动计算位点的，不需要人工去设置位点，对运维人员友好。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;四、如何判断主从库是否有延迟&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上面提到的问题 6 是主从读写分离后，从库复制存在延迟，接下来我们来探讨下如何观察主从延迟多少的问题。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;方案一：判断从库的同步状态参数 seconds_behind_master 是否为 0。（不准确）&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;方案二：对比位点确保主备无延迟。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;方案三：对比 GTID 集合确保主备无延迟。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;方案一：查看 seconds_behind_master&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可以在从库上执行 slow slave status 命令来看执行结果里面的 &lt;code&gt;seconds_behind_master&lt;/code&gt; 参数的值，如下图所示，Seconds_Behind_Master 等于 0&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.3241252302025783&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/SfAHMuUxqJ0y0kbmE8yz1AjZ9Z2rFCbib5zORALpPyiaoibx58icFTubicaO0fIWVzUgaFibPIWI8Ig6t7eyB6RssWNw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;543&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Seconds_Behind_Master 的单位是秒，所以精度不准确。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以为了保证查询的数据是和主库一致的，就需要先判断 seconds_behind_master 是否已经等于 0，如果不等于 0，就必须等到这个参数变为 0 才能执行查询请求。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;方案二：对比位点&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可以通过查看从库当前的同步位点来确认从库同步是否有延迟。下图是在从库上执行 &lt;code&gt;show slave status \G&lt;/code&gt;命令后的结果：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6237288135593221&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/SfAHMuUxqJ0y0kbmE8yz1AjZ9Z2rFCbibAGHsZXtrS9Kv8ySjbmeq6abW020dXUpqGwU568RxBgkpUDZ9xkb5TA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1180&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;Master_Log_File&lt;/code&gt; 和 &lt;code&gt;Read_Master_Log_Pos&lt;/code&gt; 这两个参数合起来表示的是读到的主库的最新位点，第一参数是代表读取到了哪个文件，第二个是读取到的文件的位置。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;Relay_Master_Log_File&lt;/code&gt; 和 &lt;code&gt;Exec_Master_Log_Pos&lt;/code&gt;，这两个参数合起来表示的是从库执行的最新位点。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果红色框起来的两个参数：&lt;code&gt;Master_Log_File&lt;/code&gt; 和 &lt;code&gt;Relay_Master_Log_File&lt;/code&gt; 相等，则说明从库读到的最新文件和主库上生成的文件相同，这里都是 mysql-bin.000934。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果蓝色框起来的两个参数 &lt;code&gt;Read_Master_Log_Pos&lt;/code&gt; 和 &lt;code&gt;Exec_Master_Log_Pos&lt;/code&gt; 相等，则说明从库读到的日志文件的位置和从库上执行日志文件的位置相同，这里都是 59521082。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当上面两组参数都相等时，则说明没有延迟。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;方案三：对比 GTID 集合&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;方案三是对比 GTID 集合。首先我们在从库上执行  &lt;code&gt;show slave status \G&lt;/code&gt;来查看 GTID 集合。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如下图所示：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.3654970760233918&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/SfAHMuUxqJ0y0kbmE8yz1AjZ9Z2rFCbibicePBvx54LqrogZqFZQYzA5UQgibEI00Nic2l2QYXMbn0NiaE4HlhsjdPg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1026&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;Master_UUID&lt;/code&gt; 表示当前连接的主库的 ID。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;Auto_Position&lt;/code&gt;: 1 表示主备使用了 GTID 协议。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;Retrieved_Gtid_Set&lt;/code&gt; 表示从库收到的所有日志的 GTID 集合。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;Executed_Gtid_Set&lt;/code&gt; 表示从库已经执行完成的 GTID 集合。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果 Executed_Gtid_Set 集合是包含 Retrieved_Gtid_Set，则表示从库接收到的日志已经同步完成。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;比如上图中 &lt;code&gt;Retrieved_Gtid_Set&lt;/code&gt; 值为&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;c5d74746-d7ec-11ec-bf8f-0242ac110002:1-87323&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;前面一段是主库 id，后面一段 1-87383 是 GTID 范围。而&lt;code&gt;Executed_Gtid_Set&lt;/code&gt; 的值有两个集合&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;7083ae1f-d7ef-11ec-a329-0242ac110002:1-2,&lt;br/&gt;c5d74746-d7ec-11ec-bf8f-0242ac110002:1-87323&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;Executed_Gtid_Set&lt;/code&gt; 的第二个集合和第一个集合完全一致，第一个集合 id 和 集合范围是上次同步另外一个主库的记录。这里说明从库已经和当前主库同步完成了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;方案二对比位点和方案三的 GTID 比对都要比方案一的&lt;code&gt;seconds_behind_master&lt;/code&gt; 更准确。但是还是没有达到精确的程度，需要配合半同步复制（semi-sync replication）才能达到。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;小结：本篇通过 GTID 的方式更好地实现了主从节点的同步，以及如何观察主从同步的延迟。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;参考资料：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;www.passjava.cn&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;https://time.geekbang.org/column/article/77636&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;高性能 MySQL 第四版&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;千金良方：MySQL性能优化金字塔法则&lt;/p&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>