<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>3e41fae7422a55dabe67615a552a58e4</guid>
<title>常用 Shell 分析服务器日志命令，运维快收藏</title>
<link>https://toutiao.io/k/y451jnx</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content             autoTypeSetting24psection&quot; id=&quot;js_content&quot;&gt;&lt;section&gt;&lt;section data-tools=&quot;新媒体管家&quot; data-label=&quot;powered by xmt.cn&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.11310592459605028&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/yNKv1P4Q9eVribgKqFaAJCb0jAWhyvJtodWYdjJPzIyO1CibiagC90AsPQe50IHheI50tRG72GQTmfQudOXQFiaEiaA/640?wx_fmt=gif&quot; data-type=&quot;gif&quot; data-w=&quot;557&quot;/&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;386&quot; data-backw=&quot;578&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;578&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;325&quot; data-ratio=&quot;0.6670212765957447&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/yNKv1P4Q9eUsqck1E6JDMA1Cqic27Yqy0bXlHOWnQVicDgfWgK6XktgAUatH0ibe0nhhnXWY22NicU3eKj5e9oSDCA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;940&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;自己的小网站跑在阿里云的 ECS 上面, 偶尔也去分析分析自己网站服务器日志,看看网站的访问量。看看有没有黑阔搞破坏！于是收集，整理一些服务器日志分析命令，大家可以试试！&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;1、查看有多少个IP访问：&lt;/span&gt;&lt;/p&gt;&lt;pre&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;nginx&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;awk &#x27;{print $1}&#x27; log_file|sort|uniq|wc -l&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;/pre&gt;&lt;p&gt;&lt;span&gt;2、查看某一个页面被访问的次数：&lt;/span&gt;&lt;/p&gt;&lt;pre&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;nginx&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;grep &quot;/index.php&quot; log_file | wc -l&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;/pre&gt;&lt;p&gt;&lt;span&gt;3、查看每一个IP访问了多少个页面：&lt;/span&gt;&lt;/p&gt;&lt;pre&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;swift&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;awk &#x27;{++S[$1]} END {for (a in S) print a,S[a]}&#x27; log_file &amp;gt; log.txt&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;sort -n -t &#x27; &#x27; -k 2 log.txt 配合sort进一步排序&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;/pre&gt;&lt;p&gt;&lt;span&gt;4、将每个IP访问的页面数进行从小到大排序：&lt;/span&gt;&lt;/p&gt;&lt;pre&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;swift&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;awk &#x27;{++S[$1]} END {for (a in S) print S[a],a}&#x27; log_file | sort -n&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;/pre&gt;&lt;p&gt;&lt;span&gt;5、查看某一个IP访问了哪些页面：&lt;/span&gt;&lt;/p&gt;&lt;pre&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;nginx&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;grep ^111.111.111.111 log_file| awk &#x27;{print $1,$7}&#x27;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;/pre&gt;&lt;p&gt;&lt;span&gt;6、去掉搜索引擎统计的页面：&lt;/span&gt;&lt;/p&gt;&lt;pre&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;nginx&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;awk &#x27;{print $12,$1}&#x27; log_file | grep ^\&quot;Mozilla | awk &#x27;{print $2}&#x27; |sort | uniq | wc -l&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;/pre&gt;&lt;p&gt;&lt;span&gt;7、查看2015年8月16日14时这一个小时内有多少IP访问:&lt;/span&gt;&lt;/p&gt;&lt;pre&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;nginx&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;awk &#x27;{print $4,$1}&#x27; log_file | grep 16/Aug/2015:14 | awk &#x27;{print $2}&#x27;| sort | uniq | wc -l&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;/pre&gt;&lt;p&gt;&lt;span&gt;8、查看访问前十个ip地址&lt;/span&gt;&lt;/p&gt;&lt;pre&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;swift&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;awk &#x27;{print $1}&#x27; |sort|uniq -c|sort -nr |head -10 access_log&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;/pre&gt;&lt;blockquote&gt;&lt;p&gt;uniq -c 相当于分组统计并把统计数放在最前面&lt;/p&gt;&lt;/blockquote&gt;&lt;pre&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;swift&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;cat access.log|awk &#x27;{print $1}&#x27;|sort|uniq -c|sort -nr|head -10&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;/pre&gt;&lt;pre&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;ruby&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;cat access.log|awk &#x27;{counts[$(11)]+=1}; END {for(url in counts) print counts[url], url}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;/pre&gt;&lt;p&gt;&lt;span&gt;9、访问次数最多的10个文件或页面&lt;/span&gt;&lt;/p&gt;&lt;pre&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;swift&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;cat log_file|awk &#x27;{print $11}&#x27;|sort|uniq -c|sort -nr | head -10&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;cat log_file|awk &#x27;{print $11}&#x27;|sort|uniq -c|sort -nr|head -20&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;awk &#x27;{print $1}&#x27; log_file |sort -n -r |uniq -c | sort -n -r | head -20&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;/pre&gt;&lt;blockquote&gt;&lt;p&gt;访问量最大的前20个ip&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;span&gt;10、通过子域名访问次数，依据referer来计算，稍有不准&lt;/span&gt;&lt;/p&gt;&lt;pre&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;nginx&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;cat access.log | awk &#x27;{print $11}&#x27; | sed -e &#x27; s/http:\/\///&#x27; -e &#x27; s/\/.*//&#x27; | sort | uniq -c | sort -rn | head -20&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;/pre&gt;&lt;p&gt;&lt;span&gt;11、列出传输大小最大的几个文件&lt;/span&gt;&lt;/p&gt;&lt;pre&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;apache&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;cat www.access.log |awk &#x27;($7~/\.php/){print $10 &quot; &quot; $1 &quot; &quot; $4 &quot; &quot; $7}&#x27;|sort -nr|head -100&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;/pre&gt;&lt;p&gt;&lt;span&gt;12、列出输出大于200000byte(约200kb)的页面以及对应页面发生次数&lt;/span&gt;&lt;/p&gt;&lt;pre&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;nginx&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;cat www.access.log |awk &#x27;($10 &amp;gt; 200000 &amp;amp;&amp;amp; $7~/\.php/){print $7}&#x27;|sort -n|uniq -c|sort -nr|head -100&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;/pre&gt;&lt;p&gt;&lt;span&gt;13、如果日志最后一列记录的是页面文件传输时间，则有列出到客户端最耗时的页面&lt;/span&gt;&lt;/p&gt;&lt;pre&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;apache&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;cat www.access.log |awk &#x27;($7~/\.php/){print $NF &quot; &quot; $1 &quot; &quot; $4 &quot; &quot; $7}&#x27;|sort -nr|head -100&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;/pre&gt;&lt;p&gt;&lt;span&gt;14、列出最最耗时的页面(超过60秒的)的以及对应页面发生次数&lt;/span&gt;&lt;/p&gt;&lt;pre&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;nginx&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;cat www.access.log |awk &#x27;($NF &amp;gt; 60 &amp;amp;&amp;amp; $7~/\.php/){print $7}&#x27;|sort -n|uniq -c|sort -nr|head -100&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;/pre&gt;&lt;p&gt;&lt;span&gt;15、列出传输时间超过 30 秒的文件&lt;/span&gt;&lt;/p&gt;&lt;pre&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;nginx&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;cat www.access.log |awk &#x27;($NF &amp;gt; 30){print $7}&#x27;|sort -n|uniq -c|sort -nr|head -20&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;/pre&gt;&lt;p&gt;&lt;span&gt;16、列出当前服务器每一进程运行的数量，倒序排列&lt;/span&gt;&lt;/p&gt;&lt;pre&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;nginx&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;ps -ef | awk -F &#x27; &#x27; &#x27;{print $8 &quot; &quot; $9}&#x27; |sort | uniq -c |sort -nr |head -20&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;/pre&gt;&lt;p&gt;&lt;span&gt;17、查看apache当前并发访问数&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;对比httpd.conf中MaxClients的数字差距多少&lt;/span&gt;&lt;/p&gt;&lt;pre&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;nginx&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;netstat -an | grep ESTABLISHED | wc -l&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;/pre&gt;&lt;p&gt;&lt;span&gt;18、可以使用如下参数查看数据&lt;/span&gt;&lt;/p&gt;&lt;pre&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;nginx&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;ps -ef|grep httpd|wc -l&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;1388&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;/pre&gt;&lt;p&gt;&lt;span&gt;统计httpd进程数，连个请求会启动一个进程，使用于Apache服务器。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;表示Apache能够处理1388个并发请求，这个值Apache可根据负载情况自动调整&lt;/span&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;nginx&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;netstat -nat|grep -i &quot;80&quot;|wc -l&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;4341&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;blockquote&gt;&lt;p&gt;netstat -an会打印系统当前网络链接状态，而grep -i “80”是用来提取与80端口有关的连接的，wc -l进行连接数统计。&lt;br/&gt;最终返回的数字就是当前所有80端口的请求总数&lt;/p&gt;&lt;/blockquote&gt;&lt;pre&gt;&lt;p&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;nginx&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;netstat -na|grep ESTABLISHED|wc -l&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;376&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;/pre&gt;&lt;blockquote&gt;&lt;p&gt;netstat -an会打印系统当前网络链接状态，而grep ESTABLISHED 提取出已建立连接的信息。然后wc -l统计&lt;br/&gt;最终返回的数字就是当前所有80端口的已建立连接的总数。&lt;/p&gt;&lt;/blockquote&gt;&lt;pre&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;nginx&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;netstat -nat||grep ESTABLISHED|wc&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;/pre&gt;&lt;p&gt;&lt;span&gt;可查看所有建立连接的详细记录&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;19、输出每个ip的连接数，以及总的各个状态的连接数&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;pre&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;swift&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;netstat -n | awk &#x27;/^tcp/ {n=split($(NF-1),array,&quot;:&quot;);if(n&amp;lt;=2)++S[array[(1)]];else++S[array[(4)]];++s[$NF];++N} END {for(a in S){printf(&quot;%-20s %s\n&quot;, a, S[a]);++I}printf(&quot;%-20s %s\n&quot;,&quot;TOTAL_IP&quot;,I);for(a in s) printf(&quot;%-20s %s\n&quot;,a, s[a]);printf(&quot;%-20s %s\n&quot;,&quot;TOTAL_LINK&quot;,N);}&#x27;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;/pre&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;20、其他的收集&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;分析日志文件下 2012-05-04 访问页面最高 的前20个 URL 并排序&lt;/span&gt;&lt;/p&gt;&lt;pre&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;perl&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;cat access.log |grep &#x27;04/May/2012&#x27;| awk &#x27;{print $11}&#x27;|sort|uniq -c|sort -nr|head -20&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;/pre&gt;&lt;p&gt;&lt;span&gt;查询受访问页面的URL地址中 含有 www.abc.com 网址的 IP 地址&lt;/span&gt;&lt;/p&gt;&lt;pre&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;nginx&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;cat access_log | awk &#x27;($11~/\www.abc.com/){print $1}&#x27;|sort|uniq -c|sort -nr&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;/pre&gt;&lt;p&gt;&lt;span&gt;获取访问最高的10个IP地址 同时也可以按时间来查询&lt;/span&gt;&lt;/p&gt;&lt;pre&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;swift&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;cat linewow-access.log|awk &#x27;{print $1}&#x27;|sort|uniq -c|sort -nr|head -10&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;/pre&gt;&lt;p&gt;&lt;span&gt;时间段查询日志时间段的情况&lt;/span&gt;&lt;/p&gt;&lt;pre&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;nginx&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;cat log_file | egrep &#x27;15/Aug/2015|16/Aug/2015&#x27; |awk &#x27;{print $1}&#x27;|sort|uniq -c|sort -nr|head -10&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;/pre&gt;&lt;p&gt;&lt;span&gt;分析 2015/8/15 到 2015/8/16 访问”/index.php?g=Member&amp;amp;m=Public&amp;amp;a=sendValidCode”的IP倒序排列&lt;/span&gt;&lt;/p&gt;&lt;pre&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;ruby&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;cat log_file | egrep &#x27;15/Aug/2015|16/Aug/2015&#x27; | awk &#x27;{if($7 == &quot;/index.php?g=Member&amp;amp;m=Public&amp;amp;a=sendValidCode&quot;) print $1,$7}&#x27;|sort|uniq -c|sort -nr&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;/pre&gt;&lt;blockquote&gt;&lt;p&gt;($7~/.php/) $7里面包含.php的就输出,本句的意思是最耗时的一百个PHP页面&lt;/p&gt;&lt;/blockquote&gt;&lt;pre&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;apache&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;cat log_file |awk &#x27;($7~/\.php/){print $NF &quot; &quot; $1 &quot; &quot; $4 &quot; &quot; $7}&#x27;|sort -nr|head -100&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;/pre&gt;&lt;p&gt;&lt;span&gt;列出最最耗时的页面(超过60秒的)的以及对应页面发生次数&lt;/span&gt;&lt;/p&gt;&lt;pre&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;nginx&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;cat access.log |awk &#x27;($NF &amp;gt; 60 &amp;amp;&amp;amp; $7~/\.php/){print $7}&#x27;|sort -n|uniq -c|sort -nr|head -100&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;/pre&gt;&lt;p&gt;&lt;span&gt;统计网站流量（G)&lt;/span&gt;&lt;/p&gt;&lt;pre&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;nginx&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;cat access.log |awk &#x27;{sum+=$10} END {print sum/1024/1024/1024}&#x27;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;/pre&gt;&lt;p&gt;&lt;span&gt;统计404的连接&lt;/span&gt;&lt;/p&gt;&lt;pre&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;nginx&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;awk &#x27;($9 ~/404/)&#x27; access.log | awk &#x27;{print $9,$7}&#x27; | sort&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;/pre&gt;&lt;p&gt;&lt;span&gt;统计http status&lt;/span&gt;&lt;/p&gt;&lt;pre&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;swift&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;cat access.log |awk &#x27;{counts[$(9)]+=1}; END {for(code in counts) print code, counts[code]}&#x27;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;cat access.log |awk &#x27;{print $9}&#x27;|sort|uniq -c|sort -rn&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;/pre&gt;&lt;p&gt;&lt;span&gt;每秒并发&lt;/span&gt;&lt;/p&gt;&lt;pre&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;nginx&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;watch &quot;awk &#x27;{if($9~/200|30|404/)COUNT[$4]++}END{for( a in COUNT) print a,COUNT[a]}&#x27; log_file|sort -k 2 -nr|head -n10&quot;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;/pre&gt;&lt;p&gt;&lt;span&gt;带宽统计&lt;/span&gt;&lt;/p&gt;&lt;pre&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;swift&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;cat apache.log |awk &#x27;{if($7~/GET/) count++}END{print &quot;client_request=&quot;count}&#x27;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;/pre&gt;&lt;p&gt;&lt;span&gt;找出某天访问次数最多的10个IP&lt;/span&gt;&lt;/p&gt;&lt;pre&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;perl&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;cat /tmp/access.log | grep &quot;20/Mar/2011&quot; |awk &#x27;{print $3}&#x27;|sort |uniq -c|sort -nr|head&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;/pre&gt;&lt;p&gt;&lt;span&gt;当天ip连接数最高的ip都在干些什么&lt;/span&gt;&lt;/p&gt;&lt;pre&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;perl&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;cat access.log | grep &quot;10.0.21.17&quot; | awk &#x27;{print $8}&#x27; | sort | uniq -c | sort -nr | head -n 10&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;/pre&gt;&lt;p&gt;&lt;span&gt;小时单位里ip连接数最多的10个时段&lt;/span&gt;&lt;/p&gt;&lt;pre&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;swift&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;awk -vFS=&quot;[:]&quot; &#x27;{gsub(&quot;-.*&quot;,&quot;&quot;,$1);num[$2&quot; &quot;$1]++}END{for(i in num)print i,num[i]}&#x27; log_file | sort -n -k 3 -r | head -10&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;/pre&gt;&lt;p&gt;&lt;span&gt;找出访问次数最多的几个分钟&lt;/span&gt;&lt;/p&gt;&lt;pre&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;swift&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;awk &#x27;{print $1}&#x27; access.log | grep &quot;20/Mar/2011&quot; |cut -c 14-18|sort|uniq -c|sort -nr|head&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;/pre&gt;&lt;p&gt;&lt;span&gt;取5分钟日志&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;code&gt;if [ $DATE_MINUTE != $DATE_END_MINUTE ] ;then #&lt;/code&gt;&lt;br/&gt;&lt;span&gt;则判断开始时间戳与结束时间戳是否相等&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;code&gt;START_LINE=sed -n &quot;/$DATE_MINUTE/=&quot; $APACHE_LOG|head -n1&lt;/code&gt; &lt;span&gt;#如果不相等，则取出开始时间戳的行号，与结束时间戳的行号&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;查看tcp的链接状态&lt;/span&gt;&lt;/p&gt;&lt;pre&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;swift&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;netstat -nat |awk &#x27;{print $6}&#x27;|sort|uniq -c|sort -rn &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;netstat -n | awk &#x27;/^tcp/ {++S[$NF]};END {for(a in S) print a, S[a]}&#x27; &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;netstat -n | awk &#x27;/^tcp/ {++state[$NF]}; END {for(key in state) print key,&quot;\t&quot;,state[key]}&#x27; &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;netstat -n | awk &#x27;/^tcp/ {++arr[$NF]};END {for(k in arr) print k,&quot;\t&quot;,arr[k]}&#x27; &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;netstat -n |awk &#x27;/^tcp/ {print $NF}&#x27;|sort|uniq -c|sort -rn &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;netstat -ant | awk &#x27;{print $NF}&#x27; | grep -v &#x27;[a-z]&#x27; | sort | uniq -c&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;netstat -ant|awk &#x27;/ip:80/{split($5,ip,&quot;:&quot;);++S[ip[1]]}END{for (a in S) print S[a],a}&#x27; |sort -n &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;netstat -ant|awk &#x27;/:80/{split($5,ip,&quot;:&quot;);++S[ip[1]]}END{for (a in S) print S[a],a}&#x27; |sort -rn|head -n 10 &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;awk &#x27;BEGIN{printf (&quot;http_code\tcount_num\n&quot;)}{COUNT[$10]++}END{for (a in COUNT) printf a&quot;\t\t&quot;COUNT[a]&quot;\n&quot;}&#x27;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;/pre&gt;&lt;p&gt;&lt;span&gt;查找请求数前20个IP（常用于查找攻来源）：&lt;/span&gt;&lt;/p&gt;&lt;pre&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;swift&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;netstat -anlp|grep 80|grep tcp|awk &#x27;{print $5}&#x27;|awk -F: &#x27;{print $1}&#x27;|sort|uniq -c|sort -nr|head -n20 &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;netstat -ant |awk &#x27;/:80/{split($5,ip,&quot;:&quot;);++A[ip[1]]}END{for(i in A) print A[i],i}&#x27; |sort -rn|head -n20&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;/pre&gt;&lt;p&gt;&lt;span&gt;用tcpdump嗅探80端口的访问看看谁最高&lt;/span&gt;&lt;/p&gt;&lt;pre&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;swift&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;tcpdump -i eth0 -tnn dst port 80 -c 1000 | awk -F&quot;.&quot; &#x27;{print $1&quot;.&quot;$2&quot;.&quot;$3&quot;.&quot;$4}&#x27; | sort | uniq -c | sort -nr |head -20&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;/pre&gt;&lt;p&gt;&lt;span&gt;查找较多time_wait连接&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;code&gt;netstat -n|grep TIME_WAIT|awk &#x27;{print $5}&#x27;|sort|uniq -c|sort -rn|head -n20&lt;/code&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;找查较多的SYN连接&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;code&gt;netstat -an | grep SYN | awk &#x27;{print $5}&#x27; | awk -F: &#x27;{print $1}&#x27; | sort | uniq -c | sort -nr | more&lt;/code&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;根据端口列进程&lt;/span&gt;&lt;/p&gt;&lt;pre&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;nginx&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;netstat -ntlp | grep 80 | awk &#x27;{print $7}&#x27; | cut -d/ -f1&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;/pre&gt;&lt;p&gt;&lt;span&gt;查看了连接数和当前的连接数&lt;/span&gt;&lt;/p&gt;&lt;pre&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;perl&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;netstat -ant | grep $ip:80 | wc -l &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;netstat -ant | grep $ip:80 | grep EST | wc -l&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;/pre&gt;&lt;p&gt;&lt;span&gt;查看IP访问次数&lt;/span&gt;&lt;/p&gt;&lt;pre&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;nginx&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;netstat -nat|grep &quot;:80&quot;|awk &#x27;{print $5}&#x27; |awk -F: &#x27;{print $1}&#x27; | sort| uniq -c|sort -n&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;/pre&gt;&lt;p&gt;&lt;span&gt;Linux命令分析当前的链接状况&lt;/span&gt;&lt;/p&gt;&lt;pre&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;nginx&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;netstat -n | awk &#x27;/^tcp/ {++S[$NF]} END {for(a in S) print a, S[a]}&#x27;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;/pre&gt;&lt;p&gt;&lt;code&gt;watch &quot;netstat -n | awk &#x27;/^tcp/ {++S[\$NF]} END {for(a in S) print a, S[a]}&#x27;&quot;&lt;/code&gt; &lt;span&gt;# 通过watch可以一直监控&lt;/span&gt;&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;LAST_ACK 5 #关闭一个TCP连接需要从两个方向上分别进行关闭，双方都是通过发送FIN来表示单方向数据的关闭，当通信双方发送了最后一个FIN的时候，发送方此时处于LAST_ACK状态，当发送方收到对方的确认（Fin的Ack确认）后才真正关闭整个TCP连接；&lt;/p&gt;&lt;p&gt;SYN_RECV 30 # 表示正在等待处理的请求数；&lt;/p&gt;&lt;p&gt;ESTABLISHED 1597 # 表示正常数据传输状态；&lt;/p&gt;&lt;p&gt;FIN_WAIT1 51 # 表示server端主动要求关闭tcp连接；&lt;/p&gt;&lt;p&gt;FIN_WAIT2 504 # 表示客户端中断连接；&lt;/p&gt;&lt;p&gt;TIME_WAIT 1057 # 表示处理完毕，等待超时结束的请求数；&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;span&gt;来源：https://segmentfault.com/a/1190000009745139&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;XOps 风向标！GOPS  2022 · 上海站，&lt;strong&gt;&lt;span&gt;10月28-29日，&lt;/span&gt;&lt;/strong&gt;&lt;strong&gt;&lt;span&gt;字节、&lt;/span&gt;&lt;/strong&gt;腾讯、阿里、平安银行等互联网、金融、通信云原生、DevOps、安全、数字化转型经验，扫码解锁更多精彩⏬&lt;/span&gt;&lt;/strong&gt;&lt;span/&gt;&lt;/p&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1.7786667&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/yNKv1P4Q9eUsqck1E6JDMA1Cqic27Yqy0opTJsyJoRxNzqCFia8b8zasK7ynUwJmx1cq7hAOhfG9m5xOfw28BticA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;750&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;img data-ratio=&quot;1.7786667&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/yNKv1P4Q9eUsqck1E6JDMA1Cqic27Yqy0lBsmC4JdLCVEzWaib2u3LXKwzib3ncDibUsw4OiaiafH3EJhXib5UDBD1Kfg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;750&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;img data-ratio=&quot;1.7786667&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/yNKv1P4Q9eUsqck1E6JDMA1Cqic27Yqy0pxvd69RtPb9rSqwI4Rmiac3LDTiapD5npicaRRicIafZdic9ff6Jm0cKYBw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;750&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;img data-ratio=&quot;1.7786667&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/yNKv1P4Q9eUsqck1E6JDMA1Cqic27Yqy0YfhqDu22gicXcEPq4RxnBicG0ibQzVNrj9tEZl0GyOXHUxlbkI1ibZM61w/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;750&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;&amp;lt;&amp;lt;  滑动查看下一张图片  &amp;gt;&amp;gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;h2&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;近期好文：&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;&lt;h2&gt;&lt;span&gt;&lt;strong&gt;“高效运维”公众号诚邀广大技术人员投稿&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;&lt;section&gt;&lt;span&gt;投稿邮箱：jiachen@greatops.net，或添加联系人微信：greatops1118。&lt;/span&gt;&lt;/section&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;94248&quot;&gt;&lt;section&gt;&lt;img data-ratio=&quot;0.6222222222222222&quot; data-type=&quot;png&quot; data-w=&quot;45&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/d5TCS9b3zE1d63yHRpJDZ2G0wgx1wY6ciaaPcfRr35t8sZ2H1qkica0UTZY6pTqGNxd6XkRo0rU9WvcSqBb9w5icQ/640?wx_fmt=png&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section data-brushtype=&quot;text&quot;&gt;点个“在看”，一年不宕机&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/div&gt;

          
        &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>b66e9d8e885072593aafe45f0a5b4b9e</guid>
<title>京东到家埋点治理实践</title>
<link>https://toutiao.io/k/2y51ec7</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content             autoTypeSetting24psection&quot; id=&quot;js_content&quot;&gt;&lt;p&gt;&lt;strong&gt;导读：&lt;/strong&gt;京东到家作为行业领先的即时零售电商平台，又是数据驱动型的公司，埋点的价值日益重要，埋点的可用性、准确率也成了一直在攻克的难题。本文主要讲解京东到家在治理埋点数据、提高埋点数据质量工作中的一些实践经验。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;目录：&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;一 什么是埋点&lt;/p&gt;&lt;p&gt;二 为什么要治理埋点&lt;/p&gt;&lt;p&gt;三 如何治理埋点&lt;/p&gt;&lt;p&gt;     3.1 建立统一的埋点流程&lt;/p&gt;&lt;p&gt;     3.2 建立完善的埋点规范&lt;/p&gt;&lt;p&gt;     3.3 建立完善的质量规范&lt;/p&gt;&lt;p&gt;     3.4 优化埋点平台&lt;/p&gt;&lt;p&gt;四 埋点治理收益&lt;/p&gt;&lt;p&gt;五 总结与展望&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;一 什么是埋点？&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.3261538461538461&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PNm6V9cebJUjNJmBDhDxvlaWjzUibu0alRnDm6XJyolwXvsyTr4bfJViciccLdvAwXRPKeibWGICexdNF7rc7wtQWA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1300&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;埋点数据可以为后续的优化和运营策略提供数据支撑。&lt;/span&gt;&lt;span&gt;在京东到家最常见的埋点场景是在商品，例如在商品“曝光”、“点击”、“加车”、“结算”、“提单”这五种行为上做埋点，形成数据漏斗来了解商品、商家、品牌的售卖情况，进而了解用户更喜欢购买哪类商品、哪些商家或者哪个品牌。&lt;/span&gt;&lt;span&gt;很明显，如果某个商品用户不喜欢购买，相应的加车会比较少，如果某个商品被多次加购，说明用户喜欢购买这个商品，这样可以评估哪种品类更受欢迎，给后续的用户体验优化做一些数据支撑。&lt;/span&gt;&lt;/section&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;二 为什么要治理埋点&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;section&gt;埋点是数据的来源，通过大数据处理、数据统计、数据分析、数据挖掘等加工处理，可以得到衡量产品状态的一些基本指标，从而洞察产品的状态。&lt;/section&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1.2323462414578588&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PNm6V9cebJUjNJmBDhDxvlaWjzUibu0aldLh98KqiaLTXWvJWBs0rMwUgpUhgnujrib3WZ7F93HicC0TDNAP3qvhGg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;878&quot;/&gt;&lt;/figure&gt;&lt;p&gt;&lt;span&gt;京东到家历史的埋点是可以满足一些常规的数据分析的，但随着业务的发展，历史埋点方案的弊端也就逐渐体现出来了：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;流程规划缺失：&lt;/strong&gt;没有统一的流程规范，关键节点缺失，埋点上线难；&lt;/p&gt;&lt;p&gt;&lt;strong&gt;设计规范缺失：&lt;/strong&gt;埋点上报时机不一致、同样的业务组件上报的内容不一致、数据差异性高；&lt;/p&gt;&lt;section&gt;&lt;strong&gt;开发不规范：&lt;/strong&gt;各端的技术方案不统一、扩展性较差；&lt;/section&gt;&lt;section&gt;&lt;strong&gt;质量保障难：&lt;/strong&gt;缺少质量标准，埋点错误数据非常多，数据信任度比较低；&lt;/section&gt;&lt;section&gt;&lt;strong&gt;冗余埋点严重：&lt;/strong&gt;无用埋点很多，造成资源浪费，维护成本也高；&lt;/section&gt;&lt;section&gt;&lt;strong&gt;埋点使用困难：&lt;/strong&gt;各业务各端不同的规范，以及大量的脏数据，导致数据分析不能用同一种规则去解析，跨业务打通也比较困难。&lt;/section&gt;&lt;section&gt;要解决上述问题，就需要进行埋点治理，提高埋点质量。首先要建立统一的埋点流程，使得产品、研发、测试、数据团队都按照这个规范进行执行落地。其次要建立统一的埋点规范，将历史埋点进行梳理，结合数据团队的使用情况，无用的埋点给予下线，节省资源消耗和降低维护成本，错误的或者不完善的埋点升级成新规范的埋点，节省研发开发的成本以及数据同学提取数据的成本。最后约定质量规范，提高埋点数据质量，从而提高整体效率。&lt;/section&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;三 如何治理埋点&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;section&gt;京东到家一共有5个平台包括android、ios、rn、h5、wechat_app，为了确保埋点治理能够被很好的推进，就需要数据产品制定统一的埋点流程和规范，使整个规划可以顺利的进行落地。&lt;/section&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;3.1 建立统一的埋点流程&lt;span/&gt;&lt;/h3&gt;&lt;section&gt;京东到家目前包括跟版和非跟版需求，不管什么类型的需求，埋点涉及到的团队几乎都是一样的。埋点体系上涉及到的团队非常多，不止涉及到数据产品一个团队，一般埋点体系涉及到的人员有：业务方（常说的需求方、市场运营团队），产品（专指前端产品），数据产品（负责埋点需求和全流程），开发（埋点开发人员），测试（埋点数据测试），数仓（解析埋点并规范落库），数据分析师（使用埋点数据进行取数或分析）。每一环又都不可或缺，任何一个环节出现问题，都会导致埋点数据不准确。统一和规范了埋点治理流程是实现埋点治理的关键的一步，也是埋点整体治理体系的第一步。&lt;/section&gt;&lt;section&gt;埋点治理新流程，如图：&lt;br/&gt;&lt;/section&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.8183361629881154&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PNm6V9cebJUjNJmBDhDxvlaWjzUibu0alfcEnnnwzDIcia2u43rrYxzdLhvKlAbN41krLac8gq74VKopgS8aYAzQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1178&quot;/&gt;&lt;/figure&gt;&lt;p&gt;&lt;span&gt;经过几个版本的需求迭代，我们发现埋点治理新流程有如下&lt;/span&gt;&lt;strong&gt;优势：&lt;/strong&gt;&lt;strong/&gt;&lt;/p&gt;&lt;p&gt;1）&lt;strong&gt;提升了设计质量&lt;/strong&gt;：数据产品对业务更加了解，设计埋点的效率提升了50%，同时埋点设计考虑更加全面，比如全归因、推荐场景等；&lt;/p&gt;&lt;p&gt;2）&lt;strong&gt;埋点支持扩展、复用&lt;/strong&gt;：比如商品组件，节省研发以及测试成本，无需重复开发；&lt;/p&gt;&lt;p&gt;3）&lt;strong&gt;埋点需求口径一致&lt;/strong&gt;：节省了数据分析30%的人力成本。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;3.2 建立完善的埋点规范&lt;span/&gt;&lt;/h3&gt;&lt;section&gt;埋点体系上涉及到的团队非常多，为了能够使上述流程可以很好地进行下去，就需要对有关团队制定规范并执行落地。&lt;/section&gt;&lt;p&gt;&lt;strong&gt;3.2.1 产品提需规范&lt;/strong&gt;&lt;/p&gt;&lt;section&gt;随着项目的增多，数据埋点&lt;span&gt;并行&lt;/span&gt;上报、量级会对负载能力以及存储能力造成一定的影响，尤其是大促期间，海量的数据会导致埋点的入库&lt;span&gt;延迟&lt;/span&gt;，同时也会提高存储设备、服务器、带宽等固定成本，故需要我们在埋点接收环节对埋点进行一定的管控，比如：需求是否合理、是否有遗漏、参数是否完善等；还需要统计每个环节使用的人力成本，统计埋点去向以及分析产生的业务价值。&lt;/section&gt;&lt;section&gt;为了使&lt;span&gt;数据产品、研发、测试、数据团队可以对埋点的口径达成统一，我们要求&lt;/span&gt;所有的需求都需要通过前端产品在埋点管理平台进行需求提报,包括填写页面、版本、需求名称、需求描述、前置路径、关键参数以及上传对应UI图（标记埋点位置）等。&lt;/section&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5145493257629524&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PNm6V9cebJUjNJmBDhDxvlaWjzUibu0aldAKGdASHLcyG2tldEQ6iapUH123pmSqSs9F3dKDSltRHpXJ7X9p0fBg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2818&quot;/&gt;&lt;/figure&gt;&lt;section&gt;&lt;strong&gt;3.2.2 数据设计规范&lt;/strong&gt;&lt;/section&gt;&lt;p&gt;我们对历史埋点进行梳理，从中归纳了四大类型，包括ep精准曝光、浏览、点击、api接口下发：&lt;/p&gt;&lt;p&gt;&lt;strong&gt;ep精准曝光：&lt;/strong&gt;资源位露出并且达到一定条件的时候，在同一接口ID下，组合够一定的条数进行上报。&lt;/p&gt;&lt;section&gt;支持配置有效曝光的条件，无需发版：&lt;/section&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;section&gt;&lt;span&gt;&quot;epDuration&quot;&lt;/span&gt;:1，&lt;span&gt;&quot;epPercent&quot;&lt;/span&gt;:0.5&lt;br/&gt;&lt;/section&gt;&lt;/pre&gt;&lt;section&gt;资源位：一般由网关下发userAction给前端，主要下发资源位spm_id，
拼接规则：&lt;/section&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;section&gt;res_type|unit_index|res_unit|tpl|index|res_name|sub_page&lt;br/&gt;&lt;br/&gt;res_type---资源位类型&lt;br/&gt;unit_index---实际楼层&lt;br/&gt;res_unit---实际房间号&lt;br/&gt;tpl----资源位样式&lt;br/&gt;index---cms配置的楼层&lt;br/&gt;res_name---资源位名称&lt;br/&gt;sub_page---资源位所属父级tab&lt;br/&gt;&lt;/section&gt;&lt;/pre&gt;&lt;section&gt;采用资源位的方式，是一旦参数有所变化，是不需要前端发版就可以随时上线的，缩短了数据周期。&lt;/section&gt;&lt;section&gt;&lt;strong&gt;浏览：&lt;/strong&gt;在页面有点击行为且有落地页承接的需要处理成PV埋点，&lt;/section&gt;&lt;section&gt;PV四要素：上一页面名称、当前页面名称、当前页面参数、上一页面资源位参数。&lt;/section&gt;&lt;section&gt;页面有进入和返回，进入的时候携带上一页的资源位信息、页面信息、接口信息，返回的时候增加一个字段进行区分&lt;/section&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;p&gt;示例：&lt;br/&gt;正向触发：&lt;br/&gt;pv参数{&lt;br/&gt;当前页面参数，&lt;br/&gt;ref_par{&lt;br/&gt;来源页相关参数&lt;br/&gt;}}&lt;br/&gt;----------------------------------&lt;br/&gt;逆向触发：&lt;br/&gt;pv参数{&lt;br/&gt;当前页面参数，&lt;br/&gt;ret_Type:back&lt;br/&gt;}}&lt;/p&gt;&lt;/pre&gt;&lt;section&gt;&lt;strong&gt;点击：&lt;/strong&gt; 点击某一个可点区域或者按钮（非跳页）时进行上报，&lt;/section&gt;&lt;section&gt;点击信息主要包括上一页面名称、当前页面名称、点击名称、点击参数。&lt;/section&gt;&lt;section&gt;在场景上主要分为以下6类，包括&lt;/section&gt;&lt;section&gt;1）点击：clickXX&lt;/section&gt;&lt;section&gt;2）点击选中：selectXX&lt;/section&gt;&lt;section&gt;3）点击唤起弹层：showXXLayer&lt;/section&gt;&lt;section&gt;4）点击进入某个地方:goXX&lt;/section&gt;&lt;section&gt;5）用点击模拟曝光：epLayerOpen&lt;/section&gt;&lt;section&gt;6）用点击代替查询结果：getXXResult&lt;/section&gt;&lt;section&gt;大家通过名称就可以知道埋点是用来做什么的，以及具体的功能场景是如何的，代入感比较强。&lt;/section&gt;&lt;section&gt;&lt;strong&gt;api接口下发：&lt;/strong&gt;没有资源位且不需要精准曝光的，只是评估某个功能好坏的采用api，即接口下发数据就上报，主要包括接口名称、接口中对应功能的信息字段。&lt;/section&gt;&lt;section&gt;api的埋点命名采用接口信息，是为了方便大家口径保持一致，精准定位问题。&lt;/section&gt;&lt;section&gt;&lt;strong&gt;除了以上四种类型，同时各端各业务还需从以下六个方向在全局上保持统一：&lt;/strong&gt;&lt;/section&gt;&lt;section&gt;&lt;strong&gt;公参提取：&lt;/strong&gt; 针对不同的类型制定了不同的公参，包括必须上报以及选择上报的公参，同时还设置了可扩展参数，用于后续公参的补充；&lt;/section&gt;&lt;section&gt;&lt;strong&gt;上报时机：&lt;/strong&gt; 是点击上报还是调用接口上报，避免各端各业务有不一样的上报时机；&lt;/section&gt;&lt;section&gt;&lt;strong&gt;组件化&lt;/strong&gt;：相同业务特性，进行组件抽取，相同设计进行复用，比如点击优惠券“click_coupon”，所有页面点击命名一致，通过页面、资源位信息以及优惠券ID来识别具体的优惠券；&lt;/section&gt;&lt;section&gt;&lt;strong&gt;事件命名&lt;/strong&gt;：各端各页面相同业务，采用同样的埋点方式以及埋点命名，比如“加车、结算、提单、支付”等；&lt;/section&gt;&lt;section&gt;&lt;strong&gt;字段&lt;/strong&gt;：各端各页面相同业务所涉及到字段采用同样的，比如商品ID、门店ID等。&lt;/section&gt;&lt;section&gt;&lt;strong&gt;事件串联&lt;/strong&gt;：整体通过页面ID（pageId--唯一ID，产生一条进入pv就生成一次，返回pv与进入保持一致）、接口ID（traceId---唯一ID，识别具体哪次请求产生的埋点）、资源位信息进行精细化地串联，实现前后路径的一对一衔接。&lt;/section&gt;&lt;p&gt;&lt;strong&gt;3.2.3 研发落地规范&lt;/strong&gt;&lt;/p&gt;&lt;section&gt;&lt;strong&gt;埋点接入&lt;/strong&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.16106604866743918&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PNm6V9cebJUjNJmBDhDxvlaWjzUibu0alKhDOsT6mKgnWANK4441guhfKgmTbQxSEbKSAbe6gZW6kj4zKtZzEtA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1726&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;埋点开发&lt;/strong&gt;&lt;span&gt;：&lt;/span&gt;&lt;span&gt;严格按照数据产品方案落地，包括上报时机和技术规则；&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.43257261410788383&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PNm6V9cebJUjNJmBDhDxvlaWjzUibu0alYAXYQL2W2aYd2ZtwHBrTrvZf9oibaY6MQokxpAVCow066djcic2WZnzQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1928&quot;/&gt;&lt;/figure&gt;&lt;/section&gt;&lt;section&gt;&lt;strong&gt;埋点组件化&lt;/strong&gt;&lt;span&gt;：&lt;/span&gt;&lt;span&gt;根据不同类型的埋点制作成标准埋点组件，比如“加减车组件”，&lt;/span&gt;&lt;/section&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6685714285714286&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PNm6V9cebJUjNJmBDhDxvlaWjzUibu0allZJxwm3qQBibaNKukiaGVqKZmke3SbPP82BHjcUbm0P807koVXs3No6A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1400&quot;/&gt;&lt;/figure&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;private void addCart(View v) {&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (entity == null || context==null || (context instanceof Activity) &amp;amp;&amp;amp; ((Activity) context).isFinishing()) {&lt;br/&gt;            &lt;span&gt;return&lt;/span&gt;;&lt;br/&gt;        }&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (entity.getIconType() == 1) {&lt;br/&gt;            &lt;span&gt;if&lt;/span&gt; (isAllCart(params)) {&lt;br/&gt;                //全局购物车spu加车&lt;br/&gt;                addCartSpu(v);&lt;br/&gt;            } &lt;span&gt;else&lt;/span&gt; {&lt;br/&gt;                //mini购物车spu加车&lt;br/&gt;                &lt;span&gt;if&lt;/span&gt; (context != null &amp;amp;&amp;amp; params != null) {&lt;br/&gt;                    String userAction;&lt;br/&gt;                    &lt;span&gt;if&lt;/span&gt; (!TextUtils.isEmpty(entity.getUserActionSku())) {&lt;br/&gt;                        userAction = entity.getUserActionSku();&lt;br/&gt;                    } &lt;span&gt;else&lt;/span&gt; {&lt;br/&gt;                        userAction = entity.getUserAction();&lt;br/&gt;                    }&lt;br/&gt;                    DataPointUtil.addRefPar(DataPointUtil.transToActivity(context), pageName, &lt;span&gt;&quot;userAction&quot;&lt;/span&gt;, userAction, &lt;span&gt;&quot;traceId&quot;&lt;/span&gt;, traceId);&lt;br/&gt;                    new SpuSelectDialog(context, params).showDialog();&lt;br/&gt;                }&lt;br/&gt;            }&lt;br/&gt;            //加车监听spu&lt;br/&gt;            &lt;span&gt;if&lt;/span&gt; (onClickAddListener != null) {&lt;br/&gt;                onClickAddListener.onClickSpu(v);&lt;br/&gt;            }&lt;br/&gt;        } &lt;span&gt;else&lt;/span&gt; {&lt;br/&gt;            //mini购物车sku加车&lt;br/&gt;            &lt;span&gt;if&lt;/span&gt; (isMiniCart(params)) {&lt;br/&gt;                addMiniCartSku(v, params);&lt;br/&gt;            } &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (isAllCart(params)) {&lt;br/&gt;                //全局购物车sku加车&lt;br/&gt;                addCartSku(v, (OnSpuAdapterParams) params);&lt;br/&gt;            }&lt;br/&gt;            //加车监听sku&lt;br/&gt;            &lt;span&gt;if&lt;/span&gt; (onClickAddListener != null) {&lt;br/&gt;                onClickAddListener.onClickSku(v);&lt;br/&gt;            }&lt;br/&gt;        }&lt;br/&gt;        //sku加车埋点&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (params != null &amp;amp;&amp;amp; params.getPointData() != null) {&lt;br/&gt;            pointData.put(&lt;span&gt;&quot;storeId&quot;&lt;/span&gt;, entity.getStoreId());&lt;br/&gt;            pointData.put(&lt;span&gt;&quot;skuId&quot;&lt;/span&gt;, entity.getSkuId());&lt;br/&gt;            pointData.put(&lt;span&gt;&quot;spuId&quot;&lt;/span&gt;, entity.getSpuId());&lt;br/&gt;            pointData.put(&lt;span&gt;&quot;traceId&quot;&lt;/span&gt;, traceId);&lt;br/&gt;            &lt;span&gt;if&lt;/span&gt; (pointData.get(&lt;span&gt;&quot;userAction&quot;&lt;/span&gt;) == null) {&lt;br/&gt;                &lt;span&gt;if&lt;/span&gt; (!TextUtils.isEmpty(entity.getUserActionSku())) {&lt;br/&gt;                    pointData.put(&lt;span&gt;&quot;userAction&quot;&lt;/span&gt;, entity.getUserActionSku());&lt;br/&gt;                } &lt;span&gt;else&lt;/span&gt; {&lt;br/&gt;                    pointData.put(&lt;span&gt;&quot;userAction&quot;&lt;/span&gt;, entity.getUserAction());&lt;br/&gt;                }&lt;br/&gt;            }&lt;br/&gt;            DataPointUtil.addClick(DataPointUtil.transToActivity(context), pageName, &lt;span&gt;&quot;click_add&quot;&lt;/span&gt;, pointData);&lt;br/&gt;        }&lt;br/&gt;    }&lt;/p&gt;&lt;/pre&gt;&lt;section&gt;&lt;strong&gt;埋点自测&lt;/strong&gt;：通过埋点管理平台研发自测设置为必填项，来限制研发必须进行自测，才可以流转到测试团队。&lt;/section&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6462167689161554&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PNm6V9cebJUjNJmBDhDxvlaWjzUibu0alC2z13PycDG6kG6COIe7CG2HGrvM4Q8bz0DHXibc78I1ePtwoppGuwhQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1956&quot;/&gt;&lt;/figure&gt;&lt;section&gt;&lt;strong&gt;埋点下线&lt;/strong&gt;&lt;span&gt;：&lt;/span&gt;&lt;span&gt;禁止在没有业务需求下，下线任意埋点，下线埋点均需经过数据产品审核。&lt;/span&gt;&lt;/section&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.14338919925512103&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PNm6V9cebJUjNJmBDhDxvlaWjzUibu0alxrWBpCbURXzfEZhUebUAz4k8fXcwV3Dicg9CibD8AT1Kv1B74qSWbxZQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2148&quot;/&gt;&lt;/figure&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;3.3 建立完善的质量规范&lt;span/&gt;&lt;/h3&gt;&lt;section&gt;为确保埋点的质量就要做到上线前的测试以及上线后灰度期间的验收。&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.40902021772939345&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PNm6V9cebJUjNJmBDhDxvlaWjzUibu0alibG51OYxic5Ebp8p25ZMyedPcbBExXsrianmtreZ7LictBTAvqobfGXGQA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1286&quot;/&gt;&lt;/p&gt;&lt;section&gt;埋点测试范围包含各点击、ep精准曝光、浏览、api接口下发，埋点参数信息，以及由埋点SDK获取的各类字段：&lt;/section&gt;&lt;section&gt;1）埋点上报时机；&lt;/section&gt;&lt;section&gt;2）埋点上报参数；&lt;/section&gt;&lt;section&gt;3）埋点上报场景；&lt;/section&gt;&lt;section&gt;4）埋点是否重复上报；&lt;/section&gt;&lt;section&gt;5）埋点上报是否出现多余的埋点；&lt;/section&gt;&lt;section&gt;6）埋点上报是否有空数组。&lt;/section&gt;&lt;section&gt;埋点验收主要为上线后灰度期间的数据验收，主要是运用简易数据报表验证埋点数据是否适合逻辑上报、量级上是否满足，前后关联是否满足，是否可实现逻辑上的串联。&lt;/section&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6852941176470588&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PNm6V9cebJUjNJmBDhDxvlaWjzUibu0alPiaria60lB2AMWzxZMQF8MwPUvthRGlJOd3elhTy0YEKpLRT5nyQMwJw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2040&quot;/&gt;&lt;/figure&gt;&lt;section&gt;&lt;span&gt;3.4 优化埋点平台&lt;/span&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;数据分析对于埋点的口径、上报时机、用途不是很清晰，为了提升双方的沟通效率，在埋点质量平台增加了“页面大全、资源位大全以及埋点大全”，数据团队可以清楚地了解埋点的动态。&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5117773019271948&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PNm6V9cebJUjNJmBDhDxvlaWjzUibu0alnZEQc1gMhkWt7Wc6ic7p2e9OibkxibPIr2rmrD6eaEcNsn6RDHheIoVBQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2802&quot;/&gt;&lt;/p&gt;&lt;section&gt;同时通过“数据治理平台”也可以查看各页面的基础信息，包括访问量、用户数等。&lt;/section&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5644916540212443&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PNm6V9cebJUjNJmBDhDxvlaWjzUibu0alAxYpZTCb8khwDk5V0CW7hvHGPYW3mAVfrMeKSg9Rt0HRcreQMpgRnw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2636&quot;/&gt;&lt;/figure&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;四 埋点治理收益&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;section&gt;京东到家目前的埋点准确率已经平均达到了96.5%，在搜推比较精细化的场景下甚至达到了99%以上，比治理之前有了巨大的提升。来来推业务、京明管家业务、B端业务也都复用了目前京东到家业务的整套治理方案。&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5214050493962679&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PNm6V9cebJUjNJmBDhDxvlaWjzUibu0aldUsjRbMrQsia52KNcveeMiby57uYjmsu0ibVJqwteianjJic06ZBJyBYNXw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1822&quot;/&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;五 总结与展望&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p&gt;随着京东到家用户的逐渐壮大和新项目的启动，业务越来越复杂，埋点的数据质量必须得到保障，我们不得不考虑埋点的种种隐患，做到未雨绸缪。埋点数据上报不准确、每个版本人工回溯核心埋点成本的上升、埋点量级的上升对存储以及服务器的压力等，都需要我们有一个完善的埋点监控机制，来持续改善我们的现状。到家埋点后续将重点在监控完善的道路上继续前进。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section class=&quot;mp_profile_iframe_wrp&quot;&gt;&lt;mp-common-profile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mpprofile&quot; data-id=&quot;MzAwMzg1ODMwNw==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/PNm6V9cebJXiceZGCcxwiaBWCsfyZjibdQfkhbOKqgNPJkHWNwibaGupDicA7sXCUs9jCM8lTeYaribatAd9NaibGBj3A/0?wx_fmt=png&quot; data-nickname=&quot;达达集团技术&quot; data-alias=&quot;dada-tech&quot; data-signature=&quot;分享达达集团大研发部在打磨产品、精进技术方面的心得体会，与极客们互相切磋、共同成长&quot; data-from=&quot;1&quot; data-is_biz_ban=&quot;0&quot;/&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;/div&gt;

          
        &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>047cab0f643786f74c4cf477e85d0250</guid>
<title>Http 2.0 一篇就够了</title>
<link>https://toutiao.io/k/tpj25u1</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content             autoTypeSetting24psection&quot; id=&quot;js_content&quot;&gt;&lt;p&gt;自1997年HTTP/1.1发布之后，HTTP/1.1便迅速占领了市场，时至今日(2022年)仍是当前使用最广泛的http协议。但是，这并不能说明HTTP/1.1就完美无缺了，仍然存在很多问题。&lt;/p&gt;&lt;h1&gt;HTTP1.1 当前存在的问题&lt;/h1&gt;&lt;p&gt;  当前HTTP1.1其实在协议本身的格式以及功能上在经历过HTTP0.9、HTTP1.0等几次迭代之后，已经逐渐趋于稳定。当前协议的主要问题是：协议制定初期原始依赖的底层协议带来的问题，即依赖TCP带来的问题：效率慢。&lt;/p&gt;&lt;p&gt;  在http协议制定初期，谁也不会想到一个小小的浏览器能够出现这么丰富多彩的内容，最初的设定，仅仅是为了发布和共享文件，根本不会考虑&quot;交互&quot;的体验问题，压根想象不到当今的浏览器客户端一个页面下来，会产生这么多的请求。当初的设定很简单：只是为了让欧洲的学者之间能够共享文件，保证学术信息的分享；所以，可靠性是当初优先考虑的问题，TCP是可靠连接，理所当然就选择了TCP。&lt;/p&gt;&lt;p&gt;  可是后来随着互联网的发展，当初选择TCP作为底层协议的弊端逐渐凸显：建立连接复杂，效率低。TCP建立连接需要三次握手和四次挥手，创建和断开过程繁琐，效率很低。&lt;/p&gt;&lt;p&gt;  在http1.1协议之前，每一个请求都要新建一个链接；已知平均一个站点有65 ~ 79个请求(2019年统计)，那么打开这么一个网站，就需要 65 ~ 79次请求...好在在http1.1之后新增了&lt;code&gt;keep-alive&lt;/code&gt;字段，可以复用原有的TCP链接，无需每来一个请求就三次握手创建一个TCP链接，也无需一个响应结束四次挥手关闭一个TCP链接，在一定程度上提高了整体协议效率。但是，依然存在其他问题，例如：对头阻塞问题(Head-of-line blocking)。在http1.1协议下，同一个网站内所有HTTP请求的请求顺序是流水线式的顺序执行的，即虽然可能共用了同一个TCP链接通道，但是同一个TCP链接通道下的两个请求会存在阻塞等待的情况：如果前一个HTTP请求没有处理完，第二个http请求只能阻塞等待，这样停滞时间会影响整体协议的传输效率。并且，在不同的浏览器中，同一域名下并发连接的数目都是有限的，例如Chrome浏览器，同一域名下只允许最多&lt;code&gt;6&lt;/code&gt;个并发连接数，这样一来，如果平均一个网站需要 65 ~ 79 个http请求(2019年官方统计数据)，假设都在同一域名下，至少需要 &lt;code&gt;65 / 6&lt;/code&gt; 11个请求等待，才能将所有请求发送完毕。而且假设其中一个链接通道中某个请求延迟或者等待，将直接阻塞后面队列中的请他请求的请求时间。&lt;br/&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;571&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;671&quot; data-ratio=&quot;1.1751313485113835&quot; data-type=&quot;png&quot; data-w=&quot;571&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/f2nwBpf5ibzvyarYOcFI5BMUzb61lciaVaulMxt0pibXVF18dWJuAtFQsho2KgIKxsRzLCzIfBxfqvq90ia6bVYtfA/640?wx_fmt=png&quot;/&gt;&lt;/p&gt;&lt;h1&gt;HTTP2.0 做的改进&lt;/h1&gt;&lt;p&gt;  为提高http的整体性能，http2.0在不改变当前协议整体格式及语义的前提下，对http协议的传输进行了优化，使得http2.0的整体传输效率得到了很大的提升。可以点击以下链接感受一下速度：https://http2.akamai.com/demo&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6411214953271028&quot; data-type=&quot;png&quot; data-w=&quot;1070&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/f2nwBpf5ibzvyarYOcFI5BMUzb61lciaVa0J2SuaBtPziabfhtvXmibpU9mWgicfAxOLI9gTXCSuwCZYdt4AlXs4p3A/640?wx_fmt=png&quot;/&gt;&lt;/p&gt;&lt;p&gt;HTTP2.0的改进主要是针对HTTP性能的提升。&lt;/p&gt;&lt;p&gt;  影响http网络通信性能的因素主要有两个：延迟 和 带宽。随着硬件能力的不断提升以及5G的普及，带宽逐渐不是影响网络通信效率的因素，延迟成了影响http网络通信的主要因素。而想要提升延迟，需要从网络协议的本身来找原因。早在2009年，Google就开始了对提升http性能的因素做研究；当时研发了一种叫做&lt;code&gt;SPDY&lt;/code&gt;的协议，并在2012年得到了Chrome、Firefox以及Opera等浏览器的支持，并成功应用到了Google、Twitter、Facebook等大型网站中来；从此以后，越来越多的公司想要使用SPDY。&lt;/p&gt;&lt;p&gt;  HTTP官方看到了这个趋势，决定仿照依赖&lt;code&gt;SPDY&lt;/code&gt;协议的模型，对HTTP协议进行改造，于是就有了现在的HTTP2.0。前期HTTP2.0基本继承了&lt;code&gt;SPDY&lt;/code&gt;协议，后来又在此基础上做了扩展。与&lt;code&gt;SPDY&lt;/code&gt;协议类似，HTTP2.0遵循了如下原则：&lt;/p&gt;&lt;p&gt;  HTTP2.0和SPDY的原理很简单，就是仿照TCP的拆包解包来解决当前HTTP的队头阻塞(Head-of-Line blocking）的问题，以实现多个请求并发传输、多路复用的效果。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5024390243902439&quot; data-type=&quot;other&quot; data-w=&quot;820&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz/f2nwBpf5ibzvyarYOcFI5BMUzb61lciaVakbpl5cNpR3IlP0pQwIIJjEVcMY2Y3Kfic3LSFk9dmiaiaKpkt94Gvzt4Q/640?wx_fmt=other&quot;/&gt; 下面，就来详细说说http2.0的改进：&lt;/p&gt;&lt;h2&gt;HTTP2.0 二进制分帧&lt;/h2&gt;&lt;p&gt;  二进制分帧，算是HTTP2.0最重大的改变了，HTTP2.0的多路复用就是基于这个才得以实现。&lt;/p&gt;&lt;p&gt;  二进制分帧是在当前HTTPS的TLS协议之上，抽象了一层（也就是说，使用HTTP2.0的前提是必须使用HTTPS）。可以在传输的时候把一个请求拆分成多个很小的数据包，多个请求可以同时拆成许多数据包一起发送，到了服务端，服务端再根据数据包的序号进行拼接，得到完整的每一个请求。&lt;/p&gt;&lt;p&gt;  这些拆分的请求最小粒度叫&lt;code&gt;frame&lt;/code&gt;，按照类型可分为两类结构：&lt;code&gt;Headers frame&lt;/code&gt;和&lt;code&gt;data frame&lt;/code&gt;。&lt;code&gt;headers frame&lt;/code&gt;是对请求头做了抽象，&lt;code&gt;data frame&lt;/code&gt;是针对请求体做了抽象。&lt;/p&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;578&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;292&quot; data-ratio=&quot;0.5052854122621564&quot; data-type=&quot;png&quot; data-w=&quot;2838&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/f2nwBpf5ibzvyarYOcFI5BMUzb61lciaVahictZrDLOJYLANOoPw9AhHMUmF2A6EHDlGMnQiaaGuQUt7bPsYO3OjbA/640?wx_fmt=png&quot;/&gt;&lt;/section&gt;&lt;p&gt;除了&lt;code&gt;frame&lt;/code&gt;结构外，整个二进制分帧层还有&lt;code&gt;message&lt;/code&gt;、&lt;code&gt;stream&lt;/code&gt;两种数据结构，这几种数据结构存在包含关系：&lt;code&gt;frame&lt;/code&gt;最小，&lt;code&gt;message&lt;/code&gt;包含多个&lt;code&gt;frame&lt;/code&gt;，&lt;code&gt;stream&lt;/code&gt;包含多个&lt;code&gt;message&lt;/code&gt;； &lt;code&gt;frame&lt;/code&gt;、&lt;code&gt;message&lt;/code&gt;、&lt;code&gt;stream&lt;/code&gt;三种数据结构共同构成了http2.0的二进制分帧层。三种数据结构的联系和作用分别如下：&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;code&gt;frame&lt;/code&gt;是最小的传输单位，内部有特殊标识，能够区分此&lt;code&gt;frame&lt;/code&gt;属于哪个&lt;code&gt;stream&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;code&gt;message&lt;/code&gt;是逻辑层面的东西，在具体实现中没有体现，多用于表示是请求&lt;code&gt;message&lt;/code&gt;还是相应&lt;code&gt;message&lt;/code&gt;，一个&lt;code&gt;messsage&lt;/code&gt;包含多个&lt;code&gt;frame&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;code&gt;stream&lt;/code&gt;是HTTP2.0传输的最大粒度的&quot;包&quot;，它包含唯一性字段和优先级信息，能够包含请求或者相应&lt;code&gt;message&lt;/code&gt;。&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;578&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;472&quot; data-ratio=&quot;0.8172531214528944&quot; data-type=&quot;png&quot; data-w=&quot;1762&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/f2nwBpf5ibzvyarYOcFI5BMUzb61lciaVaOumVY7V8NIGT3YAbzLkZgIQiaAeMtpzlryryrnssX6ewjpicTtS38qaA/640?wx_fmt=png&quot;/&gt;&lt;/p&gt;&lt;p&gt;那么，http2.0具体是怎样实现多路复用、解决http1.1的队头阻塞(head of block)问题的呢？&lt;/p&gt;&lt;p&gt;首先，http2.0的所有请求都&lt;code&gt;只在一条tcp连接中传输的&lt;/code&gt;，http2.0会把当前所有请求拆成无数小的frame(其实这时候已经区分出不同stream了)&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;578&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;378&quot; data-ratio=&quot;0.6542857142857142&quot; data-type=&quot;png&quot; data-w=&quot;1400&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/f2nwBpf5ibzvyarYOcFI5BMUzb61lciaVafnSbM2cQbnfwK50H33b3uhePDic9m3ezLzl2tclVA6rAiaVQicz7ZkJng/640?wx_fmt=png&quot;/&gt; 然后根据各个frame中的标识信息(frame中标有stream标识)，组成一个个的stream，最后把各种的stream在一条tcp双向管道中进行传输。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;578&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;416&quot; data-ratio=&quot;0.7192857142857143&quot; data-type=&quot;png&quot; data-w=&quot;1400&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/f2nwBpf5ibzvyarYOcFI5BMUzb61lciaVaV2gBYiatBibFOTrsG6iaAxayib1SSWAfDY8biak9j7zvX2ycMVrkicaqLElQ/640?wx_fmt=png&quot;/&gt;&lt;/p&gt;&lt;p&gt;注意：虽然二进制分帧协议中有&lt;code&gt;message&lt;/code&gt;结构，但是，这只是一种逻辑层面的结构，用于区分是请求还是响应信息片段，并不参与真正的协议实现。底层实现仅仅有&lt;code&gt;stream&lt;/code&gt;和&lt;code&gt;frame&lt;/code&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;578&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;226&quot; data-ratio=&quot;0.39151599443671764&quot; data-type=&quot;png&quot; data-w=&quot;2876&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/f2nwBpf5ibzvyarYOcFI5BMUzb61lciaVa2ibKZuVszUdIS5Re6mDeuUuCvQoYdk34QXhMrWWtXrJGyMY9XsahIBg/640?wx_fmt=png&quot;/&gt;&lt;/p&gt;&lt;p&gt;client端和server端在收到各类stream后，根据steam的标识，拼出完整的请求或者响应stream数组，再根据stream数组中的&lt;code&gt;frame&lt;/code&gt;信息，解析出完整的请求或者响应信息。&lt;/p&gt;&lt;p&gt;这样，就实现了http在传输过程中的多路复用。&lt;/p&gt;&lt;p&gt;值得一提的是，在http2.0在传输过程中，我们不再使用纯文本，而是把请求的数据都采用二进制(0或者1)的形式进行传输，这样也减少文本转义带来的额外性能开销；&lt;/p&gt;&lt;h2&gt;HTTP2.0 头部压缩&lt;/h2&gt;&lt;p&gt;  在http1.1传输过程中，请求体可以根据 gzip进行压缩，但是对请求头没有做处理，随着网站请求量的增多，在http2.0之后，对请求头也做了压缩处理。&lt;/p&gt;&lt;p&gt;  对于一个站点，大部分的请求中请求头的信息都是重复的，不同的仅仅只有少数头部属性。&lt;/p&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;578&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;463&quot; data-ratio=&quot;0.8004385964912281&quot; data-type=&quot;png&quot; data-w=&quot;1824&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/f2nwBpf5ibzvyarYOcFI5BMUzb61lciaVaebeWicBcwYovY7eRV51LolSxErEFPibEFrlU8FNh2kopbBlYhYsNs8Zw/640?wx_fmt=png&quot;/&gt;&lt;/section&gt;&lt;p&gt;为了增加传输速率，http2.0在传输的时候，会维护一张请求头部信息的哈希表，并同时存储在客户端和服务端，每次传输的时候，如果发现传输的头部信息在哈希表中已经存在，则只传哈希表的index值，不再传输具体的内容，这样一来，就极大减少了数据的传输。同时，如果有新的头部字段，这张哈希表也会动态的在客户端以及服务端增加新值，后续再有相同字段的时候，将不会再传输，只会传哈希表的index值。&lt;/p&gt;&lt;p&gt;  事实上，上文所谓的那张哈希表细分下来是两张表：一张叫静态表，一张叫动态表。静态表是存放HTTP协议本身固定的一些常见值：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;347&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;306&quot; data-ratio=&quot;0.8819444444444444&quot; data-type=&quot;png&quot; data-w=&quot;576&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/f2nwBpf5ibzvyarYOcFI5BMUzb61lciaVaboYic9sQibhK6ibj4syJewib3ibFLl0TwNh6HVicH3O8PC4iaw9OVCqH2EcDg/640?wx_fmt=png&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;span/&gt;&lt;/section&gt;&lt;p&gt;动态表存放一些网站特定的属性字段，而且会随着请求中字段的变化而进行增加。&lt;/p&gt;&lt;p&gt;之后，请求头的内容变成了除少量header字段外大部分是哈希表index值的数据；但是这还没有结束，http2.0还会将现有的数据内容进行&lt;code&gt;霍夫曼编码处理&lt;/code&gt;，再一次进行压缩。&lt;/p&gt;&lt;p&gt;以上便是http2.0头部压缩的算法，叫做HACK算法。&lt;/p&gt;&lt;h2&gt;HTTP2.0 数据推送&lt;/h2&gt;&lt;p&gt;  不同于http1.1的请求-响应模式，http2.0可以由服务端向客户端推送消息，但这里的推送方式又有别于tcp、或者websocket的双向通信，有一定的局限性。&lt;/p&gt;&lt;p&gt;  在常见的http1.1协议下，client端和服务端严格按照 “请求-响应”的方式进行通信。这样会出现一种情况：某些请求显得很多余。例如，请求一个网站页面，在返回主要的html文件后，html文件中内联的css 、js等文件内容必须通过额外的客户端请求，才能从服务端拿到数据；而这些内联的数据文件，是一定且必须拿到的，这样看来，http1.1场景下，这些内联的数据文件必须由客户端再次发起请求，才能得到服务端的响应数据；而在http2.0的场景下，服务端会根据文件中关联的其他文件，预判并主动推送下次请求中必须的数据。http2.0的数据推送仅限于此了，不同于tcp、websocket的双向通信，要特别注意。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;578&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;253&quot; data-ratio=&quot;0.438498957609451&quot; data-type=&quot;png&quot; data-w=&quot;2878&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/f2nwBpf5ibzvyarYOcFI5BMUzb61lciaVabC38cv78KJOFOoqnVxUOSoBialxKVo2NHpXPhcK0hFnOcB93D9aicR0Q/640?wx_fmt=png&quot;/&gt;&lt;/p&gt;&lt;p&gt;这里可能会有人要问：“http提供了缓存能力，如果推送来的数据客户端缓存里有，该怎么办？” 其实很简单，如果服务端推送数据过来，客户端可以针对推送的数据自行选择放弃或者保存，但是如果客户端将推送来的数据主动放弃，这样其实就白白浪费了一次http响应传输；http2.0还有更好的方式是将客户端已有的缓存信息标识告诉服务端，服务端通过判断之后，只推送不存在的数据信息即可。&lt;/p&gt;&lt;section class=&quot;mp_profile_iframe_wrp&quot;&gt;&lt;mp-common-profile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mpprofile&quot; data-id=&quot;MzAwMjcwOTA3NA==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/f2nwBpf5ibztoBhtqTiaSHIibBLJS3b7LH5huqHWs5rP3R58NM5FDOe1PuWGpwwZoaGJcCC6ID5Tmlx6DAooYXspA/0?wx_fmt=png&quot; data-nickname=&quot;码农RyuGou&quot; data-alias=&quot;ryugou&quot; data-signature=&quot;分享挨踢人的工作生活&quot; data-from=&quot;0&quot;/&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;/div&gt;

          
        &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>1ee832cf58bc13f369469ae3fcbe9b6f</guid>
<title>开源 2 年半，除了性能优化我们啥也没做</title>
<link>https://toutiao.io/k/swk2aqc</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;RichText ztext Post-RichText css-4em6pe&quot; options=&quot;[object Object]&quot; lazyloadimageprops=&quot;[object Object]&quot; usegifprops=&quot;[object Object]&quot;&gt;&lt;p data-first-child=&quot;&quot; data-pid=&quot;35PvLZmM&quot;&gt;性能优化是个十分广泛的话题，它涉及 CPU、内存、磁盘、网络等方面。MegEngine 作为一个训推一体的深度学习框架，也在持续不断探索性能优化的最优解。&lt;/p&gt;&lt;p data-pid=&quot;Ro9Ed9A1&quot;&gt;本篇整理了 Bot 过往发布的相关文章，希望能帮助大家更好的理解和掌握 MegEngine 使用技巧。&lt;/p&gt;&lt;h2 id=&quot;h_569058143_0&quot; data-into-catalog-status=&quot;&quot;&gt;工欲善其事必先利其器&lt;/h2&gt;&lt;h3 id=&quot;h_569058143_1&quot; data-into-catalog-status=&quot;&quot;&gt;&lt;b&gt;学会使用性能评测工具&lt;/b&gt;&lt;/h3&gt;&lt;p data-pid=&quot;HV_5WhgO&quot;&gt;提到性能优化，笔者认为性能优化人员的技术水平大概可被分为以下三类：&lt;/p&gt;&lt;ol&gt;&lt;li data-pid=&quot;DPxcSgBS&quot;&gt;“瞎着写“。这类技术水平的人员一般不会在意其他，遇事先上”三板斧“，如循环展开，向量化，指令重排。性能好往往也不知其所以然，性能不好也没有什么后续的优化思路。&lt;/li&gt;&lt;li data-pid=&quot;xDIhl2AU&quot;&gt;”摸着写”。这类技术水平的人员与第一类的一个显著的分水岭是学会使用性能评测工具，通过工具能够摸到程序的瓶颈在何处，然后进行对应的优化。&lt;/li&gt;&lt;li data-pid=&quot;TpUKqWRY&quot;&gt;”瞄着写“。这类人员有了量化分析程序性能的能力。当面临同一个程序的多种写法时，能够做到即使不真实实现程序，也能较为精准的算出来哪种写法性能更好。&lt;/li&gt;&lt;/ol&gt;&lt;p data-pid=&quot;fuC8ug_a&quot;&gt;需要注意的是以上三类人员所用的技术是逐级包含的关系，例如第三类人员同样掌握性能评测工具的使用方法和”三板斧“式的优化方法。正所谓工欲善其事必先利其器，其实只有达到第二类的水平，性能优化人员才初步具有独立优化能力，所以性能评测工具的掌握至关重要。如果你对性能优化中一些基本概念还不够了解，且对以下问题也有相同的疑问：&lt;/p&gt;&lt;ul&gt;&lt;li data-pid=&quot;9NmvdxJn&quot;&gt;Python 及 C/C++ 拓展程序的常见的优化目标有哪些；&lt;/li&gt;&lt;li data-pid=&quot;AbVCT-us&quot;&gt;常见工具的能力范围和局限是什么，给定一个优化目标我们应该如何选择工具；&lt;/li&gt;&lt;li data-pid=&quot;_o-mWr3U&quot;&gt;各种工具的使用方法和结果的可视化方法；&lt;/li&gt;&lt;/ul&gt;&lt;p data-pid=&quot;2EQKXCZr&quot;&gt;&lt;b&gt;《&lt;a href=&quot;https://zhuanlan.zhihu.com/p/362575905&quot; class=&quot;internal&quot;&gt;profiling 与性能优化总结&lt;/a&gt;》&lt;/b&gt;将会是一个很好的总结性材料。&lt;/p&gt;&lt;h3 id=&quot;h_569058143_2&quot; data-into-catalog-status=&quot;&quot;&gt;&lt;b&gt;学会基本的性能优化方法论&lt;/b&gt;&lt;/h3&gt;&lt;p data-pid=&quot;rlsD60oG&quot;&gt;学会了使用性能评测工具之后，还需要了解基本的性能优化方法论，然后就基本具有独立优化能力了。性能优化很多时候就是&lt;b&gt;不断迭代&lt;/b&gt;的过程：&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-53efd4c11d060639799ea10c169c80ee_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;317&quot; data-rawheight=&quot;694&quot; class=&quot;content_image&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;317&quot; data-rawheight=&quot;694&quot; class=&quot;content_image lazy&quot; data-actualsrc=&quot;https://pic3.zhimg.com/v2-53efd4c11d060639799ea10c169c80ee_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p data-pid=&quot;OP00xg1q&quot;&gt;以 ARM Cortex a55 上的 GaussianBlur 优化为例，一起看&lt;/p&gt;&lt;a target=&quot;_blank&quot; href=&quot;https://zhuanlan.zhihu.com/p/517371998&quot; data-draft-node=&quot;block&quot; data-draft-type=&quot;link-card&quot; data-image=&quot;https://pic3.zhimg.com/equation_ipico.jpg&quot; data-image-width=&quot;120&quot; data-image-height=&quot;120&quot; data-text=&quot;MegEngine Bot：ARM 算子性能优化上手指南&quot; class=&quot;LinkCard new&quot;&gt;&lt;span class=&quot;LinkCard-contents&quot;&gt;&lt;span class=&quot;LinkCard-title loading&quot; data-text=&quot;true&quot;/&gt;&lt;span class=&quot;LinkCard-desc loading&quot;/&gt;&lt;/span&gt;&lt;span class=&quot;LinkCard-image LinkCard-image--default&quot;/&gt;&lt;/a&gt;&lt;h2 id=&quot;h_569058143_3&quot; data-into-catalog-status=&quot;&quot;&gt;作为深度学习框架，模型训练速度很重要&lt;/h2&gt;&lt;h3 id=&quot;h_569058143_4&quot; data-into-catalog-status=&quot;&quot;&gt;&lt;b&gt;解决零碎算子时间占比高的问题&lt;/b&gt;&lt;/h3&gt;&lt;p data-pid=&quot;1xelIwfH&quot;&gt;众所周知，很多深度学习模型中都有类似 element-wise 的散碎操作。例如加减乘除算术运算和神经网络中的激活函数，以及 BatchNormalization 在模型推理的时候一般也被优化成一系列的 element-wise 操作。&lt;/p&gt;&lt;p data-pid=&quot;9WJqpQic&quot;&gt;这些散碎的操作具有计算访存比低的特点，即其计算量较低但是访存量较高，是一种典型的内存受限(memory bound)的操作。算子融合(kernel fusion)是针对内存受限的算子的常见优化手段。但是这些散碎算子的计算模式众多，这些计算模式相互组合将会是指数级别的，依靠手工写代码进行针对性优化是不现实的。MegEngine 通过引入 JIT 和自动代码生成技术解决计算模式组合爆炸的问题，从而享受到 kernel fusion 带来的性能收益，详见&lt;/p&gt;&lt;a target=&quot;_blank&quot; href=&quot;https://zhuanlan.zhihu.com/p/357490714&quot; data-draft-node=&quot;block&quot; data-draft-type=&quot;link-card&quot; data-text=&quot;MegEngine Bot：JIT in MegEngine&quot; class=&quot;LinkCard new&quot;&gt;&lt;span class=&quot;LinkCard-contents&quot;&gt;&lt;span class=&quot;LinkCard-title loading&quot; data-text=&quot;true&quot;/&gt;&lt;span class=&quot;LinkCard-desc loading&quot;/&gt;&lt;/span&gt;&lt;span class=&quot;LinkCard-image LinkCard-image--default&quot;/&gt;&lt;/a&gt;&lt;h2 id=&quot;h_569058143_5&quot; data-into-catalog-status=&quot;&quot;&gt;作为一个训推一体的框架，推理速度同样重要&lt;/h2&gt;&lt;h3 id=&quot;h_569058143_6&quot; data-into-catalog-status=&quot;&quot;&gt;&lt;b&gt;云侧&lt;/b&gt;&lt;/h3&gt;&lt;p data-pid=&quot;EN09swQl&quot;&gt;单精度矩阵乘法（SGEMM）几乎是每一位学习 CUDA 的同学绕不开的案例，这个经典的计算密集型案例可以很好地展示 GPU 编程中常用的优化技巧，而能否写出高效率的 SGEMM Kernel，也是反映一位 CUDA 程序员对 GPU 体系结构的理解程度的优秀考题。&lt;/p&gt;&lt;p data-pid=&quot;8fmThUsz&quot;&gt;在&lt;b&gt;《&lt;a href=&quot;https://zhuanlan.zhihu.com/p/410278370&quot; class=&quot;internal&quot;&gt;CUDA 矩阵乘法终极优化指南&lt;/a&gt;》&lt;/b&gt;一文中，详细介绍了 CUDA SGEMM 的优化手段，适合认真阅读过 《CUDA C++ Programming Guide》 、具备一定 CUDA 编程基础的同学阅读。&lt;/p&gt;&lt;p data-pid=&quot;WXrEaPGk&quot;&gt;2020 年 5 月 Nvidia 发布了新一代的 GPU 架构安培（Ampere）。其中和深度学习关系最密切的莫过于性能强劲的第三代的 TensorCore ，新一代的 TensorCore 支持了更为丰富的 DL（Deep Learning）数据类型，包括了新的 TesorFloat-32（TF32），Bfloat16（BF16）计算单元以及 INT8, INT4 和 INT1 的计算单元，这些计算单元为 DL 推理提供了全面的支持。为了发挥这些计算单元的能力，以往会由资深的 HPC 工程师手写 GPU 汇编实现的卷积、矩阵乘算子来挖掘硬件的能力。然而凭借人力手工优化算子的方式已经没有办法应对如此多的数据类型，因此对于 DL 应用的优化渐渐地越来越依赖一些自动化的工具，例如面向深度学习领域的编译器。在这样的趋势下，Nvidia 开发了线性代数模板库 CUTLASS ，抽象了一系列高性能的基本组件，可以用于生成各种数据类型，各种计算单元的卷积、矩阵乘算子。&lt;/p&gt;&lt;p data-pid=&quot;BguqIypD&quot;&gt;MegEngine 在 CUTLASS 的基础上进行了二次开发，可以高效地开发新的高性能的算子，快速地迁移到新的 GPU 架构。一文看懂 &lt;b&gt;《&lt;a href=&quot;https://zhuanlan.zhihu.com/p/372973726&quot; class=&quot;internal&quot;&gt;MegEngine CUDA 平台的底层卷积算子的实现原理&lt;/a&gt;》&lt;/b&gt;。文中还有对 Nvidia CUTLASS 的 Implicit GEMM 卷积文档进行解读和补充。&lt;/p&gt;&lt;h3 id=&quot;h_569058143_7&quot; data-into-catalog-status=&quot;&quot;&gt;&lt;b&gt;端 &amp;amp; 芯侧&lt;/b&gt;&lt;/h3&gt;&lt;p data-pid=&quot;dcvnrKqT&quot;&gt;卷积计算优化作为 CV 模型推理性能优化中最重要的一项工作，CPU 上 Inference 中有关卷积的优化有很多的途径。&lt;/p&gt;&lt;p data-pid=&quot;FMou_-zI&quot;&gt;MegEngine 通过实现 Im2col+matmul 卷积以及 Winograd 卷积中的一些进一步优化的技术手段，进一步加速了卷积计算的性能，从而加速整个模型的 Inference 性能。&lt;/p&gt;&lt;p data-pid=&quot;KwsdHqb6&quot;&gt;如在 Float32 的经典网络开启相关优化后，在骁龙 855 上的测试速度为：&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-1fcf738d7505ed9f57937364b7f4995a_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1226&quot; data-rawheight=&quot;562&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic3.zhimg.com/v2-1fcf738d7505ed9f57937364b7f4995a_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1226&quot; data-rawheight=&quot;562&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic3.zhimg.com/v2-1fcf738d7505ed9f57937364b7f4995a_r.jpg&quot; data-actualsrc=&quot;https://pic3.zhimg.com/v2-1fcf738d7505ed9f57937364b7f4995a_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p data-pid=&quot;JtuTONeZ&quot;&gt;有关 Im2col 和 Winograd 算法的实现以及优化方法，见&lt;/p&gt;&lt;a target=&quot;_blank&quot; href=&quot;https://zhuanlan.zhihu.com/p/532187602&quot; data-draft-node=&quot;block&quot; data-draft-type=&quot;link-card&quot; data-text=&quot;MegEngine Bot：MegEngine Inference 卷积优化之 Im2col 和 winograd 优化&quot; class=&quot;LinkCard new&quot;&gt;&lt;span class=&quot;LinkCard-contents&quot;&gt;&lt;span class=&quot;LinkCard-title loading&quot; data-text=&quot;true&quot;/&gt;&lt;span class=&quot;LinkCard-desc loading&quot;/&gt;&lt;/span&gt;&lt;span class=&quot;LinkCard-image LinkCard-image--default&quot;/&gt;&lt;/a&gt;&lt;p data-pid=&quot;VGaBh7E8&quot;&gt;在数字信号和数字图像领域， 对频域的研究是一个重要分支。 我们日常“加工”的图像都是像素级，被称为是图像的空域数据。空域数据表征我们“可读”的细节。如果我们将同一张图像视为信号，进行频谱分析，可以得到图像的频域数据。实现图像空域和频域转换的工具，就是傅立叶变换。由于图像数据在空间上是离散的，我们使用傅立叶变换的离散形式 DFT（Discrete Fourier Transform）及其逆变换 IDFT（Inverse Discrete Fourier Transform)。Cooley-Tuckey 在 DFT 的基础上，开发了更快的算法 FFT（Fast Fourier Transform）。&lt;/p&gt;&lt;p data-pid=&quot;DaRxycbh&quot;&gt;DFT/FFT 在深度学习领域也有延伸应用。 比如利用 FFT 可以降低卷积计算量的特点，FFT_Conv 算法也成为常见的深度学习卷积算法。&lt;/p&gt;&lt;p data-pid=&quot;Dep9_gow&quot;&gt;理论优化时，我们总会选择更好的设备去计算理论上限。但在实际应用时，算力较弱的移动设备，如何承载模型推理的运算？&lt;/p&gt;&lt;p data-pid=&quot;nqF97MUM&quot;&gt;一般认为，让模型运行于 GPU 上会比运行于 CPU 上具有较大的优势，取得可观的性能提升。这通常是真实情况，但是，在工程实践中我们也发现，对于某些模型维度较小的模型，在移动设备上，GPU 运行并没有带来性能的提升，而且还额外引入了兼容性的问题。所以，在某些应用场景下，我们需要以 CPU 为运行载体，尝试各种方法，以提升模型推理性能。&lt;/p&gt;&lt;p data-pid=&quot;N_3MDxxu&quot;&gt;在&lt;b&gt;《&lt;a href=&quot;https://zhuanlan.zhihu.com/p/400228375&quot; class=&quot;internal&quot;&gt;基于 MegEngine 移动端 CPU 的深度学习模型推理性能优化&lt;/a&gt;》&lt;/b&gt;一文中，作者总结了自己在工程实践中，基于 MegEngine 推理引擎，发现的 2 有效的优化方法“ NCHW44 和 Record ”的原理及使用方法做了详细说明。&lt;/p&gt;&lt;blockquote data-pid=&quot;cGVA1oHh&quot;&gt;如果你在 MegEngine 的使用过程中也有自己独特的技巧，欢迎联系 Bot（微信号：megengine-bot）投稿，还有多种社区周边相送哦~&lt;/blockquote&gt;&lt;h2 id=&quot;h_569058143_8&quot; data-into-catalog-status=&quot;&quot;&gt;相比于性能，易用性也不可或缺&lt;/h2&gt;&lt;p data-pid=&quot;d8FFOnc2&quot;&gt;为解决实际生产条件下，用户的 NN 网络千差万别的情况。在同一类数学计算中，开发者们会开发多种高效的算法，分别适用于不同的参数，以保证网络的性能。接下来开发者们需要解决一个新问题，当计算参数确定以后，如何让最快的算法执行该计算。&lt;/p&gt;&lt;p data-pid=&quot;JOMLuPzI&quot;&gt;大部分框架靠先验的经验选择算法，MegEngine 亦总结有优秀的先验经验值，实现计算时自动选择算法。但是依靠经验不能保证一定选择了最快的算法。很多实际场景中，用户希望网络有最极致的性能。为此，MegEngine 设计了专门的流程 - Fast Run，可以为每个计算自动选择最快的算法，从而保证整个网络的运行时间最短。&lt;/p&gt;&lt;p data-pid=&quot;wYgbS2Hd&quot;&gt;原理及使用方法见&lt;/p&gt;&lt;a target=&quot;_blank&quot; href=&quot;https://zhuanlan.zhihu.com/p/387775972&quot; data-draft-node=&quot;block&quot; data-draft-type=&quot;link-card&quot; data-text=&quot;MegEngine Bot：Fast Run：提高 MegEngine 模型推理性能的神奇功能&quot; class=&quot;LinkCard new&quot;&gt;&lt;span class=&quot;LinkCard-contents&quot;&gt;&lt;span class=&quot;LinkCard-title loading&quot; data-text=&quot;true&quot;/&gt;&lt;span class=&quot;LinkCard-desc loading&quot;/&gt;&lt;/span&gt;&lt;span class=&quot;LinkCard-image LinkCard-image--default&quot;/&gt;&lt;/a&gt;&lt;p data-pid=&quot;rupmVWoA&quot;&gt;为了在不同的应用场景上都能表现出不错的性能，MegEngine 中的张量（Tensor）具有不同的排布格式（Format），不同存储格式在不同的输入数据和不同硬件平台上的性能也不相同。全局图优化从整个模型的角度决策模型的哪一部分转换成哪种存储格式能使得整个模型的性能最优，避免给用户带来繁杂的选择和权衡从而导致额外的心智负担。同 Fast Run 一样，全局图优化也是可选择开启的优化选项。&lt;/p&gt;&lt;p data-pid=&quot;7ZUMsIu9&quot;&gt;在 int8 模型上，经过全局图优化和 MegEngine 原 Format 优化方法（传统图优化）的推理时间表现对比如下图：&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-68eb1c2bb448277c8d4043000ecb8d04_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;603&quot; data-rawheight=&quot;328&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic1.zhimg.com/v2-68eb1c2bb448277c8d4043000ecb8d04_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;603&quot; data-rawheight=&quot;328&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic1.zhimg.com/v2-68eb1c2bb448277c8d4043000ecb8d04_r.jpg&quot; data-actualsrc=&quot;https://pic1.zhimg.com/v2-68eb1c2bb448277c8d4043000ecb8d04_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p data-pid=&quot;TV07Ywet&quot;&gt;全局图优化能解决哪些问题？如何使用？以及底层技术原理解析。可以看：&lt;/p&gt;&lt;a target=&quot;_blank&quot; href=&quot;https://zhuanlan.zhihu.com/p/491037155&quot; data-draft-node=&quot;block&quot; data-draft-type=&quot;link-card&quot; data-image=&quot;https://pic4.zhimg.com/equation_ipico.jpg&quot; data-image-width=&quot;120&quot; data-image-height=&quot;120&quot; data-text=&quot;MegEngine Bot：全局图优化：提升 MegEngine 模型推理性能的又一神器&quot; class=&quot;LinkCard new&quot;&gt;&lt;span class=&quot;LinkCard-contents&quot;&gt;&lt;span class=&quot;LinkCard-title loading&quot; data-text=&quot;true&quot;/&gt;&lt;span class=&quot;LinkCard-desc loading&quot;/&gt;&lt;/span&gt;&lt;span class=&quot;LinkCard-image LinkCard-image--default&quot;/&gt;&lt;/a&gt;&lt;h2 id=&quot;h_569058143_9&quot; data-into-catalog-status=&quot;&quot;&gt;【很重要的补充说明】&lt;/h2&gt;&lt;p data-pid=&quot;FnvqRdp9&quot;&gt;在 Bot 把这篇内容给技术同学看的时候，被投诉：以偏概全！&lt;/p&gt;&lt;p data-pid=&quot;HgKEauKs&quot;&gt;据他们说：以上提到的技术点，绝对不是开源至今所有的重点工作；还有更多性能优化工作，只是没有被整理成文章而已。&lt;/p&gt;&lt;p data-pid=&quot;Un_K9f3T&quot;&gt;所以，欢迎大家留言自己感兴趣的内容方向，在线催更~~ &lt;/p&gt;&lt;h2 id=&quot;h_569058143_10&quot; data-into-catalog-status=&quot;&quot;&gt;附&lt;/h2&gt;&lt;p data-pid=&quot;aEnWoh8I&quot;&gt;GitHub：&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//github.com/MegEngine&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;MegEngine 旷视天元&lt;/a&gt; （欢迎 star~&lt;/p&gt;&lt;p data-pid=&quot;l4wkbVhC&quot;&gt;Gitee：&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//gitee.com/MegEngine/MegEngine&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;MegEngine/MegEngine&lt;/a&gt;&lt;/p&gt;&lt;p data-pid=&quot;mQdfRgAF&quot;&gt;MegEngine 官网：&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//www.megengine.org.cn/&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;MegEngine-深度学习，简单开发&lt;/a&gt;&lt;/p&gt;&lt;p data-pid=&quot;H9IUwogi&quot;&gt;欢迎加入 MegEngine 技术交流 QQ 群：1029741705&lt;/p&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>f4b1eeb36ab23bcb6d45f811d8045008</guid>
<title>一文就想搞懂 Sentinel 限流熔断？带你入个门</title>
<link>https://toutiao.io/k/j600vjd</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;p&gt;&lt;span&gt;大家好，我是码哥。&lt;/span&gt;&lt;/p&gt;&lt;section class=&quot;mp_profile_iframe_wrp&quot;&gt;&lt;mp-common-profile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mpprofile&quot; data-id=&quot;MzkzMDI1NjcyOQ==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/EoJib2tNvVtf7icAmS0BQH6oDVG37Q8NzcfdguS5qAqOhfxvZyIKqmuX5BbnDjynrBbZzktp1EiaeFLzapp1nHysw/0?wx_fmt=png&quot; data-nickname=&quot;码哥字节&quot; data-alias=&quot;MageByte&quot; data-signature=&quot;拥抱硬核技术和对象，面向人民币编程。&quot; data-from=&quot;0&quot; data-is_biz_ban=&quot;0&quot;/&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;面对互联网的高并发过载流量，为了保证系统的稳定性，我们一般会对过载流量进行限流。今天就给大家详细介绍一款限流框架&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;1、什么是 sentinel：&lt;/span&gt;&lt;br/&gt;&lt;/h2&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;在基于 SpringCloud 构建的微服务体系中，服务间的调用链路会随着系统的演进变得越来越长，这无疑会增加了整个系统的不可靠因素。&lt;br/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在并发流量比较高的情况下，由于网络调用之间存在一定的超时时间，链路中的某个服务出现宕机都会大大增加整个调用链路的响应时间，而瞬间的流量洪峰则会导致这条链路上所有服务的可用线程资源被打满，从而造成整体服务的不可用，这也就是我们常说的 “雪崩效应”。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;而在微服务系统设计的过程中，为了应对这样的糟糕情况，最常用的手段就是进行 ”流量控制“ 以及对网络服务的调用实现“熔断降级”。因此，Sentinel 就因运而生了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Sentinel 是一款面向分布式服务架构的轻量级流量控制组件，主要以流量为切入点，从流量控制、熔断降级、系统自适应保护等多个维度来保障服务的稳定性，核心思想是：&lt;strong&gt;根据对应资源配置的规则来为资源执行相应的流控/降级/系统保护策略&lt;/strong&gt;，Sentinel 的主要特性如下图：&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.49697885196374625&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/knmrNHnmCLGVzxh38ed9LXOgwib5TiaDgXctThNfJ16Raf44YKaibdOtkqvhmOyeQIFZMFeSGByQ24dicBib2CHOosw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;662&quot;/&gt;&lt;p&gt;&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;2、主流限流熔断组件对比：&lt;/span&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.7601156069364162&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/knmrNHnmCLGVzxh38ed9LXOgwib5TiaDgX1ruapo5gDibhjdLINWzgopibf7IZsyVSNQboPBpVonSibiaxZOZlWUeCeA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;692&quot;/&gt;从三者的对比来看，Hystrix 功能相对较少且官方已宣布停止维护，官方推荐 resilience4j 作为 Hystrix 的替代品。而对比 resilience4j 和 sentinel，可明显看出 sentinel 支持的功能、场景更丰富，灵活性可用性更高。&lt;p&gt;&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;3、sentinel-dashboard 控制台的部署与使用说明：&lt;/span&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;（1）进入官网下载 sentinel-dashboard 的 jar 包：&lt;code&gt;Releases · alibaba/Sentinel · GitHub&lt;/code&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;（2）使用以下命令直接运行 jar 包（JDK 版本必须≥ 1.8）：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;java -jar -Dserver.port=9999 sentinel-dashboard-1.8.2.jar&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;（3）启动参数说明：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;-Dserver.port&lt;/code&gt;：指定启动的端口，默认8080&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;-Dproject.name&lt;/code&gt;：指定本服务的名称&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;-Dcsp.sentinel.dashboard.server&lt;/code&gt;：指定sentinel控制台的地址，用于将自己注册进入实现监控自己&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;-Dsentinel.dashboard.auth.username=sentinel&lt;/code&gt; 用于指定控制台的登录用户名为 &quot;sentinel&quot;，默认值为 “sentinel”&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;-Dsentinel.dashboard.auth.password=123456&lt;/code&gt; 用于指定控制台的登录密码为 &quot;123456&quot;，默认值为 &quot;sentinel&quot;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;-Dserver.servlet.session.timeout=7200&lt;/code&gt; 用于指定 Spring Boot 服务端 session 的过期时间，如 7200 表示 7200 秒；60m 表示 60 分钟，默认为 30 分钟，需要注意的是，部署多台控制台时，session 默认不会在各实例之间共享，这一块需要自行改造。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;更多具体启动参数配置如下图：&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1.0797186400937866&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/knmrNHnmCLGVzxh38ed9LXOgwib5TiaDgXgzR15VMREgS8EE7eDF1zibc4icgUiaK8UficMnV6wiaNWevTw3YfUjce4pA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;853&quot;/&gt;&lt;p&gt;&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;官方文档地址：https://github.com/alibaba/Sentinel/wiki/%E6%8E%A7%E5%88%B6%E5%8F%B0&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;（4）控制台访问地址：&lt;code&gt;http://localhost:9999&lt;/code&gt;，默认账号密码都为 &lt;code&gt;sentinel/sentinel&lt;/code&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5711775043936731&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/knmrNHnmCLGVzxh38ed9LXOgwib5TiaDgXxSGTLhXIoYIJib9IFMYgibdLlYAJCkEHkMHuoOFJaarpmJFk513hgGkg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;569&quot;/&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;br/&gt;&lt;/h2&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;二、SpringBoot 整合 sentinel-dashboard&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;接下来我们介绍下 SpringBoot 集成 &lt;code&gt;sentinel-dashboard&lt;/code&gt; 控制台进行规则配置。那为什么要集成 &lt;code&gt;sentinel-dashboard&lt;/code&gt; 控制台，sentinel 不是提供了相关的API吗？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其实 SpringBoot 官方一直提倡 &lt;code&gt;约定&amp;gt;配置&amp;gt;编码&lt;/code&gt; 的规则，能够不硬编码何乐而不为呢？因此本文后续内容主要还是结合 &lt;code&gt;sentinel-dashboard&lt;/code&gt; 控制台进行讲解，关于API的使用大家可以按照官方文档学习，讲解的非常清楚，这里就不过多介绍了。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;1、引入依赖：&lt;/span&gt;&lt;/h4&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;&amp;lt;&lt;span&gt;dependency&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&amp;lt;&lt;span&gt;groupId&lt;/span&gt;&amp;gt;&lt;/span&gt;com.alibaba.cloud&lt;span&gt;&amp;lt;/&lt;span&gt;groupId&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&amp;lt;&lt;span&gt;artifactId&lt;/span&gt;&amp;gt;&lt;/span&gt;spring-cloud-starter-alibaba-sentinel&lt;span&gt;&amp;lt;/&lt;span&gt;artifactId&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&amp;lt;/&lt;span&gt;dependency&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;2、添加配置：&lt;/span&gt;&lt;/h4&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;# sentinel看板的地址&lt;/span&gt;&lt;br/&gt;&lt;span&gt;spring.cloud.sentinel.transport.dashboard&lt;/span&gt; &lt;span&gt;=&lt;/span&gt; &lt;span&gt;localhost:9999&lt;/span&gt;&lt;br/&gt;&lt;span&gt;# 开启对sentinel看板的饥饿式加载。sentinel默认是懒加载机制，只有访问过一次的资源才会被监控，通过关闭懒加载，在项目启动时就连接sentinel控制台&lt;/span&gt;&lt;br/&gt;&lt;span&gt;spring.cloud.sentinel.eager&lt;/span&gt; &lt;span&gt;=&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;3、新建测试接口：&lt;/span&gt;&lt;/h4&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;@RestController&lt;/span&gt;&lt;br/&gt;&lt;span&gt;@RequestMapping&lt;/span&gt;(&lt;span&gt;&quot;/sentinel&quot;&lt;/span&gt;)&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;FlowLimitController&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;@GetMapping&lt;/span&gt;(&lt;span&gt;&quot;/test&quot;&lt;/span&gt;)&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; String &lt;span&gt;test&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;&quot;接收到一条消息--------&quot;&lt;/span&gt;;&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;4、启动微服务：&lt;/span&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;启动微服务，然后浏览器输入：&lt;code&gt;http://localhost:9999/sentinel/test&lt;/code&gt;，此时查看sentinel控制台，将会看见 &lt;code&gt;sentinel-service&lt;/code&gt; 这个服务已经被监控了，如下图：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.3312769895126465&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/knmrNHnmCLGVzxh38ed9LXOgwib5TiaDgXRibUbdYHDxN9JkNkOl2YL1Cz4Yxydy9oYx7GkjibOY8jIgHvwEZRiaUiag/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1621&quot;/&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;/&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;/&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;三、Sentinel-dashboard的使用与规则配置&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;前面我们基于 SpringBoot 整合了 &lt;code&gt;Sentinel-dashboard&lt;/code&gt;，这一部分我们就详细介绍下 &lt;code&gt;sentinel-dashboard&lt;/code&gt; 控制台的使用。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;1、资源与规则：&lt;/span&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;Sentinel&lt;/code&gt; 可以简单分为 &lt;code&gt;Sentinel&lt;/code&gt; 核心库和 &lt;code&gt;Dashboard&lt;/code&gt;，核心库不依赖 &lt;code&gt;Dashboard&lt;/code&gt;，但是结合 &lt;code&gt;Dashboard&lt;/code&gt; 可以获得更好的效果。使用 &lt;code&gt;Sentinel&lt;/code&gt; 来进行资源保护，主要分为几个步骤:&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;（1）定义资源：&lt;/strong&gt; 资源可以是程序中的任何内容，例如一个服务，服务里的方法，甚至是一段代码。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;（2）定义规则：&lt;/strong&gt; Sentinel 支持以下几种规则：流量控制规则、熔断降级规则、系统保护规则、来源访问控制规则 和 热点参数规则。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;（3）检验规则是否生效&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;由于 Sentinel 中所有的规则都可以在动态地查询和修改，并且修改后立即生效，并且 Sentinel 中资源定义和规则的配置是分离的。因此在编码时，我们先把需要保护的资源定义好（埋点），之后便可以在需要的时候动态配置规则了。也可以理解为，只要有了资源，我们就能在任何时候灵活地定义各种规则。&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;1.1、定义资源：&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;对于资源的定义有两种，一种是硬编码的方式，一种是通过 &lt;code&gt;@SentinelResource&lt;/code&gt; 注解的方式。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;（1）硬编码方式(不推荐)：&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但由于硬编码的方式对代码的侵入性太强，不推荐使用，所以我们在下文只简单介绍下了如何使用&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;① 抛出异常的方式定义资源：SphU&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;使用 &lt;code&gt;SphU.entry(“资源名”)&lt;/code&gt;定义资源的方式主要用于 &lt;code&gt;try-catch&lt;/code&gt;，将需要保护的代码使用 &lt;code&gt;SphU.entry(&quot;资源名&quot;)&lt;/code&gt; 和 &lt;code&gt;entry.exit()&lt;/code&gt; 包围起来，当 catch 到 &lt;code&gt;BlockException&lt;/code&gt; 时执行异常处理&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;代码示例：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;Entry entry = &lt;span&gt;null&lt;/span&gt;;&lt;br/&gt;&lt;span&gt;try&lt;/span&gt; {&lt;br/&gt;    &lt;span&gt;// 定义一个sentinel保护的资源，&lt;/span&gt;&lt;br/&gt;    entry = SphU.entry(resourceName);&lt;br/&gt;    &lt;span&gt;// 被保护的业务逻辑&lt;/span&gt;&lt;br/&gt;} &lt;span&gt;catch&lt;/span&gt; (BlockException e) {&lt;br/&gt;    &lt;span&gt;// 如果被保护的资源被限流或者降级了，就会抛出BlockException&lt;/span&gt;&lt;br/&gt;    log.warn(&lt;span&gt;&quot;资源被限流或降级了&quot;&lt;/span&gt;, e);&lt;br/&gt;} &lt;span&gt;catch&lt;/span&gt; (InterruptedException e) {&lt;br/&gt;    log.error(&lt;span&gt;&quot;发生InterruptedException&quot;&lt;/span&gt;,e);&lt;br/&gt;} &lt;span&gt;finally&lt;/span&gt; {&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (entry != &lt;span&gt;null&lt;/span&gt;) {&lt;br/&gt;        entry.exit();&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在下面的例子中， 用 &lt;code&gt;try-with-resources&lt;/code&gt; 来定义资源。参考代码如下:&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;(String[] args)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;// 配置规则.&lt;/span&gt;&lt;br/&gt;    initFlowRules();&lt;br/&gt; &lt;br/&gt;    &lt;span&gt;// 1.5.0 版本开始可以直接利用 try-with-resources 特性&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;try&lt;/span&gt; (Entry entry = SphU.entry(resourceName)) {&lt;br/&gt;        &lt;span&gt;// 被保护的逻辑&lt;/span&gt;&lt;br/&gt;        System.out.println(&lt;span&gt;&quot;hello world&quot;&lt;/span&gt;);&lt;br/&gt;    } &lt;span&gt;catch&lt;/span&gt; (BlockException ex) {&lt;br/&gt;        &lt;span&gt;// 处理被流控的逻辑&lt;/span&gt;&lt;br/&gt;        System.out.println(&lt;span&gt;&quot;blocked!&quot;&lt;/span&gt;);&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;② 返回布尔值的方式定义资源：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;使用 &lt;code&gt;SphO.entry(“资源名”)&lt;/code&gt; 定义资源的方式主要用于 &lt;code&gt;if-else&lt;/code&gt;，当资源发生触发 &lt;code&gt;sentinel&lt;/code&gt; 规则之后就会返回 false，这时可以根据返回值，进行限流降级的处理逻辑。&lt;/p&gt;&lt;article data-content=&quot;[{&#x27;type&#x27;:&#x27;block&#x27;,&#x27;id&#x27;:&#x27;EzhH-1661857738918&#x27;,&#x27;name&#x27;:&#x27;paragraph&#x27;,&#x27;data&#x27;:{&#x27;version&#x27;:1},&#x27;nodes&#x27;:[{&#x27;type&#x27;:&#x27;text&#x27;,&#x27;id&#x27;:&#x27;3Twb-1661857738916&#x27;,&#x27;leaves&#x27;:[{&#x27;text&#x27;:&#x27;Tom哥开知识星球啦！一起搞事情！&#x27;,&#x27;marks&#x27;:[]}]}],&#x27;state&#x27;:{}}]&quot;&gt;&lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;https://mp.weixin.qq.com/s?__biz=Mzg2NzYyNjQzNg==&amp;amp;mid=2247502324&amp;amp;idx=1&amp;amp;sn=d50366d73cbb6af01d04989e430d60f7&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;你已选中了添加链接的内容&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;关注【码哥字节】&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;&lt;/article&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;示例代码如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;// 资源名可使用任意有业务语义的字符串&lt;/span&gt;&lt;br/&gt;&lt;span&gt;if&lt;/span&gt; (SphO.entry(&lt;span&gt;&quot;自定义资源名&quot;&lt;/span&gt;)) {&lt;br/&gt;  &lt;span&gt;// 务必保证finally会被执行&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;try&lt;/span&gt; {&lt;br/&gt;    &lt;span&gt;/**&lt;br/&gt;    * 被保护的业务逻辑&lt;br/&gt;    */&lt;/span&gt;&lt;br/&gt;  } &lt;span&gt;finally&lt;/span&gt; {&lt;br/&gt;    SphO.exit();&lt;br/&gt;  }&lt;br/&gt;} &lt;span&gt;else&lt;/span&gt; {&lt;br/&gt;  &lt;span&gt;// 资源访问阻止，被限流或被降级&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;// 进行相应的处理操作&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;注意：&lt;code&gt;SphO.entry(xxx)&lt;/code&gt; 需要与 &lt;code&gt;SphO.exit() &lt;/code&gt;方法成对出现，匹配调用，位置正确，否则会导致调用链记录异常，抛出 &lt;code&gt;ErrorEntryFreeException&lt;/code&gt; 异常。&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;（2）@SentinelResource注解方式(推荐)：&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;使用 &lt;code&gt;@SentinelResource&lt;/code&gt; 注解可以更加的灵活的定义资源，如下示例就定义了一个名为 “HelloWorld” 的资源&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;@SentinelResource&lt;/span&gt;(&lt;span&gt;&quot;HelloWorld&quot;&lt;/span&gt;)&lt;br/&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;helloWorld&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;// 资源中的逻辑&lt;/span&gt;&lt;br/&gt;    System.out.println(&lt;span&gt;&quot;hello world&quot;&lt;/span&gt;);&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;需要注意的是，&lt;code&gt;@SentinelResource&lt;/code&gt; 注解用于定义资源埋点，但不支持 private 方法。默认情况下，Sentinel 对控制资源的保护处理是直接抛出异常，这样对用户不友好，所以我们需要通过可选的异常处理 &lt;code&gt;blockHandler&lt;/code&gt; 和 &lt;code&gt;fallback&lt;/code&gt; 配置项处理一下异常信息。&lt;code&gt;@SentinelResource&lt;/code&gt; 注解包含以下属性：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;① value：&lt;/strong&gt; 资源名称，必需项&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;② entryType：&lt;/strong&gt; entry 类型，可选项（默认为 &lt;code&gt;EntryType.OUT&lt;/code&gt;）&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;③ blockHandler/blockHandlerClass：&lt;/strong&gt; &lt;code&gt;blockHandler&lt;/code&gt; 指定函数负责处理 &lt;code&gt;BlockException&lt;/code&gt; 异常，可选项。&lt;code&gt;blockHandler&lt;/code&gt; 函数默认需要和原方法在同一个类中，通过指定 &lt;code&gt;blockHandlerClass&lt;/code&gt; 为对应类的 Class 对象，则可以指定其他类中的函数，但注意对应的函数必需为 static 函数，否则无法解析。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;blockHandler&lt;/code&gt; 函数访问范围需要是 public，返回类型需要与原方法相匹配，参数类型必须和原方法一致并且最后加一个类型为 &lt;code&gt;BlockException&lt;/code&gt; 的异常参数。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;④ fallback /fallbackClass：&lt;/strong&gt; fallback 指定的函数负责处理业务运行的异常，可选项，&lt;code&gt;fallback&lt;/code&gt; 函数可以针对所有类型的异常（除了&lt;code&gt;exceptionsToIgnore&lt;/code&gt;里面排除掉的异常类型）进行处理。&lt;code&gt;fallback&lt;/code&gt; 函数默认需要和原方法在同一个类中，通过指定 &lt;code&gt;fallbackClass&lt;/code&gt; 为对应类的 Class 对象，则可以指定指定为其他类的函数，但注意对应的函数必需为 static 函数，否则无法解析。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;fallback&lt;/code&gt; 函数的返回值类型必须与原函数返回值类型一致；方法参数列表需要和原函数一致，或者可以额外多一个 &lt;code&gt;Throwable&lt;/code&gt; 类型的参数用于接收对应的异常。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;⑤ defaultFallback（since 1.6.0）：&lt;/strong&gt; 默认的 &lt;code&gt;fallback&lt;/code&gt; 函数名称，可选项，通常用于通用的 fallback 逻辑。&lt;code&gt;defaultFallback&lt;/code&gt; 函数默认需要和原方法在同一个类中，通过指定 &lt;code&gt;fallbackClass&lt;/code&gt; 为对应类的 Class 对象，则可以指定指定为其他类的函数，但注意对应的函数必需为 static 函数，否则无法解析。&lt;code&gt;defaultFallback&lt;/code&gt; 函数可以针对所有类型的异常（除了 &lt;code&gt;exceptionsToIgnore&lt;/code&gt; 里面排除掉的异常类型）进行处理。若同时配置了 &lt;code&gt;fallback&lt;/code&gt;和 &lt;code&gt;defaultFallback&lt;/code&gt;，则只有 &lt;code&gt;fallback&lt;/code&gt;会生效。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;defaultFallback&lt;/code&gt;函数的返回值类型必须与原函数返回值类型一致；方法参数列表需要为空，或者可以额外多一个 &lt;code&gt;Throwable&lt;/code&gt; 类型的参数用于接收对应的异常。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;⑥ exceptionsToIgnore（since 1.6.0）：&lt;/strong&gt; 用于指定哪些异常被排除掉，不会计入异常统计中，也不会进入 &lt;code&gt;fallback&lt;/code&gt; 逻辑中，而是会原样抛出。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;特别地，若 &lt;code&gt;blockHandler&lt;/code&gt; 和 &lt;code&gt;fallback&lt;/code&gt; 都进行了配置，则被限流降级而抛出 &lt;code&gt;BlockException&lt;/code&gt; 时只会进入 &lt;code&gt;blockHandler&lt;/code&gt; 处理逻辑。若未配置 &lt;code&gt;blockHandler&lt;/code&gt;、&lt;code&gt;fallback&lt;/code&gt; 和 &lt;code&gt;defaultFallback&lt;/code&gt;，则被限流降级时会将 &lt;code&gt;BlockException&lt;/code&gt; 直接抛出（若方法本身未定义 &lt;code&gt;throws BlockException&lt;/code&gt; 则会被 JVM 包装一层 &lt;code&gt;UndeclaredThrowableException&lt;/code&gt;）&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;@SentinelResource&lt;/code&gt; 的 &lt;code&gt;fallback&lt;/code&gt; 负责业务运行的异常，&lt;code&gt;blockHandler&lt;/code&gt; 负责 &lt;code&gt;sentinel&lt;/code&gt; 配置的违规。&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;1.2、定义规则：&lt;/h5&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;    Sentinel 支持以下几种规则：流量控制规则、熔断降级规则、系统保护规则、来源访问控制规则 和 热点参数规则。而定义规则同样支持两种方式：一种是硬编码的方式，一种是通过 sentinel-dashboard 控制台直接配置，这部分我们在下文会继续介绍。&lt;/code&gt;&lt;/pre&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;2、流控规则：&lt;/span&gt;&lt;/h4&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;2.1、流控规则的核心属性：&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;流量控制，原理是监控应用流量的 QPS 或 并发线程数 等指标，当达到指定阈值时对流量进行控制，避免系统被瞬时的流量高峰冲垮，保障应用高可用性。同一个资源可以创建多条限流规则，一条限流规则由以下属性组成：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;① resource：&lt;/strong&gt; 资源名，即限流规则的作用对象，默认请求路径。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;② limitApp：&lt;/strong&gt; 流控针对的调用来源，若为 default 则不区分调用来源，默认值default&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;③ count：&lt;/strong&gt; 限流阈值&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;④ grade：&lt;/strong&gt; 限流阈值类型（1代表 QPS，0 代表并发线程数），默认值QPS&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;⑤ strategy：&lt;/strong&gt; 流控模式&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;直接拒绝（默认）：&lt;/strong&gt; 接口达到限流条件时，直接限流&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;关联：&lt;/strong&gt; 当关联的资源达到阈值时，就限流自己（适合做应用让步）&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;链路：&lt;/strong&gt; 只记录指定链路上的流量，指定资源从入口资源进来的流量，如果达到阈值，就可以限流&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;⑥ controlBehavior：&lt;/strong&gt; 流控效果&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;快速失败（默认）：&lt;/strong&gt; 当 QPS 超过任意规则的阈值后，新的请求就会被立即拒绝，拒绝方式为抛出&lt;code&gt;FlowException&lt;/code&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;排队等待：&lt;/strong&gt; 这种方式严格控制了请求通过的间隔时间，也即是让请求以均匀的速度通过，对应的是漏桶算法。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;Warm Up：&lt;/strong&gt; 该方式主要用于系统长期处于低水位的情况下，当流量突然增加时，直接把系统拉升到高水位可能瞬间把系统压垮。通过&quot;冷启动&quot;，让通过的流量缓慢增加，在一定时间内逐渐增加到阈值上限，给冷系统一个预热的时间，避免冷系统被压垮的情况。预热底层是根据令牌桶算法实现的。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;以上几种属性在 &lt;code&gt;sentinel-dashboard&lt;/code&gt; 控制台对应的规则如下图：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.7223042836041359&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/knmrNHnmCLGVzxh38ed9LXOgwib5TiaDgXDY7zGNUL97XI8SVuGSWvG3fLHNnXqfa56gJ9GiaopnQ2QiaIwMibgQo8g/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;677&quot;/&gt;&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;2.2、阈值类型：&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;（1）基于 QPS 的流控：&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;QPS，每秒请求数，即在不断向服务器发送请求的情况下，服务器每秒能够处理的请求数量。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;（2）基于并发线程数的流控：&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;并发数控制用于保护业务线程池不被慢调用耗尽。例如，当应用所依赖的下游应用由于某种原因导致服务不稳定、响应延迟增加，对于调用者来说，意味着吞吐量下降和更多的线程数占用，极端情况下甚至导致线程池耗尽。为应对太多线程占用的情况，业内有使用隔离的方案，比如：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;通过不同业务逻辑使用不同线程池来隔离业务自身之间的资源争抢（线程池隔离），这种隔离方案虽然隔离性比较好，但是代价就是线程数目太多，线程上下文切换的 overhead 比较大，特别是对低延时的调用有比较大的影响。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;使用信号量来控制同时请求的个数（信号量隔离），这种隔离方案虽然能够控制线程数量，但无法控制请求排队时间，当请求过多时排队也是无益的，直接拒绝能够迅速降低系统压力。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;Sentinel&lt;/code&gt; 并发线程数限流不负责创建和管理线程池，而是简单统计当前请求上下文的线程个数（正在执行的调用数目），如果超出阈值，新的请求会被立即拒绝，效果类似于信号量隔离。并发数控制通常在调用端进行配置。&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;2.3、流控效果：&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当系统的流量超过设定的阈值时，&lt;code&gt;sentinel&lt;/code&gt; 则采取措施进行流量控制，流控效果总共分为三种：&lt;strong&gt;快速失败、Warm Up、排队等待&lt;/strong&gt;。对应的 &lt;code&gt;FlowRule&lt;/code&gt; 中的 &lt;code&gt;controlBehavior&lt;/code&gt; 字段。&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;快速失败（默认）：&lt;/strong&gt; 当 QPS 超过任意规则的阈值后，新的请求就会被立即拒绝，拒绝方式为抛出&lt;code&gt;FlowException&lt;/code&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;排队等待：&lt;/strong&gt; 这种方式严格控制了请求通过的间隔时间，也即是让请求以均匀的速度通过，对应的是漏桶算法。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;Warm Up：&lt;/strong&gt; 该方式主要用于系统长期处于低水位的情况下，当流量突然增加时，直接把系统拉升到高水位可能瞬间把系统压垮。通过&quot;冷启动&quot;，让通过的流量缓慢增加，在一定时间内逐渐增加到阈值上限，给冷系统一个预热的时间，避免冷系统被压垮的情况。预热底层是根据令牌桶算法实现的。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;注意：若使用除了快速失败之外的流量控制效果，则调用关系限流策略（&lt;code&gt;strategy&lt;/code&gt;）会被忽略。&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;（1）快速失败：&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;默认的流量控制方式，当 QPS 超过任意规则的阈值后，新的请求就会被立即拒绝，拒绝方式为抛出&lt;code&gt;FlowException&lt;/code&gt;。这种方式适用于对系统处理能力确切已知的情况下，比如通过压测确定了系统的准确水位时&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;（2）Warm Up：&lt;/strong&gt;&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;注意：该方式只针对 QPS 流控，对并发线程数流控不支持&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;即预热/冷启动方式，该方式主要用于系统长期处于低水位的情况下，当流量突然增加时，直接把系统拉升到高水位可能瞬间把系统压垮。通过&quot;冷启动&quot;，让通过的流量缓慢增加，在一定时间内逐渐增加到阈值上限，给冷系统一个预热的时间，避免冷系统被压垮的情况。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;预热底层是根据令牌桶算法实现的，源码对应得类在 &lt;code&gt;com.alibaba.csp.sentinel.slots.block.flow.controller.WarmUpController&lt;/code&gt; 中，算法中有一个冷却因子&lt;code&gt;coldFactor&lt;/code&gt;，默认值是3，即请求 QPS 从 &lt;code&gt;threshold(阈值) / 3 &lt;/code&gt;开始，经预热时长逐渐升至设定的 QPS 阈值。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;比如通过 &lt;code&gt;sentinel-dashboard&lt;/code&gt; 设定 &lt;code&gt;testWarmUP&lt;/code&gt; 资源的 QPS 阈值为，流控效果为 &lt;code&gt;warm up&lt;/code&gt;，预热时长为5秒，如下图所示，&lt;code&gt;testWarmUP&lt;/code&gt; 资源刚开始限流的阈值为 &lt;code&gt;20/3=7&lt;/code&gt;，但经过10秒的预热后，慢慢将阈值升至20。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.7716535433070866&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/knmrNHnmCLGVzxh38ed9LXOgwib5TiaDgXpXyeZHr8Tn5Yr3o66dZOlBRN1POpuUXG31O7mo54HTo23NBPCYKcVQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;508&quot;/&gt;通常冷启动的过程系统允许通过的 QPS 曲线如下图所示：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.8315972222222222&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/knmrNHnmCLGVzxh38ed9LXOgwib5TiaDgXZJb1D1rzOtAZMGvbwicfZ2Cg2x3D8Zn2YWInrQNB8uYayd6MuufCrOw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;576&quot;/&gt;比如秒杀系统在开启瞬间，会有很多流量上来，很可能把系统打死，预热方式就是为了保护系统，可慢慢的把流量放进来，慢慢的把阈值增长到设置的阈值。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;（3）排队等待：&lt;/strong&gt;&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;注意：这一效果只针对QPS流控，并发线程数流控不支持。&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;排队等待的方式会以匀速排队方式严格控制请求通过的间隔时间，也就是让请求以均匀的速度通过，其余的排队等待，它还会让设置一个超时时间，当请求超过超时间时间还未处理，则会被丢弃。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;对应的是漏桶算法，源码对应得类：&lt;code&gt;com.alibaba.csp.sentinel.slots.block.flow.controller.RateLimiterController&lt;/code&gt;。该方式的作用如下图：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.37404580152671757&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/knmrNHnmCLGVzxh38ed9LXOgwib5TiaDgX0KcVAd20VQen1d06QOo9Up1kk47icRFsa0uKI6N9xl7Ixytc7iaU00Aw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;655&quot;/&gt;该方式主要用于处理间隔性突发的流量。假设某时刻来了大流量的请求，如果此时要处理所有请求，很可能会导致系统负载过高，影响稳定性。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但其实接下来几秒可能系统处于空闲状态，若直接把多余的请求丢弃则没有充分利用系统的处理能力，所以我们希望系统能够在接下来的空闲期间逐渐处理这些请求，而不是在第一秒直接拒绝多余的请求。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;Sentinel&lt;/code&gt; 的 &lt;code&gt;Rate Limiter&lt;/code&gt; 模式能在某一段时间间隔内以匀速方式处理这样的请求, 充分利用系统的处理能力, 也就是削峰填谷, 保证资源的稳定性。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;Sentinel&lt;/code&gt;会以固定的间隔时间让请求通过, 访问资源，当请求到来时，如果当前请求距离上个通过的请求通过的时间间隔不小于预设值，则让当前请求通过；否则，计算当前请求的预期通过时间，如果该请求的预期通过时间大于规则预设的 &lt;code&gt;timeout&lt;/code&gt; 时间，则该请求会等待直到预设时间到来通过；反之，则马上抛出阻塞异常。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;下图能很形象的展示这种场景的削峰填谷的作用：X轴代表时间，Y轴代表系统处理的请求&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5887681159420289&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/knmrNHnmCLGVzxh38ed9LXOgwib5TiaDgXUMxibLRoZdtHRsYibhkGJtP2JY2M40xW5H3ricK2TbQzH84WNoHo7iaXyg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;552&quot;/&gt;比如通过 &lt;code&gt;sentinel-dashboard&lt;/code&gt; 对 &lt;code&gt;service&lt;/code&gt; 资源设置限流阈值为10，流控效果为排队等候，每秒10次请求时，再有请求就排队等候，等待超时时间为 10000ms，超时过后，请求将被踢出排队队列，返回限流异常。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.8328611898016998&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/knmrNHnmCLGVzxh38ed9LXOgwib5TiaDgXKSr4Mia1oSskMqibLN3ibrGickqEowI6oazLHGrppmeyOvfKWhhGuOZib0A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;706&quot;/&gt;&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;2.4、流控模式：&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;调用关系包括调用方、被调用方；一个方法又可能会调用其它方法，形成一个调用链路的层次关系。&lt;code&gt;Sentinel&lt;/code&gt; 通过 &lt;code&gt;NodeSelectorSlot&lt;/code&gt; 建立不同资源间的调用的关系，并且通过 &lt;code&gt;ClusterBuilderSlot&lt;/code&gt; 记录每个资源的实时统计信息。有了调用链路的统计信息，我们可以衍生出多种流量控制模式，总共分为三种，对应属性为 &lt;code&gt;strategy&lt;/code&gt;：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;直接拒绝（默认）：&lt;/strong&gt; 接口达到限流条件时，直接限流&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;关联：&lt;/strong&gt; 当关联的资源达到阈值时，就限流自己（适合做应用让步）&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;链路：&lt;/strong&gt; 只记录指定链路上的流量，指定资源从入口资源进来的流量，如果达到阈值，就可以限流&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;（1）直接拒绝：&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;默认的流控模式，当QPS超过任意规则的阈值后，新的请求就会被立即拒绝，拒绝方式为抛出 &lt;code&gt;FlowException&lt;/code&gt;，这里不再详细介绍。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;（2）关联：&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当两个资源之间具有资源争抢或者依赖关系的时候，这两个资源便具有了关联，该流控模式的作用是当关联的资源达到阈值时，就限流自己，适合做应用让步。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;比如对数据库同一个字段的读操作和写操作存在争抢，读的速度过高会影响写得速度，写的速度过高会影响读的速度，如果放任读写操作争抢资源，则争抢本身带来的开销会降低整体的吞吐量，这时可使用关联限流来避免具有关联关系的资源之间过度的争抢。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;举例来说，&lt;code&gt;read_db&lt;/code&gt; 和 &lt;code&gt;write_db&lt;/code&gt; 这两个资源分别代表数据库读写，我们可以给 &lt;code&gt;read_db&lt;/code&gt; 设置限流规则来达到写优先的目的&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;还有一个例子，电商的 下订单 和 支付 两个操作，一旦支付接口达到了阈值，那么需要优先保障支付操作， 那么订单接口就应用被限流，从而保护支付的目的。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;@RestController&lt;/span&gt;&lt;br/&gt;&lt;span&gt;@RequestMapping&lt;/span&gt;(&lt;span&gt;&quot;/sentinel&quot;&lt;/span&gt;)&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;FlowLimitController&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt; &lt;br/&gt;    &lt;span&gt;/**&lt;br/&gt;     * 下单接口&lt;br/&gt;     */&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;@GetMapping&lt;/span&gt;(&lt;span&gt;&quot;/order&quot;&lt;/span&gt;)&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; String &lt;span&gt;order&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;  &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;&quot;下单成功..........&quot;&lt;/span&gt;;&lt;br/&gt;    }&lt;br/&gt; &lt;br/&gt;    &lt;span&gt;/**&lt;br/&gt;     * 支付接口&lt;br/&gt;     */&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;@GetMapping&lt;/span&gt;(&lt;span&gt;&quot;/pay&quot;&lt;/span&gt;)&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; String &lt;span&gt;pay&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;  &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;&quot;支付成功..........&quot;&lt;/span&gt;;&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;此时的流控规则配置如下图：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.7957639939485628&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/knmrNHnmCLGVzxh38ed9LXOgwib5TiaDgXHo5TE3ztlzmeZIWjVBxlzUxLibibYQtqMybsGI3ISQmdj3o59glsuE2Q/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;661&quot;/&gt;注意：关联之后，这里设置的限流规则是针对被关联资源，也就是 &lt;code&gt;/sentinel/pay&lt;/code&gt; 这个资源，但是真正被限流则是 &lt;code&gt;/sentinel/order&lt;/code&gt;。我们只需要不断的请求 &lt;code&gt;/sentinel/pay&lt;/code&gt; 达到阈值，然后在请求 &lt;code&gt;/sentinel/order&lt;/code&gt;，就可以看到订单接口被限流了&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.11964549483013294&quot; data-type=&quot;png&quot; data-w=&quot;677&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/knmrNHnmCLGVzxh38ed9LXOgwib5TiaDgXX1x2r21S4me8ocUVZUziawicOR54N7L7X0XxvoGeo2ICqrRTsC1K9zXQ/640?wx_fmt=png&quot;/&gt;&lt;strong&gt;（3）链路：&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;该流控模式针对资源链路上的接口进行限流，例如：A、B两个接口都调用某一资源C，&lt;code&gt;A -&amp;gt; C、B -&amp;gt; C&lt;/code&gt; 可以看成两个简单的链路，此时可以针对C配置链路限流，比如限制A调用C，而B调用C则不受影响，它的功能有点类似于针对来源配置项，但链路流控是针对上级接口，它的粒度更细。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;@RestController&lt;/span&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;TestController&lt;/span&gt;  &lt;/span&gt;{&lt;br/&gt; &lt;br/&gt;    &lt;span&gt;@Autowired&lt;/span&gt;&lt;br/&gt;    TestService testService;&lt;br/&gt; &lt;br/&gt;    &lt;span&gt;@GetMapping&lt;/span&gt;(&lt;span&gt;&quot;/test&quot;&lt;/span&gt;)&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; String &lt;span&gt;test&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;span&gt;throws&lt;/span&gt; InterruptedException &lt;/span&gt;{&lt;br/&gt;        testService.test();&lt;br/&gt;        System.out.println(&lt;span&gt;&quot;链路流控模式限流示例&quot;&lt;/span&gt;);&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;&quot;test&quot;&lt;/span&gt;;&lt;br/&gt;    }&lt;br/&gt; &lt;br/&gt;    &lt;span&gt;@GetMapping&lt;/span&gt;(&lt;span&gt;&quot;/test1&quot;&lt;/span&gt;)&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; String &lt;span&gt;test1&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt;{&lt;br/&gt;        testService.test();&lt;br/&gt;        System.out.println(&lt;span&gt;&quot;正常链路接口&quot;&lt;/span&gt;);&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;&quot;test&quot;&lt;/span&gt;;&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;@Service&lt;/span&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;TestService&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt; &lt;br/&gt;    &lt;span&gt;@SentinelResource&lt;/span&gt;(value = &lt;span&gt;&quot;service&quot;&lt;/span&gt;)&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;test&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        System.out.println(&lt;span&gt;&quot;service&quot;&lt;/span&gt;);&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;添加配置：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;spring.cloud.sentinel.web-context-unify=&lt;span&gt;false&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;此时的流控规则配置如下图：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.797583081570997&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/knmrNHnmCLGVzxh38ed9LXOgwib5TiaDgXCMkuP8vajA61iclT2kubZowb1aDYTVedAiab7F2d5kc7VWXduibXiaHYuw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;662&quot;/&gt;不断访问 test 和 test1 两个接口，发现即使 test 接口被限流了，test1 接口也不受影响。&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;2.5、流控规则的硬编码方式：&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;前面的示例都是基于 &lt;code&gt;sentinel-dashboard&lt;/code&gt; 控制台去定义限流规则，但我们也可以通过调用 &lt;code&gt;FlowRuleManager.loadRules()&lt;/code&gt; 方法来用硬编码的方式定义流量控制规则，比如：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;initFlowQpsRule&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    List&amp;lt;FlowRule&amp;gt; rules = &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;&amp;gt;();&lt;br/&gt;    FlowRule rule = &lt;span&gt;new&lt;/span&gt; FlowRule(resourceName);&lt;br/&gt;    &lt;span&gt;// set limit qps to 20&lt;/span&gt;&lt;br/&gt;    rule.setCount(&lt;span&gt;20&lt;/span&gt;);&lt;br/&gt;    rule.setGrade(RuleConstant.FLOW_GRADE_QPS);&lt;br/&gt;    rule.setLimitApp(&lt;span&gt;&quot;default&quot;&lt;/span&gt;);&lt;br/&gt;    rules.add(rule);&lt;br/&gt;    FlowRuleManager.loadRules(rules);&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;官网示例链接：&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;https://github.com/alibaba/Sentinel/wiki/如何使用#流量控制规则-flowrule&lt;/p&gt;&lt;/blockquote&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;3、熔断降级规则：&lt;/span&gt;&lt;/h4&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;3.1、熔断降级规则的核心属性：&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;熔断机制可以防止应用程序不断执行可能失败的操作，快速地拒绝可能导致错误的调用，当感知到下游服务的资源出现不稳定状态（调用超时或异常比例升高时），暂时切断对下游服务的调用，而不是一直阻塞等待服务响应，阻止级联失败导致的雪崩效应，保证系统的可用性；尤其是后端太忙的时候，使用熔断设计可以保护后端不会过载。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;另外，在微服务架构下，我们一般都会设置超时与重试机制，但如果错误太多，或是在短时间内得不到修复，那么我们重试也没有意义了，这时也需要使用熔断机制快速返回结果。当资源被熔断降级后，在接下来的降级时间窗口之内，对该资源的调用都会自动返回降级数据（默认行为是抛出 &lt;code&gt;DegradeException&lt;/code&gt;），当检测到该节点的服务调用响应正常后，则恢复调用链路。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;熔断降级规则包含以下核心属性：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.417960088691796&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/knmrNHnmCLGVzxh38ed9LXOgwib5TiaDgXHMquHxu4kDETH36gQHibiaazlz2cexoPB7DjcvTO2ZianNscVxf0q0QUw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;902&quot;/&gt;以上几种属性在 &lt;code&gt;sentinel-dashboard&lt;/code&gt; 控制台对应的规则如下图：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.46153846153846156&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/knmrNHnmCLGVzxh38ed9LXOgwib5TiaDgX0sdHl3SUmb8qZX9cTfRHaogsiaauC8ATeGKg2ma2Zx4EiaQEOZTOYk5A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;546&quot;/&gt;&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;3.2、熔断策略：&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;sentinel&lt;/code&gt; 提供了以下几种荣熔断策略：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;（1）平均响应时间 ：&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;DEGRADE_GRADE_RT&lt;/code&gt;，当资源的平均响应时间超过阈值（DegradeRule 中的 count，以 ms 为单位）之后，资源会进入降级状态，那么在接下的时间窗口（&lt;code&gt;DegradeRule&lt;/code&gt; 中的 &lt;code&gt;timeWindow&lt;/code&gt;，以 s 为单位）之内，对这个方法的调用都会自动地熔断（抛出 &lt;code&gt;DegradeException&lt;/code&gt;）。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;注意：&lt;code&gt;Sentinel&lt;/code&gt; 默认统计的 RT 上限是 4900 ms，超出此阈值的都会算作 4900 ms，若需要变更此上限可以通过启动配置项 &lt;code&gt;-Dcsp.sentinel.statistic.max.rt=xxx&lt;/code&gt; 来配置。&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;（2）异常比例 ：&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;DEGRADE_GRADE_EXCEPTION_RATIO&lt;/code&gt;，当资源的每秒异常总数占通过量的比值超过阈值（&lt;code&gt;DegradeRule&lt;/code&gt; 中的 count）之后，资源进入降级状态，即在接下的时间窗口（&lt;code&gt;DegradeRule&lt;/code&gt; 中的 &lt;code&gt;timeWindow&lt;/code&gt;，以 s 为单位）之内，对这个方法的调用都会自动地熔断。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;异常比率的阈值范围是 &lt;code&gt;[0.0, 1.0]&lt;/code&gt;，代表 &lt;code&gt;0% - 100%&lt;/code&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;（3）异常数 ：&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;DEGRADE_GRADE_EXCEPTION_COUNT&lt;/code&gt;，当资源近 1 分钟的异常数目超过阈值之后会进行熔断。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;注意由于统计时间窗口是分钟级别的，若 &lt;code&gt;timeWindow&lt;/code&gt; 小于 60s，则结束熔断状态后仍可能再进入熔断状态。&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;3.3、熔断降级规则的硬编码方式：&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在 &lt;code&gt;sentinel-dashboard&lt;/code&gt; 控制台去定义熔断规则比较简单，我们就不详细展开了。除此之外，我们也可以通过调用 &lt;code&gt;DegradeRuleManager.loadRules()&lt;/code&gt; 方法来用硬编码的方式定义流量控制规则，比如：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;@PostConstruct&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;initSentinelRule&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;br/&gt;&lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;//熔断规则：5s内调用接口出现异常次数超过5的时候, 进行熔断&lt;/span&gt;&lt;br/&gt;    List&amp;lt;DegradeRule&amp;gt; degradeRules = &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;&amp;gt;();&lt;br/&gt;    DegradeRule rule = &lt;span&gt;new&lt;/span&gt; DegradeRule();&lt;br/&gt;    rule.setResource(&lt;span&gt;&quot;queryGoodsInfo&quot;&lt;/span&gt;);&lt;br/&gt;    rule.setCount(&lt;span&gt;5&lt;/span&gt;);&lt;br/&gt;    &lt;span&gt;//熔断规则&lt;/span&gt;&lt;br/&gt;    rule.setGrade(RuleConstant.DEGRADE_GRADE_EXCEPTION_COUNT);&lt;br/&gt;    rule.setTimeWindow(&lt;span&gt;5&lt;/span&gt;);&lt;br/&gt;    degradeRules.add(rule);&lt;br/&gt;    DegradeRuleManager.loadRules(degradeRules);&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;官方示例链接：&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;https://github.com/alibaba/Sentinel/wiki/如何使用#熔断降级规则-degraderule&lt;/p&gt;&lt;/blockquote&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;4、热点参数规则：&lt;/span&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;热点就是经常访问的数据，很多时候我们肯定希望统计某个访问频次 Top K 数据并对其进行限流，比如：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;商品 ID 为参数，统计一段时间内最常购买的商品 ID 并进行限制&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;用户 ID 为参数，针对一段时间内频繁访问的用户 ID 进行限制&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;热点参数限流会统计传入参数中的热点参数，并根据配置的限流阈值与模式，对包含热点参数的资源调用进行限流。热点参数限流可以看做是一种特殊的流量控制，仅对包含热点参数的资源调用生效。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Sentinel 利用 LRU 策略统计最近最常访问的热点参数，结合令牌桶算法来进行参数级别的流控。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;热点参数限流只针对QPS。&lt;/p&gt;&lt;/blockquote&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;4.1、热点参数规则的核心属性：&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;热点参数规则（&lt;code&gt;ParamFlowRule&lt;/code&gt;）类似于流量控制规则（&lt;code&gt;FlowRule&lt;/code&gt;）：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5407488986784141&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/knmrNHnmCLGVzxh38ed9LXOgwib5TiaDgXW7uSZdiaSnj8mibLjBRMEeF74QgT2eop3kgGlPhJJIib2hp7CVYQDoZ2w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;908&quot;/&gt;&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;4.2、热点参数规则的硬编码方式：&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;（1）定义资源：&lt;/strong&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;@GetMapping&lt;/span&gt;(&lt;span&gt;&quot;/byHotKey&quot;&lt;/span&gt;)&lt;br/&gt;&lt;span&gt;@SentinelResource&lt;/span&gt;(value = &lt;span&gt;&quot;byHotKey&quot;&lt;/span&gt;,blockHandler = &lt;span&gt;&quot;userAccessError&quot;&lt;/span&gt;)&lt;br/&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; String &lt;span&gt;byHotKeyTest&lt;/span&gt;&lt;span&gt;(@RequestParam(value = &lt;span&gt;&quot;userId&quot;&lt;/span&gt;, required = &lt;span&gt;false&lt;/span&gt;)&lt;/span&gt; String userId,&lt;br/&gt;                    @&lt;span&gt;RequestParam&lt;/span&gt;&lt;span&gt;(value = &lt;span&gt;&quot;goodId&quot;&lt;/span&gt;, required = &lt;span&gt;false&lt;/span&gt;)&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; goodId)&lt;br/&gt;&lt;/span&gt;{&lt;br/&gt;    log.info(Thread.currentThread().getName() + &lt;span&gt;&quot;\t&quot;&lt;/span&gt; + &lt;span&gt;&quot;...byHotKey&quot;&lt;/span&gt;);&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; &lt;span&gt;&quot;-----------by HotKey：UserId&quot;&lt;/span&gt;;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可以看到，我们上边的代码示例有两个参数，分别是 userId、goodId&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;（2）添加热点参数限流规则：&lt;/strong&gt;*&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们可以通过 &lt;code&gt;ParamFlowRuleManager&lt;/code&gt; 的 &lt;code&gt;loadRules&lt;/code&gt; 方法配置热点参数规则，案例的具体限流代码如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;ParamFlowRule pRule = &lt;span&gt;new&lt;/span&gt; ParamFlowRule(&lt;span&gt;&quot;byHotKey&quot;&lt;/span&gt;)&lt;br/&gt;    .setParamIdx(&lt;span&gt;1&lt;/span&gt;)&lt;br/&gt;    .setCount(&lt;span&gt;1&lt;/span&gt;);&lt;br/&gt;&lt;span&gt;// 针对 goodId 为1000 的参数值，单独设置限流 QPS 阈值为 5，而不是全局的阈值 1.&lt;/span&gt;&lt;br/&gt;ParamFlowItem item = &lt;span&gt;new&lt;/span&gt; ParamFlowItem().setObject(String.valueOf(&lt;span&gt;1000&lt;/span&gt;))&lt;br/&gt;                .setClassType(&lt;span&gt;int&lt;/span&gt;&lt;span&gt;.&lt;span&gt;class&lt;/span&gt;.&lt;span&gt;getName&lt;/span&gt;())&lt;br/&gt;                .&lt;span&gt;setCount&lt;/span&gt;(5)&lt;/span&gt;;&lt;br/&gt;pRule.setParamFlowItemList(Collections.singletonList(item));&lt;br/&gt; &lt;br/&gt;ParamFlowRuleManager.loadRules(Collections.singletonList(pRule));&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;官方示例链接 ：&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;https://github.com/alibaba/Sentinel/wiki/热点参数限流&lt;/p&gt;&lt;/blockquote&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;4.3、热点参数的控制台配置方式：&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1.0075901328273245&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/knmrNHnmCLGVzxh38ed9LXOgwib5TiaDgXraKibibtSol7SAv8HNN6sDevibauy7iaa3ToIq9MvVtXUbfmg52yMI7SBw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;527&quot;/&gt;上述配置的具体含义，当 “byHotKey” 这个资源的第1个参数（这里参数索引是从0开始），即 goodId 的 QPS 超过1秒1次将会被限流，需要注意的是，只有包含指定索引的参数请求才会被限流，否则不影响。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;另外，sentinel 提供了 参数例外项 这个配置，从上图配置中，我们将 参数 goodId 的参数值等于1000 时，限流阈值设置成了 5，也就是说 &lt;code&gt;goodId = 1000&lt;/code&gt; 这个请求 QPS 放宽到每秒 5 次 以上才会被限流。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;5、系统保护规则：&lt;/span&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Sentinel 系统保护的目标是在系统不被拖垮的情况下，提高系统的吞吐率，系统自适应限流从整体维度对应用入口流量进行控制，从单台机器的 Load、CPU 使用率、总体平均 RT、入口 QPS 和 并发线程数 等几个维度的监控指标，通过自适应的流控策略，让系统的入口流量和系统的负载达到一个平衡，让系统尽可能跑在最大吞吐量的同时保证系统整体的稳定性。&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;5.1、系统保护规则的核心属性：&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;系统保护规则包含下面几个重要的属性：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.39028475711892796&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/knmrNHnmCLGVzxh38ed9LXOgwib5TiaDgXibrAe2dBYobtFTicrYT938cMdo1FP4e7uG7zZLkVZqlY68YeVCg5EwMg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;597&quot;/&gt;所以，&lt;code&gt;sentinel&lt;/code&gt; 的系统保护支持以下几种模式：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;Load 自适应：&lt;/strong&gt;（仅对 Linux/Unix-like 机器生效）系统的 load1 作为触发指标，进行自适应系统保护。当系统 load1 超过设定的触发值，且系统当前的并发线程数超过估算的系统容量时才会触发系统保护（BBR 阶段）。系统容量由系统的 &lt;code&gt;maxQps * minRt&lt;/code&gt; 估算得出。设定参考值一般是 &lt;code&gt;CPU cores * 2.5&lt;/code&gt;。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;CPU usage：&lt;/strong&gt;（1.5.0+ 版本）当系统 CPU 使用率超过阈值即触发系统保护（取值范围 0.0-1.0），比较灵敏。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;平均 RT：&lt;/strong&gt; 当单台机器上所有入口流量的平均 RT 达到阈值即触发系统保护，单位是毫秒。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;并发线程数：&lt;/strong&gt; 当单台机器上所有入口流量的并发线程数达到阈值即触发系统保护。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;入口 QPS：&lt;/strong&gt; 当单台机器上所有入口流量的 QPS 达到阈值即触发系统保护。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;以上几种模式在 &lt;code&gt;sentinel-dashboard&lt;/code&gt; 控制台对应的配置如下图：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.37925925925925924&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/knmrNHnmCLGVzxh38ed9LXOgwib5TiaDgXMAd0SIxk6GjWSlkTMKRhb1FAgx5mlic3LicYzgsfwWiaLtA230v4LNjEg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;675&quot;/&gt;&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;注意：系统保护规则是应用整体维度的，而不是资源维度的，并且仅对入口流量生效。入口流量指的是进入应用的流量，比如 Web 服务或 Dubbo 服务端接收的请求，都属于入口流量。&lt;/p&gt;&lt;/blockquote&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;5.2、系统保护规则的硬编码方式：&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;除了在 &lt;code&gt;sentinel&lt;/code&gt; 控制台配置系统保护规则，我们也可以通过调用 &lt;code&gt;SystemRuleManager.loadRules()&lt;/code&gt; 方法来用硬编码的方式定义流量控制规则。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;initSystemRule&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    List&amp;lt;SystemRule&amp;gt; rules = &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;&amp;gt;();&lt;br/&gt;    SystemRule rule = &lt;span&gt;new&lt;/span&gt; SystemRule();&lt;br/&gt;    rule.setHighestSystemLoad(&lt;span&gt;10&lt;/span&gt;);&lt;br/&gt;    rules.add(rule);&lt;br/&gt;    SystemRuleManager.loadRules(rules);&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;官方示例链接：&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;https://github.com/alibaba/Sentinel/wiki/如何使用#系统保护规则-systemrule&lt;/p&gt;&lt;/blockquote&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;6、来源访问控制规则：&lt;/span&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;来源访问控制，就是根据调用来源判断该次请求是否允许放行，也就是黑白名单控制。若配置白名单则只有请求来源位于白名单内时才可通过；若配置黑名单则请求来源位于黑名单时不通过，其余的请求通过。&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;6.1、来源访问控制的核心配置：&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;来源访问控制规则（&lt;code&gt;AuthorityRule&lt;/code&gt;）非常简单，主要有以下配置项：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;resource：&lt;/strong&gt; 资源名，即限流规则的作用对象。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;limitApp：&lt;/strong&gt; 对应的黑名单/白名单，不同来源用 “,” 分隔，如 “&lt;code&gt;appA&lt;/code&gt;,&lt;code&gt;appB&lt;/code&gt;”。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;strategy：&lt;/strong&gt; 限制模式，&lt;code&gt;AUTHORITY_WHITE&lt;/code&gt; 为白名单模式，&lt;code&gt;AUTHORITY_BLACK&lt;/code&gt; 为黑名单模式，默认为白名单模式。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;6.2、来源访问规则的硬编码方式：&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;比如我们希望控制对资源 test 的访问设置白名单，只有来源为 appA 和 appB 的请求才可通过，则可以配置如下白名单规则：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;官方示例链接：&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;https://github.com/alibaba/Sentinel/wiki/如何使用#访问控制规则-authorityrule&lt;/p&gt;&lt;/blockquote&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;6.3、来源访问规则的控制台配置方式：&lt;/h5&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.30881585811163276&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/knmrNHnmCLGVzxh38ed9LXOgwib5TiaDgXicXU5BribWThBr2Zt2XgNmNSBcWqKjX9A4V5hWYRx5ohTc45wGib4lfnQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1917&quot;/&gt;&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;7、集群流控：&lt;/span&gt;&lt;/h4&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;7.1、为什么需要集群流控：&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;有了单机流控，还需要集群流控的原因如下：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;微服务要保证高可用，必须是集群，假设有100个集群，那么想要设置流控规则，就要每个微服务都设置一遍，这样的维护成本太高了&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;单体流控容易造成流量不均匀的问题，出现总流控阈值没有达到，但某些微服务却已经被限流了，这个是非常糟糕的问题，因此实际生产中对于集群不推荐单体流控。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以 &lt;code&gt;sentinel&lt;/code&gt; 提供了集群流控规则解决上述的问题，思想很简单，就是提供一个专门的 &lt;code&gt;server&lt;/code&gt; 来统计调用的总量，其他的实例都与 &lt;code&gt;server&lt;/code&gt; 保持通信。通过集群流控可以精确地控制整个集群的调用总量，结合单机限流兜底，可以更好地发挥流量控制的效果。集群流控中共有两种身份：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;Token Client：&lt;/strong&gt; 集群流控客户端，用于向所属 &lt;code&gt;Token Server&lt;/code&gt; 通信请求 token。集群限流服务端会返回给客户端结果，决定是否限流。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;Token Server：&lt;/strong&gt; 即集群流控服务端，处理来自 &lt;code&gt;Token Client&lt;/code&gt; 的请求，根据配置的集群规则判断是否应该发放 token（是否允许通过）。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;sentinel的集群限流有两种模式，分别如下：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;独立模式（Alone）：&lt;/strong&gt; 即作为独立的 &lt;code&gt;token server&lt;/code&gt; 进程启动，独立部署，隔离性好，但是需要额外的部署操作。独立模式适合作为 &lt;code&gt;Global Rate Limiter&lt;/code&gt; 给集群提供流控服务。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;嵌入模式（Embedded）：&lt;/strong&gt; 即作为内置的 &lt;code&gt;token server&lt;/code&gt; 与服务在同一进程中启动。在此模式下，集群中各个实例都是对等的，&lt;code&gt;token server&lt;/code&gt; 和 client 可以随时进行转变，因此无需单独部署，灵活性比较好。但是隔离性不佳，需要限制 &lt;code&gt;token server&lt;/code&gt; 的总 QPS，防止影响应用本身。嵌入模式适合某个应用集群内部的流控。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;7.2、集群流控的控制台配置方式：&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;下面就以嵌入模式为例介绍一下如何配置。就以 &lt;code&gt;sentinel-openfeign-provider&lt;/code&gt; 这个模块作为演示，直接启动三个集群，端口分别为 9009、9011、9013，如下图：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.30793650793650795&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/knmrNHnmCLGVzxh38ed9LXOgwib5TiaDgX6vpshVaYxBW1YfeFIdZ815JHcmZ2xbrQXkef4XtEXkia7SAIsaAUPicA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;630&quot;/&gt;此时只需要在控制台指定一个服务为&lt;code&gt;token server&lt;/code&gt;，其他的为&lt;code&gt;token client&lt;/code&gt;，集群流控-&amp;gt;新增&lt;code&gt;token server&lt;/code&gt;，操作如下图：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.40976514215080345&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/knmrNHnmCLGVzxh38ed9LXOgwib5TiaDgXHKUqGgsKZbqwiaGZJgvQ8cxZps0uqEqyTEvKmm5W5M93FYPCJfibUXXQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1618&quot;/&gt;选取一个作为服务端，另外两个作为客户端，此时就已经配置好了，如下图：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.3419593345656192&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/knmrNHnmCLGVzxh38ed9LXOgwib5TiaDgXrzTBeibQ8VyBdT8XOz7YDmCOX4YuqN3TVBWsKvYRlrlomiaxjcibs4EGg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1623&quot;/&gt;此时就可以添加集群流控规则了，可以在sentinel控制台直接添加，如下图：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.1926889714993804&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/knmrNHnmCLGVzxh38ed9LXOgwib5TiaDgXOJ07yJ2rAicHV87K8bgLqYMdVaLfZ7rtxKEVWXJH7ye4VK5icv6w9XUg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1614&quot;/&gt;至此集群流控到这儿就介绍完了&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;/&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;四、sentinel 整合 openFeign：&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上文介绍的都是在单个模块间的进行 &lt;code&gt;fallback&lt;/code&gt; 和 &lt;code&gt;blockhandler&lt;/code&gt; 测试，但在实际的 SpringCloud 微服务开发场景中肯定会遇到服务间远程服务调用的问题，而目前最主流的远程调用组件就是 &lt;code&gt;openFeign&lt;/code&gt; 了，那接下来我们看看 &lt;code&gt;sentinel&lt;/code&gt; 如何整合 &lt;code&gt;openFeign&lt;/code&gt; 进行熔断降级。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;1、引入 openFeign 的依赖：&lt;/span&gt;&lt;/h4&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;&amp;lt;&lt;span&gt;dependency&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&amp;lt;&lt;span&gt;groupId&lt;/span&gt;&amp;gt;&lt;/span&gt;org.springframework.cloud&lt;span&gt;&amp;lt;/&lt;span&gt;groupId&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&amp;lt;&lt;span&gt;artifactId&lt;/span&gt;&amp;gt;&lt;/span&gt;spring-cloud-starter-openfeign&lt;span&gt;&amp;lt;/&lt;span&gt;artifactId&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&amp;lt;/&lt;span&gt;dependency&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;2、配置文件中开启 &lt;/span&gt;&lt;code&gt;&lt;span&gt;openFeign&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 对 &lt;/span&gt;&lt;code&gt;&lt;span&gt;sentinel&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 熔断降级的支持：&lt;/span&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;feign.sentinel.enabled=&lt;span&gt;true&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;3、消费者主启动类添加注解 &lt;/span&gt;&lt;code&gt;&lt;span&gt;@EnableFeignClients&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 激活 &lt;/span&gt;&lt;code&gt;&lt;span&gt;openFeign&lt;/span&gt;&lt;/code&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;4、消费者声明接口，标识要调用提供方模块的哪个方法，并在 &lt;/span&gt;&lt;code&gt;&lt;span&gt;@FeignClient&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 注解中使用 &lt;/span&gt;&lt;code&gt;&lt;span&gt;fallback&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 属性指定熔断降级类：&lt;/span&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;@FeignClient&lt;/span&gt;(value = &lt;span&gt;&quot;payment-provider&quot;&lt;/span&gt;, fallback = PaymentServiceImpl&lt;span&gt;.&lt;span&gt;class&lt;/span&gt;)&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt; &lt;span&gt;PaymentService&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt; &lt;br/&gt;    &lt;span&gt;@GetMapping&lt;/span&gt;(&lt;span&gt;&quot;/payment/get/{id}&quot;&lt;/span&gt;)&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; CommonResult &lt;span&gt;paymentSql&lt;/span&gt;&lt;span&gt;(@PathVariable(&lt;span&gt;&quot;id&quot;&lt;/span&gt;)&lt;/span&gt;Long id)&lt;/span&gt;;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;5、添加降级类：实现第4步的定义的接口，并添加降级逻辑：&lt;/span&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;@Component&lt;/span&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;PaymentServiceFallback&lt;/span&gt; &lt;span&gt;implements&lt;/span&gt; &lt;span&gt;PaymentService&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt; &lt;br/&gt;    &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; CommonResult &lt;span&gt;paymentSql&lt;/span&gt;&lt;span&gt;(Long id)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; CommonResult(&lt;span&gt;414&lt;/span&gt;, &lt;span&gt;&quot;open-feign 整合 sentinel 实现的全局服务降级策略&quot;&lt;/span&gt;,&lt;span&gt;null&lt;/span&gt;);&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;PaymentServiceFallback&lt;/code&gt; 是 &lt;code&gt;PaymentService&lt;/code&gt; 的降级回调类，一旦&lt;code&gt;PaymentService&lt;/code&gt; 中对应得接口出现了异常，则会调用这个类中对应得方法进行降级处理。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;五、Sentinel 所存在的问题：&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;通过 &lt;code&gt;Sentinel-Dashboard&lt;/code&gt; 控制台配置的规则依然要推送到微服务应用中 &lt;code&gt;Sentinel&lt;/code&gt; 客户端本身才能生效，而微服务之间的调用链路等指标信息也需要推送给&lt;code&gt;Sentinel&lt;/code&gt;控制台，才能比较方便地使用&lt;code&gt;Sentinel&lt;/code&gt;提供的一些能力，因此在开源的架构版本中需要微服务应用本身开启独立端口与 &lt;code&gt;sentinel-dashboard&lt;/code&gt; 进行通信，从而获取配置规则以及上送微服务应用的各类指标信息。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;而这显然也会占用微服务额外的资源，并且由于 &lt;code&gt;sentinel-dashboard&lt;/code&gt; 在此条件下并不具备集群部署能力，因此也会形成一个单节点问题，但是有一套控制台总好过于没有，如果希望比较方便快速地应用 &lt;code&gt;Sentinel&lt;/code&gt; 这也是一种代价。此时的 &lt;code&gt;Sentinel&lt;/code&gt; 架构如下图所示：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6133464180569186&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/knmrNHnmCLGVzxh38ed9LXOgwib5TiaDgXMh3icUCMbuw8gYI3VmiaCYseAKlrujibLvjwThPl0MDYPIPBXEia1ugdDQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1019&quot;/&gt;在开源版本架构中，通过 &lt;code&gt;sentinel-dashboard&lt;/code&gt; 控制台配置的限流、熔断降级等规则都是存储于 &lt;code&gt;Sentinel-Dashboard&lt;/code&gt; 控制台服务的内存之中，如果控制台服务重启或者微服务应用重启都会导致规则丢失，而这在生产环境下显然是不能接受的，因此 &lt;code&gt;Sentinel&lt;/code&gt; 官方推荐在生产架构中使用第三方数据源作为永久存储中心，比如 nacos、apollo、zookeeper，这样各个微服务的限流、降级规则都可以永久存储。&lt;/p&gt;&lt;section class=&quot;mp_profile_iframe_wrp&quot;&gt;&lt;mp-common-profile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mpprofile&quot; data-id=&quot;MzkzMDI1NjcyOQ==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/EoJib2tNvVtf7icAmS0BQH6oDVG37Q8NzcfdguS5qAqOhfxvZyIKqmuX5BbnDjynrBbZzktp1EiaeFLzapp1nHysw/0?wx_fmt=png&quot; data-nickname=&quot;码哥字节&quot; data-alias=&quot;MageByte&quot; data-signature=&quot;拥抱硬核技术和对象，面向人民币编程。&quot; data-from=&quot;0&quot; data-is_biz_ban=&quot;0&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>