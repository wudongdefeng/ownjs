<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>c5e092ff14719d902cc4b7372b64c143</guid>
<title>优质网站同好者周刊（第 091 期） | 倾城博客</title>
<link>https://toutiao.io/k/6nb4sth</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;content&quot;&gt;&lt;p&gt;&lt;a href=&quot;https://nicelinks.site/?utm_source=weekly&quot;&gt;倾城之链&lt;/a&gt;作为一个开放平台，旨在云集全球&lt;strong&gt;优秀网站&lt;/strong&gt;，探索互联网中更广阔的世界。此周刊，将汇聚过去一周&lt;a href=&quot;https://nicelinks.site/?utm_source=weekly&quot;&gt;倾城&lt;/a&gt;所收录的内容，以飨同好；欢迎推荐或自荐（仅限有独立域名的网站，可以是二级域名）。您如果要了解收录要求，请参见&lt;a href=&quot;https://nicelinks.site/about?utm_source=weekly&quot;&gt;关于倾城&lt;/a&gt;。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;备注&lt;/strong&gt;：本周刊&lt;strong&gt;每周五&lt;/strong&gt;生成，首发于个人微信公众号&lt;a href=&quot;https://mp.weixin.qq.com/mp/appmsgalbum?__biz=MzI5MDIwMzM2Mg==&amp;amp;action=getalbum&amp;amp;album_id=1530765143352082433&amp;amp;scene=173&amp;amp;from_msgid=2650641087&amp;amp;from_itemidx=1&amp;amp;count=3#wechat_redirect&quot;&gt;晚晴幽草轩&lt;/a&gt;、博客&lt;a href=&quot;https://www.jeffjade.com&quot;&gt;晚晴幽草轩&lt;/a&gt;，以及&lt;a href=&quot;https://forum.lovejade.cn/&quot;&gt;悠然宜想亭&lt;/a&gt;社区；此一键生成脚本基于 &lt;a href=&quot;https://nicelinks.site/post/602d30aad099ff5688618591&quot;&gt;Deno&lt;/a&gt; 编写，并在 Github 开源：&lt;a href=&quot;https://github.com/nicejade/nicelinks-weekly&quot;&gt;nicejade/nicelinks-weekly&lt;/a&gt;。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;标签&lt;/strong&gt;：&lt;a href=&quot;https://nicelinks.site/tags/3D&quot;&gt;&lt;code&gt;3D&lt;/code&gt;&lt;/a&gt; · &lt;a href=&quot;https://nicelinks.site/tags/%E8%BD%AF%E4%BB%B6&quot;&gt;&lt;code&gt;软件&lt;/code&gt;&lt;/a&gt; · &lt;a href=&quot;https://nicelinks.site/tags/%E5%85%8D%E8%B4%B9&quot;&gt;&lt;code&gt;免费&lt;/code&gt;&lt;/a&gt;&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;The Freedom to Create&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;img src=&quot;https://oss.nicelinks.site/www.blender.org.png?x-oss-process=style/png2jpg&quot; alt=&quot;倾城之链 - blender.org - Home of the Blender project - Free and Open 3D Creation Software&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;推荐语&lt;/strong&gt;：&lt;a href=&quot;https://nicelinks.site/redirect?url=https://www.blender.org/&quot;&gt;Blender&lt;/a&gt; 是一款&lt;strong&gt;免费开源&lt;/strong&gt;三维图形图像软件，提供从建模、动画、材质、渲染、到音频处理、&lt;strong&gt;视频剪辑&lt;/strong&gt;，甚至游戏创建等一系列动画短片制作解决方案（最早可追溯至 1988 年）。高级用户使用 Blender 的 Python 脚本 API 来定制应用程序并编写专门的工具；通常这些都包含在 Blender 的未来版本中。Blender 非常适合受益于其统一管道和响应式开发过程的个人和小型工作室。&lt;/p&gt;&lt;p&gt;Blender 以 GNU GPL 许可，由其贡献者拥有。 出于这个原因，Blender 永远是免费的开源软件。其&lt;strong&gt;使命&lt;/strong&gt;是：将世界上最好的 3D CG 技术作为免费/开源软件，交到艺术家手中。Blender 想象每个人都应该可以自由创作 3D CG 内容，拥有自由的技术和创意制作手段，自由进入市场。&lt;/p&gt;&lt;p&gt;Blender 跨平台支持良好，它的界面使用 OpenGL 来提供一致的体验（而且可以通过 Python 脚本自定义），可以工作在所有主流的 Windows（10、8、7、Vista）、Linux、OS X 等众多其它操作系统上。为了确认具体的兼容性， &lt;a href=&quot;https://www.blender.org/download/requirements/&quot;&gt;支持的平台&lt;/a&gt; 列表   显示了开发团队定期测试的平台。&lt;/p&gt;&lt;p&gt;Blender 拥有方便在不同工作下使用的多种用户界面，内置绿屏抠像、摄像机反向跟踪、遮罩处理、后期结点合成等高级影视解决方案。Blender 内置有 Cycles 渲染器与实时渲染引擎 EEVEE。同时还支持多种第三方渲染器。&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://nicelinks.site/redirect?url=https://www.blender.org/&quot;&gt;Blender&lt;/a&gt; 为全世界的媒体工作者和艺术家而设计，可以被用来进行三维可视化，同时也可以创作广播和&lt;strong&gt;电影级品质的视频&lt;/strong&gt;，另外内置的实时三维游戏引擎，让制作独立回放的三维互动内容成为可能。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;谁在使用 Blender&lt;/strong&gt;？ Blender 有一套非常丰富的工具集，因此几乎可以适用于所有类型的媒体产品。全世界的工作室与开发者们都把它用在各种各样的项目中，包括业余作品、商业化的产品、电影、游戏以及其他互动应用比如多功能信息栏，游戏以及科学研究。&lt;/p&gt;&lt;p&gt;作为 GNU 通用公共许可证 (GPL)下的社区驱动项目，公众有权对代码库进行大大小小的更改，从而带来新功能、响应式错误修复和更好的可用性。Blender 没有价格标签，但您可以 投资、 参与和帮助推进强大的协作工具：&lt;strong&gt;Blender 是您自己的 3D 软件&lt;/strong&gt;。&lt;/p&gt;&lt;p&gt;── 出自&lt;a href=&quot;https://nicelinks.site/post/636cee71ee7f3505edab554d&quot;&gt;倾城之链 - blender.org - Home of the Blender project - Free and Open 3D Creation Software&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;标签&lt;/strong&gt;：&lt;a href=&quot;https://nicelinks.site/tags/AI&quot;&gt;&lt;code&gt;AI&lt;/code&gt;&lt;/a&gt; · &lt;a href=&quot;https://nicelinks.site/tags/%E5%9B%BE%E7%89%87&quot;&gt;&lt;code&gt;图片&lt;/code&gt;&lt;/a&gt; · &lt;a href=&quot;https://nicelinks.site/tags/%E8%BD%AC%E5%8C%96&quot;&gt;&lt;code&gt;转化&lt;/code&gt;&lt;/a&gt;&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;PicSo is an AI-powered digital art generator that creates artistically styled images from input text. Enter any text prompt to create pictures in your chosen art style and turn your ideas/text into an AI-generated painting in seconds. Website and APP available.&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;img src=&quot;https://oss.nicelinks.site/picso.ai.png?x-oss-process=style/png2jpg&quot; alt=&quot;倾城之链 - PicSo-Text To AI Art Maker&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;推荐语&lt;/strong&gt;：&lt;a href=&quot;https://nicelinks.site/redirect?url=https://picso.ai/&quot;&gt;PicSo&lt;/a&gt; 是一个人工智能（&lt;a href=&quot;https://nicelinks.site/tags/AI&quot;&gt;AI&lt;/a&gt;）驱动的数字艺术生成器，可以从输入文本中创建具有艺术风格的图像。输入任何文本提示，以您选择的艺术风格创建图片，并在几秒钟内将您的想法/文本变成 AI 生成的绘画。网站和 APP 可用。&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://nicelinks.site/redirect?url=https://picso.ai/discover&quot;&gt;PicSo Discover&lt;/a&gt; 展示了非常多生成的图片，看起来很棒；但真实体验，发现 PicSo 还不够智能；比如以：“Newton and Tesla standing in outer space（牛顿和特斯拉站在外太空）”这句文本去体验，它所生成的图片，虽然是勉强展现出文本的意思，但效果简直“不忍直视”；必须提供足够全的描述，才能得到想要的结果，比如像这样：&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;beautiful green landscape with a blue sky in the style of Genshin Impact, ghibli studio, 4k, ultra detail, attractive look, animation, hand drawn anime, concept art, wide angle, cinematic High Fidelity.&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;官方介绍道：“&lt;a href=&quot;https://nicelinks.site/redirect?url=https://picso.ai/&quot;&gt;PicSo&lt;/a&gt; 以毕加索命名，表达了通过这款产品，每个人都可以成为像毕加索一样伟大的艺术家，进行富有创造性和意义的艺术创作。有了这个工具，任何人都可以在几秒钟内创造出独一无二的数字艺术作品，无论他们的预算或项目如何。装饰您的房子，创建 NFT 或动漫角色，或设计您自己的杰作！只需文字提示，PicSo 即可在数秒内生成 AI 数字艺术”。截止 2022 年，类似产品已经有很多，相信未来会日趋向好；感兴趣的朋友不妨体验下（注册即可，有体验次数限制，超过需要付费购买）。&lt;/p&gt;&lt;p&gt;── 出自&lt;a href=&quot;https://nicelinks.site/post/636bc30db8db8e6db6203869&quot;&gt;倾城之链 - PicSo-Text To AI Art Maker&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;标签&lt;/strong&gt;：&lt;a href=&quot;https://nicelinks.site/tags/AI&quot;&gt;&lt;code&gt;AI&lt;/code&gt;&lt;/a&gt; · &lt;a href=&quot;https://nicelinks.site/tags/%E5%9B%BE%E7%89%87%E7%BC%96%E8%BE%91%E5%99%A8&quot;&gt;&lt;code&gt;图片编辑器&lt;/code&gt;&lt;/a&gt; · &lt;a href=&quot;https://nicelinks.site/tags/%E5%9B%BE%E7%89%87&quot;&gt;&lt;code&gt;图片&lt;/code&gt;&lt;/a&gt;&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;Generate or update existing images with our AI image editing tool.&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;img src=&quot;https://oss.nicelinks.site/sceneryai.com.png?x-oss-process=style/png2jpg&quot; alt=&quot;倾城之链 - SceneryAI - AI-powered image editing&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;推荐语&lt;/strong&gt;：&lt;a href=&quot;https://nicelinks.site/redirect?url=https://sceneryai.com/&quot;&gt;SceneryAI&lt;/a&gt; ，人工智能驱动（&lt;a href=&quot;https://nicelinks.site/tags/AI&quot;&gt;AI&lt;/a&gt;）的图像编辑，可以快速生成或更新图像；使用 SceneryAI，您可以在 30 秒内更改照片的&lt;strong&gt;主题&lt;/strong&gt;或&lt;strong&gt;风景&lt;/strong&gt;。只需上传您的照片并删除您要更新的部分。SceneryAI 是内容营销人员、创作者和数字艺术家在几秒钟内更新他们的照片和创作的完美解决方案。&lt;/p&gt;&lt;p&gt;SceneryAI 使用非常便捷，只需要以下三步：&lt;/p&gt;&lt;ol&gt;&lt;li&gt;使用 SceneryAI 的 AI 功能，上传您想要编辑的照片；&lt;/li&gt;&lt;li&gt;使用 AI 的力量擦除您想要更新的照片部分；&lt;/li&gt;&lt;li&gt;描述您希望如何更新照片和渲染照片；&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;如果你是一个想跳过 Photoshop 的艺术家、一个需要快速编辑的营销人员、一个想狂欢的摄影师，或者一个想创造超棒食物照片的厨师？可以尝试 SceneryAI ，它免费可用；付费模式支持以最高质量渲染无限图像（19 美元/每月）。&lt;/p&gt;&lt;p&gt;── 出自&lt;a href=&quot;https://nicelinks.site/post/636a443b68917b7b541fba8f&quot;&gt;倾城之链 - SceneryAI - AI-powered image editing&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;标签&lt;/strong&gt;：&lt;a href=&quot;https://nicelinks.site/tags/%E8%B5%84%E8%AE%AF&quot;&gt;&lt;code&gt;资讯&lt;/code&gt;&lt;/a&gt; · &lt;a href=&quot;https://nicelinks.site/tags/%E6%8A%95%E8%B5%84&quot;&gt;&lt;code&gt;投资&lt;/code&gt;&lt;/a&gt; · &lt;a href=&quot;https://nicelinks.site/tags/%E5%8F%AF%E8%A7%86%E5%8C%96&quot;&gt;&lt;code&gt;可视化&lt;/code&gt;&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;关键字&lt;/strong&gt;：大盘云图, 盯盘云图, 大盘全景图, 股市云图, 大盘板块图, 打盘云图, 大盘云图官网, 在线看盘, 大盘云图.com&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;大盘云图颠覆了以往看盘软件一成不变的红涨绿跌，它将所有股票按所属行业进行了板块划分，并以方块形式展示，用红色和绿色的深浅代表涨跌幅度，实现直观的展现大盘的全景图，适合股票爱好者和专业投资人使用盯盘使用，还可从不同的周期、资金流向、涨跌幅及量比等维度实时查看大盘最新数据&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;img src=&quot;https://oss.nicelinks.site/dapanyuntu.com.png?x-oss-process=style/png2jpg&quot; alt=&quot;倾城之链 - 大盘云图 -大盘走势，尽在掌握!【官网】&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;推荐语&lt;/strong&gt;：&lt;a href=&quot;https://nicelinks.site/redirect?url=https://dapanyuntu.com&quot;&gt;大盘云图&lt;/a&gt; ，是一款智能股票盯盘工具网站（基于 React 等框架搭建），颠覆了以往看盘软件一成不变的红涨绿跌，它将所有股票按所属行业进行了板块划分，并以方块形式展示，用红色和绿色的深浅代表涨跌幅度，用颜色的深浅标注个股的异动情况，实现直观的展现，能够使投资者更清晰的感知市场的脉搏，更加贴近市场动向。&lt;/p&gt;&lt;p&gt;它主要是针对中国 A 股市场，为投资者打造的 &lt;a href=&quot;https://nicelinks.site/tags/%E5%8F%AF&quot;&gt;可视化&lt;/a&gt; 实时行情功能，是目前市场上先进、直观的图形化看盘工具。适合股票爱好者和专业投资人使用盯盘使用，还可从不同的周期、资金流向、涨跌幅及量比等维度实时查看大盘最新数据。温馨提醒：&lt;strong&gt;股市有风险，投资须谨慎&lt;/strong&gt;。&lt;/p&gt;&lt;p&gt;── 出自&lt;a href=&quot;https://nicelinks.site/post/63668c2ae4cec4128ba691ed&quot;&gt;倾城之链 - 大盘云图 -大盘走势，尽在掌握!【官网】&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;标签&lt;/strong&gt;：&lt;a href=&quot;https://nicelinks.site/tags/%E9%98%85%E8%AF%BB&quot;&gt;&lt;code&gt;阅读&lt;/code&gt;&lt;/a&gt; · &lt;a href=&quot;https://nicelinks.site/tags/RSS&quot;&gt;&lt;code&gt;RSS&lt;/code&gt;&lt;/a&gt; · &lt;a href=&quot;https://nicelinks.site/tags/PWA&quot;&gt;&lt;code&gt;PWA&lt;/code&gt;&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;关键字&lt;/strong&gt;：PWA, 阅读器, 在线, Qi Reader, RSS, 全平台, 阅读, 订阅&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;Qi Reader - The Modern RSS Feed Reader Web App .&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;img src=&quot;https://oss.nicelinks.site/www.qireader.com.png?x-oss-process=style/png2jpg&quot; alt=&quot;倾城之链 - QiReader - 基于 PWA 技术的全平台 RSS 在线阅读器&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;推荐语&lt;/strong&gt;：&lt;a href=&quot;https://nicelinks.site/redirect?url=https://www.qireader.com/&quot;&gt;QiReader&lt;/a&gt;，优雅的全平台在线 RSS 阅读器，基于 PWA 解决方案搭建；它具有以下功能：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;strong&gt;全平台&lt;/strong&gt;：可安装到主屏幕的网页 App，支持所有桌面和移动设备；&lt;/li&gt;&lt;li&gt;&lt;strong&gt;稍后阅读&lt;/strong&gt;：一键收藏文章；&lt;/li&gt;&lt;li&gt;&lt;strong&gt;文章标签&lt;/strong&gt;：标签用于分类别收藏文章；&lt;/li&gt;&lt;li&gt;&lt;strong&gt;全文&lt;/strong&gt;：为只输出摘要内容的订阅源自动加载全文内容；&lt;/li&gt;&lt;li&gt;&lt;strong&gt;支持键盘快捷键&lt;/strong&gt;：比用鼠标更快；&lt;/li&gt;&lt;li&gt;&lt;strong&gt;OPML 导入和导出&lt;/strong&gt;：从其它阅读器中导入订阅；&lt;/li&gt;&lt;li&gt;&lt;strong&gt;内置英汉词典&lt;/strong&gt;：划词翻译，英语学习利器；&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;QiReader 基础版本免费可用，支持  50 订阅源；Pro 版本支持 300 订阅源，一年收费人民币 49 元。有注册、登录使用，整个体验超出预期，简洁实用，尤其是英汉词典，对于订阅英文网站，挺有帮助。酷爱 RSS 阅读的朋友，推荐使用。&lt;/p&gt;&lt;p&gt;── 出自&lt;a href=&quot;https://nicelinks.site/post/63665214e4cec4128ba68f15&quot;&gt;倾城之链 - QiReader - 基于 PWA 技术的全平台 RSS 在线阅读器&lt;/a&gt;&lt;/p&gt;&lt;p&gt;对倾城之链感兴趣的朋友，可通过 Web，小程序，快应用等渠道进行访问(后续将支持更多，如 VsCode 插件，Chrome 扩展等)。您有任何问题，欢迎随时向我们反馈（您可以通过官网反馈渠道，或添加如下客服微信），🤲 。&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;https://image.nicelinks.site/%E5%80%BE%E5%9F%8E%E4%B9%8B%E9%93%BE-%E5%BE%AE%E4%BF%A1-mini.jpeg&quot; alt=&quot;倾城之链 - 客服微信&quot;/&gt;&lt;/p&gt;&lt;h2 id=&quot;本期文末寄语&quot;&gt;&lt;a href=&quot;#%E6%9C%AC%E6%9C%9F%E6%96%87%E6%9C%AB%E5%AF%84%E8%AF%AD&quot; aria-label=&quot;本期文末寄语 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; version=&quot;1.1&quot; viewbox=&quot;0 0 16 16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;/&gt;&lt;/svg&gt;&lt;/a&gt;本期文末寄语&lt;/h2&gt;&lt;p&gt;随着年龄的增长，普通人学习能力会退化。当人超过一定岁数时他们开始意识到，自己接收信息的能力不如往昔。他们会对自己不熟悉的观点警惕，也不容易为此而去改变，且常常为之寻找理由。&lt;strong&gt;大多数人到了这种阶段，会试图逃避这一现实，甚至妄想改变别人的观点来肯定自己的观点。尽量不要成为他们&lt;/strong&gt;。── 网络 · 佚名&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;&lt;a href=&quot;https://nicelinks.site/?utm_source=weekly&quot;&gt;倾城之链&lt;/a&gt;作为一个开放平台，旨在云集全球&lt;strong&gt;优秀网站&lt;/strong&gt;，探索互联网中更广阔的世界；在这里，你可以轻松发现、学习、分享更多有用或有趣的事物。&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;img src=&quot;https://image.nicelinks.site/nicelinks-miniprogram-code.jpeg?imageView2/1/w/250/h/250/interlace/1/ignore-error/1&quot; alt=&quot;小程序码 - 倾城之链&quot;/&gt;&lt;/p&gt;&lt;h2 id=&quot;您可能感兴趣的文章&quot;&gt;&lt;a href=&quot;#%E6%82%A8%E5%8F%AF%E8%83%BD%E6%84%9F%E5%85%B4%E8%B6%A3%E7%9A%84%E6%96%87%E7%AB%A0&quot; aria-label=&quot;您可能感兴趣的文章 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; version=&quot;1.1&quot; viewbox=&quot;0 0 16 16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;/&gt;&lt;/svg&gt;&lt;/a&gt;您可能感兴趣的文章&lt;/h2&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>9a3462f5bf910745b569e1ae914f3525</guid>
<title>深度学习在携程搜索词义解析中的应用</title>
<link>https://toutiao.io/k/nce8xtm</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;作者简介&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;携程旅游研发部大数据与AI研发团队，为旅游事业部提供丰富的AI技术产品和技术能力。&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;一、背景介绍&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;搜索是电商最重要的门面之一，大部分用户通过搜索来找到他们想要的商品，因此搜索是用户表达意图最直接的方式，也是转化率最高的流量来源之一。绝大部分的电商搜索是通过搜索框输入搜索词（Query）来完成，因此，搜索词的词义解析和意图理解成为了搜索中的重要一环。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;主流的搜索词义解析和Query理解需要经过纠错、同义词替换、分词、词性标注、实体识别、意图识别、词重要度权重、丢词等步骤。以旅游场景下的搜索举例，如图1所示，当用户在搜索框输入“云南香各里拉”作为Query的时候，首先搜索引擎需要对该搜索词进行纠错，这是为了便于后续步骤正确解析出用户想要搜索的内容；如果有必要，还会进行同义词替换。然后，对搜索词进行分词和词性标注，识别出“云南”是省，“香格里拉”是城市或者酒店品牌，紧接着会做实体识别，召回“云南”和“香格里拉”在后台数据库里对应的实体id。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;这个时候，出现了一个分歧，“香格里拉”既可能是城市，又可能是酒店品牌。在用户进行搜索的时候，是否能够预测出正确的类别和实体，对于搜索结果的精准展示和提升用户体验有重要的意义。因此，我们必须识别出用户真正想要搜的是什么类别，并找到对应的实体，否则可能在搜索列表页前排会给出用户不想要的结果。从人的先验知识来看，用户搜索“云南香格里拉”，很大可能性是想要搜城市。意图识别步骤，就是为了实现这个功能，识别出用户真正的搜索意图是代表城市的“香格里拉”。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;后续就可以进入搜索的召回步骤，召回主要负责的是把和搜索词意图相关的商品或内容找出来。前面的步骤获取了“云南”和“香格里拉”的id，就可以很方便的召回和“云南”和“香格里拉”都相关的商品或内容。但是，有些时候，召回的结果为空或者过于稀少，这个时候给用户的体验不好，因此，在召回的结果为空或者过于稀少的情况下，往往还需要丢词和二次召回的操作。此外，有些词属于可省略词，或者对搜索产生干扰的词，也可以通过丢词来处理。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;所谓丢词，就是把搜索词中相对不重要或者联系不紧密的词丢掉，再次召回。那么该如何衡量每个词的重要程度或者紧密程度？这里就需要引入了Term Weighting的模块，把每个词视为term，通过算法或规则计算每个term的weight，每个term的weight直接决定了term重要度和紧密度的顺序。例如，假设“云南”的term weight是0.2，“香格里拉”的term weight是0.8，那么如果需要丢词，就应该先丢“云南”，保留“香格里拉”。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.993103448275862&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/kEeDgfCVf1eqznWPRyN5VaUjgkUVt1cgCa7EicMMyFJm3icRibiaaJLo72UjoTYic3fJRU19lwevwocBatIQ8BwPnDg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;725&quot;/&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;图1 搜索词义解析和Query理解步骤&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;传统的搜索意图识别会采用词表匹配，类目概率统计，加上人为设定规则。传统的Term Weighting同样会采用词表匹配和统计方法，比如根据全量商品的标题和内容统计出词的TF-IDF、前后词互信息、左右邻熵等数据，直接存成词典和分值，提供给线上使用，再根据一些规则辅助判断，比如行业专有名词直接给出较高的term weight，助词直接给出较低的term weight。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;但是，传统的搜索意图识别和Term Weighting算法无法达到很高的准确率和召回率，特别是无法处理一些较为罕见的搜索词，因此需要一些新的技术来提升这两个模块的准确率和召回率，以及提升对罕见搜索词的适应能力。此外，因为访问频率较高，搜索词义解析需要非常快的响应速度，在旅游搜索场景下，响应速度往往需要达到接近个位数的毫秒级，这对于算法来说是一个很大的挑战。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;二、 问题分析&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;为了提高准确率和召回率，我们采用深度学习来改进搜索意图识别和Term Weighting算法。深度学习通过样本的学习，可以有效解决各种情况下的意图识别和Term Weighting。此外，针对自然语言处理的大规模预训练语言模型的引入，可以进一步强化深度学习模型的能力，减少样本的标注量，使得原本标注成本较高的深度学习在搜索上应用成为可能。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;但是深度学习面临的问题是，由于模型的复杂度较高，神经网络层数较深，响应速度没法满足搜索的高要求。因此我们采用模型蒸馏和模型压缩来减少模型的复杂度，在略微降低准确率和召回率的情况下减少深度学习模型的耗时，以此保证较快的响应速度和较高的性能。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;三、意图识别&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;类目识别是意图识别的主要组成部分。意图识别中的类目识别是搜索词query经过分词后，对分词结果打上所属类目并给出对应概率值的方法。解析用户的搜索词的意图有利于分析用户的直接搜索需求，从而辅助提升用户体验。例如用户在旅游页面搜索 “云南香格里拉”，获取到用户输入的“香格里拉”对应的类目是“城市”，而不是“酒店品牌”，引导后续检索策略偏向城市意图。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;在旅游场景下，用户输入的类目存在歧义的搜索词占总量约11%，其中包含大量无分词的搜索词。“无分词”是指经过分词处理后无更细化的切分片段，“类目存在歧义”是指搜索词本身存在多种可能的类目。例如用户输入“香格里拉”，无更细化的切分片段，且对应类目数据中存在“城市”、“酒店品牌”等多个类目。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;如果搜索词本身是多个词的组合，则可以通过搜索词自身上下文明确类目，优先会以搜索词本身作为识别目标。如果单从搜索词本身不能明确所属类目，我们会优先追加该用户不相同的最近历史搜索词，以及最近商品类目点击记录，若无上述信息则追加定位站，作为补充语料。原始搜索词经过处理获得待识别的Query R。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;最近几年，预训练语言模型在很多自然语言处理任务中大放光彩。在类目识别中，我们利用预训练模型的训练网络参数，获取含上下文语义的字特征Output&lt;sub&gt;bert&lt;/sub&gt;；使用字词转换模块，字特征结合位置编码:&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.12532981530343007&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/kEeDgfCVf1eqznWPRyN5VaUjgkUVt1cg5qia727Y8TwicDMbictRic5JReWsBJxPnCMrnrpicNcsOoBDiaa1rcPZ2ESA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;758&quot;/&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;获取到分词对应的字符片段，如：&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.21978021978021978&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/kEeDgfCVf1eqznWPRyN5VaUjgkUVt1cgksbQepvQImhaOhiaAe2PvmfxaS7EJziaiclMdtpqXoZ68DpiaYMytscx0w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;455&quot;/&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;代表第i个分词对应的长度为l&lt;sub&gt;i&lt;/sub&gt;的字特征。基于字符片段W&lt;sub&gt;i&lt;/sub&gt;，字词转换模块聚合出每个词的特征H&lt;sub&gt;w&lt;/sub&gt;&lt;sub&gt;i&lt;/sub&gt;。聚合手段可以是最大值池化max-pooling、最小值池化min-pooling、均值池化mean-pooling等方式，实验得到最大池化效果最佳。模块输出为搜索词R的词特征Output&lt;sub&gt;R&lt;/sub&gt;；通过并行分类器对搜索词的词特征Output&lt;sub&gt;R&lt;/sub&gt;中各个片段给出类目数据库中涵盖的匹配类目，并给出对应类目的匹配概率。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.425&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/kEeDgfCVf1fHyuE9I3tD8MZnd2XmobCaicHOXGoYnHlrSkaJCONtArDAlialgAEI6KEJxRXRuwmoFuvgJjIL4khw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;span&gt;图2 类目识别整体结构示意图&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;类目识别模型是基于BERT-base 12层模型，由于模型过大，不满足线上运行的响应速度要求，我们对模型进行了知识蒸馏（Knowledge Distillation），将网络从大网络转化成一个小网络，保留接近于大网络的性能的同时满足线上运行的延迟要求。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;原先训练好的类目识别模型作为teacher网络，将teacher网络的输出结果 作为student网络的目标，训练student网络，使得student网络的结果p接近q ，因此，我们可以将损失函数写成:&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.12191103789126853&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/kEeDgfCVf1eqznWPRyN5VaUjgkUVt1cghI6d4QvBibGhVUEggD9edteNNtvbZujqwXbibiah9ia7P5g8v8vsOucVYA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;607&quot;/&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;这里CE是交叉熵（Cross Entropy）,symmetricalKL是对称KL散度（Kullback–Leibler divergence），y是真实标签的one-hot编码，q是teacher网络的输出结果，p是student网络的输出结果。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5064815&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/kEeDgfCVf1fHyuE9I3tD8MZnd2XmobCao8Z8cAVNN6iap0SCsLSMLaeyH7olI7J0tNX3eLiaU55cnBiaX0DfU9RuQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;span&gt;图3 知识蒸馏示意图&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;经过知识蒸馏，类目识别最终仍然可以达到较高的准确率和召回率，同时可以做到整体响应时间的95线为5ms左右。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;经过类目识别之后，还需要经过实体链接等步骤，完成最终的意图识别过程。具体内容可以参见&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MjM5MDI3MjA5MQ==&amp;amp;mid=2697272959&amp;amp;idx=2&amp;amp;sn=64a3495442aef01658ed54554b2539a2&amp;amp;chksm=8376e14bb401685d5c570e40aca22fb69a382151dc1442037fdae898bd59bcbe4108a47c489a&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;《携程实体链接技术的探索及实践》&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;《携程实体链接技术的探索及实践》&lt;/a&gt;一文，本文不再阐述。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;四、 Term Weighting&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;对于用户输入的搜索词，不同的term对于用户的核心语义诉求有着不同的重要性。在搜索的二次召回排序中需要重点关注重要性高的term，同时在丢词的时候可以忽略重要性低的term。通过计算用户输入搜索词的各个term weight，来二次召回出最接近用户意图的产品，提升用户体验。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;首先，我们需要寻找线上用户真实的反馈数据作为标注数据。用户在搜索框的输入和联想词点击情况一定程度上反映了用户对于搜索短语中词语的重视程度，因此我们选用联想词输入和点击数据，加以人工筛选和二次标注，作为Term Weighting模型的标注数据。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;在数据预处理方面，我们所能获得的标注数据为短语及其对应的关键词，这里为了使权重的分配不过于极端，给定非关键词一定量小的权重，并将剩余权重分配给关键词的每个字上，如果某一短语在数据中出现了复数次，且对应的关键词不同，则会根据关键词的频率对这些关键词的权重进行分配，并进一步分配每个字的权重。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;模型部分主要尝试BERT作为特征提取的方法，并进一步对每个term的权重进行拟合。对于给定的输入，将其转化为BERT所能接收的形式，将通过BERT后的张量再通过全连接层进行压缩，得到一维的向量后进行Softmax处理，并用该向量对结果的权重向量进行拟合，具体模型框架如下图所示：&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1.0315236&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/kEeDgfCVf1fHyuE9I3tD8MZnd2XmobCaibEeCBXPE59XzN233wqbeEGhIic1Jebbg5l9cH1jCDOH2ziak9EfyXyKg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;571&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;span&gt;图4 Term Weighting模型框架&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;由于中文BERT基于字符，因此需要将每个term中的所有字的权重进行求和，从而最终得到term的权重。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;在整个模型框架中，除去一些训练的超参数，能调整的部分主要包含两个部分：一是通过BERT产生Embedding时，可以选择BERT最后一层，或者综合BERT的第一层和最后一层的方式产生Embedding；二是在损失函数的选择上，除去使用MSE损失衡量预测权重与实际权重之间差距之外，也尝试使用非重要词的预测权重的和作为损失进行计算，但这种损失更适合只有单个关键词的情况使用。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;模型最终是以小数的形式输出每个term weight，例如[“上海”、“的”、“迪士尼”]的term weight结果为[0.3433，0.1218，0.5349]。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;该模型是为搜索服务的，有严格的响应速度要求。由于BERT模型整体比较大，在推理部分很难达到响应速度要求，因此类似于类目识别模型，我们对训练好的BERT模型进行进一步的蒸馏处理，以达到符合线上的要求。在此项目中，通过少数几层transformer去拟合BERT-base 12层transformer的效果，最后以损失可以接受的一部分性能的情况下，使得模型整体的推理速度快了10倍左右。最终，Term Weighting线上服务整体的95线可以达到2ms左右。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;五、 未来与展望&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;采用深度学习后，旅游搜索对于较为罕见的长尾搜索词，词义解析能力有了较大的提升。在目前的线上真实搜索场景，深度学习方法一般选择与传统的搜索词义解析方法相结合，这样既可以保证头部常见搜索词的性能稳定，又可以加强泛化能力。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;未来，搜索词义解析致力于给用户带来更好的搜索体验，随着硬件技术和AI技术的更新换代，高性能计算和智能计算越来越成熟，搜索词义解析的意图识别和Term Weighting未来会往更高性能的目标发展。此外，更大规模的预训练模型和旅游领域的预训练模型有助于进一步提升模型的准确率和召回率，更多用户信息和知识的引入有助于提升意图识别的效果，线上用户的反馈和模型迭代有助于提升Term Weighting的效果。这些都是我们后续会尝试的方向。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;除了意图识别和Term Weighting之外，搜索的其他功能，比如词性标注、纠错等，在满足响应速度要求的前提下未来也可以采用深度学习技术，来实现更强大的功能和更优秀的效果。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;【推荐阅读】&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/kEeDgfCVf1fHyuE9I3tD8MZnd2XmobCaRbP57RFIiaW7icFAnE0wWH4tZp7yicp28UXn4vdeLkcoGuwKblvyGhGlg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1080&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt; “携程技术”公众号&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;  分享，交流，成长&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>ad405af62eda43dc7b048b9028825b84</guid>
<title>Go 语言项目源码解析：定时任务库 cron</title>
<link>https://toutiao.io/k/0ilu8ik</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;引子&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;GitHub 上有很多优秀的开源项目，代码都是透明可见的，每个人只要有账号就可以下载来查看。而我们作为软件开发者来说也可以从中学习到很多知识，以及体会如何正确的工程化、单元测试、统一代码风格等，甚至从源码中找到问题，并提出 Pull Request 来贡献开源社区。今天这篇文章将解析 Go 语言开源项目 &lt;span&gt;robfig/cron&lt;/span&gt;&lt;sup&gt;[1]&lt;/sup&gt; 的&lt;strong&gt;「源码」&lt;/strong&gt;，这个项目不大，知名度较高，注释也比较清楚，很适合新手学习如何阅读和解析源码。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;环境准备&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;首先我们将源码&lt;strong&gt;「克隆」&lt;/strong&gt;（Fork）为自己的个人仓库，只需要在 GitHub 项目主页点击 Fork 按钮，然后输入项目名称点击确认即可。克隆完毕后，可以下载到本地，或者直接在科隆后的 GitHub 仓库主页上点击 &lt;code&gt;Create codespace on master&lt;/code&gt; 来创建 &lt;strong&gt;「Codespace」&lt;/strong&gt;。Codespace 是 GitHub 推出的基于 Azure 云服务的远程编程功能，现在对个人账号开放了，可以试一下。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.9491525423728814&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/vh4PtSfBxFOIicEI7jtoAMRArMSoH5MHibkAlXr93SEB1DyVUYWr7omg3iavtFibh9ic0DhcAwmgZNOAMsyOcIqwnsQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;413&quot;/&gt;&lt;figcaption&gt;&lt;span/&gt;Create Codespace&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;点击后，浏览器中会打开一个新页面，并会出现在线 VS Code 的界面，然后显示该项目的目录、代码以及终端，如下图。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5772314270443613&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/vh4PtSfBxFOIicEI7jtoAMRArMSoH5MHibpQ3B0S5icWVov9FFakEvZLiaGhkxd3jrQFickLspIiaksTnCHjrn1fCLng/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1871&quot;/&gt;&lt;figcaption&gt;&lt;span/&gt;Codespace&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;由于我们本次的目的是解析源码，我们主要将在这上面展现和阅读代码，并不会执行它。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;现在，我们可以开始解析源码了。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;入口文件&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;解析源码的一个比较好的手段是找到&lt;strong&gt;「入口文件」&lt;/strong&gt;（Entry File），相当于是一本书的引言（Introduction）章节，项目的整体结构通常会在入口文件中体现出来。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1.574468085106383&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/vh4PtSfBxFOIicEI7jtoAMRArMSoH5MHibDamAbK0vZFVhAymTMZEXZEOiaQSpcBiaF83bZa8CkjNUbOyzv8WXRhlw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;282&quot;/&gt;&lt;figcaption&gt;&lt;span/&gt;Code Structure&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们从项目介绍 &lt;code&gt;README.md&lt;/code&gt; 文件中可以看到，这个定时任务库的使用方式是 &lt;code&gt;cron.New(cron.WithSeconds())&lt;/code&gt; 之类的，也就是 &lt;code&gt;cron.New&lt;/code&gt; 方法。因此，我们可以猜测这个方法是在 &lt;code&gt;cron.go&lt;/code&gt; 中，我们打开它看一看。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;快速扫了一遍之后，我们可以发现这个 &lt;code&gt;New&lt;/code&gt; 方法在 113 行，如下图。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5212355212355212&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/vh4PtSfBxFOIicEI7jtoAMRArMSoH5MHib3pdfnxuepvzmXibb3DUFK3F7micQE0uib78VEIPxUNI2etBO4jKJLmZ9Q/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;2072&quot;/&gt;&lt;figcaption&gt;&lt;span/&gt;Method New&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;仔细看一下，这个方法就是返回了一个 &lt;code&gt;Cron&lt;/code&gt; 类的实例指针，中间的 &lt;code&gt;opts ...Option&lt;/code&gt; 参数是一种函数式参数（Functional Option）。而实际的代码实现，无非就是构造了一个 &lt;code&gt;Cron&lt;/code&gt; 类的实例指针 &lt;code&gt;c&lt;/code&gt;，并对其应用了函数参数，然后返回它。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这样，我们可以判断，真正的定时任务&lt;strong&gt;「核心逻辑」&lt;/strong&gt;就在 &lt;code&gt;Cron&lt;/code&gt; 类中。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;不过，无论如何，我们可以确定，入口文件就是 &lt;code&gt;cron.go&lt;/code&gt;。接下来只需要分析这个文件包含的核心模块、逻辑就可以大概理清楚整个项目的源码了。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;核心类&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那么我们再来看一下&lt;strong&gt;「核心类」&lt;/strong&gt; &lt;code&gt;Cron&lt;/code&gt; 的构造，看看是否有什么新东西。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在代码中搜索一下可以定位到 &lt;code&gt;Cron&lt;/code&gt; 类在第 13 行。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.9465381244522348&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/vh4PtSfBxFOIicEI7jtoAMRArMSoH5MHibl1L1DkWdlZ8f51DYhibRA6ZbNaJfvMhRucrsYlwZYIf8iaVsVabicSK9g/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1141&quot;/&gt;&lt;figcaption&gt;&lt;span/&gt;Cron Struct&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;Cron&lt;/code&gt; 类有很多属性，包括小写单词表示的私有属性 &lt;code&gt;entries&lt;/code&gt;、&lt;code&gt;chain&lt;/code&gt;、&lt;code&gt;parser&lt;/code&gt; 等等，我们暂时还不知道它们各自的含义，不过可以从名称猜测一下。另外，我们还可以看到第 10-12 行的注释描述，意思是 &lt;code&gt;Cron&lt;/code&gt; 会追踪 &lt;code&gt;entries&lt;/code&gt;，并执行被 &lt;code&gt;schedule&lt;/code&gt; 定义的函数，它可以开始运行、结束运行，以及 &lt;code&gt;entries&lt;/code&gt; 也会在运行过程中被检查。一脸懵逼？是的，这些描述虽然长，但并不能完全解释清楚，我们只有继续阅读更多源码中的细节，才可以了解清楚。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;另外，我们还可以在 &lt;code&gt;Cron&lt;/code&gt; 类下面发现 3 个接口以及其描述:&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;ScheduleParser&lt;/code&gt;：定时任务的解析器，可以解析并返回 &lt;code&gt;Schedule&lt;/code&gt; 实例；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;Job&lt;/code&gt;：已提交的定时任务作业&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;Schedule&lt;/code&gt;：用于描述作业的运行周期。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其实，这 3 个接口都很重要，我们从它们的所在位置就可以判断出来。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;入口方法&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在继续探索之前，我们再回忆一下这个定时任务库的使用方法，除了 &lt;code&gt;cron.New&lt;/code&gt; 之外，还需要调用 &lt;code&gt;c.Start()&lt;/code&gt; 才能正式生效。因此，我们需要仔细看看 &lt;code&gt;Cron&lt;/code&gt; 类的 &lt;code&gt;Start&lt;/code&gt; 方法。这其实也是核心类的&lt;strong&gt;「入口方法」&lt;/strong&gt;（Entry Method）。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们可以在 &lt;code&gt;cron.go&lt;/code&gt; 文件中定位到 &lt;code&gt;Start&lt;/code&gt; 方法在第 215 行，如下图。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.28939393939393937&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/vh4PtSfBxFOIicEI7jtoAMRArMSoH5MHibgeIY9skN4NvEB87ic96AJJu0oaw0bfo6IbbLoOQ5tib4YYwD0bTUmyMg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1320&quot;/&gt;&lt;figcaption&gt;&lt;span/&gt;Cron Start&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;比较有经验的 Go 语言开发工程师应该会注意到，这是一个典型的原子性操作（Atomic Operation）。&lt;code&gt;c.runningMu&lt;/code&gt; 是一个 &lt;code&gt;sync.Mutex&lt;/code&gt; 实例，可以&lt;strong&gt;「加锁」&lt;/strong&gt;（Lock）；然后 &lt;code&gt;defer c.runningMu.Unlock()&lt;/code&gt; 表示函数调用之后会&lt;strong&gt;「解锁」&lt;/strong&gt;（Unlock），因此保证重复调用该方法的时候不会出现&lt;strong&gt;「数据竞速」&lt;/strong&gt;（Data Race）；&lt;code&gt;if c.running { return }&lt;/code&gt; 的方法表示，如果已经开始运行了，就不会再执行，直接返回；&lt;code&gt;c.running&lt;/code&gt; 设置运行状态为 &lt;code&gt;true&lt;/code&gt;；最后一行比较关键，&lt;code&gt;go c.run()&lt;/code&gt; 表示新起了一个&lt;strong&gt;「协程」&lt;/strong&gt;（Goroutine）来运行 &lt;code&gt;c.run&lt;/code&gt; 方法。因此，我们找到了更核心的方法，&lt;code&gt;run&lt;/code&gt;。接下来的工作就是继续解析它了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;是不是很像玩 RPG 游戏时不断寻找机关，最终在千辛万苦之下可喜可贺进入下一关？&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;总结&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;等一下，就这么完结撒花了？我那啥都准备好了，你就让我看这个？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们在这里暂时打住的主要原因是不想让这篇文章变得又臭又长。因为源码解析通常是一个&lt;strong&gt;「需要耐心」&lt;/strong&gt;、&lt;strong&gt;「繁琐枯燥」&lt;/strong&gt;的过程，而这种过程有时会让读者产生抵触情绪。因此，笔者的主要目的是&lt;strong&gt;「抛砖引玉」&lt;/strong&gt;，将源码解析的一些核心要领用手把手的方式告诉读者，而读者也会根据自己的理解去实际操作，这样学习起来会更快也会更有意思。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;现在稍微总结一下这篇文章用到的解析源码技巧：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;找到入口文件&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;定位核心类&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;解析入口方法&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;社区&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果您对笔者的文章感兴趣，可以加笔者微信 tikazyq1 并注明 &quot;码之道&quot;，笔者会将你拉入 &quot;码之道&quot; 交流群。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;Reference&lt;/span&gt;&lt;/h3&gt;&lt;section data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;span&gt;[1] &lt;/span&gt;&lt;p&gt;robfig/cron: &lt;span&gt;https://github.com/robfig/cron&lt;/span&gt;&lt;/p&gt;&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>4c443de04647b684e4979f1585703d50</guid>
<title>React 性能优化的那些事儿</title>
<link>https://toutiao.io/k/n5sbfdg</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot; data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;要讲清楚性能优化的原理，就需要知道它的前世今生，需要回答如下的问题：&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;React 是如何进行页面渲染的？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;造成页面的卡顿的罪魁祸首是什么呢？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;我们为什么需要性能优化？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;React 有哪些场景会需要性能优化？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;React 本身的性能优化手段？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;还有哪些工具可以提升性能呢？&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/blockquote&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;为什么页面会出现卡顿的现象？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;为什么浏览器会出现页面卡顿的问题？是不是浏览器不够先进？这都 2202 年了，怎么还会有这种问题呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;实际上问题的根源来源于浏览器的刷新机制。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们人类眼睛的刷新率是 60Hz，浏览器依据人眼的刷新率 计算出了&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;1000 Ms / 60 = 16.6ms&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;也就是说，浏览器要在16.6Ms 进行一次刷新，人眼就不会感觉到卡顿，而如果超过这个时间进行刷新，就会感觉到卡顿。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;而浏览器的主进程在仅仅需要页面的渲染，还需要做解析执行Js，他们运行在一个进程中。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果js的在执行的长时间占用主进程的资源，就会导致没有资源进行页面的渲染刷新，进而导致页面的卡顿。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那么这个又和 React 的性能优化又有什么关系呢？&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;React 到底是在哪里出现了卡顿？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;基于我们上的知识，js 长期霸占浏览器主线程造成无法刷新而造成卡顿。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那么 React 的卡顿也是基于这个原因。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;React 在render的时候，会根据现有render产生的新的jsx的数据和现有fiberRoot 进行比对，找到不同的地方，然后生成新的workInProgress，进而在挂载阶段把新的workInProgress交给服务器渲染。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在这个过程中，React 为了让底层机制更高效快速，进行了大量的优化处理，如设立任务优先级、异步调度、diff算法、时间分片等。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;整个链路就是了高效快速的完成从数据更新到页面渲染的整体流程。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;为了不让递归遍历寻找所有更新节点太大而占用浏览器资源，React 升级了fiber架构，时间分片，让其可以增量更新。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;为了找出所有的更新节点，设立了diff算法，高效的查找所有的节点。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;为了更高效的更新，及时响应用户的操作，设计任务调度优先级。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;而我们的性能优化就是为了不给 React 拖后腿，让其更快，更高效的遍历。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那么性能优化的奥义是什么呢？？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;就是控制刷新渲染的波及范围，我们只让改更新的更新，不该更新的不要更新，让我们的更新链路尽可能的短的走完，那么页面当然就会及时刷新不会卡顿了。&lt;/strong&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;React 有哪些场景会需要性能优化？&lt;/span&gt;&lt;/h2&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;父组件刷新，而不波及子组件&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;组件自己控制自己是否刷新&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;减少波及范围，无关刷新数据不存入state中&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;合并 state,减少重复 setState 的操作&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;如何更快的完成diff的比较，加快进程&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们分别从这些场景说一下：·&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;一：父组件刷新，而不波及子组件。&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们知道 React 在组件刷新判定的时候，如果触发刷新，那么它会深度遍历所有子组件，查找所有更新的节点，依据新的jsx数据和旧的 fiber ，生成新的workInProgress，进而进行页面渲染。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以父组件刷新的话，子组件必然会跟着刷新，但是假如这次的刷新，和我们子组件没有关系呢？怎么减少这种波及呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如下面这样：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;export&lt;/span&gt; &lt;span&gt;default&lt;/span&gt; &lt;span&gt;&lt;span&gt;function&lt;/span&gt; &lt;span&gt;Father1&lt;/span&gt; ()&lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;let&lt;/span&gt; [name,setName] = React.useState(&lt;span&gt;&#x27;&#x27;&lt;/span&gt;);&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; (&lt;br/&gt;        &lt;span&gt;&lt;span&gt;&amp;lt;&lt;span&gt;div&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;&amp;lt;&lt;span&gt;button&lt;/span&gt; &lt;span&gt;onClick&lt;/span&gt;=&lt;span&gt;{()&lt;/span&gt;=&amp;gt;&lt;/span&gt;setName(&quot;获取到的数据&quot;)}&amp;gt;点击获取数据&lt;span&gt;&amp;lt;/&lt;span&gt;button&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;            {name}&lt;br/&gt;            &lt;span&gt;&amp;lt;&lt;span&gt;Children&lt;/span&gt;/&amp;gt;&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;&amp;lt;/&lt;span&gt;div&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;    )&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;function&lt;/span&gt; &lt;span&gt;Children&lt;/span&gt;()&lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; (&lt;br/&gt;        &lt;span&gt;&lt;span&gt;&amp;lt;&lt;span&gt;div&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;            这里是子组件&lt;br/&gt;        &lt;span&gt;&amp;lt;/&lt;span&gt;div&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;    )&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;复制代码&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;运行结果：&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.16377440347071584&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz/pfCCZhlbMQR2GgKe0EsXmHenicYiaSVbTFAVI5FaouBnlZaLeYtiaX5mkbmBxKfPN4Q0PobCq46KwaK46H8zyzIUw/640?wx_fmt=jpeg&quot; data-type=&quot;other&quot; data-w=&quot;1844&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可以看到我们的子组件被波及了，解决办法有很多，总体来说分为两种。&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;子组件自己判断是否需要更新 ,典型的就是 PureComponent，shouldComponentUpdate，memo&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;父组件对子组件做个缓冲判断&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;第一种：使用 PureComponent&lt;/span&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;使用 PureComponent 的原理就是它会对state 和props进行浅比较，如果发现并不相同就会更新。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;export&lt;/span&gt; &lt;span&gt;default&lt;/span&gt; &lt;span&gt;&lt;span&gt;function&lt;/span&gt; &lt;span&gt;Father1&lt;/span&gt; ()&lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;let&lt;/span&gt; [name,setName] = React.useState(&lt;span&gt;&#x27;&#x27;&lt;/span&gt;);&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; (&lt;br/&gt;        &lt;span&gt;&lt;span&gt;&amp;lt;&lt;span&gt;div&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;&amp;lt;&lt;span&gt;button&lt;/span&gt; &lt;span&gt;onClick&lt;/span&gt;=&lt;span&gt;{()&lt;/span&gt;=&amp;gt;&lt;/span&gt;setName(&quot;父组件的数据&quot;)}&amp;gt;点击刷新父组件&lt;span&gt;&amp;lt;/&lt;span&gt;button&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;            {name}&lt;br/&gt;          &lt;br/&gt;            &lt;span&gt;&amp;lt;&lt;span&gt;Children1&lt;/span&gt;/&amp;gt;&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;&amp;lt;/&lt;span&gt;div&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;    )&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;Children&lt;/span&gt; &lt;span&gt;extends&lt;/span&gt; &lt;span&gt;React&lt;/span&gt;.&lt;span&gt;PureComponent&lt;/span&gt;&lt;/span&gt;{&lt;br/&gt;    render() {&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; (&lt;br/&gt;            &lt;span&gt;&lt;span&gt;&amp;lt;&lt;span&gt;div&lt;/span&gt;&amp;gt;&lt;/span&gt;这里是子组件&lt;span&gt;&amp;lt;/&lt;span&gt;div&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;        )&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;复制代码&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;执行结果：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.140197152245345&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz/pfCCZhlbMQR2GgKe0EsXmHenicYiaSVbTFa4Am031f9j44Jk3B0C3d3hFVP4HWJR1LMXYRh05GicTFNm6oAribAkqQ/640?wx_fmt=jpeg&quot; data-type=&quot;other&quot; data-w=&quot;1826&quot;/&gt;&lt;figcaption&gt;04.jpg&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;实际上&lt;code&gt;PureComponent&lt;/code&gt;就是在内部更新的时候调用了会调用如下方法来判断 新旧state和props&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;function shallowEqual(objA: mixed, objB: mixed): boolean {&lt;br/&gt;  if (is(objA, objB)) {&lt;br/&gt;    return true;&lt;br/&gt;  }&lt;br/&gt;  if (&lt;br/&gt;    typeof objA !== &#x27;object&#x27; ||&lt;br/&gt;    objA === null ||&lt;br/&gt;    typeof objB !== &#x27;object&#x27; ||&lt;br/&gt;    objB === null&lt;br/&gt;  ) {&lt;br/&gt;    return false;&lt;br/&gt;  }&lt;br/&gt;  const keysA = Object.keys(objA);&lt;br/&gt;  const keysB = Object.keys(objB);&lt;br/&gt;  if (keysA.length !== keysB.length) {&lt;br/&gt;    return false;&lt;br/&gt;  }&lt;br/&gt;  // Test for A&#x27;s keys different from B.&lt;br/&gt;  for (let i = 0; i &amp;lt; keysA.length; i++) {&lt;br/&gt;    const currentKey = keysA[i];&lt;br/&gt;    if (&lt;br/&gt;      !hasOwnProperty.call(objB, currentKey) ||&lt;br/&gt;      !is(objA[currentKey], objB[currentKey])&lt;br/&gt;    ) {&lt;br/&gt;      return false;&lt;br/&gt;    }&lt;br/&gt;  }&lt;br/&gt;  return true;&lt;br/&gt;}&lt;br/&gt;复制代码&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;它的判断步骤如下：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;第一步，首先会直接比较新老 &lt;code&gt;props&lt;/code&gt; 或者新老 &lt;code&gt;state&lt;/code&gt; 是否相等。如果相等那么不更新组件。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;第二步，判断新老 &lt;code&gt;state&lt;/code&gt; 或者 &lt;code&gt;props&lt;/code&gt; ，有不是对象或者为 &lt;code&gt;null&lt;/code&gt; 的，那么直接返回 false ，更新组件。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;第三步，通过 &lt;code&gt;Object.keys&lt;/code&gt; 将新老 &lt;code&gt;props&lt;/code&gt; 或者新老 &lt;code&gt;state&lt;/code&gt; 的属性名 &lt;code&gt;key&lt;/code&gt; 变成数组，判断数组的长度是否相等，如果不相等，证明有属性增加或者减少，那么更新组件。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;第四步，遍历老 &lt;code&gt;props&lt;/code&gt; 或者老 &lt;code&gt;state&lt;/code&gt; ，判断对应的新 &lt;code&gt;props&lt;/code&gt; 或新 &lt;code&gt;state&lt;/code&gt; ，有没有与之对应并且相等的（这个相等是浅比较），如果有一个不对应或者不相等，那么直接返回 &lt;code&gt;false&lt;/code&gt; ，更新组件。到此为止，浅比较流程结束， &lt;code&gt;PureComponent&lt;/code&gt; 就是这么做渲染节流优化的。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;在使用PureComponent时需要注意的细节：&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;由于&lt;code&gt;PureComponent&lt;/code&gt; 使用的是浅比较判断&lt;code&gt;state&lt;/code&gt;和&lt;code&gt;props&lt;/code&gt;，所以如果我们在父子组件中，子组件使用&lt;code&gt;PureComponent&lt;/code&gt;,在父组件刷新的过程中不小心把传给子组件的回调函数变了，就会造成子组件的误触发，这个时候&lt;code&gt;PureComponent&lt;/code&gt;就失效了。&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;细节一：函数组件中，匿名函数，箭头函数和普通函数都会重新声明&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;下面这些情况都会造成函数的重新声明：&lt;/p&gt;&lt;h6 data-tool=&quot;mdnice编辑器&quot;&gt;箭头函数&lt;/h6&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt; &amp;lt;Children1 callback={(value)=&amp;gt;setValue(value)}/&amp;gt;&lt;br/&gt;复制代码&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h6 data-tool=&quot;mdnice编辑器&quot;&gt;匿名函数&lt;/h6&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&amp;lt;Children1 callback={function (value){setValue(value)}}/&amp;gt;&lt;br/&gt;复制代码&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h6 data-tool=&quot;mdnice编辑器&quot;&gt;普通函数&lt;/h6&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;export&lt;/span&gt; &lt;span&gt;default&lt;/span&gt; &lt;span&gt;&lt;span&gt;function&lt;/span&gt; &lt;span&gt;Father1&lt;/span&gt; ()&lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;let&lt;/span&gt; [name,setName] = React.useState(&lt;span&gt;&#x27;&#x27;&lt;/span&gt;);&lt;br/&gt;    &lt;span&gt;let&lt;/span&gt; [value,setValue] = React.useState(&lt;span&gt;&#x27;&#x27;&lt;/span&gt;)&lt;br/&gt;    &lt;span&gt;const&lt;/span&gt; setData=&lt;span&gt;(&lt;span&gt;value&lt;/span&gt;)=&amp;gt;&lt;/span&gt;{&lt;br/&gt;        setValue(value)&lt;br/&gt;    }&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; (&lt;br/&gt;        &lt;span&gt;&lt;span&gt;&amp;lt;&lt;span&gt;div&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;&amp;lt;&lt;span&gt;button&lt;/span&gt; &lt;span&gt;onClick&lt;/span&gt;=&lt;span&gt;{()&lt;/span&gt;=&amp;gt;&lt;/span&gt;setName(&quot;父组件的数据&quot;+Math.random())}&amp;gt;点击刷新父组件&lt;span&gt;&amp;lt;/&lt;span&gt;button&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;            {name}&lt;br/&gt;            &lt;span&gt;&amp;lt;&lt;span&gt;Children1&lt;/span&gt; &lt;span&gt;callback&lt;/span&gt;=&lt;span&gt;{setData}/&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;&amp;lt;/&lt;span&gt;div&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;    )&lt;br/&gt;}&lt;br/&gt;&lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;Children1&lt;/span&gt; &lt;span&gt;extends&lt;/span&gt; &lt;span&gt;React&lt;/span&gt;.&lt;span&gt;PureComponent&lt;/span&gt;&lt;/span&gt;{&lt;br/&gt;    render() {&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; (&lt;br/&gt;            &lt;span&gt;&lt;span&gt;&amp;lt;&lt;span&gt;div&lt;/span&gt;&amp;gt;&lt;/span&gt;这里是子组件&lt;span&gt;&amp;lt;/&lt;span&gt;div&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;        )&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;复制代码&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;执行结果：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.22355289421157684&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz/pfCCZhlbMQR2GgKe0EsXmHenicYiaSVbTFdCSNKJyw85UDQajUEnTqHKjS3slSD0RZxUu8HCQkDLEjMLfMPA4tVA/640?wx_fmt=jpeg&quot; data-type=&quot;other&quot; data-w=&quot;2004&quot; class=&quot;rich_pages wxw-img&quot;/&gt;&lt;figcaption&gt;05.jpg&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可以看到子组件的 PureComponent 完全失效了。这个时候就可以使用useMemo或者 useCallback 出马了，利用他们缓冲一份函数，保证不会出现重复声明就可以了。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;export&lt;/span&gt; &lt;span&gt;default&lt;/span&gt; &lt;span&gt;&lt;span&gt;function&lt;/span&gt; &lt;span&gt;Father1&lt;/span&gt; ()&lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;let&lt;/span&gt; [name,setName] = React.useState(&lt;span&gt;&#x27;&#x27;&lt;/span&gt;);&lt;br/&gt;    &lt;span&gt;let&lt;/span&gt; [value,setValue] = React.useState(&lt;span&gt;&#x27;&#x27;&lt;/span&gt;)&lt;br/&gt;    &lt;span&gt;const&lt;/span&gt; setData= React.useCallback(&lt;span&gt;(&lt;span&gt;value&lt;/span&gt;)=&amp;gt;&lt;/span&gt;{&lt;br/&gt;        setValue(value)&lt;br/&gt;    },[])&lt;br/&gt;    &lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; (&lt;br/&gt;        &lt;span&gt;&lt;span&gt;&amp;lt;&lt;span&gt;div&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;&amp;lt;&lt;span&gt;button&lt;/span&gt; &lt;span&gt;onClick&lt;/span&gt;=&lt;span&gt;{()&lt;/span&gt;=&amp;gt;&lt;/span&gt;setName(&quot;父组件的数据&quot;+Math.random())}&amp;gt;点击刷新父组件&lt;span&gt;&amp;lt;/&lt;span&gt;button&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;            {name}&lt;br/&gt;            &lt;span&gt;&amp;lt;&lt;span&gt;Children1&lt;/span&gt; &lt;span&gt;callback&lt;/span&gt;=&lt;span&gt;{setData}/&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;&amp;lt;/&lt;span&gt;div&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;    )&lt;br/&gt;}&lt;br/&gt;复制代码&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;看结果：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.17395626242544732&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz/pfCCZhlbMQR2GgKe0EsXmHenicYiaSVbTFEcwqibWZTZwZxaCMXWwar6roNbWt4fPdcVcYxmuX8QeQZkzo8aFDhCg/640?wx_fmt=jpeg&quot; data-type=&quot;other&quot; data-w=&quot;2012&quot;/&gt;可以看到我们的子组件这次并没有参与父组件的刷新，在&lt;code&gt;React Profiler&lt;/code&gt;中也提示，&lt;code&gt;Children1&lt;/code&gt;并没有渲染。&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;细节二：class组件中不使用箭头函数，匿名函数&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;原理和函数组件中的一样，class 组件中每一次刷新都会重复调用&lt;code&gt;render&lt;/code&gt;函数，那么&lt;code&gt;render&lt;/code&gt;函数中使用的匿名函数，箭头函数就会造成重复刷新的问题。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;export &lt;span&gt;default&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;Father&lt;/span&gt; &lt;span&gt;extends&lt;/span&gt; &lt;span&gt;React&lt;/span&gt;.&lt;span&gt;PureComponent&lt;/span&gt;&lt;/span&gt;{&lt;br/&gt;    constructor(props) {&lt;br/&gt;        &lt;span&gt;super&lt;/span&gt;(props);&lt;br/&gt;        &lt;span&gt;this&lt;/span&gt;.state = {&lt;br/&gt;            name:&lt;span&gt;&quot;&quot;&lt;/span&gt;,&lt;br/&gt;            count:&lt;span&gt;&quot;&quot;&lt;/span&gt;,&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;    render() {&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; (&lt;br/&gt;            &amp;lt;div&amp;gt;&lt;br/&gt;                &amp;lt;button onClick={()=&amp;gt;&lt;span&gt;this&lt;/span&gt;.setState({name:&lt;span&gt;&quot;父组件的数据&quot;&lt;/span&gt;+&lt;span&gt;Math&lt;/span&gt;.random()})}&amp;gt;点击获取数据&amp;lt;/button&amp;gt;&lt;br/&gt;                {&lt;span&gt;this&lt;/span&gt;.state.name}&lt;br/&gt;                &amp;lt;&lt;span&gt;Children1&lt;/span&gt; callback={()=&amp;gt;&lt;span&gt;this&lt;/span&gt;.setState({count:&lt;span&gt;11&lt;/span&gt;})}/&amp;gt;&lt;br/&gt;            &amp;lt;/div&amp;gt;&lt;br/&gt;        )&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;复制代码&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;执行结果：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.17777777777777778&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz/pfCCZhlbMQR2GgKe0EsXmHenicYiaSVbTF8TiaIRdibg8afrLU0Cu0Df05CpT7F1bLib0UqiaMPibnASv5ib62cBnoViclA/640?wx_fmt=jpeg&quot; data-type=&quot;other&quot; data-w=&quot;1980&quot;/&gt;&lt;figcaption&gt;image.png&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;而优化这个非常简单，只需要把函数换成普通函数就可以。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;export &lt;span&gt;default&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;Father&lt;/span&gt; &lt;span&gt;extends&lt;/span&gt; &lt;span&gt;React&lt;/span&gt;.&lt;span&gt;PureComponent&lt;/span&gt;&lt;/span&gt;{&lt;br/&gt;    constructor(props) {&lt;br/&gt;        &lt;span&gt;super&lt;/span&gt;(props);&lt;br/&gt;        &lt;span&gt;this&lt;/span&gt;.state = {&lt;br/&gt;            name:&lt;span&gt;&quot;&quot;&lt;/span&gt;,&lt;br/&gt;            count:&lt;span&gt;&quot;&quot;&lt;/span&gt;,&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;    setCount=(count)=&amp;gt;{&lt;br/&gt;        &lt;span&gt;this&lt;/span&gt;.setState({count})&lt;br/&gt;    }&lt;br/&gt;    render() {&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; (&lt;br/&gt;            &amp;lt;div&amp;gt;&lt;br/&gt;                &amp;lt;button onClick={()=&amp;gt;&lt;span&gt;this&lt;/span&gt;.setState({name:&lt;span&gt;&quot;父组件的数据&quot;&lt;/span&gt;+&lt;span&gt;Math&lt;/span&gt;.random()})}&amp;gt;点击获取数据&amp;lt;/button&amp;gt;&lt;br/&gt;                {&lt;span&gt;this&lt;/span&gt;.state.name}&lt;br/&gt;                &amp;lt;&lt;span&gt;Children1&lt;/span&gt; callback={&lt;span&gt;this&lt;/span&gt;.setCount(&lt;span&gt;111&lt;/span&gt;)}/&amp;gt;&lt;br/&gt;            &amp;lt;/div&amp;gt;&lt;br/&gt;        )&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;复制代码&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;执行结果：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.16683621566632756&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz/pfCCZhlbMQR2GgKe0EsXmHenicYiaSVbTF2Zg4JflFt2ok12UbXp1b2rYb7icb8rqnxcSHA0RWBdbsjRGpKgibTlDw/640?wx_fmt=jpeg&quot; data-type=&quot;other&quot; data-w=&quot;1966&quot;/&gt;&lt;figcaption&gt;image.png&lt;/figcaption&gt;&lt;/figure&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;细节三：在 class 组件的render函数中调用bind 函数&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个细节是我们在class组件中，没有在&lt;code&gt;constructor&lt;/code&gt;中进行&lt;code&gt;bind&lt;/code&gt;的操作，而是在&lt;code&gt;render&lt;/code&gt;函数中，那么由于&lt;code&gt;bind&lt;/code&gt;函数的特性，它的每一次调用都会返回一个新的函数，所以同样会造成&lt;code&gt;PureComponent&lt;/code&gt;的失效&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;export &lt;span&gt;default&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;Father&lt;/span&gt; &lt;span&gt;extends&lt;/span&gt; &lt;span&gt;React&lt;/span&gt;.&lt;span&gt;PureComponent&lt;/span&gt;&lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;//...&lt;/span&gt;&lt;br/&gt;    setCount(count){&lt;br/&gt;        &lt;span&gt;this&lt;/span&gt;.setCount({count})&lt;br/&gt;    }&lt;br/&gt;    render() {&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; (&lt;br/&gt;            &amp;lt;div&amp;gt;&lt;br/&gt;                &amp;lt;button onClick={()=&amp;gt;&lt;span&gt;this&lt;/span&gt;.setState({name:&lt;span&gt;&quot;父组件的数据&quot;&lt;/span&gt;+&lt;span&gt;Math&lt;/span&gt;.random()})}&amp;gt;点击获取数据&amp;lt;/button&amp;gt;&lt;br/&gt;                {&lt;span&gt;this&lt;/span&gt;.state.name}&lt;br/&gt;                &amp;lt;&lt;span&gt;Children1&lt;/span&gt; callback={&lt;span&gt;this&lt;/span&gt;.setCount.bind(&lt;span&gt;this&lt;/span&gt;,&lt;span&gt;&quot;11111&quot;&lt;/span&gt;)}/&amp;gt;&lt;br/&gt;            &amp;lt;/div&amp;gt;&lt;br/&gt;        )&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;复制代码&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;看执行结果：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.13354037267080746&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz/pfCCZhlbMQR2GgKe0EsXmHenicYiaSVbTFyCkloezoQMrqSuHsicIs2aSHXfOQ4YGVAP4XX31r4fib80eeDCpbiaSRw/640?wx_fmt=jpeg&quot; data-type=&quot;other&quot; data-w=&quot;1932&quot;/&gt;&lt;figcaption&gt;image.png&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;优化的方式也很简单，把&lt;code&gt;bind&lt;/code&gt;操作放在&lt;code&gt;constructor&lt;/code&gt;中就可以了。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;constructor&lt;/span&gt;(props) {&lt;br/&gt;    &lt;span&gt;super&lt;/span&gt;(props);&lt;br/&gt;    &lt;span&gt;this&lt;/span&gt;.state = {&lt;br/&gt;        name:&lt;span&gt;&quot;&quot;&lt;/span&gt;,&lt;br/&gt;        count:&lt;span&gt;&quot;&quot;&lt;/span&gt;,&lt;br/&gt;    }&lt;br/&gt;    &lt;span&gt;this&lt;/span&gt;.setCount= &lt;span&gt;this&lt;/span&gt;.setCount.bind(&lt;span&gt;this&lt;/span&gt;);&lt;br/&gt;}&lt;br/&gt;复制代码&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;执行结果就不在此展示了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;而实际上上诉所说的三个细节同样对&lt;code&gt;React.memo&lt;/code&gt;有效，它同样也会浅比较传入的&lt;code&gt;props&lt;/code&gt;.&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;第二种：shouldComponentUpdate&lt;/span&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;class 组件中 使用 shouldComponentUpdate 是主要的优化方式，它不仅仅可以判断来自父组件的&lt;code&gt;nextprops&lt;/code&gt;，还可以根据&lt;code&gt;nextState&lt;/code&gt;和最新的&lt;code&gt;nextContext&lt;/code&gt;来决定是否更新。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;Children2&lt;/span&gt; &lt;span&gt;extends&lt;/span&gt; &lt;span&gt;React&lt;/span&gt;. &lt;span&gt;PureComponent&lt;/span&gt;&lt;/span&gt;{&lt;br/&gt;    shouldComponentUpdate(nextProps, nextState, nextContext) {&lt;br/&gt;        &lt;span&gt;//判断只有偶数的时候，子组件才会更新&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt;(nextProps !== &lt;span&gt;this&lt;/span&gt;.props &amp;amp;&amp;amp; nextProps.count  % &lt;span&gt;2&lt;/span&gt; === &lt;span&gt;0&lt;/span&gt;){&lt;br/&gt;            &lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;;&lt;br/&gt;        }&lt;span&gt;else&lt;/span&gt;{&lt;br/&gt;            &lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;;&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;    render() {&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; (&lt;br/&gt;            &amp;lt;div&amp;gt;&lt;br/&gt;                只有父组件传入的值等于 &lt;span&gt;2&lt;/span&gt;的时候才会更新&lt;br/&gt;                {&lt;span&gt;this&lt;/span&gt;.props.count}&lt;br/&gt;            &amp;lt;/div&amp;gt;&lt;br/&gt;        )&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;复制代码&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;它的用法也是非常简单，就是如果需要更新就返回true，不需要更新就返回false.&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;第三种：函数组件如何判断props的变化的更新呢？使用 React.memo函数&lt;/span&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;React.memo&lt;/code&gt;的规则是如果想要复用最后一次渲染结果，就返回&lt;code&gt;true&lt;/code&gt;，不想复用就返回&lt;code&gt;false&lt;/code&gt;。所以它和&lt;code&gt;shouldComponentUpdate&lt;/code&gt;的正好相反，&lt;code&gt;false&lt;/code&gt;才会更新，&lt;code&gt;true&lt;/code&gt;就返回缓冲。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;const&lt;/span&gt; Children3 = React.memo(&lt;span&gt;&lt;span&gt;function&lt;/span&gt; (&lt;span&gt;{count}&lt;/span&gt;)&lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; (&lt;br/&gt;        &lt;span&gt;&lt;span&gt;&amp;lt;&lt;span&gt;div&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;            只有父组件传入的值是偶数的时候才会更新&lt;br/&gt;            {count}&lt;br/&gt;        &lt;span&gt;&amp;lt;/&lt;span&gt;div&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;    )&lt;br/&gt;},(prevProps, nextProps)=&amp;gt;{&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt;(nextProps.count % &lt;span&gt;2&lt;/span&gt; === &lt;span&gt;0&lt;/span&gt;){&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;;&lt;br/&gt;    }&lt;span&gt;else&lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;;&lt;br/&gt;    }&lt;br/&gt;})&lt;br/&gt;复制代码&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果我们不传入第二个函数，而是默认让 &lt;code&gt;React.memo&lt;/code&gt;包裹一下，那么它只会对&lt;code&gt;props&lt;/code&gt;浅比较一下，并不会有比较&lt;code&gt;state&lt;/code&gt;之类的逻辑。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;以上三种都是我们为了应对父组件更新触发子组件，子组件决定是否更新的实现。下面我们讲一下父组件对子组件缓冲实现的情况：&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;使用 React.useMemo来实现对子组件的缓冲&lt;/span&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;看下面这段逻辑，我们的子组件只关心&lt;code&gt;count&lt;/code&gt;数据，当我们刷新&lt;code&gt;name&lt;/code&gt;数据的时候，并不会触发刷新 &lt;code&gt;Children1&lt;/code&gt;子组件，实现了我们对组件的缓冲控制。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;export&lt;/span&gt; &lt;span&gt;default&lt;/span&gt; &lt;span&gt;&lt;span&gt;function&lt;/span&gt; &lt;span&gt;Father1&lt;/span&gt; ()&lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;let&lt;/span&gt; [count,setCount] = React.useState(&lt;span&gt;0&lt;/span&gt;);&lt;br/&gt;    &lt;span&gt;let&lt;/span&gt; [name,setName] = React.useState(&lt;span&gt;0&lt;/span&gt;);&lt;br/&gt;    &lt;span&gt;const&lt;/span&gt; render = React.useMemo(&lt;span&gt;&lt;span&gt;()&lt;/span&gt;=&amp;gt;&lt;span&gt;&amp;lt;&lt;span&gt;Children1&lt;/span&gt; &lt;span&gt;count&lt;/span&gt; = &lt;span&gt;{count}/&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;,[count])&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; (&lt;br/&gt;        &lt;span&gt;&lt;span&gt;&amp;lt;&lt;span&gt;div&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;&amp;lt;&lt;span&gt;button&lt;/span&gt; &lt;span&gt;onClick&lt;/span&gt;=&lt;span&gt;{()&lt;/span&gt;=&amp;gt;&lt;/span&gt;setCount(++count)}&amp;gt;点击刷新count&lt;span&gt;&amp;lt;/&lt;span&gt;button&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;&amp;lt;&lt;span&gt;br&lt;/span&gt;/&amp;gt;&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;&amp;lt;&lt;span&gt;button&lt;/span&gt; &lt;span&gt;onClick&lt;/span&gt;=&lt;span&gt;{()&lt;/span&gt;=&amp;gt;&lt;/span&gt;setName(++name)}&amp;gt;点击刷新name&lt;span&gt;&amp;lt;/&lt;span&gt;button&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;&amp;lt;&lt;span&gt;br&lt;/span&gt;/&amp;gt;&lt;/span&gt;&lt;br/&gt;            {&quot;count&quot;+count}&lt;br/&gt;            &lt;span&gt;&amp;lt;&lt;span&gt;br&lt;/span&gt;/&amp;gt;&lt;/span&gt;&lt;br/&gt;            {&quot;name&quot;+name}&lt;br/&gt;            &lt;span&gt;&amp;lt;&lt;span&gt;br&lt;/span&gt;/&amp;gt;&lt;/span&gt;&lt;br/&gt;            {render}&lt;br/&gt;        &lt;span&gt;&amp;lt;/&lt;span&gt;div&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;    )&lt;br/&gt;}&lt;br/&gt;&lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;Children1&lt;/span&gt; &lt;span&gt;extends&lt;/span&gt; &lt;span&gt;React&lt;/span&gt;.&lt;span&gt;PureComponent&lt;/span&gt;&lt;/span&gt;{&lt;br/&gt;    render() {&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; (&lt;br/&gt;            &lt;span&gt;&lt;span&gt;&amp;lt;&lt;span&gt;div&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;                子组件只关系count 数据&lt;br/&gt;                {this.props.count}&lt;br/&gt;            &lt;span&gt;&amp;lt;/&lt;span&gt;div&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;        )&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;复制代码&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;执行结果：当我们点击刷新name数据时，可以看到没有子组件参与刷新&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.1894463667820069&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz/pfCCZhlbMQR2GgKe0EsXmHenicYiaSVbTF4ogStoIsmsyU2IzibxkZ0PgzMUsEic4vq8msibaXuCQfBiaLkfUHib4L4kw/640?wx_fmt=jpeg&quot; data-type=&quot;other&quot; data-w=&quot;2312&quot; class=&quot;rich_pages wxw-img&quot;/&gt;当我们点击刷新count 数据时，子组件参与了刷新&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.1745325022261799&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz/pfCCZhlbMQR2GgKe0EsXmHenicYiaSVbTF7OOwQQ0Sib7nicfZ1QgYRDvT7v82bKJuic5BleNSs38RE12TWxCm3yMfQ/640?wx_fmt=jpeg&quot; data-type=&quot;other&quot; data-w=&quot;2246&quot;/&gt;&lt;figcaption&gt;image.png&lt;/figcaption&gt;&lt;/figure&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;二：组件自己控制自己是否刷新&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里就需要用到上面提到的&lt;code&gt;shouldComponentUpdate&lt;/code&gt;以及&lt;code&gt;PureComponent&lt;/code&gt;,这里不再赘述。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;三：减少波及范围，无关刷新数据不存入state中&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这种场景就是我们有意识的控制，如果有一个数据我们在页面上并没有用到它，但是它又和我们的其他的逻辑有关系，那么我们就可以把它存储在其他的地方，而不是state中。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;场景一：无意义重复调用setState，合并相关的state&lt;/span&gt;&lt;/h4&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;export&lt;/span&gt; &lt;span&gt;default&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;Father&lt;/span&gt; &lt;span&gt;extends&lt;/span&gt; &lt;span&gt;React&lt;/span&gt;.&lt;span&gt;Component&lt;/span&gt;&lt;/span&gt;{&lt;br/&gt;    state = {&lt;br/&gt;        &lt;span&gt;count&lt;/span&gt;:&lt;span&gt;0&lt;/span&gt;,&lt;br/&gt;        &lt;span&gt;name&lt;/span&gt;:&lt;span&gt;&quot;&quot;&lt;/span&gt;,&lt;br/&gt;    }&lt;br/&gt;    getData=&lt;span&gt;(&lt;span&gt;count&lt;/span&gt;)=&amp;gt;&lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;this&lt;/span&gt;.setState({count});&lt;br/&gt;        &lt;span&gt;//依据异步获取数据&lt;/span&gt;&lt;br/&gt;        setTimeout(&lt;span&gt;&lt;span&gt;()&lt;/span&gt;=&amp;gt;&lt;/span&gt;{&lt;br/&gt;            &lt;span&gt;this&lt;/span&gt;.setState({&lt;br/&gt;                &lt;span&gt;name&lt;/span&gt;:&lt;span&gt;&quot;异步获取回来的数据&quot;&lt;/span&gt;+count&lt;br/&gt;            })&lt;br/&gt;        },&lt;span&gt;200&lt;/span&gt;)&lt;br/&gt;    }&lt;br/&gt;    componentDidUpdate(prevProps, prevState, snapshot) {&lt;br/&gt;        &lt;span&gt;console&lt;/span&gt;.log(&lt;span&gt;&quot;渲染次数,&quot;&lt;/span&gt;,++count,&lt;span&gt;&quot;次&quot;&lt;/span&gt;)&lt;br/&gt;    }&lt;br/&gt;    render() {&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; (&lt;br/&gt;            &lt;span&gt;&lt;span&gt;&amp;lt;&lt;span&gt;div&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;                &lt;span&gt;&amp;lt;&lt;span&gt;button&lt;/span&gt; &lt;span&gt;onClick&lt;/span&gt;=&lt;span&gt;{()&lt;/span&gt;=&amp;gt;&lt;/span&gt;this.getData(++this.state.count)}&amp;gt;点击获取数据&lt;span&gt;&amp;lt;/&lt;span&gt;button&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;                {this.state.name}&lt;br/&gt;            &lt;span&gt;&amp;lt;/&lt;span&gt;div&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;        )&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;复制代码&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;React Profiler&lt;/code&gt;的执行结果：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.21074964639321075&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz/pfCCZhlbMQR2GgKe0EsXmHenicYiaSVbTFYxwVxbeOSgFonJhnhY795KRPcianVZncQ7RPvsicec69xbAKj1tMMc3Q/640?wx_fmt=jpeg&quot; data-type=&quot;other&quot; data-w=&quot;1414&quot;/&gt;&lt;figcaption&gt;01.jpg&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可以看到我们的父组件执行了两次。其中的一次是无意义的先&lt;code&gt;setState&lt;/code&gt;保存一次数据，然后又根据这个数据异步获取了数据以后又调用了一次&lt;code&gt;setState&lt;/code&gt;，造成了第二次的数据刷新.&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;而解决办法就是把这个数据合并到异步数据获取完成以后，一起更新到state中。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;getData=&lt;span&gt;(&lt;span&gt;count&lt;/span&gt;)=&amp;gt;&lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;//依据异步获取数据&lt;/span&gt;&lt;br/&gt;        setTimeout(&lt;span&gt;&lt;span&gt;()&lt;/span&gt;=&amp;gt;&lt;/span&gt;{&lt;br/&gt;            &lt;span&gt;this&lt;/span&gt;.setState({&lt;br/&gt;                &lt;span&gt;name&lt;/span&gt;:&lt;span&gt;&quot;异步获取回来的数据&quot;&lt;/span&gt;+count,&lt;br/&gt;                count&lt;br/&gt;            })&lt;br/&gt;        },&lt;span&gt;200&lt;/span&gt;)&lt;br/&gt;}&lt;br/&gt;复制代码&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;看执行结果：只渲染了一次。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.18413597733711048&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz/pfCCZhlbMQR2GgKe0EsXmHenicYiaSVbTFe6op19QfPUx8Jau7IMvWHyZWAKeicr01ibYAEDUdHtRe5HUnR8R7EhDg/640?wx_fmt=jpeg&quot; data-type=&quot;other&quot; data-w=&quot;1412&quot;/&gt;&lt;figcaption&gt;02.jpg&lt;/figcaption&gt;&lt;/figure&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;场景二：和页面刷新没有相关的数据，不存入state中&lt;/span&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;实际上我们发现这个数据在页面上并没有展示，我们并不需要把他们都存放在state 中，所以我们可以把这个数据存储在state之外的地方。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;br/&gt;&lt;span&gt;export&lt;/span&gt; &lt;span&gt;default&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;Father&lt;/span&gt; &lt;span&gt;extends&lt;/span&gt; &lt;span&gt;React&lt;/span&gt;.&lt;span&gt;Component&lt;/span&gt;&lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;constructor&lt;/span&gt;(props) {&lt;br/&gt;        &lt;span&gt;super&lt;/span&gt;(props);&lt;br/&gt;        &lt;span&gt;this&lt;/span&gt;.state = {&lt;br/&gt;            &lt;span&gt;name&lt;/span&gt;:&lt;span&gt;&quot;&quot;&lt;/span&gt;,&lt;br/&gt;        }&lt;br/&gt;        &lt;span&gt;this&lt;/span&gt;.count = &lt;span&gt;0&lt;/span&gt;;&lt;br/&gt;    }&lt;br/&gt;    getData=&lt;span&gt;(&lt;span&gt;count&lt;/span&gt;)=&amp;gt;&lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;this&lt;/span&gt;.count = count;&lt;br/&gt;        &lt;span&gt;//依据异步获取数据&lt;/span&gt;&lt;br/&gt;        setTimeout(&lt;span&gt;&lt;span&gt;()&lt;/span&gt;=&amp;gt;&lt;/span&gt;{&lt;br/&gt;            &lt;span&gt;this&lt;/span&gt;.setState({&lt;br/&gt;                &lt;span&gt;name&lt;/span&gt;:&lt;span&gt;&quot;异步获取回来的数据&quot;&lt;/span&gt;+count,&lt;br/&gt;            })&lt;br/&gt;        },&lt;span&gt;200&lt;/span&gt;)&lt;br/&gt;    }&lt;br/&gt;    componentDidUpdate(prevProps, prevState, snapshot) {&lt;br/&gt;        &lt;span&gt;console&lt;/span&gt;.log(&lt;span&gt;&quot;渲染次数,&quot;&lt;/span&gt;,++count,&lt;span&gt;&quot;次&quot;&lt;/span&gt;)&lt;br/&gt;    }&lt;br/&gt;    render() {&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; (&lt;br/&gt;            &lt;span&gt;&lt;span&gt;&amp;lt;&lt;span&gt;div&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;                &lt;span&gt;&amp;lt;&lt;span&gt;button&lt;/span&gt; &lt;span&gt;onClick&lt;/span&gt;=&lt;span&gt;{()&lt;/span&gt;=&amp;gt;&lt;/span&gt;this.getData(++this.count)}&amp;gt;点击获取数据&lt;span&gt;&amp;lt;/&lt;span&gt;button&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;                {this.state.name}&lt;br/&gt;            &lt;span&gt;&amp;lt;/&lt;span&gt;div&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;        )&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;复制代码&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这样的操作并不会影响我们对它的使用。在&lt;code&gt;class&lt;/code&gt;组件中我们可以把数据存储在&lt;code&gt;this&lt;/code&gt;上面，而在&lt;code&gt;Function&lt;/code&gt;中，则我们可以通过利用 &lt;code&gt;useRef&lt;/code&gt; 这个 &lt;code&gt;Hooks&lt;/code&gt; 来实现同样的效果。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;export&lt;/span&gt; &lt;span&gt;default&lt;/span&gt; &lt;span&gt;&lt;span&gt;function&lt;/span&gt; &lt;span&gt;Father1&lt;/span&gt; ()&lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;let&lt;/span&gt; [name,setName] = React.useState(&lt;span&gt;&#x27;&#x27;&lt;/span&gt;);&lt;br/&gt;    &lt;span&gt;const&lt;/span&gt; countContainer = React.useRef(&lt;span&gt;0&lt;/span&gt;);&lt;br/&gt;    &lt;span&gt;const&lt;/span&gt; getData=&lt;span&gt;(&lt;span&gt;count&lt;/span&gt;)=&amp;gt;&lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;//依据异步获取数据&lt;/span&gt;&lt;br/&gt;        setTimeout(&lt;span&gt;&lt;span&gt;()&lt;/span&gt;=&amp;gt;&lt;/span&gt;{&lt;br/&gt;            setName(&lt;span&gt;&quot;异步获取回来的数据&quot;&lt;/span&gt;+count)&lt;br/&gt;            countContainer.current = count++;&lt;br/&gt;        },&lt;span&gt;200&lt;/span&gt;)&lt;br/&gt;    }&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; (&lt;br/&gt;        &lt;span&gt;&lt;span&gt;&amp;lt;&lt;span&gt;div&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;&amp;lt;&lt;span&gt;button&lt;/span&gt; &lt;span&gt;onClick&lt;/span&gt;=&lt;span&gt;{()&lt;/span&gt;=&amp;gt;&lt;/span&gt;getData(++countContainer.current)}&amp;gt;点击获取数据&lt;span&gt;&amp;lt;/&lt;span&gt;button&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;            {name}&lt;br/&gt;        &lt;span&gt;&amp;lt;/&lt;span&gt;div&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;    )&lt;br/&gt;}&lt;br/&gt;复制代码&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;场景三：通过存入useRef的数据中，避免父子组件的重复刷新&lt;/span&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;假设父组件中有需要用到子组件的数据，子组件需要把数据回到返回给父组件，而如果父组件把这份数据存入到了 &lt;code&gt;stat&lt;/code&gt;e 中，那么父组件刷新，子组件也会跟着刷新。这种的情况我们就可以把数据存入到 &lt;code&gt;useRef&lt;/code&gt; 中，以避免无意义的刷新出现。或者把数据存入到class的 &lt;code&gt;this&lt;/code&gt; 下。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;四：合并 state,减少重复 setState 的操作&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;合并 &lt;code&gt;state&lt;/code&gt; ,减少重复 &lt;code&gt;setState&lt;/code&gt; 的操作,实际上 &lt;code&gt;React&lt;/code&gt;已经帮我们做了，那就是批量更新，在&lt;code&gt;React18&lt;/code&gt; 之前的版本中，批量更新只有在 React自己的生命周期或者点击事件中有提供，而异步更新则没有，例如&lt;code&gt;setTimeout&lt;/code&gt;，&lt;code&gt;setInternal&lt;/code&gt;等。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以如果我们想在&lt;code&gt;React18&lt;/code&gt; 之前的版本中也想在异步代码添加对批量更新的支持，就可以使用&lt;code&gt;React&lt;/code&gt;给我们提供的&lt;code&gt;api&lt;/code&gt;。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;import&lt;/span&gt; ReactDOM &lt;span&gt;from&lt;/span&gt; &lt;span&gt;&#x27;react-dom&#x27;&lt;/span&gt;;&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; { unstable_batchedUpdates } = ReactDOM;&lt;br/&gt;复制代码&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;使用方法如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;componentDidMount() {&lt;br/&gt;    setTimeout(()=&amp;gt;{&lt;br/&gt;        unstable_batchedUpdates(()=&amp;gt;{&lt;br/&gt;            &lt;span&gt;this&lt;/span&gt;.setState({ number:&lt;span&gt;this&lt;/span&gt;.state.number + &lt;span&gt;1&lt;/span&gt; })&lt;br/&gt;            console.log(&lt;span&gt;this&lt;/span&gt;.state.number)&lt;br/&gt;            &lt;span&gt;this&lt;/span&gt;.setState({ number:&lt;span&gt;this&lt;/span&gt;.state.number + &lt;span&gt;1&lt;/span&gt;})&lt;br/&gt;            console.log(&lt;span&gt;this&lt;/span&gt;.state.number)&lt;br/&gt;            &lt;span&gt;this&lt;/span&gt;.setState({ number:&lt;span&gt;this&lt;/span&gt;.state.number + &lt;span&gt;1&lt;/span&gt; })&lt;br/&gt;            console.log(&lt;span&gt;this&lt;/span&gt;.state.number)&lt;br/&gt;        })&lt;br/&gt;    })&lt;br/&gt;}&lt;br/&gt;复制代码&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;而在 React 18中的话，就不需要我们这样做了，它 对settimeout、promise、原生事件、react事件、外部事件处理程序进行自动批量处理。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;五：如何更快的完成diff的比较，加快进程&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;diff&lt;/code&gt;算法就是为了帮助我们找到需要更新的异同点，那么有什么办法可以让我们的&lt;code&gt;diff&lt;/code&gt;算法更快呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那就是合理的使用&lt;code&gt;key&lt;/code&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;diff&lt;/code&gt;的调用是在&lt;code&gt;reconcileChildren&lt;/code&gt;中的&lt;code&gt;reconcileChildFibers&lt;/code&gt;，当没有可以复用&lt;code&gt;current&lt;/code&gt; &lt;code&gt;fiber&lt;/code&gt;节点时，就会走&lt;code&gt;mountChildFibers&lt;/code&gt;，当有的时候就走&lt;code&gt;reconcileChildFibers&lt;/code&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;而&lt;code&gt;reconcilerChildFibers&lt;/code&gt;的函数中则会针&lt;code&gt;render&lt;/code&gt;函数返回的新的&lt;code&gt;jsx&lt;/code&gt;数据进行判断，它是否是对象，就会判断它的&lt;code&gt;newChild.$$typeof&lt;/code&gt;是否是&lt;code&gt;REACT_ELEMENT_TYPE&lt;/code&gt;，如果是就按单节点处理。如果不是继续判断是否是&lt;code&gt;REACT_PORTAL_TYPE&lt;/code&gt;或者&lt;code&gt;REACT_LAZY_TYPE&lt;/code&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;继续判断它是否为数组，或者可迭代对象。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;而在单节点处理函数&lt;code&gt;reconcileSingleElement&lt;/code&gt;中，会执行如下逻辑：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;通过 &lt;code&gt;key&lt;/code&gt;,判断上次更新的时候的 &lt;code&gt;Fiber&lt;/code&gt; 节点是否存在对应的 &lt;code&gt;DOM&lt;/code&gt; 节点。如果没有 则直接走创建流程，新生成一个 Fiber 节点，并返回&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;如果有，那么就会继续判断，&lt;code&gt;DOM&lt;/code&gt; 节点是否可以复用？&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;如果有，就将上次更新的 &lt;code&gt;Fiber&lt;/code&gt; 节点的副本作为本次新生的&lt;code&gt;Fiber&lt;/code&gt; 节点并返回&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;如果没有，那么就标记 &lt;code&gt;DOM&lt;/code&gt; 需要被删除，新生成一个 &lt;code&gt;Fiber&lt;/code&gt; 节点并返回。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;function&lt;/span&gt; &lt;span&gt;reconcileSingleElement&lt;/span&gt;&lt;span&gt;(&lt;br/&gt;    returnFiber: Fiber,&lt;br/&gt;    currentFirstChild: Fiber | null,&lt;br/&gt;    element: ReactElement&lt;br/&gt;)&lt;/span&gt;: &lt;span&gt;Fiber&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;const&lt;/span&gt; key = element.key; &lt;span&gt;//jsx 虚拟 DOM 返回的数据&lt;/span&gt;&lt;br/&gt;    let child = currentFirstChild;&lt;span&gt;//当前的fiber &lt;/span&gt;&lt;br/&gt;    &lt;br/&gt;    &lt;span&gt;// 首先判断是否存在对应DOM节点&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;while&lt;/span&gt; (child !== &lt;span&gt;null&lt;/span&gt;) {&lt;br/&gt;        &lt;span&gt;// 上一次更新存在DOM节点，接下来判断是否可复用&lt;/span&gt;&lt;br/&gt;        &lt;br/&gt;        &lt;span&gt;// 首先比较key是否相同&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (child.key === key) {&lt;br/&gt;            &lt;br/&gt;            &lt;span&gt;// key相同，接下来比较type是否相同&lt;/span&gt;&lt;br/&gt;            &lt;br/&gt;            &lt;span&gt;switch&lt;/span&gt; (child.tag) {&lt;br/&gt;                &lt;span&gt;// ...省略case&lt;/span&gt;&lt;br/&gt;                &lt;br/&gt;                &lt;span&gt;default&lt;/span&gt;: {&lt;br/&gt;                    &lt;span&gt;if&lt;/span&gt; (child.elementType === element.type) {&lt;br/&gt;                        &lt;span&gt;// type相同则表示可以复用&lt;/span&gt;&lt;br/&gt;                        &lt;span&gt;// 返回复用的fiber&lt;/span&gt;&lt;br/&gt;                        &lt;span&gt;return&lt;/span&gt; existing;&lt;br/&gt;                    }&lt;br/&gt;                    &lt;br/&gt;                    &lt;span&gt;// type不同则跳出switch&lt;/span&gt;&lt;br/&gt;                    &lt;span&gt;break&lt;/span&gt;;&lt;br/&gt;                }&lt;br/&gt;            }&lt;br/&gt;            &lt;span&gt;// 代码执行到这里代表：key相同但是type不同&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;// 将该fiber及其兄弟fiber标记为删除&lt;/span&gt;&lt;br/&gt;            deleteRemainingChildren(returnFiber, child);&lt;br/&gt;            &lt;span&gt;break&lt;/span&gt;;&lt;br/&gt;        } &lt;span&gt;else&lt;/span&gt; {&lt;br/&gt;            &lt;span&gt;// key不同，将该fiber标记为删除&lt;/span&gt;&lt;br/&gt;            deleteChild(returnFiber, child);&lt;br/&gt;        }&lt;br/&gt;        child = child.sibling;&lt;br/&gt;    }&lt;br/&gt;    &lt;br/&gt;    &lt;span&gt;// 创建新Fiber，并返回 ...省略&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;复制代码&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;从上面的代码就可以看出，&lt;code&gt;React&lt;/code&gt; 是如何判断一个 &lt;code&gt;Fiber&lt;/code&gt; 节点是否可以被复用的。&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;第一步：判断&lt;code&gt;element&lt;/code&gt;的 &lt;code&gt;key&lt;/code&gt; 和 &lt;code&gt;fiber&lt;/code&gt; 的&lt;code&gt;key&lt;/code&gt; 是否相同&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;如果不相同，就会创建新的 &lt;code&gt;Fiber&lt;/code&gt;,并返回&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;第二步：如果相同，就判断&lt;code&gt;element.type&lt;/code&gt;和&lt;code&gt;fiber&lt;/code&gt;的 &lt;code&gt;type&lt;/code&gt; 是否相同，&lt;code&gt;type&lt;/code&gt; 就是他们的类型，比如&lt;code&gt;p&lt;/code&gt;标签就是&lt;code&gt;p，div&lt;/code&gt; 标签就是&lt;code&gt;div&lt;/code&gt;.如果 &lt;code&gt;type&lt;/code&gt; 不相同，那么就会标识删除。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;如果相同，那就可以可以判断可以复用了，返回&lt;code&gt;existing&lt;/code&gt;。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;而在多节点更新的时候，&lt;code&gt;key&lt;/code&gt;的作用则更加重要，&lt;code&gt;React&lt;/code&gt; 会通过遍历新旧数据，数组和链表来通过按个判断它们的&lt;code&gt;key&lt;/code&gt;和 &lt;code&gt;type&lt;/code&gt; 来决定是否复用。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以我们需要合理的使用&lt;code&gt;key&lt;/code&gt;来加快&lt;code&gt;diff&lt;/code&gt;算法的比对和&lt;code&gt;fiber&lt;/code&gt;的复用。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那么如何合理使用&lt;code&gt;key&lt;/code&gt;呢。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其实很简单，只需要每一次设置的值和我们的数据一直就可以了。不要使用&lt;code&gt;数组&lt;/code&gt;的下标，这种&lt;code&gt;key&lt;/code&gt;和数据没有关联，我们的数据发生了更新，结果 &lt;code&gt;React&lt;/code&gt; 还指望着复用。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;还有哪些工具可以提升性能呢？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;实际的开发中还有其他的很多场景需要进行优化：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;频繁输入或者滑动滚动的防抖节流&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;针对大数据展示的虚拟列表，虚拟表格&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;针对大数据展示的时间分片 等等等等 后面再补充吧！&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;感谢大佬的文章：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;React进阶实践指南-渲染控制篇&lt;/span&gt;&lt;sup&gt;[2]&lt;/sup&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;over...&lt;/p&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>89ad0b658e86029aca6218472a536233</guid>
<title>美团图灵机器学习平台性能起飞的秘密（一）</title>
<link>https://toutiao.io/k/akfvkbe</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content js_underline_content             autoTypeSetting24psection&amp;#10;            &quot; id=&quot;js_content&quot;&gt;&lt;p data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;578&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;58&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.1546875&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsU2zk0q52HtKQjubeUEyZHBVHPgeBXgTUj0ib1Kwfosl82xO1Aw7x6gccLuuYs1dbxI7REI7OcjbGw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;总第543&lt;/span&gt;&lt;/strong&gt;&lt;strong&gt;&lt;span&gt;篇&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;2022年 第060篇&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;section data-role=&quot;outer&quot; label=&quot;Powered by 135editor.com&quot;&gt;&lt;section data-role=&quot;outer&quot; label=&quot;Powered by 135editor.com&quot;&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;127&quot;&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;127&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;p&gt;&lt;img border=&quot;0&quot; class=&quot;rich_pages wxw-img&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;103&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;103&quot; data-ratio=&quot;1&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsU2zk0q52HtKQjubeUEyZHBic5ADGrKxgSd0tibyMiasOHXjb46qFBw7PTfuWAxXzWq32lDkL05icwkMg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;750&quot; data-width=&quot;100%&quot; opacity=&quot;&quot; title=&quot;undefined&quot;/&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-brushtype=&quot;text&quot; data-style=&quot;text-align: left; font-size: 14px; color: inherit;&quot;&gt;&lt;section&gt;&lt;span&gt;美团图灵机器学习平台在长期的优化实践中，积累了一系列独特的优化方法。本文主要介绍了图灵机器学习平台在内存优化方面沉淀的优化技术，我们深入到源码层面，介绍了Spark算子的原理并提供了最佳实践。希望为读者带来一些思路上的启发。&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;导语&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;&lt;span&gt;图灵平台是美团履约平台技术部2018年开始自研的算法平台，提供模型全生命周期的一站式服务，旨在帮助算法同学脱离繁琐的工程化开发，把有限的精力聚焦于业务和算法的迭代优化中。&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;随着美团图灵机器学习平台的发展，图灵技术团队在内存优化、计算优化、磁盘IO优化三个方面沉淀了一系列性能优化技术。我们将以连载的方式为大家揭秘这些技术。本文作为该系列的开篇之作，将重点为大家介绍内存优化。&lt;/span&gt;&lt;/section&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;1. 业务背景&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;&lt;span&gt;图灵平台主要包括机器学习平台、特征平台、图灵在线服务（Online Serving）、AB实验平台四大功能，具体可参考《&lt;/span&gt;&lt;a href=&quot;https://tech.meituan.com/2020/01/23/meituan-delivery-machine-learning.html&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;一站式机器学习平台建设实践&lt;/span&gt;&lt;/a&gt;&lt;span&gt;》以及《&lt;/span&gt;&lt;a href=&quot;https://tech.meituan.com/2021/05/13/turing-os-online-serving.html&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;算法平台在线服务体系的演进与实践&lt;/span&gt;&lt;/a&gt;&lt;span&gt;》这两篇博客。其中，图灵机器学习平台的离线训练引擎是基于Spark实现的。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;随着图灵的用户增长，越来越多算法模型在图灵平台上完成迭代，优化离线训练引擎的性能和吞吐对于节约离线计算资源显得愈发重要。经过半年持续的迭代，我们积累了一系列独特的优化方法，使图灵机器学习平台的离线资源消耗下降80%，生产任务平均耗时下降63%（&lt;/span&gt;&lt;span&gt;如下图所示&lt;/span&gt;&lt;span&gt;），图灵全平台的训练任务在性能层面都得到了较为明显的提升。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;资源消耗下降：&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;504&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;140&quot; data-ratio=&quot;0.2972222222222222&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/hEx03cFgUsVqztmibAUx0Y8MwibKMSw0ympYcScw9B7rXvGWjdG0799G6ha4XUiarfxHF37j38yz0meEjicqia0FRhA/640?wx_fmt=jpeg&quot; data-w=&quot;1080&quot;/&gt;&lt;figcaption&gt;&lt;span&gt;图1 资源消耗&lt;/span&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;当前平台性能：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;下图是某位图灵用户的实验。使用100万数据训练深度模型，总计约29亿的数据调用深度模型，计算评估指标并保存到Hive，整个实验只需要35分钟。其中Spark开启DynamicAllocation，maxExecutor=400 ，单个Executor为7Core16GB。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;558&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;435&quot; data-ratio=&quot;0.7796875&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/hEx03cFgUsVp67ZmRqzWlNicuIvd9QzdAL1LnB1VVKicpIKO1tOw72wnOFK0vuWnUjJ1QN6xb99nLomO3maNAzCA/640?wx_fmt=jpeg&quot; data-w=&quot;1280&quot;/&gt;&lt;figcaption&gt;&lt;span&gt;图2 实验运行图&lt;/span&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;/section&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;2. 图灵训练引擎优化&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;&lt;span&gt;那么，图灵训练引擎的性能优化是如何做到的呢？我们的优化分为内存优化、计算优化、磁盘IO优化三个层面。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;内存优化包括列裁切、自适应Cache、算子优化。我们借鉴Spark SQL原理设计了列裁切，可以自动剔除各组件中用户实际没有使用的字段，以降低内存占用。何时对Dataset Persist和Unpersist一直是Spark代码中的取舍问题，针对用户不熟悉Persist和Unpersist时机这个问题，我们将多年的开发经验沉淀在图灵中，结合列裁切技术实现自适应Cache。在计算优化方面，我们完成了图优化、Spark源码优化、XGB源码优化。在磁盘IO优化方面，我们创新性的实现了自动化小文件保存优化，能够使用一个Action实现多级分区表小文件的合并保存。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;此外，我们实现的TFRecord表示优化技术，成功将Spark生成的TFRecord体积减少50%。因图灵平台使用的优化技巧较多，我们将分成多篇文章为大家逐一介绍这些优化技术。&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;558&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;250&quot; data-ratio=&quot;0.525&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/hEx03cFgUsVqztmibAUx0Y8MwibKMSw0ymicfpU64dx0RtSPx3icAWyKMFr0biayjJM0T7icNR5gEicgVh2FoUYF14MXw/640?wx_fmt=jpeg&quot; data-w=&quot;1280&quot;/&gt;&lt;figcaption&gt;&lt;span&gt;图3 图灵训练引擎优化&lt;/span&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;而在众多优化中，收益最高、适用性最广的技术的就是算子优化，这项技术极大提升了图灵训练引擎的吞吐量。本篇文章首先将为大家介绍内存优化中的算子优化技术。&lt;/span&gt;&lt;/section&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;3. Spark算子解读&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;&lt;span&gt;同样的业务需求，不同的算子实现会有不一样的特性。我们将多年的Spark开发技巧总结在下表中：&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;/&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;578&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;178&quot; data-ratio=&quot;0.30833333333333335&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/hEx03cFgUsVqztmibAUx0Y8MwibKMSw0ymOdQYEg68ECLrXhv0T3ocu8PuspGlS8fhVx6kZSos4j5RmasAQn1zGw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1080&quot;/&gt;&lt;figcaption&gt;&lt;span&gt;表1 Spark算子开发技巧总结&lt;/span&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;/section&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;多行输入多行输出&lt;/strong&gt;：多行数据一起进入内存处理。输出多行数据。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;多列输出&lt;/strong&gt;：特定场景下，我们希望输出多个字段。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;ol class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;SQL场景下只能输出Struct，再从Struct中SELECT各字段。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;map/flatMap/mapPartitions可以轻松输出任意个字段。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;中间结果复用&lt;/strong&gt;：&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;ol class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;SQL场景下：SQL场景下只能先SELECT一次得到中间变量，再SELECT中间变量完成后续处理。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;map/flatMap/mapPartitions可将计算逻辑封装在函数内。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;重量级对象复用&lt;/strong&gt;：&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;ol class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;Executor级别，例如可以通过广播变量实现，或者通过静态类成员变量的“懒汉”模式实现。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;Partition级别，mapPartitions时，先创建对象，后迭代数据，这个对象可在Partition内复用。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;/ol&gt;&lt;p&gt;&lt;span&gt;通过对比我们发现，mapPartitions是各类算子中最为灵活——可以灵活实现输入M条输出N条数据，可以输出任意数量的字段，还可以实现重量级对象在Partition或Executor级别上的复用。mapPartitions因其强大的功能和灵活可定制性，在图灵训练引擎的开发中有着举足轻重的地位（&lt;/span&gt;&lt;span&gt;例如按Batch调用深度模型、上下采样、Partition统计等组件，都是基于该算子实现&lt;/span&gt;&lt;span&gt;）。但是mapPartitions也有一个不足之处。&lt;/span&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;4. mapPartitions之殇&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;&lt;span&gt;相信大部分读者都曾经写过这样的代码，创建一个重量级对象在Partition内完成复用，而不是像map算子那样每处理一行数据创建一个对象。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;mapPartitions模板，重量级对象复用&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;section&gt;&lt;span&gt;dataset.mapPartitions((MapPartitionsFunction&amp;lt;Row, Row&amp;gt;) iterator -&amp;gt; {&lt;br/&gt;  HeavyObject obj = &lt;span&gt;new&lt;/span&gt; HeavyObject();&lt;br/&gt;  List&amp;lt;Row&amp;gt; list = &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;&amp;gt;();&lt;br/&gt;  &lt;span&gt;// 遍历处理数据&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;while&lt;/span&gt; (iterator.hasNext()) {&lt;br/&gt;    Row row = iterator.next();&lt;br/&gt;    &lt;span&gt;// 拼凑batch或逐条处理&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;// ....&lt;/span&gt;&lt;br/&gt;    obj.process(row)&lt;br/&gt;    &lt;span&gt;// batch add或逐条add&lt;/span&gt;&lt;br/&gt;    list.add(...);&lt;br/&gt;  }&lt;br/&gt;  &lt;span&gt;// 返回list的迭代器&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; list.iterator();&lt;br/&gt;}, RowEncoder.apply(schema));&lt;/span&gt;&lt;/section&gt;&lt;/pre&gt;&lt;p&gt;&lt;span&gt;熟悉mapPartitions的同学都知道，这段代码完成了重量级对象的复用，相比map算子好像已经减少了大量GC，但这样仍旧非常容易溢出。那么：&lt;/span&gt;&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;为什么mapPartitions算子容易溢出呢？&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;当多个mapPartitions算子串联的时候又是如何GC的呢？&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;5. Spark Pipeline中的mapPartitions&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;&lt;span&gt;在进行下一部分讲解之前，我们先简要介绍一下Spark的懒执行机制。Spark的算子分为Action和Transformation两大类。RDD的依赖关系构成了数据处理的有向无环图DAG。只有当Action算子出现时，才会执行Action算子与前面一系列Transformation算子构成的DAG。Spark还会根据Shuffle将DAG划分成多个Stage进行计算，Shuffle过程需要跨节点交换数据，会产生大量的磁盘IO和网络IO。而每个Stage内的计算则构成了Pipeline，在内存中进行。&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;463&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;479&quot; data-ratio=&quot;1.03515625&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/hEx03cFgUsVp67ZmRqzWlNicuIvd9QzdA94CUtyWp9pj9qqBZBTl0gg3PIkG93DD17oBgl1RQVS9dzH5Kmz5mVQ/640?wx_fmt=jpeg&quot; data-w=&quot;1280&quot;/&gt;&lt;figcaption&gt;&lt;span&gt;图4 多列词典映射实验图&lt;/span&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;我们以上图为例，该同学实验中的多列词典映射组件，对大量的特征做了词典映射计算。多列词典映射组件包含两个部分，计算词典和应用词典。&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;section&gt;&lt;blockquote&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;计算词典&lt;/strong&gt;：通过去重和collect生成了各个特征的词典，每个特征词典的计算都伴随着1次Shuffle和1次Action。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;应用词典&lt;/strong&gt;&lt;span&gt;：&lt;/span&gt;&lt;span&gt;将特征根据词典映射成唯一ID，不存在Shuffle。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;与Spark StringIndexer的Pipeline优化相似，当进行多个特征的词典映射计算时，图灵机器学习平台会将计算词典的Action单独执行，而多个应用词典则一起执行。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;词典生成后，所有应用词典的计算逻辑（&lt;/span&gt;&lt;span&gt;mapPartitions Transformation&lt;/span&gt;&lt;span&gt;）不存在Shuffle，因此被划分到同一个Stage中，所有mapPartitions算子将串联成一条非常长的Pipeline。最终由后面的Action算子触发提交Job，执行该Pipeline。Stage的划分可参考下图：&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;578&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;144&quot; data-ratio=&quot;0.25&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/hEx03cFgUsVqztmibAUx0Y8MwibKMSw0ym4Wu3HCq8UdghRH9VA58vA0gGleMTnjCGR7DHxANLEya5WXMRiaKv1eQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1280&quot;/&gt;&lt;figcaption&gt;&lt;span&gt;图5 应用多个词典Stage&lt;/span&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;应用词典的实现中，每个mapPartitionsFunction中都新建了一个ArrayList充当Buffer来存储计算后的数据，最终返回ArrayList.iterator()。执行时，每次应用词典都会将整个Partition的数据拉入ArrayList当中。上述词典映射串联构成Pipeline的时候，内存中会有多少数据呢？&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;带着这个疑问，让我们走进Spark的源代码，看看mapPartitionsFunction是如何构成Spark Pipeline的。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Spark的一个Stage中会划分为多个Task，除了union和coalesce的场景，1个Partition对应1个Task。Task的执行通过抽象方法runTask()完成，以实现类ResultTask为例，最后runTask()方法调用了rdd.iterator()。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;ResultTask.scala&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;section&gt;&lt;span&gt;&lt;span&gt;override&lt;/span&gt; &lt;span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;runTask&lt;/span&gt;&lt;/span&gt;(context: &lt;span&gt;TaskContext&lt;/span&gt;): &lt;span&gt;U&lt;/span&gt; = {&lt;br/&gt;  ...... &lt;span&gt;// 源码缩略不进行展示：初始化一些需要的对象&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;val&lt;/span&gt; (rdd, func) = ser.deserialize[(&lt;span&gt;RDD&lt;/span&gt;[&lt;span&gt;T&lt;/span&gt;], (&lt;span&gt;TaskContext&lt;/span&gt;, &lt;span&gt;Iterator&lt;/span&gt;[&lt;span&gt;T&lt;/span&gt;]) =&amp;gt; &lt;span&gt;U&lt;/span&gt;)](&lt;br/&gt;  &lt;span&gt;ByteBuffer&lt;/span&gt;.wrap(taskBinary.value), &lt;span&gt;Thread&lt;/span&gt;.currentThread.getContextClassLoader)&lt;br/&gt;    _executorDeserializeTime = &lt;span&gt;System&lt;/span&gt;.currentTimeMillis() - deserializeStartTime&lt;br/&gt;    _executorDeserializeCpuTime = &lt;span&gt;if&lt;/span&gt; (threadMXBean.isCurrentThreadCpuTimeSupported) {&lt;br/&gt;    threadMXBean.getCurrentThreadCpuTime - deserializeStartCpuTime&lt;br/&gt;  } &lt;span&gt;else&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;L&lt;br/&gt;  &lt;span&gt;// 这里的func()调用了rdd.iterator()&lt;/span&gt;&lt;br/&gt;  func(context, rdd.iterator(partition, context))&lt;br/&gt;}&lt;/span&gt;&lt;/section&gt;&lt;/pre&gt;&lt;p&gt;&lt;span&gt;而RDD的iterator方法的源码如下，其调用逻辑最终都会进入computeOrReadCheckpoint方法，若没有CheckPoint则进入compute方法执行计算。以MapPartitionsRDD类为例，获取父RDD的Iterator并传入自己的计算逻辑函数f中。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;RDD.scala&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;section&gt;&lt;span&gt;&lt;span&gt;final&lt;/span&gt; &lt;span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;iterator&lt;/span&gt;&lt;/span&gt;(split: &lt;span&gt;Partition&lt;/span&gt;, context: &lt;span&gt;TaskContext&lt;/span&gt;): &lt;span&gt;Iterator&lt;/span&gt;[&lt;span&gt;T&lt;/span&gt;] = {&lt;br/&gt;  &lt;span&gt;if&lt;/span&gt; (storageLevel != &lt;span&gt;StorageLevel&lt;/span&gt;.&lt;span&gt;NONE&lt;/span&gt;) {&lt;br/&gt;    getOrCompute(split, context) &lt;span&gt;// 内部依然调用下面的computeOrReadCheckpoint(partition, context)&lt;/span&gt;&lt;br/&gt;  } &lt;span&gt;else&lt;/span&gt; {&lt;br/&gt;    computeOrReadCheckpoint(split, context)&lt;br/&gt;  }&lt;br/&gt;}&lt;br/&gt;&lt;span&gt;// StorageLevel不为NONE时调用的方法&lt;/span&gt;&lt;br/&gt;&lt;span&gt;private&lt;/span&gt;[spark] &lt;span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;getOrCompute&lt;/span&gt;&lt;/span&gt;(partition: &lt;span&gt;Partition&lt;/span&gt;, context: &lt;span&gt;TaskContext&lt;/span&gt;): &lt;span&gt;Iterator&lt;/span&gt;[&lt;span&gt;T&lt;/span&gt;] = {&lt;br/&gt;  ...... &lt;span&gt;// 初始化相关变量&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;SparkEnv&lt;/span&gt;.get.blockManager.getOrElseUpdate(blockId, storageLevel, elementClassTag, () =&amp;gt; {&lt;br/&gt;    readCachedBlock = &lt;span&gt;false&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;// 内部依然调用iterator()中的computeOrReadCheckpoint方法&lt;/span&gt;&lt;br/&gt;    computeOrReadCheckpoint(partition, context)&lt;br/&gt;  }) &lt;span&gt;match&lt;/span&gt; {&lt;br/&gt;    ...... &lt;span&gt;// 源码缩略不进行展示：按case包装为对应iterator返回&lt;/span&gt;&lt;br/&gt;  }&lt;br/&gt;}&lt;br/&gt;&lt;span&gt;// 默认调用该方法&lt;/span&gt;&lt;br/&gt;&lt;span&gt;private&lt;/span&gt;[spark] &lt;span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;computeOrReadCheckpoint&lt;/span&gt;&lt;/span&gt;(split: &lt;span&gt;Partition&lt;/span&gt;, context: &lt;span&gt;TaskContext&lt;/span&gt;): &lt;span&gt;Iterator&lt;/span&gt;[&lt;span&gt;T&lt;/span&gt;] = {&lt;br/&gt;  &lt;span&gt;if&lt;/span&gt; (isCheckpointedAndMaterialized) {&lt;br/&gt;    &lt;span&gt;// 有checkpoint或materialized则返回依赖关系中第一个父RDD的iterator&lt;/span&gt;&lt;br/&gt;    firstParent[&lt;span&gt;T&lt;/span&gt;].iterator(split, context)&lt;br/&gt;  } &lt;span&gt;else&lt;/span&gt; {&lt;br/&gt;    &lt;span&gt;// 调用当前RDD的compute方法计算，内部的计算逻辑包含了用户编写的代码&lt;/span&gt;&lt;br/&gt;    compute(split, context)&lt;br/&gt;  }&lt;br/&gt;}&lt;/span&gt;&lt;/section&gt;&lt;/pre&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;MapPartitionsRDD.scala&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;section&gt;&lt;span&gt;&lt;span&gt;override&lt;/span&gt; &lt;span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;compute&lt;/span&gt;&lt;/span&gt;(split: &lt;span&gt;Partition&lt;/span&gt;, context: &lt;span&gt;TaskContext&lt;/span&gt;): &lt;span&gt;Iterator&lt;/span&gt;[&lt;span&gt;U&lt;/span&gt;] =&lt;br/&gt;  &lt;span&gt;// 用户编写的代码逻辑被封装为函数‘f’，在此接受参数后执行&lt;/span&gt;&lt;br/&gt;  f(context, split.index, firstParent[&lt;span&gt;T&lt;/span&gt;].iterator(split, context))&lt;/span&gt;&lt;/section&gt;&lt;/pre&gt;&lt;p&gt;&lt;span&gt;为了更清晰的解释这个问题，以下述代码为例。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;Example&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;section&gt;&lt;span&gt;&lt;span&gt;val&lt;/span&gt; rddA = initRDD(); &lt;span&gt;// 获取一个RDD&lt;/span&gt;&lt;br/&gt;&lt;span&gt;//funcA、funcB、funcC均为用户的代码逻辑&lt;/span&gt;&lt;br/&gt;&lt;span&gt;val&lt;/span&gt; rddB = rddA.mapPartitions(funcA)&lt;br/&gt;&lt;span&gt;val&lt;/span&gt; rddC = rddB.mapPartitions(funcB)&lt;br/&gt;&lt;span&gt;val&lt;/span&gt; rddD = rddC.mapPartitions(funcC)&lt;br/&gt;rddD.count()&lt;/span&gt;&lt;/section&gt;&lt;/pre&gt;&lt;p&gt;&lt;span&gt;在遇到count算子时会进行RDD回溯，最终的形成计算链路为fCount(funcC(funcB(funcA(rddA.iterator=&amp;gt;iterator))))，由此构成了Pipeline，以多个mapPartitions + ArrayList.iterator()串联的代码展开则如下所示：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;Example&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;section&gt;&lt;span&gt;iteratorA =&amp;gt; &lt;span&gt;// iteratorA：初始RDD对应Partition的输出迭代器&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;var&lt;/span&gt; list = &lt;span&gt;List&lt;/span&gt;[&lt;span&gt;Row&lt;/span&gt;]()&lt;br/&gt;  &lt;span&gt;while&lt;/span&gt; (iteratorA.hasNext) {&lt;br/&gt;    list = process(iteratorA.next()) +: list &lt;span&gt;// funcA：每条拉至内存处理后加入resultList&lt;/span&gt;&lt;br/&gt;  }&lt;br/&gt;  &lt;span&gt;val&lt;/span&gt; iteratorB = list.iterator&lt;br/&gt;iteratorB =&amp;gt; &lt;span&gt;// iteratorB：rddA对应Partition的输出迭代器&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;var&lt;/span&gt; list = &lt;span&gt;List&lt;/span&gt;[&lt;span&gt;Row&lt;/span&gt;]()&lt;br/&gt;  &lt;span&gt;while&lt;/span&gt; (iteratorB.hasNext) {&lt;br/&gt;    list = process(iteratorB.next()) +: list &lt;span&gt;// funcB：每条数据拉至内存处理后加入resultList&lt;/span&gt;&lt;br/&gt;  }&lt;br/&gt;  &lt;span&gt;val&lt;/span&gt; iteratorC = list.iterator&lt;br/&gt;iteratorC =&amp;gt;  &lt;span&gt;// iteratorC：rddB对应Partition的输出迭代器&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;var&lt;/span&gt; list = &lt;span&gt;List&lt;/span&gt;[&lt;span&gt;Row&lt;/span&gt;]()&lt;br/&gt;  &lt;span&gt;while&lt;/span&gt; (iteratorC.hasNext) {&lt;br/&gt;    list = process(iteratorC.next()) +: list &lt;span&gt;// funcC：每条数据拉至内存处理后加入resultList&lt;/span&gt;&lt;br/&gt;  }&lt;br/&gt;  &lt;span&gt;val&lt;/span&gt; iteratorD = list.iterator&lt;br/&gt;iteratorD =&amp;gt; count()&lt;/span&gt;&lt;/section&gt;&lt;/pre&gt;&lt;p&gt;&lt;span&gt;回看mapPartitions模板，作为Buffer的ArrayList是每个mapPartitionsFunction的局部变量，ArrayList.iterator()引用了这个Buffer，结合上面的源码我们知道，子RDD会引用父RDD的Iterator。结合该同学的实验分析，每个RDD中的计算都形成了一个Array Buffer，在RDD的function调用链路中Array Buffer2依赖Array Buffer1.iterator()，Array Buffer3依赖Array Buffer2.iterator()。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;以此类推，在计算RDD-3时，RDD-1的func1已经出栈，且RDD-3不依赖Array Buffer1.iterator()，因此局部变量Array Buffer1可以被GC。由此可见在Stage-应用多个词典的计算过程中，内存占用的峰值达到了两个Array Buffer，也就是两倍partitionSize。&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;578&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;124&quot; data-ratio=&quot;0.21484375&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/hEx03cFgUsVqztmibAUx0Y8MwibKMSw0ymPH6jyerkpRRzt1qsjibnBV2Qrh4HiaiaQopLb0mw96v2P91qJKjk1ymqQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1280&quot;/&gt;&lt;figcaption&gt;&lt;span&gt;图6 应用多个词典内存占用&lt;/span&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;为了完全证实这个想法，又进行了实际的测试验证：初始化1个单Partition的RDD，并且该Partition的数据量为300万，占用内存大约为180M。接着将这些数据利用多个mapPartitions + ArrayList.iterator()串联，每输入1个对象，生成1个新对象放入Buffer中，最后用rdd.count()触发Action，整个执行流程中只包含一个Stage。运行的JVM堆内存设置为512M，以此来观察堆内存中的实例对象及其GC活动是否符合只有两个Buffer的预期。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;观察结果如下，每一行数据以一个GenericRowWithSchema实例存在并加入ArrayList中，其计算过程中最大的峰值正好为600万即两倍的分区数据量。GC以周期性的活动去销毁上上个mapPartitions中的无用Buffer，并且堆内存保持在了最大约两倍的数据占用量（&lt;/span&gt;&lt;span&gt;约360M&lt;/span&gt;&lt;span&gt;），因此验证了推断。以下是测试中的GenericRowWithSchema对象实例计数图、内存实时占用以及GC活动统计图。&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;578&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;381&quot; data-ratio=&quot;0.6578125&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/hEx03cFgUsVp67ZmRqzWlNicuIvd9QzdAicQNMBVxMAgBx9macZmxx3gnooFC1cwez09x9NDic9yjnfDe8rl0RtrQ/640?wx_fmt=jpeg&quot; data-w=&quot;1280&quot;/&gt;&lt;figcaption&gt;&lt;span&gt;图7 对象统计&lt;/span&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;/&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;578&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;259&quot; data-ratio=&quot;0.44722222222222224&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/hEx03cFgUsVp67ZmRqzWlNicuIvd9QzdAfIF3BXMuaia9wkrvOibVUefjIn5PY88uHQdlicb5GIgS2N4ibZlOYk5nvg/640?wx_fmt=jpeg&quot; data-w=&quot;1080&quot;/&gt;&lt;figcaption&gt;&lt;span&gt;图8 内存统计&lt;/span&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;经过测试验证，mapPartitions + ArrayList.iterator()导致了两倍partitionSize的内存占用。&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;使用mapPartitions + ArrayList.iterator()仅仅只是造成OOM或GC压力大吗？偏偏不巧，在Spark的内存管理中另有一番天地，会牵扯到更多的性能问题。&lt;/span&gt;&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;Spark内存管理机制&lt;/span&gt;&lt;/h3&gt;&lt;section&gt;&lt;span&gt;Spark从2.0开始使用的是统一内存管理机制，主要分为四大区域，System Reserved、User Memory、Storage Memory和Execution Memory。System Reserved是为系统预留使用的内存，User Memory是用户定义的数据结构和Spark的元数据。存储内存Storage Memory与执行内存Execution Memory在运行期间会共享一块内存区域，默认有由spark.storage.storageFraction参数控制。Spark使用动态占用机制来管理这两块内存。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;/&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;243&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;381&quot; data-ratio=&quot;1.56875&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/hEx03cFgUsVqztmibAUx0Y8MwibKMSw0ym4siaHnic6KbFuiaSjszc9xR1fthaaBEmfNjYNuiaFAZFKpVfeic1e0pZmXA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1280&quot;/&gt;&lt;figcaption&gt;&lt;span&gt;图9 Spark内存逻辑模型&lt;/span&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;Storage和Execution的动态占用机制&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;当Storage或Execution的内存不足、而对方的内存空余时，可以占用对方的内存空间。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;Storage占用Execution时，如果Execution需要更多内存，则会将Storage占用的内存淘汰（&lt;/span&gt;&lt;span&gt;根据RDD的StorageLevel决定是溢写到磁盘还是直接删除&lt;/span&gt;&lt;span&gt;），归还借用的内存空间。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;Execution占用Storage时，如果Storage需要更多内存，则直接发生淘汰（&lt;/span&gt;&lt;span&gt;Execution的逻辑复杂，归还内存的难度非常高&lt;/span&gt;&lt;span&gt;）。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;从Storage中淘汰掉的RDD Cache会在RDD重新使用时再次Cache。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;section&gt;&lt;span&gt;在涉及到mapPartitions + ArrayList.iterator()的执行过程中，由于大量的内存占用，导致Execution Memory不足，借用Storage Memory，并且借用后仍存在内存不足情况时，Storage Memory中的已缓存的Block会进行淘汰机制，根据其存储级别进行落盘或直接删除，这会导致缓存数据多次的IO操作与重复计算，极大的降低了数据处理的效率。&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;310&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;401&quot; data-ratio=&quot;1.29296875&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/hEx03cFgUsVqztmibAUx0Y8MwibKMSw0ymehF4zvcDia9j8OTanLKpfibiaw7LlXmNPFJayFkOJZdJfRKiaGTEicxj5Zw/640?wx_fmt=jpeg&quot; data-w=&quot;1280&quot;/&gt;&lt;figcaption&gt;&lt;span&gt;图10 淘汰机制&lt;/span&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;&lt;span&gt;让我们小结一下mapPartitions + ArrayList.iterator()的实现方式：&lt;/span&gt;&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;Spark通过mapPartitionsFunction嵌套实现Pipeline，例如fCount(funcC(funcB(funcA)))，func中的Buffer是方法中的局部变量。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;在mapPartitionsFunction中使用不限制长度的Buffer，会导致partitionSize两倍的数据拉入内存。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;可能触发Spark内存管理的淘汰机制，导致缓存数据多次的IO操作与重复计算。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;6. 最佳实践&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;&lt;span&gt;以多输入多输出为例，假设我们需要处理一批单个分区数据量达到千万级别的数据集，以单个分区中每5行数据为一批次，每批次随机输出2行数据，那么在mapPartitions基础上，可以这样写：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;BatchIteratorDemo：mapPartitions处理多输入-&amp;gt;多输出——以单分区每5行数据为一批次，每批次随机输出2行数据的Demo&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;section&gt;&lt;span&gt;Dataset&amp;lt;Row&amp;gt; dataset = initDataset();&lt;span&gt;// 初始化数据集&lt;/span&gt;&lt;br/&gt;&lt;span&gt;// mapPartitions中调用BatchIterator完成计算逻辑&lt;/span&gt;&lt;br/&gt;Dataset&amp;lt;Row&amp;gt; result = dataset.mapPartitions((MapPartitionsFunction&amp;lt;Row, Row&amp;gt;) inputIterator -&amp;gt; &lt;span&gt;new&lt;/span&gt; Iterator&amp;lt;Row&amp;gt;() {&lt;br/&gt;  &lt;span&gt;// 一批处理的数据行数&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; INPUT_BATCH_PROCESS_SIZE = &lt;span&gt;5&lt;/span&gt;;&lt;br/&gt;  &lt;span&gt;// 当前批次处理的数据集&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;private&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; List&amp;lt;Row&amp;gt; batchRows = &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;&amp;gt;(INPUT_BATCH_PROCESS_SIZE);&lt;br/&gt;  &lt;span&gt;// 当前批次输出iterator&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;private&lt;/span&gt; Iterator&amp;lt;Row&amp;gt; batchResult = Collections.emptyIterator();&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; &lt;span&gt;hasNext&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;// 本轮结果已全部消费，进入下一批次batch&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (!batchResult.hasNext()) {&lt;br/&gt;      batchRows.clear();&lt;br/&gt;      &lt;span&gt;int&lt;/span&gt; count = &lt;span&gt;0&lt;/span&gt;;&lt;br/&gt;      &lt;span&gt;// 按一个 batch 5条数据加入集合&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;while&lt;/span&gt; (count++ &amp;lt; INPUT_BATCH_PROCESS_SIZE &amp;amp;&amp;amp; inputIterator.hasNext()) {&lt;br/&gt;        batchRows.add(inputIterator.next());&lt;br/&gt;      }&lt;br/&gt;      &lt;span&gt;// 上游数据全部消费&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;if&lt;/span&gt; (batchRows.size() == &lt;span&gt;0&lt;/span&gt;) {&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;;&lt;br/&gt;      }&lt;br/&gt;      &lt;span&gt;// 随机获取2条数据&lt;/span&gt;&lt;br/&gt;      batchResult = processBatch(batchRows);&lt;span&gt;// 随机抽取2条数据创建新对象返回&lt;/span&gt;&lt;br/&gt;    }&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;;&lt;br/&gt;  }&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; Row &lt;span&gt;next&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;      &lt;span&gt;return&lt;/span&gt; batchResult.next();&lt;span&gt;// 消费当前批次的结果&lt;/span&gt;&lt;br/&gt;    }&lt;br/&gt;}, RowEncoder.apply(dataset.schema()));&lt;/span&gt;&lt;/section&gt;&lt;/pre&gt;&lt;p&gt;&lt;span&gt;当该方式应用到fCount(funcC(funcB(funcA(rddA.iterator=&amp;gt;iterator))))构成的Pipeline时，以多个mapPartitions + ArrayList.iterator()串联的代码展开则如下所示：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;Example&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;section&gt;&lt;span&gt;iteratorA =&amp;gt; iteratorB =  &lt;span&gt;// iteratorA：初始RDD对应Partition的输出迭代器&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;new&lt;/span&gt; &lt;span&gt;Iterator&lt;/span&gt;[&lt;span&gt;Row&lt;/span&gt;] {&lt;br/&gt;    &lt;span&gt;override&lt;/span&gt; &lt;span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;hasNext&lt;/span&gt;&lt;/span&gt;: &lt;span&gt;Boolean&lt;/span&gt; = {&lt;br/&gt;      processBatch(iteratorA) &lt;span&gt;// 只处理一个batch的数据&lt;/span&gt;&lt;br/&gt;    }&lt;br/&gt;    &lt;span&gt;override&lt;/span&gt; &lt;span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;next&lt;/span&gt;&lt;/span&gt;(): &lt;span&gt;Row&lt;/span&gt; = nextInBatch() &lt;span&gt;// 获取当前batch的下个输出&lt;/span&gt;&lt;br/&gt;  }&lt;br/&gt;iteratorB =&amp;gt; iteratorC =  &lt;span&gt;// iteratorB：rddA对应Partition的结果迭代器&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;new&lt;/span&gt; &lt;span&gt;Iterator&lt;/span&gt;[&lt;span&gt;Row&lt;/span&gt;] {&lt;br/&gt;    &lt;span&gt;override&lt;/span&gt; &lt;span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;hasNext&lt;/span&gt;&lt;/span&gt;: &lt;span&gt;Boolean&lt;/span&gt; = {&lt;br/&gt;      processBatch(iteratorB) &lt;span&gt;// 只处理一个batch的数据&lt;/span&gt;&lt;br/&gt;    }&lt;br/&gt;    &lt;span&gt;override&lt;/span&gt; &lt;span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;next&lt;/span&gt;&lt;/span&gt;(): &lt;span&gt;Row&lt;/span&gt; = nextInBatch() &lt;span&gt;// 获取当前batch的下个输出&lt;/span&gt;&lt;br/&gt;  }&lt;br/&gt;iteratorC =&amp;gt; iteratorD =  &lt;span&gt;// iteratorC：rddB对应Partition的结果迭代器&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;new&lt;/span&gt; &lt;span&gt;Iterator&lt;/span&gt;[&lt;span&gt;Row&lt;/span&gt;] {&lt;br/&gt;    &lt;span&gt;override&lt;/span&gt; &lt;span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;hasNext&lt;/span&gt;&lt;/span&gt;: &lt;span&gt;Boolean&lt;/span&gt; = {&lt;br/&gt;      processBatch(iteratorC) &lt;span&gt;// 只处理一个batch的数据&lt;/span&gt;&lt;br/&gt;    }&lt;br/&gt;    &lt;span&gt;override&lt;/span&gt; &lt;span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;next&lt;/span&gt;&lt;/span&gt;(): &lt;span&gt;Row&lt;/span&gt; = nextInBatch() &lt;span&gt;// 获取当前batch的下个输出&lt;/span&gt;&lt;br/&gt;  }&lt;br/&gt;iteratorD =&amp;gt; count()&lt;/span&gt;&lt;/section&gt;&lt;/pre&gt;&lt;section&gt;&lt;span&gt;我们可以看到，多输入多输出Demo以inputBatch=5、outputBatch=2作为消费单位，内存占用只有Batch=7（inputBatch + outputBatch），每次处理完一个批次，直到当前批次产生的2条数据全部被下一个RDD Iterator消费完之后，才会继续尝试从上一个RDD Iterator读取下一个批次进入内存计算，不需要为了返回分区Iterator而直接消费整个分区数据。将随机抽取数据的逻辑串联处理，其Stage将如下图所示，每个Buffer仅为一个Batch，内存消耗几乎可以忽略不计。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;578&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;124&quot; data-ratio=&quot;0.21484375&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/hEx03cFgUsVqztmibAUx0Y8MwibKMSw0ymgqe213lv6iaWYibAm0swBOY8dC9RDYP6bvict9bZ35MnNzrnww3AcsYtw/640?wx_fmt=jpeg&quot; data-w=&quot;1280&quot;/&gt;&lt;figcaption&gt;&lt;span&gt;图11 Demo Stage&lt;/span&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;最终的数据处理效果对比如下图：&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;578&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;385&quot; data-ratio=&quot;0.66640625&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/hEx03cFgUsVqztmibAUx0Y8MwibKMSw0ymNMF3Lw4Gu3micV6uic28D8qezIdJZaf8DBoxYXqySFt8MTibkibO17wKQA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1280&quot;/&gt;&lt;figcaption&gt;&lt;span&gt;图12 数据处理效果对比&lt;/span&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;/section&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;7. 总结&lt;/span&gt;&lt;/h2&gt;&lt;section&gt;&lt;span&gt;本文作为《图灵机器学习平台性能起飞的秘密》系列的第一篇，主要讲述了内存优化中的算子优化技巧，深入分析了mapPartitions算子的原理，并提供了mapPartitions算子的最佳实践。图灵机器学习平台基于此方案进一步开发了BufferIterator框架，能够灵活应对输入M条数据输出N条数据的场景，极大提升了图灵的吞吐量。后续我们将继续为大家介绍更多的优化技巧，敬请期待。&lt;/span&gt;&lt;/section&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;8. 作者简介&lt;/span&gt;&lt;/h2&gt;&lt;section&gt;&lt;span&gt;琦帆、立煌、兆军等，均来自美团到家事业群/履约平台技术部。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;----------  END  ----------&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong/&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;也许你还想看&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;  | &lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MjM5NjQ5MTI5OA==&amp;amp;mid=2651751331&amp;amp;idx=1&amp;amp;sn=d917732980c4b7e91eb79e050edf5bd7&amp;amp;chksm=bd125aee8a65d3f84ed5400749ac0fd296dad70eaba658f81b8bcfda3702bc05dce1c61c3a7f&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;一站式机器学习平台建设实践&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;/&gt;&lt;/strong&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MjM5NjQ5MTI5OA==&amp;amp;mid=2651751331&amp;amp;idx=1&amp;amp;sn=d917732980c4b7e91eb79e050edf5bd7&amp;amp;chksm=bd125aee8a65d3f84ed5400749ac0fd296dad70eaba658f81b8bcfda3702bc05dce1c61c3a7f&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;一站式机器学习平台建设实践&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;一站式机器学习平台建设实践&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;  |&lt;/strong&gt;&lt;/span&gt; &lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MjM5NjQ5MTI5OA==&amp;amp;mid=2651762169&amp;amp;idx=1&amp;amp;sn=4f28a8fac47ab2b28265dca489cff695&amp;amp;chksm=bd1274b48a65fda25011247807430d7451b9a3461956a4b8eade2db183a873d4b4fbe535ce99&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;算法平台在线服务体系的演进与实践&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;算法平台在线服务体系的演进与实践&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;  |&lt;/strong&gt; &lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MjM5NjQ5MTI5OA==&amp;amp;mid=2651749742&amp;amp;idx=3&amp;amp;sn=8075733b3adf3050645f526b033089a5&amp;amp;chksm=bd12a4238a652d35482d27a4fa283661fe557213f2cfdbba148f9a3b1733810ac547904cb21e&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;机器学习在美团配送系统的实践：用技术还原真实世界&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;机器学习在美团配送系统的实践：用技术还原真实世界&lt;/a&gt;&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;阅读更多&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MjM5NjQ5MTI5OA==&amp;amp;mid=2651765958&amp;amp;idx=1&amp;amp;sn=8201546812e5a95a2bee9dffc6d12f00&amp;amp;chksm=bd12658b8a65ec9de2f5be1e96796dfb3c8f1a374d4b7bd91266072f557caf8118d4ddb72b07&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;前‍端&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; tab=&quot;outerlink&quot; data-linktype=&quot;2&quot;&gt;前端&lt;/a&gt;&lt;span&gt;&lt;strong&gt; |&lt;/strong&gt;&lt;/span&gt;&lt;a target=&quot;_blank&quot; href=&quot;https://t.1yb.co/jo7v&quot; textvalue=&quot; 安全&quot; tab=&quot;outerlink&quot; data-linktype=&quot;2&quot;&gt;&lt;strong&gt; &lt;/strong&gt; &lt;/a&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MjM5NjQ5MTI5OA==&amp;amp;mid=2651765981&amp;amp;idx=1&amp;amp;sn=c2dd86f15dee2cbbc89e27677d985060&amp;amp;chksm=bd1265908a65ec86d4d08f7600d1518b61c90f6453074f9b308c96861c045712280a73751c73&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;算‍法&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; tab=&quot;outerlink&quot; data-linktype=&quot;2&quot;&gt;算法&lt;/a&gt;&lt;span&gt;&lt;strong&gt; |&lt;/strong&gt; &lt;/span&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MjM5NjQ5MTI5OA==&amp;amp;mid=2651765982&amp;amp;idx=1&amp;amp;sn=231b41f653ac7959f3e3b8213dcec2b0&amp;amp;chksm=bd1265938a65ec85630c546169444d56377bc2f11401d251da7ca50e5d07e353aa01580c7216&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;后‍端&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; tab=&quot;outerlink&quot; data-linktype=&quot;2&quot;&gt;后端&lt;/a&gt;&lt;span&gt;&lt;strong&gt; | &lt;/strong&gt;&lt;/span&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MjM5NjQ5MTI5OA==&amp;amp;mid=2651765964&amp;amp;idx=1&amp;amp;sn=ab6d8db147234fe57f27dd46eec40fef&amp;amp;chksm=bd1265818a65ec9749246dd1a2eb3bf7798772cc4d5b4283b15eae2f80bc6db63a1471a9e61e&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;数‍据&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; tab=&quot;outerlink&quot; data-linktype=&quot;2&quot;&gt;数据&lt;/a&gt;&lt;/p&gt;&lt;section&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MjM5NjQ5MTI5OA==&amp;amp;mid=2651765965&amp;amp;idx=1&amp;amp;sn=37e0c56c8b080146ce5249243bfd84d8&amp;amp;chksm=bd1265808a65ec96d3a2b2c87c6e27c910d49cb6b149970fb2db8bf88045a0a85fed2e6a0b84&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;安‍全&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; tab=&quot;outerlink&quot; data-linktype=&quot;2&quot;&gt;安全&lt;/a&gt;&lt;span&gt;&lt;strong&gt; | &lt;/strong&gt;&lt;/span&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MjM5NjQ5MTI5OA==&amp;amp;mid=2651765972&amp;amp;idx=1&amp;amp;sn=afe02ec92762c1ce18740d03324c4ac3&amp;amp;chksm=bd1265998a65ec8f10d5f58d0f3681ddfc5325137218e568e1cda3a50e427749edb5c6a7dcf5&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;And‍roid&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; tab=&quot;outerlink&quot; data-linktype=&quot;2&quot;&gt;Android&lt;/a&gt;&lt;span&gt;&lt;strong&gt; |&lt;/strong&gt; &lt;/span&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MjM5NjQ5MTI5OA==&amp;amp;mid=2651765973&amp;amp;idx=1&amp;amp;sn=32a23bf1d278dda0398f993ab60a697e&amp;amp;chksm=bd1265988a65ec8e630ef4d24b4946ab6bd7e66702c1d712481cf3c471468a059c470a14c30d&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;iO‍S&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; tab=&quot;outerlink&quot; data-linktype=&quot;2&quot;&gt;iOS&lt;/a&gt;&lt;span&gt; &lt;strong&gt; |&lt;/strong&gt; &lt;/span&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MjM5NjQ5MTI5OA==&amp;amp;mid=2651765963&amp;amp;idx=1&amp;amp;sn=a3de9ef267d07d94118c1611776a4b28&amp;amp;chksm=bd1265868a65ec906592d25ad65f2a8516338d07ec3217059e6975fc131fc0107d66a8cd2612&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;运‍维&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; tab=&quot;outerlink&quot; data-linktype=&quot;2&quot;&gt;运维&lt;/a&gt;&lt;span&gt;&lt;strong&gt; | &lt;/strong&gt;&lt;/span&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MjM5NjQ5MTI5OA==&amp;amp;mid=2651765974&amp;amp;idx=1&amp;amp;sn=763c1e37d04acffd0142a2852ecfb000&amp;amp;chksm=bd12659b8a65ec8dfcfeb2028ef287fae7c38f134a665375ba420556ce5d2e4cf398147bd12e&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;测‍试&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; tab=&quot;outerlink&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;测试&lt;/span&gt;&lt;/a&gt;&lt;/section&gt;&lt;section class=&quot;mp_profile_iframe_wrp&quot;&gt;&lt;mp-common-profile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mpprofile&quot; data-id=&quot;MjM5NjQ5MTI5OA==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsVGibnsaEib3aNlqF0tOrA2RGEmNSbia2nnohE4Tpf95UyTiaSjDVbHRfY8WNBeTuLLTaVdSckkNyEx1Q/0?wx_fmt=png&quot; data-nickname=&quot;美团技术团队&quot; data-alias=&quot;meituantech&quot; data-signature=&quot;10000+工程师，如何支撑中国领先的生活服务电子商务平台？数亿消费者、数百万商户、2000多个行业、几千亿交易额背后是哪些技术在支撑？这里是美团、大众点评、美团外卖、美团配送、美团优选等技术团队的对外窗口。&quot; data-from=&quot;0&quot; data-is_biz_ban=&quot;0&quot;/&gt;&lt;/section&gt;&lt;p&gt;&lt;mp-style-type data-value=&quot;3&quot;/&gt;&lt;/p&gt;&lt;/div&gt;

          
        &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>