<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>c24b73c0eea4360a593a0c44f93f4b34</guid>
<title>用代码画时序图！YYDS</title>
<link>https://toutiao.io/k/43k0d0b</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content                           autoTypeSetting24psection&amp;#10;                          &quot; id=&quot;js_content&quot;&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot; data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;前言&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;大家好，我是&lt;strong&gt;捡田螺的小男孩&lt;/strong&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;最近通过代码来画&lt;strong&gt;时序图，UML用例图&lt;/strong&gt;，感觉很不错，所以给大家分享一下。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;日常开发，一般在设计阶段，我们都需要&lt;strong&gt;画时序图、用例图&lt;/strong&gt;等等。大家平时画图的时候，是用&lt;code&gt;draw.io&lt;/code&gt;还是&lt;code&gt;processOn&lt;/code&gt;呢？用它们画出的图，其实都很挺好看的。但是呢，今天田螺哥介绍一个款开源的画图神器！用代码就能画图，配合&lt;code&gt;IDE&lt;/code&gt;使用，画图高效简单，信手拈来,还挺美观的。这个神器就是&lt;code&gt;PlantUML&lt;/code&gt;。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5851979345955249&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/PoF8jo1PmpzYk6vp8mPsqnjKxojfF0I7YB70FrcBkwxqqL2nq6jJ8mletIxs3resblPkFfTibaZwibqJiap3CEVwQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1162&quot;/&gt;&lt;/figure&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;1. PlantUML 简介&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;PlantUML是一个开源项目，可以快速编写UML图的工具。它可以支持编码的方式来生成图形。可以用来画&lt;strong&gt;时序图、UML用例图、类图、思维导图、ER图&lt;/strong&gt;等等。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;PlantUML 画出来的图，简洁美观，先给大家看看,一个用PlantUML画出来的登录时序图,以及对应画图的代码,如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;/**&lt;br/&gt; * 关注公众号：键捡田螺的小男孩&lt;br/&gt; */&lt;br/&gt;@startuml&lt;br/&gt;title Sequence Diagram of User login&lt;br/&gt;actor User as user&lt;br/&gt;&lt;br/&gt;participant &lt;span&gt;&quot;gateway&quot;&lt;/span&gt; as gateway&lt;br/&gt;participant &lt;span&gt;&quot;user-core&quot;&lt;/span&gt; as userCore&lt;br/&gt;database &lt;span&gt;&quot;MySQL&quot;&lt;/span&gt; as mysql&lt;br/&gt;database &lt;span&gt;&quot;Redis&quot;&lt;/span&gt; as redis&lt;br/&gt;&lt;br/&gt;autonumber&lt;br/&gt;user-&amp;gt; gateway:login request，param：username，password&lt;br/&gt;activate gateway&lt;br/&gt;gateway-&amp;gt; userCore:forward the login request&lt;br/&gt;activate userCore&lt;br/&gt;userCore-&amp;gt; userCore :check the login param&lt;br/&gt;userCore-&amp;gt; mysql:query user info from mysql by username&lt;br/&gt;activate mysql&lt;br/&gt;mysql-&amp;gt; userCore:response with username and password&lt;br/&gt;deactivate mysql&lt;br/&gt;userCore-&amp;gt;userCore:compare the requested password with the DB&lt;span&gt;&#x27;s password&lt;br/&gt;userCore-&amp;gt; userCore: generate an unique token&lt;br/&gt;userCore--&amp;gt; redis: save the token to redis&lt;br/&gt;userCore-&amp;gt; gateway: response with the token&lt;br/&gt;deactivate userCore&lt;br/&gt;gateway-&amp;gt; user: login success with the token&lt;br/&gt;deactivate gateway&lt;br/&gt;@enduml&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;登录用例时序图如下:&lt;/strong&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5354713313896987&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PoF8jo1PmpzYk6vp8mPsqnjKxojfF0I729Wc1Qiaw9Nanib6xic0PCDZ3LfIZqnbqPJfy1kbAbs84tlhdticjQqoeg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1029&quot;/&gt;&lt;/figure&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;2. PlantUML的安装使用&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;PlantUML的安装很方便的.有个插件,名字是:&lt;code&gt;PlantUML Integration&lt;/code&gt;,大家可以去IDE的插件市场,搜索安装即可,如下:&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5044352454169131&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/PoF8jo1PmpzYk6vp8mPsqnjKxojfF0I7ry5FIulvlUO4P5YupdOQvgGXTEpks0E7WoY6oNHNoMMlvXicKyiaauQw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;3382&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;安装成功后,想快速体验一般的话.可以新建一个项目,然后新建一个plantUML File文件,然后把我上个小节,登录时序图那个代码复制进去,就可以看到登录时序图啦.&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.4071261682242991&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/PoF8jo1PmpzYk6vp8mPsqnjKxojfF0I7FlkwKPXZoUy0MrzfWuVUnneKrohb7ibvkoA6ST5Re5LWibIianqx2icATw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;3424&quot;/&gt;&lt;/figure&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/figure&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;（如果是非时序图，希望即时展示，需要安装下&lt;code&gt;Graphviz&lt;/code&gt;&lt;span&gt;哈&lt;/span&gt;&lt;span&gt;）&lt;/span&gt;&lt;/span&gt;&lt;/figure&gt;&lt;/section&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;3.如何用PlantUML 画时序图&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;什么是&lt;strong&gt;时序图&lt;/strong&gt;?&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;时序图（Sequence Diagram），又名序列图、循序图，是一种UML交互图。它通过描述对象之间发送消息的时间顺序显示多个对象之间的动态协作。它可以表示用例的行为顺序，当执行一个用例行为时，其中的每条消息对应一个类操作或状态机中引起转换的触发事件。&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如何&lt;strong&gt;用PlantUML画时序图&lt;/strong&gt;呢?&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;你可以先新建一个PlantUML文件&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.436769394261424&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/PoF8jo1PmpzYk6vp8mPsqnjKxojfF0I7xq5jpgagib6Wqng9LPdBGth3CtYP7AzBzYfSiaDv3thQiacR42V7TjmUQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1882&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;然后选择Sequence,并定义一个文件名称&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6903553299492385&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/PoF8jo1PmpzYk6vp8mPsqnjKxojfF0I7U8HPqTIu09ayDo8PLDZ4Y6dMfPm04QZ9Bk9NxzsRSrNECTMoUozyZA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;788&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;就会有默认的时序图生成啦.&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.40250855188141393&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/PoF8jo1PmpzYk6vp8mPsqnjKxojfF0I7yQPhPdQwyVbBqRv4MPlnlpyFVcg5JaiarJRwfrHNDC76V9ibYcatQicHg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1754&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们照着登录时序图的代码,来大概说下每个关键词的意思吧.&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;/**&lt;br/&gt; * 关注公众号：键捡田螺的小男孩&lt;br/&gt; */&lt;br/&gt;@startuml&lt;br/&gt;title Sequence Diagram of User login&lt;br/&gt;actor User as user&lt;br/&gt;&lt;br/&gt;participant &lt;span&gt;&quot;gateway&quot;&lt;/span&gt; as gateway&lt;br/&gt;participant &lt;span&gt;&quot;user-core&quot;&lt;/span&gt; as userCore&lt;br/&gt;database &lt;span&gt;&quot;MySQL&quot;&lt;/span&gt; as mysql&lt;br/&gt;database &lt;span&gt;&quot;Redis&quot;&lt;/span&gt; as redis&lt;br/&gt;&lt;br/&gt;autonumber&lt;br/&gt;user-&amp;gt; gateway:login request，param：username，password&lt;br/&gt;activate gateway&lt;br/&gt;gateway-&amp;gt; userCore:forward the login request&lt;br/&gt;activate userCore&lt;br/&gt;userCore-&amp;gt; userCore :check the login param&lt;br/&gt;userCore-&amp;gt; mysql:query user info from mysql by username&lt;br/&gt;activate mysql&lt;br/&gt;mysql-&amp;gt; userCore:response with username and password&lt;br/&gt;deactivate mysql&lt;br/&gt;userCore-&amp;gt;userCore:compare the requested password with the DB&lt;span&gt;&#x27;s password&lt;br/&gt;userCore-&amp;gt; userCore: generate an unique token&lt;br/&gt;userCore--&amp;gt; redis: save the token to redis&lt;br/&gt;userCore-&amp;gt; gateway: response with the token&lt;br/&gt;deactivate userCore&lt;br/&gt;gateway-&amp;gt; user: login success with the token&lt;br/&gt;deactivate gateway&lt;br/&gt;@enduml&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;关键词解释如下:&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;title&lt;/code&gt;:表示该UML用例图的标题&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;actor&lt;/code&gt;:表示人形的参与者&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;as&lt;/code&gt;: 使用as 关键字命名参与者。你可以把它理解成定义变量一样,as后面跟着的就是变量,声明后,我们后面就可以使用这个变量啦&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;participant&lt;/code&gt;:表示普通的参与者,它跟actor的主要区别是:形状不一样&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;database&lt;/code&gt;:表示参与者形状是数据库.&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;显示的顺序是怎么定义的&lt;/strong&gt;:声明的参与者顺序将是（默认的）显示顺序。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;autonumber&lt;/code&gt;:可以给参与者添加顺序&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;-&amp;gt;&lt;/code&gt;:表示绘制两个参与者之间的信息,如果你希望是虚线,可以使用&lt;code&gt;--&amp;gt;&lt;/code&gt;.&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;activate&lt;/code&gt;和&lt;code&gt;deactivate&lt;/code&gt;:表示参与者的生命线&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当然,&lt;code&gt;PlantUML&lt;/code&gt;功能挺丰富的,它还可以组合消息,虽然在我的登录时序图还没体现出来. 它提供了&lt;code&gt;alt/else、opt、loop&lt;/code&gt;来组合消息.如下:&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;@startuml&lt;br/&gt;Alice -&amp;gt; Bob: 认证请求&lt;br/&gt;&lt;br/&gt;alt 登录成功&lt;br/&gt;&lt;br/&gt;    Bob -&amp;gt; Alice: 认证接受&lt;br/&gt;&lt;br/&gt;&lt;span&gt;else&lt;/span&gt; 某种失败情况&lt;br/&gt;&lt;br/&gt;    Bob -&amp;gt; Alice: 认证失败&lt;br/&gt;    group 我自己的标签&lt;br/&gt;    Alice -&amp;gt; Log : 开始记录攻击日志&lt;br/&gt;        loop 1000次&lt;br/&gt;            Alice -&amp;gt; Bob: DNS 攻击&lt;br/&gt;        end&lt;br/&gt;    Alice -&amp;gt; Log : 结束记录攻击日志&lt;br/&gt;    end&lt;br/&gt;&lt;br/&gt;&lt;span&gt;else&lt;/span&gt; 另一种失败&lt;br/&gt;&lt;br/&gt;   Bob -&amp;gt; Alice: 请重复&lt;br/&gt;&lt;br/&gt;end&lt;br/&gt;@enduml&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;对应的时序图如下:&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1.7531380753138075&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PoF8jo1PmpzYk6vp8mPsqnjKxojfF0I7LcClic4n7eCZaeEpMtl0iasf6ibkx4jsklArbIjW2O4zzmbnDa6fIKjKA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;239&quot;/&gt;&lt;/figure&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;4. 如何用PlantUML 画UML用例图&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;什么是用例图?&lt;/strong&gt;&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;用例图（英语：use case diagram）是用户与系统交互的最简表示形式，展现了用户和与他相关的用例之间的关系。通过用例图，人们可以获知系统不同种类的用户和用例。用例图也经常和其他图表配合使用。&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;如何用PlantUML画UML用例图呢?&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;你可以先新建一个PlantUML文件,然后选择user case,并定义个文件名&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.7537993920972644&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/PoF8jo1PmpzYk6vp8mPsqnjKxojfF0I7iaKv78EvBUt8Z4Y0rFo3mwk1XRh0DCAh7MwMxgAEPiaUWtfok0fDYbzw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;658&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;就会有默认的UML用例图生成啦&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.4780578898225957&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/PoF8jo1PmpzYk6vp8mPsqnjKxojfF0I7r0roAphecDJjd758YouibPkzyNcYmvdN5NzaC2mVEtyCicKS3gw19tvQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;2142&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我挑官网一个用例图demo来介绍吧,代码如下:&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;@startuml&lt;br/&gt;left to right direction&lt;br/&gt;actor Guest as g&lt;br/&gt;package Professional {&lt;br/&gt;  actor Chef as c&lt;br/&gt;  actor &lt;span&gt;&quot;Food Critic&quot;&lt;/span&gt; as &lt;span&gt;fc&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;package Restaurant {&lt;br/&gt;  usecase &lt;span&gt;&quot;Eat Food&quot;&lt;/span&gt; as UC1&lt;br/&gt;  usecase &lt;span&gt;&quot;Pay for Food&quot;&lt;/span&gt; as UC2&lt;br/&gt;  usecase &lt;span&gt;&quot;Drink&quot;&lt;/span&gt; as UC3&lt;br/&gt;  usecase &lt;span&gt;&quot;Review&quot;&lt;/span&gt; as UC4&lt;br/&gt;}&lt;br/&gt;&lt;span&gt;fc&lt;/span&gt; --&amp;gt; UC4&lt;br/&gt;g --&amp;gt; UC1&lt;br/&gt;g --&amp;gt; UC2&lt;br/&gt;g --&amp;gt; UC3&lt;br/&gt;@enduml&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;对应生成的用例图如下:&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6387096774193548&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/PoF8jo1PmpzYk6vp8mPsqnjKxojfF0I7Y3nGBfBOl1h68roajppWc4qfJPXYw3kbBaDXa6wHjHxZv2vVJJbtYQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1240&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;来看下每个关键词的意思:&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;left to right direction&lt;/code&gt;:表示从左到右绘制用例图&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;actor Guest as g&lt;/code&gt;:定义一个人形参与者,变量别名是g.&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;package Professional&lt;/code&gt;:定义一个包&lt;code&gt;package&lt;/code&gt;,名字为&lt;code&gt;Professional&lt;/code&gt;.&lt;code&gt;package&lt;/code&gt;可以用来对用例和角色分组.&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;usecase &quot;Eat Food&quot; as UC1&lt;/code&gt;:定义一个用例,别名为&lt;code&gt;UC1&lt;/code&gt;.&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;fc --&amp;gt; UC4&lt;/code&gt;:表示角色&lt;code&gt;fc&lt;/code&gt;和用例&lt;code&gt;UC4&lt;/code&gt;关联起来.角色和用例之间的关系,用&lt;code&gt;--&amp;gt;&lt;/code&gt;来表示。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;5. 如何用plantUML 画思维导图&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;什么是思维导图?&lt;/strong&gt;&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;英文是The Mind Map，又名心智导图，是表达发散性思维的有效图形思维工具 ，它简单却又很有效同时又很高效，是一种实用性的思维工具。&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;写了一个简单的思维导图,代码如下:&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;@startmindmap&lt;br/&gt;* 公众号：捡田螺的小男孩，干货面试题&lt;br/&gt;** 计算机网络面试题&lt;br/&gt;*** TCP/IP十五连问&lt;br/&gt;*** 两万字计算机面试题汇总&lt;br/&gt;** MySQL面试题&lt;br/&gt;** Redis面试题&lt;br/&gt;** 大厂面试真题&lt;br/&gt;*** 虾皮十五连问&lt;br/&gt;*** 五年Oppo后端面试真题&lt;br/&gt;*** 腾讯云十五连问&lt;br/&gt;@endmindmap&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;plantUML画思维导图,还是挺简单的,大家可以看下效果&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.3434343434343434&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/PoF8jo1PmpzYk6vp8mPsqnjKxojfF0I76uSibtQt8rwhJanceoFd5qHhfPGhmNBeZN7OlE2kBeYzibxp2GF3hxgg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1980&quot;/&gt;&lt;/figure&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;6. 如何用planUML 画活动流程图&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;什么是活动图?&lt;/strong&gt;&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;动态图（activity diagram，活动图）是阐明了业务用例实现的工作流程。&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我画了一个简单版的登录活动流程图:&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;@startuml&lt;br/&gt;title Activity Diagram of User login&lt;br/&gt;&lt;br/&gt;start&lt;br/&gt;:user request login;&lt;br/&gt;&lt;span&gt;if&lt;/span&gt; (is request param null？) &lt;span&gt;then&lt;/span&gt; (N)&lt;br/&gt;  :query user info by username;&lt;br/&gt;  &lt;span&gt;if&lt;/span&gt; (is user info  null ?) &lt;span&gt;then&lt;/span&gt; (N)&lt;br/&gt;    :compare the password;&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (Is password right?) &lt;span&gt;then&lt;/span&gt; (Y)&lt;br/&gt;      :generate a token ,and &lt;span&gt;set&lt;/span&gt; it to redis;&lt;br/&gt;      :response with login success;&lt;br/&gt;    &lt;span&gt;else&lt;/span&gt;(N)&lt;br/&gt;       :response with wrong password code;&lt;br/&gt;       stop&lt;br/&gt;    endif&lt;br/&gt;  &lt;span&gt;else&lt;/span&gt;(Y)&lt;br/&gt;    :response with error userinfo;&lt;br/&gt;    stop&lt;br/&gt;  endif&lt;br/&gt;&lt;span&gt;else&lt;/span&gt;(Y)&lt;br/&gt;  :response with error param;&lt;br/&gt;  stop&lt;br/&gt;  endif&lt;br/&gt;stop&lt;br/&gt;@enduml&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;生成的流程图如下:&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.45964642582628745&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/PoF8jo1PmpzYk6vp8mPsqnjKxojfF0I7xyzHtCPRa8uHhJJP9T4mEx8VOl22Gsb2YGlLdQptnzibA2S4fvOKeuw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;2602&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;活动图关键解释如下：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;start&lt;/code&gt;表示活动图流程的开始&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;stop&lt;/code&gt;表示活动图流程的结束&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;:user request login;&lt;/code&gt;:表示活动流程节点为&lt;code&gt;user request login&lt;/code&gt;,需要加&lt;code&gt;:&lt;/code&gt;和&lt;code&gt;;&lt;/code&gt;的哈&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;if+then+endif&lt;/code&gt;表示一个完整的条件判断&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;最后&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;本文介绍了plantUML画图,有兴趣的小伙伴,可以移步官网学习哈。&lt;span&gt;如果这篇文章对您有所帮助，&lt;/span&gt;&lt;span&gt;求一键三连：&lt;/span&gt;&lt;span&gt;点赞、转发、在看。&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;section class=&quot;mp_profile_iframe_wrp&quot;&gt;&lt;mp-common-profile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-id=&quot;Mzg3NzU5NTIwNg==&quot; data-pluginname=&quot;mpprofile&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/PoF8jo1PmpxpY5pHeUUaicHSaqaylBb25Rbib0ocE4ZmXWdicS9tbGvFc9qvbiaNDibKKvuFYqlUdSW6VicXhoLNHfMQ/0?wx_fmt=png&quot; data-nickname=&quot;捡田螺的小男孩&quot; data-alias=&quot;&quot; data-signature=&quot;专注后端技术栈，热爱分享，热爱交朋友，热爱工作总结。毕业于华南理工大学，软件工程专业~&quot; data-from=&quot;0&quot; data-is_biz_ban=&quot;0&quot;/&gt;&lt;/section&gt;&lt;/div&gt;

          

          
          &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>e962f9e9c810a14fe96f3f398bf77270</guid>
<title>微服务架构的演进</title>
<link>https://toutiao.io/k/x6q7qad</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content                           autoTypeSetting24psection&amp;#10;                          &quot; id=&quot;js_content&quot;&gt;&lt;section data-role=&quot;paragraph&quot; data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&lt;strong&gt;您好，我是路人，更多优质文章见个人博客：http://itsoku.com&lt;/strong&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;本文将介绍微服务架构和相关&lt;/span&gt;&lt;span&gt;的组件，介绍他们是什么以及为什么要使用微服务架构和这些组件。&lt;/span&gt;&lt;span&gt;本文侧重于简明地表达微服务架构的全局图景，因此不会涉及具体如何使用组件等细节。&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;要理解微服务，首先要先理解不是微服务的那些。通常跟微服务相对的是单体应用，即将所有功能都打包成在一个独立单元的应用程序。从单体应用到微服务并不是一蹴而就的，这是一个逐渐演变的过程。本文将以一个网上超市应用为例来说明这一过程。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;86122&quot; data-custom=&quot;#138bde&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;最初的需求&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;span&gt;几年前，小明和小皮一起创业做网上超市。小明负责程序开发，小皮负责其他事宜。当时互联网还不发达，网上超市还是蓝海。只要功能实现了就能随便赚钱。所以他们的需求很简单，只需要一个网站挂在公网，用户能够在这个网站上浏览商品、购买商品；另外还需一个管理后台，可以管理商品、用户、以及订单数据。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;我们整理一下功能清单：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;1）网站&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-role=&quot;list&quot;/&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;2）管理后台&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-role=&quot;list&quot;/&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;由于需求简单，小明左手右手一个慢动作，网站就做好了。管理后台出于安全考虑，不和网站做在一起，小明右手左手慢动作重播，管理网站也做好了。总体架构图如下：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;366&quot; data-backw=&quot;568&quot; data-ratio=&quot;0.6446700507614214&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;591&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/fEsWkVrSk54hgjZLSSBibVuy3eQ4XDaBHOMGor3HUwUSGpdNEBp54UaYJxQmK9LaQpJjXSKL2AEaWlicowIgh6wA/640?wx_fmt=png&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;小明挥一挥手，找了家云服务部署上去，网站就上线了。上线后好评如潮，深受各类肥宅喜爱。小明小皮美滋滋地开始躺着收钱。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;86122&quot; data-custom=&quot;#138bde&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;随着业务发展……&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;span&gt;好景不长，没过几天，各类网上超市紧跟着拔地而起，对小明小皮造成了强烈的冲击。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在竞争的压力下，小明小皮决定开展一些营销手段：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-role=&quot;list&quot;&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;开展促销活动。比如元旦全场打折，春节买二送一，情人节狗粮优惠券等等。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;拓展渠道，新增移动端营销。除了网站外，还需要开发移动端APP，微信小程序等。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;精准营销。利用历史数据对用户进行分析，提供个性化服务。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;……&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;这些活动都需要程序开发的支持。小明拉了同学小红加入团队。小红负责数据分析以及移动端相关开发。小明负责促销活动相关功能的开发。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;因为开发任务比较紧迫，小明小红没有好好规划整个系统的架构，随便拍了拍脑袋，决定把促销管理和数据分析放在管理后台里，微信和移动端APP另外搭建。通宵了几天后，新功能和新应用基本完工。这时的架构图如下：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;476&quot; data-backw=&quot;568&quot; data-ratio=&quot;0.8378839590443686&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;586&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/fEsWkVrSk54hgjZLSSBibVuy3eQ4XDaBHrKNJLBkJRmdR9wO0aJicYUjtiakuRUD6FZlp7r8sd9V47td9ROTSRjNA/640?wx_fmt=png&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;这一阶段存在很多不合理的地方：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-role=&quot;list&quot;&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;网站和移动端应用有很多相同业务逻辑的重复代码。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;数据有时候通过数据库共享，有时候通过接口调用传输。接口调用关系杂乱。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;单个应用为了给其他应用提供接口，渐渐地越改越大，包含了很多本来就不属于它的逻辑。应用边界模糊，功能归属混乱。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;管理后台在一开始的设计中保障级别较低。加入数据分析和促销管理相关功能后出现性能瓶颈，影响了其他应用。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;数据库表结构被多个应用依赖，无法重构和优化。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;所有应用都在一个数据库上操作，数据库出现性能瓶颈。特别是数据分析跑起来的时候，数据库性能急剧下降。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;开发、测试、部署、维护愈发困难。即使只改动一个小功能，也需要整个应用一起发布。有时候发布会不小心带上了一些未经测试的代码，或者修改了一个功能后，另一个意想不到的地方出错了。为了减轻发布可能产生的问题的影响和线上业务停顿的影响，所有应用都要在凌晨三四点执行发布。发布后为了验证应用正常运行，还得盯到第二天白天的用户高峰期……&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;团队出现推诿扯皮现象。关于一些公用的功能应该建设在哪个应用上的问题常常要争论很久，最后要么干脆各做各的，或者随便放个地方但是都不维护。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;尽&lt;/span&gt;&lt;span&gt;管有着诸多问题，但也不能否认这一阶段的成果：快速地根据业务变化建设了系统。不过&lt;/span&gt;&lt;strong&gt;&lt;span&gt;紧迫且繁重的任务容易使人陷入局部、短浅的思维方式，从而做出妥协式的决策。&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;在这种架构中，每个人都只关注在自己的一亩三分地，缺乏全局的、长远的设计。长此以往，系统建设将会越来越困难，甚至陷入不断推翻、重建的循环。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;86122&quot; data-custom=&quot;#138bde&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;是时候做出改变了&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;span&gt;幸好小明和小红是有追求有理想的好青年。意识到问题后，小明和小红从琐碎的业务需求中腾出了一部分精力，开始梳理整体架构，针对问题准备着手改造。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-role=&quot;paragraph&quot; data-custom=&quot;#138bde&quot;&gt;&lt;section label=&quot;Copyright © 2015 Yead All Rights Reserved.&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;p&gt;&lt;span&gt;要做改造，首先你需要有足够的精力和资源。如果你的需求方（业务人员、项目经理、上司等）很强势地一心追求需求进度，以至于你无法挪出额外的精力和资源的话，那么你可能无法做任何事……&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;要做改造，首先你需要有足够的精力和资源。如果你的需求方（业务人员、项目经理、上司等）很强势地一心追求需求进度，以至于你无法挪出额外的精力和资源的话，那么你可能无法做任何事……&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在编程的世界中，最重要的便是抽象能力。微服务改造的过程实际上也是个抽象的过程。小明和小红整理了网上超市的业务逻辑，抽象出公用的业务能力，做成几个公共服务：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-role=&quot;list&quot;/&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;各个应用后台只需从这些服务获取所需的数据，从而删去了大量冗余的代码，就剩个轻薄的控制层和前端。这一阶段的架构如下：&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;376&quot; data-backw=&quot;568&quot; data-ratio=&quot;0.6626180836707153&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;741&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/fEsWkVrSk54hgjZLSSBibVuy3eQ4XDaBHicArwoI8y7icszLxIcfGyldHA2zxY78O37BGjvribwA49kFQMJCuoWxpw/640?wx_fmt=png&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;这个阶段只是将服务分开了，数据库依然是共用的，所以一些烟囱式系统的缺点仍然存在：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-role=&quot;list&quot;/&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;如果一直保持共用数据库的模式，则整个架构会越来越僵化，失去了微服务架构的意义。因此小明和小红一鼓作气，把数据库也拆分了。所有持久化层相互隔离，由各个服务自己负责。另外，为了提高系统的实时性，加入了消息队列机制。架构如下：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;480&quot; data-backw=&quot;568&quot; data-ratio=&quot;0.8452685421994884&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;782&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/fEsWkVrSk54hgjZLSSBibVuy3eQ4XDaBHuQdzicZ5XicK4IzDQOHroxiaKqDj0W3stEIXvNRPCXFBCia3q2YiaV7R4ow/640?wx_fmt=png&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;完全拆分后各个服务可以采用异构的技术。比如数据分析服务可以使用数据仓库作为持久化层，以便于高效地做一些统计计算；商品服务和促销服务访问频率比较大，因此加入了缓存机制等。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-role=&quot;paragraph&quot; data-custom=&quot;#138bde&quot;&gt;&lt;section label=&quot;Copyright © 2015 Yead All Rights Reserved.&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;p&gt;&lt;span&gt;还有一种抽象出公共逻辑的方法是把这些公共逻辑做成公共的框架库。这种方法可以减少服务调用的性能损耗。但是这种方法的管理成本非常高昂，很难保证所有应用版本的一致性。&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot; data-custom=&quot;#138bde&quot;&gt;&lt;section label=&quot;Copyright © 2015 Yead All Rights Reserved.&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;p&gt;&lt;span&gt;数据库拆分也有一些问题和挑战：比如说跨库级联的需求，通过服务查询数据颗粒度的粗细问题等。但是这些问题可以通过合理的设计来解决。总体来说，数据库拆分是一个利大于弊的。&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;微服务架构还有一个技术外的好处，它使整个系统的分工更加明确，责任更加清晰，每个人专心负责为其他人提供更好的服务。在单体应用的时代，公共的业务功能经常没有明确的归属。最后要么各做各的，每个人都重新实现了一遍；要么是随机一个人（一般是能力比较强或者比较热心的人）做到他负责的应用里面。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在后者的情况下，这个人在负责自己应用之外，还要额外负责给别人提供这些公共的功能——而这个功能本来是无人负责的，仅仅因为他能力较强/比较热心，就莫名地背锅（这种情况还被美其名曰能者多劳）。结果最后大家都不愿意提供公共的功能。长此以往，团队里的人渐渐变得各自为政，不再关心全局的架构设计。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;从这个角度上看，使用微服务架构同时也需要组织结构做相应的调整。所以说做微服务改造需要管理者的支持。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;改造完成后，小明和小红分清楚各自的锅。两人十分满意，一切就像是麦克斯韦方程组一样漂亮完美。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;然而……&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;86122&quot; data-custom=&quot;#138bde&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;没有银弹&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;span&gt;春天来了，万物复苏，又到了一年一度的购物狂欢节。眼看着日订单数量蹭蹭地上涨，小皮小明小红喜笑颜开。可惜好景不长，乐极生悲，突然嘣的一下，系统挂了。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;以往单体应用，排查问题通常是看一下日志，研究错误信息和调用堆栈。而&lt;/span&gt;&lt;strong&gt;&lt;span&gt;微服务架构整个应用分散成多个服务，定位故障点非常困难。&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;小明一个台机器一台机器地查看日志，一个服务一个服务的手工调用。经过十几分钟的查找，小明终于定位到故障点：促销服务由于接收的请求量太大而停止响应了。其他服务都直接或间接地会调用促销服务，于是也跟着宕机了。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span/&gt;&lt;strong&gt;&lt;span&gt;在微服务架构中，一个服务故障可能会产生雪崩效用，导致整个系统故障。&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;其实在节前，小明和小红是有做过请求量评估的。按照预计，服务器资源是足以支持节日的请求量的，所以肯定是哪里出了问题。不过形势紧急，随着每一分每一秒流逝的都是白花花的银子，因此小明也没时间排查问题，当机立断在云上新建了几台虚拟机，然后一台一台地部署新的促销服务节点。几分钟的操作后，系统总算是勉强恢复正常了。整个故障时间内估计损失了几十万的销售额，三人的心在滴血……&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;事后，小明简单写了个日志分析工具（量太大了，文本编辑器几乎打不开，打开了肉眼也看不过来），统计了促销服务的访问日志，发现在故障期间，商品服务由于代码问题，在某些场景下会对促销服务发起大量请求。这个问题并不复杂，小明手指抖一抖，修复了这个价值几十万的Bug。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;问题是解决了，但谁也无法保证不会再发生类似的其他问题。微服务架构虽然逻辑设计上看是完美的，但就像积木搭建的华丽宫殿一样，经不起风吹草动。微服务架构虽然解决了旧问题，也引入了新的问题：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-role=&quot;list&quot;&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;微服务架构整个应用分散成多个服务，定位故障点非常困难。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;稳定性下降。服务数量变多导致其中一个服务出现故障的概率增大，并且一个服务故障可能导致整个系统挂掉。事实上，在大访问量的生产场景下，故障总是会出现的。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;服务数量非常多，部署、管理的工作量很大。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;开发方面：如何保证各个服务在持续开发的情况下仍然保持协同合作。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;测试方面：服务拆分后，几乎所有功能都会涉及多个服务。原本单个程序的测试变为服务间调用的测试。测试变得更加复杂。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;小明小红痛定思痛，决心好好解决这些问题。对故障的处理一般从两方面入手，一方面尽量减少故障发生的概率，另一方面降低故障造成的影响。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;285&quot; data-backw=&quot;374&quot; data-ratio=&quot;0.7620320855614974&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;374&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/fEsWkVrSk54hgjZLSSBibVuy3eQ4XDaBHCQ0PUjuOVFw9RWLMclkJX9DfKEYuTE5zicrofnOHjiaGhp2hVZSa2QJA/640?wx_fmt=png&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;86122&quot; data-custom=&quot;#138bde&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;监控 - 发现故障的征兆&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;span&gt;在高并发分布式的场景下，故障经常是突然间就雪崩式爆发。所以必须建立完善的监控体系，尽可能发现故障的征兆。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;微服务架构中组件繁多，各个组件所需要监控的指标不同。比如Redis缓存一般监控占用内存值、网络流量，数据库监控连接数、磁盘空间，业务服务监控并发数、响应延迟、错误率等。因此如果做一个大而全的监控系统来监控各个组件是不大现实的，而且扩展性会很差。一般的做法是让各个组件提供报告自己当前状态的接口（metrics接口），这个接口输出的数据格式应该是一致的。然后部署一个指标采集器组件，定时从这些接口获取并保持组件状态，同时提供查询服务。最后还需要一个UI，从指标采集器查询各项指标，绘制监控界面或者根据阈值发出告警。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;大部分组件都不需要自己动手开发，网络上有开源组件。小明下载了RedisExporter和MySQLExporter，这两个组件分别提供了Redis缓存和MySQL数据库的指标接口。微服务则根据各个服务的业务逻辑实现自定义的指标接口。然后小明采用Prometheus作为指标采集器，Grafana配置监控界面和邮件告警。这样一套微服务监控系统就搭建起来了：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;304&quot; data-backw=&quot;568&quot; data-ratio=&quot;0.5345821325648416&quot; data-s=&quot;300,640&quot; data-type=&quot;jpeg&quot; data-w=&quot;694&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/fEsWkVrSk54hgjZLSSBibVuy3eQ4XDaBHv833iaL9fRZ2TVWFvbfsoy7kLy3ia0grSjnwye8FlL9BQWVp62f1Pickg/640?wx_fmt=jpeg&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;86122&quot; data-custom=&quot;#138bde&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;定位问题 - 链路跟踪&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;span&gt;在微服务架构下，一个用户的请求往往涉及多个内部服务调用。为了方便定位问题，需要能够记录每个用户请求时，微服务内部产生了多少服务调用，及其调用关系。这个叫做链路跟踪。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;我们用一个Istio文档里的链路跟踪例子来看看效果：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;228&quot; data-backw=&quot;568&quot; data-ratio=&quot;0.40078125&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/fEsWkVrSk54hgjZLSSBibVuy3eQ4XDaBHd7Phv0xDCGUrXducmOCHPEVC9ywicicx6UicYjwoZiaIRNvgtPEU86tHmw/640?wx_fmt=png&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;图片来自Istio文档&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;从图中可以看到，这是一个用户访问productpage页面的请求。在请求过程中，productpage服务顺序调用了details和reviews服务的接口。而reviews服务在响应过程中又调用了ratings的接口。整个链路跟踪的记录是一棵树：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;411&quot; data-backw=&quot;461&quot; data-ratio=&quot;0.8915401301518439&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;461&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/fEsWkVrSk54hgjZLSSBibVuy3eQ4XDaBHicxf0oNv3OApmicGNsqzcQJ0DTnJEiaIqo7Zv2MekJpFxOLbia4CIw7KyA/640?wx_fmt=png&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;要实现链路跟踪，每次服务调用会在HTTP的HEADERS中记录至少记录四项数据：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-role=&quot;list&quot;&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;traceId：traceId标识一个用户请求的调用链路。具有相同traceId的调用属于同一条链路。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;spanId：标识一次服务调用的ID，即链路跟踪的节点ID。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;parentId：父节点的spanId。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;requestTime &amp;amp; responseTime：请求时间和响应时间。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;另外，还需要调用日志收集与存储的组件，以及展示链路调用的UI组件。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;391&quot; data-backw=&quot;501&quot; data-ratio=&quot;0.780439121756487&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;501&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/fEsWkVrSk54hgjZLSSBibVuy3eQ4XDaBHQw8EVsfFClOBpF6iajN94XLyytIzNnVPmEzUfpHIiaw1b0x21qH9QDDA/640?wx_fmt=png&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;以上只是一个极简的说明，关于链路跟踪的理论依据可详见Google的Dapper&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;了解了理论基础后，小明选用了Dapper的一个开源实现Zipkin。然后手指一抖，写了个HTTP请求的拦截器，在每次HTTP请求时生成这些数据注入到HEADERS，同时异步发送调用日志到Zipkin的日志收集器中。这里额外提一下，HTTP请求的拦截器，可以在微服务的代码中实现，也可以使用一个网络代理组件来实现（不过这样子每个微服务都需要加一层代理）。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;链路跟踪只能定位到哪个服务出现问题，不能提供具体的错误信息。查找具体的错误信息的能力则需要由日志分析组件来提供。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;86122&quot; data-custom=&quot;#138bde&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;分析问题 - 日志分析&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;span&gt;日志分析组件应该在微服务兴起之前就被广泛使用了。即使单体应用架构，当访问数变大、或服务器规模增多时，日志文件的大小会膨胀到难以用文本编辑器进行访问，更糟的是它们分散在多台服务器上面。排查一个问题，需要登录到各台服务器去获取日志文件，一个一个地查找（而且打开、查找都很慢）想要的日志信息。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;因此，在应用规模变大时，我们需要一个日志的&lt;/span&gt;&lt;strong&gt;&lt;span&gt;“搜索引擎”&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;。以便于能准确地找到想要的日志。另外，数据源一侧还需要收集日志的组件和展示结果的UI组件：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;308&quot; data-backw=&quot;568&quot; data-ratio=&quot;0.5423023578363384&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;721&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/fEsWkVrSk54hgjZLSSBibVuy3eQ4XDaBHia8Kticu8Yo32sdx5rKT7mE8Iia8dW16FkUdo3xcVtbvwM81WrzYuUPKQ/640?wx_fmt=png&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;小明调查了一下，使用了大名鼎鼎的ELK日志分析组件。ELK是Elasticsearch、Logstash和Kibana三个组件的缩写。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-role=&quot;list&quot;&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;Elasticsearch：搜索引擎，同时也是日志的存储。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;Logstash：日志采集器，它接收日志输入，对日志进行一些预处理，然后输出到Elasticsearch。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;Kibana：UI组件，通过Elasticsearch的API查找数据并展示给用户。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;最后还有一个小问题是如何将日志发送到Logstash。一种方案是在日志输出的时候直接调用Logstash接口将日志发送过去。这样一来又（咦，为啥要用“又”）要修改代码……于是小明选用了另一种方案：日志仍然输出到文件，每个服务里再部署个Agent扫描日志文件然后输出给Logstash。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;86122&quot; data-custom=&quot;#138bde&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;网关 - 权限控制，服务治理&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;span&gt;拆分成微服务后，出现大量的服务，大量的接口，使得整个调用关系乱糟糟的。经常在开发过程中，写着写着，忽然想不起某个数据应该调用哪个服务。或者写歪了，调用了不该调用的服务，本来一个只读的功能结果修改了数据……&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;为了应对这些情况，微服务的调用需要一个把关的东西，也就是网关。在调用者和被调用者中间加一层网关，每次调用时进行权限校验。另外，网关也可以作为一个提供服务接口文档的平台。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;使用网关有一个问题就是要决定在多大粒度上使用：最粗粒度的方案是整个微服务一个网关，微服务外部通过网关访问微服务，微服务内部则直接调用；最细粒度则是所有调用，不管是微服务内部调用或者来自外部的调用，都必须通过网关。折中的方案是按照业务领域将微服务分成几个区，区内直接调用，区间通过网关调用。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;由于整个网上超市的服务数量还不算特别多，小明采用的最粗粒度的方案：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;510&quot; data-backw=&quot;568&quot; data-ratio=&quot;0.8986975397973951&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;691&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/fEsWkVrSk54hgjZLSSBibVuy3eQ4XDaBHeVSZnN3MS49oKWeicLibmcPwofvMpIl517jY8SDYJRUjk6ZPyXLY1IsA/640?wx_fmt=png&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;86122&quot; data-custom=&quot;#138bde&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;服务注册与发现 - 动态扩容&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;span&gt;前面的组件，都是旨在降低故障发生的可能性。然而故障总是会发生的，所以另一个需要研究的是如何降低故障产生的影响。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;最粗暴的（也是最常用的）故障处理策略就是冗余。一般来说，一个服务都会部署多个实例，这样一来能够分担压力提高性能，二来即使一个实例挂了其他实例还能响应。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;冗余的一个问题是使用几个冗余？这个问题在时间轴上并没有一个切确的答案。根据服务功能、时间段的不同，需要不同数量的实例。比如在平日里，可能4个实例已经够用；而在促销活动时，流量大增，可能需要40个实例。因此冗余数量并不是一个固定的值，而是根据需要实时调整的。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;一般来说新增实例的操作为：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-role=&quot;list&quot;/&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;操作只有两步，但如果注册到负载均衡或DNS的操作为人工操作的话，那事情就不简单了。想想新增40个实例后，要手工输入40个IP的感觉……&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;解决这个问题的方案是服务自动注册与发现。首先，需要部署一个服务发现服务，它提供所有已注册服务的地址信息的服务。DNS也算是一种服务发现服务。然后各个应用服务在启动时自动将自己注册到服务发现服务上。并且应用服务启动后会实时（定期）从服务发现服务同步各个应用服务的地址列表到本地。服务发现服务也会定期检查应用服务的健康状态，去掉不健康的实例地址。这样新增实例时只需要部署新实例，实例下线时直接关停服务即可，服务发现会自动检查服务实例的增减。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;184&quot; data-backw=&quot;568&quot; data-ratio=&quot;0.3242876526458616&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;737&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/fEsWkVrSk54hgjZLSSBibVuy3eQ4XDaBHziaezfx1d6Uag1siaCYtaxHZkcG3ZpXymZPZQL7PUMdnTrBaxibibK2Img/640?wx_fmt=png&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;服务发现还会跟客户端负载均衡配合使用。由于应用服务已经同步服务地址列表在本地了，所以访问微服务时，可以自己决定负载策略。甚至可以在服务注册时加入一些元数据（服务版本等信息），客户端负载则根据这些元数据进行流量控制，实现A/B测试、蓝绿发布等功能。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;服务发现有很多组件可以选择，比如说Zookeeper 、Eureka、Consul、Etcd等。不过小明觉得自己水平不错，想炫技，于是基于Redis自己写了一个……&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;86122&quot; data-custom=&quot;#138bde&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;熔断、服务降级、限流&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;86152&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;span data-bgopacity=&quot;40%&quot;/&gt;&lt;span data-bgopacity=&quot;25%&quot;/&gt;&lt;span/&gt;&lt;/section&gt;&lt;section&gt;&lt;section data-brushtype=&quot;text&quot;&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;熔断&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;当一个服务因为各种原因停止响应时，调用方通常会等待一段时间，然后超时或者收到错误返回。如果调用链路比较长，可能会导致请求堆积，整条链路占用大量资源一直在等待下游响应。所以当多次访问一个服务失败时，应熔断，标记该服务已停止工作，直接返回错误。直至该服务恢复正常后再重新建立连接。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;640&quot; data-backw=&quot;568&quot; data-ratio=&quot;1.1275992438563327&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;1058&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/fEsWkVrSk54hgjZLSSBibVuy3eQ4XDaBH2Wd71fAFO7yk9Sx5rQVLqa3B8zWRkCcEbiak2Vhxeqq2TK0iaicBlr8DQ/640?wx_fmt=png&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;图片来自《微服务设计》&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;86152&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;span data-bgopacity=&quot;40%&quot;/&gt;&lt;span data-bgopacity=&quot;25%&quot;/&gt;&lt;span/&gt;&lt;/section&gt;&lt;section&gt;&lt;section data-brushtype=&quot;text&quot;&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;服务降级&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;span&gt;当下游服务停止工作后，如果该服务并非核心业务，则上游服务应该降级，以保证核心业务不中断。比如网上超市下单界面有一个推荐商品凑单的功能，当推荐模块挂了后，下单功能不能一起挂掉，只需要暂时关闭推荐功能即可。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;86152&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;span data-bgopacity=&quot;40%&quot;/&gt;&lt;span data-bgopacity=&quot;25%&quot;/&gt;&lt;span/&gt;&lt;/section&gt;&lt;section&gt;&lt;section data-brushtype=&quot;text&quot;&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;限流&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;span&gt;一个服务挂掉后，上游服务或者用户一般会习惯性地重试访问。这导致一旦服务恢复正常，很可能因为瞬间网络流量过大又立刻挂掉，在棺材里重复着仰卧起坐。因此服务需要能够自我保护——限流。限流策略有很多，最简单的比如当单位时间内请求数过多时，丢弃多余的请求。另外，也可以考虑分区限流。仅拒绝来自产生大量请求的服务的请求。例如商品服务和订单服务都需要访问促销服务，商品服务由于代码问题发起了大量请求，促销服务则只限制来自商品服务的请求，来自订单服务的请求则正常响应。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;341&quot; data-backw=&quot;401&quot; data-ratio=&quot;0.8503740648379052&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;401&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/fEsWkVrSk54hgjZLSSBibVuy3eQ4XDaBHVzMRaQ7a2D0EiaCJpicntx2b7gMiba6kTJHmb93m2zZbickN9kYMLgLIrw/640?wx_fmt=png&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;86122&quot; data-custom=&quot;#138bde&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;测试&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;span&gt;微服务架构下，测试分为三个层次：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-role=&quot;list&quot;/&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;三种测试从上到下实施的容易程度递增，但是测试效果递减。端到端测试最费时费力，但是通过测试后我们对系统最有信心。单元测试最容易实施，效率也最高，但是测试后不能保证整个系统没有问题。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;204&quot; data-backw=&quot;568&quot; data-ratio=&quot;0.3589511754068716&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;1106&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/fEsWkVrSk54hgjZLSSBibVuy3eQ4XDaBH2hyqGWiat1ecUDmExMVOiavZgh6BbTLZtR5f9N2u6oVr5A6f0nSKVq8A/640?wx_fmt=png&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;由于端到端测试实施难度较大，一般只对核心功能做端到端测试。一旦端到端测试失败，则需要将其分解到单元测试：则分析失败原因，然后编写单元测试来重现这个问题，这样未来我们便可以更快地捕获同样的错误。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;服务测试的难度在于服务会经常依赖一些其他服务。这个问题可以通过Mock Server解决：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;326&quot; data-backw=&quot;568&quot; data-ratio=&quot;0.5731182795698925&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;930&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/fEsWkVrSk54hgjZLSSBibVuy3eQ4XDaBH4NmoowBpu9Nnds9WqibBfrmEXiaW5b7gf0vTutmK83a0HBRaTN9RREqQ/640?wx_fmt=png&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;单元测试大家都很熟悉了。我们一般会编写大量的单元测试（包括回归测试）尽量覆盖所有代码。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;86122&quot; data-custom=&quot;#138bde&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;微服务框架&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;span&gt;指标接口、链路跟踪注入、日志引流、服务注册发现、路由规则等组件以及熔断、限流等功能都需要在应用服务上添加一些对接代码。如果让每个应用服务自己实现是非常耗时耗力的。基于DRY的原则，小明开发了一套微服务框架，将与各个组件对接的代码和另外一些公共代码抽离到框架中，所有的应用服务都统一使用这套框架进行开发。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;使用微服务框架可以实现很多自定义的功能。甚至可以将程序调用堆栈信息注入到链路跟踪，实现代码级别的链路跟踪。或者输出线程池、连接池的状态信息，实时监控服务底层状态。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;使用统一的微服务框架有一个比较严重的问题：框架更新成本很高。每次框架升级，都需要所有应用服务配合升级。当然，一般会使用兼容方案，留出一段并行时间等待所有应用服务升级。但是如果应用服务非常多时，升级时间可能会非常漫长。并且有一些很稳定几乎不更新的应用服务，其负责人可能会拒绝升级……因此，使用统一微服务框架需要完善的版本管理方法和开发管理规范。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;86122&quot; data-custom=&quot;#138bde&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;另一条路 - Service Mesh&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;span&gt;另一种抽象公共代码的方法是直接将这些代码抽象到一个反向代理组件。每个服务都额外部署这个代理组件，所有出站入站的流量都通过该组件进行处理和转发。这个组件被称为Sidecar。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-role=&quot;paragraph&quot; data-custom=&quot;#138bde&quot;&gt;&lt;section label=&quot;Copyright © 2015 Yead All Rights Reserved.&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;p&gt;&lt;span&gt;Sidecar不会产生额外网络成本。Sidecar会和微服务节点部署在同一台主机上并且共用相同的虚拟网卡。所以sidecar和微服务节点的通信实际上都只是通过内存拷贝实现的。&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;283&quot; data-backw=&quot;440&quot; data-ratio=&quot;0.6431818181818182&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;440&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/fEsWkVrSk54hgjZLSSBibVuy3eQ4XDaBH0mrSyudVcCk3UsibBoKXqNynibaYBPBTHSZvEGBKk4QLFmMFaicqhPUjg/640?wx_fmt=png&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot;/&gt;&lt;span&gt;图片来自：&lt;/span&gt;&lt;span&gt;Pattern: Service Mesh&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Sidecar只负责网络通信。还需要有个组件来统一管理所有sidecar的配置。在Service Mesh中，负责网络通信的部分叫数据平面（data plane），负责配置管理的部分叫控制平面（control plane）。数据平面和控制平面构成了Service Mesh的基本架构。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;362&quot; data-backw=&quot;568&quot; data-ratio=&quot;0.6369137670196672&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;661&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/fEsWkVrSk54hgjZLSSBibVuy3eQ4XDaBHG5X3nDdpACOsHEegiaw07QopeUkmfOwJDYpCzafMkhNWsuHcf6nMbVw/640?wx_fmt=png&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;图片来自：Pattern: Service Mesh&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Sevice Mesh相比于微服务框架的优点在于它不侵入代码，升级和维护更方便。它经常被诟病的则是性能问题。即使回环网络不会产生实际的网络请求，但仍然有内存拷贝的额外成本。另外有一些集中式的流量处理也会影响性能。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;86122&quot; data-custom=&quot;#138bde&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;结束、也是开始&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;span&gt;微服务不是架构演变的终点。往细走还有Serverless、FaaS等方向。另一方面也有人在唱合久必分分久必合，重新发现单体架构……&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;www.cnblogs.com/skabyy/p/11396571.html&lt;/span&gt;&lt;/section&gt;&lt;pre&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1.2204545454545455&quot; data-w=&quot;440&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/RkqIyCg0bs5eA3lABIgSNCAiaiaXF3XfK77DciajeWbGUJ91ribtXtpsDEzlYeAB4icdIhcSrlEeJM4Kf0FiaS68icE8w/640?wx_fmt=png&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot;/&gt;&lt;/section&gt;&lt;/pre&gt;&lt;p&gt;&lt;/p&gt;&lt;pre&gt;&lt;p&gt;&lt;small&gt;喜欢就点个&quot;在看&quot;呗^_^&lt;/small&gt;&lt;/p&gt;&lt;/pre&gt;&lt;/section&gt;&lt;/div&gt;

          

          
          &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>6c0c46421a709884249ef59faad5f454</guid>
<title>面试25k职位遇到的线程池8连问，能答出来算你狠！</title>
<link>https://toutiao.io/k/hecj2ay</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content                                       &quot; id=&quot;js_content&quot;&gt;&lt;section class=&quot;channels_iframe_wrp&quot; data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;mpvideosnap class=&quot;js_uneditable custom_select_card channels_iframe videosnap_video_iframe&quot; data-pluginname=&quot;videosnap&quot; data-id=&quot;export/UzFfAgtgekIEAQAAAAAAog8z0-8GmQAAAAstQy6ubaLX4KHWvLEZgBPE9KJYWj5rLZb8zNPgMIsBlZXI7By1FOoD9IS8ocBL&quot; data-url=&quot;https://findermp.video.qq.com/251/20304/stodownload?encfilekey=rjD5jyTuFrIpZ2ibE8T7YmwgiahniaXswqz6bwvxz6OrscibFX1ibWpLcal8LmZQxsKazULgWADWKPHSicr38aylic84KAU32icFn1AYCh66tt1vA25waA0bgn6elg&amp;amp;adaptivelytrans=0&amp;amp;bizid=1023&amp;amp;dotrans=0&amp;amp;hy=SH&amp;amp;idx=1&amp;amp;m=&amp;amp;scene=0&amp;amp;token=x5Y29zUxcibAdPIFjnJKCYpW2MxRvRkbbopSUs8QP80dZVcprkczhy5kryNMibIxuHLXIA3bdhtRE&quot; data-headimgurl=&quot;http://wx.qlogo.cn/finderhead/Q3auHgzwzM5nv7YHhmhvPsGGX04JCIgibK2x2Ru0TOY9HeZTGSIL1KQ/0&quot; data-username=&quot;v2_060000231003b20faec8c5e08a1fc3d5c807ec30b07756771265bc6b6234fb9e05062ae69ab4@finder&quot; data-nickname=&quot;儒猿IT&quot; data-desc=&quot;可能很多兄弟都听说过Java线程池的理论原理，但是没在高并发环境下玩儿过Java线程池的优化！#Java #Java线程池 #高并发 @微信时刻 &quot; data-nonceid=&quot;14456131982360074779&quot; data-type=&quot;video&quot; data-width=&quot;1920&quot; data-height=&quot;1080&quot;/&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;文章来源：&lt;/span&gt;&lt;/strong&gt;&lt;strong&gt;&lt;span&gt;https://juejin.cn/post/7137186083074703391&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p data-mid=&quot;&quot; mpa-is-content=&quot;t&quot;&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1.5454545454545454&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/gdxAJ6zQsUYfldc9KVnrcQSOpyXRZEVepgnN1Ykwcia3wuOHibVmnRkSUNjygD8GZMLUCuCgdjn0EF6VibajENJrQ/640?wx_fmt=png&quot; data-w=&quot;22&quot;/&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p data-mid=&quot;&quot; mpa-is-content=&quot;t&quot;&gt;大家好，这篇文章主要跟大家聊下 Java 线程池面试中可能会问到的一些问题。&lt;/p&gt;&lt;p data-mid=&quot;&quot; mpa-is-content=&quot;t&quot;&gt;全程干货，耐心看完，你能轻松应对各种线程池面试。&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;img data-ratio=&quot;0.972972972972973&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Xuz7cCrSxHUr4F6rIJJmUyiaCTDRkk8vhJocsm8Boar8kRkaicGNLVaY5y2RWVy1h5sV9tfDvvjOYwTmHMnKsxQw/640?wx_fmt=png&quot; data-w=&quot;74&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/p&gt;&lt;p data-mid=&quot;&quot; mpa-is-content=&quot;t&quot;&gt;&lt;span&gt;相信各位 Javaer 在面试中或多或少肯定被问到过线程池相关问题吧，线程池是一个相对比较复杂的体系，基于此可以问出各种各样、五花八门的问题。&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;若你很熟悉线程池，如果可以，完全可以滔滔不绝跟面试官扯一个小时线程池，一般面试也就一个小时左右，那么这样留给面试官问其他问题的时间就很少了，或者其他问题可能问的也就不深入了，那你通过面试的几率是不就更大点了呢。&lt;/span&gt;&lt;/h4&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;下面我们开始列下线程池面试可能会被问到的问题以及该怎么回答，以下只是参考答案，你也可以加入自己的理解。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.06451612903225806&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/01NCBYDP9ZfkwrnCoIlkXhdAZbvSQoo0P17WWyOtfcfypVW5ic2ibUZHEXIuYjH409ebVxiar8pn7dx5yHGpWWV8A/640?wx_fmt=png&quot; data-w=&quot;310&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;h4 data-id=&quot;heading-0&quot;&gt;&lt;span&gt;&lt;strong&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h4&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong mpa-from-tpl=&quot;t&quot;&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;1. 面试官：日常工作中有用到线程池吗？什么是线程池？为什么要使用线程池？&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h4&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;一般面试官考察你线程池相关知识前，大概率会先问这个问题，如果你说没用过，不了解，ok，那就没以下问题啥事了，估计你的面试结果肯定也凶多吉少了。&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;作为 JUC 包下的门面担当，线程池是名副其实的 JUC 一哥，不了解线程池，那说明你对 JUC 包其他工具也了解的不咋样吧，对 JUC 没深入研究过，那就是没掌握到 Java 的精髓，给面试官这样一个印象，那结果可想而知了。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;所以说，这一分一定要吃下，那我们应该怎么回答好这问题呢？&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong mpa-from-tpl=&quot;t&quot;&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;可以这样说：&lt;/span&gt;&lt;/strong&gt;&lt;/h4&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;计算机发展到现在，摩尔定律在现有工艺水平下已经遇到难易突破的物理瓶颈，通过多核 CPU 并行计算来提升服务器的性能已经成为主流，随之出现了多线程技术。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;线程作为操作系统宝贵的资源，对它的使用需要进行控制管理，线程池就是采用池化思想（类似连接池、常量池、对象池等）管理线程的工具。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;JUC 给我们提供了 ThreadPoolExecutor 体系类来帮助我们更方便的管理线程、并行执行任务。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;下图是 Java 线程池继承体系：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.9732360097323601&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz/1J6IbIcPCLaRf8gwR5lGpYybM87ib19wcA2qDsWslw2Q4j8mat8229rjxoM09jD1iaGZ0cibW6zwsJXiambu3wnB2w/640?wx_fmt=jpeg&quot; data-type=&quot;other&quot; data-w=&quot;411&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;使用线程池可以带来以下好处：&lt;/span&gt;&lt;/strong&gt;&lt;span/&gt;&lt;/p&gt;&lt;blockquote&gt;&lt;ol class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;降低资源消耗。降低频繁创建、销毁线程带来的额外开销，复用已创建线程&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;降低使用复杂度。将任务的提交和执行进行解耦，我们只需要创建一个线程池，然后往里面提交任务就行，具体执行流程由线程池自己管理，降低使用复杂度&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;提高线程可管理性。能安全有效的管理线程资源，避免不加限制无限申请造成资源耗尽风险&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;提高响应速度。任务到达后，直接复用已创建好的线程执行&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;线程池的使用场景简单来说可以有：&lt;/span&gt;&lt;/strong&gt;&lt;span/&gt;&lt;/p&gt;&lt;blockquote&gt;&lt;ol class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;快速响应用户请求，响应速度优先&lt;/strong&gt;。比如一个用户请求，需要通过 RPC 调用好几个服务去获取数据然后聚合返回，此场景就可以用线程池并行调用，响应时间取决于响应最慢的那个 RPC 接口的耗时；又或者一个注册请求，注册完之后要发送短信、邮件通知，为了快速返回给用户，可以将该通知操作丢到线程池里异步去执行，然后直接返回客户端成功，提高用户体验。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;单位时间处理更多请求，吞吐量优先&lt;/strong&gt;。比如接受 MQ 消息，然后去调用第三方接口查询数据，此场景并不追求快速响应，主要利用有限的资源在单位时间内尽可能多的处理任务，可以利用队列进行任务的缓冲&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.06451612903225806&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/01NCBYDP9ZfkwrnCoIlkXhdAZbvSQoo0P17WWyOtfcfypVW5ic2ibUZHEXIuYjH409ebVxiar8pn7dx5yHGpWWV8A/640?wx_fmt=png&quot; data-w=&quot;310&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/p&gt;&lt;h4 data-id=&quot;heading-1&quot;&gt;&lt;span&gt;&lt;strong&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h4&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong mpa-from-tpl=&quot;t&quot;&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;2. 面试官：ThreadPoolExecutor 都有哪些核心参数？&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h4&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;其实一般面试官问你这个问题并不是简单听你说那几个参数，而是想要你描述下线程池执行流程。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;包含核心线程数（corePoolSize）、最大线程数（maximumPoolSize），空闲线程超时时间（keepAliveTime）、时间单位（unit）、阻塞队列（workQueue）、拒绝策略（handler）、线程工厂（ThreadFactory）这7个参数。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;回答完包含这几个参数之后，会再主动描述下线程池的执行流程，也就是 execute() 方法执行流程。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;execute()方法执行逻辑如下：&lt;/span&gt;&lt;/p&gt;&lt;pre&gt;&lt;code lang=&quot;java&quot;&gt;&lt;span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-preserve=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;execute&lt;/span&gt;(&lt;span&gt;Runnable command&lt;/span&gt;) &lt;/span&gt;{&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    &lt;span&gt;if&lt;/span&gt; (command == &lt;span&gt;null&lt;/span&gt;)&lt;br mpa-from-tpl=&quot;t&quot;/&gt;        &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; NullPointerException();&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    &lt;span&gt;int&lt;/span&gt; c = ctl.&lt;span&gt;get&lt;/span&gt;();&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    &lt;span&gt;if&lt;/span&gt; (workerCountOf(c) &amp;lt; corePoolSize) {&lt;br mpa-from-tpl=&quot;t&quot;/&gt;        &lt;span&gt;if&lt;/span&gt; (addWorker(command, &lt;span&gt;true&lt;/span&gt;))&lt;br mpa-from-tpl=&quot;t&quot;/&gt;            &lt;span&gt;return&lt;/span&gt;;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;        c = ctl.&lt;span&gt;get&lt;/span&gt;();&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    }&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    &lt;span&gt;if&lt;/span&gt; (isRunning(c) &amp;amp;&amp;amp; workQueue.offer(command)) {&lt;br mpa-from-tpl=&quot;t&quot;/&gt;        &lt;span&gt;int&lt;/span&gt; recheck = ctl.&lt;span&gt;get&lt;/span&gt;();&lt;br mpa-from-tpl=&quot;t&quot;/&gt;        &lt;span&gt;if&lt;/span&gt; (! isRunning(recheck) &amp;amp;&amp;amp; &lt;span&gt;remove&lt;/span&gt;(command))&lt;br mpa-from-tpl=&quot;t&quot;/&gt;            reject(command);&lt;br mpa-from-tpl=&quot;t&quot;/&gt;        &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (workerCountOf(recheck) == &lt;span&gt;0&lt;/span&gt;)&lt;br mpa-from-tpl=&quot;t&quot;/&gt;            addWorker(&lt;span&gt;null&lt;/span&gt;, &lt;span&gt;false&lt;/span&gt;);&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    }&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (!addWorker(command, &lt;span&gt;false&lt;/span&gt;))&lt;br mpa-from-tpl=&quot;t&quot;/&gt;        reject(command);&lt;br mpa-from-tpl=&quot;t&quot;/&gt;}&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;可以总结出如下主要执行流程，当然看上述代码会有一些异常分支判断，可以自己顺理加到下述执行主流程里&lt;/span&gt;&lt;/p&gt;&lt;blockquote&gt;&lt;ol class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;判断线程池的状态，如果不是RUNNING状态，直接执行拒绝策略&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;如果当前线程数 &amp;lt; 核心线程池，则新建一个线程来处理提交的任务&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;如果当前线程数 &amp;gt; 核心线程数且任务队列没满，则将任务放入阻塞队列等待执行&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;如果 核心线程池 &amp;lt; 当前线程池数 &amp;lt; 最大线程数，且任务队列已满，则创建新的线程执行提交的任务&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;如果当前线程数 &amp;gt; 最大线程数，且队列已满，则执行拒绝策略拒绝该任务&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在回答完包含哪些参数及 execute 方法的执行流程后。&lt;/span&gt;&lt;span&gt;然后可以说下这个执行流程是 JUC 标准线程池提供的执行流程，主要用在 CPU 密集型场景下。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;像 Tomcat、Dubbo 这类框架，他们内部的线程池主要用来处理网络 IO 任务的，所以他们都对 JUC 线程池的执行流程进行了调整来支持 IO 密集型场景使用。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;他们提供了阻塞队列 TaskQueue，该队列继承 LinkedBlockingQueue，重写了 offer() 方法来实现执行流程的调整。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-preserve=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;pre&gt;&lt;code&gt;@Override&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    &lt;span&gt;public&lt;/span&gt; boolean offer(Runnable o) {&lt;br mpa-from-tpl=&quot;t&quot;/&gt;        &lt;span&gt;//we can&#x27;t do any checks&lt;/span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;        &lt;span&gt;if&lt;/span&gt; (&lt;span&gt;parent&lt;/span&gt;==&lt;span&gt;null&lt;/span&gt;) &lt;span&gt;return&lt;/span&gt; super.offer(o);&lt;br mpa-from-tpl=&quot;t&quot;/&gt;        &lt;span&gt;//we are maxed out on threads, simply queue the object&lt;/span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;        &lt;span&gt;if&lt;/span&gt; (&lt;span&gt;parent&lt;/span&gt;.getPoolSize() == &lt;span&gt;parent&lt;/span&gt;.getMaximumPoolSize()) &lt;span&gt;return&lt;/span&gt; super.offer(o);&lt;br mpa-from-tpl=&quot;t&quot;/&gt;        &lt;span&gt;//we have idle threads, just add it to the queue&lt;/span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;        &lt;span&gt;if&lt;/span&gt; (&lt;span&gt;parent&lt;/span&gt;.getSubmittedCount()&amp;lt;=(&lt;span&gt;parent&lt;/span&gt;.getPoolSize())) &lt;span&gt;return&lt;/span&gt; super.offer(o);&lt;br mpa-from-tpl=&quot;t&quot;/&gt;        &lt;span&gt;//if we have less threads than maximum force creation of a new thread&lt;/span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;        &lt;span&gt;if&lt;/span&gt; (&lt;span&gt;parent&lt;/span&gt;.getPoolSize()&amp;lt;&lt;span&gt;parent&lt;/span&gt;.getMaximumPoolSize()) &lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;        &lt;span&gt;//if we reached here, we need to add it to the queue&lt;/span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;        &lt;span&gt;return&lt;/span&gt; super.offer(o);&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    }&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;可以看到他在入队之前做了几个判断，这里的 parent 就是所属的线程池对象&lt;/span&gt;&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;&lt;span&gt;1.如果 parent 为 null，直接调用父类 offer 方法入队&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;2.如果当前线程数等于最大线程数，则直接调用父类 offer()方法入队&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;3.如果当前未执行的任务数量小于等于当前线程数，仔细思考下，是不是说明有空闲的线程呢，那么直接调用父类 offer() 入队后就马上有线程去执行它&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;4.如果当前线程数小于最大线程数量，则直接返回 false，然后回到 JUC 线程池的执行流程回想下，是不是就去添加新线程去执行任务了呢&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;5.其他情况都直接入队&lt;/span&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;可以看出当当前线程数大于核心线程数时，JUC 原生线程池首先是把任务放到队列里等待执行，而不是先创建线程执行。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;如果 Tomcat 接收的请求数量大于核心线程数，请求就会被放到队列中，等待核心线程处理，这样会降低请求的总体响应速度。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;所以 Tomcat并没有使用 JUC 原生线程池，利用 TaskQueue 的 offer() 方法巧妙的修改了 JUC 线程池的执行流程，改写后 Tomcat 线程池执行流程如下：&lt;/span&gt;&lt;/p&gt;&lt;blockquote&gt;&lt;ol class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;判断如果当前线程数小于核心线程池，则新建一个线程来处理提交的任务&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;如果当前当前线程池数大于核心线程池，小于最大线程数，则创建新的线程执行提交的任务&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;如果当前线程数等于最大线程数，则将任务放入任务队列等待执行&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;如果队列已满，则执行拒绝策略&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;span&gt;然后还可以再说下线程池的 Worker 线程模型，继承 AQS 实现了锁机制。线程启动后执行 runWorker() 方法，runWorker() 方法中调用 getTask() 方法从阻塞队列中获取任务，获取到任务后先执行 beforeExecute() 钩子函数，再执行任务，然后再执行 afterExecute() 钩子函数。若超时获取不到任务会调用 processWorkerExit() 方法执行 Worker 线程的清理工作。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;img data-ratio=&quot;0.06451612903225806&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/01NCBYDP9ZfkwrnCoIlkXhdAZbvSQoo0P17WWyOtfcfypVW5ic2ibUZHEXIuYjH409ebVxiar8pn7dx5yHGpWWV8A/640?wx_fmt=png&quot; data-w=&quot;310&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/p&gt;&lt;h4 data-id=&quot;heading-2&quot;&gt;&lt;span&gt;&lt;strong&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h4&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong mpa-from-tpl=&quot;t&quot;&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;3. 面试官：什么是阻塞队列？说说常用的阻塞队列有哪些？&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h4&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;阻塞队列 BlockingQueue 继承 Queue，是我们熟悉的基本数据结构队列的一种特殊类型。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;当从阻塞队列中获取数据时，如果队列为空，则等待直到队列有元素存入。当向阻塞队列中存入元素时，如果队列已满，则等待直到队列中有元素被移除。提供 offer()、put()、take()、poll() 等常用方法。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;JDK 提供的阻塞队列的实现有以下几种：&lt;/span&gt;&lt;/strong&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;1）ArrayBlockingQueue：由数组实现的有界阻塞队列，该队列按照 FIFO 对元素进行排序。维护两个整形变量，标识队列头尾在数组中的位置，在生产者放入和消费者获取数据共用一个锁对象，意味着两者无法真正的并行运行，性能较低。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;2）LinkedBlockingQueue：由链表组成的有界阻塞队列，如果不指定大小，默认使用 Integer.MAX_VALUE 作为队列大小，该队列按照 FIFO 对元素进行排序，对生产者和消费者分别维护了独立的锁来控制数据同步，意味着该队列有着更高的并发性能。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;3）SynchronousQueue：不存储元素的阻塞队列，无容量，可以设置公平或非公平模式，插入操作必须等待获取操作移除元素，反之亦然。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;4）PriorityBlockingQueue：支持优先级排序的无界阻塞队列，默认情况下根据自然序排序，也可以指定 Comparator。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;5）DelayQueue：支持延时获取元素的无界阻塞队列，创建元素时可以指定多久之后才能从队列中获取元素，常用于缓存系统或定时任务调度系统。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;6）LinkedTransferQueue：一个由链表结构组成的无界阻塞队列，与LinkedBlockingQueue相比多了transfer和tryTranfer方法，该方法在有消费者等待接收元素时会立即将元素传递给消费者。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;7）LinkedBlockingDeque：一个由链表结构组成的双端阻塞队列，可以从队列的两端插入和删除元素。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.06451612903225806&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/01NCBYDP9ZfkwrnCoIlkXhdAZbvSQoo0P17WWyOtfcfypVW5ic2ibUZHEXIuYjH409ebVxiar8pn7dx5yHGpWWV8A/640?wx_fmt=png&quot; data-w=&quot;310&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong mpa-from-tpl=&quot;t&quot;&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;4. 面试官：你刚说到了 Worker 继承 AQS 实现了锁机制，那 ThreadPoolExecutor 都用到了哪些锁？为什么要用锁？&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h4&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;p mpa-is-content=&quot;t&quot;&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;1）mainLock 锁&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;ThreadPoolExecutor 内部维护了 ReentrantLock 类型锁 mainLock，在访问 workers 成员变量以及进行相关数据统计记账（比如访问 largestPoolSize、completedTaskCount）时需要获取该重入锁。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;面试官：为什么要有 mainLock？&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-preserve=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; ReentrantLock mainLock = &lt;span&gt;new&lt;/span&gt; ReentrantLock();&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    &lt;span&gt;/**&lt;br mpa-from-tpl=&quot;t&quot;/&gt;     * Set containing all worker threads in pool. Accessed only when&lt;br mpa-from-tpl=&quot;t&quot;/&gt;     * holding mainLock.&lt;br mpa-from-tpl=&quot;t&quot;/&gt;     */&lt;/span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; HashSet&amp;lt;Worker&amp;gt; workers = &lt;span&gt;new&lt;/span&gt; HashSet&amp;lt;Worker&amp;gt;();&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    &lt;span&gt;/**&lt;br mpa-from-tpl=&quot;t&quot;/&gt;     * Tracks largest attained pool size. Accessed only under&lt;br mpa-from-tpl=&quot;t&quot;/&gt;     * mainLock.&lt;br mpa-from-tpl=&quot;t&quot;/&gt;     */&lt;/span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    &lt;span&gt;private&lt;/span&gt; int largestPoolSize;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    &lt;span&gt;/**&lt;br mpa-from-tpl=&quot;t&quot;/&gt;     * Counter for completed tasks. Updated only on termination of&lt;br mpa-from-tpl=&quot;t&quot;/&gt;     * worker threads. Accessed only under mainLock.&lt;br mpa-from-tpl=&quot;t&quot;/&gt;     */&lt;/span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    &lt;span&gt;private&lt;/span&gt; long completedTaskCount;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;可以看到 workers 变量用的 HashSet 是线程不安全的，是不能用于多线程环境的。largestPoolSize、completedTaskCount 也是没用 volatile 修饰，所以需要在锁的保护下进行访问。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;面试官：&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;为什么不直接用个线程安全容器呢？&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;其实 Doug 老爷子在 mainLock 变量的注释上解释了，意思就是说事实证明，相比于线程安全容器，此处更适合用 lock，主要原因之一就是串行化 interruptIdleWorkers() 方法，避免了不必要的中断风暴&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;面试官：&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;怎么理解这个中断风暴呢？&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;其实简单理解就是如果不加锁，interruptIdleWorkers() 方法在多线程访问下就会发生这种情况。一个线程调用interruptIdleWorkers() 方法对 Worker 进行中断，此时该 Worker 出于中断中状态，此时又来一个线程去中断正在中断中的 Worker 线程，这就是所谓的中断风暴。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;面试官：&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;那 largestPoolSize、completedTaskCount 变量加个 volatile 关键字修饰是不是就可以不用 mainLock 了？&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;这个其实 Doug 老爷子也考虑到了，其他一些内部变量能用 volatile 的都加了 volatile 修饰了，这两个没加主要就是为了保证这两个参数的准确性，在获取这两个值时，能保证获取到的一定是修改方法执行完成后的值。如果不加锁，可能在修改方法还没执行完成时，此时来获取该值，获取到的就是修改前的值。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;p mpa-is-content=&quot;t&quot;&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;2）Worker 线程锁&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;刚也说了 Worker 线程继承 AQS，实现了 Runnable 接口，内部持有一个 Thread 变量，一个 firstTask，及 completedTasks 三个成员变量。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;基于 AQS 的 acquire()、tryAcquire() 实现了 lock()、tryLock() 方法，类上也有注释，该锁主要是用来维护运行中线程的中断状态。在 runWorker() 方法中以及刚说的 interruptIdleWorkers() 方法中用到了。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;面试官：&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;这个维护运行中线程的中断状态怎么理解呢？&lt;/span&gt;&lt;/p&gt;&lt;pre&gt;&lt;code lang=&quot;java&quot;&gt;&lt;span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-preserve=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;protected&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; &lt;span&gt;tryAcquire&lt;/span&gt;&lt;span&gt;(&lt;span&gt;int&lt;/span&gt; unused)&lt;/span&gt; &lt;/span&gt;{&lt;br mpa-from-tpl=&quot;t&quot;/&gt;      &lt;span&gt;if&lt;/span&gt; (compareAndSetState(&lt;span&gt;0&lt;/span&gt;, &lt;span&gt;1&lt;/span&gt;)) {&lt;br mpa-from-tpl=&quot;t&quot;/&gt;          setExclusiveOwnerThread(Thread.currentThread());&lt;br mpa-from-tpl=&quot;t&quot;/&gt;          &lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;      }&lt;br mpa-from-tpl=&quot;t&quot;/&gt;      &lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;  }&lt;br mpa-from-tpl=&quot;t&quot;/&gt;  &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;lock&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;        &lt;/span&gt;{ acquire(&lt;span&gt;1&lt;/span&gt;); }&lt;br mpa-from-tpl=&quot;t&quot;/&gt;  &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; &lt;span&gt;tryLock&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;  &lt;/span&gt;{ &lt;span&gt;return&lt;/span&gt; tryAcquire(&lt;span&gt;1&lt;/span&gt;); }&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在runWorker() 方法中获取到任务开始执行前，需要先调用 w.lock() 方法，lock() 方法会调用 tryAcquire() 方法，tryAcquire() 实现了一把非重入锁，通过 CAS 实现加锁。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.4307228915662651&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz/1J6IbIcPCLaRf8gwR5lGpYybM87ib19wcZDELXiaCwtBbbmwZxfiaWZ0LJvVjI8uuH41icTRgjXeOXZH6LWAKePTfA/640?wx_fmt=jpeg&quot; data-type=&quot;other&quot; data-w=&quot;664&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;interruptIdleWorkers() 方法会中断那些等待获取任务的线程，会调用 w.tryLock() 方法来加锁，如果一个线程已经在执行任务中，那么 tryLock() 就获取锁失败，就保证了不能中断运行中的线程了。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.38088012139605465&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz/1J6IbIcPCLaRf8gwR5lGpYybM87ib19wclhExKhfVOxCUdCY9gHfeA8R6LsGibzf7Y3TmTfKEJIkWO5pda3hdhjg/640?wx_fmt=jpeg&quot; data-type=&quot;other&quot; data-w=&quot;659&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;所以 Worker 继承 AQS 主要就是为了实现了一把非重入锁，维护线程的中断状态，保证不能中断运行中的线程。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;img data-ratio=&quot;0.06451612903225806&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/01NCBYDP9ZfkwrnCoIlkXhdAZbvSQoo0P17WWyOtfcfypVW5ic2ibUZHEXIuYjH409ebVxiar8pn7dx5yHGpWWV8A/640?wx_fmt=png&quot; data-w=&quot;310&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/p&gt;&lt;h4 data-id=&quot;heading-4&quot;&gt;&lt;span&gt;&lt;strong&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h4&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong mpa-from-tpl=&quot;t&quot;&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;5. 面试官：你在项目中是怎样使用线程池的？Executors 了解吗？&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h4&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;这里面试官主要想知道你日常工作中使用线程池的姿势，现在大多数公司都在遵循阿里巴巴 Java 开发规范，该规范里明确说明不允许使用
Executors 创建线程池，而是通过 ThreadPoolExecutor 显示指定参数去创建&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;你可以这样说，知道 Executors 工具类，很久之前有用过，也踩过坑，Executors 创建的线程池有发生 OOM 的风险。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Executors.newFixedThreadPool 和 Executors.SingleThreadPool 创建的线程池内部使用的是无界（Integer.MAX_VALUE）的 LinkedBlockingQueue 队列，可能会堆积大量请求，导致 OOM&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Executors.newCachedThreadPool 和Executors.scheduledThreadPool 创建的线程池最大线程数是用的Integer.MAX_VALUE，可能会创建大量线程，导致 OOM&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;自己在日常工作中也有封装类似的工具类，但是都是内存安全的，参数需要自己指定适当的值，也有基于 LinkedBlockingQueue 实现了内存安全阻塞队列 MemorySafeLinkedBlockingQueue，当系统内存达到设置的剩余阈值时，就不在往队列里添加任务了，避免发生 OOM&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;我们一般都是在 Spring 环境中使用线程池的，直接使用 JUC 原生 ThreadPoolExecutor 有个问题，Spring 容器关闭的时候可能任务队列里的任务还没处理完，有丢失任务的风险。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;我们知道 Spring 中的 Bean 是有生命周期的，如果 Bean 实现了 Spring 相应的生命周期接口（InitializingBean、DisposableBean接口），在 Bean 初始化、容器关闭的时候会调用相应的方法来做相应处理。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;所以最好不要直接使用 ThreadPoolExecutor 在 Spring 环境中，&lt;strong&gt;可以使用 Spring 提供的 ThreadPoolTaskExecutor，或者 DynamicTp 框架提供的 DtpExecutor 线程池实现。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;也会按业务类型进行线程池隔离，各任务执行互不影响，避免共享一个线程池，任务执行参差不齐，相互影响，高耗时任务会占满线程池资源，导致低耗时任务没机会执行；同时如果任务之间存在父子关系，可能会导致死锁的发生，进而引发 OOM。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;img data-ratio=&quot;0.06451612903225806&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/01NCBYDP9ZfkwrnCoIlkXhdAZbvSQoo0P17WWyOtfcfypVW5ic2ibUZHEXIuYjH409ebVxiar8pn7dx5yHGpWWV8A/640?wx_fmt=png&quot; data-w=&quot;310&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/p&gt;&lt;h4 data-id=&quot;heading-5&quot;&gt;&lt;span&gt;&lt;strong&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h4&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong mpa-from-tpl=&quot;t&quot;&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;6. 面试官：刚你说到了通过 ThreadPoolExecutor 来创建线程池，那核心参数设置多少合适呢？&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h4&gt;&lt;/section&gt;&lt;/section&gt;&lt;h4 data-id=&quot;heading-5&quot;&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p&gt;&lt;span&gt;这个问题该怎么回答呢？&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;可能很多人都看到过《Java 并发编程事件》这本书里介绍的一个线程数计算公式：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Ncpu = CPU 核数&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Ucpu = 目标 CPU 利用率，0 &amp;lt;= Ucpu &amp;lt;= 1&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;W / C = 等待时间 / 计算时间的比例&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;要程序跑到 CPU 的目标利用率，需要的线程数为：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Nthreads = Ncpu * Ucpu * (1 + W / C)&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;这公式太偏理论化了，很难实际落地下来，首先很难获取准确的等待时间和计算时间。再着一个服务中会运行着很多线程，比如 Tomcat 有自己的线程池、Dubbo 有自己的线程池、GC 也有自己的后台线程，我们引入的各种框架、中间件都有可能有自己的工作线程，这些线程都会占用 CPU 资源，所以通过此公式计算出来的误差一定很大。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;所以说怎么确定线程池大小呢？&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;其实没有固定答案，需要通过压测不断的动态调整线程池参数，观察 CPU 利用率、系统负载、GC、内存、RT、吞吐量 等各种综合指标数据，来找到一个相对比较合理的值。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;所以不要再问设置多少线程合适了，这个问题没有标准答案，需要结合业务场景，设置一系列数据指标，排除可能的干扰因素，注意链路依赖（比如连接池限制、三方接口限流），然后通过不断动态调整线程数，测试找到一个相对合适的值。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.06451612903225806&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/01NCBYDP9ZfkwrnCoIlkXhdAZbvSQoo0P17WWyOtfcfypVW5ic2ibUZHEXIuYjH409ebVxiar8pn7dx5yHGpWWV8A/640?wx_fmt=png&quot; data-w=&quot;310&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/p&gt;&lt;h4 data-id=&quot;heading-6&quot;&gt;&lt;span&gt;&lt;strong&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h4&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong mpa-from-tpl=&quot;t&quot;&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;7. 面试官：你们线程池是咋监控的？&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h4&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;因为线程池的运行相对而言是个黑盒，它的运行我们感知不到，该问题主要考察怎么感知线程池的运行情况。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;可以这样回答：&lt;/span&gt;&lt;/strong&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;我们自己对线程池 ThreadPoolExecutor 做了一些增强，做了一个线程池管理框架。主要功能有监控告警、动态调参。主要利用了 ThreadPoolExecutor 类提供&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;的一些 set、get方法以及一些钩子函数。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;动态调参是基于配置中心实现的，核心参数配置在配置中心，可以随时调整、实时生效，利用了线程池提供的 set 方法。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;监控，主要就是利用线程池提供的一些 get 方法来获取一些指标数据，然后采集数据上报到监控系统进行大盘展示。也提供了 Endpoint 实时查看线程池指标数据。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;同时定义了5种告警规则。&lt;/span&gt;&lt;/p&gt;&lt;blockquote&gt;&lt;ol class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;线程池活跃度告警。活跃度 = activeCount / maximumPoolSize，当活跃度达到配置的阈值时，会进行事前告警。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;队列容量告警。容量使用率 = queueSize / queueCapacity，当队列容量达到配置的阈值时，会进行事前告警。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;拒绝策略告警。当触发拒绝策略时，会进行告警。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;任务执行超时告警。重写 ThreadPoolExecutor 的 afterExecute() 和 beforeExecute()，根据当前时间和开始时间的差值算出任务执行时长，超过配置的阈值会触发告警。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;任务排队超时告警。重写 ThreadPoolExecutor 的  beforeExecute()，记录提交任务时时间，根据当前时间和提交时间的差值算出任务排队时长，超过配置的阈值会触发告警&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;span&gt;通过监控+告警可以让我们及时感知到我们业务线程池的执行负载情况，第一时间做出调整，防止事故的发生。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.06451612903225806&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/01NCBYDP9ZfkwrnCoIlkXhdAZbvSQoo0P17WWyOtfcfypVW5ic2ibUZHEXIuYjH409ebVxiar8pn7dx5yHGpWWV8A/640?wx_fmt=png&quot; data-w=&quot;310&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/p&gt;&lt;h4 data-id=&quot;heading-7&quot;&gt;&lt;span&gt;&lt;strong&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h4&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong mpa-from-tpl=&quot;t&quot;&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;8. 面试官：你在使用线程池的过程中遇到过哪些坑或者需要注意的地方？&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h4&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;这个问题其实也是在考察你对一些细节的掌握程度，就全甩锅给年轻刚毕业没经验的自己就行。&lt;/span&gt;&lt;span&gt;可以适当多说些，也证明自己对线程池有着丰富的使用经验。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;1）OOM 问题。刚开始使用线程都是通过 Executors 创建的，前面说了，这种方式创建的线程池会有发生 OOM 的风险。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;2）任务执行异常丢失问题。可以通过下述4种方式解决&lt;/span&gt;&lt;/p&gt;&lt;blockquote&gt;&lt;ol class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;在任务代码中增加 try、catch 异常处理&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;如果使用的 Future 方式，则可通过 Future 对象的 get 方法接收抛出的异常&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;为工作线程设置 setUncaughtExceptionHandler，在 uncaughtException 方法中处理异常&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;可以重写 afterExecute(Runnable r, Throwable t) 方法，拿到异常 t&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;span&gt;3）共享线程池问题。整个服务共享一个全局线程池，导致任务相互影响，耗时长的任务占满资源，短耗时任务得不到执行。同时父子线程间会导致死锁的发生，今儿导致 OOM&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;4）跟 ThreadLocal 配合使用，导致脏数据问题。我们知道 Tomcat 利用线程池来处理收到的请求，会复用线程，如果我们代码中用到了 ThreadLocal，在请求处理完后没有去 remove，那每个请求就有可能获取到之前请求遗留的脏值。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;5）ThreadLocal 在线程池场景下会失效，可以考虑用阿里开源的 Ttl 来解决&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;以上提到的线程池动态调参、通知告警在开源动态线程池项目 DynamicTp 中已经实现了，可以直接引入到自己项目中使用。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;h2 data-id=&quot;heading-8&quot;&gt;&lt;span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/span&gt;&lt;/h2&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;p mpa-is-content=&quot;t&quot;&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;关于 DynamicTp&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;h2 data-id=&quot;heading-8&quot;&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p&gt;&lt;span&gt;DynamicTp 是一个基于配置中心实现的轻量级动态线程池管理工具，主要功能可以总结为动态调参、通知报警、运行监控、三方包线程池管理等几大类。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.22274881516587677&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz/1J6IbIcPCLaRf8gwR5lGpYybM87ib19wcOxWhlqoFAreEnVHsx60k8uPk676DWxTRsd6rR6KajpfBU8bnlqEicpg/640?wx_fmt=jpeg&quot; data-type=&quot;other&quot; data-w=&quot;1266&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;经过多个版本迭代，目前最新版本 &lt;strong&gt;v1.0.8&lt;/strong&gt; 具有以下特性&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;特性&lt;/strong&gt; &lt;/span&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;代码零侵入&lt;/strong&gt;：所有配置都放在配置中心，对业务代码零侵入&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;轻量简单&lt;/strong&gt;：基于 springboot 实现，引入 starter，接入只需简单4步就可完成，顺利3分钟搞定&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;高可扩展&lt;/strong&gt;：框架核心功能都提供 SPI 接口供用户自定义个性化实现（配置中心、配置文件解析、通知告警、监控数据采集、任务包装等等）&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;线上大规模应用&lt;/strong&gt;：参考&lt;/span&gt;&lt;span&gt;美团线程池实践&lt;/span&gt;&lt;span&gt;（https://tech.meituan.com/2020/04/02/java-pooling-pratice-in-meituan.html）&lt;/span&gt;&lt;span&gt;，美团内部已经有该理论成熟的应用经验&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;多平台通知报警&lt;/strong&gt;：提供多种报警维度（配置变更通知、活性报警、容量阈值报警、拒绝触发报警、任务执行或等待超时报警），已支持企业微信、钉钉、飞书报警，同时提供 SPI 接口可自定义扩展实现&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;监控&lt;/strong&gt;：定时采集线程池指标数据，支持通过 MicroMeter、JsonLog 日志输出、Endpoint 三种方式，可通过 SPI 接口自定义扩展实现&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;任务增强&lt;/strong&gt;：提供任务包装功能，实现TaskWrapper接口即可，如 MdcTaskWrapper、TtlTaskWrapper、SwTraceTaskWrapper，可以支持线程池上下文信息传递&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;兼容性&lt;/strong&gt;：JUC 普通线程池和 Spring 中的 ThreadPoolTaskExecutor 也可以被框架监控，@Bean 定义时加 @DynamicTp 注解即可&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;可靠性&lt;/strong&gt;：框架提供的线程池实现 Spring 生命周期方法，可以在 Spring 容器关闭前尽可能多的处理队列中的任务&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;多模式&lt;/strong&gt;：参考Tomcat线程池提供了 IO 密集型场景使用的 EagerDtpExecutor 线程池&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;支持多配置中心&lt;/strong&gt;：基于主流配置中心实现线程池参数动态调整，实时生效，已支持 Nacos、Apollo、Zookeeper、Consul、Etcd，同时也提供 SPI 接口可自定义扩展实现&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;中间件线程池管理&lt;/strong&gt;：集成管理常用第三方组件的线程池，已集成Tomcat、Jetty、Undertow、Dubbo、RocketMq、Hystrix等组件的线程池管理（调参、监控报警）&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 data-id=&quot;heading-9&quot;&gt;&lt;span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/span&gt;&lt;/h2&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;p mpa-is-content=&quot;t&quot;&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;项目地址&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;目前累计 1.7k star，感谢你的 star，欢迎 pr，业务之余一起给开源贡献一份力量&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;官网&lt;/strong&gt;：https://dynamictp.cn/&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;gitee地址&lt;/strong&gt;：https://gitee.com/dromara/dynamic-tp&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;&lt;section class=&quot;channels_iframe_wrp&quot;&gt;&lt;mpvideosnap class=&quot;js_uneditable custom_select_card channels_iframe videosnap_video_iframe&quot; data-pluginname=&quot;videosnap&quot; data-id=&quot;export/UzFfAgtgekIEAQAAAAAAog8z0-8GmQAAAAstQy6ubaLX4KHWvLEZgBPE9KJYWj5rLZb8zNPgMIsBlZXI7By1FOoD9IS8ocBL&quot; data-url=&quot;https://findermp.video.qq.com/251/20304/stodownload?encfilekey=rjD5jyTuFrIpZ2ibE8T7YmwgiahniaXswqz6bwvxz6OrscibFX1ibWpLcal8LmZQxsKazULgWADWKPHSicr38aylic84KAU32icFn1AYCh66tt1vA25waA0bgn6elg&amp;amp;adaptivelytrans=0&amp;amp;bizid=1023&amp;amp;dotrans=0&amp;amp;hy=SH&amp;amp;idx=1&amp;amp;m=&amp;amp;scene=0&amp;amp;token=AxricY7RBHdVCV6RaHVQu6KuibBT8ZN7Ze1icAHsib93o1RcVItKibvOPdWBB8E6okxztZovnAe7tUGI&quot; data-headimgurl=&quot;http://wx.qlogo.cn/finderhead/Q3auHgzwzM5nv7YHhmhvPsGGX04JCIgibK2x2Ru0TOY9HeZTGSIL1KQ/0&quot; data-username=&quot;v2_060000231003b20faec8c5e08a1fc3d5c807ec30b07756771265bc6b6234fb9e05062ae69ab4@finder&quot; data-nickname=&quot;儒猿IT&quot; data-desc=&quot;可能很多兄弟都听说过Java线程池的理论原理，但是没在高并发环境下玩儿过Java线程池的优化！#Java #Java线程池 #高并发 @微信时刻 &quot; data-nonceid=&quot;14456131982360074779&quot; data-type=&quot;video&quot; data-width=&quot;1920&quot; data-height=&quot;1080&quot;/&gt;&lt;/section&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.21428571428571427&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/84QSpkgaj14GBzMnf1ibXkydLwCmhrWBooDwrdnlqYlsyB5PetG1T1oXxJ63G8TK58dqkDo7uzR7bKic50DxbTQQ/640?wx_fmt=png&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; data-w=&quot;336&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6538461538461539&quot; data-w=&quot;52&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/BXOuoE8lPAIR47zmQ1XOqSQszO2PjLgkgakpDZQSsUkLLnGszEu0eyGjvHNRqu6picb2kicC4lo95WZGiaxqibqW4A/640?wx_fmt=png&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot;/&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p data-mid=&quot;&quot; mpa-is-content=&quot;t&quot;&gt;&lt;span&gt;欢迎扫码加入儒猿技术交流群，每天晚上20:00都有Java面试、Redis、MySQL、RocketMQ、SpringCloudAlibaba、Java架构等技术答疑分享，更能跟小伙伴们一起交流技术&lt;/span&gt;&lt;nobr data-mid=&quot;&quot;/&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;267&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;267&quot; data-galleryid=&quot;&quot; data-ratio=&quot;1&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/1J6IbIcPCLbPrUTW4zORxkXJU3pH9mPiawH9oZtZGKTkHyVL2wemkqNmPoJKDZlAt5ibgr2CibGkffw2ozqicds4gw/640?wx_fmt=png&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; data-type=&quot;png&quot; data-w=&quot;396&quot;/&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-id=&quot;41056&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-id=&quot;41056&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;p&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-id=&quot;94152&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-width=&quot;100%&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-autoskip=&quot;1&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p mpa-is-content=&quot;t&quot;&gt;&lt;span&gt;&lt;strong&gt;另外推荐儒猿课堂的1元系列课程给您，欢迎加入一起学习~&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p mpa-is-content=&quot;t&quot;&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;互联网Java工程师面试突击课&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;（1元专享）&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;1&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/1J6IbIcPCLZn0ZLz1APC2Hxj148icL295hjkFx86RFTZFibdBopicpMl5Scptaibp0pQAe5jUBMtXym9w4CncFBHsQ/640?wx_fmt=png&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; data-type=&quot;png&quot; data-w=&quot;160&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;SpringCloudAlibaba零基础入门到项目实战&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;（1元专享）&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;1&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/1J6IbIcPCLZn0ZLz1APC2Hxj148icL295NSLHaU5cHQTtyG2K5uK4iaA70v1g50BoQIRUVz4FBN1iahXdqc1M99Ww/640?wx_fmt=png&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; data-type=&quot;png&quot; data-w=&quot;160&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;亿级流量下的电商详情页系统实战项目&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;（1元专享）&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;1&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/1J6IbIcPCLZn0ZLz1APC2Hxj148icL295I9n8XXUWoEeuogklrbj2QN4JZ6cdgYeRys5CCsml2tkFfibLXdeqoFA/640?wx_fmt=png&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; data-type=&quot;png&quot; data-w=&quot;160&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;Kafka消息中间件内核源码精讲&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;（1元专享）&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;1&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/1J6IbIcPCLZn0ZLz1APC2Hxj148icL295yiaEcp1k5HBVycE8BGD0lGz5NZmKWmKXUtSBS7Jnm4FkTY8R5XFZkPw/640?wx_fmt=png&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; data-type=&quot;png&quot; data-w=&quot;160&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;12个实战案例带你玩转Java并发编程&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;（1元专享）&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;1&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/1J6IbIcPCLZn0ZLz1APC2Hxj148icL295WWU9o0Pj51xAIa2qCs9xD2rdDIRLriaibePNSrWJVCknYn6b5lrF3CQQ/640?wx_fmt=png&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; data-type=&quot;png&quot; data-w=&quot;160&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;Elasticsearch零基础入门到精通&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;（1元专享）&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;1&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/1J6IbIcPCLZn0ZLz1APC2Hxj148icL295QdxHC6HadPfaakPOo7DxxQpLH19lMZH0yAwRI3iajVXblNnwfMxBk9A/640?wx_fmt=png&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; data-type=&quot;png&quot; data-w=&quot;160&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;基于Java手写分布式中间件系统实战&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;（1元专享）&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;1&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/1J6IbIcPCLZn0ZLz1APC2Hxj148icL295r0mR5hhVpAlXTAZzlVvSg1dxegAaZrIZ9ftePV5QQQg2ibIZbiaA6CCg/640?wx_fmt=png&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; data-type=&quot;png&quot; data-w=&quot;160&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;基于ShardingSphere的分库分表实战课&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;（1元专享）&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;1&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/1J6IbIcPCLZn0ZLz1APC2Hxj148icL295hicEliaIKPfLpHqQAo4CdAorqyxd9HvqD8sADicO7wFHGJxNtRus6LlBA/640?wx_fmt=png&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; data-type=&quot;png&quot; data-w=&quot;160&quot;/&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;/div&gt;

          

          
          &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>ca3362c94da19fea9c1975ae7876c80c</guid>
<title>HiveServer2 内存泄漏问题定位与优化方案</title>
<link>https://toutiao.io/k/zvgtzdc</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;/h1&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;动手点关注 干货不迷路 👇&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p class=&quot;mp_profile_iframe_wrp&quot;&gt;&lt;mp-common-profile class=&quot;js_uneditable js_wx_tap_highlight&quot; data-pluginname=&quot;mpprofile&quot; data-id=&quot;MzI1MzYzMjE0MQ==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/5EcwYhllQOhkoWTP1gVm0Lqs480XOARyoSYjPEsRVCSF35cbWIp6cliaYic8KUfNfiaSjVnruzTQUTCA0lmv9vUmw/0?wx_fmt=png&quot; data-nickname=&quot;字节跳动技术团队&quot; data-alias=&quot;BytedanceTechBlog&quot; data-signature=&quot;字节跳动的技术实践分享&quot; data-from=&quot;2&quot; data-is_biz_ban=&quot;0&quot; has-insert-preloading=&quot;1&quot; data-index=&quot;0&quot; data-origin_num=&quot;230&quot; data-isban=&quot;0&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;前言&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;HiveServer2 属于 Hive 组件的一个服务，主要提供 Hive 访问接口，例如可通过 JDBC 的方式提交 Hive 作业，HiveServer2 基于 Java 开发，整个服务运行过程中，内存的管理回收均由 JVM 进行控制。在 JVM 语言中的内存泄漏与 C/C++ 语言的内存泄漏会有些差异，JVM 的内存泄漏更多的是业务代码逻辑错误引起大量对象引用被持有，导致多次 GC 均无法被回收，或者部分对象占用内存过大，直接超过 JVM 分配的内存上限，导致 JVM 内存耗尽，引起 JVM 的 OOM。这种情况下该 JVM 服务会停止响应并且退出，但是并不会引起操作系统的崩溃。&lt;/p&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;背景&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;近期收到反馈，一套开启高可用的 EMR 集群中的 HiveServer2 一段时间后便会停止服务，此集群的 HiveServer2 一共有3个节点，状态信息注册至 Zookeeper 中，提供 HA 的能力，一段时间后几乎3个节点都会停止服务，通过对 HiveServer2 的日志查看发现是大量的 FULL GC后出现 OOM：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.50703125&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/5EcwYhllQOjhwauW8aQwqs2R8V6a2jLm0PFsZ1PXiaYOlI8FbArERvec6iaEKD6T0KCATeAamibvwf9Pfkwh1icwrQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;了解到该集群是一套从线下私有化部署的集群迁移而来，迁移前的集群中 HiveServer2 的 heapsize 为 2G，于是为了对齐业务参数将 heapsize 调整至 2G，间隔一天后，再次收到反馈，OOM 的问题依旧存在，查看日志，问题依旧是 HiveServer2 发生了 OOM，由于参数已经对齐之前的配置，那么问题可能不单纯是内存不足，可能会有其他问题。于是首先将 HiveServer2 的 heapsize 调整为 4G，确保可以在一定时间内稳定运行，留下定位时间。&lt;/p&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;定位&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;定位方向为两个方向：一个是分析 dump file，查看在内存不足的时候，内存消耗在哪些地方；第二个方向是针对日志进行细粒度分析，确保整个流程执行顺序是合理的。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.45390625&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/5EcwYhllQOjhwauW8aQwqs2R8V6a2jLmtLECEhFdcDMrCH1clsFic0EINmc1Q1V0uibLJPq8ibPmLItBUicfNnLNqg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;通过对 JVM 的 dump 文件进行分析，定位到在发生 HiveServer2 的 OOM 的时候，queryIdOperation 这个 ConcurrentHashMap 占据了大量的内存，而此时 HiveServer2 的负载非常低。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.0765625&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/5EcwYhllQOjhwauW8aQwqs2R8V6a2jLmS4E8knoWCHTcEziaQNxnJf2KdTRibnLjBbNFn3xhn35PGOfEX5ic9Hribg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;再基于具体的 QueryId 进行跟踪日志，HiveServer2 对作业处理的逻辑为在建立 Connection 的时候会调用一次 OpenSession，拿到一个HiveConnection 对象，此后便通过 HiveConnection 对象调用 ExecuteStatement 执行 SQL，后台每接收到一个 SQL 作业便生成一个 Operation 对象用来对 SQL 作业实现隔离。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;每一个 Operation 有自己独立的 QueryId，每条 SQL 作业会经历编译，执行，关闭环节，注意此关闭指的是关闭当前执行的 SQL 作业，而不是关闭整个 HiveServer2 的连接，基于此思路追踪日志，发现部分 QueryId 没有执行 Close operation 方法。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5284450063211125&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/5EcwYhllQOjhwauW8aQwqs2R8V6a2jLm0lg55jtW3AY93vVXBRI8AiayyWsjricIWGTIKiaiaZ9piaxUZFodv48ia3YA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1582&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;有了这个思路后，再对 Hive 的源码进行查阅，发现 Close operation 方法被调用的前提是在一个名称为 queryIdOperation 的 Map 对象中可以找出 QueryId，如果没有从 queryIdOperation 找到合法的 QueryId，则不会触发 Close 方法。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;再结合前面的堆栈图，其中 queryIdOperation 占据了大量的内存，于是基本可以确定定位出问题的原因，为当 SQL 执行结束后，有一个 queryIdOperation 的 Map 对象，没有成功的移除内部的内容，导致该 Map 越来越大，最后导致 HiveServer2 内存耗尽，出现 OOM，有了这个大概的思路，就需要仔细分析为什么会出现这个问题，从而找到具体的解决方案。&lt;/p&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;分析&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在解决这个问题之前，先对 HiveServer2 本身做一个分析，HiveServer2 不同于一般的数据库服务，HiveServer2 是由一系列的 RPC 接口组成，具体的接口定义在 org.apache.hive.service.rpc.thrift 包下的 TCLIService.Iface 中，部分接口如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;public TOpenSessionResp OpenSession(TOpenSessionReq req) throws org.apache.thrift.TException;&lt;br/&gt;&lt;br/&gt;public TCloseSessionResp CloseSession(TCloseSessionReq req) throws org.apache.thrift.TException;&lt;br/&gt;&lt;br/&gt;public TGetInfoResp GetInfo(TGetInfoReq req) throws org.apache.thrift.TException;&lt;br/&gt;&lt;br/&gt;public TExecuteStatementResp ExecuteStatement(TExecuteStatementReq req) throws org.apache.thrift.TException;&lt;br/&gt;&lt;br/&gt;public TGetTypeInfoResp GetTypeInfo(TGetTypeInfoReq req) throws org.apache.thrift.TException;&lt;br/&gt;&lt;br/&gt;public TGetCatalogsResp GetCatalogs(TGetCatalogsReq req) throws org.apache.thrift.TException;&lt;br/&gt;&lt;br/&gt;public TGetSchemasResp GetSchemas(TGetSchemasReq req) throws org.apache.thrift.TException;&lt;br/&gt;&lt;br/&gt;public TGetTablesResp GetTables(TGetTablesReq req) throws org.apache.thrift.TException;&lt;br/&gt;&lt;br/&gt;public TGetTableTypesResp GetTableTypes(TGetTableTypesReq req) throws org.apache.thrift.TException;&lt;br/&gt;&lt;br/&gt;public TGetColumnsResp GetColumns(TGetColumnsReq req) throws org.apache.thrift.TException;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;更多关于接口和服务器的知识可查看：&lt;a target=&quot;_blank&quot; href=&quot;https://mp.weixin.qq.com/s?__biz=MzkwMzMwOTQwMg==&amp;amp;mid=2247493330&amp;amp;idx=1&amp;amp;sn=be67af4d26e248d0f93abf13101cbdc3&amp;amp;scene=21&amp;amp;token=1569549436&amp;amp;lang=zh_CN#wechat_redirect&quot; textvalue=&quot;干货 | 在字节跳动，一个更好的企业级SparkSQL Server这么做&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;干货 | 在字节跳动，一个更好的企业级SparkSQL Server这么做&lt;/a&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;每一个 RPC 接口之间相互独立，一个作业从连接到执行 SQL 再到作业结束，会调用一系列的 RPC 接口组合完成这个动作，中间通过 OperationHandle 中的 THandleIdentifier 作为唯一 session id，由客户端每次执行的时候进行传递，THandleIdentifier 在 OpenSession 的时候被创建。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;HiveServer2 基于此对整个作业的执行进行管理。具体的调用顺序，以及调用何种接口，对于使用者是透明的，常用的客户端例如 Hive JDBC Driver 或者 PyHive 等已经封装了对应的调用顺序，使用者只需要关心正常的打开连接，执行 SQL，关闭连接即可，与标准的数据库操作逻辑保持一致。&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1.1917098445595855&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/5EcwYhllQOjhwauW8aQwqs2R8V6a2jLmsnqnpXDXkB3055vzSbayOhicq58PeQZ9yRY1B6kwByKibJ62X6r1k9eQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;579&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;一个简单的调用逻辑如上图所示，当一个 Connection 执行多条 SQL 后，每一条 SQL 都是一个 Operation 进行记录，并且各自拥有各自的 Query Id，HiveServer 基于此 Query Id 做一些状态的管理，当连接结束后，调用 CloseOperation 清理所有内容。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;每一条 SQL 执行结束后，都会调用 CloseOperation 进行相关的状态清除，如果清除失败，当 connection 被 close 的时候，也会循环调用 CloseOperation 去清理状态，确保状态的一致性。这里需要注意的是，既然 HiveServer2 是一系列的独立 RPC 接口，那么必然会出现万一用户不调用某些接口怎么办，例如不调用 CloseSession，HiveServer2 为了解决这个问题内置了一个超时机制，当 Connection 达到超时的阈值后，会执行 close 动作，清除 Session 和 Operation 的状态，具体的实现在 SessionManager 中的 startTimeoutChecker 方法中：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.9468479604449939&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/5EcwYhllQOjhwauW8aQwqs2R8V6a2jLmiakZvkbKQCOibnNtDCnQicpu134anbpcJhyWoA12T6w3picEOPAlTqwv6w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1618&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;有了这些知识，再来分析前面出现 OOM 的问题，出现 OOM 是一个名叫 queryIdOperation 的 ConcurrentHashMap 对象占据了大量的内存，对这个对象分析会发现这个对象位于：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.28762135922330095&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/5EcwYhllQOjhwauW8aQwqs2R8V6a2jLmuibiciaibibXFe45iaPPwQSYlQy4IVrUdhsUWDspHIHuO7JpssnlQAvSMw4Q/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1648&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;一个 Hive Connection 被打开后，可以执行多条 SQL，每一条 SQL 都是一个独立的 Operation，此 Map 维护一个 queryId 和 Operation 的关系。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当一个新的 SQL 作业到达的时候，QueryState 对象的 build 方法会构建出一个 queryState，在这里生成此 SQL 的唯一标记，也就是 QueryId：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5490196078431373&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/5EcwYhllQOjhwauW8aQwqs2R8V6a2jLmyPb3w8I2SIQickkJWreQnSv9YVFsRh15C1TPOJ6MWpA147tzrmncriaw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1530&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;并且将该 QueryId 添加至 Connection 对象持有的 Hive Session，同时调用 OperationManager 的 addOperation 方法将此对象添加至 Map 中：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.3767228177641654&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/5EcwYhllQOjhwauW8aQwqs2R8V6a2jLme9jZNrklDSaibdlf0sDwy8fxLicXf9yz0MBV5mG367DibTk6S390gMqBw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1306&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当作业执行结束后，通过 OperationManager.closeOperation 调用 removeOperation 移除该 Map 中的映射：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.3362193362193362&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/5EcwYhllQOjhwauW8aQwqs2R8V6a2jLmsmCw29vrV4fVyCd1H7miaNbAcm7cDSiaoLpJab7aTFf2o6mvABD7fGrA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1386&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;而 Query Id 是通过顶层的 Connection 中的 HiveSession 中去获取：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.11764705882352941&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/5EcwYhllQOjhwauW8aQwqs2R8V6a2jLmr7Vln2iadmTeC8SXz8TibU2cSWsibqp39bADGquApMibCnmOBIbUVmlK5Q/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1326&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;即使这里 removeOperation 失败了，在 CloseSession，或者 HiveServer2 触发超时动作后，都会再次回收该 Map 对象中的内容。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;有了这个思路，于是再去对日志进行深度分析，发现：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.25546875&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/5EcwYhllQOjhwauW8aQwqs2R8V6a2jLmhNlkZH39oneWRwbUYIpH9TMW0mqYCRgWwIVKyp60DiaSe47n6fUVIbg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;很多 SQL 作业在执行后，并没有调用 removeOperation 的行为，可以看到也就自然没有触发移除 queryIdOperation 的内容，那么内存被耗尽自然就可以理解，同时在 SQL 执行后会紧接着产生一个非法 Operation 的堆栈：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5015625&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/5EcwYhllQOjhwauW8aQwqs2R8V6a2jLmxdx1HzrxcaQHcB6tB5WWFYGMhQsgn6vv8jl9bdCVibnxbzNSLzMJ86Q/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;思路理到这里，需要想的问题是：为什么没有触发 removeOperation 的行为，或者说 removeOperation 没有执行成功，基于前面的理解来看，removeOperation 会有3种触发时机，分别是：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;SQL 作业执行结束调用 CloseOperatipn。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;Connection 断开调用 CloseSession。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;HiveServer2 自身的状态判断 Connection 超时发起 Close。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以没有被调用的可能性不大，那么只剩下调用了，但是没有执行成功，没有执行成功也有2种情况：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;失败可能性不大，因为失败了，那么一定会留下堆栈信息，于是只剩下执行了但是没有移除，出现这样的情况基本就是只能是：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.11764705882352941&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/5EcwYhllQOjhwauW8aQwqs2R8V6a2jLmr7Vln2iadmTeC8SXz8TibU2cSWsibqp39bADGquApMibCnmOBIbUVmlK5Q/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1326&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;里面查询出的 QueryId 并不是当前作业的 QueryId，这个 ID 发生了篡改，那么什么样的情况下会发生篡改？再来理一理 HiveServer 的状态逻辑：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5301418439716312&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/5EcwYhllQOjhwauW8aQwqs2R8V6a2jLmoVPSAnJFJiaVtmoJqm0nWu9VkTD9FjYoF6dtKb4yjVzSQm7DndTbz9A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;564&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;一个 Connection 执行 SQL 的时候，会先产生一个 Operation，并且生成一个 Query Id，将这个 Query Id 设置成全局 HiveSession的内容：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.32225063938618925&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/5EcwYhllQOjhwauW8aQwqs2R8V6a2jLmELeB6ZYe414iaQXicyRoXNoE1teficIXfqs6pdp30r864Ywrox24wKTEw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1564&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;同时把这些信息存储到这两个 Map 中：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.13861386138613863&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/5EcwYhllQOjhwauW8aQwqs2R8V6a2jLmnKBECCg2S9NKFTngyoR5AYwx4K5JtibOUK3ThL5S5Dy2BFRH2LLXeSg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1414&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在 close 的时候再从 HiveSession 中去查询出来，由于 HiveServer2 是一系列的独立 RPC 请求，因此不能保证整个流程的原子性，那么想一种情况，假设 N 个并行线程，同时持有一个 Hive Connection，且同时开始发送 SQL 会怎样？&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.24679029957203993&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/5EcwYhllQOjhwauW8aQwqs2R8V6a2jLmKY9wGV11m0xL0TEYUic5HyMSJU3ZTeIf0vqV37ue5Tu5cPxCOgibR9iag/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;701&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可以看到如果两个子线程同时使用同一个 Connection 执行 SQL，于是会出现一个线程把另一个线程的 Query Id 进行覆盖，导致其中一个线程丢失自己的 Query Id，导致无法成功的从 Map 中移除对象，具体的执行思路为：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;t1: 线程 A 将 conf 中的 queryId 设成 A；&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;ol start=&quot;2&quot; data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;t2: 线程 B 将 conf 中的 queryId 设成 B；&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;ol start=&quot;3&quot; data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;t3: 线程 A 从 conf 中拿到 queryId 为 B，并 close B；&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;ol start=&quot;4&quot; data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;t4: 线程 B 从 conf 中拿到 queryId 为 B，并 close B，出现异常。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;于是一直遗留了 queryId A，因为两个线程同时变成了相同的 Query Id，当其中一个线程执行了 remove 动作后，另一个线程要基于当前 Query Id 再去查询内容的时候，便会出现紧接着的第二个错误，也就是非法的 Session Id。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;由于本次出现问题的使用场景是 Airflow 进行调用，Airflow 具有工作流的能力可同时在一个 Dag 中并发开启 N 个并行节点，而这些并行节点在同一个 Dag 下，因此共享同一个 Connection，于是触发了这个问题。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但是我们要知道，多个线程使用同一个 Connection 是非常常见的现场，特别是在数据库的连接池的概念中，那么为什么没有出问题呢？这里也就涉及到 HiveServer2 本身的架构问题，HiveServer2 本身不是一个数据库，仅仅提供了兼容 JDBC 接口的协议和 Driver 而已，因此相比传统的数据库的连接池，它并不能保证串行，也就是不具有排它效果，当然这只是次要问题，主要还是 HiveServer2 实现的缺陷。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;对于此问题的复现，只需要创建一个 HiveConnection，同时并行开启多个线程同时使用该 Connection 对象执行 SQL，便可复现这个问题。执行过程中观察 HiveServer2 内存变化，可以发现 HiveServer2 的内存上升后，并没有发生下降，随着使用时间的增加，最后直至 OOM。&lt;/p&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;解决&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;既然找到了问题，那么解决方案就清楚了，那便是将 Query Id 这个值设置成 Operation 级别，而不是 HiveSession 级别，此问题影响 Hive3.x 版本，2.x 暂时没有这个特性，因此不受影响。再对照官方已知的 issue，此问题是已知 issue，目前 Hive 已经将此问题修复，且合入了4.0的版本，具体可查看：https://issues.apache.org/jira/browse/HIVE-22275&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但是由于该 issue 是针对 4.0.0 的代码修复的，对于 3.x 系列并没有 patch，直接 cherry-pick 将会有大量的代码不兼容，因此需要自行参考进行修复，修复的思路为给 Operation 新增：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.23404255319148937&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/5EcwYhllQOjhwauW8aQwqs2R8V6a2jLmUK9TEiavibT99g952SDib15EEZLiaxFXz7Th5VrloUicrpTJQyicTqVNVhkA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;658&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;将 Query Id 从 HiveSession 级别移除，存入 Operation 级别，同时更新 Query Id 的获取和设置：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.3874538745387454&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/5EcwYhllQOjhwauW8aQwqs2R8V6a2jLmUUXLHS5zTWd5hFv9ibcqQha9m7tLMmmGKnK7xb6iaCIEvSBF3PDeeib3w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1084&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;对 Hive 进行重新打包，在现有集群上对 hive-service-x.x.x.jar 进行替换，即可修复此问题。&lt;/p&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;结尾&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;虽然有些问题在官方 issue 上已经有发布，但是实际业务过程中我们依旧需要仔细定位，确保当前的问题，与已知问题是一致的，尽可能少的留下隐患，同时也有助于更加掌握引擎本身的原理和实现逻辑。只有对问题有清晰的认知，且对解决方案的逻辑有足够的了解，才能保证整个集群在生产环境下的稳定。&lt;/p&gt;&lt;/section&gt;&lt;p&gt;支持构建开源Hadoop生态的企业级大数据分析系统，完全兼容开源，提供 Hadoop、Spark、Hive、Flink集成和管理，帮助用户轻松完成企业大数据平台的构建，降低运维门槛，快速形成大数据分析能力。点击阅读原文立即体验产品！&lt;/p&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>a86ec3ee7e6a7cf7169c8135366cf9c5</guid>
<title>图文结合简单易学的 npm 包的发布流程</title>
<link>https://toutiao.io/k/82vinrs</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot; data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;聪明的你做了几个项目之后，有没有发现发现某些工具方法或者组件的使用频率很高，好多项目都在用。如何做到这些工具方法或者组件的更优雅地复用而不是用到了就复制粘贴呢？封装为一个npm包是一个不错的选择。本文以图文结合的方式介绍了如何从0到1发布一个npm包，文中的一些关键点的说明将帮你避坑提效。欢迎阅读学习~&lt;/span&gt;&lt;/p&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;1.代码准备&lt;/span&gt;&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;每个人要发布的npm包类型都不尽相同，有UI组件库，有工具函数库，还有使用的插件等。笔者要发布的npm包是在项目中常用的工具函数组成的工具函数库，构建工具使用的是rollup，代码托管在github上。下面简述一下一些关键点：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;首先在github上新建仓库，新建仓库时License 选择MIT, 此步骤不选择也无妨，后续添加license也可以。但是一定要有License才能发布npm包。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.4217687074829932&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz/H8M5QJDxMHqxzRPoVjHHlI9l2eVqDvbptaewNUH8ksS7K5GazFwAGJF3FpHSNYYH4OD26apgHPDnMpib3bZxaWQ/640?wx_fmt=other&quot; data-type=&quot;other&quot; data-w=&quot;1176&quot;/&gt;&lt;/figure&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.869942196531792&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz/H8M5QJDxMHqxzRPoVjHHlI9l2eVqDvbplGuwcrbic3jxrxWVdu1cPx0CiaL6H9FN3iabMHS06eiarbsOlBcybGF1sg/640?wx_fmt=other&quot; data-type=&quot;other&quot; data-w=&quot;346&quot;/&gt;&lt;/figure&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;完善功能&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;打包，并在package.json中指明入口&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.677536231884058&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz/H8M5QJDxMHqxzRPoVjHHlI9l2eVqDvbp8pRwsia3ia3TdyY8KFvpFdIP4GEyTDckQIhiawb4q76vCp3MqTrvnFxtg/640?wx_fmt=other&quot; data-type=&quot;other&quot; data-w=&quot;276&quot;/&gt;&lt;img data-ratio=&quot;0.350109409190372&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz/H8M5QJDxMHqxzRPoVjHHlI9l2eVqDvbp6dM5Xp50q03ic9hyH4NsLQv1WwvCb4X1ficplzhGVYIy4Ag4uJABCZoQ/640?wx_fmt=other&quot; data-type=&quot;other&quot; data-w=&quot;457&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;另外如果发布公有包需要在package.json中增加publishConfig的配置&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;&quot;publishConfig&quot;&lt;/span&gt;: {&lt;br/&gt;  &lt;span&gt;&quot;access&quot;&lt;/span&gt;: &lt;span&gt;&quot;public&quot;&lt;/span&gt;&lt;br/&gt;},&lt;br/&gt;复制代码&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;更多关于项目的搭建以及一些配置方面的内容建议阅读文末的参考资料。&lt;/p&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;2.账号注册&lt;/span&gt;&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;先看下图了解注册的流程：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.08915304606240713&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz/H8M5QJDxMHqxzRPoVjHHlI9l2eVqDvbpOX2QfEOUMVDub8ZxIhfysM6rNgkG5YnicY3z4VdX8IROwoCSicDhoISw/640?wx_fmt=other&quot; data-type=&quot;other&quot; data-w=&quot;1346&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;网址：&lt;span&gt;www.npmjs.com/signup&lt;/span&gt;&lt;sup&gt;[2]&lt;/sup&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;输入网址后会进行安全性检查，之后界面如下：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.4421397379912664&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz/H8M5QJDxMHqxzRPoVjHHlI9l2eVqDvbpcBic9z2EgsmEwtbaqEpX47kMwp2NzebcYvZrO6bNN6GcwOOiaEPwRM0Q/640?wx_fmt=other&quot; data-type=&quot;other&quot; data-w=&quot;916&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;点击&quot;我是人类&quot; 会进行图片验证，如下图：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.7454323995127893&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz/H8M5QJDxMHqxzRPoVjHHlI9l2eVqDvbpIia93xw7FagfB6Sskxial6ceiazloicULBGs9syajGIbGMSH3ibopJKopaA/640?wx_fmt=other&quot; data-type=&quot;other&quot; data-w=&quot;821&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;图片验证完就是输入用户名、密码、邮箱过程，&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;最后让输入one-time-password，这个一次性密码（相当于验证码）会发到你预留的邮箱里面。填写之后应该会注册成功的。&lt;/p&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;3.npm包发布&lt;/span&gt;&lt;/h1&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;3.1 登录npm账号&lt;/span&gt;&lt;/h2&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;3.1.1 登录失败&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;执行&lt;code&gt;npm login&lt;/code&gt; 命令登录npm ：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.37512953367875645&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz/H8M5QJDxMHqxzRPoVjHHlI9l2eVqDvbpUupkbQxYpj69Q7mTBZXlNhVGtt1sUF9AV2lnpshQtic7ljdypCZ2RSg/640?wx_fmt=other&quot; data-type=&quot;other&quot; data-w=&quot;965&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如上图所示，登录失败了。解决办法：使用nrm切换镜像，将镜像改为npm。下面简要介绍一下nrm。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;3.1.2 nrm 介绍&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;nrm 用于管理镜像，是一个可以切换npm镜像的管理工具。如下是安装和查看是否安装成功的命令：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;npm&lt;/span&gt; &lt;span&gt;i&lt;/span&gt; &lt;span&gt;-g&lt;/span&gt; &lt;span&gt;nrm&lt;/span&gt;&lt;br/&gt;&lt;span&gt;nrm&lt;/span&gt; &lt;span&gt;-V&lt;/span&gt;&lt;br/&gt;复制代码&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.215633423180593&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz/H8M5QJDxMHqxzRPoVjHHlI9l2eVqDvbpDPqrOZP36qPzG7mxnvqbXwK7QErZNQiaz3FNnXCbLm6rla3XtDicN4fQ/640?wx_fmt=other&quot; data-type=&quot;other&quot; data-w=&quot;371&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;常用nrm命令如下：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.9259259259259259&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz/H8M5QJDxMHqxzRPoVjHHlI9l2eVqDvbpjYia7Wib7cVgHScJBMt2zSlnYDuOOZgvH5xic1puEm1X4bR8goc2KA2Vw/640?wx_fmt=other&quot; data-type=&quot;other&quot; data-w=&quot;864&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;想了解更多关于&lt;span&gt;nrm&lt;/span&gt;&lt;sup&gt;[3]&lt;/sup&gt;的内容请查看文档和&lt;span&gt;资料&lt;/span&gt;&lt;sup&gt;[4]&lt;/sup&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;下图是使用nrm ls命令查看镜像：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.35714285714285715&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz/H8M5QJDxMHqxzRPoVjHHlI9l2eVqDvbpAic1GY1d9XF9J3bMYgRoX9NqE6okzhEkUhN3r9Pakk2g4BkI0bPaiaqw/640?wx_fmt=other&quot; data-type=&quot;other&quot; data-w=&quot;630&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;下图是将镜像切换为npm&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.22620904836193448&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz/H8M5QJDxMHqxzRPoVjHHlI9l2eVqDvbp9zribkvtzmZMUpGCibrSqeV3rXlA9vEJxG0eLRrv3fH3D124lvcfvsEg/640?wx_fmt=other&quot; data-type=&quot;other&quot; data-w=&quot;641&quot;/&gt;&lt;/figure&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;3.1.3 成功登录&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;切换镜像之后再登录：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.2966226138032305&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz/H8M5QJDxMHqxzRPoVjHHlI9l2eVqDvbp5FOBKEBGycpc8Q66q6qlZAnROcS7m7ia5Slj3fUqnzKB0Sxo28squow/640?wx_fmt=other&quot; data-type=&quot;other&quot; data-w=&quot;681&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如上图登录时需要输入OTP，要查看邮箱。输入OTP回车之后就可以成功登录了&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;3.2 如何发布npm包&lt;/span&gt;&lt;/h2&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;3.2.1 首次发布成功&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;登录成功之后即可执行发布命令：&lt;code&gt;npm publish&lt;/code&gt;，如下图：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.8092345078979344&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz/H8M5QJDxMHqxzRPoVjHHlI9l2eVqDvbpQOzaFyUtkuAuTnajCRJqNpZrD8iafhRwPibJqmjMk1DFj0yM9E8jmN9Q/640?wx_fmt=other&quot; data-type=&quot;other&quot; data-w=&quot;823&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;此时npm包发布成功了。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;3.2.2 名字相似发布失败&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但是感觉名字&#x27;mxdevutil&#x27;可读性不咋好啊，所以改了一下名字，新名字为&#x27;mx-dev-util&#x27;重新发布，但却报错，如下图所示：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.28804902962206336&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz/H8M5QJDxMHqxzRPoVjHHlI9l2eVqDvbpjwbk17atno5h8RV2GQkoUzTY9Licdq1UKlDHLhq1qicIEz4UIBkBFrXg/640?wx_fmt=other&quot; data-type=&quot;other&quot; data-w=&quot;979&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上图报错信息告诉我们：新包的名字和已有的包名字很相似，所以没有发布成功。解决的方法之一是可以起区分度较大的名字，但删掉重新发布更好。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;3.3 如何删除npm 包&lt;/span&gt;&lt;/h2&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;3.3.1 废弃npm 包&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;查资料所如下命令可以删掉发布错误的npm包：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.09900990099009901&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz/H8M5QJDxMHqxzRPoVjHHlI9l2eVqDvbp0voAqbxibnwoFY7FEYt1W0fIDmQK8ib8U9SgqiaUeSwPBmv11Xjtx7zxg/640?wx_fmt=other&quot; data-type=&quot;other&quot; data-w=&quot;707&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但实际上此命令是表示废弃已发布的npm包，并不是删除。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在npm网站上仍然能够查到已废弃的npm包，如下图所示：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.7121951219512195&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz/H8M5QJDxMHqxzRPoVjHHlI9l2eVqDvbpwkKOneibdFt1eyadWhtwYOZbbm2s35wNrjCxIWDqV1GhxzSo9KMARlA/640?wx_fmt=other&quot; data-type=&quot;other&quot; data-w=&quot;820&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;废弃之后是否可以发布成功呢？重新执行npm publish&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.35671342685370744&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz/H8M5QJDxMHqxzRPoVjHHlI9l2eVqDvbpuxMMjGlrvHBhsb84n45qiaYG3I4Ej1PZzlTuriaz8dzibcpDvMsicukluA/640?wx_fmt=other&quot; data-type=&quot;other&quot; data-w=&quot;499&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;执行结果如下图：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.28804902962206336&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz/H8M5QJDxMHqxzRPoVjHHlI9l2eVqDvbpjwbk17atno5h8RV2GQkoUzTY9Licdq1UKlDHLhq1qicIEz4UIBkBFrXg/640?wx_fmt=other&quot; data-type=&quot;other&quot; data-w=&quot;979&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;还是报错，所以单单废弃原有包还是不能发布新包的。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;3.3.2 删除npm包&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;正确的解决办法是：&lt;code&gt;npm unpublish &amp;lt;报名&amp;gt; \-force&lt;/code&gt; ,命令执行效果：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.16018662519440124&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz/H8M5QJDxMHqxzRPoVjHHlI9l2eVqDvbpJnDXRjECKOzdzI4nALPRsaqcGe3ZwIddW3WXAwvxXibibqaicLN0zicQoA/640?wx_fmt=other&quot; data-type=&quot;other&quot; data-w=&quot;643&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;再在npm网站上查找则查不到了：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5103050288540808&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz/H8M5QJDxMHqxzRPoVjHHlI9l2eVqDvbpwPSaevulBT52rKDLpj5LXnPyK1Y5ZuQnHvUhib8ib8qHzNpUiapib2tibgA/640?wx_fmt=other&quot; data-type=&quot;other&quot; data-w=&quot;1213&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;删掉已发布的包之后，终于可以重新发布了：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.8308457711442786&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz/H8M5QJDxMHqxzRPoVjHHlI9l2eVqDvbpiaTfqTiabudptSAhQaG0lMXxr2sKmPYOOje2JkoHsS33ozpnkWHRpGNg/640?wx_fmt=other&quot; data-type=&quot;other&quot; data-w=&quot;804&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;发布成功！在npm网站上也能够看到新包了：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5723192019950125&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz/H8M5QJDxMHqxzRPoVjHHlI9l2eVqDvbp7BLKz9MYkhtPOCSB5HcNyLtu0IkI9l2lMJsPRrv8UKVKDufLGluwRA/640?wx_fmt=other&quot; data-type=&quot;other&quot; data-w=&quot;802&quot;/&gt;&lt;/figure&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;3.4 如何使用npm包&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;首先安装我们发布的npm包，执行命令 &lt;code&gt;npm i mx-dev-util&lt;/code&gt;, 如下图：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.3299856527977044&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz/H8M5QJDxMHqxzRPoVjHHlI9l2eVqDvbpxhjjYzbwApxqr29tHg1llzrVQ0qjtQeqrhUOTjthFnOH18VROnAOfA/640?wx_fmt=other&quot; data-type=&quot;other&quot; data-w=&quot;697&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可以查看package.json文件，返现已经将mx-dev-util加添为dependiences:&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.7368421052631579&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz/H8M5QJDxMHqxzRPoVjHHlI9l2eVqDvbpsbj2NxViab3AzdVPibic7On7cxAdx7EmATZ7QOUo6FIsCXyNjs9M4M1RQ/640?wx_fmt=other&quot; data-type=&quot;other&quot; data-w=&quot;418&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;接着就是在项目中使用npm包提供的方法了：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.2211895910780669&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz/H8M5QJDxMHqxzRPoVjHHlI9l2eVqDvbpfb0B6joYJrsweicfrLvLclBuuUKZlduRHtGPvnuFPJKT6VCicevw3bzA/640?wx_fmt=other&quot; data-type=&quot;other&quot; data-w=&quot;538&quot;/&gt;&lt;/figure&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;3.5 更新npm包版本&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;更新npm包两步走：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;第一步：执行npm version &amp;lt;版本号类型&amp;gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;第二步：执行 npm publish&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;3.5.1 npm version介绍&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;npm version命令使用方式如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;npm version  major | minor | patch | premajor | preminor | prepatch | prerelease&lt;br/&gt;复制代码&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里简单介绍一下major | minor | patch 的区别：在package.json中有一个version字段，结构为 &quot;x.y.z&quot; ，也就是三位的版本号。分别对应 version里面的major、minor，patch。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果当前版本为 0.0.1 则发布major、minor，patch版本之后会变为 1.0.0 ，0.1.0， 0.0.2。导图总结如下：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6592356687898089&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz/H8M5QJDxMHqxzRPoVjHHlI9l2eVqDvbpP7W7t5MgNOSDKjU9UkGyH6r0T3jNicQFAASkZUxoazvs4Apq1R7JqXA/640?wx_fmt=other&quot; data-type=&quot;other&quot; data-w=&quot;628&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;了解更多可查看npm version文档和&lt;span&gt;相关资料&lt;/span&gt;&lt;sup&gt;[5]&lt;/sup&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;了解了npm version命令之后，执行&lt;code&gt;npm version major&lt;/code&gt; :&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.1837837837837838&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz/H8M5QJDxMHqxzRPoVjHHlI9l2eVqDvbpBBFXNqqe5QtdPibfBAXxUdT0G0masWRUBbBtH6DafgneIEsgNDWniaYQ/640?wx_fmt=other&quot; data-type=&quot;other&quot; data-w=&quot;740&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;执行命令失败，提示需要先提交代码，下图为提交代码过程：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6736566186107471&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz/H8M5QJDxMHqxzRPoVjHHlI9l2eVqDvbpbyv5w8nunwe7bicKkvGvNBFKLgBBVgYLaU81icyg7PgzP1pvribiclg94w/640?wx_fmt=other&quot; data-type=&quot;other&quot; data-w=&quot;763&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;提交代码后，再执行版本更新命令：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.19186046511627908&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz/H8M5QJDxMHqxzRPoVjHHlI9l2eVqDvbp9QzhxwLML0KL90dHwD8zekRFqialQG3MXtY7Thqd1waWxMJAloXTlqQ/640?wx_fmt=other&quot; data-type=&quot;other&quot; data-w=&quot;516&quot;/&gt;&lt;/figure&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;3.5.2 改版后发布&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;提示版本已经更新为2.0.0版本，然后执行 &lt;code&gt;npm publish&lt;/code&gt; 命令：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.8897535667963683&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz/H8M5QJDxMHqxzRPoVjHHlI9l2eVqDvbpH8FOPR2R05pUa4RUuXWPPZgZxm89HflVtzj2MTAaJCDstnpiaupLPqA/640?wx_fmt=other&quot; data-type=&quot;other&quot; data-w=&quot;771&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可以看到版本更新成功。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;下面总结一下用到发布npm包用到的npm命令&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.4104803493449782&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz/H8M5QJDxMHqxzRPoVjHHlI9l2eVqDvbpJpzibvqy5lXxibpw41vZ4aEicibPAdFJTGv7taW7qGBeZJdK1icevqiblXVA/640?wx_fmt=other&quot; data-type=&quot;other&quot; data-w=&quot;916&quot;/&gt;&lt;/figure&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;4.总结&lt;/span&gt;&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;（1）本文介绍发布一个npm包的三个关键环节：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;发布内容。也就是代码，这是npm包的基础&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;注册npm账号。这是能够成功执行npm 发布命令的前提&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;npm包发布。掌握npm 包发布的这些命令是关键&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;（2）本文介绍了如何使用nrm 切换npm的镜像&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;希望看完本文对您有帮助，表达不清楚或者写错的地方欢迎不吝指正~&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;参考资料：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;[1] &lt;span&gt;npm包发布详细教程&lt;/span&gt;&lt;sup&gt;[6]&lt;/sup&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;[2] &lt;span&gt;如何发布自己的npm包（超详细步骤，博主都在用）&lt;/span&gt;&lt;sup&gt;[7]&lt;/sup&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;[3] &lt;span&gt;如何发布一个npm包&lt;/span&gt;&lt;sup&gt;[8]&lt;/sup&gt;&lt;/p&gt;&lt;section data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;p&gt;&lt;em/&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;关于本文&lt;/span&gt;&lt;/section&gt;&lt;h1 data-v-a4949a24=&quot;&quot;&gt;&lt;span&gt;作者：NewName&lt;/span&gt;&lt;/h1&gt;&lt;p&gt;&lt;span&gt;https://juejin.cn/post/7125709933709885448&lt;/span&gt;&lt;/p&gt;&lt;section data-tool=&quot;mdnice编辑器&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>