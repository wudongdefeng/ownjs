<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>5af31c40f510eb5e1f0fe10ad1e6f70f</guid>
<title>Thrift 序列化协议浅析</title>
<link>https://toutiao.io/k/v6esqht</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;编码简图&lt;span/&gt;&lt;/h4&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6463414634146342&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/5EcwYhllQOiaQFeS3PEy4Qvdh15OU7JPIw3ib5IfGdZFxBgxyfahXhvZRx3UubRW7Ls9vWCibQYqicHUCUjiaMicSzeQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;738&quot;/&gt;&lt;/figure&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;编码具体内容&lt;span/&gt;&lt;/h4&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;抓包拿到编码后的字节流（转成了十进制，方便大家看）&lt;br/&gt;&lt;br/&gt;/* 接口名长度 */         0   0   0    25&lt;br/&gt;/* 接口名 */            83  101  97  114  99  104  68  101  112  97  114  116&lt;br/&gt;                       109  101  110  116  66  121  75  101  121  119  111&lt;br/&gt;                       114  100&lt;br/&gt;/* 消息类型 */           1&lt;br/&gt;/* 消息序号 */           0   0   0   1&lt;br/&gt;/* keyword 字段类型 */   11&lt;br/&gt;/* keyword 字段ID*/     0   1&lt;br/&gt;/* keyword len */      0   0   0   4&lt;br/&gt;/* keyword value */    108   97   114   107&lt;br/&gt;/* &lt;span&gt;limit&lt;/span&gt; 字段类型 */     8&lt;br/&gt;/* &lt;span&gt;limit&lt;/span&gt; 字段ID*/       0   2&lt;br/&gt;/* &lt;span&gt;limit&lt;/span&gt; value */      0   0   0   50&lt;br/&gt;/* 字段终止符 */         0&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;编码含义&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;消息头&lt;/strong&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;msg_type：消息类型，包含四种类型&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;Call：客户端消息。调用远程方法，并且期待对方发送响应。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;OneWay：客户端消息。调用远程方法，不期待响应。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;Reply：服务端消息。正常响应。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;Exception：服务端消息。异常响应。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;msg_seq_id：消息序号。客户端使用消息序号来处理响应的失序到达，实现请求和响应的匹配。服务端不需要检查该序列号，也不能对序列号有任何的逻辑依赖，只需要响应的时候将其原样返回即可。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;消息体&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;消息体分为两种编码模式：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;定长类型 -&amp;gt; T-V 模式，即：字段类型 + 序号 + 字段值&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;变长类型 -&amp;gt; T-L-V 模式，即：字段类型 + 序号 + 字段长度 + 字段值&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;field_type：字段类型，包括 String、I64、Struct、Stop 等。字段类型有两个作用：&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;Stop 类型用于停止嵌套解析&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;非 Stop 类型用于 Skip（Skip 操作是跳过当前字段，会在「常见问题 - 兼容性」进行讲解）&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;fied_id：字段序号，解码时通过序号确定字段&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;len：字段长度，用于变长类型，如 String&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;value：字段值&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;strong&gt;数据格式&lt;/strong&gt;&lt;span/&gt;&lt;/h4&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;1. 定长数据类型&lt;span/&gt;&lt;/h4&gt;&lt;section data-tool=&quot;mdnice编辑器&quot;&gt;&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;数据类型&lt;/th&gt;&lt;th&gt;类型标识(8 位)&lt;/th&gt;&lt;th&gt;类型尺寸（单位：字节）&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;bool&lt;/td&gt;&lt;td&gt;2&lt;/td&gt;&lt;td&gt;1&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;byte&lt;/td&gt;&lt;td&gt;3&lt;/td&gt;&lt;td&gt;1&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;double&lt;/td&gt;&lt;td&gt;4&lt;/td&gt;&lt;td&gt;8&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;i16&lt;/td&gt;&lt;td&gt;6&lt;/td&gt;&lt;td&gt;2&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;i32&lt;/td&gt;&lt;td&gt;8&lt;/td&gt;&lt;td&gt;4&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;i64&lt;/td&gt;&lt;td&gt;10&lt;/td&gt;&lt;td&gt;8&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/section&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;2. 变长数据类型&lt;span/&gt;&lt;/h4&gt;&lt;section data-tool=&quot;mdnice编辑器&quot;&gt;&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;数据类型&lt;/th&gt;&lt;th&gt;类型标识（8 位）&lt;/th&gt;&lt;th&gt;类型尺寸（长度 + 值）&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;string&lt;/td&gt;&lt;td&gt;11&lt;/td&gt;&lt;td&gt;4 + N&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;struct&lt;/td&gt;&lt;td&gt;12&lt;/td&gt;&lt;td&gt;嵌套数据 + 一个字节停止符（0）&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;map&lt;/td&gt;&lt;td&gt;13&lt;/td&gt;&lt;td&gt;1 + 1 + 4 + N*(X+Y) 【key 类型 + val 类型 + 长度 + 值】&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;set&lt;/td&gt;&lt;td&gt;14&lt;/td&gt;&lt;td&gt;1 + 4 + N 【val 类型 + 长度 + 值】&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;list&lt;/td&gt;&lt;td&gt;15&lt;/td&gt;&lt;td&gt;1 + 4 + N 【val 类型 + 长度 + 值】&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/section&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;其他协议&lt;/h2&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;Compact 协议&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Compact 协议是二进制压缩协议，在大部分字段的编码方式上与 Binary 协议保持一致。区别在于整数类型（包括变长类型的长度）采用了【先 zigzag 编码 ，再 varint 压缩编码】实现，最大化节省空间开销。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那么问题来了，varint 和 zigzag 是什么？&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;varint 编码&lt;span/&gt;&lt;/h4&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;解决的问题：定长存储的整数类型绝对值较小时空间浪费大&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;据统计，RPC 通信时大部分时候传递的整数值都很小，如果使用定长存储会很浪费。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;举个 🌰，对 i32 类型的 7 进行编码，可以说前面 3 个字节都浪费了：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;00000000 00000000 00000000 00000111&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;解决思路：将整数类型由定长存储转为变长存储（能用 1 个字节存下就坚决不用 2 个字节）&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;原理并不复杂，就是将整数按 7bit 分段，每个字节的最高位作为标识位，标识后一个字节是否属于该数据。1 代表后面的字节还是属于当前数据，0 代表这是当前数据的最后一个字节。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;以 i32 类型，数值 955 为例，可以看出，由原来的 4 字节压缩到了 2 字节：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;binary编码：       00000000  00000000  00000011  10111011&lt;br/&gt;切分：        0000  0000000   0000000   0000111   0111011&lt;br/&gt;compact编码：                          00000111  10111011&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当然，varint 编码同样存在缺陷，那就是存储大数的时候，反而会比 binary 的空间开销更大：本来 4 个字节存下的数可能需要 5 个字节，8 个字节存下的数可能需要 10 个字节。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;zigzag 编码&lt;span/&gt;&lt;/h4&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;解决的问题：绝对值较小的负数经过 varint 编码后空间开销较大
举个 🌰，i32 类型的负数（-11）&lt;/p&gt;&lt;/blockquote&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;原码：         10000000  00000000  00000000  00001011&lt;br/&gt;反码：         11111111  11111111  11111111  11110100&lt;br/&gt;补码：         11111111  11111111  11111111  11110101&lt;br/&gt;varint编码：   00001111  11111111  11111111  11111111  11110101&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;显然，对于绝对值较小的负数，用 varint 编码以后前导 1 过多，难以压缩，空间开销比 binary 编码还大。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;解决思路：负数转正数，从而把前导 1 转成前导 0，便于 varint 压缩&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;算法公式 &amp;amp; 步骤 &amp;amp; 示范：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;// 算法公式&lt;br/&gt;32位： (n &amp;lt;&amp;lt; 1) ^ (n &amp;gt;&amp;gt; 31)&lt;br/&gt;64位： (n &amp;lt;&amp;lt; 1) ^ (n &amp;gt;&amp;gt; 63)&lt;br/&gt;&lt;br/&gt;&lt;br/&gt;/*&lt;br/&gt; * 算法步骤：&lt;br/&gt; * 1. 不分正负：符号位后置，数值位前移&lt;br/&gt; * 2. 对于负数：符号位不变，数值位取反&lt;br/&gt; */&lt;br/&gt;&lt;br/&gt;&lt;br/&gt;// 示例&lt;br/&gt;负数(-11）&lt;br/&gt;  补码：                     11111111  11111111  11111111  11110101&lt;br/&gt;  符号位后置，数值位前移：      11111111  11111111  11111111  11101011&lt;br/&gt;  符号位不变，数值位取反(21)：  00000000  00000000  00000000  00010101&lt;br/&gt;&lt;br/&gt;正数(11）&lt;br/&gt;  补码：                     00000000  00000000  00000000  00010101&lt;br/&gt;  符号位后置，数值位前移(22)：  00000000  00000000  00000000  00101010&lt;br/&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;【奇怪的知识】为什么取名叫 zigzag？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;因为这个算法将负数编码成正奇数，正数编码成偶数。最后效果是正负数穿插向前，就像这样：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;编码前       编码后&lt;br/&gt;  0           0&lt;br/&gt;  -1          1&lt;br/&gt;  1           2&lt;br/&gt;  -2          3&lt;br/&gt;  2           4&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;Json 协议&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Thrift 不仅支持二进制序列化协议，也支持 Json 这种文本协议&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;数据格式&lt;span/&gt;&lt;/h4&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;/* bool、i8、i16、i32、i64、double、string */&lt;br/&gt;&lt;span&gt;&quot;编号&quot;&lt;/span&gt;: {&lt;br/&gt;  &lt;span&gt;&quot;类型&quot;&lt;/span&gt;: &lt;span&gt;&quot;值&quot;&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;// 示例&lt;br/&gt;&lt;span&gt;&quot;1&quot;&lt;/span&gt;: {&lt;br/&gt;  &lt;span&gt;&quot;str&quot;&lt;/span&gt;: &lt;span&gt;&quot;keyword&quot;&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;br/&gt;/* struct */&lt;br/&gt;&lt;span&gt;&quot;编号&quot;&lt;/span&gt;: {&lt;br/&gt;  &lt;span&gt;&quot;rec&quot;&lt;/span&gt;: {&lt;br/&gt;    &lt;span&gt;&quot;成员编号&quot;&lt;/span&gt;: {&lt;br/&gt;      &lt;span&gt;&quot;成员类型&quot;&lt;/span&gt;: &lt;span&gt;&quot;成员值&quot;&lt;/span&gt;&lt;br/&gt;    },&lt;br/&gt;    ...&lt;br/&gt;  }&lt;br/&gt;}&lt;br/&gt;// 示例&lt;br/&gt;&lt;span&gt;&quot;1&quot;&lt;/span&gt;: {&lt;br/&gt;  &lt;span&gt;&quot;rec&quot;&lt;/span&gt;: {&lt;br/&gt;    &lt;span&gt;&quot;1&quot;&lt;/span&gt;: {&lt;br/&gt;      &lt;span&gt;&quot;i32&quot;&lt;/span&gt;: 50&lt;br/&gt;    }&lt;br/&gt;  }&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;br/&gt;/* map */&lt;br/&gt;&lt;span&gt;&quot;编号&quot;&lt;/span&gt;: {&lt;br/&gt;  &lt;span&gt;&quot;map&quot;&lt;/span&gt;: [&lt;br/&gt;    &lt;span&gt;&quot;键类型&quot;&lt;/span&gt;,&lt;br/&gt;    &lt;span&gt;&quot;值类型&quot;&lt;/span&gt;,&lt;br/&gt;    元素个数,&lt;br/&gt;      &lt;span&gt;&quot;键1&quot;&lt;/span&gt;,&lt;br/&gt;      &lt;span&gt;&quot;值1&quot;&lt;/span&gt;,&lt;br/&gt;      ...&lt;br/&gt;      &lt;span&gt;&quot;键n&quot;&lt;/span&gt;,&lt;br/&gt;      &lt;span&gt;&quot;值n&quot;&lt;/span&gt;&lt;br/&gt;   ]&lt;br/&gt;}&lt;br/&gt;// 示例&lt;br/&gt;&lt;span&gt;&quot;6&quot;&lt;/span&gt;: {&lt;br/&gt;  &lt;span&gt;&quot;map&quot;&lt;/span&gt;: [&lt;br/&gt;    &lt;span&gt;&quot;i64&quot;&lt;/span&gt;,&lt;br/&gt;    &lt;span&gt;&quot;str&quot;&lt;/span&gt;,&lt;br/&gt;    1,&lt;br/&gt;    666,&lt;br/&gt;    &lt;span&gt;&quot;mapValue&quot;&lt;/span&gt;&lt;br/&gt;  ]&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;br/&gt;/* List */&lt;br/&gt;&lt;span&gt;&quot;编号&quot;&lt;/span&gt;: {&lt;br/&gt;  &lt;span&gt;&quot;set/lst&quot;&lt;/span&gt;: [&lt;br/&gt;    &lt;span&gt;&quot;值类型&quot;&lt;/span&gt;,&lt;br/&gt;    元素个数,&lt;br/&gt;    &lt;span&gt;&quot;ele1&quot;&lt;/span&gt;,&lt;br/&gt;    &lt;span&gt;&quot;ele2&quot;&lt;/span&gt;,&lt;br/&gt;    &lt;span&gt;&quot;elen&quot;&lt;/span&gt;&lt;br/&gt;  ]&lt;br/&gt;}&lt;br/&gt;// 示例&lt;br/&gt;&lt;span&gt;&quot;2&quot;&lt;/span&gt;: {&lt;br/&gt;  &lt;span&gt;&quot;lst&quot;&lt;/span&gt;: [&lt;br/&gt;    &lt;span&gt;&quot;str&quot;&lt;/span&gt;,&lt;br/&gt;    2,&lt;br/&gt;    &lt;span&gt;&quot;lark&quot;&lt;/span&gt;,&lt;span&gt;&quot;keyword&quot;&lt;/span&gt;]&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;case 分析&lt;/h2&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;修改字段类型导致 RPC 超时&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;现象：A 服务访问 B 服务，业务逻辑短时间处理完，但整个请求 15s 超时，必现。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;直接原因：IDL 类型被修改；并且只升级了服务端（B 服务），没升级客户端（A 服务）&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.31368993653671806&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/5EcwYhllQOiaQFeS3PEy4Qvdh15OU7JPIiac3ia5DgujnicJnlx4uoS1aPHE7Z9rgFAq0icRmxmfSY3PkDqrClwp8xQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2206&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;本质原因：string 是变长编码，i64 是定长编码。由于客户端没有升级，所以反序列化的时候，会把 signTime 当做 string 类型来解析。而变长编码是 T-L-V 模式，所以解析的时候会把 signTime 的低位 4 字节翻译成 string 的 length。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;signTime 是时间戳，大整数，比如：1624206147902，转成二进制为：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;00000000 00000000 00000001 01111010 00101010 00111011 00000001 00111110&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;低位 4 字节转成十进制为：378&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;也就是要再读 378 个字节作为 SignTime 的值，这已经超过了整个 payload 的大小，最终导致 Socket 读超时。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;【注】修改类型不一定就会导致超时，如果 value 的值比较小，解析到的 length 也比较小，能够保证读完。但是错误的解析可能会导致各种预期之外的情况，包括：&lt;/p&gt;&lt;ol class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;乱码&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;空值&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;报错：unknown data type xxx （skip 异常）&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;/blockquote&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;常见问题&lt;/h2&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;兼容性&lt;span/&gt;&lt;/h3&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;增加字段&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;通过 skip 来跳过增加的字段，从而保证兼容性&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.550185873605948&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/5EcwYhllQOiaQFeS3PEy4Qvdh15OU7JPIqduvE5zmCdobaa7Xhj86ZrNucsEhWDfJ65gQ78VJ95paGfpUkwy21g/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2152&quot;/&gt;&lt;/figure&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;删除字段&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;编译生成的解析代码是基于 field_id 的 switch-case 结构，语法结构上直接具备兼容性。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.49913344887348354&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/5EcwYhllQOiaQFeS3PEy4Qvdh15OU7JPIY25mOuC4YEsviba15EvnNcLcWFNVYCib3ibl0Gyn12dVpaibGzcdXvPW8w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2308&quot;/&gt;&lt;/figure&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;修改字段名&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;不破坏兼容性，因为 binary 协议不会对 name 进行编码&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;Exception&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Thrift 有两种 Exception，一种是框架内置的异常，一种是 IDL 自定义的异常。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;框架内置的异常包括：「方法名错误」、「消息序列号错误」、「协议错误」，这些异常由框架捕获并封装成 Exception 消息，反序列化时会转成 error 并抛给上层，逻辑如下：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5452586206896551&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/5EcwYhllQOiaQFeS3PEy4Qvdh15OU7JPI5fdYBoZPz4artJQYfhKrIeiabySQscvsq12F9ZoeLZTDVPSTBqN1oYA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1856&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;另一种异常是由用户在 IDL 中自定义的，关键字是 exception，用法上跟 struct 没有太大区别。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.28315946348733234&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/5EcwYhllQOiaQFeS3PEy4Qvdh15OU7JPIdov82JAyeXYUJRfBibgDPpbyvoIo4eAUDcmNqx1hHFFq7sBmAFXLdLA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1342&quot;/&gt;&lt;/figure&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;optional、require 实现原理&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;optional 表示字段可填，require 表示必填&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;span&gt;字段被标识为 optional 之后：&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;基本类型会被编译为指针类型&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;序列化代码会做空值判断，如果字段为空，则不会被编码&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;span&gt;字段被标识为 require 之后：&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;基本类型会被编译为非指针类型（复合类型 optional 和 require 没区别）&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;序列化不会做空值判断，字段一定会被编码。如果没有显式赋值，就编码默认值（默认空值，或者 IDL 显式指定的默认值）&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/ul&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>7af845a3418e67b0ef038a16bc1e866b</guid>
<title>日志导致线程Block的这些坑，你不得不防</title>
<link>https://toutiao.io/k/eakgqf8</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content                                       &quot; id=&quot;js_content&quot;&gt;
            &lt;p data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;578&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;58&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.1546875&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsU2zk0q52HtKQjubeUEyZHBVHPgeBXgTUj0ib1Kwfosl82xO1Aw7x6gccLuuYs1dbxI7REI7OcjbGw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;总第525&lt;/span&gt;&lt;/strong&gt;&lt;strong&gt;&lt;span&gt;篇&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;2022年 第042篇&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;section data-role=&quot;outer&quot; label=&quot;Powered by 135editor.com&quot;&gt;&lt;section data-role=&quot;outer&quot; label=&quot;Powered by 135editor.com&quot;&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;127&quot;&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;127&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;p&gt;&lt;img border=&quot;0&quot; class=&quot;rich_pages wxw-img&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;103&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;103&quot; data-ratio=&quot;1&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsU2zk0q52HtKQjubeUEyZHBic5ADGrKxgSd0tibyMiasOHXjb46qFBw7PTfuWAxXzWq32lDkL05icwkMg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;750&quot; data-width=&quot;100%&quot; opacity=&quot;&quot; title=&quot;undefined&quot;/&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-brushtype=&quot;text&quot; data-style=&quot;text-align: left; font-size: 14px; color: inherit;&quot;&gt;&lt;p&gt;&lt;span&gt;研发人员在项目开发中不可避免地要使用日志，通过它来记录信息和排查问题。Apache Log4j2提供了灵活且强大的日志框架，虽然上手比较快，但稍有不慎也非常容易踩“坑”。&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;本文介绍了美团统一API网关服务Shepherd在实践中所踩过的关于日志导致线程Block的那些“坑”，以及我们如何从日志框架源码层面进行分析和解决问题的过程，并在最后给大家分享一些关于日志避“坑”的实践经验，希望能给大家带来一些帮助。&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;1. 前言&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;2. 背景&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;3. 踩过的坑&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;4. 避坑指南&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;5. 最佳实践&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;1. 前言&lt;/span&gt;&lt;/h2&gt;&lt;section&gt;&lt;span&gt;日志对程序的重要性不言而喻。它很“大”，我们在项目中经常通过日志来记录信息和排查问题，相关代码随处可见。它也很“小”，作为辅助工具，日志使用简单、上手快，我们通常不会花费过多精力耗在日志上。但看似不起眼的日志也隐藏着各种各样的“坑”，如果使用不当，它不仅不能帮助我们，反而还可能降低服务性能，甚至拖垮我们的服务。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;日志导致线程Block的问题，相信你或许已经遇到过，对此应该深有体会；或许你还没遇到过，但不代表没有问题，只是可能还没有触发而已。本文主要介绍美团统一API网关服务Shepherd（&lt;/span&gt;&lt;span&gt;参见&lt;/span&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MjM5NjQ5MTI5OA==&amp;amp;mid=2651762298&amp;amp;idx=1&amp;amp;sn=1fec5406ab2f3cc9161050247d9c1a9a&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;《百亿规模API网关服务Shepherd的设计与实现》&lt;/span&gt;&lt;/a&gt;&lt;span&gt;一文&lt;/span&gt;&lt;span&gt;）在实践中所踩过的关于日志导致线程Block的那些“坑”，然后再分享一些避“坑”经验。&lt;/span&gt;&lt;/section&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;2. 背景&lt;/span&gt;&lt;/h2&gt;&lt;section&gt;&lt;span&gt;API网关服务Shepherd基于Java语言开发，使用业界大名鼎鼎的&lt;/span&gt;&lt;a href=&quot;https://logging.apache.org/log4j/2.x/&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;Apache Log4j2&lt;/span&gt;&lt;/a&gt;&lt;span&gt;作为主要日志框架，同时使用美团内部的XMD-Log SDK和Scribe-Log SDK对日志内容进行处理，日志处理整体流程如下图1所示。业务打印日志时，日志框架基于Logger配置来决定把日志交给XMDFile处理还是Scribe处理。其中，XMDFile是XMD-Log内部提供的日志Appender名称，负责输出日志到本地磁盘，Scribe是Scribe-Log内部提供的日志Appender名称，负责上报日志到远程日志中心。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;542&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;184&quot; data-ratio=&quot;0.3389592123769339&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsXQu61RnticpkHboWVKAGbMJyickBNiboIQLHPnw4QYGyibARL2XZlFianferjD0kqZbQM3AnKEW84yiaKg/640?wx_fmt=png&quot; data-w=&quot;1422&quot;/&gt;&lt;figcaption&gt;&lt;span&gt;图1 日志处理流程示意图&lt;/span&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;随着业务的快速增长，日志导致的线程Block问题愈发频繁。比如调用后端RPC服务超时，导致调用方大量线程Block；再比如，业务内部输出异常日志导致服务大量线程Block等，这些问题严重影响着服务的稳定性。因此，我们结合项目在过去一段时间暴露出来的各种由于日志导致的线程Block问题，对日志框架存在的稳定性风险因素进行了彻底的排查和修复，并在线下、线上环境进行全方位验证。在此过程中，我们总结了一些日志使用相关的实践经验，希望分享给大家。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;在进入正文前，首先介绍项目当时的运行环境和日志相关配置信息。&lt;/span&gt;&lt;/section&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;section&gt;&lt;span&gt;java version &quot;1.8.0_45&quot;&lt;br/&gt;Java(TM) SE Runtime Environment (build 1.8.0_45-b14)&lt;br/&gt;Java HotSpot(TM) 64-Bit Server VM (build 25.45-b02, mixed mode)&lt;/span&gt;&lt;/section&gt;&lt;/pre&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;section&gt;&lt;span&gt;&lt;span&gt;&amp;lt;&lt;span&gt;dependency&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&amp;lt;&lt;span&gt;groupId&lt;/span&gt;&amp;gt;&lt;/span&gt;org.apache.logging.log4j&lt;span&gt;&amp;lt;/&lt;span&gt;groupId&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&amp;lt;&lt;span&gt;artifactId&lt;/span&gt;&amp;gt;&lt;/span&gt;log4j-api&lt;span&gt;&amp;lt;/&lt;span&gt;artifactId&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&amp;lt;&lt;span&gt;version&lt;/span&gt;&amp;gt;&lt;/span&gt;2.7&lt;span&gt;&amp;lt;/&lt;span&gt;version&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&amp;lt;/&lt;span&gt;dependency&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&amp;lt;&lt;span&gt;dependency&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&amp;lt;&lt;span&gt;groupId&lt;/span&gt;&amp;gt;&lt;/span&gt;org.apache.logging.log4j&lt;span&gt;&amp;lt;/&lt;span&gt;groupId&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&amp;lt;&lt;span&gt;artifactId&lt;/span&gt;&amp;gt;&lt;/span&gt;log4j-core&lt;span&gt;&amp;lt;/&lt;span&gt;artifactId&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&amp;lt;&lt;span&gt;version&lt;/span&gt;&amp;gt;&lt;/span&gt;2.7&lt;span&gt;&amp;lt;/&lt;span&gt;version&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&amp;lt;/&lt;span&gt;dependency&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&amp;lt;&lt;span&gt;dependency&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&amp;lt;&lt;span&gt;groupId&lt;/span&gt;&amp;gt;&lt;/span&gt;org.apache.logging.log4j&lt;span&gt;&amp;lt;/&lt;span&gt;groupId&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&amp;lt;&lt;span&gt;artifactId&lt;/span&gt;&amp;gt;&lt;/span&gt;log4j-slf4j-impl&lt;span&gt;&amp;lt;/&lt;span&gt;artifactId&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&amp;lt;&lt;span&gt;version&lt;/span&gt;&amp;gt;&lt;/span&gt;2.7&lt;span&gt;&amp;lt;/&lt;span&gt;version&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&amp;lt;/&lt;span&gt;dependency&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/section&gt;&lt;/pre&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;section&gt;&lt;span&gt;&lt;span&gt;&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&amp;lt;&lt;span&gt;configuration&lt;/span&gt; &lt;span&gt;status&lt;/span&gt;=&lt;span&gt;&quot;warn&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&amp;lt;&lt;span&gt;appenders&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;&amp;lt;&lt;span&gt;Console&lt;/span&gt; &lt;span&gt;name&lt;/span&gt;=&lt;span&gt;&quot;Console&quot;&lt;/span&gt; &lt;span&gt;target&lt;/span&gt;=&lt;span&gt;&quot;SYSTEM_OUT&quot;&lt;/span&gt; &lt;span&gt;follow&lt;/span&gt;=&lt;span&gt;&quot;true&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;&amp;lt;&lt;span&gt;PatternLayout&lt;/span&gt; &lt;span&gt;pattern&lt;/span&gt;=&lt;span&gt;&quot;%d{yyyy/MM/dd HH:mm:ss.SSS} %t [%p] %c{1} (%F:%L) %msg%n&quot;&lt;/span&gt; /&amp;gt;&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;&amp;lt;/&lt;span&gt;Console&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;        &lt;span&gt;&amp;lt;&lt;span&gt;XMDFile&lt;/span&gt; &lt;span&gt;name&lt;/span&gt;=&lt;span&gt;&quot;ShepherdLog&quot;&lt;/span&gt; &lt;span&gt;fileName&lt;/span&gt;=&lt;span&gt;&quot;shepherd.log&quot;&lt;/span&gt;/&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;        &lt;span&gt;&amp;lt;!--XMDFile异步磁盘日志配置示例--&amp;gt;&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;&amp;lt;!--默认按天&amp;amp;按512M文件大小切分日志，默认最多保留30个日志文件。--&amp;gt;&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;&amp;lt;!--注意：fileName前会自动增加文件路径，只配置文件名即可--&amp;gt;&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;&amp;lt;&lt;span&gt;XMDFile&lt;/span&gt; &lt;span&gt;name&lt;/span&gt;=&lt;span&gt;&quot;LocalServiceLog&quot;&lt;/span&gt; &lt;span&gt;fileName&lt;/span&gt;=&lt;span&gt;&quot;request.log&quot;&lt;/span&gt;/&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;        &lt;span&gt;&amp;lt;&lt;span&gt;Scribe&lt;/span&gt; &lt;span&gt;name&lt;/span&gt;=&lt;span&gt;&quot;LogCenterSync&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;&amp;lt;!-- 在指定日志名方面，scribeCategory 和 appkey 两者至少存在一种，且 scribeCategory 高于 appkey。--&amp;gt;&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;&amp;lt;!-- &amp;lt;Property name=&quot;scribeCategory&quot;&amp;gt;data_update_test_lc&amp;lt;/Property&amp;gt; --&amp;gt;&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;&amp;lt;&lt;span&gt;LcLayout&lt;/span&gt;/&amp;gt;&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;&amp;lt;/&lt;span&gt;Scribe&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;&amp;lt;&lt;span&gt;Async&lt;/span&gt; &lt;span&gt;name&lt;/span&gt;=&lt;span&gt;&quot;LogCenterAsync&quot;&lt;/span&gt; &lt;span&gt;blocking&lt;/span&gt;=&lt;span&gt;&quot;false&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;&amp;lt;&lt;span&gt;AppenderRef&lt;/span&gt; &lt;span&gt;ref&lt;/span&gt;=&lt;span&gt;&quot;LogCenterSync&quot;&lt;/span&gt;/&amp;gt;&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;&amp;lt;/&lt;span&gt;Async&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&amp;lt;/&lt;span&gt;appenders&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&amp;lt;&lt;span&gt;loggers&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;&amp;lt;&lt;span&gt;AsyncLogger&lt;/span&gt; &lt;span&gt;name&lt;/span&gt;=&lt;span&gt;&quot;com.sankuai.shepherd&quot;&lt;/span&gt; &lt;span&gt;level&lt;/span&gt;=&lt;span&gt;&quot;info&quot;&lt;/span&gt; &lt;span&gt;additivity&lt;/span&gt;=&lt;span&gt;&quot;false&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;&amp;lt;&lt;span&gt;AppenderRef&lt;/span&gt; &lt;span&gt;ref&lt;/span&gt;=&lt;span&gt;&quot;ShepherdLog&quot;&lt;/span&gt; &lt;span&gt;level&lt;/span&gt;=&lt;span&gt;&quot;warn&quot;&lt;/span&gt;/&amp;gt;&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;&amp;lt;&lt;span&gt;AppenderRef&lt;/span&gt; &lt;span&gt;ref&lt;/span&gt;=&lt;span&gt;&quot;LogCenterAsync&quot;&lt;/span&gt; &lt;span&gt;level&lt;/span&gt;=&lt;span&gt;&quot;info&quot;&lt;/span&gt;/&amp;gt;&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;&amp;lt;/&lt;span&gt;AsyncLogger&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;        &lt;span&gt;&amp;lt;&lt;span&gt;root&lt;/span&gt; &lt;span&gt;level&lt;/span&gt;=&lt;span&gt;&quot;info&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;&amp;lt;!--Console日志是同步、阻塞的，推荐只在本地调试时使用，线上将该配置去掉--&amp;gt;&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;&amp;lt;!--appender-ref ref=&quot;Console&quot; /--&amp;gt;&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;&amp;lt;&lt;span&gt;appender-ref&lt;/span&gt; &lt;span&gt;ref&lt;/span&gt;=&lt;span&gt;&quot;LocalServiceLog&quot;&lt;/span&gt;/&amp;gt;&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;&amp;lt;&lt;span&gt;appender-ref&lt;/span&gt; &lt;span&gt;ref&lt;/span&gt;=&lt;span&gt;&quot;LogCenterAsync&quot;&lt;/span&gt;/&amp;gt;&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;&amp;lt;/&lt;span&gt;root&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&amp;lt;/&lt;span&gt;loggers&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&amp;lt;/&lt;span&gt;configuration&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/section&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;3. 踩过的坑&lt;/span&gt;&lt;/h2&gt;&lt;section&gt;&lt;span&gt;本章节主要记录项目过去一段时间，我们所遇到的一系列日志导致的线程Block问题，并逐个深入分析问题根因。&lt;/span&gt;&lt;/section&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;3.1 日志队列满导致线程Block&lt;/span&gt;&lt;/h3&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;3.1.1 问题现场&lt;/span&gt;&lt;/h4&gt;&lt;section&gt;&lt;span&gt;收到“jvm.thread.blocked.count”告警后立刻通过监控平台查看线程监控指标，当时的线程堆栈如图2和图3所示。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;542&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;272&quot; data-ratio=&quot;0.5010416666666667&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsXQu61RnticpkHboWVKAGbMJwraRbxibEywyvzYrKOhLr6GhJExg0K6qKLeicwWiaaFONeqgBsQtia299A/640?wx_fmt=png&quot; data-w=&quot;1920&quot;/&gt;&lt;/figure&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;542&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;233&quot; data-ratio=&quot;0.4296875&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsXQu61RnticpkHboWVKAGbMJ8q1gTHY8NiavyJCIQPVibdXCzuCCiaF7G15zhE4tiawUzSZKx1r7N8zBqQ/640?wx_fmt=png&quot; data-w=&quot;1920&quot;/&gt;&lt;figcaption&gt;&lt;span&gt;图2 等待锁的Blocked线程堆栈&lt;/span&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;542&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;271&quot; data-ratio=&quot;0.5&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsXQu61RnticpkHboWVKAGbMJFCwsbUn1l3B3DIb8bngIRXDYT8cibfmiafCtyAqzHAjD7OrgwtCP6UTQ/640?wx_fmt=png&quot; data-w=&quot;1920&quot;/&gt;&lt;figcaption&gt;&lt;span&gt;图3 持有锁的Runnable线程堆栈&lt;/span&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;从Blocked线程堆栈不难看出这跟日志打印相关，而且是INFO级别的日志，遂即登陆机器查看日志是否有异样，发现当时日志量非常大，差不多每两分钟就写满一个500MB的日志文件。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;那大量输出日志和线程Block之间会有怎样的关联呢？接下来本章节将结合如下图4所示的调用链路深入分析线程Block的根因。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;542&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;271&quot; data-ratio=&quot;0.5004803073967339&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsXQu61RnticpkHboWVKAGbMJfQMuCFeiaH033ATFjTWpLZiaeZuohtQzhdicGwFxmia5H2icTW9XZ8EjfAw/640?wx_fmt=png&quot; data-w=&quot;2082&quot;/&gt;&lt;figcaption&gt;&lt;span&gt;图4 日志调用链路&lt;/span&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;/section&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;3.1.2 为什么会Block线程？&lt;/span&gt;&lt;/h4&gt;&lt;section&gt;&lt;span&gt;从Blocked线程堆栈着手分析，查看PrintStream相关代码片段如下图5所示，可以看到被阻塞地方有synchronized同步调用，再结合上文发现每两分钟写满一个500MB日志文件的现象，初步怀疑是日志量过大导致了线程阻塞。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;562&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;142&quot; data-ratio=&quot;0.2534908700322234&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsXQu61RnticpkHboWVKAGbMJb7cTxPg2bc3H2AIxkicXER5KqHZwj2PufsrH1QAaX9K27cADUIxRVMQ/640?wx_fmt=png&quot; data-w=&quot;1862&quot;/&gt;&lt;figcaption&gt;&lt;span&gt;图5 PringStream代码片段&lt;/span&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;但上述猜测仍有一些值得推敲的地方：&lt;/span&gt;&lt;/section&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;如果仅仅因为日志量过大就导致线程Block，那日志框架也太不堪重用了，根本没法在高并发、高吞吐业务场景下使用。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;日志配置里明明是输出日志到文件，怎么会输出到Console PrintStream？&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;3.1.3 为什么会输出到Console？&lt;/span&gt;&lt;/h4&gt;&lt;section&gt;&lt;span&gt;继续沿着线程堆栈调用链路分析，可以看出是AsyncAppender调用append方法追加日志时发生了错误，相关代码片段如下：&lt;/span&gt;&lt;/section&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;section&gt;&lt;span&gt;&lt;span&gt;// org.apache.logging.log4j.core.appender.AsyncAppender&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// 内部维护的阻塞队列，队列大小默认是128&lt;/span&gt;&lt;br/&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; BlockingQueue&amp;lt;LogEvent&amp;gt; queue;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;append&lt;/span&gt;&lt;span&gt;(&lt;span&gt;final&lt;/span&gt; LogEvent logEvent)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (!isStarted()) {&lt;br/&gt;        &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; IllegalStateException(&lt;span&gt;&quot;AsyncAppender &quot;&lt;/span&gt; + getName() + &lt;span&gt;&quot; is not active&quot;&lt;/span&gt;);&lt;br/&gt;    }&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (!Constants.FORMAT_MESSAGES_IN_BACKGROUND) { &lt;span&gt;// LOG4J2-898: user may choose&lt;/span&gt;&lt;br/&gt;        logEvent.getMessage().getFormattedMessage(); &lt;span&gt;// LOG4J2-763: ask message to freeze parameters&lt;/span&gt;&lt;br/&gt;    }&lt;br/&gt;    &lt;span&gt;final&lt;/span&gt; Log4jLogEvent memento = Log4jLogEvent.createMemento(logEvent, includeLocation);&lt;br/&gt;   &lt;span&gt;// 日志事件转入异步队列&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (!transfer(memento)) {&lt;br/&gt;       &lt;span&gt;// 执行到这里说明队列满了，入队失败，根据是否blocking执行具体策略&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (blocking) {&lt;br/&gt;           &lt;span&gt;// 阻塞模式，选取特定的策略来处理，策略可能是 &quot;忽略日志&quot;、&quot;日志入队并阻塞&quot;、&quot;当前线程打印日志&quot;&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;// delegate to the event router (which may discard, enqueue and block, or log in current thread)&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;final&lt;/span&gt; EventRoute route = asyncQueueFullPolicy.getRoute(thread.getId(), memento.getLevel());&lt;br/&gt;            route.logMessage(&lt;span&gt;this&lt;/span&gt;, memento);&lt;br/&gt;        } &lt;span&gt;else&lt;/span&gt; {&lt;br/&gt;           &lt;span&gt;// 非阻塞模式，交由 ErrorHandler 处理失败日志&lt;/span&gt;&lt;br/&gt;            error(&lt;span&gt;&quot;Appender &quot;&lt;/span&gt; + getName() + &lt;span&gt;&quot; is unable to write primary appenders. queue is full&quot;&lt;/span&gt;);&lt;br/&gt;            logToErrorAppenderIfNecessary(&lt;span&gt;false&lt;/span&gt;, memento);&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; &lt;span&gt;transfer&lt;/span&gt;&lt;span&gt;(&lt;span&gt;final&lt;/span&gt; LogEvent memento)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; queue &lt;span&gt;instanceof&lt;/span&gt; TransferQueue&lt;br/&gt;        ? ((TransferQueue&amp;lt;LogEvent&amp;gt;) queue).tryTransfer(memento)&lt;br/&gt;        : queue.offer(memento);&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;error&lt;/span&gt;&lt;span&gt;(&lt;span&gt;final&lt;/span&gt; String msg)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    handler.error(msg);&lt;br/&gt;}&lt;/span&gt;&lt;/section&gt;&lt;/pre&gt;&lt;section&gt;&lt;span&gt;AsyncAppender顾名思义是个异步Appender，采用异步方式处理日志，在其内部维护了一个BlockingQueue队列，每次处理日志时，都先尝试把Log4jLogEvent事件存入队列中，然后交由后台线程从队列中取出事件并处理（&lt;/span&gt;&lt;span&gt;把日志交由AsyncAppender所关联的Appender处理&lt;/span&gt;&lt;span&gt;），但队列长度总是有限的，且队列默认大小是128，如果日志量过大或日志异步线程处理不及时，就很可能导致日志队列被打满。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;当日志队列满时，日志框架内部提供了两种处理方式，具体如下：&lt;/span&gt;&lt;/section&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;如果blocking配置为true，会选择相应的处理策略，默认是SYNCHRONOUS策略，可以在log4j2.component.properties文件中，通过log4j2.AsyncQueueFullPolicy参数配置日志框架提供的其他策略或自定义策略。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;DISCARD策略，直接忽略日志。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;SYNCHRONOUS策略，当前线程直接发送日志到Appender。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;ENQUEUE策略，强制阻塞入队。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;如果blocking配置为false，则由ErrorHandler和ErrorAppender处理失败日志。日志框架提供了默认的ErrorHandler实现，即DefaultErrorHandler，目前暂不支持业务在XML、JSON等日志配置文件里自定义ErrorHandler。日志框架默认不提供ErrorAppender，业务如有需要可在XML、JSON等日志配置文件里自定义error-ref配置。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;section&gt;&lt;span&gt;在本项目的日志配置文件中可以看到，AsyncAppender设置了blocking为false，且没有配置error-ref，下面具体分析DefaultErrorHandler。&lt;/span&gt;&lt;/section&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;section&gt;&lt;span&gt;&lt;span&gt;// org.apache.logging.log4j.core.appender.DefaultErrorHandler&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; Logger LOGGER = StatusLogger.getLogger();&lt;br/&gt;&lt;br/&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; MAX_EXCEPTIONS = &lt;span&gt;3&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// 5min 时间间隔&lt;/span&gt;&lt;br/&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;long&lt;/span&gt; EXCEPTION_INTERVAL = TimeUnit.MINUTES.toNanos(&lt;span&gt;5&lt;/span&gt;);&lt;br/&gt;&lt;br/&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; exceptionCount = &lt;span&gt;0&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;long&lt;/span&gt; lastException = System.nanoTime() - EXCEPTION_INTERVAL - &lt;span&gt;1&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;error&lt;/span&gt;&lt;span&gt;(&lt;span&gt;final&lt;/span&gt; String msg)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;final&lt;/span&gt; &lt;span&gt;long&lt;/span&gt; current = System.nanoTime();&lt;br/&gt;   &lt;span&gt;// 当前时间距离上次异常处理时间间隔超过5min 或者异常处理数小于3次&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (current - lastException &amp;gt; EXCEPTION_INTERVAL || exceptionCount++ &amp;lt; MAX_EXCEPTIONS) {&lt;br/&gt;       &lt;span&gt;// StatusLogger 负责处理&lt;/span&gt;&lt;br/&gt;        LOGGER.error(msg);&lt;br/&gt;    }&lt;br/&gt;    lastException = current;&lt;br/&gt;}&lt;/span&gt;&lt;/section&gt;&lt;/pre&gt;&lt;section&gt;&lt;span&gt;DefaultErrorHandler内部在处理异常日志时增加了条件限制，只有下述&lt;strong&gt;两个条件任一满足&lt;/strong&gt;时才会处理，从而避免大量异常日志导致的性能问题。&lt;/span&gt;&lt;/section&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;两条日志处理间隔超过5min。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;异常日志数量不超过3次。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;section&gt;&lt;span&gt;但项目所用日志框架版本的默认实现看起来存在一些不太合理的地方：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;所以，在多线程场景下，可能有大量异常日志同时被DefaultErrorHandler处理，带来线程安全问题。值得一提的是，该问题已有相关&lt;/span&gt;&lt;a href=&quot;https://issues.apache.org/jira/browse/LOG4J2-3185&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;Issue: DefaultErrorHandler can not share values across threads&lt;/span&gt;&lt;/a&gt;&lt;span&gt;反馈给社区，并在&lt;/span&gt;&lt;a href=&quot;https://logging.apache.org/log4j/2.x/changes-report.html#a2.15.0&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;2.15.0&lt;/span&gt;&lt;/a&gt;&lt;span&gt;版本中进行了修复。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;从上述DefaultErrorHandler代码中可以看到，真正负责处理日志的是StatusLogger，继续跟进代码进入logMessage方法，方法执行逻辑如下：&lt;/span&gt;&lt;/section&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;如果StatusLogger内部注册了StatusListener，则由对应的StatusListener负责处理日志。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;否则由SimpleLogger负责处理日志，直接输出日志到System.err输出流。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;section&gt;&lt;span&gt;&lt;span&gt;// org.apache.logging.log4j.status.StatusLogger&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; StatusLogger STATUS_LOGGER = &lt;span&gt;new&lt;/span&gt; StatusLogger(StatusLogger&lt;span&gt;.&lt;span&gt;class&lt;/span&gt;.&lt;span&gt;getName&lt;/span&gt;(),&lt;br/&gt;            &lt;span&gt;ParameterizedNoReferenceMessageFactory&lt;/span&gt;.&lt;span&gt;INSTANCE&lt;/span&gt;)&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// StatusListener&lt;/span&gt;&lt;br/&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; Collection&amp;lt;StatusListener&amp;gt; listeners = &lt;span&gt;new&lt;/span&gt; CopyOnWriteArrayList&amp;lt;&amp;gt;();&lt;br/&gt;&lt;br/&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; SimpleLogger logger;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;StatusLogger&lt;/span&gt;&lt;span&gt;(&lt;span&gt;final&lt;/span&gt; String name, &lt;span&gt;final&lt;/span&gt; MessageFactory messageFactory)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;super&lt;/span&gt;(name, messageFactory);&lt;br/&gt;    &lt;span&gt;this&lt;/span&gt;.logger = &lt;span&gt;new&lt;/span&gt; SimpleLogger(&lt;span&gt;&quot;StatusLogger&quot;&lt;/span&gt;, Level.ERROR, &lt;span&gt;false&lt;/span&gt;, &lt;span&gt;true&lt;/span&gt;, &lt;span&gt;false&lt;/span&gt;, &lt;span&gt;false&lt;/span&gt;, Strings.EMPTY,&lt;br/&gt;            messageFactory, PROPS, System.err);&lt;br/&gt;    &lt;span&gt;this&lt;/span&gt;.listenersLevel = Level.toLevel(DEFAULT_STATUS_LEVEL, Level.WARN).intLevel();&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;/**&lt;br/&gt; * Retrieve the StatusLogger.&lt;br/&gt; *&lt;br/&gt; * &lt;span&gt;@return&lt;/span&gt; The StatusLogger.&lt;br/&gt; */&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; StatusLogger &lt;span&gt;getLogger&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; STATUS_LOGGER;&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;logMessage&lt;/span&gt;&lt;span&gt;(&lt;span&gt;final&lt;/span&gt; String fqcn, &lt;span&gt;final&lt;/span&gt; Level level, &lt;span&gt;final&lt;/span&gt; Marker marker, &lt;span&gt;final&lt;/span&gt; Message msg,&lt;br/&gt;        &lt;span&gt;final&lt;/span&gt; Throwable t)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    StackTraceElement element = &lt;span&gt;null&lt;/span&gt;;&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (fqcn != &lt;span&gt;null&lt;/span&gt;) {&lt;br/&gt;        element = getStackTraceElement(fqcn, Thread.currentThread().getStackTrace());&lt;br/&gt;    }&lt;br/&gt;    &lt;span&gt;final&lt;/span&gt; StatusData data = &lt;span&gt;new&lt;/span&gt; StatusData(element, level, msg, t, &lt;span&gt;null&lt;/span&gt;);&lt;br/&gt;    msgLock.lock();&lt;br/&gt;    &lt;span&gt;try&lt;/span&gt; {&lt;br/&gt;        messages.add(data);&lt;br/&gt;    } &lt;span&gt;finally&lt;/span&gt; {&lt;br/&gt;        msgLock.unlock();&lt;br/&gt;    }&lt;br/&gt;  &lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (listeners.size() &amp;gt; &lt;span&gt;0&lt;/span&gt;) {&lt;br/&gt;       &lt;span&gt;// 如果系统注册了 listener，由 StatusConsoleListener 处理日志&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;final&lt;/span&gt; StatusListener listener : listeners) {&lt;br/&gt;            &lt;span&gt;if&lt;/span&gt; (data.getLevel().isMoreSpecificThan(listener.getStatusLevel())) {&lt;br/&gt;                listener.log(data);&lt;br/&gt;            }&lt;br/&gt;        }&lt;br/&gt;    } &lt;span&gt;else&lt;/span&gt; {&lt;br/&gt;       &lt;span&gt;// 否则由 SimpleLogger 处理日志，直接输出到 System.err&lt;/span&gt;&lt;br/&gt;        logger.logMessage(fqcn, level, marker, msg, t);&lt;br/&gt;    }&lt;br/&gt;}&lt;/span&gt;&lt;/section&gt;&lt;/pre&gt;&lt;section&gt;&lt;span&gt;从上述Blocked线程堆栈来看，是StatusConsoleListener负责处理日志，而StatusConsoleListener是StatusListener接口的实现类，那么StatusConsoleListener是如何被创建的？&lt;/span&gt;&lt;/section&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;3.1.4 StatusConsoleListener是怎么来的？&lt;/span&gt;&lt;/h4&gt;&lt;section&gt;&lt;span&gt;通常来说，每个项目都会有一个日志配置文件（&lt;/span&gt;&lt;span&gt;如log4j2.xml&lt;/span&gt;&lt;span&gt;），该配置对应Log4j2日志框架中的Configuration接口，不同的日志配置文件格式有不同的实现类：&lt;/span&gt;&lt;/section&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;XmlConfiguration，即XML格式日志配置&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;JsonConfiguration，即JSON格式日志配置&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;XMDConfiguration，即美团内部日志组件XMD-Log定义的日志配置（&lt;/span&gt;&lt;span&gt;XML格式&lt;/span&gt;&lt;span&gt;）&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;......&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;section&gt;&lt;span&gt;log4j2.xml 示例配置（&lt;/span&gt;&lt;span&gt;仅做示例，请勿实际项目中使用该配置&lt;/span&gt;&lt;span&gt;）。&lt;/span&gt;&lt;/section&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;section&gt;&lt;span&gt;&lt;span&gt;&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&amp;lt;&lt;span&gt;Configuration&lt;/span&gt; &lt;span&gt;status&lt;/span&gt;=&lt;span&gt;&quot;debug&quot;&lt;/span&gt; &lt;span&gt;name&lt;/span&gt;=&lt;span&gt;&quot;RoutingTest&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;&amp;lt;&lt;span&gt;Properties&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&amp;lt;&lt;span&gt;Property&lt;/span&gt; &lt;span&gt;name&lt;/span&gt;=&lt;span&gt;&quot;filename&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;target/rolling1/rollingtest-$${sd:type}.log&lt;span&gt;&amp;lt;/&lt;span&gt;Property&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;&amp;lt;/&lt;span&gt;Properties&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;&amp;lt;&lt;span&gt;ThresholdFilter&lt;/span&gt; &lt;span&gt;level&lt;/span&gt;=&lt;span&gt;&quot;debug&quot;&lt;/span&gt;/&amp;gt;&lt;/span&gt;&lt;br/&gt; &lt;br/&gt;  &lt;span&gt;&amp;lt;&lt;span&gt;Appenders&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&amp;lt;&lt;span&gt;Console&lt;/span&gt; &lt;span&gt;name&lt;/span&gt;=&lt;span&gt;&quot;STDOUT&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;&amp;lt;&lt;span&gt;PatternLayout&lt;/span&gt; &lt;span&gt;pattern&lt;/span&gt;=&lt;span&gt;&quot;%m%n&quot;&lt;/span&gt;/&amp;gt;&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;&amp;lt;&lt;span&gt;ThresholdFilter&lt;/span&gt; &lt;span&gt;level&lt;/span&gt;=&lt;span&gt;&quot;debug&quot;&lt;/span&gt;/&amp;gt;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&amp;lt;/&lt;span&gt;Console&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&amp;lt;&lt;span&gt;Routing&lt;/span&gt; &lt;span&gt;name&lt;/span&gt;=&lt;span&gt;&quot;Routing&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;&amp;lt;&lt;span&gt;Routes&lt;/span&gt; &lt;span&gt;pattern&lt;/span&gt;=&lt;span&gt;&quot;$${sd:type}&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;&amp;lt;&lt;span&gt;Route&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;          &lt;span&gt;&amp;lt;&lt;span&gt;RollingFile&lt;/span&gt; &lt;span&gt;name&lt;/span&gt;=&lt;span&gt;&quot;Rolling-${sd:type}&quot;&lt;/span&gt; &lt;span&gt;fileName&lt;/span&gt;=&lt;span&gt;&quot;${filename}&quot;&lt;/span&gt;&lt;br/&gt;                       &lt;span&gt;filePattern&lt;/span&gt;=&lt;span&gt;&quot;target/rolling1/test1-${sd:type}.%i.log.gz&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;&amp;lt;&lt;span&gt;PatternLayout&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;              &lt;span&gt;&amp;lt;&lt;span&gt;pattern&lt;/span&gt;&amp;gt;&lt;/span&gt;%d %p %c{1.} [%t] %m%n&lt;span&gt;&amp;lt;/&lt;span&gt;pattern&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;&amp;lt;/&lt;span&gt;PatternLayout&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;&amp;lt;&lt;span&gt;SizeBasedTriggeringPolicy&lt;/span&gt; &lt;span&gt;size&lt;/span&gt;=&lt;span&gt;&quot;500&quot;&lt;/span&gt; /&amp;gt;&lt;/span&gt;&lt;br/&gt;          &lt;span&gt;&amp;lt;/&lt;span&gt;RollingFile&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;&amp;lt;/&lt;span&gt;Route&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;&amp;lt;&lt;span&gt;Route&lt;/span&gt; &lt;span&gt;ref&lt;/span&gt;=&lt;span&gt;&quot;STDOUT&quot;&lt;/span&gt; &lt;span&gt;key&lt;/span&gt;=&lt;span&gt;&quot;Audit&quot;&lt;/span&gt;/&amp;gt;&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;&amp;lt;/&lt;span&gt;Routes&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&amp;lt;/&lt;span&gt;Routing&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;&amp;lt;/&lt;span&gt;Appenders&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt; &lt;br/&gt;  &lt;span&gt;&amp;lt;&lt;span&gt;Loggers&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&amp;lt;&lt;span&gt;Logger&lt;/span&gt; &lt;span&gt;name&lt;/span&gt;=&lt;span&gt;&quot;EventLogger&quot;&lt;/span&gt; &lt;span&gt;level&lt;/span&gt;=&lt;span&gt;&quot;info&quot;&lt;/span&gt; &lt;span&gt;additivity&lt;/span&gt;=&lt;span&gt;&quot;false&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;&amp;lt;&lt;span&gt;AppenderRef&lt;/span&gt; &lt;span&gt;ref&lt;/span&gt;=&lt;span&gt;&quot;Routing&quot;&lt;/span&gt;/&amp;gt;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&amp;lt;/&lt;span&gt;Logger&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt; &lt;br/&gt;    &lt;span&gt;&amp;lt;&lt;span&gt;Root&lt;/span&gt; &lt;span&gt;level&lt;/span&gt;=&lt;span&gt;&quot;error&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;&amp;lt;&lt;span&gt;AppenderRef&lt;/span&gt; &lt;span&gt;ref&lt;/span&gt;=&lt;span&gt;&quot;STDOUT&quot;&lt;/span&gt;/&amp;gt;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&amp;lt;/&lt;span&gt;Root&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;&amp;lt;/&lt;span&gt;Loggers&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&amp;lt;/&lt;span&gt;Configuration&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/section&gt;&lt;/pre&gt;&lt;section&gt;&lt;span&gt;Log4j2在启动时会加载并解析log4j2.xml配置文件，由对应的ConfigurationFactory创建具体Configuration实例。&lt;/span&gt;&lt;/section&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;section&gt;&lt;span&gt;&lt;span&gt;// org.apache.logging.log4j.core.config.xml.XmlConfiguration&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;XmlConfiguration&lt;/span&gt;&lt;span&gt;(&lt;span&gt;final&lt;/span&gt; LoggerContext loggerContext, &lt;span&gt;final&lt;/span&gt; ConfigurationSource configSource)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;super&lt;/span&gt;(loggerContext, configSource);&lt;br/&gt;    &lt;span&gt;final&lt;/span&gt; File configFile = configSource.getFile();&lt;br/&gt;    &lt;span&gt;byte&lt;/span&gt;[] buffer = &lt;span&gt;null&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;try&lt;/span&gt; {&lt;br/&gt;        &lt;span&gt;final&lt;/span&gt; InputStream configStream = configSource.getInputStream();&lt;br/&gt;        &lt;span&gt;try&lt;/span&gt; {&lt;br/&gt;            buffer = toByteArray(configStream);&lt;br/&gt;        } &lt;span&gt;finally&lt;/span&gt; {&lt;br/&gt;            Closer.closeSilently(configStream);&lt;br/&gt;        }&lt;br/&gt;        &lt;span&gt;final&lt;/span&gt; InputSource source = &lt;span&gt;new&lt;/span&gt; InputSource(&lt;span&gt;new&lt;/span&gt; ByteArrayInputStream(buffer));&lt;br/&gt;        source.setSystemId(configSource.getLocation());&lt;br/&gt;        &lt;span&gt;final&lt;/span&gt; DocumentBuilder documentBuilder = newDocumentBuilder(&lt;span&gt;true&lt;/span&gt;);&lt;br/&gt;        Document document;&lt;br/&gt;        &lt;span&gt;try&lt;/span&gt; {&lt;br/&gt;           &lt;span&gt;// 解析 xml 配置文件&lt;/span&gt;&lt;br/&gt;            document = documentBuilder.parse(source);&lt;br/&gt;        } &lt;span&gt;catch&lt;/span&gt; (&lt;span&gt;final&lt;/span&gt; Exception e) {&lt;br/&gt;            &lt;span&gt;// LOG4J2-1127&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;final&lt;/span&gt; Throwable throwable = Throwables.getRootCause(e);&lt;br/&gt;            &lt;span&gt;if&lt;/span&gt; (throwable &lt;span&gt;instanceof&lt;/span&gt; UnsupportedOperationException) {&lt;br/&gt;                LOGGER.warn(&lt;br/&gt;                        &lt;span&gt;&quot;The DocumentBuilder {} does not support an operation: {}.&quot;&lt;/span&gt;&lt;br/&gt;                        + &lt;span&gt;&quot;Trying again without XInclude...&quot;&lt;/span&gt;,&lt;br/&gt;                        documentBuilder, e);&lt;br/&gt;                document = newDocumentBuilder(&lt;span&gt;false&lt;/span&gt;).parse(source);&lt;br/&gt;            } &lt;span&gt;else&lt;/span&gt; {&lt;br/&gt;                &lt;span&gt;throw&lt;/span&gt; e;&lt;br/&gt;            }&lt;br/&gt;        }&lt;br/&gt;        rootElement = document.getDocumentElement();&lt;br/&gt;       &lt;span&gt;// 处理根节点属性配置，即 &amp;lt;Configuration&amp;gt;&amp;lt;/Configuration&amp;gt; 节点&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;final&lt;/span&gt; Map&amp;lt;String, String&amp;gt; attrs = processAttributes(rootNode, rootElement);&lt;br/&gt;       &lt;span&gt;// 创建 StatusConfiguration&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;final&lt;/span&gt; StatusConfiguration statusConfig = &lt;span&gt;new&lt;/span&gt; StatusConfiguration().withVerboseClasses(VERBOSE_CLASSES)&lt;br/&gt;                .withStatus(getDefaultStatus());&lt;br/&gt;        &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;final&lt;/span&gt; Map.Entry&amp;lt;String, String&amp;gt; entry : attrs.entrySet()) {&lt;br/&gt;            &lt;span&gt;final&lt;/span&gt; String key = entry.getKey();&lt;br/&gt;            &lt;span&gt;final&lt;/span&gt; String value = getStrSubstitutor().replace(entry.getValue());&lt;br/&gt;           &lt;span&gt;// 根据配置文件中的 status 属性值，来设置 StatusConfiguration 的 status level&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;if&lt;/span&gt; (&lt;span&gt;&quot;status&quot;&lt;/span&gt;.equalsIgnoreCase(key)) {&lt;br/&gt;                statusConfig.withStatus(value);&lt;br/&gt;            &lt;span&gt;// 根据配置文件中的 dest 属性值，来设置 StatusConfiguration 的日志输出 destination&lt;/span&gt;&lt;br/&gt;            } &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (&lt;span&gt;&quot;dest&quot;&lt;/span&gt;.equalsIgnoreCase(key)) {&lt;br/&gt;                statusConfig.withDestination(value);&lt;br/&gt;            } &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (&lt;span&gt;&quot;shutdownHook&quot;&lt;/span&gt;.equalsIgnoreCase(key)) {&lt;br/&gt;                isShutdownHookEnabled = !&lt;span&gt;&quot;disable&quot;&lt;/span&gt;.equalsIgnoreCase(value);&lt;br/&gt;            } &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (&lt;span&gt;&quot;verbose&quot;&lt;/span&gt;.equalsIgnoreCase(key)) {&lt;br/&gt;                statusConfig.withVerbosity(value);&lt;br/&gt;            } &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (&lt;span&gt;&quot;packages&quot;&lt;/span&gt;.equalsIgnoreCase(key)) {&lt;br/&gt;                pluginPackages.addAll(Arrays.asList(value.split(Patterns.COMMA_SEPARATOR)));&lt;br/&gt;            } &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (&lt;span&gt;&quot;name&quot;&lt;/span&gt;.equalsIgnoreCase(key)) {&lt;br/&gt;                setName(value);&lt;br/&gt;            } &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (&lt;span&gt;&quot;strict&quot;&lt;/span&gt;.equalsIgnoreCase(key)) {&lt;br/&gt;                strict = Boolean.parseBoolean(value);&lt;br/&gt;            } &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (&lt;span&gt;&quot;schema&quot;&lt;/span&gt;.equalsIgnoreCase(key)) {&lt;br/&gt;                schemaResource = value;&lt;br/&gt;            } &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (&lt;span&gt;&quot;monitorInterval&quot;&lt;/span&gt;.equalsIgnoreCase(key)) {&lt;br/&gt;                &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; intervalSeconds = Integer.parseInt(value);&lt;br/&gt;                &lt;span&gt;if&lt;/span&gt; (intervalSeconds &amp;gt; &lt;span&gt;0&lt;/span&gt;) {&lt;br/&gt;                    getWatchManager().setIntervalSeconds(intervalSeconds);&lt;br/&gt;                    &lt;span&gt;if&lt;/span&gt; (configFile != &lt;span&gt;null&lt;/span&gt;) {&lt;br/&gt;                        &lt;span&gt;final&lt;/span&gt; FileWatcher watcher = &lt;span&gt;new&lt;/span&gt; ConfiguratonFileWatcher(&lt;span&gt;this&lt;/span&gt;, listeners);&lt;br/&gt;                        getWatchManager().watchFile(configFile, watcher);&lt;br/&gt;                    }&lt;br/&gt;                }&lt;br/&gt;            } &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (&lt;span&gt;&quot;advertiser&quot;&lt;/span&gt;.equalsIgnoreCase(key)) {&lt;br/&gt;                createAdvertiser(value, configSource, buffer, &lt;span&gt;&quot;text/xml&quot;&lt;/span&gt;);&lt;br/&gt;            }&lt;br/&gt;        }&lt;br/&gt;      &lt;br/&gt;       &lt;span&gt;// 初始化 StatusConfiguration&lt;/span&gt;&lt;br/&gt;        statusConfig.initialize();&lt;br/&gt;    } &lt;span&gt;catch&lt;/span&gt; (&lt;span&gt;final&lt;/span&gt; SAXException | IOException | ParserConfigurationException e) {&lt;br/&gt;        LOGGER.error(&lt;span&gt;&quot;Error parsing &quot;&lt;/span&gt; + configSource.getLocation(), e);&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (getName() == &lt;span&gt;null&lt;/span&gt;) {&lt;br/&gt;        setName(configSource.getLocation());&lt;br/&gt;    }&lt;br/&gt;  &lt;br/&gt;   &lt;span&gt;// 忽略以下内容&lt;/span&gt;&lt;br/&gt;}&lt;/span&gt;&lt;/section&gt;&lt;/pre&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;section&gt;&lt;span&gt;&lt;span&gt;// org.apache.logging.log4j.core.config.status.StatusConfiguration&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; PrintStream DEFAULT_STREAM = System.out;&lt;br/&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; Level DEFAULT_STATUS = Level.ERROR;&lt;br/&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; Verbosity DEFAULT_VERBOSITY = Verbosity.QUIET;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; Collection&amp;lt;String&amp;gt; errorMessages = Collections.synchronizedCollection(&lt;span&gt;new&lt;/span&gt; LinkedList&amp;lt;String&amp;gt;());&lt;br/&gt;&lt;span&gt;// StatusLogger&lt;/span&gt;&lt;br/&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; StatusLogger logger = StatusLogger.getLogger();&lt;br/&gt;&lt;br/&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;volatile&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; initialized = &lt;span&gt;false&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;private&lt;/span&gt; PrintStream destination = DEFAULT_STREAM;&lt;br/&gt;&lt;span&gt;private&lt;/span&gt; Level status = DEFAULT_STATUS;&lt;br/&gt;&lt;span&gt;private&lt;/span&gt; Verbosity verbosity = DEFAULT_VERBOSITY;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;initialize&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;this&lt;/span&gt;.initialized) {&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (&lt;span&gt;this&lt;/span&gt;.status == Level.OFF) {&lt;br/&gt;            &lt;span&gt;this&lt;/span&gt;.initialized = &lt;span&gt;true&lt;/span&gt;;&lt;br/&gt;        } &lt;span&gt;else&lt;/span&gt; {&lt;br/&gt;            &lt;span&gt;final&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; configured = configureExistingStatusConsoleListener();&lt;br/&gt;            &lt;span&gt;if&lt;/span&gt; (!configured) {&lt;br/&gt;               &lt;span&gt;// 注册新 StatusConsoleListener&lt;/span&gt;&lt;br/&gt;                registerNewStatusConsoleListener();&lt;br/&gt;            }&lt;br/&gt;            migrateSavedLogMessages();&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; &lt;span&gt;configureExistingStatusConsoleListener&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;boolean&lt;/span&gt; configured = &lt;span&gt;false&lt;/span&gt;;&lt;br/&gt;    &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;final&lt;/span&gt; StatusListener statusListener : &lt;span&gt;this&lt;/span&gt;.logger.getListeners()) {&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (statusListener &lt;span&gt;instanceof&lt;/span&gt; StatusConsoleListener) {&lt;br/&gt;            &lt;span&gt;final&lt;/span&gt; StatusConsoleListener listener = (StatusConsoleListener) statusListener;&lt;br/&gt;           &lt;span&gt;// StatusConsoleListener 的 level 以 StatusConfiguration 的 status 为准&lt;/span&gt;&lt;br/&gt;            listener.setLevel(&lt;span&gt;this&lt;/span&gt;.status);&lt;br/&gt;            &lt;span&gt;this&lt;/span&gt;.logger.updateListenerLevel(&lt;span&gt;this&lt;/span&gt;.status);&lt;br/&gt;            &lt;span&gt;if&lt;/span&gt; (&lt;span&gt;this&lt;/span&gt;.verbosity == Verbosity.QUIET) {&lt;br/&gt;                listener.setFilters(&lt;span&gt;this&lt;/span&gt;.verboseClasses);&lt;br/&gt;            }&lt;br/&gt;            configured = &lt;span&gt;true&lt;/span&gt;;&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; configured;&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;registerNewStatusConsoleListener&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;   &lt;span&gt;// 创建 StatusConsoleListener，级别以 StatusConfiguration 为准&lt;/span&gt;&lt;br/&gt;   &lt;span&gt;// 默认 status 是 DEFAULT_STATUS 即 ERROR&lt;/span&gt;&lt;br/&gt;   &lt;span&gt;// 默认 destination 是 DEFAULT_STREAM 即 System.out&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;final&lt;/span&gt; StatusConsoleListener listener = &lt;span&gt;new&lt;/span&gt; StatusConsoleListener(&lt;span&gt;this&lt;/span&gt;.status, &lt;span&gt;this&lt;/span&gt;.destination);&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (&lt;span&gt;this&lt;/span&gt;.verbosity == Verbosity.QUIET) {&lt;br/&gt;        listener.setFilters(&lt;span&gt;this&lt;/span&gt;.verboseClasses);&lt;br/&gt;    }&lt;br/&gt;    &lt;span&gt;this&lt;/span&gt;.logger.registerListener(listener);&lt;br/&gt;}&lt;/span&gt;&lt;/section&gt;&lt;/pre&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;section&gt;&lt;span&gt;&lt;span&gt;// org.apache.logging.log4j.status.StatusConsoleListener&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;private&lt;/span&gt; Level level = Level.FATAL; &lt;span&gt;// 级别&lt;/span&gt;&lt;br/&gt;&lt;span&gt;private&lt;/span&gt; String[] filters;&lt;br/&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; PrintStream stream; &lt;span&gt;// 输出流&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;StatusConsoleListener&lt;/span&gt;&lt;span&gt;(&lt;span&gt;final&lt;/span&gt; Level level, &lt;span&gt;final&lt;/span&gt; PrintStream stream)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (stream == &lt;span&gt;null&lt;/span&gt;) {&lt;br/&gt;        &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; IllegalArgumentException(&lt;span&gt;&quot;You must provide a stream to use for this listener.&quot;&lt;/span&gt;);&lt;br/&gt;    }&lt;br/&gt;    &lt;span&gt;this&lt;/span&gt;.level = level;&lt;br/&gt;    &lt;span&gt;this&lt;/span&gt;.stream = stream;&lt;br/&gt;}&lt;/span&gt;&lt;/section&gt;&lt;/pre&gt;&lt;section&gt;&lt;span&gt;以XmlConfiguration为例，分析上述日志配置解析代码片段可以得知，创建XmlConfiguration时，会先创建StatusConfiguration，随后在初始化StatusConfiguration时创建并注册StatusConsoleListener到StatusLogger的listeners中，日志配置文件中&amp;lt;Configuration&amp;gt;标签的属性值通过XmlConfiguration-&amp;gt;StatusConfiguration-&amp;gt;StatusConsoleListener这样的关系链路最终影响StatusConsoleListener的行为。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;日志配置文件中的&amp;lt;Configuration&amp;gt;标签可以配置属性字段，部分字段如下所示：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;在本项目的日志配置文件中可以看到并没有设置Configuration的dest属性值，所以日志直接输出到System.out。&lt;/span&gt;&lt;/section&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;3.1.5 StatusLogger有什么用？&lt;/span&gt;&lt;/h4&gt;&lt;section&gt;&lt;span&gt;上文提到StatusConsoleListener是注册在StatusLogger中，StatusLogger在交由StatusListener处理日志前，会判断日志级别，如果级别条件不满足，则忽略此日志，StatusConsoleListener的日志级别默认是ERROR。&lt;/span&gt;&lt;/section&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;section&gt;&lt;span&gt;&lt;span&gt;// org.apache.logging.log4j.status.StatusLogger&lt;/span&gt;&lt;br/&gt;  &lt;br/&gt;&lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;logMessage&lt;/span&gt;&lt;span&gt;(&lt;span&gt;final&lt;/span&gt; String fqcn, &lt;span&gt;final&lt;/span&gt; Level level, &lt;span&gt;final&lt;/span&gt; Marker marker, &lt;span&gt;final&lt;/span&gt; Message msg,&lt;br/&gt;        &lt;span&gt;final&lt;/span&gt; Throwable t)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    StackTraceElement element = &lt;span&gt;null&lt;/span&gt;;&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (fqcn != &lt;span&gt;null&lt;/span&gt;) {&lt;br/&gt;        element = getStackTraceElement(fqcn, Thread.currentThread().getStackTrace());&lt;br/&gt;    }&lt;br/&gt;    &lt;span&gt;final&lt;/span&gt; StatusData data = &lt;span&gt;new&lt;/span&gt; StatusData(element, level, msg, t, &lt;span&gt;null&lt;/span&gt;);&lt;br/&gt;    msgLock.lock();&lt;br/&gt;    &lt;span&gt;try&lt;/span&gt; {&lt;br/&gt;        messages.add(data);&lt;br/&gt;    } &lt;span&gt;finally&lt;/span&gt; {&lt;br/&gt;        msgLock.unlock();&lt;br/&gt;    }&lt;br/&gt;  &lt;br/&gt;   &lt;span&gt;// 系统注册了 listener，由 StatusConsoleListener 处理日志&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (listeners.size() &amp;gt; &lt;span&gt;0&lt;/span&gt;) {&lt;br/&gt;        &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;final&lt;/span&gt; StatusListener listener : listeners) {&lt;br/&gt;           &lt;span&gt;// 比较当前日志的 leve 和 listener 的 level&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;if&lt;/span&gt; (data.getLevel().isMoreSpecificThan(listener.getStatusLevel())) {&lt;br/&gt;                listener.log(data);&lt;br/&gt;            }&lt;br/&gt;        }&lt;br/&gt;    } &lt;span&gt;else&lt;/span&gt; {&lt;br/&gt;        logger.logMessage(fqcn, level, marker, msg, t);&lt;br/&gt;    }&lt;br/&gt;}&lt;/span&gt;&lt;/section&gt;&lt;/pre&gt;&lt;section&gt;&lt;span&gt;我们回头再来看下StatusLogger，StatusLogger采用单例模式实现，它输出日志到Console（&lt;/span&gt;&lt;span&gt;如System.out或System.err&lt;/span&gt;&lt;span&gt;），从上文分析可知，在高并发场景下非常容易导致线程Block，那么它的存在有什么意义呢？&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;看官方介绍大意是说，在日志初始化完成前，也有打印日志调试的需求，StatusLogger就是为了解决这个问题而生。&lt;/span&gt;&lt;/section&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;Troubleshooting tip for the impatient:&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;From log4j-2.9 onward, log4j2 will print all internal logging to the console if system property log4j2.debug is defined (&lt;/span&gt;&lt;span&gt;with any or no value&lt;/span&gt;&lt;span&gt;).&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;Prior to log4j-2.9, there are two places where internal logging can be controlled:&lt;/span&gt;&lt;/section&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;Before a configuration is found, status logger level can be controlled with system property org.apache.logging.log4j.simplelog.StatusLogger.level.&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;After a configuration is found, status logger level can be controlled in the configuration file with the &quot;status&quot; attribute, for example: &amp;lt;Configuration status=&quot;trace&quot;&amp;gt;.&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;section&gt;&lt;span&gt;Just as it is desirable to be able to diagnose problems in applications, it is frequently necessary to be able to diagnose problems in the logging configuration or in the configured components. Since logging has not been configured, &quot;normal&quot; logging cannot be used during initialization. In addition, normal logging within appenders could create infinite recursion which Log4j will detect and cause the recursive events to be ignored. To accomodate this need, the Log4j 2 API includes a &lt;/span&gt;&lt;a href=&quot;https://logging.apache.org/log4j/2.x/log4j-api/apidocs/org/apache/logging/log4j/status/StatusLogger.html&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;StatusLogger&lt;/span&gt;&lt;/a&gt;&lt;span&gt;.&lt;/span&gt;&lt;/section&gt;&lt;/blockquote&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;3.1.6 问题小结&lt;/span&gt;&lt;/h4&gt;&lt;section&gt;&lt;span&gt;日志量过大导致AsyncAppender日志队列被打满，新的日志事件无法入队，进而由ErrorHandler处理日志，同时由于ErrorHandler存在线程安全问题，导致大量日志输出到了Console，而Console在输出日志到PrintStream输出流时，存在synchronized同步代码块，所以在高并发场景下导致线程Block。&lt;/span&gt;&lt;/section&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;3.2 AsyncAppender导致线程Block&lt;/span&gt;&lt;/h3&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;3.2.1 问题现场&lt;/span&gt;&lt;/h4&gt;&lt;section&gt;&lt;span&gt;收到“jvm.thread.blocked.count”告警后立刻通过监控平台查看线程监控指标，当时的线程堆栈如下图6和图7所示。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;562&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;284&quot; data-ratio=&quot;0.5046875&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsXQu61RnticpkHboWVKAGbMJNyODMs6BSzv9eEdEpeibQFAa9ONd6MOy15dAUQDG0464TjicicMBSiaicIw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1920&quot;/&gt;&lt;figcaption&gt;&lt;span&gt;图6 等待锁的Blocked线程堆栈&lt;/span&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;562&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;275&quot; data-ratio=&quot;0.4890625&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsXQu61RnticpkHboWVKAGbMJM1iaBUETc10QG5eaic9fBaDaZzI8UHL7uRUYN5vrW2khibJ9pGzEs9a6g/640?wx_fmt=png&quot; data-w=&quot;1920&quot;/&gt;&lt;figcaption&gt;&lt;span&gt;图7 持有锁的Runnable线程堆栈&lt;/span&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;从Blocked线程堆栈不难看出是跟日志打印相关，由于是ERROR级别日志，查看具体报错日志，发现有两种业务异常，分别如下图8和图9所示：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;562&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;296&quot; data-ratio=&quot;0.5265625&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsXQu61RnticpkHboWVKAGbMJ4OSQrNjPZwf2Fg1TFWrmH3a0Y7Ux07ibucEPbvRyHyPbz2GXMomqdJw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1920&quot;/&gt;&lt;figcaption&gt;&lt;span&gt;图8 业务异常堆栈一&lt;/span&gt;&lt;span/&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;562&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;177&quot; data-ratio=&quot;0.3151041666666667&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsXQu61RnticpkHboWVKAGbMJS5YgdnjMrbKltZmczQnng4MSzmm7wjbMcamEJytnpUrtLEwOLicqnjw/640?wx_fmt=png&quot; data-w=&quot;1920&quot;/&gt;&lt;figcaption&gt;&lt;span&gt;图9 业务异常堆栈二&lt;/span&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;这些业务异常会是导致线程Block的幕后元凶吗？接下来本章节将结合如下图10所示的调用链路深入分析线程Block的根因。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;562&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;281&quot; data-ratio=&quot;0.5004803073967339&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsXQu61RnticpkHboWVKAGbMJPQQUHFMFSZ5Vk1ia9uCMlWOnfsD18n3T6v9QuKfUPz65eqspNS00mNA/640?wx_fmt=png&quot; data-w=&quot;2082&quot;/&gt;&lt;figcaption&gt;&lt;span&gt;图10 日志调用链路&lt;/span&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;/section&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;3.2.2 为什么会Block线程？&lt;/span&gt;&lt;/h4&gt;&lt;section&gt;&lt;span&gt;从Blocked线程堆栈中可以看出，线程阻塞在类加载流程上，查看WebAppClassLoader相关代码片段如下图11所示，发现加载类时确实会根据类名来加synchronized同步块，因此初步猜测是类加载导致线程Block。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;562&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;289&quot; data-ratio=&quot;0.5142231947483589&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsXQu61RnticpkHboWVKAGbMJcQXkeWElickoPBpWHfw7CaczRelbsD6LiaBDLaJ5jAgBplqEZvMQI5oQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1828&quot;/&gt;&lt;figcaption&gt;&lt;span&gt;图11 WebAppClassLoader&lt;/span&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;但上述猜测还有一些值得推敲的地方：&lt;/span&gt;&lt;/section&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;项目代码里只是普通地输出一条ERROR日志而已，为何会触发类加载？&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;通常情况下类加载几乎不会触发线程Block，不然一个项目要加载成千上万个类，如果因为加载类就导致Block，那项目就没法正常运行了。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;3.2.3 为什么会触发类加载？&lt;/span&gt;&lt;/h4&gt;&lt;section&gt;&lt;span&gt;继续从Blocked线程堆栈着手分析，查看堆栈中的ThrowableProxy相关代码，发现其构造函数会遍历整个异常堆栈中的所有堆栈元素，最终获取所有堆栈元素类所在的JAR名称和版本信息。具体流程如下：&lt;/span&gt;&lt;/section&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;首先获取堆栈元素的类名称。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;再通过loadClass的方式获取对应的Class对象。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;进一步获取该类所在的JAR信息，从CodeSource中获取JAR名称，从Package中获取JAR版本。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;section&gt;&lt;span&gt;&lt;span&gt;// org.apache.logging.log4j.core.impl.ThrowableProxy&lt;/span&gt;&lt;br/&gt;  &lt;br/&gt;&lt;span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;ThrowableProxy&lt;/span&gt;&lt;span&gt;(&lt;span&gt;final&lt;/span&gt; Throwable throwable, &lt;span&gt;final&lt;/span&gt; Set&amp;lt;Throwable&amp;gt; visited)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;this&lt;/span&gt;.throwable = throwable;&lt;br/&gt;    &lt;span&gt;this&lt;/span&gt;.name = throwable.getClass().getName();&lt;br/&gt;    &lt;span&gt;this&lt;/span&gt;.message = throwable.getMessage();&lt;br/&gt;    &lt;span&gt;this&lt;/span&gt;.localizedMessage = throwable.getLocalizedMessage();&lt;br/&gt;    &lt;span&gt;final&lt;/span&gt; Map&amp;lt;String, CacheEntry&amp;gt; map = &lt;span&gt;new&lt;/span&gt; HashMap&amp;lt;&amp;gt;();&lt;br/&gt;    &lt;span&gt;final&lt;/span&gt; Stack&amp;lt;Class&amp;lt;?&amp;gt;&amp;gt; stack = ReflectionUtil.getCurrentStackTrace();&lt;br/&gt;   &lt;span&gt;// 获取堆栈扩展信息&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;this&lt;/span&gt;.extendedStackTrace = &lt;span&gt;this&lt;/span&gt;.toExtendedStackTrace(stack, map, &lt;span&gt;null&lt;/span&gt;, throwable.getStackTrace());&lt;br/&gt;    &lt;span&gt;final&lt;/span&gt; Throwable throwableCause = throwable.getCause();&lt;br/&gt;    &lt;span&gt;final&lt;/span&gt; Set&amp;lt;Throwable&amp;gt; causeVisited = &lt;span&gt;new&lt;/span&gt; HashSet&amp;lt;&amp;gt;(&lt;span&gt;1&lt;/span&gt;);&lt;br/&gt;    &lt;span&gt;this&lt;/span&gt;.causeProxy = throwableCause == &lt;span&gt;null&lt;/span&gt; ? &lt;span&gt;null&lt;/span&gt; : &lt;span&gt;new&lt;/span&gt; ThrowableProxy(throwable, stack, map, throwableCause,&lt;br/&gt;        visited, causeVisited);&lt;br/&gt;    &lt;span&gt;this&lt;/span&gt;.suppressedProxies = &lt;span&gt;this&lt;/span&gt;.toSuppressedProxies(throwable, visited);&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;ExtendedStackTraceElement[] toExtendedStackTrace(&lt;span&gt;final&lt;/span&gt; Stack&amp;lt;Class&amp;lt;?&amp;gt;&amp;gt; stack, &lt;span&gt;final&lt;/span&gt; Map&amp;lt;String, CacheEntry&amp;gt; map,&lt;br/&gt;                                                 &lt;span&gt;final&lt;/span&gt; StackTraceElement[] rootTrace,&lt;br/&gt;                                                 &lt;span&gt;final&lt;/span&gt; StackTraceElement[] stackTrace) {&lt;br/&gt;    &lt;span&gt;int&lt;/span&gt; stackLength;&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (rootTrace != &lt;span&gt;null&lt;/span&gt;) {&lt;br/&gt;        &lt;span&gt;int&lt;/span&gt; rootIndex = rootTrace.length - &lt;span&gt;1&lt;/span&gt;;&lt;br/&gt;        &lt;span&gt;int&lt;/span&gt; stackIndex = stackTrace.length - &lt;span&gt;1&lt;/span&gt;;&lt;br/&gt;        &lt;span&gt;while&lt;/span&gt; (rootIndex &amp;gt;= &lt;span&gt;0&lt;/span&gt; &amp;amp;&amp;amp; stackIndex &amp;gt;= &lt;span&gt;0&lt;/span&gt; &amp;amp;&amp;amp; rootTrace[rootIndex].equals(stackTrace[stackIndex])) {&lt;br/&gt;            --rootIndex;&lt;br/&gt;            --stackIndex;&lt;br/&gt;        }&lt;br/&gt;        &lt;span&gt;this&lt;/span&gt;.commonElementCount = stackTrace.length - &lt;span&gt;1&lt;/span&gt; - stackIndex;&lt;br/&gt;        stackLength = stackIndex + &lt;span&gt;1&lt;/span&gt;;&lt;br/&gt;    } &lt;span&gt;else&lt;/span&gt; {&lt;br/&gt;        &lt;span&gt;this&lt;/span&gt;.commonElementCount = &lt;span&gt;0&lt;/span&gt;;&lt;br/&gt;        stackLength = stackTrace.length;&lt;br/&gt;    }&lt;br/&gt;    &lt;span&gt;final&lt;/span&gt; ExtendedStackTraceElement[] extStackTrace = &lt;span&gt;new&lt;/span&gt; ExtendedStackTraceElement[stackLength];&lt;br/&gt;    Class&amp;lt;?&amp;gt; clazz = stack.isEmpty() ? &lt;span&gt;null&lt;/span&gt; : stack.peek();&lt;br/&gt;    ClassLoader lastLoader = &lt;span&gt;null&lt;/span&gt;;&lt;br/&gt;    &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = stackLength - &lt;span&gt;1&lt;/span&gt;; i &amp;gt;= &lt;span&gt;0&lt;/span&gt;; --i) {&lt;br/&gt;       &lt;span&gt;// 遍历 StackTraceElement&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;final&lt;/span&gt; StackTraceElement stackTraceElement = stackTrace[i];&lt;br/&gt;       &lt;span&gt;// 获取堆栈元素对应的类名称&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;final&lt;/span&gt; String className = stackTraceElement.getClassName();&lt;br/&gt;        &lt;span&gt;// The stack returned from getCurrentStack may be missing entries for java.lang.reflect.Method.invoke()&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;// and its implementation. The Throwable might also contain stack entries that are no longer&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;// present as those methods have returned.&lt;/span&gt;&lt;br/&gt;        ExtendedClassInfo extClassInfo;&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (clazz != &lt;span&gt;null&lt;/span&gt; &amp;amp;&amp;amp; className.equals(clazz.getName())) {&lt;br/&gt;            &lt;span&gt;final&lt;/span&gt; CacheEntry entry = &lt;span&gt;this&lt;/span&gt;.toCacheEntry(stackTraceElement, clazz, &lt;span&gt;true&lt;/span&gt;);&lt;br/&gt;            extClassInfo = entry.element;&lt;br/&gt;            lastLoader = entry.loader;&lt;br/&gt;            stack.pop();&lt;br/&gt;            clazz = stack.isEmpty() ? &lt;span&gt;null&lt;/span&gt; : stack.peek();&lt;br/&gt;        } &lt;span&gt;else&lt;/span&gt; {&lt;br/&gt;           &lt;span&gt;// 对加载过的 className 进行缓存，避免重复加载&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;final&lt;/span&gt; CacheEntry cacheEntry = map.get(className);&lt;br/&gt;            &lt;span&gt;if&lt;/span&gt; (cacheEntry != &lt;span&gt;null&lt;/span&gt;) {&lt;br/&gt;                &lt;span&gt;final&lt;/span&gt; CacheEntry entry = cacheEntry;&lt;br/&gt;                extClassInfo = entry.element;&lt;br/&gt;                &lt;span&gt;if&lt;/span&gt; (entry.loader != &lt;span&gt;null&lt;/span&gt;) {&lt;br/&gt;                    lastLoader = entry.loader;&lt;br/&gt;                }&lt;br/&gt;            } &lt;span&gt;else&lt;/span&gt; {&lt;br/&gt;               &lt;span&gt;// 通过加载类来获取类的扩展信息，如 location 和 version 等&lt;/span&gt;&lt;br/&gt;                &lt;span&gt;final&lt;/span&gt; CacheEntry entry = &lt;span&gt;this&lt;/span&gt;.toCacheEntry(stackTraceElement,&lt;br/&gt;                    &lt;span&gt;// 获取 Class 对象&lt;/span&gt;&lt;br/&gt;                    &lt;span&gt;this&lt;/span&gt;.loadClass(lastLoader, className), &lt;span&gt;false&lt;/span&gt;);&lt;br/&gt;                extClassInfo = entry.element;&lt;br/&gt;                map.put(stackTraceElement.toString(), entry);&lt;br/&gt;                &lt;span&gt;if&lt;/span&gt; (entry.loader != &lt;span&gt;null&lt;/span&gt;) {&lt;br/&gt;                    lastLoader = entry.loader;&lt;br/&gt;                }&lt;br/&gt;            }&lt;br/&gt;        }&lt;br/&gt;        extStackTrace[i] = &lt;span&gt;new&lt;/span&gt; ExtendedStackTraceElement(stackTraceElement, extClassInfo);&lt;br/&gt;    }&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; extStackTrace;&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;/**&lt;br/&gt; * Construct the CacheEntry from the Class&#x27;s information.&lt;br/&gt; *&lt;br/&gt; * &lt;span&gt;@param&lt;/span&gt; stackTraceElement The stack trace element&lt;br/&gt; * &lt;span&gt;@param&lt;/span&gt; callerClass       The Class.&lt;br/&gt; * &lt;span&gt;@param&lt;/span&gt; exact             True if the class was obtained via Reflection.getCallerClass.&lt;br/&gt; * &lt;span&gt;@return&lt;/span&gt; The CacheEntry.&lt;br/&gt; */&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;private&lt;/span&gt; CacheEntry &lt;span&gt;toCacheEntry&lt;/span&gt;&lt;span&gt;(&lt;span&gt;final&lt;/span&gt; StackTraceElement stackTraceElement, &lt;span&gt;final&lt;/span&gt; Class&amp;lt;?&amp;gt; callerClass,&lt;br/&gt;                                &lt;span&gt;final&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; exact)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    String location = &lt;span&gt;&quot;?&quot;&lt;/span&gt;;&lt;br/&gt;    String version = &lt;span&gt;&quot;?&quot;&lt;/span&gt;;&lt;br/&gt;    ClassLoader lastLoader = &lt;span&gt;null&lt;/span&gt;;&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (callerClass != &lt;span&gt;null&lt;/span&gt;) {&lt;br/&gt;        &lt;span&gt;try&lt;/span&gt; {&lt;br/&gt;            &lt;span&gt;// 获取 jar 文件信息&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;final&lt;/span&gt; CodeSource source = callerClass.getProtectionDomain().getCodeSource();&lt;br/&gt;            &lt;span&gt;if&lt;/span&gt; (source != &lt;span&gt;null&lt;/span&gt;) {&lt;br/&gt;                &lt;span&gt;final&lt;/span&gt; URL locationURL = source.getLocation();&lt;br/&gt;                &lt;span&gt;if&lt;/span&gt; (locationURL != &lt;span&gt;null&lt;/span&gt;) {&lt;br/&gt;                    &lt;span&gt;final&lt;/span&gt; String str = locationURL.toString().replace(&lt;span&gt;&#x27;\\&#x27;&lt;/span&gt;, &lt;span&gt;&#x27;/&#x27;&lt;/span&gt;);&lt;br/&gt;                    &lt;span&gt;int&lt;/span&gt; index = str.lastIndexOf(&lt;span&gt;&quot;/&quot;&lt;/span&gt;);&lt;br/&gt;                    &lt;span&gt;if&lt;/span&gt; (index &amp;gt;= &lt;span&gt;0&lt;/span&gt; &amp;amp;&amp;amp; index == str.length() - &lt;span&gt;1&lt;/span&gt;) {&lt;br/&gt;                        index = str.lastIndexOf(&lt;span&gt;&quot;/&quot;&lt;/span&gt;, index - &lt;span&gt;1&lt;/span&gt;);&lt;br/&gt;                        location = str.substring(index + &lt;span&gt;1&lt;/span&gt;);&lt;br/&gt;                    } &lt;span&gt;else&lt;/span&gt; {&lt;br/&gt;                        location = str.substring(index + &lt;span&gt;1&lt;/span&gt;);&lt;br/&gt;                    }&lt;br/&gt;                }&lt;br/&gt;            }&lt;br/&gt;        } &lt;span&gt;catch&lt;/span&gt; (&lt;span&gt;final&lt;/span&gt; Exception ex) {&lt;br/&gt;            &lt;span&gt;// Ignore the exception.&lt;/span&gt;&lt;br/&gt;        }&lt;br/&gt;      &lt;span&gt;// 获取类所在 jar 版本信息&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;final&lt;/span&gt; Package pkg = callerClass.getPackage();&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (pkg != &lt;span&gt;null&lt;/span&gt;) {&lt;br/&gt;            &lt;span&gt;final&lt;/span&gt; String ver = pkg.getImplementationVersion();&lt;br/&gt;            &lt;span&gt;if&lt;/span&gt; (ver != &lt;span&gt;null&lt;/span&gt;) {&lt;br/&gt;                version = ver;&lt;br/&gt;            }&lt;br/&gt;        }&lt;br/&gt;        lastLoader = callerClass.getClassLoader();&lt;br/&gt;    }&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; CacheEntry(&lt;span&gt;new&lt;/span&gt; ExtendedClassInfo(exact, location, version), lastLoader);&lt;br/&gt;}&lt;/span&gt;&lt;/section&gt;&lt;/pre&gt;&lt;section&gt;&lt;span&gt;从上述代码中可以看到，ThrowableProxy#toExtendedStackTrace方法通过Map&amp;lt;String, CacheEntry&amp;gt;缓存当前堆栈元素类对应的CacheEntry，来避免重复解析CacheEntry，但是由于Map缓存put操作使用的key来自于StackTraceElement.toString方法，而get操作使用的key却来自于StackTraceElement.getClassName方法，即使对于同一个StackTraceElement而言，其toString和getClassName方法对应的返回结果也不一样，所以此map形同虚设。&lt;/span&gt;&lt;/section&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;section&gt;&lt;span&gt;&lt;span&gt;// java.lang.StackTraceElement&lt;/span&gt;&lt;br/&gt;  &lt;br/&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; String &lt;span&gt;getClassName&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; declaringClass;&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; String &lt;span&gt;toString&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; getClassName() + &lt;span&gt;&quot;.&quot;&lt;/span&gt; + methodName +&lt;br/&gt;        (isNativeMethod() ? &lt;span&gt;&quot;(Native Method)&quot;&lt;/span&gt; :&lt;br/&gt;         (fileName != &lt;span&gt;null&lt;/span&gt; &amp;amp;&amp;amp; lineNumber &amp;gt;= &lt;span&gt;0&lt;/span&gt; ?&lt;br/&gt;          &lt;span&gt;&quot;(&quot;&lt;/span&gt; + fileName + &lt;span&gt;&quot;:&quot;&lt;/span&gt; + lineNumber + &lt;span&gt;&quot;)&quot;&lt;/span&gt; :&lt;br/&gt;          (fileName != &lt;span&gt;null&lt;/span&gt; ?  &lt;span&gt;&quot;(&quot;&lt;/span&gt;+fileName+&lt;span&gt;&quot;)&quot;&lt;/span&gt; : &lt;span&gt;&quot;(Unknown Source)&quot;&lt;/span&gt;)));&lt;br/&gt;}&lt;/span&gt;&lt;/section&gt;&lt;/pre&gt;&lt;section&gt;&lt;span&gt;该问题已有相关&lt;/span&gt;&lt;a href=&quot;https://issues.apache.org/jira/browse/LOG4J2-2389&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;Issue: fix the CacheEntry map in ThrowableProxy#toExtendedStackTrace to be put and gotten with same key&lt;/span&gt;&lt;/a&gt;&lt;span&gt;反馈给社区，并在&lt;/span&gt;&lt;a href=&quot;https://logging.apache.org/log4j/2.x/changes-report.html#a2.11.1&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;2.11.1&lt;/span&gt;&lt;/a&gt;&lt;span&gt;版本中修复了该问题。虽然通过让get/put方法使用同一个key来修复缓存的有效性问题，但由于ThrowableProxy对每个Throwable都会创建一个全新的Map，而不是使用全局Map，因此其缓存也仅仅对单个Throwable生效，作用范围非常有限，食之无味，弃之可惜。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;言归正传，通常情况下一个类加载器对于一个类只会加载一次，类加载器内部保存有类缓存，无需重复加载，但目前的现象却是由于类加载而导致线程大量Block，因此必然是有些类加载不了，且不断重复尝试加载，那到底是什么类无法加载呢？&lt;/span&gt;&lt;/section&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;3.2.4 到底什么类加载不了？&lt;/span&gt;&lt;/h4&gt;&lt;section&gt;&lt;span&gt;要找到具体是什么类无法加载，归根结底还是要分析业务异常的具体堆栈。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;545&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;287&quot; data-ratio=&quot;0.5265625&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsXQu61RnticpkHboWVKAGbMJ4OSQrNjPZwf2Fg1TFWrmH3a0Y7Ux07ibucEPbvRyHyPbz2GXMomqdJw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1920&quot;/&gt;&lt;figcaption&gt;&lt;span&gt;图12 业务异常堆栈一&lt;/span&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-cropselx1=&quot;1&quot; data-cropselx2=&quot;546&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;172&quot; data-ratio=&quot;0.3151041666666667&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsXQu61RnticpkHboWVKAGbMJS5YgdnjMrbKltZmczQnng4MSzmm7wjbMcamEJytnpUrtLEwOLicqnjw/640?wx_fmt=png&quot; data-w=&quot;1920&quot;/&gt;&lt;figcaption&gt;&lt;span&gt;图13 业务异常堆栈二&lt;/span&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;对比如图12和图13所示的两份业务异常堆栈，我们可以看到两份堆栈基本相似，且大多数类都是很普通的类，但是唯一不同的地方在于：&lt;/span&gt;&lt;/section&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;sun.reflect.NativeMethodAccessorImpl（&lt;/span&gt;&lt;span&gt;参见图12&lt;/span&gt;&lt;span&gt;）。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;sun.reflect.GeneratedMethodAccessor261（&lt;/span&gt;&lt;span&gt;参见图13&lt;/span&gt;&lt;span&gt;）。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;section&gt;&lt;span&gt;从字面信息中不难猜测出这与反射调用相关，但问题是这两份堆栈对应的其实是同一份业务代码，为什么会产生两份不同的异常堆栈？&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;查阅相关资料得知，这与JVM反射调用相关，JVM对反射调用分两种情况：&lt;/span&gt;&lt;/section&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;默认使用native方法进行反射操作。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;一定条件下会生成字节码进行反射操作，即生成sun.reflect.GeneratedMethodAccessor&amp;lt;N&amp;gt;类，它是一个反射调用方法的包装类，代理不同的方法，类后缀序号递增。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;section&gt;&lt;span&gt;JVM反射调用的主要流程是获取MethodAccessor，并由MethodAccessor执行invoke调用，相关代码如下：&lt;/span&gt;&lt;/section&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;section&gt;&lt;span&gt;&lt;span&gt;// java.lang.reflect.Method  &lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;@CallerSensitive&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; Object &lt;span&gt;invoke&lt;/span&gt;&lt;span&gt;(Object obj, Object... args)&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;throws&lt;/span&gt; IllegalAccessException, IllegalArgumentException,&lt;br/&gt;       InvocationTargetException&lt;br/&gt;&lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (!override) {&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (!Reflection.quickCheckMemberAccess(clazz, modifiers)) {&lt;br/&gt;            Class&amp;lt;?&amp;gt; caller = Reflection.getCallerClass();&lt;br/&gt;            checkAccess(caller, clazz, obj, modifiers);&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    MethodAccessor ma = methodAccessor;             &lt;span&gt;// read volatile&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (ma == &lt;span&gt;null&lt;/span&gt;) {&lt;br/&gt;      &lt;span&gt;// 获取 MethodAccessor&lt;/span&gt;&lt;br/&gt;        ma = acquireMethodAccessor();&lt;br/&gt;    }&lt;br/&gt;    &lt;span&gt;// 通过 MethodAccessor 调用&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; ma.invoke(obj, args);&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;private&lt;/span&gt; MethodAccessor &lt;span&gt;acquireMethodAccessor&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    MethodAccessor tmp = &lt;span&gt;null&lt;/span&gt;;&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (root != &lt;span&gt;null&lt;/span&gt;) tmp = root.getMethodAccessor();&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (tmp != &lt;span&gt;null&lt;/span&gt;) {&lt;br/&gt;        methodAccessor = tmp;&lt;br/&gt;    } &lt;span&gt;else&lt;/span&gt; {&lt;br/&gt;        &lt;span&gt;// 通过 ReflectionFactory 创建 MethodAccessor&lt;/span&gt;&lt;br/&gt;        tmp = reflectionFactory.newMethodAccessor(&lt;span&gt;this&lt;/span&gt;);&lt;br/&gt;        setMethodAccessor(tmp);&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; tmp;&lt;br/&gt;}&lt;/span&gt;&lt;/section&gt;&lt;/pre&gt;&lt;section&gt;&lt;span&gt;当noInflation为false（&lt;/span&gt;&lt;span&gt;默认为false&lt;/span&gt;&lt;span&gt;）或者反射方法所在类是VM匿名类（&lt;/span&gt;&lt;span&gt;类名中包括斜杠“/”&lt;/span&gt;&lt;span&gt;）的情况下，ReflectionFactory会返回一个MethodAccessor代理类，即DelegatingMethodAccessorImpl。&lt;/span&gt;&lt;/section&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;section&gt;&lt;span&gt;&lt;span&gt;// sun.reflect.ReflectionFactory&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; MethodAccessor &lt;span&gt;newMethodAccessor&lt;/span&gt;&lt;span&gt;(Method method)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;   &lt;span&gt;// 通过启动参数获取并解析 noInflation 和 inflationThreshold 值&lt;/span&gt;&lt;br/&gt;   &lt;span&gt;// noInflation 默认为 false&lt;/span&gt;&lt;br/&gt;   &lt;span&gt;// inflationThreshold 默认为15&lt;/span&gt;&lt;br/&gt;    checkInitted();&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (noInflation &amp;amp;&amp;amp; !ReflectUtil.isVMAnonymousClass(method.getDeclaringClass())) {&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; MethodAccessorGenerator().&lt;br/&gt;            generateMethod(method.getDeclaringClass(),&lt;br/&gt;                           method.getName(),&lt;br/&gt;                           method.getParameterTypes(),&lt;br/&gt;                           method.getReturnType(),&lt;br/&gt;                           method.getExceptionTypes(),&lt;br/&gt;                           method.getModifiers());&lt;br/&gt;    } &lt;span&gt;else&lt;/span&gt; {&lt;br/&gt;        NativeMethodAccessorImpl acc =&lt;br/&gt;            &lt;span&gt;new&lt;/span&gt; NativeMethodAccessorImpl(method);&lt;br/&gt;        DelegatingMethodAccessorImpl res =&lt;br/&gt;            &lt;span&gt;new&lt;/span&gt; DelegatingMethodAccessorImpl(acc);&lt;br/&gt;        acc.setParent(res);&lt;br/&gt;      &lt;br/&gt;       &lt;span&gt;// 返回代理 DelegatingMethodAccessorImpl&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; res;&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;checkInitted&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (initted) &lt;span&gt;return&lt;/span&gt;;&lt;br/&gt;    AccessController.doPrivileged(&lt;br/&gt;        &lt;span&gt;new&lt;/span&gt; PrivilegedAction&amp;lt;Void&amp;gt;() {&lt;br/&gt;            &lt;span&gt;&lt;span&gt;public&lt;/span&gt; Void &lt;span&gt;run&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;                &lt;span&gt;// Tests to ensure the system properties table is fully&lt;/span&gt;&lt;br/&gt;                &lt;span&gt;// initialized. This is needed because reflection code is&lt;/span&gt;&lt;br/&gt;                &lt;span&gt;// called very early in the initialization process (before&lt;/span&gt;&lt;br/&gt;                &lt;span&gt;// command-line arguments have been parsed and therefore&lt;/span&gt;&lt;br/&gt;                &lt;span&gt;// these user-settable properties installed.) We assume that&lt;/span&gt;&lt;br/&gt;                &lt;span&gt;// if System.out is non-null then the System class has been&lt;/span&gt;&lt;br/&gt;                &lt;span&gt;// fully initialized and that the bulk of the startup code&lt;/span&gt;&lt;br/&gt;                &lt;span&gt;// has been run.&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;                &lt;span&gt;if&lt;/span&gt; (System.out == &lt;span&gt;null&lt;/span&gt;) {&lt;br/&gt;                    &lt;span&gt;// java.lang.System not yet fully initialized&lt;/span&gt;&lt;br/&gt;                    &lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;;&lt;br/&gt;                }&lt;br/&gt;&lt;br/&gt;                String val = System.getProperty(&lt;span&gt;&quot;sun.reflect.noInflation&quot;&lt;/span&gt;);&lt;br/&gt;                &lt;span&gt;if&lt;/span&gt; (val != &lt;span&gt;null&lt;/span&gt; &amp;amp;&amp;amp; val.equals(&lt;span&gt;&quot;true&quot;&lt;/span&gt;)) {&lt;br/&gt;                    noInflation = &lt;span&gt;true&lt;/span&gt;;&lt;br/&gt;                }&lt;br/&gt;&lt;br/&gt;                val = System.getProperty(&lt;span&gt;&quot;sun.reflect.inflationThreshold&quot;&lt;/span&gt;);&lt;br/&gt;                &lt;span&gt;if&lt;/span&gt; (val != &lt;span&gt;null&lt;/span&gt;) {&lt;br/&gt;                    &lt;span&gt;try&lt;/span&gt; {&lt;br/&gt;                        inflationThreshold = Integer.parseInt(val);&lt;br/&gt;                    } &lt;span&gt;catch&lt;/span&gt; (NumberFormatException e) {&lt;br/&gt;                        &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; RuntimeException(&lt;span&gt;&quot;Unable to parse property sun.reflect.inflationThreshold&quot;&lt;/span&gt;, e);&lt;br/&gt;                    }&lt;br/&gt;                }&lt;br/&gt;&lt;br/&gt;                initted = &lt;span&gt;true&lt;/span&gt;;&lt;br/&gt;                &lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;;&lt;br/&gt;            }&lt;br/&gt;        });&lt;br/&gt;}&lt;/span&gt;&lt;/section&gt;&lt;/pre&gt;&lt;section&gt;&lt;span&gt;默认情况下DelegatingMethodAccessorImpl代理了NativeMethodAccessorImpl，但是随着反射调用次数的增加，当一个方法被反射调用的次数超过一定的阀值时（&lt;/span&gt;&lt;span&gt;inflationThreshold，默认值是15&lt;/span&gt;&lt;span&gt;），NativeMethodAccessorImpl会通过字节码生成技术，自动生成MethodAccessorImpl实现类，并修改DelegatingMethodAccessorImpl的内部代理对象指向字节码生成类实例，从而改变后续反射调用逻辑。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;562&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;583&quot; data-ratio=&quot;1.0379981464318813&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsXQu61RnticpkHboWVKAGbMJicllsLdibFLTDnn9BGkwxUBNTfup2iczicnruN8ORMnQPq21WVMqdohO0g/640?wx_fmt=png&quot; data-w=&quot;1079&quot;/&gt;&lt;figcaption&gt;&lt;span&gt;图14 MethodAccessor关系图&lt;/span&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;/section&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;section&gt;&lt;span&gt;&lt;span&gt;// sun.reflect.DelegatingMethodAccessorImpl&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;DelegatingMethodAccessorImpl&lt;/span&gt; &lt;span&gt;extends&lt;/span&gt; &lt;span&gt;MethodAccessorImpl&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;   &lt;span&gt;// 内部代理 MethodAccessorImpl&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; MethodAccessorImpl delegate;&lt;br/&gt;&lt;br/&gt;    DelegatingMethodAccessorImpl(MethodAccessorImpl delegate) {&lt;br/&gt;        setDelegate(delegate);&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; Object &lt;span&gt;invoke&lt;/span&gt;&lt;span&gt;(Object obj, Object[] args)&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;throws&lt;/span&gt; IllegalArgumentException, InvocationTargetException&lt;br/&gt;    &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; delegate.invoke(obj, args);&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;void&lt;/span&gt; &lt;span&gt;setDelegate&lt;/span&gt;&lt;span&gt;(MethodAccessorImpl delegate)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;this&lt;/span&gt;.delegate = delegate;&lt;br/&gt;    }&lt;br/&gt;}&lt;/span&gt;&lt;/section&gt;&lt;/pre&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;section&gt;&lt;span&gt;&lt;span&gt;// sun.reflect.NativeMethodAccessorImpl&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;NativeMethodAccessorImpl&lt;/span&gt; &lt;span&gt;extends&lt;/span&gt; &lt;span&gt;MethodAccessorImpl&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; Method method;&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; DelegatingMethodAccessorImpl parent;&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; numInvocations;&lt;br/&gt;&lt;br/&gt;    NativeMethodAccessorImpl(Method method) {&lt;br/&gt;        &lt;span&gt;this&lt;/span&gt;.method = method;&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; Object &lt;span&gt;invoke&lt;/span&gt;&lt;span&gt;(Object obj, Object[] args)&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;throws&lt;/span&gt; IllegalArgumentException, InvocationTargetException&lt;br/&gt;    &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;// We can&#x27;t inflate methods belonging to vm-anonymous classes because&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;// that kind of class can&#x27;t be referred to by name, hence can&#x27;t be&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;// found from the generated bytecode.&lt;/span&gt;&lt;br/&gt;      &lt;br/&gt;       &lt;span&gt;// 每次调用时 numInvocations 都会自增加1，如果超过阈值（默认是15次），就会修改父类的代理对象，从而改变调用链路&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (++numInvocations &amp;gt; ReflectionFactory.inflationThreshold()&lt;br/&gt;                &amp;amp;&amp;amp; !ReflectUtil.isVMAnonymousClass(method.getDeclaringClass())) {&lt;br/&gt;            MethodAccessorImpl acc = (MethodAccessorImpl)&lt;br/&gt;               &lt;span&gt;// 动态生成字节码，优化反射调用速度&lt;/span&gt;&lt;br/&gt;                &lt;span&gt;new&lt;/span&gt; MethodAccessorGenerator().&lt;br/&gt;                    generateMethod(method.getDeclaringClass(),&lt;br/&gt;                                   method.getName(),&lt;br/&gt;                                   method.getParameterTypes(),&lt;br/&gt;                                   method.getReturnType(),&lt;br/&gt;                                   method.getExceptionTypes(),&lt;br/&gt;                                   method.getModifiers());&lt;br/&gt;           &lt;span&gt;// 修改父代理类的代理对象&lt;/span&gt;&lt;br/&gt;            parent.setDelegate(acc);&lt;br/&gt;        }&lt;br/&gt;&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; invoke0(method, obj, args);&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;void&lt;/span&gt; &lt;span&gt;setParent&lt;/span&gt;&lt;span&gt;(DelegatingMethodAccessorImpl parent)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;this&lt;/span&gt;.parent = parent;&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;native&lt;/span&gt; Object &lt;span&gt;invoke0&lt;/span&gt;&lt;span&gt;(Method m, Object obj, Object[] args)&lt;/span&gt;&lt;/span&gt;;&lt;br/&gt;}&lt;/span&gt;&lt;/section&gt;&lt;/pre&gt;&lt;section&gt;&lt;span&gt;从MethodAccessorGenerator#generateName方法可以看到，字节码生成的类名称规则是sun.reflect.GeneratedConstructorAccessor&amp;lt;N&amp;gt;，其中N是从0开始的递增数字，且生成类是由DelegatingClassLoader类加载器定义，所以其他类加载器无法加载该类，也就无法生成类缓存数据，从而导致每次加载类时都需要遍历JarFile，极大地降低了类查找速度，且类加载过程是synchronized同步调用，在高并发情况下会更加恶化，从而导致线程Block。&lt;/span&gt;&lt;/section&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;section&gt;&lt;span&gt;&lt;span&gt;// sun.reflect.MethodAccessorGenerator&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; MethodAccessor &lt;span&gt;generateMethod&lt;/span&gt;&lt;span&gt;(Class&amp;lt;?&amp;gt; declaringClass,&lt;br/&gt;                                     String   name,&lt;br/&gt;                                     Class&amp;lt;?&amp;gt;[] parameterTypes,&lt;br/&gt;                                     Class&amp;lt;?&amp;gt;   returnType,&lt;br/&gt;                                     Class&amp;lt;?&amp;gt;[] checkedExceptions,&lt;br/&gt;                                     &lt;span&gt;int&lt;/span&gt; modifiers)&lt;/span&gt;&lt;br/&gt;&lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; (MethodAccessor) generate(declaringClass,&lt;br/&gt;                                     name,&lt;br/&gt;                                     parameterTypes,&lt;br/&gt;                                     returnType,&lt;br/&gt;                                     checkedExceptions,&lt;br/&gt;                                     modifiers,&lt;br/&gt;                                     &lt;span&gt;false&lt;/span&gt;,&lt;br/&gt;                                     &lt;span&gt;false&lt;/span&gt;,&lt;br/&gt;                                     &lt;span&gt;null&lt;/span&gt;);&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;private&lt;/span&gt; MagicAccessorImpl &lt;span&gt;generate&lt;/span&gt;&lt;span&gt;(&lt;span&gt;final&lt;/span&gt; Class&amp;lt;?&amp;gt; declaringClass,&lt;br/&gt;                                   String name,&lt;br/&gt;                                   Class&amp;lt;?&amp;gt;[] parameterTypes,&lt;br/&gt;                                   Class&amp;lt;?&amp;gt;   returnType,&lt;br/&gt;                                   Class&amp;lt;?&amp;gt;[] checkedExceptions,&lt;br/&gt;                                   &lt;span&gt;int&lt;/span&gt; modifiers,&lt;br/&gt;                                   &lt;span&gt;boolean&lt;/span&gt; isConstructor,&lt;br/&gt;                                   &lt;span&gt;boolean&lt;/span&gt; forSerialization,&lt;br/&gt;                                   Class&amp;lt;?&amp;gt; serializationTargetClass)&lt;/span&gt;&lt;br/&gt;&lt;/span&gt;{&lt;br/&gt;  &lt;br/&gt;   &lt;span&gt;final&lt;/span&gt; String generatedName = generateName(isConstructor, forSerialization);&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;// 忽略以上代码&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; AccessController.doPrivileged(&lt;br/&gt;        &lt;span&gt;new&lt;/span&gt; PrivilegedAction&amp;lt;MagicAccessorImpl&amp;gt;() {&lt;br/&gt;            &lt;span&gt;&lt;span&gt;public&lt;/span&gt; MagicAccessorImpl &lt;span&gt;run&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;                    &lt;span&gt;try&lt;/span&gt; {&lt;br/&gt;                    &lt;span&gt;return&lt;/span&gt; (MagicAccessorImpl)&lt;br/&gt;                    ClassDefiner.defineClass&lt;br/&gt;                            (generatedName,&lt;br/&gt;                             bytes,&lt;br/&gt;                             &lt;span&gt;0&lt;/span&gt;,&lt;br/&gt;                             bytes.length,&lt;br/&gt;                             declaringClass.getClassLoader()).newInstance();&lt;br/&gt;                    } &lt;span&gt;catch&lt;/span&gt; (InstantiationException | IllegalAccessException e) {&lt;br/&gt;                        &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; InternalError(e);&lt;br/&gt;                    }&lt;br/&gt;                }&lt;br/&gt;            });&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// 生成反射类名，看到了熟悉的 sun.reflect.GeneratedConstructorAccessor&amp;lt;N&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;synchronized&lt;/span&gt; String &lt;span&gt;generateName&lt;/span&gt;&lt;span&gt;(&lt;span&gt;boolean&lt;/span&gt; isConstructor, &lt;span&gt;boolean&lt;/span&gt; forSerialization)&lt;/span&gt;&lt;br/&gt;&lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (isConstructor) {&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (forSerialization) {&lt;br/&gt;            &lt;span&gt;int&lt;/span&gt; num = ++serializationConstructorSymnum;&lt;br/&gt;            &lt;span&gt;return&lt;/span&gt; &lt;span&gt;&quot;sun/reflect/GeneratedSerializationConstructorAccessor&quot;&lt;/span&gt; + num;&lt;br/&gt;        } &lt;span&gt;else&lt;/span&gt; {&lt;br/&gt;            &lt;span&gt;int&lt;/span&gt; num = ++constructorSymnum;&lt;br/&gt;            &lt;span&gt;return&lt;/span&gt; &lt;span&gt;&quot;sun/reflect/GeneratedConstructorAccessor&quot;&lt;/span&gt; + num;&lt;br/&gt;        }&lt;br/&gt;    } &lt;span&gt;else&lt;/span&gt; {&lt;br/&gt;        &lt;span&gt;int&lt;/span&gt; num = ++methodSymnum;&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;&quot;sun/reflect/GeneratedMethodAccessor&quot;&lt;/span&gt; + num;&lt;br/&gt;    }&lt;br/&gt;}&lt;/span&gt;&lt;/section&gt;&lt;/pre&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;section&gt;&lt;span&gt;&lt;span&gt;// sun.reflect.ClassDefiner&lt;/span&gt;&lt;br/&gt;  &lt;br/&gt;&lt;span&gt;static&lt;/span&gt; Class&amp;lt;?&amp;gt; defineClass(String name, &lt;span&gt;byte&lt;/span&gt;[] bytes, &lt;span&gt;int&lt;/span&gt; off, &lt;span&gt;int&lt;/span&gt; len,&lt;br/&gt;                            &lt;span&gt;final&lt;/span&gt; ClassLoader parentClassLoader)&lt;br/&gt;{&lt;br/&gt;    ClassLoader newLoader = AccessController.doPrivileged(&lt;br/&gt;        &lt;span&gt;new&lt;/span&gt; PrivilegedAction&amp;lt;ClassLoader&amp;gt;() {&lt;br/&gt;            &lt;span&gt;&lt;span&gt;public&lt;/span&gt; ClassLoader &lt;span&gt;run&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;                    &lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; DelegatingClassLoader(parentClassLoader);&lt;br/&gt;                }&lt;br/&gt;            });&lt;br/&gt;   &lt;span&gt;// 通过 DelegatingClassLoader 类加载器定义生成类&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; unsafe.defineClass(name, bytes, off, len, newLoader, &lt;span&gt;null&lt;/span&gt;);&lt;br/&gt;}&lt;/span&gt;&lt;/section&gt;&lt;/pre&gt;&lt;section&gt;&lt;span&gt;那么，JVM反射调用为什么要做这么做？&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;其实这是JVM对反射调用的一种优化手段，在sun.reflect.ReflectionFactory的文档注释里对此做了解释，这是一种“Inflation”机制，加载字节码的调用方式在第一次调用时会比Native调用的速度要慢3~4倍，但是在后续调用时会比Native调用速度快20多倍。为了避免反射调用影响应用的启动速度，所以在反射调用的前几次通过Native方式调用，当超过一定调用次数后使用字节码方式调用，提升反射调用性能。&lt;/span&gt;&lt;/section&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;section&gt;&lt;span&gt;&quot;Inflation&quot; mechanism. Loading bytecodes to implement Method.invoke() and Constructor.newInstance() currently costs 3-4x more than an invocation via native code for the first invocation (though subsequent invocations have been benchmarked to be over 20x faster). Unfortunately this cost increases startup time for certain applications that use reflection intensively (but only once per class) to bootstrap themselves. To avoid this penalty we reuse the existing JVM entry points for the first few invocations of Methods and Constructors and then switch to the bytecode-based implementations.&lt;/span&gt;&lt;/section&gt;&lt;/blockquote&gt;&lt;section&gt;&lt;span&gt;至此，总算理清了类加载导致线程Block的直接原因，但这并非根因，业务代码中普普通通地打印一条ERROR日志，为何会导致解析、加载异常堆栈类？&lt;/span&gt;&lt;/section&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;3.2.5 为什么要解析异常堆栈？&lt;/span&gt;&lt;/h4&gt;&lt;section&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;562&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;276&quot; data-ratio=&quot;0.4905897114178168&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsXQu61RnticpkHboWVKAGbMJntLZDgMWfkl3xDffTQL46gX28YddkuqOLFdHibqcFbMMhrTSEX7KeSw/640?wx_fmt=png&quot; data-w=&quot;1594&quot;/&gt;&lt;figcaption&gt;&lt;span&gt;图15 AsyncAppender处理日志流程&lt;/span&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;AsyncAppender处理日志简要流程如上图15所示，在其内部维护一个BlockingQueue队列和一个AsyncThread线程，处理日志时先把日志转换成Log4jLogEvent快照然后入队，同时AsyncThread线程负责从队列里获取元素来异步处理日志事件。&lt;/span&gt;&lt;/section&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;section&gt;&lt;span&gt;&lt;span&gt;// org.apache.logging.log4j.core.appender.AsyncAppender&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;append&lt;/span&gt;&lt;span&gt;(&lt;span&gt;final&lt;/span&gt; LogEvent logEvent)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (!isStarted()) {&lt;br/&gt;        &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; IllegalStateException(&lt;span&gt;&quot;AsyncAppender &quot;&lt;/span&gt; + getName() + &lt;span&gt;&quot; is not active&quot;&lt;/span&gt;);&lt;br/&gt;    }&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (!Constants.FORMAT_MESSAGES_IN_BACKGROUND) { &lt;span&gt;// LOG4J2-898: user may choose&lt;/span&gt;&lt;br/&gt;        logEvent.getMessage().getFormattedMessage(); &lt;span&gt;// LOG4J2-763: ask message to freeze parameters&lt;/span&gt;&lt;br/&gt;    }&lt;br/&gt;   &lt;span&gt;// 创建 日志数据快照&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;final&lt;/span&gt; Log4jLogEvent memento = Log4jLogEvent.createMemento(logEvent, includeLocation);&lt;br/&gt;   &lt;span&gt;// 放入 BlockingQueue 中&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (!transfer(memento)) {&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (blocking) {&lt;br/&gt;            &lt;span&gt;// delegate to the event router (which may discard, enqueue and block, or log in current thread)&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;final&lt;/span&gt; EventRoute route = asyncQueueFullPolicy.getRoute(thread.getId(), memento.getLevel());&lt;br/&gt;            route.logMessage(&lt;span&gt;this&lt;/span&gt;, memento);&lt;br/&gt;        } &lt;span&gt;else&lt;/span&gt; {&lt;br/&gt;            error(&lt;span&gt;&quot;Appender &quot;&lt;/span&gt; + getName() + &lt;span&gt;&quot; is unable to write primary appenders. queue is full&quot;&lt;/span&gt;);&lt;br/&gt;            logToErrorAppenderIfNecessary(&lt;span&gt;false&lt;/span&gt;, memento);&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;}&lt;/span&gt;&lt;/section&gt;&lt;/pre&gt;&lt;section&gt;&lt;span&gt;AsyncAppender在生成LogEvent的快照Log4jLogEvent时，会先对LogEvent序列化处理统一转换为LogEventProxy，此时不同类型的LogEvent的处理情况稍有差异：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;综上，不管LogEvent的实际类型是MutableLogEvent还是Log4jLogEvent，最终都会触发创建ThrowableProxy实例，并在ThrowableProxy构造函数内触发了解析、加载异常堆栈类。&lt;/span&gt;&lt;/section&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;section&gt;&lt;span&gt;&lt;span&gt;// org.apache.logging.log4j.core.impl.Log4jLogEvent&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// 生成Log4jLogEvent快照&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; Log4jLogEvent &lt;span&gt;createMemento&lt;/span&gt;&lt;span&gt;(&lt;span&gt;final&lt;/span&gt; LogEvent event, &lt;span&gt;final&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; includeLocation)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;// TODO implement Log4jLogEvent.createMemento()&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; deserialize(serialize(event, includeLocation));&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; Serializable &lt;span&gt;serialize&lt;/span&gt;&lt;span&gt;(&lt;span&gt;final&lt;/span&gt; LogEvent event, &lt;span&gt;final&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; includeLocation)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (event &lt;span&gt;instanceof&lt;/span&gt; Log4jLogEvent) {&lt;br/&gt;       &lt;span&gt;// 确保 ThrowableProxy 已完成初始化&lt;/span&gt;&lt;br/&gt;        event.getThrownProxy(); &lt;span&gt;// ensure ThrowableProxy is initialized&lt;/span&gt;&lt;br/&gt;       &lt;span&gt;// 创建 LogEventProxy&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; LogEventProxy((Log4jLogEvent) event, includeLocation);&lt;br/&gt;    }&lt;br/&gt;   &lt;span&gt;// 创建 LogEventProxy&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; LogEventProxy(event, includeLocation);&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; ThrowableProxy &lt;span&gt;getThrownProxy&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (thrownProxy == &lt;span&gt;null&lt;/span&gt; &amp;amp;&amp;amp; thrown != &lt;span&gt;null&lt;/span&gt;) {&lt;br/&gt;        thrownProxy = &lt;span&gt;new&lt;/span&gt; ThrowableProxy(thrown);&lt;br/&gt;    }&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; thrownProxy;&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;LogEventProxy&lt;/span&gt;&lt;span&gt;(&lt;span&gt;final&lt;/span&gt; LogEvent event, &lt;span&gt;final&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; includeLocation)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;this&lt;/span&gt;.loggerFQCN = event.getLoggerFqcn();&lt;br/&gt;    &lt;span&gt;this&lt;/span&gt;.marker = event.getMarker();&lt;br/&gt;    &lt;span&gt;this&lt;/span&gt;.level = event.getLevel();&lt;br/&gt;    &lt;span&gt;this&lt;/span&gt;.loggerName = event.getLoggerName();&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;final&lt;/span&gt; Message msg = event.getMessage();&lt;br/&gt;    &lt;span&gt;this&lt;/span&gt;.message = msg &lt;span&gt;instanceof&lt;/span&gt; ReusableMessage&lt;br/&gt;            ? memento((ReusableMessage) msg)&lt;br/&gt;            : msg;&lt;br/&gt;    &lt;span&gt;this&lt;/span&gt;.timeMillis = event.getTimeMillis();&lt;br/&gt;    &lt;span&gt;this&lt;/span&gt;.thrown = event.getThrown();&lt;br/&gt;   &lt;span&gt;// 创建 ThrownProxy 实例&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;this&lt;/span&gt;.thrownProxy = event.getThrownProxy();&lt;br/&gt;    &lt;span&gt;this&lt;/span&gt;.contextData = memento(event.getContextData());&lt;br/&gt;    &lt;span&gt;this&lt;/span&gt;.contextStack = event.getContextStack();&lt;br/&gt;    &lt;span&gt;this&lt;/span&gt;.source = includeLocation ? event.getSource() : &lt;span&gt;null&lt;/span&gt;;&lt;br/&gt;    &lt;span&gt;this&lt;/span&gt;.threadId = event.getThreadId();&lt;br/&gt;    &lt;span&gt;this&lt;/span&gt;.threadName = event.getThreadName();&lt;br/&gt;    &lt;span&gt;this&lt;/span&gt;.threadPriority = event.getThreadPriority();&lt;br/&gt;    &lt;span&gt;this&lt;/span&gt;.isLocationRequired = includeLocation;&lt;br/&gt;    &lt;span&gt;this&lt;/span&gt;.isEndOfBatch = event.isEndOfBatch();&lt;br/&gt;    &lt;span&gt;this&lt;/span&gt;.nanoTime = event.getNanoTime();&lt;br/&gt;}&lt;/span&gt;&lt;/section&gt;&lt;/pre&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;section&gt;&lt;span&gt;&lt;span&gt;// org.apache.logging.log4j.core.impl.MutableLogEvent&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; ThrowableProxy &lt;span&gt;getThrownProxy&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (thrownProxy == &lt;span&gt;null&lt;/span&gt; &amp;amp;&amp;amp; thrown != &lt;span&gt;null&lt;/span&gt;) {&lt;br/&gt;       &lt;span&gt;// 构造 ThrowableProxy 时打印异常堆栈&lt;/span&gt;&lt;br/&gt;        thrownProxy = &lt;span&gt;new&lt;/span&gt; ThrowableProxy(thrown);&lt;br/&gt;    }&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; thrownProxy;&lt;br/&gt;}&lt;/span&gt;&lt;/section&gt;&lt;/pre&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;3.2.6 问题小结&lt;/span&gt;&lt;/h4&gt;&lt;section&gt;&lt;span&gt;Log4j2打印异常日志时，AsyncAppender会先创建日志事件快照，并进一步触发解析、加载异常堆栈类。JVM通过生成字节码的方式优化反射调用性能，但该动态生成的类无法被WebAppClassLoader类加载器加载，因此当大量包含反射调用的异常堆栈被输出到日志时，会频繁地触发类加载，由于类加载过程是synchronized同步加锁的，且每次加载都需要读取文件，速度较慢，从而导致线程Block。&lt;/span&gt;&lt;/section&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;3.3 Lambda表达式导致线程Block&lt;/span&gt;&lt;/h3&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;3.3.1 问题现场&lt;/span&gt;&lt;/h4&gt;&lt;section&gt;&lt;span&gt;收到“jvm.thread.blocked.count”告警后，立刻通过监控平台查看线程监控指标，当时的线程堆栈如下图16和图17所示：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;562&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;286&quot; data-ratio=&quot;0.5083333333333333&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsXQu61RnticpkHboWVKAGbMJrqL8ib4EeWcSvtlGkbnETtNKsHGSIJjax9ia4czzBDbHic2mWvfia6eC7Q/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1920&quot;/&gt;&lt;/figure&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;562&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;212&quot; data-ratio=&quot;0.3776041666666667&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsXQu61RnticpkHboWVKAGbMJvL0AZKq3RU8nGmwrjnqKWHqrhXNSzMS3wVImyTjdQmK17aMD1o8tZw/640?wx_fmt=png&quot; data-w=&quot;1920&quot;/&gt;&lt;figcaption&gt;&lt;span&gt;图16 等待锁的Blocked线程堆栈&lt;/span&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;562&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;290&quot; data-ratio=&quot;0.515625&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsXQu61RnticpkHboWVKAGbMJviaMs45iaZ1ib3mCv4iczrSNUMiaLniaeLwZBD5dic6Nwx9K3KcW2IwEXVPDA/640?wx_fmt=png&quot; data-w=&quot;1920&quot;/&gt;&lt;figcaption&gt;&lt;span&gt;图17 持有锁的Runnable线程堆栈&lt;/span&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;从Blocked线程堆栈不难看出是和日志打印相关，由于是ERROR级别日志，查看具体报错日志，发现如下图18所示的业务异常。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;562&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;376&quot; data-ratio=&quot;0.66875&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsXQu61RnticpkHboWVKAGbMJcQ8FpYiaDJPQIMibykV6YicAhctlhTacKicQJ3FrAwM9goicncPu6UBhwVA/640?wx_fmt=png&quot; data-w=&quot;1920&quot;/&gt;&lt;figcaption&gt;&lt;span&gt;图18 业务异常堆栈&lt;/span&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;本案例的Blocked线程堆栈和上述“AsyncAppender导致线程Block”案例一样，那么导致线程Block的罪魁祸首会是业务异常吗？接下来本章节将结合下图19所示的调用链路深入分析线程Block的根因。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;562&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;281&quot; data-ratio=&quot;0.5004803073967339&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsXQu61RnticpkHboWVKAGbMJPQQUHFMFSZ5Vk1ia9uCMlWOnfsD18n3T6v9QuKfUPz65eqspNS00mNA/640?wx_fmt=png&quot; data-w=&quot;2082&quot;/&gt;&lt;figcaption&gt;&lt;span&gt;图19 日志调用链路&lt;/span&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;/section&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;3.3.2 为什么会Block线程？&lt;/span&gt;&lt;/h4&gt;&lt;section&gt;&lt;span&gt;从Blocked线程堆栈中可以看出，线程阻塞在类加载上，该线程堆栈和上述“AsyncAppender导致线程Block”案例相似，这里不再重复分析。&lt;/span&gt;&lt;/section&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;3.3.3 为什么会触发类加载？&lt;/span&gt;&lt;/h4&gt;&lt;section&gt;&lt;span&gt;原因和上述“AsyncAppender导致线程Block”案例相似，这里不再重复分析。&lt;/span&gt;&lt;/section&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;3.3.4 到底什么类加载不了？&lt;/span&gt;&lt;/h4&gt;&lt;section&gt;&lt;span&gt;上述“AsyncAppender导致线程Block”案例中，类加载器无法加载由JVM针对反射调用优化所生成的字节码类，本案例是否也是该原因导致，还待进一步具体分析。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;要找到具体是什么类无法加载，归根结底还是要分析业务异常的具体堆栈。从业务堆栈中可以明显看出来，没有任何堆栈元素和JVM反射调用相关，因此排除JVM反射调用原因，但如下的特殊堆栈信息引起了注意：&lt;/span&gt;&lt;/section&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;section&gt;&lt;span&gt;com.sankuai.shepherd.core.process.ProcessHandlerFactory$$Lambda$&lt;span&gt;35&lt;/span&gt;/&lt;span&gt;1331430278&lt;/span&gt;&lt;/span&gt;&lt;/section&gt;&lt;/pre&gt;&lt;section&gt;&lt;span&gt;从堆栈的关键字$$Lambda$大致能猜测出这是代码里使用了Lambda表达式的缘故，查看代码确实相关部分使用了Lambda表达式，经过断点调试，证实的确无法加载该类。那么，这样的类是怎么来的？&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;查阅相关资料得知，Lambda表达式区别于匿名内部类实现，在构建时不会生成class文件，而是在运行时通过invokeDynamic指令动态调用，Lambda表达式的内容会被封装在一个静态方法内，JVM通过ASM字节码技术来动态生成调用类，也就是$$Lambda$这种形式的类，生成类示例如下图20所示：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;562&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;307&quot; data-ratio=&quot;0.5453795379537953&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsXQu61RnticpkHboWVKAGbMJwpO0vKka6SsYH6wFYT2noY43R4IcwIdccKxfDPp4WD2ONS0PqKkyWQ/640?wx_fmt=png&quot; data-w=&quot;1212&quot;/&gt;&lt;figcaption&gt;&lt;span&gt;图20 Lambda生成类示例&lt;/span&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;Lambda表达式的实现原理不是本文重点内容，在此不做过多介绍。项目代码中使用Lambda表达式是再普通不过的事情，但是关于此类的案例却并不多见，实在令人难以置信。继续查阅Lambda表达式相关文档，发现异常堆栈类名包含$$Lambda$这样的关键字，其实是JDK的一个Bug，相关Issue可参考:&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;值得一提的是，该Bug在JDK9版本已经修复，实际测试中发现，在JDK8的高版本如8U171等已修复该Bug，异常堆栈中不会有类似$$Lambda$的堆栈信息，示例如下图21所示：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;562&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;185&quot; data-ratio=&quot;0.3296875&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsXQu61RnticpkHboWVKAGbMJKYbFZrshb9EYophgL9R6USYXZ5NWibrF9sP43fePo2ygp3XBMBhqGQQ/640?wx_fmt=png&quot; data-w=&quot;1920&quot;/&gt;&lt;figcaption&gt;&lt;span&gt;图21 JDK8U171版本下Lambda异常堆栈示例&lt;/span&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;/section&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;3.3.5 为什么要解析异常堆栈？&lt;/span&gt;&lt;/h4&gt;&lt;section&gt;&lt;span&gt;原因和上述“AsyncAppender导致线程Block”案例相似，不再重复分析。&lt;/span&gt;&lt;/section&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;3.3.6 问题小结&lt;/span&gt;&lt;/h4&gt;&lt;section&gt;&lt;span&gt;Log4j2打印异常日志时，AsyncAppender会先创建日志事件快照，并进一步触发解析、加载异常堆栈类。JDK 8低版本中使用Lambda表达式所生成的异常堆栈类无法被WebAppClassLoader类加载器加载，因此，当大量包含Lambda表达式调用的异常堆栈被输出到日志时，会频繁地触发类加载，由于类加载过程是synchronized同步加锁的，且每次加载都需要读取文件，速度较慢，从而导致了线程Block。&lt;/span&gt;&lt;/section&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;3.4 AsyncLoggerConfig导致线程Block&lt;/span&gt;&lt;/h3&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;3.4.1 问题现场&lt;/span&gt;&lt;/h4&gt;&lt;section&gt;&lt;span&gt;收到“jvm.thread.blocked.count”告警后立刻通过监控平台查看线程监控指标，当时的线程堆栈如下图22和图23所示。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;562&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;282&quot; data-ratio=&quot;0.5010416666666667&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsXQu61RnticpkHboWVKAGbMJ6NyN5hwgsNeA4jkPjyVWjUVZBYyR7QunYZZTEicNg83XLknmWH3DAWA/640?wx_fmt=png&quot; data-w=&quot;1920&quot;/&gt;&lt;/figure&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;562&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;145&quot; data-ratio=&quot;0.25833333333333336&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsXQu61RnticpkHboWVKAGbMJsAHxH2EoGibTrGwgkicKwWmum2SkT3SLNryoJKE2ltfiaeXVgnAIX863A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1920&quot;/&gt;&lt;figcaption&gt;&lt;span&gt;图22 等待锁的Blocked线程堆栈&lt;/span&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;562&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;281&quot; data-ratio=&quot;0.49947916666666664&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsXQu61RnticpkHboWVKAGbMJP86NkLceZ6CNBtG8BaO2gd0xibrBicynHNYA4JzPRyKkZcAuAaH9UylQ/640?wx_fmt=png&quot; data-w=&quot;1920&quot;/&gt;&lt;figcaption&gt;&lt;span&gt;图23 持有锁的Runnable线程堆栈&lt;/span&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;从Blocked线程堆栈不难看出是和日志打印相关，本案例的业务异常和上述“AsyncAppender导致线程Block”的业务异常一样，这里不再重复介绍。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;那么，到底是什么原因导致线程Block呢？接下来本章节将结合下图24所示的调用链路深入分析线程Block的根因。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;562&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;247&quot; data-ratio=&quot;0.43981831945495836&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsXQu61RnticpkHboWVKAGbMJSEicHcN1AXcOFicpwwyY4uiawXicwGkIy8E6D2SSMHWrE6A4ZjGkftVichA/640?wx_fmt=png&quot; data-w=&quot;2642&quot;/&gt;&lt;figcaption&gt;&lt;span&gt;图24 日志调用链路&lt;/span&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;/section&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;3.4.2 为什么会Block线程？&lt;/span&gt;&lt;/h4&gt;&lt;section&gt;&lt;span&gt;原因和上述“AsyncAppender导致线程Block”案例相似，这里不再重复分析。&lt;/span&gt;&lt;/section&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;3.4.3 为什么会触发类加载？&lt;/span&gt;&lt;/h4&gt;&lt;section&gt;&lt;span&gt;原因和上述“AsyncAppender导致线程Block”案例相似，这里不再重复分析。&lt;/span&gt;&lt;/section&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;3.4.4 到底是什么类加载不了？&lt;/span&gt;&lt;/h4&gt;&lt;section&gt;&lt;span&gt;原因和上述“AsyncAppender导致线程Block”案例相似，这里不再重复分析。&lt;/span&gt;&lt;/section&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;3.4.5 为什么要解析异常堆栈？&lt;/span&gt;&lt;/h4&gt;&lt;section&gt;&lt;span&gt;在开始分析原因之前，先理清楚Log4j2关于日志的几个重要概念：&lt;/span&gt;&lt;/section&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;&amp;lt;Logger&amp;gt;，日志配置标签，用于XML日志配置文件中，对应Log4j2框架中的LoggerConfig类，同步分发日志事件到对应Appender。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;&amp;lt;AsyncLogger&amp;gt;，日志配置标签，用于XML日志配置文件中，对应Log4j2框架中的AsyncLoggerConfig类，内部使用Disruptor队列异步分发日志事件到对应Appender。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;Logger，同步日志类，用于创建同步日志实例，同步调用ReliabilityStrategy处理日志。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;AsyncLogger，异步日志类，用于创建异步日志实例，内部使用Disruptor队列实现异步调用ReliabilityStrategy处理日志。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;section&gt;&lt;span&gt;总的来说，&amp;lt;Logger&amp;gt;标签和Logger类是完全不同的两个概念，&amp;lt;AsyncLogger&amp;gt;标签和AsyncLogger类也是完全不同的两个概念，不可混淆。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;由于项目并未配置Log4jContextSelector参数，所以使用的是同步Logger，即通过LoggerFactory.getLogger方法获取的是Logger类实例而不是AsyncLogger类实例，同时由于项目的log4j2.xml配置文件里配置了&amp;lt;AsyncLogger&amp;gt;标签，所以其底层是Logger和AsyncLoggerConfig组合。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;AsyncLoggerConfig处理日志事件简要流程如下图25所示，内部使用Disruptor队列，在生成队列元素时，由translator来负责填充元素字段，并把填充后的元素放入RingBuffer中，于此同时，独立的异步线程从RingBuffer中消费事件，并调用配置在该AsyncLoggerConfig上的Appender处理日志请求。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;562&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;116&quot; data-ratio=&quot;0.2070030895983522&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsXQu61RnticpkHboWVKAGbMJyOZ20ibSgg3JgxhsA37ZiaMSPSd1gMYDUpUzibQy2BOtheme8X4BYgZ8g/640?wx_fmt=png&quot; data-w=&quot;1942&quot;/&gt;&lt;figcaption&gt;&lt;span&gt;图25 AsyncLoggerConfig处理流程&lt;/span&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;AsyncLoggerConfig提供了带有Disruptor队列实现的代理类即AsyncLoggerConfigDisruptor，在日志事件进入RingBuffer时，由于项目使用的是ReusableLogEventFactory，所以由MUTABLE_TRANSLATOR负责初始化日志事件，在此过程中会调用getThrownProxy方法创建ThrowableProxy实例，进而在ThrowableProxy构造函数内部触发解析、加载异常堆栈类。&lt;/span&gt;&lt;/section&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;section&gt;&lt;span&gt;&lt;span&gt;// org.apache.logging.log4j.core.async.AsyncLoggerConfigDisruptor$EventTranslatorTwoArg&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;/**&lt;br/&gt; * Object responsible for passing on data to a RingBuffer event with a MutableLogEvent.&lt;br/&gt; */&lt;/span&gt;&lt;br/&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; EventTranslatorTwoArg&amp;lt;Log4jEventWrapper, LogEvent, AsyncLoggerConfig&amp;gt; MUTABLE_TRANSLATOR =&lt;br/&gt;        &lt;span&gt;new&lt;/span&gt; EventTranslatorTwoArg&amp;lt;Log4jEventWrapper, LogEvent, AsyncLoggerConfig&amp;gt;() {&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;translateTo&lt;/span&gt;&lt;span&gt;(&lt;span&gt;final&lt;/span&gt; Log4jEventWrapper ringBufferElement, &lt;span&gt;final&lt;/span&gt; &lt;span&gt;long&lt;/span&gt; sequence,&lt;br/&gt;            &lt;span&gt;final&lt;/span&gt; LogEvent logEvent, &lt;span&gt;final&lt;/span&gt; AsyncLoggerConfig loggerConfig)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;       &lt;span&gt;// 初始化 Disruptor RingBuffer 日志元素字段&lt;/span&gt;&lt;br/&gt;        ((MutableLogEvent) ringBufferElement.event).initFrom(logEvent);&lt;br/&gt;        ringBufferElement.loggerConfig = loggerConfig;&lt;br/&gt;    }&lt;br/&gt;};&lt;/span&gt;&lt;/section&gt;&lt;/pre&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;section&gt;&lt;span&gt;&lt;span&gt;// org.apache.logging.log4j.core.impl.MutableLogEvent&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;initFrom&lt;/span&gt;&lt;span&gt;(&lt;span&gt;final&lt;/span&gt; LogEvent event)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;this&lt;/span&gt;.loggerFqcn = event.getLoggerFqcn();&lt;br/&gt;    &lt;span&gt;this&lt;/span&gt;.marker = event.getMarker();&lt;br/&gt;    &lt;span&gt;this&lt;/span&gt;.level = event.getLevel();&lt;br/&gt;    &lt;span&gt;this&lt;/span&gt;.loggerName = event.getLoggerName();&lt;br/&gt;    &lt;span&gt;this&lt;/span&gt;.timeMillis = event.getTimeMillis();&lt;br/&gt;    &lt;span&gt;this&lt;/span&gt;.thrown = event.getThrown();&lt;br/&gt;   &lt;span&gt;// 触发创建 ThrowableProxy 实例&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;this&lt;/span&gt;.thrownProxy = event.getThrownProxy();&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;// &lt;span&gt;NOTE:&lt;/span&gt; this ringbuffer event SHOULD NOT keep a reference to the specified&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;// thread-local MutableLogEvent&#x27;s context data, because then two threads would call&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;// ReadOnlyStringMap.clear() on the same shared instance, resulting in data corruption.&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;this&lt;/span&gt;.contextData.putAll(event.getContextData());&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;this&lt;/span&gt;.contextStack = event.getContextStack();&lt;br/&gt;    &lt;span&gt;this&lt;/span&gt;.source = event.isIncludeLocation() ? event.getSource() : &lt;span&gt;null&lt;/span&gt;;&lt;br/&gt;    &lt;span&gt;this&lt;/span&gt;.threadId = event.getThreadId();&lt;br/&gt;    &lt;span&gt;this&lt;/span&gt;.threadName = event.getThreadName();&lt;br/&gt;    &lt;span&gt;this&lt;/span&gt;.threadPriority = event.getThreadPriority();&lt;br/&gt;    &lt;span&gt;this&lt;/span&gt;.endOfBatch = event.isEndOfBatch();&lt;br/&gt;    &lt;span&gt;this&lt;/span&gt;.includeLocation = event.isIncludeLocation();&lt;br/&gt;    &lt;span&gt;this&lt;/span&gt;.nanoTime = event.getNanoTime();&lt;br/&gt;    setMessage(event.getMessage());&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; ThrowableProxy &lt;span&gt;getThrownProxy&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (thrownProxy == &lt;span&gt;null&lt;/span&gt; &amp;amp;&amp;amp; thrown != &lt;span&gt;null&lt;/span&gt;) {&lt;br/&gt;       &lt;span&gt;// 构造 ThrowableProxy 时打印异常堆栈&lt;/span&gt;&lt;br/&gt;        thrownProxy = &lt;span&gt;new&lt;/span&gt; ThrowableProxy(thrown);&lt;br/&gt;    }&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; thrownProxy;&lt;br/&gt;}&lt;/span&gt;&lt;/section&gt;&lt;/pre&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;3.4.6 问题小结&lt;/span&gt;&lt;/h4&gt;&lt;section&gt;&lt;span&gt;Log4j2打印异常日志时，AsyncLoggerConfig会初始化Disruptor RingBuffer日志元素字段，并进一步触发解析、加载异常堆栈类。JVM通过生成字节码的方式优化反射调用性能，但该动态生成的类无法被WebAppClassLoader类加载器加载，因此当大量包含反射调用的异常堆栈被输出到日志时，会频繁地触发类加载，由于类加载过程是synchronized同步加锁的，且每次加载都需要读取文件，速度较慢，从而导致线程Block。&lt;/span&gt;&lt;/section&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;4. 避坑指南&lt;/span&gt;&lt;/h2&gt;&lt;section&gt;&lt;span&gt;本章节主要对上述案例中导致线程Block的原因进行汇总分析，并给出相应的解决方案。&lt;/span&gt;&lt;/section&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;4.1 问题总结&lt;/span&gt;&lt;/h3&gt;&lt;section&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;562&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;121&quot; data-ratio=&quot;0.21521997621878716&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsXQu61RnticpkHboWVKAGbMJvkDdxRibHNJTicv3PObBZlibRAL9PkzRfiaPMl6xdEDZZnHGf9LA0Ldsqw/640?wx_fmt=png&quot; data-w=&quot;1682&quot;/&gt;&lt;figcaption&gt;&lt;span&gt;图26 日志异步处理流程&lt;/span&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;日志异步处理流程示意如图26所示，整体步骤如下：&lt;/span&gt;&lt;/section&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;业务线程组装日志事件对象，如创建日志快照或者初始化日志字段等。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;日志事件对象入队，如BlockingQueue队列或Disruptor RingBuffer队列等。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;日志异步线程从队列获取日志事件对象，并输出至目的地，如本地磁盘文件或远程日志中心等。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;section&gt;&lt;span&gt;对应地，Log4j2导致线程Block的主要潜在风险点如下：&lt;/span&gt;&lt;/section&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;如上图标号①所示，日志事件对象在入队前，组装日志事件时触发了异常堆栈类解析、加载，从而引发线程Block。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;如上图标号②所示，日志事件对象在入队时，由于队列满，无法入队，从而引发线程Block。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;如上图标号③所示，日志事件对象在出队后，对日志内容进行格式化处理时触发了异常堆栈类解析、加载，从而引发线程 Block。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;section&gt;&lt;span&gt;从上述分析不难看出：&lt;/span&gt;&lt;/section&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;标号①和②处如果发生线程Block，那么会直接影响业务线程池内的所有线程。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;标号③出如果发生线程Block，那么会影响日志异步线程，该线程通常为单线程。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;标号①和②处发生线程Block的影响范围远比标号③更大，因此核心是要避免日志事件在入队操作完成前触发线程Block&lt;/strong&gt;。其实日志异步线程通常是单线程，因此对于单个Appender来说，不会出现Block现象，至多会导致异步线程处理速度变慢而已，但如果存在多个异步Appender，那么多个日志异步线程仍然会出现彼此Block的现象。&lt;/span&gt;&lt;/section&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;4.2 对症下药&lt;/span&gt;&lt;/h3&gt;&lt;section&gt;&lt;span&gt;搞清楚了日志导致线程Block的原因后，问题也就不难解决，解决方案主要从日志事件“入队前”、“入队时”和“出队后”三方面展开。&lt;/span&gt;&lt;/section&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;4.2.1 入队前避免线程Block&lt;/span&gt;&lt;/h4&gt;&lt;section&gt;&lt;span&gt;结合上文分析的“AsyncAppender导致线程Block”、“Lambda表达式导致线程Block”和“AsyncLoggerConfig导致线程Block”案例，日志事件入队前避免线程Block的解决方案可从如下几方面考虑：&lt;/span&gt;&lt;/section&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;日志事件入队前避免触发异常堆栈类解析、加载操作。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;禁用JVM反射调用优化。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;升级JDK版本修复Lambda类Bug。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;section&gt;&lt;span&gt;先说方案结论：&lt;/span&gt;&lt;/section&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;自定义Appender实现，创建日志事件快照时避免触发异常堆栈类解析、加载，美团内部Scribe-Log提供的AsyncScribeAppender即是如此。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;日志配置文件中不使用&amp;lt;AsyncLogger&amp;gt;标签，可以使用&amp;lt;Logger&amp;gt;标签来代替。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;section&gt;&lt;span&gt;下面具体分析方案可行性：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;1.&lt;/strong&gt; &lt;strong&gt;日志事件入队前避免触发异常堆栈类解析、加载操作&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;如果在日志事件入队前，能避免异常堆栈类解析、加载操作，则可从根本上解决该问题，但在Log4j2的2.17.1版本中AsyncAppender和AsyncLoggerConfig仍存在该问题，此时：&lt;/span&gt;&lt;/section&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;对于AsyncAppender场景来说，可以通过自定义Appender实现，在生成日志事件快照时避免触发解析、加载异常堆栈类，并在配置文件中使用自定义的Appender代替Log4j2提供的AsyncAppender。自定义AsyncScribeAppender相关代码片段如下。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;section&gt;&lt;span&gt;&lt;span&gt;// org.apache.logging.log4j.scribe.appender.AsyncScribeAppender&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;append&lt;/span&gt;&lt;span&gt;(&lt;span&gt;final&lt;/span&gt; LogEvent logEvent)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;// ... 以上部分忽略 ...&lt;/span&gt;&lt;br/&gt;    Log4jLogEvent.Builder builder = &lt;span&gt;new&lt;/span&gt; Log4jLogEvent.Builder(event);&lt;br/&gt;    builder.setIncludeLocation(includeLocation);&lt;br/&gt;    &lt;span&gt;// 创建日志快照，避免解析、加载异常堆栈类&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;final&lt;/span&gt; Log4jLogEvent memento = builder.build();&lt;br/&gt;    &lt;span&gt;// ... 以下部分忽略 ...&lt;/span&gt;&lt;br/&gt;}&lt;/span&gt;&lt;/section&gt;&lt;/pre&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;对于AsyncLoggerConfig场景来说，可以考虑使用非ReusableLogEventFactory类型的LogEventFactory来规避该问题，除此之外也可以考虑换用LoggerConfig来避免该问题。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;2.&lt;/strong&gt; &lt;strong&gt;禁用JVM反射调用优化&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;调大inflationThreshold（&lt;/span&gt;&lt;span&gt;其类型为 int&lt;/span&gt;&lt;span&gt;）值到int最大值，如此，虽然一定范围内（&lt;/span&gt;&lt;span&gt;反射调用次数不超过int最大值时&lt;/span&gt;&lt;span&gt;）避免了类加载Block问题，但损失了反射调用性能，顾此失彼，且无法根治。另外，对于非反射类问题仍然无法解决，如上文所述的Lambda表达式问题等。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;3.&lt;/strong&gt; &lt;strong&gt;升级JDK版本修复Lambda类Bug&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;升级JDK版本的确可以解决Lambda表达式问题，但并不能彻底解决线程Block问题，如上文所述的反射调用等。&lt;/span&gt;&lt;/section&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;4.2.2 入队时避免线程Block&lt;/span&gt;&lt;/h4&gt;&lt;section&gt;&lt;span&gt;结合上文分析的“日志队列满导致线程Block”案例，日志事件入队时避免线程Block的解决方案可从如下几方面考虑：&lt;/span&gt;&lt;/section&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;日志队列满时，Appender忽略该日志。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;Appender使用自定义的ErrorHandler实现处理日志。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;关闭StatusConfigListener日志输出。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;section&gt;&lt;span&gt;先说方案结论：&lt;strong&gt;自定义Appender实现，日志事件入队失败时忽略错误日志，美团内部Scribe-Log提供的AsyncScribeAppender即是如此&lt;/strong&gt;。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;下面具体分析方案可行性：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;1.&lt;/strong&gt; &lt;strong&gt;日志队列满时Appender忽略该日志&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;日志队列满，某种程度上说明日志线程的处理能力不足，在现有机器资源不变的情况下需要做一定取舍，如果日志不是特别重要通常可丢弃该日志，此时：&lt;/span&gt;&lt;/section&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;section&gt;&lt;span&gt;&lt;span&gt;// org.apache.logging.log4j.scribe.appender.AsyncScribeAppender&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;append&lt;/span&gt;&lt;span&gt;(&lt;span&gt;final&lt;/span&gt; LogEvent logEvent)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;// ... 以上部分忽略 ...&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (!transfer(memento)) {&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (blocking) {&lt;br/&gt;            &lt;span&gt;// delegate to the event router (which may discard, enqueue and block, or log in current thread)&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;final&lt;/span&gt; EventRouteAsyncScribe route = asyncScribeQueueFullPolicy.getRoute(processingThread.getId(), memento.getLevel());&lt;br/&gt;            route.logMessage(&lt;span&gt;this&lt;/span&gt;, memento);&lt;br/&gt;        } &lt;span&gt;else&lt;/span&gt; {&lt;br/&gt;           &lt;span&gt;// 自定义printDebugInfo参数，控制是否输出error信息，默认为false&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;if&lt;/span&gt; (printDebugInfo) {&lt;br/&gt;                error(&lt;span&gt;&quot;Appender &quot;&lt;/span&gt; + getName() + &lt;span&gt;&quot; is unable to write primary appenders. queue is full&quot;&lt;/span&gt;);&lt;br/&gt;            }&lt;br/&gt;            logToErrorAppenderIfNecessary(&lt;span&gt;false&lt;/span&gt;, memento);&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;  &lt;span&gt;// ... 以下部分忽略 ...&lt;/span&gt;&lt;br/&gt;}&lt;/span&gt;&lt;/section&gt;&lt;/pre&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;2.&lt;/strong&gt; &lt;strong&gt;Appender使用自定义的ErrorHandler实现处理日志&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;自定义ErrorHandler，Appender内设置handler为自定义ErrorHandler实例即可，但该方式仅适用于通过Log4j2 API方式创建的Logger，不支持日志配置文件的使用方式。由于大多数用户都使用配置文件方式，所以该方案使用场景有限，不过可以期待后续日志框架支持配置文件自定义ErrorHandler，已有相关&lt;/span&gt;&lt;a href=&quot;https://issues.apache.org/jira/browse/LOG4J2-2927&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;Issue: ErrorHandlers on Appenders cannot be configured&lt;/span&gt;&lt;/a&gt;&lt;span&gt;反馈给社区。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;3.&lt;/strong&gt; &lt;strong&gt;关闭StatusConfigListener日志输出&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;4.2.3 出队后避免线程Block&lt;/span&gt;&lt;/h4&gt;&lt;section&gt;&lt;span&gt;日志事件出队后会按照用户配置的输出样式，对日志内容进行格式化转换，此时仍然可能触发解析、加载异常堆栈类。因此，日志出队后避免线程Block的根本解决方法是在异常格式化转换时避免解析、加载异常堆栈类。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;先说方案结论：&lt;strong&gt;显式配置日志输出样式%ex来代替默认的%xEx，避免对日志内容格式化时解析、加载异常堆栈类&lt;/strong&gt;。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;下面通过分析日志内容格式化处理流程来介绍解决方案。以PatternLayout为例，日志内容格式化转换流程链路为：Layout-&amp;gt;PatternFormatter-&amp;gt;LogEventPatternConverter。其中LogEventPatternConverter是个抽象类，有两个处理异常的格式化转换具体实现类，分别是ThrowablePatternConverter和ExtendedThrowablePatternConverter。&lt;/span&gt;&lt;/section&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;section&gt;&lt;span&gt;&lt;span&gt;// org.apache.logging.log4j.core.layout.PatternLayout&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// 将 LogEvent 转换为可以输出的 String&lt;/span&gt;&lt;br/&gt;&lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; String &lt;span&gt;toSerializable&lt;/span&gt;&lt;span&gt;(&lt;span&gt;final&lt;/span&gt; LogEvent event)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;   &lt;span&gt;// 由 PatternSerializer 对日志事件格式化处理&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; eventSerializer.toSerializable(event);&lt;br/&gt;}&lt;/span&gt;&lt;/section&gt;&lt;/pre&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;section&gt;&lt;span&gt;&lt;span&gt;// org.apache.logging.log4j.core.layout.PatternLayout.PatternSerializer&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; String &lt;span&gt;toSerializable&lt;/span&gt;&lt;span&gt;(&lt;span&gt;final&lt;/span&gt; LogEvent event)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;final&lt;/span&gt; StringBuilder sb = getStringBuilder();&lt;br/&gt;    &lt;span&gt;try&lt;/span&gt; {&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; toSerializable(event, sb).toString();&lt;br/&gt;    } &lt;span&gt;finally&lt;/span&gt; {&lt;br/&gt;        trimToMaxSize(sb);&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; StringBuilder &lt;span&gt;toSerializable&lt;/span&gt;&lt;span&gt;(&lt;span&gt;final&lt;/span&gt; LogEvent event, &lt;span&gt;final&lt;/span&gt; StringBuilder buffer)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; len = formatters.length;&lt;br/&gt;    &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; len; i++) {&lt;br/&gt;      &lt;span&gt;// 由 PatternFormatter 对日志事件格式化处理&lt;/span&gt;&lt;br/&gt;        formatters[i].format(event, buffer);&lt;br/&gt;    }&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (replace != &lt;span&gt;null&lt;/span&gt;) { &lt;span&gt;// creates temporary objects&lt;/span&gt;&lt;br/&gt;        String str = buffer.toString();&lt;br/&gt;        str = replace.format(str);&lt;br/&gt;        buffer.setLength(&lt;span&gt;0&lt;/span&gt;);&lt;br/&gt;        buffer.append(str);&lt;br/&gt;    }&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; buffer;&lt;br/&gt;}&lt;/span&gt;&lt;/section&gt;&lt;/pre&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;section&gt;&lt;span&gt;&lt;span&gt;// org.apache.logging.log4j.core.pattern.PatternFormatter&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;format&lt;/span&gt;&lt;span&gt;(&lt;span&gt;final&lt;/span&gt; LogEvent event, &lt;span&gt;final&lt;/span&gt; StringBuilder buf)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (skipFormattingInfo) {&lt;br/&gt;       &lt;span&gt;// 由 LogEventPatternConverter 对日志事件进行格式化处理&lt;/span&gt;&lt;br/&gt;        converter.format(event, buf);&lt;br/&gt;    } &lt;span&gt;else&lt;/span&gt; {&lt;br/&gt;        formatWithInfo(event, buf);&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;formatWithInfo&lt;/span&gt;&lt;span&gt;(&lt;span&gt;final&lt;/span&gt; LogEvent event, &lt;span&gt;final&lt;/span&gt; StringBuilder buf)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; startField = buf.length();&lt;br/&gt;   &lt;span&gt;// 由 LogEventPatternConverter 对日志事件进行格式化处理&lt;/span&gt;&lt;br/&gt;    converter.format(event, buf);&lt;br/&gt;    field.format(startField, buf);&lt;br/&gt;}&lt;/span&gt;&lt;/section&gt;&lt;/pre&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;section&gt;&lt;span&gt;&lt;span&gt;// org.apache.logging.log4j.core.pattern.LogEventPatternConverter&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;abstract&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;LogEventPatternConverter&lt;/span&gt; &lt;span&gt;extends&lt;/span&gt; &lt;span&gt;AbstractPatternConverter&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;/**&lt;br/&gt;     * 将日志事件 LogEvent 转换为 String&lt;br/&gt;     * Formats an event into a string buffer.&lt;br/&gt;     *&lt;br/&gt;     * &lt;span&gt;@param&lt;/span&gt; event      event to format, may not be null.&lt;br/&gt;     * &lt;span&gt;@param&lt;/span&gt; toAppendTo string buffer to which the formatted event will be appended.  May not be null.&lt;br/&gt;     */&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;abstract&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;format&lt;/span&gt;&lt;span&gt;(&lt;span&gt;final&lt;/span&gt; LogEvent event, &lt;span&gt;final&lt;/span&gt; StringBuilder toAppendTo)&lt;/span&gt;&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;}&lt;/span&gt;&lt;/section&gt;&lt;/pre&gt;&lt;section&gt;&lt;span&gt;日志框架对异常进行格式化转换时，有如下两个配置项可参考，默认配置是%xEx。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;1.&lt;/strong&gt; &lt;strong&gt;%ex，仅输出异常信息，不获取扩展信息（JAR文件名称和版本信息）&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;对应的格式转化类是ThrowablePatternConverter，在format方法内部并没有获取ThrowableProxy对象，所以不会触发解析、加载异常堆栈类。&lt;/span&gt;&lt;/section&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;section&gt;&lt;span&gt;&lt;span&gt;// org.apache.logging.log4j.core.pattern.ThrowablePatternConverter&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;@Plugin&lt;/span&gt;(name = &lt;span&gt;&quot;ThrowablePatternConverter&quot;&lt;/span&gt;, category = PatternConverter.CATEGORY)&lt;br/&gt;&lt;span&gt;@ConverterKeys&lt;/span&gt;({ &lt;span&gt;&quot;ex&quot;&lt;/span&gt;, &lt;span&gt;&quot;throwable&quot;&lt;/span&gt;, &lt;span&gt;&quot;exception&quot;&lt;/span&gt; })&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;ThrowablePatternConverter&lt;/span&gt; &lt;span&gt;extends&lt;/span&gt; &lt;span&gt;LogEventPatternConverter&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;/**&lt;br/&gt;     * {&lt;span&gt;@inheritDoc&lt;/span&gt;}&lt;br/&gt;     */&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;format&lt;/span&gt;&lt;span&gt;(&lt;span&gt;final&lt;/span&gt; LogEvent event, &lt;span&gt;final&lt;/span&gt; StringBuilder buffer)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;final&lt;/span&gt; Throwable t = event.getThrown();&lt;br/&gt;&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (isSubShortOption()) {&lt;br/&gt;            formatSubShortOption(t, getSuffix(event), buffer);&lt;br/&gt;        }&lt;br/&gt;        &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (t != &lt;span&gt;null&lt;/span&gt; &amp;amp;&amp;amp; options.anyLines()) {&lt;br/&gt;            formatOption(t, getSuffix(event), buffer);&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; &lt;span&gt;isSubShortOption&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; ThrowableFormatOptions.MESSAGE.equalsIgnoreCase(rawOption) ||&lt;br/&gt;                ThrowableFormatOptions.LOCALIZED_MESSAGE.equalsIgnoreCase(rawOption) ||&lt;br/&gt;                ThrowableFormatOptions.FILE_NAME.equalsIgnoreCase(rawOption) ||&lt;br/&gt;                ThrowableFormatOptions.LINE_NUMBER.equalsIgnoreCase(rawOption) ||&lt;br/&gt;                ThrowableFormatOptions.METHOD_NAME.equalsIgnoreCase(rawOption) ||&lt;br/&gt;                ThrowableFormatOptions.CLASS_NAME.equalsIgnoreCase(rawOption);&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;formatSubShortOption&lt;/span&gt;&lt;span&gt;(&lt;span&gt;final&lt;/span&gt; Throwable t, &lt;span&gt;final&lt;/span&gt; String suffix, &lt;span&gt;final&lt;/span&gt; StringBuilder buffer)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        StackTraceElement[] trace;&lt;br/&gt;        StackTraceElement throwingMethod = &lt;span&gt;null&lt;/span&gt;;&lt;br/&gt;        &lt;span&gt;int&lt;/span&gt; len;&lt;br/&gt;&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (t != &lt;span&gt;null&lt;/span&gt;) {&lt;br/&gt;            trace = t.getStackTrace();&lt;br/&gt;            &lt;span&gt;if&lt;/span&gt; (trace !=&lt;span&gt;null&lt;/span&gt; &amp;amp;&amp;amp; trace.length &amp;gt; &lt;span&gt;0&lt;/span&gt;) {&lt;br/&gt;                throwingMethod = trace[&lt;span&gt;0&lt;/span&gt;];&lt;br/&gt;            }&lt;br/&gt;        }&lt;br/&gt;&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (t != &lt;span&gt;null&lt;/span&gt; &amp;amp;&amp;amp; throwingMethod != &lt;span&gt;null&lt;/span&gt;) {&lt;br/&gt;            String toAppend = Strings.EMPTY;&lt;br/&gt;&lt;br/&gt;            &lt;span&gt;if&lt;/span&gt; (ThrowableFormatOptions.CLASS_NAME.equalsIgnoreCase(rawOption)) {&lt;br/&gt;                toAppend = throwingMethod.getClassName();&lt;br/&gt;            }&lt;br/&gt;            &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (ThrowableFormatOptions.METHOD_NAME.equalsIgnoreCase(rawOption)) {&lt;br/&gt;                toAppend = throwingMethod.getMethodName();&lt;br/&gt;            }&lt;br/&gt;            &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (ThrowableFormatOptions.LINE_NUMBER.equalsIgnoreCase(rawOption)) {&lt;br/&gt;                toAppend = String.valueOf(throwingMethod.getLineNumber());&lt;br/&gt;            }&lt;br/&gt;            &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (ThrowableFormatOptions.MESSAGE.equalsIgnoreCase(rawOption)) {&lt;br/&gt;                toAppend = t.getMessage();&lt;br/&gt;            }&lt;br/&gt;            &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (ThrowableFormatOptions.LOCALIZED_MESSAGE.equalsIgnoreCase(rawOption)) {&lt;br/&gt;                toAppend = t.getLocalizedMessage();&lt;br/&gt;            }&lt;br/&gt;            &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (ThrowableFormatOptions.FILE_NAME.equalsIgnoreCase(rawOption)) {&lt;br/&gt;                toAppend = throwingMethod.getFileName();&lt;br/&gt;            }&lt;br/&gt;&lt;br/&gt;            len = buffer.length();&lt;br/&gt;            &lt;span&gt;if&lt;/span&gt; (len &amp;gt; &lt;span&gt;0&lt;/span&gt; &amp;amp;&amp;amp; !Character.isWhitespace(buffer.charAt(len - &lt;span&gt;1&lt;/span&gt;))) {&lt;br/&gt;                buffer.append(&lt;span&gt;&#x27; &#x27;&lt;/span&gt;);&lt;br/&gt;            }&lt;br/&gt;            buffer.append(toAppend);&lt;br/&gt;&lt;br/&gt;            &lt;span&gt;if&lt;/span&gt; (Strings.isNotBlank(suffix)) {&lt;br/&gt;                buffer.append(&lt;span&gt;&#x27; &#x27;&lt;/span&gt;);&lt;br/&gt;                buffer.append(suffix);&lt;br/&gt;            }&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;formatOption&lt;/span&gt;&lt;span&gt;(&lt;span&gt;final&lt;/span&gt; Throwable throwable, &lt;span&gt;final&lt;/span&gt; String suffix, &lt;span&gt;final&lt;/span&gt; StringBuilder buffer)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;final&lt;/span&gt; StringWriter w = &lt;span&gt;new&lt;/span&gt; StringWriter();&lt;br/&gt;&lt;br/&gt;        throwable.printStackTrace(&lt;span&gt;new&lt;/span&gt; PrintWriter(w));&lt;br/&gt;        &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; len = buffer.length();&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (len &amp;gt; &lt;span&gt;0&lt;/span&gt; &amp;amp;&amp;amp; !Character.isWhitespace(buffer.charAt(len - &lt;span&gt;1&lt;/span&gt;))) {&lt;br/&gt;            buffer.append(&lt;span&gt;&#x27; &#x27;&lt;/span&gt;);&lt;br/&gt;        }&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (!options.allLines() || !Strings.LINE_SEPARATOR.equals(options.getSeparator()) || Strings.isNotBlank(suffix)) {&lt;br/&gt;            &lt;span&gt;final&lt;/span&gt; StringBuilder sb = &lt;span&gt;new&lt;/span&gt; StringBuilder();&lt;br/&gt;            &lt;span&gt;final&lt;/span&gt; String[] array = w.toString().split(Strings.LINE_SEPARATOR);&lt;br/&gt;            &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; limit = options.minLines(array.length) - &lt;span&gt;1&lt;/span&gt;;&lt;br/&gt;            &lt;span&gt;final&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; suffixNotBlank = Strings.isNotBlank(suffix);&lt;br/&gt;            &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt;= limit; ++i) {&lt;br/&gt;                sb.append(array[i]);&lt;br/&gt;                &lt;span&gt;if&lt;/span&gt; (suffixNotBlank) {&lt;br/&gt;                    sb.append(&lt;span&gt;&#x27; &#x27;&lt;/span&gt;);&lt;br/&gt;                    sb.append(suffix);&lt;br/&gt;                }&lt;br/&gt;                &lt;span&gt;if&lt;/span&gt; (i &amp;lt; limit) {&lt;br/&gt;                    sb.append(options.getSeparator());&lt;br/&gt;                }&lt;br/&gt;            }&lt;br/&gt;            buffer.append(sb.toString());&lt;br/&gt;&lt;br/&gt;        } &lt;span&gt;else&lt;/span&gt; {&lt;br/&gt;            buffer.append(w.toString());&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;/**&lt;br/&gt;     * This converter obviously handles throwables.&lt;br/&gt;     *&lt;br/&gt;     * &lt;span&gt;@return&lt;/span&gt; true.&lt;br/&gt;     */&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; &lt;span&gt;handlesThrowable&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;;&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;protected&lt;/span&gt; String &lt;span&gt;getSuffix&lt;/span&gt;&lt;span&gt;(&lt;span&gt;final&lt;/span&gt; LogEvent event)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;//noinspection ForLoopReplaceableByForEach&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;final&lt;/span&gt; StringBuilder toAppendTo = &lt;span&gt;new&lt;/span&gt; StringBuilder();&lt;br/&gt;        &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;, size = formatters.size(); i &amp;lt;  size; i++) {&lt;br/&gt;            formatters.get(i).format(event, toAppendTo);&lt;br/&gt;        }&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; toAppendTo.toString();&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; ThrowableFormatOptions &lt;span&gt;getOptions&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; options;&lt;br/&gt;    }&lt;br/&gt;}&lt;/span&gt;&lt;/section&gt;&lt;/pre&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;2.&lt;/strong&gt; &lt;strong&gt;%xEx，不仅输出异常信息，同时获取扩展信息&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;对应的格式转化类是ExtendedThrowablePatternConverter，在format方法内部获取了ThrowableProxy对象，此时一定会触发解析、加载异常堆栈类。&lt;/span&gt;&lt;/section&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;section&gt;&lt;span&gt;&lt;span&gt;// org.apache.logging.log4j.core.pattern.ExtendedThrowablePatternConverter&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;@Plugin&lt;/span&gt;(name = &lt;span&gt;&quot;ExtendedThrowablePatternConverter&quot;&lt;/span&gt;, category = PatternConverter.CATEGORY)&lt;br/&gt;&lt;span&gt;@ConverterKeys&lt;/span&gt;({ &lt;span&gt;&quot;xEx&quot;&lt;/span&gt;, &lt;span&gt;&quot;xThrowable&quot;&lt;/span&gt;, &lt;span&gt;&quot;xException&quot;&lt;/span&gt; })&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;ExtendedThrowablePatternConverter&lt;/span&gt; &lt;span&gt;extends&lt;/span&gt; &lt;span&gt;ThrowablePatternConverter&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;/**&lt;br/&gt;     * {&lt;span&gt;@inheritDoc&lt;/span&gt;}&lt;br/&gt;     */&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;format&lt;/span&gt;&lt;span&gt;(&lt;span&gt;final&lt;/span&gt; LogEvent event, &lt;span&gt;final&lt;/span&gt; StringBuilder toAppendTo)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;       &lt;span&gt;// 获取 ThrowableProxy 对象，触发解析、加载异常堆栈类&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;final&lt;/span&gt; ThrowableProxy proxy = event.getThrownProxy();&lt;br/&gt;        &lt;span&gt;final&lt;/span&gt; Throwable throwable = event.getThrown();&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; ((throwable != &lt;span&gt;null&lt;/span&gt; || proxy != &lt;span&gt;null&lt;/span&gt;) &amp;amp;&amp;amp; options.anyLines()) {&lt;br/&gt;            &lt;span&gt;if&lt;/span&gt; (proxy == &lt;span&gt;null&lt;/span&gt;) {&lt;br/&gt;                &lt;span&gt;super&lt;/span&gt;.format(event, toAppendTo);&lt;br/&gt;                &lt;span&gt;return&lt;/span&gt;;&lt;br/&gt;            }&lt;br/&gt;            &lt;span&gt;final&lt;/span&gt; String extStackTrace = proxy.getExtendedStackTraceAsString(options.getIgnorePackages(),&lt;br/&gt;                    options.getTextRenderer(), getSuffix(event), options.getSeparator());&lt;br/&gt;            &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; len = toAppendTo.length();&lt;br/&gt;            &lt;span&gt;if&lt;/span&gt; (len &amp;gt; &lt;span&gt;0&lt;/span&gt; &amp;amp;&amp;amp; !Character.isWhitespace(toAppendTo.charAt(len - &lt;span&gt;1&lt;/span&gt;))) {&lt;br/&gt;                toAppendTo.append(&lt;span&gt;&#x27; &#x27;&lt;/span&gt;);&lt;br/&gt;            }&lt;br/&gt;            toAppendTo.append(extStackTrace);&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;}&lt;/span&gt;&lt;/section&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;5. 最佳实践&lt;/span&gt;&lt;/h2&gt;&lt;section&gt;&lt;span&gt;本章节主要结合项目在日志使用方面的一系列踩坑经历和实践经验，总结了一份关于日志配置的最佳实践，供大家参考。&lt;/span&gt;&lt;/section&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;建议日志配置文件中对所有Appender的PatternLayout都增加%ex配置，因为如果没有显式配置%ex，则异常格式化输出的默认配置是%xEx，此时会打印异常的扩展信息（&lt;/span&gt;&lt;span&gt;JAR名称和版本&lt;/span&gt;&lt;span&gt;），可能导致业务线程Block。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;不建议日志配置文件中使用AsyncAppender，建议自定义Appender实现，因为AsyncAppender是日志框架默认提供的，目前最新版本中仍然存在日志事件入队前就触发加载异常堆栈类的问题，可能导致业务线程Block。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;不建议生产环境使用ConsoleAppender，因为输出日志到Console时有synchronized同步操作，高并发场景下非常容易导致业务线程Block。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;不建议在配置文件中使用&amp;lt;AsyncLogger&amp;gt;标签，因为日志事件元素在入队前就会触发加载异常堆栈类，可能导致业务线程Block。如果希望使用Log4j2提供的异步日志AsyncLogger，建议配置Log4jContextSelector=org.apache.logging.log4j.core.async.AsyncLoggerContextSelector参数，开启异步日志。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;section&gt;&lt;span&gt;下面提供一份log4j2.xml配置示例：&lt;/span&gt;&lt;/section&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;section&gt;&lt;span&gt;&lt;span&gt;&amp;lt;&lt;span&gt;configuration&lt;/span&gt; &lt;span&gt;status&lt;/span&gt;=&lt;span&gt;&quot;warn&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&amp;lt;&lt;span&gt;appenders&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;&amp;lt;&lt;span&gt;Console&lt;/span&gt; &lt;span&gt;name&lt;/span&gt;=&lt;span&gt;&quot;Console&quot;&lt;/span&gt; &lt;span&gt;target&lt;/span&gt;=&lt;span&gt;&quot;SYSTEM_OUT&quot;&lt;/span&gt; &lt;span&gt;follow&lt;/span&gt;=&lt;span&gt;&quot;true&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;&amp;lt;&lt;span&gt;PatternLayout&lt;/span&gt; &lt;span&gt;pattern&lt;/span&gt;=&lt;span&gt;&quot;%d{yyyy/MM/dd HH:mm:ss.SSS} %t [%p] %c{1} (%F:%L) %msg%n %ex&quot;&lt;/span&gt; /&amp;gt;&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;&amp;lt;/&lt;span&gt;Console&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;        &lt;span&gt;&amp;lt;&lt;span&gt;XMDFile&lt;/span&gt; &lt;span&gt;name&lt;/span&gt;=&lt;span&gt;&quot;ShepherdLog&quot;&lt;/span&gt; &lt;span&gt;fileName&lt;/span&gt;=&lt;span&gt;&quot;shepherd.log&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;           &lt;span&gt;&amp;lt;&lt;span&gt;PatternLayout&lt;/span&gt; &lt;span&gt;pattern&lt;/span&gt;=&lt;span&gt;&quot;%d{yyyy/MM/dd HH:mm:ss.SSS} %t [%p] %c{1} (%F:%L) %msg%n %ex&quot;&lt;/span&gt; /&amp;gt;&lt;/span&gt;&lt;br/&gt;       &lt;span&gt;&amp;lt;/&lt;span&gt;XMDFile&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;        &lt;span&gt;&amp;lt;!--XMDFile异步磁盘日志配置示例--&amp;gt;&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;&amp;lt;!--默认按天&amp;amp;按512M文件大小切分日志，默认最多保留30个日志文件。--&amp;gt;&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;&amp;lt;!--注意：fileName前会自动增加文件路径，只配置文件名即可--&amp;gt;&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;&amp;lt;&lt;span&gt;XMDFile&lt;/span&gt; &lt;span&gt;name&lt;/span&gt;=&lt;span&gt;&quot;LocalServiceLog&quot;&lt;/span&gt; &lt;span&gt;fileName&lt;/span&gt;=&lt;span&gt;&quot;request.log&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;           &lt;span&gt;&amp;lt;&lt;span&gt;PatternLayout&lt;/span&gt; &lt;span&gt;pattern&lt;/span&gt;=&lt;span&gt;&quot;%d{yyyy/MM/dd HH:mm:ss.SSS} %t [%p] %c{1} (%F:%L) %msg%n %ex&quot;&lt;/span&gt; /&amp;gt;&lt;/span&gt;&lt;br/&gt;       &lt;span&gt;&amp;lt;/&lt;span&gt;XMDFile&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;     &lt;br/&gt;       &lt;span&gt;&amp;lt;!-- 使用自定义的AsyncScribeAppender代替原有的AsycncAppender --&amp;gt;&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;&amp;lt;&lt;span&gt;AsyncScribe&lt;/span&gt; &lt;span&gt;name&lt;/span&gt;=&lt;span&gt;&quot;LogCenterAsync&quot;&lt;/span&gt; &lt;span&gt;blocking&lt;/span&gt;=&lt;span&gt;&quot;false&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;&amp;lt;!-- 在指定日志名方面，scribeCategory 和 appkey 两者至少存在一种，且 scribeCategory 高于 appkey。--&amp;gt;&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;&amp;lt;!-- &amp;lt;Property name=&quot;scribeCategory&quot;&amp;gt;data_update_test_lc&amp;lt;/Property&amp;gt; --&amp;gt;&lt;/span&gt;&lt;br/&gt;           &lt;span&gt;&amp;lt;&lt;span&gt;LcLayout&lt;/span&gt;/&amp;gt;&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;&amp;lt;/&lt;span&gt;AsyncScribe&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&amp;lt;/&lt;span&gt;appenders&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&amp;lt;&lt;span&gt;loggers&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;&amp;lt;&lt;span&gt;logger&lt;/span&gt; &lt;span&gt;name&lt;/span&gt;=&lt;span&gt;&quot;com.sankuai.shepherd&quot;&lt;/span&gt; &lt;span&gt;level&lt;/span&gt;=&lt;span&gt;&quot;info&quot;&lt;/span&gt; &lt;span&gt;additivity&lt;/span&gt;=&lt;span&gt;&quot;false&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;&amp;lt;&lt;span&gt;AppenderRef&lt;/span&gt; &lt;span&gt;ref&lt;/span&gt;=&lt;span&gt;&quot;ShepherdLog&quot;&lt;/span&gt; &lt;span&gt;level&lt;/span&gt;=&lt;span&gt;&quot;warn&quot;&lt;/span&gt;/&amp;gt;&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;&amp;lt;&lt;span&gt;AppenderRef&lt;/span&gt; &lt;span&gt;ref&lt;/span&gt;=&lt;span&gt;&quot;LogCenterAsync&quot;&lt;/span&gt; &lt;span&gt;level&lt;/span&gt;=&lt;span&gt;&quot;info&quot;&lt;/span&gt;/&amp;gt;&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;&amp;lt;/&lt;span&gt;logger&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;        &lt;span&gt;&amp;lt;&lt;span&gt;root&lt;/span&gt; &lt;span&gt;level&lt;/span&gt;=&lt;span&gt;&quot;info&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;&amp;lt;!--Console日志是同步、阻塞的，推荐只在本地调试时使用，线上将该配置去掉--&amp;gt;&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;&amp;lt;!--appender-ref ref=&quot;Console&quot; /--&amp;gt;&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;&amp;lt;&lt;span&gt;appender-ref&lt;/span&gt; &lt;span&gt;ref&lt;/span&gt;=&lt;span&gt;&quot;LocalServiceLog&quot;&lt;/span&gt;/&amp;gt;&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;&amp;lt;&lt;span&gt;appender-ref&lt;/span&gt; &lt;span&gt;ref&lt;/span&gt;=&lt;span&gt;&quot;LogCenterAsync&quot;&lt;/span&gt;/&amp;gt;&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;&amp;lt;/&lt;span&gt;root&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&amp;lt;/&lt;span&gt;loggers&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&amp;lt;/&lt;span&gt;configuration&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/section&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;6. 作者简介&lt;/span&gt;&lt;/h2&gt;&lt;section&gt;&lt;span&gt;志洋、陈超、李敏、凯晖、殷琦等，均来自美团基础技术部-应用中间件团队。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;----------  END  ----------&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;招聘信息&lt;/span&gt;&lt;/strong&gt;&lt;/section&gt;&lt;section data-source=&quot;bj.96weixin.com&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;span&gt;美团基础技术部-基础架构团队诚招高级、资深技术专家，Base北京、上海。我们致力于建设美团全公司统一的高并发高性能分布式基础架构平台，涵盖数据库、分布式监控、服务治理、高性能通信、消息中间件、基础存储、容器化、集群调度等基础架构主要的技术领域。欢迎有兴趣的同学投送简历至：&lt;/span&gt;&lt;span&gt;edp.itu.zhaopin@meituan.com&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;也许你还想看&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;  | &lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MjM5NjQ5MTI5OA==&amp;amp;mid=2651770155&amp;amp;idx=1&amp;amp;sn=03437e5e67bb971f96cd698139c71fcf&amp;amp;chksm=bd1214668a659d7079bdcaabef696bcfd0f17add2f71303e7a7fce76997631eba2629e9a669c&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;可视化全链路日志追踪&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;/&gt;&lt;/strong&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MjM5NjQ5MTI5OA==&amp;amp;mid=2651770155&amp;amp;idx=1&amp;amp;sn=03437e5e67bb971f96cd698139c71fcf&amp;amp;chksm=bd1214668a659d7079bdcaabef696bcfd0f17add2f71303e7a7fce76997631eba2629e9a669c&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;可视化全链路日志追踪&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;可视化全链路日志追踪&lt;/a&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;  |&lt;/strong&gt;&lt;/span&gt; &lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MjM5NjQ5MTI5OA==&amp;amp;mid=2651764878&amp;amp;idx=1&amp;amp;sn=47d0a950bacdbd062e544251e4d2c4d5&amp;amp;chksm=bd1261c38a65e8d59395c62f565067c8c1dad2e71e9a864dd782b111a43234c24154799a9db5&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;如何优雅地记录操作日志？&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;如何优雅地记录操作日志？&lt;/a&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;  |&lt;/strong&gt; &lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MjM5NjQ5MTI5OA==&amp;amp;mid=2651751273&amp;amp;idx=1&amp;amp;sn=388f666fd1bce3413d8564662b120b71&amp;amp;chksm=bd125a248a65d332417c729d9e434157236a41c380fb5ca5b2b3efa7bf6e980273cc544757a9&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;美团开源Logan Web：前端日志在Web端的实现&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;前端日志在Web端的实现&lt;/a&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;阅读更多&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;---&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MjM5NjQ5MTI5OA==&amp;amp;mid=2651765958&amp;amp;idx=1&amp;amp;sn=8201546812e5a95a2bee9dffc6d12f00&amp;amp;chksm=bd12658b8a65ec9de2f5be1e96796dfb3c8f1a374d4b7bd91266072f557caf8118d4ddb72b07&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;前‍端&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; tab=&quot;outerlink&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;前端&lt;/span&gt;&lt;/a&gt;&lt;span&gt;&lt;strong&gt; |&lt;/strong&gt;&lt;/span&gt;&lt;a target=&quot;_blank&quot; href=&quot;https://t.1yb.co/jo7v&quot; textvalue=&quot; 安全&quot; tab=&quot;outerlink&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;&lt;strong&gt; &lt;/strong&gt; &lt;/span&gt;&lt;/a&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MjM5NjQ5MTI5OA==&amp;amp;mid=2651765981&amp;amp;idx=1&amp;amp;sn=c2dd86f15dee2cbbc89e27677d985060&amp;amp;chksm=bd1265908a65ec86d4d08f7600d1518b61c90f6453074f9b308c96861c045712280a73751c73&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;算‍法&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; tab=&quot;outerlink&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;算法&lt;/span&gt;&lt;/a&gt;&lt;span&gt;&lt;strong&gt; |&lt;/strong&gt; &lt;/span&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MjM5NjQ5MTI5OA==&amp;amp;mid=2651765982&amp;amp;idx=1&amp;amp;sn=231b41f653ac7959f3e3b8213dcec2b0&amp;amp;chksm=bd1265938a65ec85630c546169444d56377bc2f11401d251da7ca50e5d07e353aa01580c7216&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;后‍端&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; tab=&quot;outerlink&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;后端&lt;/span&gt;&lt;/a&gt;&lt;span&gt;&lt;strong&gt; | &lt;/strong&gt;&lt;/span&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MjM5NjQ5MTI5OA==&amp;amp;mid=2651765964&amp;amp;idx=1&amp;amp;sn=ab6d8db147234fe57f27dd46eec40fef&amp;amp;chksm=bd1265818a65ec9749246dd1a2eb3bf7798772cc4d5b4283b15eae2f80bc6db63a1471a9e61e&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;数‍据&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; tab=&quot;outerlink&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;数据&lt;/span&gt;&lt;/a&gt;&lt;/section&gt;&lt;section&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MjM5NjQ5MTI5OA==&amp;amp;mid=2651765965&amp;amp;idx=1&amp;amp;sn=37e0c56c8b080146ce5249243bfd84d8&amp;amp;chksm=bd1265808a65ec96d3a2b2c87c6e27c910d49cb6b149970fb2db8bf88045a0a85fed2e6a0b84&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;安‍全&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; tab=&quot;outerlink&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;安全&lt;/span&gt;&lt;/a&gt;&lt;span&gt;&lt;strong&gt; | &lt;/strong&gt;&lt;/span&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MjM5NjQ5MTI5OA==&amp;amp;mid=2651765972&amp;amp;idx=1&amp;amp;sn=afe02ec92762c1ce18740d03324c4ac3&amp;amp;chksm=bd1265998a65ec8f10d5f58d0f3681ddfc5325137218e568e1cda3a50e427749edb5c6a7dcf5&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;And‍roid&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; tab=&quot;outerlink&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;Android&lt;/span&gt;&lt;/a&gt;&lt;span&gt;&lt;strong&gt; |&lt;/strong&gt; &lt;/span&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MjM5NjQ5MTI5OA==&amp;amp;mid=2651765973&amp;amp;idx=1&amp;amp;sn=32a23bf1d278dda0398f993ab60a697e&amp;amp;chksm=bd1265988a65ec8e630ef4d24b4946ab6bd7e66702c1d712481cf3c471468a059c470a14c30d&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;iO‍S&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; tab=&quot;outerlink&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;iOS&lt;/span&gt;&lt;/a&gt;&lt;span&gt; &lt;strong&gt; |&lt;/strong&gt; &lt;/span&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MjM5NjQ5MTI5OA==&amp;amp;mid=2651765963&amp;amp;idx=1&amp;amp;sn=a3de9ef267d07d94118c1611776a4b28&amp;amp;chksm=bd1265868a65ec906592d25ad65f2a8516338d07ec3217059e6975fc131fc0107d66a8cd2612&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;运‍维&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; tab=&quot;outerlink&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;运维&lt;/span&gt;&lt;/a&gt;&lt;span&gt;&lt;strong&gt; | &lt;/strong&gt;&lt;/span&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MjM5NjQ5MTI5OA==&amp;amp;mid=2651765974&amp;amp;idx=1&amp;amp;sn=763c1e37d04acffd0142a2852ecfb000&amp;amp;chksm=bd12659b8a65ec8dfcfeb2028ef287fae7c38f134a665375ba420556ce5d2e4cf398147bd12e&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;测‍试&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; tab=&quot;outerlink&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;测试&lt;/span&gt;&lt;/a&gt;&lt;/section&gt;&lt;section class=&quot;mp_profile_iframe_wrp&quot;&gt;&lt;mpprofile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mpprofile&quot; data-id=&quot;MjM5NjQ5MTI5OA==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsVGibnsaEib3aNlqF0tOrA2RGEmNSbia2nnohE4Tpf95UyTiaSjDVbHRfY8WNBeTuLLTaVdSckkNyEx1Q/0?wx_fmt=png&quot; data-nickname=&quot;美团技术团队&quot; data-alias=&quot;meituantech&quot; data-signature=&quot;10000+工程师，如何支撑中国领先的生活服务电子商务平台？数亿消费者、数百万商户、2000多个行业、几千亿交易额背后是哪些技术在支撑？这里是美团、大众点评、美团外卖、美团配送、美团优选等技术团队的对外窗口。&quot; data-from=&quot;0&quot;/&gt;&lt;/section&gt;
          &lt;/div&gt;

          

          



           
                                
                    
        &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>b128a369165d86c178ac26d6b194174a</guid>
<title>阿里云官方 Redis 开发规范！</title>
<link>https://toutiao.io/k/2fqcbfi</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.6573208722741433&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/iaIdQfEric9TwDLiaiaWVWJILbpcFk8iaYKHEpKlmD7krfWCzRvtA8hP2HovZAxh4om2Ssz8UqFz9JS0bISLrNSD1YA/640?wx_fmt=png&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; data-type=&quot;png&quot; data-w=&quot;3210&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;span&gt;JavaGuide在线网站：javaguide.cn&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;来源：https://developer.aliyun.com/article/531067&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;昨晚在阿里云社区看到一份阿里云官方 Redis 开发规范，是一位阿里云数据库技术专家(Redis方向)写的，感觉有很多地方值得参考。我对原文排版和内容进行了简单完善，这里分享一下。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;一、键值设计&lt;/h2&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;1. key 名设计&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;(1)【建议】: 可读性和可管理性&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;以业务名(或数据库名)为前缀(防止 key 冲突)，用冒号分隔，比如业务名:表名:id&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;ugc:video:1&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;(2)【建议】：简洁性&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;保证语义的前提下，控制 key 的长度，当 key 较多时，内存占用也不容忽视，例如：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;user:{uid}:friends:messages:{mid}简化为u:{uid}:fr:m:{mid}。&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;(3)【强制】：不要包含特殊字符&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;反例：包含空格、换行、单双引号以及其他转义字符&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;详细解析：&lt;a href=&quot;https://mp.weixin.qq.com/s?spm=a2c6h.12873639.article-detail.7.753b1feeTX187Q&amp;amp;__biz=Mzg2NTEyNzE0OA==&amp;amp;mid=2247483663&amp;amp;idx=1&amp;amp;sn=7c4ad441eaec6f0ff38d1c6a097b1fa4&amp;amp;chksm=ce5f9e8cf928179a2c74227da95bec575bdebc682e8630b5b1bb2071c0a1b4be6f98d67c37ca&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;Redis 开发规范解析(一)--键名设计&lt;/a&gt; 。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;2. value 设计&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;(1)【强制】：拒绝 bigkey(防止网卡流量、慢查询)&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;string 类型控制在 10KB 以内，hash、list、set、zset 元素个数不要超过 5000。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;反例：一个包含 200 万个元素的 list。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;非字符串的 bigkey，不要使用 del 删除，使用 hscan、sscan、zscan 方式渐进式删除，同时要注意防止 bigkey 过期时间自动删除问题(例如一个 200 万的 zset 设置 1 小时过期，会触发 del 操作，造成阻塞，而且该操作不会不出现在慢查询中(latency 可查))，&lt;span&gt;查找方法&lt;/span&gt;&lt;sup&gt;[1]&lt;/sup&gt;和&lt;span&gt;删除方法&lt;/span&gt;&lt;sup&gt;[2]&lt;/sup&gt; 。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;详细解析：&lt;a href=&quot;https://mp.weixin.qq.com/s?spm=a2c6h.12873639.article-detail.10.753b1feeTX187Q&amp;amp;__biz=Mzg2NTEyNzE0OA==&amp;amp;mid=2247483677&amp;amp;idx=1&amp;amp;sn=5c320b46f0e06ce9369a29909d62b401&amp;amp;chksm=ce5f9e9ef928178834021b6f9b939550ac400abae5c31e1933bafca2f16b23d028cc51813aec&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;Redis 开发规范解析(二)--老生常谈 bigkey&lt;/a&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;(2)【推荐】：选择适合的数据类型。&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;例如：实体类型(要合理控制和使用数据结构内存编码优化配置,例如 ziplist，但也要注意节省内存和性能之间的平衡)&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;反例：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;set&lt;/span&gt; user:1:name tom&lt;br/&gt;&lt;span&gt;set&lt;/span&gt; user:1:age 19&lt;br/&gt;&lt;span&gt;set&lt;/span&gt; user:1:favor football&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;正例:&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;hmset user:1 name tom age 19 favor football&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;3.【推荐】：控制 key 的生命周期，redis 不是垃圾桶。&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;建议使用 expire 设置过期时间(条件允许可以打散过期时间，防止集中过期)，不过期的数据重点关注 idletime。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=Mzg2OTA0Njk0OA==&amp;amp;mid=2247525881&amp;amp;idx=1&amp;amp;sn=33d4565668cff95f5ee239c6e1d660fe&amp;amp;chksm=cea12a32f9d6a324432c964bf536181f2d55ee50afba9a53d9b09fa0e1a7126a03bb1dde4c60&amp;amp;token=698289097&amp;amp;lang=zh_CN&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;《Java 面试指北》&lt;/a&gt;来啦！这是一份教你如何更高效地准备面试的小册，涵盖常见八股文（系统设计、常见框架、分布式、高并发 ......）、优质面经等内容。&lt;/p&gt;&lt;/blockquote&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;二、命令使用&lt;/h2&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;1.【推荐】 O(N)命令关注 N 的数量&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;例如 hgetall、lrange、smembers、zrange、sinter 等并非不能使用，但是需要明确 N 的值。有遍历的需求可以使用 hscan、sscan、zscan 代替。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;2.【推荐】：禁用命令&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;禁止线上使用 keys、flushall、flushdb 等，通过 redis 的 rename 机制禁掉命令，或者使用 scan 的方式渐进式处理。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;3.【推荐】合理使用 select&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;redis 的多数据库较弱，使用数字进行区分，很多客户端支持较差，同时多业务用多数据库实际还是单线程处理，会有干扰。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;4.【推荐】使用批量操作提高效率&lt;span/&gt;&lt;/h3&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;原生命令：例如 mget、mset。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;非原生命令：可以使用 pipeline 提高效率。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但要注意控制一次批量操作的 &lt;strong&gt;元素个数&lt;/strong&gt;(例如 500 以内，实际也和元素字节数有关)。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;注意两者不同：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;原生是原子操作，pipeline 是非原子操作。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;pipeline 可以打包不同的命令，原生做不到&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;pipeline 需要客户端和服务端同时支持。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;5.【建议】Redis 事务功能较弱，不建议过多使用&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Redis 的事务功能较弱(不支持回滚)，而且集群版本(自研和官方)要求一次事务操作的 key 必须在一个 slot 上(可以使用 hashtag 功能解决)&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;6.【建议】Redis 集群版本在使用 Lua 上有特殊要求：&lt;span/&gt;&lt;/h3&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;所有 key 都应该由 KEYS 数组来传递，redis.call/pcall 里面调用的 redis 命令，key 的位置，必须是 KEYS array, 否则直接返回 error，&quot;-ERR bad lua script for redis cluster, all the keys that the script uses should be passed using the KEYS array&quot;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;所有 key，必须在 1 个 slot 上，否则直接返回 error, &quot;-ERR eval/evalsha command keys must in same slot&quot;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;7.【建议】必要情况下使用 monitor 命令时，要注意不要长时间使用。&lt;span/&gt;&lt;/h3&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;三、客户端使用&lt;/h2&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;1.【推荐】避免多个应用使用一个 Redis 实例&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;正例：不相干的业务拆分，公共数据做服务化。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;2.【推荐】使用带有连接池的数据库&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;使用带有连接池的数据库，可以有效控制连接，同时提高效率，标准使用方式：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;执行命令如下：&lt;br/&gt;Jedis jedis = null;&lt;br/&gt;try {&lt;br/&gt;    jedis = jedisPool.getResource();&lt;br/&gt;    //具体的命令&lt;br/&gt;    jedis.executeCommand()&lt;br/&gt;} catch (Exception e) {&lt;br/&gt;    logger.error(&lt;span&gt;&quot;op key {} error: &quot;&lt;/span&gt; + e.getMessage(), key, e);&lt;br/&gt;} finally {&lt;br/&gt;    //注意这里不是关闭连接，在JedisPool模式下，Jedis会被归还给资源池。&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (jedis != null)&lt;br/&gt;        jedis.close();&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;下面是 JedisPool 优化方法的文章:&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;Jedis 常见异常汇总&lt;/span&gt;&lt;sup&gt;[3]&lt;/sup&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;JedisPool 资源池优化&lt;/span&gt;&lt;sup&gt;[4]&lt;/sup&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;3.【建议】高并发下建议客户端添加熔断功能(例如 netflix hystrix)&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在通过 Redis 客户端操作 Redis 中的数据时，我们会在其中加入熔断器的逻辑。比如，当节点处于熔断状态时，直接返回空值以及熔断器三种状态之间的转换，具体的示例代码像下面这样：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这样，当某一个 Redis 节点出现问题，Redis 客户端中的熔断器就会实时监测到，并且不再请求有问题的 Redis 节点，避免单个节点的故障导致整体系统的雪崩。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;4.【推荐】确保登录安全&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;设置合理的密码，如有必要可以使用 SSL 加密访问（阿里云 Redis 支持）&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;5.【建议】选择合适的内存淘汰策略&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;根据自身业务类型，选好 maxmemory-policy(最大内存淘汰策略)，设置好过期时间。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;默认策略是 volatile-lru，即超过最大内存后，在过期键中使用 lru 算法进行 key 的剔除，保证不过期数据不被删除，但是可能会出现 OOM 问题。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;其他策略如下&lt;/strong&gt; ：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;allkeys-lru：根据 LRU 算法删除键，不管数据有没有设置超时属性，直到腾出足够空间为止。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;allkeys-random：随机删除所有键，直到腾出足够空间为止。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;volatile-random:随机删除过期键，直到腾出足够空间为止。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;volatile-ttl：根据键值对象的 ttl 属性，删除最近将要过期数据。如果没有，回退到 noeviction 策略。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;noeviction：不会剔除任何数据，拒绝所有写入操作并返回客户端错误信息&quot;(error) OOM command not allowed when used memory&quot;，此时 Redis 只响应读操作。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=Mzg2OTA0Njk0OA==&amp;amp;mid=2247525881&amp;amp;idx=1&amp;amp;sn=33d4565668cff95f5ee239c6e1d660fe&amp;amp;chksm=cea12a32f9d6a324432c964bf536181f2d55ee50afba9a53d9b09fa0e1a7126a03bb1dde4c60&amp;amp;token=698289097&amp;amp;lang=zh_CN&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;《Java 面试指北》&lt;/a&gt;来啦！这是一份教你如何更高效地准备面试的小册，涵盖常见八股文（系统设计、常见框架、分布式、高并发 ......）、优质面经等内容。&lt;/p&gt;&lt;/blockquote&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;四、相关工具&lt;/h2&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;1.【推荐】：数据同步&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;redis 间数据同步可以使用：redis-port&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;2.【推荐】：big key 搜索&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=Mzg2OTA0Njk0OA==&amp;amp;mid=2247499195&amp;amp;idx=2&amp;amp;sn=13fe477aac7cbb8cd03d91511ea98ba0&amp;amp;chksm=cea1b270f9d63b667b72c142321dfccdb64deb11f4fd082e1cfedf7d45768e125a9db7fa6918&amp;amp;token=973133388&amp;amp;lang=zh_CN&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;Redis 为什么变慢了？一文讲透如何排查 Redis 性能问题 | 万字长文&lt;/a&gt;&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;3.【推荐】：热点 key 寻找&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;京东开源的 &lt;span&gt;hotkey&lt;/span&gt;&lt;sup&gt;[5]&lt;/sup&gt; 支持毫秒级探测热点数据，毫秒级推送至服务器集群内存，大幅降低热 key 对数据层查询压力。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;五 附录：删除 bigkey&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;下面操作可以使用 pipeline 加速。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;redis 4.0 已经支持 key 的异步删除，欢迎使用。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;1. Hash 删除: hscan + hdel&lt;span/&gt;&lt;/h3&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;delBigHash&lt;/span&gt;&lt;span&gt;(String host, &lt;span&gt;int&lt;/span&gt; port, String password, String bigHashKey)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    Jedis jedis = &lt;span&gt;new&lt;/span&gt; Jedis(host, port);&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (password != &lt;span&gt;null&lt;/span&gt; &amp;amp;&amp;amp; !&lt;span&gt;&quot;&quot;&lt;/span&gt;.equals(password)) {&lt;br/&gt;        jedis.auth(password);&lt;br/&gt;    }&lt;br/&gt;    ScanParams scanParams = &lt;span&gt;new&lt;/span&gt; ScanParams().count(&lt;span&gt;100&lt;/span&gt;);&lt;br/&gt;    String cursor = &lt;span&gt;&quot;0&quot;&lt;/span&gt;;&lt;br/&gt;    &lt;span&gt;do&lt;/span&gt; {&lt;br/&gt;        ScanResult&amp;lt;Entry&amp;lt;String, String&amp;gt;&amp;gt; scanResult = jedis.hscan(bigHashKey, cursor, scanParams);&lt;br/&gt;        List&amp;lt;Entry&amp;lt;String, String&amp;gt;&amp;gt; entryList = scanResult.getResult();&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (entryList != &lt;span&gt;null&lt;/span&gt; &amp;amp;&amp;amp; !entryList.isEmpty()) {&lt;br/&gt;            &lt;span&gt;for&lt;/span&gt; (Entry&amp;lt;String, String&amp;gt; entry : entryList) {&lt;br/&gt;                jedis.hdel(bigHashKey, entry.getKey());&lt;br/&gt;            }&lt;br/&gt;        }&lt;br/&gt;        cursor = scanResult.getStringCursor();&lt;br/&gt;    } &lt;span&gt;while&lt;/span&gt; (!&lt;span&gt;&quot;0&quot;&lt;/span&gt;.equals(cursor));&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;//删除bigkey&lt;/span&gt;&lt;br/&gt;    jedis.del(bigHashKey);&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;2. List 删除: ltrim&lt;span/&gt;&lt;/h3&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;delBigList&lt;/span&gt;&lt;span&gt;(String host, &lt;span&gt;int&lt;/span&gt; port, String password, String bigListKey)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    Jedis jedis = &lt;span&gt;new&lt;/span&gt; Jedis(host, port);&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (password != &lt;span&gt;null&lt;/span&gt; &amp;amp;&amp;amp; !&lt;span&gt;&quot;&quot;&lt;/span&gt;.equals(password)) {&lt;br/&gt;        jedis.auth(password);&lt;br/&gt;    }&lt;br/&gt;    &lt;span&gt;long&lt;/span&gt; llen = jedis.llen(bigListKey);&lt;br/&gt;    &lt;span&gt;int&lt;/span&gt; counter = &lt;span&gt;0&lt;/span&gt;;&lt;br/&gt;    &lt;span&gt;int&lt;/span&gt; left = &lt;span&gt;100&lt;/span&gt;;&lt;br/&gt;    &lt;span&gt;while&lt;/span&gt; (counter &amp;lt; llen) {&lt;br/&gt;        &lt;span&gt;//每次从左侧截掉100个&lt;/span&gt;&lt;br/&gt;        jedis.ltrim(bigListKey, left, llen);&lt;br/&gt;        counter += left;&lt;br/&gt;    }&lt;br/&gt;    &lt;span&gt;//最终删除key&lt;/span&gt;&lt;br/&gt;    jedis.del(bigListKey);&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;3. Set 删除: sscan + srem&lt;span/&gt;&lt;/h3&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;public void delBigSet(String host, int port, String password, String bigSetKey) {&lt;br/&gt;    Jedis jedis = new Jedis(host, port);&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (password != null &amp;amp;&amp;amp; !&lt;span&gt;&quot;&quot;&lt;/span&gt;.equals(password)) {&lt;br/&gt;        jedis.auth(password);&lt;br/&gt;    }&lt;br/&gt;    ScanParams scanParams = new ScanParams().count(100);&lt;br/&gt;    String cursor = &lt;span&gt;&quot;0&quot;&lt;/span&gt;;&lt;br/&gt;    &lt;span&gt;do&lt;/span&gt; {&lt;br/&gt;        ScanResult&amp;lt;String&amp;gt; scanResult = jedis.sscan(bigSetKey, cursor, scanParams);&lt;br/&gt;        List&amp;lt;String&amp;gt; memberList = scanResult.getResult();&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (memberList != null &amp;amp;&amp;amp; !memberList.isEmpty()) {&lt;br/&gt;            &lt;span&gt;for&lt;/span&gt; (String member : memberList) {&lt;br/&gt;                jedis.srem(bigSetKey, member);&lt;br/&gt;            }&lt;br/&gt;        }&lt;br/&gt;        cursor = scanResult.getStringCursor();&lt;br/&gt;    } &lt;span&gt;while&lt;/span&gt; (!&lt;span&gt;&quot;0&quot;&lt;/span&gt;.equals(cursor));&lt;br/&gt;&lt;br/&gt;    //删除bigkey&lt;br/&gt;    jedis.del(bigSetKey);&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;4. SortedSet 删除: zscan + zrem&lt;span/&gt;&lt;/h3&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;delBigZset&lt;/span&gt;&lt;span&gt;(String host, &lt;span&gt;int&lt;/span&gt; port, String password, String bigZsetKey)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    Jedis jedis = &lt;span&gt;new&lt;/span&gt; Jedis(host, port);&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (password != &lt;span&gt;null&lt;/span&gt; &amp;amp;&amp;amp; !&lt;span&gt;&quot;&quot;&lt;/span&gt;.equals(password)) {&lt;br/&gt;        jedis.auth(password);&lt;br/&gt;    }&lt;br/&gt;    ScanParams scanParams = &lt;span&gt;new&lt;/span&gt; ScanParams().count(&lt;span&gt;100&lt;/span&gt;);&lt;br/&gt;    String cursor = &lt;span&gt;&quot;0&quot;&lt;/span&gt;;&lt;br/&gt;    &lt;span&gt;do&lt;/span&gt; {&lt;br/&gt;        ScanResult&amp;lt;Tuple&amp;gt; scanResult = jedis.zscan(bigZsetKey, cursor, scanParams);&lt;br/&gt;        List&amp;lt;Tuple&amp;gt; tupleList = scanResult.getResult();&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (tupleList != &lt;span&gt;null&lt;/span&gt; &amp;amp;&amp;amp; !tupleList.isEmpty()) {&lt;br/&gt;            &lt;span&gt;for&lt;/span&gt; (Tuple tuple : tupleList) {&lt;br/&gt;                jedis.zrem(bigZsetKey, tuple.getElement());&lt;br/&gt;            }&lt;br/&gt;        }&lt;br/&gt;        cursor = scanResult.getStringCursor();&lt;br/&gt;    } &lt;span&gt;while&lt;/span&gt; (!&lt;span&gt;&quot;0&quot;&lt;/span&gt;.equals(cursor));&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;//删除bigkey&lt;/span&gt;&lt;br/&gt;    jedis.del(bigZsetKey);&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;参考资料&lt;/span&gt;&lt;/h3&gt;&lt;section data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;span&gt;[1]&lt;/span&gt;&lt;p&gt;查找方法: &lt;em&gt;https://developer.aliyun.com/article/531067#cc1&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[2]&lt;/span&gt;&lt;p&gt;删除方法: &lt;em&gt;https://developer.aliyun.com/article/531067#cc2&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[3]&lt;/span&gt;&lt;p&gt;Jedis 常见异常汇总: &lt;em&gt;https://yq.aliyun.com/articles/236384?spm=a2c6h.12873639.article-detail.11.753b1feeTX187Q&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[4]&lt;/span&gt;&lt;p&gt;JedisPool 资源池优化: &lt;em&gt;https://yq.aliyun.com/articles/236383?spm=a2c6h.12873639.article-detail.12.753b1feeTX187Q&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[5]&lt;/span&gt;&lt;p&gt;hotkey: &lt;em&gt;https://gitee.com/jd-platform-opensource/hotkey&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;/section&gt;&lt;section data-tool=&quot;mdnice编辑器&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>961fb0f6736a16e6175368bd320e40d4</guid>
<title>为什么游戏行业喜欢用PolarDB</title>
<link>https://toutiao.io/k/ligtpt2</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content                                       &quot; id=&quot;js_content&quot;&gt;
            &lt;h3&gt;&lt;strong&gt;游戏行业痛点&lt;/strong&gt;&lt;br/&gt;&lt;/h3&gt;&lt;p&gt;在笔者看来, 不同行业对数据库使用有巨大的差别. 比如游戏行业没有复杂的事务交易场景, 他有一个非常大的blob 字段用于存储角色的装备信息, 那么大Blob 字段的更新就会成为数据库的瓶颈, 比如在线教育行业需要有抢课的需求, 因此会有热点行更新的场景, 对热点行如何处理会成为数据库的瓶颈, 比如SaaS 行业, 每一个客户有一个Database, 因此会有非常多的Table, 那么数据库就需要对多表有很好的支持能力.&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;游戏行业和其他行业对数据库的使用要求是不一样的.&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;所以在支撑了大量游戏业务之后, 我理解游戏行业在使用自建MySQL 的时候有3个比较大的痛点&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;ol class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;1.对备份恢复的需求&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;2.对写入性能的要求&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;3.对跨region 容灾的需求&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;接下来会分别讲述这三个痛点PolarDB 是如何解决的.&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;备份恢复&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;笔者和大量游戏开发者沟通中, 游戏行业对备份恢复的需求是极其强烈的. 比如在电商行业, 是不可能存在将整个数据库实例进行回滚到一天之前的数据, 这样所有的用户的购买交易信息都丢失了.&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;但是, 在游戏行业中, 这种场景确实存在的, 比如在发版的时候, 游戏行业是有可能发版失败, 这个在其他行业出现概率非常低, 如果发版失败, 那么整个实例就需要回滚到版本之前. 因此每次发版的时候都需要对数据库实例进行备份. 因此当我们玩游戏的时候, 看到大版本需要停服更新, 那么就有可能是因为后台需要备份数据等等一系列操作了.&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;还有一种场景, 当发生因为外挂, 漏洞, 参数配置错误等等场景下, 这种紧急情况游戏就需要回滚到出问题前的版本, 这样就需要对整个实例进行回滚.&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;1.103030303030303&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/y7l9KJ42n2yyhy0EzXVHEGPK6GK15YvdyeOshdBrFwDBDdNDAlSWs4MsJ94utu9oIoP4YB0tIb2FA4k9mMfrjg/640?wx_fmt=png&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; data-type=&quot;png&quot; data-w=&quot;990&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;官方MySQL 由于是单机架构, 那么常见的备份方法是通过Xtrabackup 工具, 将数据备份到本地以后, 如果本地空间不够, 就需要上传到OSS 等远端存储中. 通常通过Xtrabackup 备份工具都需要1h 左右, 如果需要将数据上传到远端那么时间就更长了.&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;PolarDB 是天然的计存分离的架构, 那么备份的时候通过底下分布式存储的快照能力, 备份可以不超过30s, 将备份时间大大缩短了.&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;核心思路是采用Redirect-on-Write 机制, 每次创建快照并没有真正Copy数据, 只有建立快照索引, 当数据块后期有修改(Write)时才把历史版本保留给Snapshot, 然后生成新的数据块, 被原数据引用(Redirect).&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;另外一种场景是, 在游戏行业中, 有可能某一个玩家的装备被盗号了, 那么玩家就会找游戏的运营人员投诉, 运营人员会找到游戏运维人员, 帮忙查询玩家的历史数据.&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;笔者之前就遇到某著名游戏多个玩家被盗号, 然后运维人员经常需要通过PolarDB 按时间的还原的能力恢复出某多个不同时间点的实例, 用来查询这个玩家的具体装备信息, 同时由于玩家对盗号的时间也不准确, 经常有时候需要还原出多个实例才可以.&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;针对这样的场景, PolarDB 推出了Flashback Query, 就可以在当前实例查询出任意时间点的历史数据. 具体原理见文章 Flashback Query&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.3859964093357271&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/y7l9KJ42n2yyhy0EzXVHEGPK6GK15Yvdru5WTGZPF1Cco4LFks5Ag4N86ZBP1ibicnxYl2E1Xgf4g4G7TGbX3jow/640?wx_fmt=png&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; data-type=&quot;png&quot; data-w=&quot;1114&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;整体而言, PolarDB 建立了一套非常完善的备份恢复能力, 从库=&amp;gt;表=&amp;gt;行三个维度满足的游戏行业对备份恢复的需求.&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.5993485342019544&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/y7l9KJ42n2yyhy0EzXVHEGPK6GK15YvdmM5r2ibK5ibTplyhgrYodcpjJ6icsZiaMqoEp8xMOSaOQM337tImg2gUHg/640?wx_fmt=png&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; data-type=&quot;png&quot; data-w=&quot;1228&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;写入性能&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;游戏行业使用数据库的方式也与其他行业有较大区别, 是一种非常弱Schema 的使用方式, 其他行业通常对业务经常抽象, 建立表结构, 每个字段尽可能小, 不建议有大字段, 有大字段尽可能进行拆封等等.&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;但是在游戏行业中, 由于需要满足游戏快速迭代发展的需求, 玩家的装备信息结构非常复杂, 因此常见的做法是将玩家装备等级信息保存在一个大的blob字段中, 这个blob字段通过proto_buf 或者 json 进行编解码, 每次在获得装备或者升级以后, 就进行整个字段更新,  在游戏开服初期玩家数据长度较短, 而随着游戏版本更新版本, 游戏剧情, 运营活动的增多, 相对于游戏开服初期的数KB, blob字段的长度可能会膨胀到数百KB, 甚至达到MB级别, 因此可能只是获得一个装备, 就需要向数据库写入数百KB 大小的数据, 这样的写放大其实非常不合理.&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;目前也有像MongoDB 这样的文档数据库, 让用户写入的时候仅仅更新某个字段, 从而减少写放大. 但是这样影响了用户的使用习惯, 需要用户在业务逻辑上进行修改, 这是快速发展的游戏行业所不能接受的, 所以笔者看到尽管有客户因为写入问题转向了MongoDB, 但是其实不多.&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;PolarDB 针对这样的情况尽可能满足用户的使用习惯, 在数据库内核层面优化数据库的写入能力. 通过 partition redo log, redo log cache, undo log readahead,  early lock release, no blob latch 等等能力将写入能力充分优化. 具体原理可以参考我们内核月报 和之前的文章PolarDB-cloudjump 针对游戏场景, 我们修改了 sysbench 工具, 模拟游戏行业中大Blob 更新的workload, 放在 game-sysbench 工具中, 后续我们还会将更多行业比如Saas, 电商等等行业的workload 放在这个工具中.&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;在game_blob_update workload 中, 如果玩家的平均装备信息是 300kb, 我们对比了PolarDB VS aurora VS 自建MySQL 的数据&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;PolarDB 8.0 相对有最高的QPS 1877.44, 峰值QPS最高可以到2000, CPU bound场景PolarDB的性能大概是Aurora的5.7倍, 是自建 MySQL 本地盘的3倍. IO bound场景PolarDB的性能是Aurora的15倍.&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;CPU bound场景：&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;DB&lt;/th&gt;&lt;th&gt;并发数据&lt;/th&gt;&lt;th&gt;QPS&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;PolarDB 8.0&lt;/td&gt;&lt;td&gt;5&lt;/td&gt;&lt;td&gt;1877.44&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;MySQL 8.0 本地盘&lt;/td&gt;&lt;td&gt;4&lt;/td&gt;&lt;td&gt;600.22&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;Aurora 8.0&lt;/td&gt;&lt;td&gt;200&lt;/td&gt;&lt;td&gt;328.47&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;IO bound场景：&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;DB&lt;/th&gt;&lt;th&gt;并发数据&lt;/th&gt;&lt;th&gt;QPS&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;PolarDB 8.0&lt;/td&gt;&lt;td&gt;200&lt;/td&gt;&lt;td&gt;1035.30&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;MySQL 8.0 本地盘&lt;/td&gt;&lt;td&gt;200&lt;/td&gt;&lt;td&gt;610&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;Aurora 8.0&lt;/td&gt;&lt;td&gt;200&lt;/td&gt;&lt;td&gt;69.15&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;跨region 容灾&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;目前游戏行业纷纷出海, 包含了游戏服和平台服. 用户在自建MySQL/RDS 的场景中,  用户可能需要在另外一个region 建立一个新的实例, 然后通过同步工具或者DTS 进行跨region 备份. 用户需要处理region 错误场景如何进行切换等等.&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;笔者认为对数据库而言, 稳定性 &amp;gt; 易用性 &amp;gt; 性能.&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;在这个场景中, 用户如果使用云厂商的话, 使用的是云厂商提供的原子能力, 自己通过组装这些原子能力实现容灾的需求, 而PolarDB 针对这样场景提出来PolarDB GlobalDataba 的解决方案, 将跨region 的容灾放在解决方案中, 提供了一个更加易容的解决方案, 从而用户可以关注自身的业务逻辑, 而不需要处理这些容灾的场景.&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;在具体跨region 的同步场景方案中, PolarDB 是通过多通道物理复制能力, 从而保证跨region 的容灾在1s 以内.&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;Links:&lt;/p&gt;&lt;p&gt;game-sysbench: https://github.com/baotiao/game-sysbench&lt;/p&gt;&lt;p&gt;PolarDB-cloudjump: https://zhuanlan.zhihu.com/p/535426034&lt;/p&gt;&lt;p&gt;Flashback-Query: https://zhuanlan.zhihu.com/p/434466612&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;参考阅读：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;span&gt;本文由高可用架构转载。技术原创及架构实践文章，欢迎通过公众号菜单「联系我们」进行投稿。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;‍&lt;/span&gt;&lt;/p&gt;&lt;section class=&quot;mp_profile_iframe_wrp&quot;&gt;&lt;mpprofile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mpprofile&quot; data-id=&quot;MzAwMDU1MTE1OQ==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/8XkvNnTiapONl06YmHad4csRU93kcbJ76JIWzEAmOSVooibFHHkzfWzzkc7dpU4H06Wp9F6Z687vIghdawxvl47A/0?wx_fmt=png&quot; data-nickname=&quot;高可用架构&quot; data-alias=&quot;ArchNotes&quot; data-signature=&quot;高可用架构公众号。&quot; data-from=&quot;0&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;‍&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;‍&lt;/span&gt;&lt;/p&gt;
          &lt;/div&gt;

          

          



           
                                
                    
        &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>e41226234125f97244c368afa2f04c56</guid>
<title>关于HTTP协议那些事</title>
<link>https://toutiao.io/k/xvdtkbe</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;作者简介&lt;span/&gt;&lt;/h5&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;张倩：爱生活，爱美食，立志成为一枚安静优雅小吃货&lt;/p&gt;&lt;/blockquote&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;span&gt;1&lt;/span&gt;&lt;/span&gt;&lt;span&gt;前言&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;说到http协议，相信大家也都不陌生。毕竟是跟工作息息相关的，想着好好深入一下，正好看到了罗老师的《透视HTTP协议》，也算是说透了揉碎了，讲的明明白白。下面就里面的内容做了这篇学习总结&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1.2195121951219512&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/l7qvliaicFcd6SypgIYmFXotucODES1wmA0xs3aNMDscdicB7ayZGCNcZjFE5oeoIxoCwtSIeqM7PnayCZxhynI8g/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1640&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;开始之前先抛出几个问题：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;是什么在促进HTTP的发展？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;post请求是什么样的？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;缓存在浏览器network中的体现？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;HTTP的大文件传输？一切都在发展，想想更好的方案&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;HTTP协议跟TCP/IP协议栈的关系&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;下面就开始唠了～～～&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;span&gt;2&lt;/span&gt;&lt;/span&gt;&lt;span&gt;HTTP 发展史&lt;/span&gt;&lt;/h2&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5078468298807282&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/l7qvliaicFcd6SypgIYmFXotucODES1wmAQewOXxcPLPoUxYMmzPxZveVUrFhGSfBcJicBzQsqrZ0BSsRw0AnlMZg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1593&quot;/&gt;&lt;figcaption&gt;http发展史&lt;/figcaption&gt;&lt;/figure&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;HTTP 的发展历程&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;HTTP/0.9（90年代初）&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;受限于当时的大环境，只支持get的纯文本传输，后定义为HTTP/0.9 --- 是小范围的试炼&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;HTTP/1.0(93年)&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;得益于jpeg及mp3等数据格式的问世，用户期待图文并茂的网页 --- 小有成就&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;增加了 HEAD、POST 等新方法；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;增加了响应状态码，标记可能的错误原因；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;引入了协议版本号概念；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;引入了 HTTP Header（头部）的概念，让 HTTP 处理请求和响应更加灵活；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;传输的数据不再仅限于文本。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;HTTP/1.1（99年）&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;经历了第一次浏览器大战的HTTP/1.0扛住压力，推动了http的进一步完善。--- 破茧成蝶，正式成为标准（RFC 2616）&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;增加了 PUT、DELETE 等新的方法；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;增加了缓存管理和控制；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;明确了连接管理，允许持久连接；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;允许响应数据分块（chunked），利于传输大文件；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;强制要求 Host 头，让互联网主机托管成为可能。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;不过由于 HTTP/1.1 太过庞大和复杂，所以在 2014 年又做了一次修订，原来的一个大文档被拆分成了六份较小的文档，编号为 7230-7235，优化了一些细节，但此外没有任何实质性的改动。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;更上一层楼，HTTP/2（2015年）&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;“挟用户以号令天下”，Google 借此顺势把 SPDY 推上了标准的宝座，互联网标准化组织以 SPDY 为基础开始制定新版本的 HTTP 协议，最终在 2015 年发布了 HTTP/2，RFC 编号 7540。&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;二进制协议，不再是纯文本；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;可发起多个请求，废弃了 1.1 里的管道；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;使用专用算法压缩头部，减少数据传输量；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;允许服务器主动向客户端推送数据；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;增强了安全性，“事实上”要求加密通信。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;追求极致，HTTP/3&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这一次还是Google，而且它要“革自己的命”。2018 年，互联网标准化组织 IETF 提议将“HTTP over QUIC”更名为“HTTP/3”并获得批准，HTTP/3 正式进入了标准化制订阶段。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;结合发展史的总结&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;从无到有&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;从简单到复杂&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;从实现到不断的优化扩展&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;从无人知晓到无人不晓&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;追求安全、高速、便捷的传输&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;综上，大家可以思考下第一个问题了，你觉得呢?
有兴趣的可以去看参考资料里的协议详解。&lt;/p&gt;&lt;/blockquote&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;span&gt;3&lt;/span&gt;&lt;/span&gt;&lt;span&gt;HTTP 的报文&lt;/span&gt;&lt;/h2&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;客户端&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.3997050147492625&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/l7qvliaicFcd6SypgIYmFXotucODES1wmAQWlwiaefJOsae4oqSWHGicIOnZE43y9SGaMdyUiaSdHzUvpHL37ibG0lbw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1356&quot;/&gt;&lt;figcaption&gt;请求行 GET / HTTP/1.1&lt;/figcaption&gt;&lt;/figure&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;服务端&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.42668621700879766&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/l7qvliaicFcd6SypgIYmFXotucODES1wmA8LBUNCibDXicb4cMQXlo5u2RPxqnNp00MaQXELVblUuZk2w2shZXe9dg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1364&quot;/&gt;&lt;figcaption&gt;状态行 HTTP/1.1 200 OK&lt;/figcaption&gt;&lt;/figure&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;关于头字段&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;HTTP 协议规定了非常多的头部字段，实现各种各样的功能，但基本上可以分为四大类：&lt;/p&gt;&lt;/blockquote&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;通用字段：在请求头和响应头里都可以出现；Date Cache-Control， Connection，Date，Pragma，Transfer-Encoding，Upgrade&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;请求字段：仅能出现在请求头里，进一步说明请求信息或者额外的附加条件；Host，User-Agent,Referer Accept Accept-Charset Accept-Encoding Accept-Language, Authorization,Expect,From,If-Match,If-Modified-Since,If-None-Match,If-Range,If-Unmodified-Since,Max-Forwards, Range等&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;响应字段：仅能出现在响应头里，补充说明响应报文的信息；Accept-Ranges,Age，ETag，Location，Proxy-Authenticate，Retry-After，Server，Vary等&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;实体字段：它实际上属于通用字段，但专门描述 body 的额外信息。Content-Length，Allow，Content-Encoding，Content-Language， Content-Length，Content-Location，Content-MD5，Content-Range，Content-Type，Expires，Last-Modified&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;注意：1，请求头的限制：各个web服务器都不允许过大的请求头，因为头部太大可能会占用大量的服务器资源，影响运行效率。&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;apache2来说，它默认值是8k；Apache里，可按下面方式调整：LimitRequestLine 请求行的字节数
LimitRequestFields  请求头域的个数 默认值100
LimitRequestFieldSize 配置允许的请求头字节大小 默认值是8190
nginx默认的header长度上限是4k，也可根据情况配置，如下两种方式：client_header_buffer_size 16k;
large_client_header_buffers 4 16k;&lt;/p&gt;&lt;/blockquote&gt;&lt;/blockquote&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;2，如果header头信息请求超过了，nginx会直接返回400错误
3，关于头字段大小写，尽量首字母大写
4，字段名里不允许出现空格，可以使用连字符“-”，但不能使用下划线“_”  。否则响应 （400 Bad Request）&lt;/p&gt;&lt;/blockquote&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;综上，大家可以思考下第二个问题了，post请求是需要向服务端提交数据的，可要结合实体字段～
有兴趣的在跟后端联调时抓包看看吧&lt;/p&gt;&lt;/blockquote&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;span&gt;4&lt;/span&gt;&lt;/span&gt;&lt;span&gt;HTTP 的缓存机制&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;HTTP/1.0提供了Pragma及Expires的缓存字段，到HTTP/1.1扩展了更多头字段Cache-Control、Last-Modified / If-Modified-Since， Etag / If-None-Match等。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;为什么用缓存&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在传输中间有其他备份，不用每次都去服务器请求，链路更短响应更迅速。也就是：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;减少了冗余的数据传输，节省了网费。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;缓解了服务器的压力， 大大提高了网站的性能&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;加快了客户端加载网页的速度&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;怎么缓存的&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;http缓存都是从第二次请求开始的。第一次请求资源时，服务器返回资源，并在respone header头中回传资源的缓存参数；第二次请求时，浏览器判断这些请求参数，命中强缓存就直接200，否则就把请求参数加到request header头中传给服务器，看是否命中协商缓存，命中则返回304，否则服务器会返回新的资源。&lt;/p&gt;&lt;/blockquote&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;从网上抓了张图，如下：&lt;/p&gt;&lt;/blockquote&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1.1015873015873017&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/l7qvliaicFcd6SypgIYmFXotucODES1wmAb3ZuKqjCf1V87Eico0wyWRlw8nQQaKX9KtZEefm9aCia9d9pXI0WKBaA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1260&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;另一张图，不信你还不懂&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6037514654161782&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/l7qvliaicFcd6SypgIYmFXotucODES1wmACd7iajRPJUkeH2PuQyyFuboWj6ICCNsy6Gs8tSzsrjLb0XyPDw3RlBA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1706&quot;/&gt;&lt;/figure&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;强缓存与协商缓存&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.432520325203252&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/l7qvliaicFcd6SypgIYmFXotucODES1wmAibiaEc6cxJ3PBkUxKicJ7u1jWg58D8MTTEQlholleRHsYlUOr6yFjV3aA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1230&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;chrome浏览器：&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;200 from memory cache 不访问服务器，直接读缓存，从内存中读取缓存。此时的数据是缓存到内存中的，当kill进程后，数据将不存在
200 from disk cache 不访问服务器，直接读缓存，从磁盘中读取缓存，当kill进程时，数据还是存在。304 Not Modified 访问服务器，发现数据没有更新，服务器返回此状态码。然后从缓存中读取数据。&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;命中强制缓存时，资源会显示from memory cache or from disk cache&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;缓存相关的头字段&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;通用首部字段&lt;span/&gt;&lt;/h4&gt;&lt;section data-tool=&quot;mdnice编辑器&quot;&gt;&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;字段名称&lt;/th&gt;&lt;th&gt;说明&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;Pragma&lt;/td&gt;&lt;td&gt;&quot;no-cache&quot;表示禁用缓存 (HTTP/1.0)已废弃&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;Cache-Control&lt;/td&gt;&lt;td&gt;no-store no-cache max-age等，请求响应的值页有区别&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/section&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;请求首部字段&lt;span/&gt;&lt;/h4&gt;&lt;section data-tool=&quot;mdnice编辑器&quot;&gt;&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;字段名称&lt;/th&gt;&lt;th&gt;说明&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;If-Modified-Since&lt;/td&gt;&lt;td&gt;比较资源最后的更新时间是否一致&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;If-Unmodified-Since&lt;/td&gt;&lt;td&gt;比较资源最后的更新时间是否不一致&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;If-Match&lt;/td&gt;&lt;td&gt;比较 ETag 是否一致&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;If-None-Match&lt;/td&gt;&lt;td&gt;比较 ETag 是否一致&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/section&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;响应首部字段&lt;span/&gt;&lt;/h4&gt;&lt;section data-tool=&quot;mdnice编辑器&quot;&gt;&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;字段名称&lt;/th&gt;&lt;th&gt;说明&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;ETag&lt;/td&gt;&lt;td&gt;资源的匹配信息（通过强比较算法生成值）&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/section&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;实体首部字段&lt;span/&gt;&lt;/h4&gt;&lt;section data-tool=&quot;mdnice编辑器&quot;&gt;&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;字段名称&lt;/th&gt;&lt;th&gt;说明&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;Expires&lt;/td&gt;&lt;td&gt;资源的过期时间(HTTP/1.0)，有弊端&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;Last-Modified&lt;/td&gt;&lt;td&gt;资源的最后一次修改时间&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/section&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;关于Cache-Control&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;网上找了张图，方便大家理解～&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.9100294985250738&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/l7qvliaicFcd6SypgIYmFXotucODES1wmAtsOx6TfzV2UU24t5ZuLBsJ21O1ANRiaOjhqQWgQb8dtzmTvLIl9nn8w/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1356&quot;/&gt;&lt;/figure&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;综上，大家工作的过程中也留意下chrome的network，结合思考下～&lt;/p&gt;&lt;/blockquote&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;span&gt;5&lt;/span&gt;&lt;/span&gt;&lt;span&gt;HTTP 的大文件传输&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如何在有限的带宽下快捷的传输大文件呢？更有效的节省内存、带宽等资源。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;数据压缩（把大文件整体变小）&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;客户端请求时带上Accept-Encoding（支持的压缩方式），响应时指定Content-Encoding（此响应的压缩方式），按此压缩后发给客户端。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;gzip 等压缩算法通常只对文本文件有较好的压缩率，而图片、音频视频等多媒体数据本身就已经是高度压缩的，效果不好。在 Nginx 里就会使用“gzip on”指令，启用对“text/html”的压缩。&lt;/p&gt;&lt;/blockquote&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;分块传输&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;如果大文件整体不能变小，那就把它“拆开”，分解成多个小块。&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;HTTP协议1.1版本提供了分开传输机制（Chunked transfer encoding）。也就是服务端的”化整为零“，即把大文件拆开，分成多个小块来传输。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;注意：HTTP/2 中已经不支持 chunked 这一格式了，因为其本身提供了更加高级的流机制来实现类似功能。&lt;/p&gt;&lt;/blockquote&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;Transfer-Encoding&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个响应头有下面几个值：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;chunked：数据分块发送。此时应缺省 Content-Length 响应头。意思是报文里的 body 部分不是一次性发过来的，而是分成了许多的块（chunk）逐个发送。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;compress：使用 Lempel-Ziv-Welch 算法进行传输的格式，目前没有浏览器在支持。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;deflate：使用 deflate 压缩算法 zlib 结构。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;gzip：使用 Lempel-Ziv coding 编码的压缩格式。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;identity：标识身份函数（e.g. no compression, nor modification）。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;也可以同时指定多个值，用逗号分隔，像这样：Transfer-Encoding: gzip, chunked。&lt;/p&gt;&lt;/blockquote&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.56&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/l7qvliaicFcd6SypgIYmFXotucODES1wmAZNLZhAbFsgpdRH6ibNtWaryxCTa3UNQyicZ6wJwhib0Ric7loicvIymMFQA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2000&quot;/&gt;&lt;/figure&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.56&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/l7qvliaicFcd6SypgIYmFXotucODES1wmAhNGNcpAZiaW33uVpQWFsYVpjjYZmZuq8B5JnYysiaQqM1yic86tX7SlWA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2000&quot;/&gt;&lt;/figure&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.56&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/l7qvliaicFcd6SypgIYmFXotucODES1wmACeL7dlGqcudNE3HVq868KmDWBrAsjSrgsPEsxz5SX8E89QNGBSsNZw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2000&quot;/&gt;&lt;/figure&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;“Transfer-Encoding: chunked”和“Content-Length”这两个字段是互斥的，也就是说响应报文里这两个字段不能同时出现。&lt;/p&gt;&lt;/blockquote&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;范围请求&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;HTTP协议还提出了范围请求（range requests）的概念。允许客户端在请求头里使用专用字段来表示只获取文件的一部分，相当于是客户端的“化整为零”。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;试想你正在追剧，想拖着看，这实际上是想获取一个大文件其中的片段数据，而这时就用到范围请求了。&lt;/p&gt;&lt;/blockquote&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;相关头字段&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;请求头Range是 HTTP 范围请求的专用字段，格式是“bytes=x-y”，其中的 x 和 y 是以字节为单位的数据范围；响应头里有“Accept-Ranges: bytes”标识服务端支持范围请求的。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;请求&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;bytes=x-y&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;表示第二个500字节：bytes=500-999&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;表示最后500个字节：bytes=-500&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;表示500字节以后的范围：bytes=500-&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;第一个和最后一个字节：bytes=0-0,-1&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;同时指定几个范围：bytes=500-600,601-999&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;请求报文&lt;/p&gt;&lt;/blockquote&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;GET /test HTTP/1.1&lt;br/&gt;&lt;br/&gt;Host: www.test.com&lt;br/&gt;&lt;br/&gt;Range: bytes=0-31&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;响应报文&lt;/p&gt;&lt;/blockquote&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;HTTP/1.1 206 Partial Content&lt;br/&gt;&lt;br/&gt;Content-Length: 32&lt;br/&gt;&lt;br/&gt;Accept-Ranges: bytes&lt;br/&gt;&lt;br/&gt;Content-Range: bytes 0-31/96&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;先发个 HEAD，看服务器是否支持范围请求，同时获取文件的大小；开 N 个线程，每个线程使用 Range 字段划分出各自负责下载的片段，发请求传输数据；下载意外中断也不怕，不必重头再来一遍，只要根据上次的下载记录，用 Range 请求剩下的那一部分就可以了。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;范围请求-多段数据&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;刚才说的范围请求一次只获取一个片段，其实它还支持在 Range 头里使用多个“x-y”，一次性获取多个片段数据。请求头Range同时指定几个范围：bytes=500-600,601-999&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;特殊的 MIME 类型：“multipart/byteranges”，表示报文的 body 是由多段字节序列组成的，并且还要用一个参数“boundary=xxx”来分隔段。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;多段数据的格式与分块传输也比较类似，但它需要用分隔标记 boundary 来区分不同的片段，可以通过图来对比一下。&lt;/p&gt;&lt;/blockquote&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.56&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/l7qvliaicFcd6SypgIYmFXotucODES1wmAqlrrZaN8CY0069Jdml8NjTLD7Wqgw0lH8YNI37bQiaic4zN0aW6I6Lkw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2000&quot;/&gt;&lt;/figure&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;每一个分段必须以“- -boundary”开始（前面加两个“-”），之后要用“Content-Type”和“Content-Range”标记这段数据的类型和所在范围，然后就像普通的响应头一样以回车换行结束，再加上分段数据，最后用一个“- -boundary- -”（前后各有两个“-”）表示所有的分段结束。&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;例如，Telnet 发出有两个范围的请求：&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;请求报文&lt;/p&gt;&lt;/blockquote&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;GET /test2 HTTP/1.1&lt;br/&gt;&lt;br/&gt;Host: www.test.com&lt;br/&gt;&lt;br/&gt;Range: bytes=0-9, 20-29&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;响应报文&lt;/p&gt;&lt;/blockquote&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;HTTP/1.1 206 Partial Content&lt;br/&gt;&lt;br/&gt;Content-Type: multipart/byteranges; boundary=00000000001&lt;br/&gt;&lt;br/&gt;Content-Length: 189&lt;br/&gt;&lt;br/&gt;Connection: keep-alive&lt;br/&gt;&lt;br/&gt;Accept-Ranges: bytes&lt;br/&gt;&lt;br/&gt;&lt;br/&gt;&lt;br/&gt;--00000000001&lt;br/&gt;&lt;br/&gt;Content-Type: text/plain&lt;br/&gt;&lt;br/&gt;Content-Range: bytes 0-9/96&lt;br/&gt;&lt;br/&gt;&lt;br/&gt;// this is&lt;br/&gt;&lt;br/&gt;--00000000001&lt;br/&gt;&lt;br/&gt;Content-Type: text/plain&lt;br/&gt;&lt;br/&gt;Content-Range: bytes 20-29/96&lt;br/&gt;&lt;br/&gt;&lt;br/&gt;ext json d&lt;br/&gt;&lt;br/&gt;--00000000001--&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;大文件传输的总结&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;压缩 HTML 等文本文件是传输大文件最基本的方法；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;分块传输可以流式收发数据，节约内存和带宽，使用响应头字段“Transfer-Encoding: chunked”来表示，分块的格式是 16 进制长度头 + 数据块；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;范围请求可以只获取部分数据，即“分块请求”，实现视频拖拽或者断点续传，使用请求头字段“Range”和响应头字段 “Content-Range”，响应状态码必须是 206；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;也可以一次请求多个范围，这时候响应报文的数据类型是“multipart/byteranges”，body 里的多个部分会用 boundary 字符串分隔。要注意这四种方法不是互斥的，而是可以混合起来使用，例如压缩后再分块传输，或者分段后再分块，实验环境的 URI“/16-3”就模拟了后一种的情形，你可以自己用 Telnet 试一下。》综上，大家也思考下新时代里大文件传输的方式。五、相关的协议&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;span&gt;6&lt;/span&gt;&lt;/span&gt;&lt;span&gt;相关的协议&lt;/span&gt;&lt;/h2&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.47868453105968334&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/l7qvliaicFcd6SypgIYmFXotucODES1wmA7fQNBNYzxrRSyA3H1PqSY85dicfzvYeaxh8xxm0I7pp7vrHibiafIAr7g/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1642&quot;/&gt;&lt;/figure&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;TCP/IP传输协议，即传输控制/网络协议，也叫作网络通讯协议。它是在网络的使用中的最基本的通信协议。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;应用层的主要协议有HTTP、Telnet、FTP、SMTP等，是用来接收来自传输层的数据或者按不同应用要求与方式将数据传输至传输层；传输层的主要协议有UDP、TCP，是使用者使用平台和计算机信息网内部数据结合的通道，可以实现数据传输与数据共享；网络层的主要协议有ICMP、IP、IGMP，主要负责网络中数据包的传送等；而网络访问层，也叫网路接口层或数据链路层，主要协议有ARP、RARP，主要功能是提供链路管理错误检测、对不同通信媒介有关信息细节问题进行有效处理等。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;下面是wireshake的抓包，访问&lt;code&gt;http://127.0.0.1/&lt;/code&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.660958904109589&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/l7qvliaicFcd6SypgIYmFXotucODES1wmAUparRQtcYiaribkm9LvB0IdLykdibaCoa8EIk9c5mj85DHytGHehfjFJQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1168&quot;/&gt;&lt;figcaption&gt;图片来源：罗老师的透析http协议&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Wireshark 里就会有捕获的数据包（域名访问的话还会有dns解析）&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1.8037974683544304&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/l7qvliaicFcd6SypgIYmFXotucODES1wmAjQLH96YCDffI9sHP1ia10nfplOZ60D88u6T3ewrTSfnLgCI1vxPt4Qg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;316&quot;/&gt;&lt;figcaption&gt;图片来源：罗老师的透析http协议&lt;/figcaption&gt;&lt;/figure&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;浏览器从地址栏的输入中获得服务器的 IP 地址和端口号；浏览器用 TCP 的三次握手与服务器建立连接；浏览器向服务器发送拼好的报文；服务器收到报文后处理请求，同样拼好报文再发给浏览器；浏览器解析报文，渲染输出页面。&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上面是极简情况下，现在的大多数场景更复杂，如下图：NSFileHandle_3.png&lt;img data-ratio=&quot;0.44175824175824174&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/l7qvliaicFcd6SypgIYmFXotucODES1wmAsw5w0fCe9VkLVibg15sFibzFquBvjLl9vwXGUgalQ8M4Y0mrx3vuRvWw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;455&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;综上 ，最后一个问题的答案也揭晓了&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;【参考资料】&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;[1] 罗剑锋（Chrono）《透视HTTP协议》(深入理解HTTP协议本质与应用)&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;[2] IETF RFC Hypertext Transfer Protocol 协议相关RFC&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;[3] IETF RFC2616 (终于成为了标准)&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>