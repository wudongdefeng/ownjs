<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>8af3f782735b7683576d3229e642be64</guid>
<title>CentOS 下安装 Docker 极简教程</title>
<link>https://toutiao.io/k/t9yi9em</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content js_underline_content             autoTypeSetting24psection&amp;#10;            &quot; id=&quot;js_content&quot;&gt;&lt;section class=&quot;mp_profile_iframe_wrp&quot;&gt;&lt;mp-common-profile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mpprofile&quot; data-id=&quot;MzI0MzA2OTc4MQ==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/Bfv9smoHwth5nBzNr9kZshQ25yhLz08JicGiaeuWY5k8z6JHS4KYxQ2zp2lU9mjSC6PsvBlib658u3CnrSQsuCzAg/0?wx_fmt=png&quot; data-nickname=&quot;码农UP2U&quot; data-alias=&quot;&quot; data-signature=&quot;关于 Java、PHP、其他编程语言……或安全、或码农、或技术、或总结！学习交流，共同进步！码农 up to you，码农UP2U!&quot; data-from=&quot;0&quot; data-is_biz_ban=&quot;0&quot;/&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;早期文章&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;hr/&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;        上篇文章通过 Vagrant 给 VirtualBox 安装了 CentOS，这篇再整理一下在 CentOS 下安装 Docker。Vagrant + VirtualBox + Docker 来搭建开发环境是很方便的，不过机器性能不高的话会很卡。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.2459016393442623&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Bfv9smoHwtjkRulU9ibyGWmthOxbo86D6olNnT89mIwdwGicloBjqFHic9SmdDEwibdib0LyQQnAVicItPDVsm9KFWlg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1037&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;1.卸载系统中的docker&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;        首先来卸载一下当前的 docker，当然系统中可能没有。&lt;/span&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;properties&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;[vagrant@localhost ~]$ sudo yum remove docker \&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&amp;gt; docker-client \&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&amp;gt; docker-client-latest \&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&amp;gt; docker-common \&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&amp;gt; docker-latest \&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&amp;gt; docker-latest-logrotate \&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&amp;gt; docker-logrotate \&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&amp;gt; docket-engine&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;Failed to set locale, defaulting to C&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;Loaded plugins: fastestmirror&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;No Match for argument: docker&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;No Match for argument: docker-client&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;No Match for argument: docker-client-latest&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;No Match for argument: docker-common&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;No Match for argument: docker-latest&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;No Match for argument: docker-latest-logrotate&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;No Match for argument: docker-logrotate&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;No Match for argument: docket-engine&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;No Packages marked for removal&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;2.安装对应的依赖环境和镜像地址&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;        安装yum-utils，它属于是yum的一个扩展工具。&lt;/span&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;sql&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;[vagrant@localhost ~]$ sudo yum install -y yum-utils&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;Complete!&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;[vagrant@localhost ~]$&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;        然后呢，添加 Docker 的资源库。&lt;/span&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;ruby&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;[vagrant@localhost ~]$ sudo yum-config-manager \&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&amp;gt; --add-repo \&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&amp;gt; https://download.docker.com/linux/centos/docker-ce.repo&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;Failed to set locale, defaulting to C&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;Loaded plugins: fastestmirror&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;adding repo from: https://download.docker.com/linux/centos/docker-ce.repo&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;grabbing file https://download.docker.com/linux/centos/docker-ce.repo to /etc/yum.repos.d/docker-ce.repo&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;repo saved to /etc/yum.repos.d/docker-ce.repo&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;        官网的速度可能较慢，这里也可以添加阿里云的资源库。&lt;/span&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;cs&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;[vagrant@localhost ~]$ sudo yum-config-manager \&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&amp;gt; --add-repo \&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&amp;gt; http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;Failed to set locale, defaulting to C&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;Loaded plugins: fastestmirror&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;adding repo from: http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;grabbing file http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo to /etc/yum.repos.d/docker-ce.repo&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;repo saved to /etc/yum.repos.d/docker-ce.repo&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;3.安装 Docker&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;        这里通过 yum 安装 docker-ce、docker-ce-cli 和 containerd.io。&lt;/span&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;sql&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;[vagrant@localhost ~]$ sudo yum install -y docker-ce docker-ce-cli containerd.io&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;Failed to set locale, defaulting to C&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;Loaded plugins: fastestmirror&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;Loading mirror speeds from cached hostfile&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt; * base: mirror.lzu.edu.cn&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt; * extras: mirrors.ustc.edu.cn&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt; * updates: mirrors.ustc.edu.cn&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;docker-ce-stable                                                                                                     | 3.5 kB  00:00:00     &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;(1/2): docker-ce-stable/7/x86_64/updateinfo                                                                          |   55 B  00:00:00     &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;(2/2): docker-ce-stable/7/x86_64/primary_db                                                                          |  88 kB  00:00:00     &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;Complete!&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;其中 docker-ce 是 Docker 的社区版，专门用于开发人员和小团队创建基于容器的应用。比如，我们现在就是在搭建开发环境。docker-ce-cli 相当于是个命令行工具。&lt;/span&gt;&lt;span&gt;&lt;span&gt;containerd.io 是 一个守护进程&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;4.启动 Docker 并查看运行中的容器&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;        启动 docker 直接使用 systemctl 或者 service 即可启动。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;sql&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;[vagrant@localhost ~]$ sudo systemctl start docker&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;[vagrant@localhost ~]$ sudo docker ps&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;CONTAINER ID   IMAGE     COMMAND   CREATED   STATUS    PORTS     NAMES&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;        通过 docker ps 命令可以查看运行中的容器，当然了，我们这里只是刚刚安装了 Docker，不会有运行中的容器。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;5.查看 Docker 版本&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;        查看 Docker 的版本，其实就类似于我们安装完 JDK 并配置完 JDK 的环境变量以后，通过 java -version 来验证一下安装和配置是否正确。我们通过 docker version 来查看 Docker 是否安装成功。&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;properties&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;[root@localhost ~]# docker version&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;Client: Docker Engine - Community&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt; Version:           20.10.21&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt; API version:       1.41&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt; Go version:        go1.18.7&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt; Git commit:        baeda1f&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt; Built:             Tue Oct 25 18:04:24 2022&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt; OS/Arch:           linux/amd64&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt; Context:           default&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt; Experimental:      true&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;Server: Docker Engine - Community&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt; Engine:&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  Version:          20.10.21&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  API version:      1.41 (minimum version 1.12)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  Go version:       go1.18.7&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  Git commit:       3056208&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  Built:            Tue Oct 25 18:02:38 2022&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  OS/Arch:          linux/amd64&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  Experimental:     false&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt; containerd:&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  Version:          1.6.10&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  GitCommit:        770bd0108c32f3fb5c73ae1264f7e503fe7b2661&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt; runc:&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  Version:          1.1.4&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  GitCommit:        v1.1.4-0-g5fd4c4d&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt; docker-init:&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  Version:          0.19.0&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  GitCommit:        de40ad0&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;        其实此时执行 docker version 有些多此一举，因为我们在上一步启动 Docker 后执行了 docker ps 命令，就相当于验证 Docker 是否启动成功了。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;6.设置开机自启动&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;        最后呢，让 Docker 每次开机自动运行。因为我们是开发环境，虚拟机用完就关机了，下次启动虚拟机，让 Docker 跟着启动对于我们开发来说更方便一些。&lt;/span&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;cs&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;[root@localhost ~]&lt;span class=&quot;code-snippet__meta&quot;&gt;# systemctl enable docker&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;        好啦，Docker 的安装就到这了！一个很简单的教程！！&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.0712962962962963&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Bfv9smoHwthBDooApBDUM9yqM6BWHMOaJyrXzMxqibI7B90xNgZswWSVSatF56vMAicAA56UmJkc2rQlDUARycYQ/640?wx_fmt=png&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;公众号内回复 【mongo】 下载 SpringBoot 整合操作 MongoDB 的文档。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;公众号内回复 【&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;&lt;strong&gt;cisp知识整理&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;&lt;strong&gt;】 下载 CISP 读书笔记。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;公众号内&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;回复【java开发手册】获取《Java开发手册》黄山版。&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;section class=&quot;mp_profile_iframe_wrp&quot;&gt;&lt;mp-common-profile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mpprofile&quot; data-id=&quot;MzI0MzA2OTc4MQ==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/Bfv9smoHwth5nBzNr9kZshQ25yhLz08JicGiaeuWY5k8z6JHS4KYxQ2zp2lU9mjSC6PsvBlib658u3CnrSQsuCzAg/0?wx_fmt=png&quot; data-nickname=&quot;码农UP2U&quot; data-alias=&quot;&quot; data-signature=&quot;关于 Java、PHP、其他编程语言……或安全、或码农、或技术、或总结！学习交流，共同进步！码农 up to you，码农UP2U!&quot; data-from=&quot;0&quot; data-is_biz_ban=&quot;0&quot;/&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.36484375&quot; data-s=&quot;300,640&quot; data-type=&quot;jpeg&quot; data-w=&quot;1280&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Bfv9smoHwth5nBzNr9kZshQ25yhLz08JHWsQdz8yVn3MVh22hia7NFoPyNJz4ZI7XUnMa9xM50TJRqPkWf7BRibQ/640?wx_fmt=jpeg&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;mp-style-type data-value=&quot;3&quot;/&gt;&lt;/p&gt;&lt;/div&gt;

          
        &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>915293a7acc43cd55fc0a77637291615</guid>
<title>有些技术原理你完全看不懂</title>
<link>https://toutiao.io/k/rww5ta2</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content js_underline_content             autoTypeSetting24psection&amp;#10;            &quot; id=&quot;js_content&quot;&gt;&lt;p data-mpa-powered-by=&quot;yiban.io&quot;&gt;上一篇文章写了 &lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=Mzk0MjE3NDE0Ng==&amp;amp;mid=2247503600&amp;amp;idx=1&amp;amp;sn=4f59f1a127c793c9b478b2622b16e909&amp;amp;chksm=c2c5b45df5b23d4b964ef64713a035d4bdd680414a1a2e21d4b36173624352738012e521254c&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;为什么 JVM 叫做基于栈的 RISC 虚拟机&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;为什么 JVM 叫做基于栈的 RISC 虚拟机&lt;/a&gt;，看评论里不少人反馈一脸懵逼。&lt;/p&gt;&lt;p&gt;但我相信应该也有不少读者会觉得我整篇文章都在讲废话。&lt;/p&gt;&lt;p&gt;为什么会有这么两极分化的差异呢？&lt;/p&gt;&lt;p&gt;因为如果你知道什么是 ISA，并且把 x86、arm 等指令集都了解过，并且切实感受到了 RISC 和 CISC 指令集的区别，同时也知道基于栈的和基于寄存器的指令集的区别。那么整篇文章就除了标题外全都是废话了。&lt;/p&gt;&lt;p&gt;但如果这些你都不了解的话，那么标题就是天书，整篇文章看下来也只能明白个马马虎虎，除非你把我里面提到的所有手册和源码都浏览过。&lt;/p&gt;&lt;p&gt;所以为什么底层的这些知识非常重要，它能让你秒懂一个技术的原理，而且还能比别人理解得更透彻，上篇文章就是个很好的例子。&lt;/p&gt;&lt;p&gt;------&lt;/p&gt;&lt;p&gt;在咱们国家，计算机底层的教育是十分不重视的，整个环境也不太乐观，大部分人急功近利，只想尽快掌握到能直接提升薪资的上层技术。&lt;/p&gt;&lt;p&gt;同时，网上充斥大量的二手三手四手的博客，被那些专门研究搜索引擎的网站占据了半壁江山。&lt;/p&gt;&lt;p&gt;在公司，也动不动就讲业务价值，把没有的说成有的，把别人的说成自己的，欺骗业务，欺骗自己，还引以为傲。&lt;/p&gt;&lt;p&gt;------&lt;/p&gt;&lt;p&gt;算了，不说这些了。&lt;/p&gt;&lt;p&gt;曾经我因为寻找一手资料而苦恼，一搜就被一大堆二手信息覆盖掉了。&lt;/p&gt;&lt;p&gt;当然，这一部分锅要百度来背，用谷歌搜索一手技术资料会好很多。&lt;/p&gt;&lt;p&gt;于是，我给自己建立了一个一手资料索引的 Github，并且按照顺序自底向上排列了起来。&lt;/p&gt;&lt;p&gt;https://github.com/sunym1993/computer-all&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.8993288590604027&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;894&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/GLeh42uInXRBv2yqAtAQwK0lGwcPYiaLbiaygKBmUpXBL4QhfQaPz2BHKicYyQfGxWTNv00y8f6doB4L9YCyibv9Ow/640?wx_fmt=png&quot;/&gt;&lt;/p&gt;&lt;p&gt;对，名字起得有点大，叫&lt;strong&gt;关于计算机的一切&lt;/strong&gt;。&lt;/p&gt;&lt;p&gt;我希望这里成为我今后学习技术或分享技术的唯一资料入口，这里会保留所有最原汁原味的一手信息，包括手册、官方文档、源码，以及个别非常优质的对一手资料进行简化、格式化、结构化，而不是自行理解和篡改的网站或博客。&lt;/p&gt;&lt;p&gt;当然这个小天地才刚刚开始建立，也非常需要大家的智慧来一起进行完善！&lt;/p&gt;&lt;p&gt;------&lt;/p&gt;&lt;p&gt;有同学觉得，读手册是不是太浪费时间了，直接百度找个博客能快速把知识点学会。&lt;/p&gt;&lt;p&gt;不，暂且不说知识体系的系统性问题，就光拿一个知识点来说，网上博客你看了一圈又一圈，写成啥样的都有，尤其是需要严谨性的一些底层技术，到头来还不如花点时间看看手册。&lt;/p&gt;&lt;p&gt;比如我之前搞不懂 GNU C 和 ANSI C 的关系，网上搜一圈后你会发现更加一头雾水，还得忙着辨别真伪。&lt;/p&gt;&lt;p&gt;但只要你打开 GNU C 的手册，开头就把这个问题说的一清二楚。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.24863174354964818&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;1279&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/GLeh42uInXRBv2yqAtAQwK0lGwcPYiaLbiaOdk5gKhZVtu2GcxNF0tRibSUicIILaVuqak8uueTN9qJ2nd2Jrqk3Zg/640?wx_fmt=png&quot;/&gt;&lt;/p&gt;&lt;p&gt;如果对这些抽象的描述无法具象化，那么只需要手册再翻一页，看一下具体例子就明白了。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.3559479553903346&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;1076&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/GLeh42uInXRBv2yqAtAQwK0lGwcPYiaLbgmNCY31mXFs27iccRwMSazO3SM3l6Zib965LW8t63m9Kxs1TlTJwnWsA/640?wx_fmt=png&quot;/&gt;&lt;/p&gt;&lt;p&gt;------&lt;/p&gt;&lt;p&gt;再比如上篇文章里讲的，JVM 执行引擎在执行字节码的时候，一种是用古老的字节码解释器，用纯&quot;软件&quot;的方式来模拟执行，效率很低，另一种是用模板解释器，将每个字节码指令都映射为一个函数，直接写入机器码来执行，可针对不同 CPU 体系结构进行优化，效率很高。&lt;/p&gt;&lt;p&gt;这句话你背面试八股文的时候一定听过，而且你可能觉得挺高大上的，但如果你看过源码之后再理解这句话，就觉得它很可笑。&lt;/p&gt;&lt;p&gt;用纯软件的方式模拟执行的字节码解释器，就是用一个 topOfStack 数组来实现所谓的操作数栈，压一个值数组的一个指针就往后挪一下，弹一个值那就往前挪一下，就操作个数组嘛~&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.2833333333333333&quot; data-w=&quot;1080&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/GLeh42uInXRCDApAzMVibJOWhf2PMibTGPxvhicPmdSvV3gJewiaQrMnTzAIelLxxx5qjj4bkMUx5CsZzAsVVRp8LA/640?wx_fmt=png&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot;/&gt;&lt;/p&gt;&lt;p&gt;模板解释器将每个字节码指令都映射为一个函数，就是按每个字节码来命名一个函数。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.2465753424657534&quot; data-w=&quot;876&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/GLeh42uInXQYN0k6YY3WeicZEbQYiaMO0vuhdgbnWcnZ7ERYezC4hFrUYo0GVYMoqTo2MWbgc1LS5TUrxN1Z8w2w/640?wx_fmt=png&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot;/&gt;&lt;/p&gt;&lt;p&gt;直接写入机器码就是查各种 CPU 的手册，拼好二进制的值写进去。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.20797413793103448&quot; data-w=&quot;928&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/GLeh42uInXRCDApAzMVibJOWhf2PMibTGPscsnfCMLIewFGKGEQsm5EYYqbkkAll1WEPyR8aZXGzEmrGy8gkZqGQ/640?wx_fmt=png&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot;/&gt;&lt;/p&gt;&lt;p&gt;所谓查手册，就和人家的接口说明文档一样，那可比公司里别人写的接口文档好看多啦~&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.41574074074074074&quot; data-w=&quot;1080&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/GLeh42uInXRCDApAzMVibJOWhf2PMibTGPfdNSw1RtWKoUBSlHKt5CPI7IGaHdVnV1T73y0ro9q4uQDvDPu4HsUg/640?wx_fmt=png&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot;/&gt;&lt;/p&gt;&lt;p&gt;不同 CPU 就是不同的 .cpp 文件，分布在不同文件夹下面，简单粗暴，每个都是查手册写二进制数值，辛苦一点罢了。除非你是专门搞这些指令集的，比如把 OpenJDK 改造一下让它适配龙芯 CPU，那可能是个工程量很大的活，但原理很简单。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.32213740458015266&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;655&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/GLeh42uInXRBv2yqAtAQwK0lGwcPYiaLbibmIibzh3TZibzouoPRib8aEOpb4qbGVlOMIBkyuWwKrctLK1bgHmiamhmA/640?wx_fmt=png&quot;/&gt;&lt;/p&gt;&lt;p&gt;里面的 x86 就是我们常用的 Intel x86 CPU 嘛~&lt;/p&gt;&lt;p&gt;看到了这些底层的本质，你还觉得刚刚那句话高大上么？呵呵。&lt;/p&gt;&lt;p&gt;------&lt;/p&gt;&lt;p&gt;好啦，最后希望大家能够尊重技术，重视底层，养成查阅一手资料的好习惯。&lt;/p&gt;&lt;p&gt;老读者可能也发现了我文章的变化，从一开始的破玩意风格文章，变成现在的从一手资料里找论据并推理类型的文章。&lt;/p&gt;&lt;p&gt;我觉得，这样类型的文章并不代表会失去生动和形象，它反而能让你更容易理解到技术的本质，至于如何把它写的更生动，更易读，这就是我要努力的方向了，但这条路准没错。&lt;/p&gt;&lt;p&gt;最后，希望大家和我一起共建这块小天地，关于计算机的一切，靠你们啦~&lt;/p&gt;&lt;p&gt;https://github.com/sunym1993/computer-all&lt;/p&gt;&lt;p&gt;下方&lt;strong&gt;阅读原文&lt;/strong&gt;可以直接跳转过去。&lt;/p&gt;&lt;section class=&quot;mp_profile_iframe_wrp&quot;&gt;&lt;mp-common-profile class=&quot;custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mpprofile&quot; data-id=&quot;Mzk0MjE3NDE0Ng==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/GLeh42uInXRVh3YhnV9yvZK9TGpSsFykUQPtHm4TuNAOUOr5qtPyZlg4DNciaYWiasRx1Fgt6UFTDjaK9qc08Llw/0?wx_fmt=png&quot; data-nickname=&quot;低并发编程&quot; data-alias=&quot;dibingfa&quot; data-signature=&quot;生活也同样如此&quot; data-from=&quot;0&quot;/&gt;&lt;/section&gt;&lt;p&gt;&lt;mp-style-type data-value=&quot;3&quot;/&gt;&lt;/p&gt;&lt;/div&gt;

          
        &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>d96fff8258668e4ed57cf6a8d8b3ba53</guid>
<title>Java 字符串 split 的一个反直觉陷阱</title>
<link>https://toutiao.io/k/dv65u05</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;article class=&quot;article fmt article-content &quot;&gt;&lt;p&gt;最近生产环境遇到一个奇怪的数组下标越界报错，如下图代码所示，我们可以肯定的是 &lt;code&gt;fieldName&lt;/code&gt; 变量不为空（不是空字符串，也不是 &lt;code&gt;null&lt;/code&gt;），但是代码执行到读取 &lt;code&gt;names[0]&lt;/code&gt; 变量的时候，抛出了一个 &lt;strong&gt;数组下标越界&lt;/strong&gt; （&lt;code&gt;java.lang.ArrayIndexOutOfBoundsException&lt;/code&gt;） 的异常。&lt;/p&gt;&lt;p&gt;&lt;img referrerpolicy=&quot;no-referrer&quot; src=&quot;/img/remote/1460000042912345&quot; alt=&quot;&quot; title=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;&lt;p&gt;异常信息如下图所示&lt;/p&gt;&lt;p&gt;&lt;img referrerpolicy=&quot;no-referrer&quot; src=&quot;/img/remote/1460000042912346&quot; alt=&quot;&quot; title=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;&lt;p&gt;问题很简单，我们对一个字符串执行 &lt;code&gt;split&lt;/code&gt; 方法之后，以过往其它编程语言（Go、PHP、Javascript、Dart 等）的使用经验来看，即使字符串为空，即使没有匹配到分隔符，在返回值数组中也会包含一个当前字符串的值。但是这里却抛出了 &lt;code&gt;ArrayIndexOutOfBoundsException&lt;/code&gt;，难道 &lt;code&gt;split&lt;/code&gt; 方法的返回值可能为空数组？&lt;/p&gt;&lt;p&gt;最终经过排查发现，在上述代码段中，当 &lt;code&gt;fieldName&lt;/code&gt; 的值为 &lt;code&gt;&quot;~&quot;&lt;/code&gt; 的时候，我们访问 &lt;code&gt;names[0]&lt;/code&gt; 就会抛出 &lt;code&gt;ArrayIndexOutOfBoundsException&lt;/code&gt;，为什么会这样呢？&lt;/p&gt;&lt;p&gt;本文将会持续修正和更新，最新内容请参考我的 &lt;a href=&quot;https://link.segmentfault.com/?enc=bgMEGr%2BjxSNJ3YOMolHXsA%3D%3D.httwjFxqDZQml65dpc9jKd5T7jF7JuwiNelue%2Bs%2B3qQ%3D&quot; rel=&quot;nofollow&quot;&gt;GITHUB&lt;/a&gt; 上的 &lt;a href=&quot;https://link.segmentfault.com/?enc=66Ha7CAMrHZQGFxdCpDAFw%3D%3D.ythCQfNMbLABJ57o9hifk%2FdNZXi9C2kei5mqMXi3JkSXSdl5ysvnSP5cr7tmLLKV&quot; rel=&quot;nofollow&quot;&gt;程序猿成长计划&lt;/a&gt; 项目，欢迎 Star，更多精彩内容请 &lt;a href=&quot;https://link.segmentfault.com/?enc=HjlveqFo1D6ZsJL4Qjnd7w%3D%3D.xUIx%2BxP7RwhUmoluR%2FD6mYBqyJwX%2BMQky67%2B14H8drk%3D&quot; rel=&quot;nofollow&quot;&gt;follow me&lt;/a&gt;。&lt;/p&gt;&lt;h2&gt;问题&lt;/h2&gt;&lt;p&gt;在 Java 中，如果执行下面这段代码，直觉上你认为会输出什么？&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;java&quot;&gt;String str = &quot;~&quot;;
String []arr = str.split(&quot;~&quot;);

System.out.println(arr.length);&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;如果你有其他编程语言的经验，可能直觉上会觉得这里输出的应该是 &lt;strong&gt;2&lt;/strong&gt;，但是遗憾的是，这里输出的是 &lt;strong&gt;0&lt;/strong&gt;，变量 &lt;code&gt;arr&lt;/code&gt; 是个空数组。&lt;/p&gt;&lt;p&gt;这里不禁怀疑自己之前的记忆是不是有偏差，于是我又使用其它语言来尝试复现这个问题。&lt;/p&gt;&lt;h2&gt;不同语言中 split 的行为&lt;/h2&gt;&lt;p&gt;我总结了一个表格，说明了不用语言不同的行为，这里对比的是执行 &lt;code&gt;split&lt;/code&gt; 函数/方法后返回数组的长度：&lt;/p&gt;&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;语言\函数&lt;/th&gt;&lt;th&gt;&lt;code&gt;&quot;&quot;.split(&quot;&quot;)&lt;/code&gt;&lt;/th&gt;&lt;th&gt;&lt;code&gt;&quot;~&quot;.split(&quot;~&quot;)&lt;/code&gt;&lt;/th&gt;&lt;th align=&quot;left&quot;&gt;&lt;code&gt;&quot;~~&quot;.split(&quot;~&quot;)&lt;/code&gt;&lt;/th&gt;&lt;th align=&quot;left&quot;&gt;&lt;code&gt;&quot;&quot;.split(&quot;~&quot;)&lt;/code&gt;&lt;/th&gt;&lt;th align=&quot;left&quot;&gt;&lt;code&gt;&quot;~123&quot;.split(&quot;~&quot;)&lt;/code&gt;&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;Javascript&lt;/td&gt;&lt;td&gt;0&lt;/td&gt;&lt;td&gt;2&lt;/td&gt;&lt;td align=&quot;left&quot;&gt;3&lt;/td&gt;&lt;td align=&quot;left&quot;&gt;1&lt;/td&gt;&lt;td align=&quot;left&quot;&gt;2&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;PHP&lt;/td&gt;&lt;td&gt;0&lt;/td&gt;&lt;td&gt;2&lt;/td&gt;&lt;td align=&quot;left&quot;&gt;3&lt;/td&gt;&lt;td align=&quot;left&quot;&gt;1&lt;/td&gt;&lt;td align=&quot;left&quot;&gt;2&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;Dart&lt;/td&gt;&lt;td&gt;0&lt;/td&gt;&lt;td&gt;2&lt;/td&gt;&lt;td align=&quot;left&quot;&gt;3&lt;/td&gt;&lt;td align=&quot;left&quot;&gt;1&lt;/td&gt;&lt;td align=&quot;left&quot;&gt;2&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;Golang&lt;/td&gt;&lt;td&gt;0&lt;/td&gt;&lt;td&gt;2&lt;/td&gt;&lt;td align=&quot;left&quot;&gt;3&lt;/td&gt;&lt;td align=&quot;left&quot;&gt;1&lt;/td&gt;&lt;td align=&quot;left&quot;&gt;2&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;Scala&lt;/td&gt;&lt;td&gt;1&lt;/td&gt;&lt;td&gt;0&lt;/td&gt;&lt;td align=&quot;left&quot;&gt;0&lt;/td&gt;&lt;td align=&quot;left&quot;&gt;1&lt;/td&gt;&lt;td align=&quot;left&quot;&gt;2&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;Java&lt;/td&gt;&lt;td&gt;1&lt;/td&gt;&lt;td&gt;0&lt;/td&gt;&lt;td align=&quot;left&quot;&gt;0&lt;/td&gt;&lt;td align=&quot;left&quot;&gt;1&lt;/td&gt;&lt;td align=&quot;left&quot;&gt;2&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h3&gt;Javascript&lt;/h3&gt;&lt;p&gt;首先是 Javascript，在浏览器的控制台上直接执行，得到了下面的结果&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;javascript&quot;&gt;&quot;&quot;.split(&quot;&quot;)
&quot;~&quot;.split(&quot;~&quot;)
&quot;~~&quot;.split(&quot;~&quot;)
&quot;&quot;.split(&quot;~&quot;)
&quot;~123&quot;.split(&quot;~&quot;)&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;执行结果&lt;/p&gt;&lt;p&gt;&lt;img referrerpolicy=&quot;no-referrer&quot; src=&quot;/img/remote/1460000042912347&quot; alt=&quot;&quot; title=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;&lt;p&gt;跟我的直觉是一致的，同样的情况，这里返回的是 &lt;strong&gt;2&lt;/strong&gt;。&lt;/p&gt;&lt;h3&gt;PHP&lt;/h3&gt;&lt;p&gt;在 PHP 中，我使用了 &lt;code&gt;mb_split&lt;/code&gt; 函数，该函数用于对多字节字符串进行分割&lt;/p&gt;&lt;p&gt;&lt;img referrerpolicy=&quot;no-referrer&quot; src=&quot;/img/remote/1460000042912348&quot; alt=&quot;&quot; title=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;&lt;p&gt;执行结果如下&lt;/p&gt;&lt;p&gt;&lt;img referrerpolicy=&quot;no-referrer&quot; src=&quot;/img/remote/1460000042912349&quot; alt=&quot;&quot; title=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;&lt;p&gt;执行结果跟我的直觉也是一致的，同样的情况，这里返回的是 &lt;strong&gt;2&lt;/strong&gt;。&lt;/p&gt;&lt;h3&gt;Dart&lt;/h3&gt;&lt;p&gt;然后是 Google 的 Dart，这是一门主要用于使用 Flutter 来开发跨平台应用的编程语言，代码如下&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;dart&quot;&gt;void main() {
    print(&quot;&quot;.split(&#x27;&#x27;).length); // 0
    print(&quot;~&quot;.split(&#x27;~&#x27;).length); // 2
    print(&quot;~~&quot;.split(&#x27;~&#x27;).length); // 3
    print(&quot;&quot;.split(&#x27;~&#x27;).length); // 1
    print(&quot;~123&quot;.split(&#x27;~&#x27;).length); // 2
}&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;执行结果&lt;/p&gt;&lt;p&gt;&lt;img referrerpolicy=&quot;no-referrer&quot; src=&quot;/img/remote/1460000042912350&quot; alt=&quot;&quot; title=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;&lt;p&gt;同样，&lt;code&gt;&quot;~&quot;.split(&quot;~&quot;)&lt;/code&gt; 也是返回了两个值。&lt;/p&gt;&lt;h3&gt;Golang&lt;/h3&gt;&lt;p&gt;在 Golang 中，执行结果依旧是符合直觉的，返回的是 &lt;strong&gt;2&lt;/strong&gt;。&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;go&quot;&gt;package main

import(
    &quot;strings&quot;
    &quot;fmt&quot;
)

func main() {
    printStrs(strings.Split(&quot;&quot;, &quot;&quot;)) // 0 []
    printStrs(strings.Split(&quot;~&quot;, &quot;~&quot;)) // 2 [&quot;&quot;, &quot;&quot;, ]
    printStrs(strings.Split(&quot;~~&quot;, &quot;~&quot;)) // 3 [&quot;&quot;, &quot;&quot;, &quot;&quot;, ]
    printStrs(strings.Split(&quot;&quot;, &quot;~&quot;)) // 1 [&quot;&quot;, ]
    printStrs(strings.Split(&quot;~123&quot;, &quot;~&quot;)) // 2 [&quot;&quot;, &quot;123&quot;, ]
}

func printStrs(s []string) {
    fmt.Print(len(s), &quot; [&quot;)
    for _, item := range s {
        fmt.Printf(`&quot;%s&quot;, `, item)
    }

    fmt.Print(&quot;]\n&quot;)
}&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;执行结果&lt;/p&gt;&lt;p&gt;&lt;img referrerpolicy=&quot;no-referrer&quot; src=&quot;/img/remote/1460000042912351&quot; alt=&quot;&quot; title=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;&lt;h3&gt;Scala&lt;/h3&gt;&lt;p&gt;然后，我又尝试了 Scala，发现在 Scala 中， &lt;code&gt;split&lt;/code&gt; 的行为有些不一样了。&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;scala&quot;&gt;&quot;&quot;.split(&quot;&quot;).length
&quot;~&quot;.split(&quot;~&quot;).length
&quot;~~&quot;.split(&quot;~&quot;).length
&quot;&quot;.split(&quot;~&quot;).length
&quot;~123&quot;.split(&quot;~&quot;).length&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;img referrerpolicy=&quot;no-referrer&quot; src=&quot;/img/remote/1460000042912352&quot; alt=&quot;&quot; title=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;&lt;p&gt;代码 &lt;code&gt;&quot;~&quot;.split(&quot;~&quot;)&lt;/code&gt; 返回的是 &lt;strong&gt;空数组&lt;/strong&gt;，与在 Java 中我们遇到的问题如出一辙。&lt;/p&gt;&lt;h3&gt;Java&lt;/h3&gt;&lt;p&gt;最后，我又用 Java 执行了同样的代码&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;java&quot;&gt;package example;
import org.junit.Test;

public class ExampleTest {
  @Test
  public void testSplit() {
    printStrings(&quot;&quot;.split(&quot;&quot;)); // 1 [&quot;&quot;, ]
    printStrings(&quot;~&quot;.split(&quot;~&quot;)); // 0 []
    printStrings(&quot;~~&quot;.split(&quot;~&quot;)); // 0 []
    printStrings(&quot;&quot;.split(&quot;~&quot;)); // 1 [&quot;&quot;, ]
    printStrings(&quot;~123&quot;.split(&quot;~&quot;)); // 2 [&quot;&quot;, &quot;123&quot;, ]
  }
  
  private void printStrings(String[] strings) {
    System.out.print(strings.length + &quot; [&quot;);
    for (String str : strings) {
      System.out.printf(&quot;\&quot;%s\&quot;, &quot;, str);
    }
    System.out.println(&quot;]&quot;);
  }
}&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;执行结果&lt;/p&gt;&lt;p&gt;&lt;img referrerpolicy=&quot;no-referrer&quot; src=&quot;/img/remote/1460000042912353&quot; alt=&quot;&quot; title=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;&lt;p&gt;结果与 Scala 是一致的，同时也解释了为什么我们会遇到 &lt;code&gt;ArrayIndexOutOfBoundsException&lt;/code&gt; 的问题。&lt;/p&gt;&lt;h2&gt;原因&lt;/h2&gt;&lt;p&gt;翻阅了 Java 的 API 文档，发现原来 Java 中的 &lt;code&gt;split&lt;/code&gt; 方法确实跟其它语言是不一样的，这一点我们特别容易忽略&lt;/p&gt;&lt;p&gt;&lt;img referrerpolicy=&quot;no-referrer&quot; src=&quot;/img/remote/1460000042912354&quot; alt=&quot;&quot; title=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;&lt;p&gt;如果分隔符表达式与字符串不匹配，则返回原始字符串作为数组的唯一值，这也就解释了&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;java&quot;&gt;&quot;&quot;.split(&quot;&quot;) // 1 [&quot;&quot;]
&quot;&quot;.split(&quot;~&quot;) // 1 [&quot;&quot;]&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;如果分隔符表单式与字符串的开始字符就已经匹配了，则返回值中第一个元素会被设置为 &lt;code&gt;&quot;&quot;&lt;/code&gt;&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;java&quot;&gt;&quot;~123&quot;.split(&quot;~&quot;) // 2 [&quot;&quot;, &quot;123&quot;]&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;如果 &lt;code&gt;limit&lt;/code&gt; 参数为 &lt;strong&gt;0&lt;/strong&gt;，也就是 &lt;code&gt;split(String regex)&lt;/code&gt; 方法，则匹配结果末尾的所有空字符串 &lt;code&gt;&quot;&quot;&lt;/code&gt; 都会被丢弃，也就解释了下面两段代码&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;java&quot;&gt;&quot;~&quot;.split(&quot;~&quot;) // 0 []
&quot;~~&quot;.split(&quot;~&quot;) // 0 []&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;img referrerpolicy=&quot;no-referrer&quot; src=&quot;/img/remote/1460000042912355&quot; alt=&quot;&quot; title=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;&lt;p&gt;然后我又翻阅了 Scala 的官方文档，Scala 和 Java 的行为是一致的。&lt;/p&gt;&lt;p&gt;&lt;img referrerpolicy=&quot;no-referrer&quot; src=&quot;/img/remote/1460000042912356&quot; alt=&quot;&quot; title=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;&lt;h2&gt;总结&lt;/h2&gt;&lt;p&gt;在 Java 中使用字符串的 &lt;code&gt;split&lt;/code&gt; 方法，一般情况下的行为是和其他编程语言是一致的，但在一些边界条件下，也有一些不一致的地方，这一点是我们应该注意的，这也提醒了我们，不要想当然的认为不同语言，同名函数（方法）的功能是完全一致的，当我们遇到一些奇奇怪怪的问题时，多看官方文档才是硬道理。&lt;/p&gt;&lt;p&gt;本文将会持续修正和更新，最新内容请参考我的 &lt;a href=&quot;https://link.segmentfault.com/?enc=%2BqD1BHT8y58S%2Fah7Lnn3nA%3D%3D.qao2i7b4QmDPDMHacsCCM6Cj6fNhyfhTobCU7%2B9Oou4%3D&quot; rel=&quot;nofollow&quot;&gt;GITHUB&lt;/a&gt; 上的 &lt;a href=&quot;https://link.segmentfault.com/?enc=2OurG%2FjL8JsVrSm82H2Btg%3D%3D.LpI%2FvYxdOY5eJiVvelYkjPSVu6nl96WXoSXCtDJzSVW%2BujeUqqd3Oby0UkiSnb1V&quot; rel=&quot;nofollow&quot;&gt;程序猿成长计划&lt;/a&gt; 项目，欢迎 Star，更多精彩内容请 &lt;a href=&quot;https://link.segmentfault.com/?enc=nSY%2F9ieKl%2B67t6zSqlXhNQ%3D%3D.VWHJre%2BwPI%2FrFlO6chvzHSl6p%2Fl0%2FQFgirUMp79r428%3D&quot; rel=&quot;nofollow&quot;&gt;follow me&lt;/a&gt;。&lt;/p&gt;&lt;/article&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>c5d34166a254a543132bc6256e1501c6</guid>
<title>Spring Boot 3 的 AOT（GraalVM Native Image）应用开发</title>
<link>https://toutiao.io/k/dx4m4z4</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;article class=&quot;article-post&quot;&gt;
&lt;p&gt;GraalVM Native Images是一个利用AOT(Ahead-of-Time)技术把java程序直接编译成可执行程序的编译工具，编译出来的程序在运行时不再依赖JRE，同时启动速度快，资源消耗低，这对传统java程序来说都是极大的优势。同时云原生应用来说，GraalVM Native Images编译生成的程序体积很小，非常适合云原生环境，目前由于传统java程序生成的镜像中需要包含一个体积很大的JRE或JDK而经常被人诟病。
Spring Boot从3.0版本开始支持AOT技术。
具体的代码参照 &lt;a href=&quot;https://github.com/qihaiyan/spring-native&quot;&gt;示例项目 https://github.com/qihaiyan/spring-native&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;一概述&quot;&gt;一、概述&lt;/h2&gt;

&lt;p&gt;Spring Boot 3.0 仍然支持传统的开发方式，既编译生成jar包，通过JRE来执行，在此基础上，通过调整编译方式，可以编译生成直接运行的可执行程序，Spring AOT与传统应用的区别包括：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;程序运行时动态调整的资源无法直接使用，例如反射、动态代理等，需要在代码中通过Hint为编译器指定&lt;/li&gt;
  &lt;li&gt;应用的classpath在编译后就固定了，不能动态调整&lt;/li&gt;
  &lt;li&gt;类不会延迟加载（lazy loading），应用启动时一次性加载完成&lt;/li&gt;
  &lt;li&gt;部分java切面（AOP）技术不支持&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;二项目中加入依赖&quot;&gt;二、项目中加入依赖&lt;/h2&gt;

&lt;p&gt;在项目的gradle中增加依赖关系。&lt;/p&gt;

&lt;p&gt;Gradle:&lt;/p&gt;

&lt;div class=&quot;language-gradle highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;plugins&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;id&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;&#x27;org.springframework.boot&#x27;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;version&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;&#x27;3.0.0&#x27;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;id&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;&#x27;io.spring.dependency-management&#x27;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;version&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;&#x27;1.1.0&#x27;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;id&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;&#x27;org.graalvm.buildtools.native&#x27;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;version&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;&#x27;0.9.18&#x27;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;id&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;&#x27;java&#x27;&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;group&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;&#x27;cn.springcamp&#x27;&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;version&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;&#x27;0.0.1-SNAPSHOT&#x27;&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;sourceCompatibility&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;&#x27;17&#x27;&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;configurations&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;compileOnly&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;extendsFrom&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;annotationProcessor&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;testCompileOnly&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;extendsFrom&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;testAnnotationProcessor&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;repositories&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;mavenCentral&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;dependencies&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;implementation&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;&#x27;org.springframework.boot:spring-boot-starter-web&#x27;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;implementation&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;&#x27;org.springframework.boot:spring-boot-starter-data-jpa&#x27;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;implementation&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;&#x27;com.h2database:h2&#x27;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;annotationProcessor&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;&#x27;org.projectlombok:lombok&#x27;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;testAnnotationProcessor&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;&#x27;org.projectlombok:lombok&#x27;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;testImplementation&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;&#x27;org.springframework.boot:spring-boot-starter-test&#x27;&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;test&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;useJUnitPlatform&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;与传统Spring Boot应用相比，gradle文件中增加了 org.graalvm.buildtools.native 这个plugin，其它的没有区别。&lt;/p&gt;

&lt;h2 id=&quot;三主要程序代码&quot;&gt;三、主要程序代码&lt;/h2&gt;

&lt;p&gt;示例程序提供了一个rest接口，该接口从数据库中读取数据。为了便于演示，使用H2数据库。&lt;/p&gt;

&lt;p&gt;Application程序代码:&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nd&quot;&gt;@RestController&lt;/span&gt;
&lt;span class=&quot;nd&quot;&gt;@SpringBootApplication&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Application&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;nd&quot;&gt;@Autowired&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;DbService&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;dbService&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;

    &lt;span class=&quot;nd&quot;&gt;@RequestMapping&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;/hello&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;DemoData&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;hello&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;dbService&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;hello&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

    &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[]&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;args&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;nc&quot;&gt;SpringApplication&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;run&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;Application&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;class&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;args&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;DbService代码:&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nd&quot;&gt;@Component&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;DbService&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;nd&quot;&gt;@Autowired&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;TestDataRepository&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;testDataRepository&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;

    &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;DemoData&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;hello&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;nc&quot;&gt;DemoData&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;demoData&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;DemoData&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;demoData&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;testDataRepository&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;save&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;demoData&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;demoData&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;由于程序中没有使用反射，所以代码跟传统程序没有什么区别。&lt;/p&gt;

&lt;h2 id=&quot;三编译-native-image&quot;&gt;三、编译 Native Image&lt;/h2&gt;

&lt;p&gt;Spring Boot 编译 Native Image 支持2种方式，一种通过Docker进行编译，需要本地安装Docker。另外一种是用本地的编译环境进行编译，需要安装Visual Studio。
由于第一种方式比较简单，除了要安装Docker外没有很复杂的操作，本文只介绍第二种方式。&lt;/p&gt;

&lt;h3 id=&quot;31-安装编译环境&quot;&gt;3.1 安装编译环境&lt;/h3&gt;

&lt;p&gt;需要安装 GraalVM 和 Visual Studio 两个编译工具。
GraalVM可以直接下载安装，下载地址 https://www.graalvm.org/downloads/ ，也可以通过 &lt;a href=&quot;https://scoop.sh/&quot;&gt;Scoop&lt;/a&gt; 进行安装。
Visual Studio 需要下载安装，由于Visual Studio体积比较大，也可以只安装 &lt;a href=&quot;https://aka.ms/vs/17/release/vs_BuildTools.exe&quot;&gt;Visual Studio Build Tools&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&quot;32-执行编译命令&quot;&gt;3.2 执行编译命令&lt;/h3&gt;

&lt;p&gt;由于windows命令行工具有命令长度限制，因此编译命令不能在windows命令行工具中直接执行（包括powershell和cmd），需要在安装好的Visual Studio命令行工具（x64 Native Tools Command Prompt for VS 2022）中执行。&lt;/p&gt;

&lt;p&gt;执行命令&lt;/p&gt;



&lt;p&gt;编译生成的可执行程序在当前工程目录的 build\native\nativeTestCompile 目录中，可以看到一个与工程名相同的以exe后缀结尾的文件。
直接运行该文件，就能体验到java程序的启动速度竟然能如此之快。
启动速度虽然快了，但是编译耗时也多了不少，这是一个缺点。&lt;/p&gt;

&lt;h2 id=&quot;四单元测试&quot;&gt;四、单元测试&lt;/h2&gt;

&lt;p&gt;传统的Spring Boot单元测试技术仍然可以使用。 &lt;a href=&quot;https://springcamp.cn/spring-boot-unit-test/&quot;&gt;Spring Boot单元测试技术&lt;/a&gt;在这篇文章中有专门介绍。
需要注意的是 Spring Native不支持JUnit4，需要使用JUnit5。&lt;/p&gt;

&lt;p&gt;单元测试代码：&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nd&quot;&gt;@Slf4j&lt;/span&gt;
&lt;span class=&quot;nd&quot;&gt;@ExtendWith&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;SpringExtension&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;class&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;nd&quot;&gt;@SpringBootTest&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;webEnvironment&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;SpringBootTest&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;WebEnvironment&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;RANDOM_PORT&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;ApplicationTest&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;nd&quot;&gt;@Autowired&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;TestRestTemplate&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;testRestTemplate&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;

    &lt;span class=&quot;nd&quot;&gt;@Test&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;testHello&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;nc&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;resp&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;testRestTemplate&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;getForObject&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;/hello&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;class&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;info&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;hello result : {}&quot;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;resp&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;assertThat&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;resp&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;is&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;{\&quot;id\&quot;:1}&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;));&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;通过传统单元测试技术可以验证代码业务逻辑是正常的，对于编译成 Native Image 后程序是否还能正常运行，传统单元测试技术保证不了，需要进一步使用 Native Image 单元测试。&lt;/p&gt;

&lt;p&gt;Native Image 单元测试通过以下命令执行：&lt;/p&gt;



&lt;p&gt;该命令会首先把应用编译成 Native Image 可执行程序，再跑单元测试用例。由于  Native Image 编译相比传统应用耗时要长很多，所以先通过传统的Spring Boot单元测试技术保证代码业务逻辑正常后，再使用 Native Image 单元测试命令，减少整个开发流程的耗时。&lt;/p&gt;

&lt;/article&gt;


&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>c3fd25f004c09a83059119107cfc5f7f</guid>
<title>B站流式传输架构的前世今生</title>
<link>https://toutiao.io/k/q0yip4x</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.52&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/3EcuPIickyyEwbzUrMVnXJaXicEHYVRUz1Xar9X3Tic8ZUNJ3IfuVNP8wUpaKiafwYOY6lfXjlYbcJUJklKI7psbsg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;750&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;本期作者&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1.1921182&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/1BMf5Ir754QRKRlIsGfFjTlJDQbp5EoMAP2AToTAWC4FNwCAaCrE2Gkcl0UKNj4ibaC2BCMGcNnyqpoeyH6OXJQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;203&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;p&gt;王翔宇&lt;/p&gt;&lt;/section&gt;&lt;section&gt;&lt;p&gt;哔哩哔哩资深开发工程师&lt;/p&gt;&lt;p&gt;2017年加入B站，现服务于基础架构实时团队。先后负责B站日志系统、实时流式传输工作。&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;p&gt;魏泽丰&lt;/p&gt;&lt;/section&gt;&lt;section&gt;&lt;p&gt;哔哩哔哩高级开发工程师&lt;/p&gt;&lt;p&gt;2021年加入B站，现服务于基础架构实时团队，负责实时流式传输以及Flink CDC相关工作。&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/1BMf5Ir754QRKRlIsGfFjTlJDQbp5EoMAnP4f8l5gL39YH0JMry2W0XJfbE88WibzgO0VNKS38gvtqIFOmDkEwA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;566&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1.3046296&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/1BMf5Ir754QRKRlIsGfFjTlJDQbp5EoMqoRzKm44ccm043v6lwBFDHCPDjFnmKdCjDpMbonkO2W3zQpCBqyrOw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;p&gt;高瑞超&lt;/p&gt;&lt;/section&gt;&lt;section&gt;&lt;p&gt;哔哩哔哩资深开发工程师&lt;/p&gt;&lt;p&gt;2021年加入B站，现服务于基础架构实时团队，负责实时流式传输以及Flink connector相关工作。&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;01 背景&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;Lancer是B站的实时流式传输平台，承载全站服务端、客户端的数据上报/采集、传输、集成工作，秒级延迟，作为数仓入口是B站数据平台的生命线。目前每日峰值 5000w/s rps, 3PB/天, 4K+条流的数据同步能力。&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.3287037&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/1BMf5Ir754QRKRlIsGfFjTlJDQbp5EoMcld0oT6DNOftQxhcvusfu9TL2atIzdqOrDcCanKfK60Cx0yOicNZCEQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;服务如此大的数据规模，对产品的可靠性、可扩展性和可维护性提出了很高的要求。流式传输的实现是一个很有挑战的事情，聚焦快、准、稳的需求,  Lancer整体演进经历了大管道模型、BU粒度管道模型、单流单作业模型三个阶段的演进，下面我们娓娓道来。&lt;/p&gt;&lt;/section&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;02 关键词说明&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;logid：每个业务方上报的数据流以logid进行标识，logid是数据在传输+集成过程中的元信息标识。&lt;/p&gt;&lt;p&gt;数据源：数据进入到lancer的入口，例如：log-agent，bfe-agent，flink cdc&lt;/p&gt;&lt;p&gt;lancer-gateway（数据网关）：接收数据上报的网关。&lt;/p&gt;&lt;p&gt;数据缓冲层：也叫做内部kafka，用于解耦数据上报和数据分发。&lt;/p&gt;&lt;p&gt;lancer-collector（数据分发层）：也叫做数据同步，可以根据实际场景完成不同端到端的数据同步。&lt;/p&gt;&lt;/section&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;03 技术演进&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;整个B站流式数据传输架构的演进大致经历了三个阶段。&lt;/p&gt;&lt;/section&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt; 3.1 架构V1.0-基于flume的&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;大管道数据传输架构(2019之前)&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;B站流式传输架构建立之初，数据流量和数据流条数相对较少，因此采用了全站的数据流混合在一个管道中进行处理，基于flume二次定制化的数据传输架构，架构如下：&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.2824074&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/1BMf5Ir754QRKRlIsGfFjTlJDQbp5EoMSAibVbsjBuC0HFxEzgvU1rnQKrsHNpSicpDoYZo5tbpnpChibd4rGVonQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;整个架构从数据生成到落地分为：数据源、数据网关、数据缓冲、数据分发层。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;数据上报端基本采用sdk的方式直接发送http和grpc请求上报。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;数据网关lancer-gateway是基于flume二次迭代的数据网关，用于承载数据的上报，支持两种协议：http用于承载公网数据上报（web/app），grpc用于承载IDC内服务端数据上报。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;数据缓冲层使用kafka实现，用于解耦数据上报和数据分发。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;数据分发层lancer-collector同样是基于flume二次迭代的数据分发层，用于将数据从缓冲层同步到ODS。&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/section&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;v1.0架构在使用中暴露出一些的痛点：&lt;/p&gt;&lt;p&gt;1. 数据源端对于数据上报的可控性和容错性较差，例如：&lt;/p&gt;&lt;p&gt;2. 整体架构是一个大管道模型，资源的划分和隔离不明确，整体维护成本高，自身故障隔离性差。&lt;/p&gt;&lt;p&gt;3. 基于flume二次迭代的一些缺陷：&lt;/p&gt;&lt;/section&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt; 3.2 架构V2.0-BU粒度的&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;管道化架构(2020-2021)&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;针对v1.0的缺陷，我们引入了架构v2.0，架构如下：&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.3888889&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/1BMf5Ir754QRKRlIsGfFjTlJDQbp5EoMwDEp5av81PJA4CLAft4NvicSIY6GwXINhCgcsxRGUKJWtNxY3KaJ5uQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;此架构的关键细节如下：&lt;/p&gt;&lt;p&gt;1. 强化了数据上报源端的边缘可控能力&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;服务器上部署log-agent承载服务端数据上报。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;cdn上部署bfe-agent用于承载公网（web端、app端）数据上报。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;log-agent/bfe-agent中集成数据缓冲、预聚合、流控、重试、降级等能力，数据上报sdk只需专注数据的生成和上报逻辑。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;agent端基于logid的BU属性，将数据路由到不同的管道。&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;2. 数据管道以BU为粒度搭建，管道间资源隔离，每个管道包含整套独立的完整数据传输链路，并且数据管道支持基于airflow快速搭建。故障隔离做到BU级别。&lt;/p&gt;&lt;p&gt;3. 数据网关升级到自研lancer-gateway2.0，逻辑精简，支持流控反压，并且适配kafka failover， 基于k8s进行部署。&lt;/p&gt;&lt;p&gt;4. hdfs分发基于flink jar进行实现：支持exactly once语义保证。&lt;/p&gt;&lt;/section&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;V2.0架构相对于v1.0， 重点提升了数据上报边缘的可控力、BU粒度管道间的资源划分和隔离性。但是随着B站流式数据传输规模的快速增加，对数据传输的时效性、成本、质量也提出了越来越高的要求，V2.0也逐渐暴露出了一些缺陷：&lt;/p&gt;&lt;p&gt;1. logid级别隔离性差：&lt;/p&gt;&lt;p&gt;2. 网关是异步发送模型，极端情况下（组件崩溃），存在数据丢失风险。&lt;/p&gt;&lt;p&gt;3. ods层局部热点/故障影响放大&lt;/p&gt;&lt;p&gt;4. hdfs小文件问题放大&lt;/p&gt;&lt;/section&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;针对上述痛点，最直接的解决思路就是整体架构做进一步的隔离，以单logid为维度实现数据传输+分发。面临的挑战主要有以下几个方面：&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;如何保证全链路以logid为单位进行隔离，如何在资源使用可控的情况下合理控流并且保证数据流之间的隔离性&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;需要与外部系统进行大量的交互，如何适配外部系统的各种问题：局部热点、故障&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;集成作业的数量指数级增加，如何保障高性能、稳定性的同时并且高效的进行管理、运维、质量监控。&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/section&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt; 3.3 架构V3.0-基于Flink SQL的&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;单流单作业数据集成方案&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;在V3.0架构中，我们对整体传输链路进行了单作业单数据流隔离改造，并且基于Flink SQL支撑数据分发场景。架构如下：&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.4462963&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/1BMf5Ir754QRKRlIsGfFjTlJDQbp5EoM92iarl2RojRNficmaYTDeVexslK3OGnKVLWndDhiaX3ptwCk8DBE4ib49Q/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;相比v2.0, 资源池容量管理上依然以BU为粒度，但是每个logid的传输和分发相互独立，互不影响。具体逻辑如下 ：&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;agent：整体上报SDK和agent接收+发送逻辑按照logid进行隔离改造，logid间采集发送相互隔离。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;lancer-gateway3.0：logid的请求处理之间相互隔离，当kafka发送受阻，直接反压给agent端，下面详细介绍。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;数据缓冲层：每个logid对应一个独立的内部kafka topic，实现数据的缓冲。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;数据分发层：分发层对每个logid的启动独立的flink sql作业进行数据的分发，单个logid处理受阻，只会导致当个logid的数据堆积。&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/section&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;相较于之前的实现，v3.0架构具有以下的优势：&lt;/p&gt;&lt;p&gt;1. 可靠性：&lt;/p&gt;&lt;p&gt;2. 可维护性上：&lt;/p&gt;&lt;p&gt;3. 可扩展性：&lt;/p&gt;&lt;/section&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;04 V3.0架构具体实现&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;我们重点介绍下，当前V3.0结构各个分层的实现。&lt;/p&gt;&lt;/section&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt; 4.1 数据上报边缘层&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt; 4.1.1 log-agent&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;基于go自研，插件化架构，部署于物理机，可靠、高效的支持服务端数据上报。&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.2444444&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/1BMf5Ir754QRKRlIsGfFjTlJDQbp5EoMFOI3Ynnw4icNaHPXeuCqGJZCw4xDDJfmbWaMKibItgTx07Apib4tlYcXQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;时间架构分为收集、处理、发送三层，具有以下主要特性：&lt;/p&gt;&lt;/section&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt; 4.1.2 bfe-agent&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;基于go自研，部署于cdn，用于承载公网数据上报。&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.3611111&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/1BMf5Ir754QRKRlIsGfFjTlJDQbp5EoML7hCkh773jncf7LkFhfgNIfYnVtv9Tq5HXzYrMK4Us2mRwSDibPKMjw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;边缘cdn节点，cdn服务器上部署nginx和bfe-agent，bfe-agent整体实现架构与log-agent类似，对于web和app端数据上报请求QPS高、突发性强的特点，主要强化了以下能力：&lt;/p&gt;&lt;/section&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt; 4.2 数据上报网关层&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;v3.0方案中，数据数据网关的架构如下：&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.2583333&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/1BMf5Ir754QRKRlIsGfFjTlJDQbp5EoMF6sOwJMuac5fusqeR6QJxVWSL8fWiaAZw9rrBF5vIRSlZibXDL6v2WAQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;数据网关功能特性如下：&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;kafka的通用代理层：支持grpc /http协议&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;基于kafka send callback实现了同步发送模型，保证数据不丢：数据写入kafka后，再对请求返回ack&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;请求不拆分：基于agent的聚合机制，只支持单次请求单条记录，因此一条记录对应一条缓存层kakfa的消息&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;lancer-gateway3.0根据请求的topic信息，发送请求到对应的kafka集群&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;lancer-gateway3.0适配kafka集群的局部热点：支持partition动态剔除&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;logid与topic一一对应，处理流程中相互隔离：一个topic发送受阻，不影响其他的topic&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/section&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;整个数据网关中的实现难点是：单gateway承载多logid处理的过程中如何保证隔离性和公平性，我们参考了Golang 中GMP的机制，整体数据流程如下：&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.3851852&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/1BMf5Ir754QRKRlIsGfFjTlJDQbp5EoMicKzHBGSuNWrq6o3jDrGlOsZPAW0FYiadtId8GkjjF38FBz8aj4fn0Ew/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;1. 收到的请求，会把请求放到logid对应的请求队列，如果队列满，直接拒绝请求&lt;/p&gt;&lt;p&gt;2. 每个kafka集群，会初始化一个N大小的kafka producer pool，其中每个producer会遍历所有的队列，进行数据的发送。&lt;/p&gt;&lt;p&gt;3. 对于每个logid的请求队列，会从两个维护限制资源的占用，以保证公平性和隔离性&lt;/p&gt;&lt;/section&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt; 4.3 数据上报分发层&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.2601852&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/1BMf5Ir754QRKRlIsGfFjTlJDQbp5EoMGOO1ALHhJeqrZ8tNKibYtg5giazhVJdLemVI28OY5micZEjccAvL9GTMQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;随着flink在实时计算领域的成熟，其高性能、低延迟、exactly once语义保证、批流一体、丰富的数据源支持、活跃的社区等优势，促使我们选择了以flink sql作为数据分发层的解决方案。当前我们主要支持了kafka→hive, kafka→kafka, cdc→kafka-&amp;gt;hudi/hive三种场景：&lt;/p&gt;&lt;p&gt;1. kafka→hive&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;以流式方式，实时导入数据到hive。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;file rolling on check，保证exactly once。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;按照event time写入分区和归档，归档延迟小于15min&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;支持text+lzo(行存)和 orc+zstd（列存）两种存储格式。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;支持下游作业增量同步。&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;2. kafka→kafka&lt;/p&gt;&lt;p&gt;3. cdc→kafka-&amp;gt;hudi/hive&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.2564815&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/1BMf5Ir754QRKRlIsGfFjTlJDQbp5EoM1jg24A8jBJjvibdhsNHXPR323SYJbbFLyXvpaXknF4Db6vyh1Xic7CnA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;/&gt;&lt;section powered-by=&quot;xiumi.us&quot;/&gt;&lt;section powered-by=&quot;xiumi.us&quot;/&gt;&lt;section powered-by=&quot;xiumi.us&quot;/&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;05 Flink connector功能迭代&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;在Flink SQL数据分发场景的支持中，针对我们遇到的实际需求，对社区原生connector进行了对应的优化，我们针对性的介绍下。&lt;/p&gt;&lt;/section&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt; 5.1 hive sink connector优化&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;span&gt;断流空分区提交&lt;/span&gt;&lt;/p&gt;&lt;p&gt;背景：B站离线作业的拉起依赖上游分区提交，HDFS分区提交的判断依赖于作业整体watermark的推进，但是某些logid在断流的情况下，如何进行分区的提交呢&lt;/p&gt;&lt;p&gt;解决办法：&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.412037&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/1BMf5Ir754QRKRlIsGfFjTlJDQbp5EoMR7rJ0W0LruqaZnfENIp9Awtxvd2pDmtdLtic7CZicicicl9NCzgHpRvUNQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;如图所示：当所有的StreamFileWriter连续两次checkpoint内未处理任何数据的情况下，StreamingFileCommiter会判定发生了断流，按照当前时间提交分区。&lt;/p&gt;&lt;/section&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;支持下游增量数据同步&lt;/p&gt;&lt;p&gt;&lt;span&gt;背景：传统方式ods到dwd的数据同步只有当ods层分区ready之后才会开始，时效性较差，如何加速数据的同步？&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;span&gt;解决办法：&lt;/span&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;不依赖ods层分区ready，当ods目录中文件生成后，即可开始数据的处理，以增量的方式读取数据文件。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;通过HDFS的list操作来获取需要读取的文件，对NameNode压力较大，为此我们提供了文件list列表索引（包括文件名和数据条数），下游只需要读取索引，即可获取增量文件列表。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;实现中索引文件状态被持久化到state中，snapshot中生成.inflight状态临时文件，notifyCheckpointComplete中将文件rename成commit正式文件, 提供exactly once语义保证。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;下游作业读取文件索引，支持ods到dwd的增量数据同步。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.2268519&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/1BMf5Ir754QRKRlIsGfFjTlJDQbp5EoMRSLtibHAr8B9xEEcYAcu1DIINX4f86W7jPpswJ0RB5xj9Sb8kPkWC5g/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.212963&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/1BMf5Ir754QRKRlIsGfFjTlJDQbp5EoM9j6fywYSOrlsUGcdLPBLv8AdFAyyOtKClluYQtWYwAOseFgXEwDqBQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;span&gt;orc+zstd&lt;/span&gt;&lt;/p&gt;&lt;p&gt;背景：相较于行式存储，列式存储在压缩比上有着显著的优势。&lt;/p&gt;&lt;p&gt;解决办法：支持orc+zstd, 经过测试，相较于text+lzo，空间节省在40%以上。&lt;/p&gt;&lt;/section&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;span&gt;hdfs异步close&lt;/span&gt;&lt;/p&gt;&lt;p&gt;背景：snapshot阶段flush数据，close文件经常因为个别文件慢拖累整体吞吐。&lt;/p&gt;&lt;p&gt;&lt;span&gt;解决办法：&lt;/span&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;将close超时的文件扔到异步队列中。也就是 close 的动作不会去堵塞整个主链路的处理，提升hdfs局部热点情况下的吞吐。异步close 文件列表保存到pendingPartsForCurrentCheckpoint，并且持久化到 state 当中。故障恢复时，也能继续对文件进行关闭。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;异步close的引入，会引入分区提前创建的隐患，为此引入了对于bucket状态的判断。对于某分区，只有当隶属于此分区的所有bucket中的pendingPartsForCurrentCheckpoint为空（所有文件都进行了关闭），才在commit算子中进行分区的提交。&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;span&gt;小文件合并&lt;/span&gt;&lt;/p&gt;&lt;p&gt;背景：rolling on checkpoint的滚动策略，会导致文件数量的膨胀，对namenode产生较大的压力。&lt;/p&gt;&lt;p&gt;解决办法：&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.1722222&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/1BMf5Ir754QRKRlIsGfFjTlJDQbp5EoMWcG7HW2ylJfv2KjvKvAoicpKBDm64RQRlpLJPrOPrsdWl7YWlU51jNg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;引入了小文件合并功能，在checkpoint完成后，由 Streaming writer 的 notifyCheckpointComplete 方法触发合并操作，向下游发送EndCheckpoint信号。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;coordinator 收到每个writer的EndCheckpoint后，开始进行文件的分组，封装成一个个compactunit广播下游，全部unit发送完之后，再广播EndCompaction。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;compact operator找到属于自己的任务后开始处理，当收到EndCompaction后，往下游发送分区提交信息。&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/section&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt; 5.2 kafka connector优化&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;span&gt;支持protobuf format&lt;/span&gt;&lt;/p&gt;&lt;p&gt;背景：用户有处理protobuf格式数据的需求&lt;/p&gt;&lt;p&gt;解决办法：&lt;/p&gt;&lt;/section&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;span&gt;kafka sink支持自定义分流&lt;/span&gt;&lt;/p&gt;&lt;p&gt;背景：用户希望在一个sql作业中根据需要，灵活定制将消息发送到指定kafka 集群和topic。&lt;/p&gt;&lt;p&gt;解决办法：&lt;/p&gt;&lt;/section&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;c&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__function&quot;&gt;CREATE TABLE &lt;span class=&quot;code-snippet__title&quot;&gt;sink_test&lt;/span&gt; &lt;span class=&quot;code-snippet__params&quot;&gt;(&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  broker_name_arg varchar,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  topic_name_arg varchar,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  message &lt;span class=&quot;code-snippet__built_in&quot;&gt;string&lt;/span&gt;,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  t1 &lt;span class=&quot;code-snippet__built_in&quot;&gt;string&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;WITH&lt;/span&gt;&lt;span class=&quot;code-snippet__params&quot;&gt;(&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__string&quot;&gt;&#x27;bootstrapServers&#x27;&lt;/span&gt; = &lt;span class=&quot;code-snippet__string&quot;&gt;&#x27;BrokerUdf(broker_name_arg)&#x27;&lt;/span&gt;, &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__string&quot;&gt;&#x27;bootstrapServers.udf.class&#x27;&lt;/span&gt; = &lt;span class=&quot;code-snippet__string&quot;&gt;&#x27;com.bilibili.lancer.udf.BrokerUdf&#x27;&lt;/span&gt;, &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__string&quot;&gt;&#x27;topic&#x27;&lt;/span&gt; = &lt;span class=&quot;code-snippet__string&quot;&gt;&#x27;TopicUdf(broker_name_arg, topic_name_arg)&#x27;&lt;/span&gt;, &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__string&quot;&gt;&#x27;topic.udf.class&#x27;&lt;/span&gt; = &lt;span class=&quot;code-snippet__string&quot;&gt;&#x27;com.bilibili.lancer.udf.TopicUdf&#x27;&lt;/span&gt;, &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__string&quot;&gt;&#x27;udf.cache.min&#x27;&lt;/span&gt; = &lt;span class=&quot;code-snippet__string&quot;&gt;&#x27;1&#x27;&lt;/span&gt;, &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__string&quot;&gt;&#x27;exclude.udf.field&#x27;&lt;/span&gt; = &lt;span class=&quot;code-snippet__string&quot;&gt;&#x27;false&#x27;&lt;/span&gt;, &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__string&quot;&gt;&#x27;connector&#x27;&lt;/span&gt; = &lt;span class=&quot;code-snippet__string&quot;&gt;&#x27;kafka-diversion&#x27;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;)&lt;/span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt; 5.3 cdc connector优化&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;span&gt;sql场景下多库多表场景支持&lt;/span&gt;&lt;/p&gt;&lt;p&gt;背景：原生的flink cdc source在单个sql任务中，只能同步相同DDL定义的表，如果需要同步异构DDL，不得不启动多个独立的job进行同步。这样会存在资源的额外开销。&lt;/p&gt;&lt;p&gt;解决办法：&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6925926&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/1BMf5Ir754QRKRlIsGfFjTlJDQbp5EoMpxSZmOAXI9uTg9MRXdBcgIxUssz8ygNbrMZXpVY7bGRPYIAQicIibPGg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;/&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;span&gt;断流场景分区提交支持&lt;/span&gt;&lt;/p&gt;&lt;p&gt;背景：由于整个cdc方案存在上游和下游两个独立的job，并且都是基于event time推进watermark做分区的提交，下游watermark的推进受阻可能受到数据正常断流或者上游作业异常两种原因的影响，如果正确判断呢？&lt;/p&gt;&lt;p&gt;解决办法：&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5259259&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/1BMf5Ir754QRKRlIsGfFjTlJDQbp5EoMia4yDibEwicxlbuOqWG79VuPUHHWSDcWPDNucSef1IuScmiap8U06BsYIA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;/&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;c&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__function&quot;&gt;CREATE TABLE &lt;span class=&quot;code-snippet__title&quot;&gt;mysql_binlog&lt;/span&gt; &lt;span class=&quot;code-snippet__params&quot;&gt;(&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  host_name STRING METADATA              FROM &lt;span class=&quot;code-snippet__string&quot;&gt;&#x27;host_name&#x27;&lt;/span&gt; VIRTUAL,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  db_name STRING METADATA                FROM &lt;span class=&quot;code-snippet__string&quot;&gt;&#x27;database_name&#x27;&lt;/span&gt; VIRTUAL,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  table_name STRING METADATA             FROM &lt;span class=&quot;code-snippet__string&quot;&gt;&#x27;table_name&#x27;&lt;/span&gt; VIRTUAL,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  operation_ts TIMESTAMP(&lt;span class=&quot;code-snippet__number&quot;&gt;3&lt;/span&gt;) METADATA     FROM &lt;span class=&quot;code-snippet__string&quot;&gt;&#x27;op_ts&#x27;&lt;/span&gt; VIRTUAL,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  sequence BIGINT METADATA               FROM &lt;span class=&quot;code-snippet__string&quot;&gt;&#x27;sequence&#x27;&lt;/span&gt; VIRTUAL,  &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  heartbeat BOOLEAN METADATA             FROM &lt;span class=&quot;code-snippet__string&quot;&gt;&#x27;heartbeat&#x27;&lt;/span&gt;VIRTUAL, &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  mtime TIMESTAMP(&lt;span class=&quot;code-snippet__number&quot;&gt;3&lt;/span&gt;) METADATA            FROM &lt;span class=&quot;code-snippet__string&quot;&gt;&#x27;mtime&#x27;&lt;/span&gt;VIRTUAL, &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  id BIGINT NOT &lt;span class=&quot;code-snippet__literal&quot;&gt;NULL&lt;/span&gt;,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  filed_list BYTES NOT &lt;span class=&quot;code-snippet__literal&quot;&gt;NULL&lt;/span&gt;,  &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  PRIMARY KEY(id) NOT ENFORCED&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;WITH&lt;/span&gt; &lt;span class=&quot;code-snippet__params&quot;&gt;(&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  &lt;span class=&quot;code-snippet__string&quot;&gt;&#x27;connector&#x27;&lt;/span&gt; = &lt;span class=&quot;code-snippet__string&quot;&gt;&#x27;mysql-cdc&#x27;&lt;/span&gt;,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  &lt;span class=&quot;code-snippet__string&quot;&gt;&#x27;hostname&#x27;&lt;/span&gt; = &lt;span class=&quot;code-snippet__string&quot;&gt;&#x27;xxxx&#x27;&lt;/span&gt;,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  &lt;span class=&quot;code-snippet__string&quot;&gt;&#x27;port&#x27;&lt;/span&gt; = &lt;span class=&quot;code-snippet__string&quot;&gt;&#x27;3552&#x27;&lt;/span&gt;,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  &lt;span class=&quot;code-snippet__string&quot;&gt;&#x27;username&#x27;&lt;/span&gt; = &lt;span class=&quot;code-snippet__string&quot;&gt;&#x27;datacenter_cdc&#x27;&lt;/span&gt;,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  &lt;span class=&quot;code-snippet__string&quot;&gt;&#x27;password&#x27;&lt;/span&gt; = &lt;span class=&quot;code-snippet__string&quot;&gt;&#x27;xxx&#x27;&lt;/span&gt;,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  &lt;span class=&quot;code-snippet__string&quot;&gt;&#x27;database-name&#x27;&lt;/span&gt; = &lt;span class=&quot;code-snippet__string&quot;&gt;&#x27;xxx&#x27;&lt;/span&gt;,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  &lt;span class=&quot;code-snippet__string&quot;&gt;&#x27;debezium.format&#x27;&lt;/span&gt; = &lt;span class=&quot;code-snippet__string&quot;&gt;&#x27;bytes&#x27;&lt;/span&gt;,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  &lt;span class=&quot;code-snippet__string&quot;&gt;&#x27;table-name&#x27;&lt;/span&gt; = &lt;span class=&quot;code-snippet__string&quot;&gt;&#x27;xxx&#x27;&lt;/span&gt;,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  &lt;span class=&quot;code-snippet__string&quot;&gt;&#x27;server-time-zone&#x27;&lt;/span&gt; = &lt;span class=&quot;code-snippet__string&quot;&gt;&#x27;Asia/Shanghai&#x27;&lt;/span&gt;,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  &lt;span class=&quot;code-snippet__string&quot;&gt;&#x27;heartbeat.enable&#x27;&lt;/span&gt;=&lt;span class=&quot;code-snippet__string&quot;&gt;&#x27;true&#x27;&lt;/span&gt;,  &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  &lt;span class=&quot;code-snippet__string&quot;&gt;&#x27;scan.incremental.snapshot.chunk.size&#x27;&lt;/span&gt; = &lt;span class=&quot;code-snippet__string&quot;&gt;&#x27;80960&#x27;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;)&lt;/span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;06 架构稳定性优化&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;为了保障流式传输稳定和高效运行，我们在以下几个方面做了一些优化，分别介绍下：&lt;/p&gt;&lt;/section&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt; 6.1 管道热点优化&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;作业在正常运行的过程中，经常遇到局部热点问题，例如kafka/hdfs io热点导致局部并行度消费速度下降或者写入受阻、yarn队列机器load不均匀导致作业部分并行度消费能力不如，虽然原因多种多样，但是本质看，这些问题的一个共性就是由于局部热点导致局部数据延迟。针对这个问题，我们分别从局部流量调度和全局流量调度两个维度进行优化。&lt;/p&gt;&lt;/section&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;局部流量调度&lt;/p&gt;&lt;/section&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;span&gt;局部流量调度的优化思路是在单个producer和task内部，分区之间进行流量的重分配。目前在两个点就行了优化：&lt;/span&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;bsql Task manager内部subtask上下游通信优化：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;集成作业并没有keyby的需求，基于Flink Credit-based Flow Control反压机制，可以通过Backlog Size判断下游任务的处理负载，那么我们就可以将Round-robin发送的方式修改为根据Channel的Backlog Size信息选择负载更低的下游Channel发送的方式。注意：此种策略只有source和sink端之间是rebalance/rescale时，才有效果。会造成一定的序列化开销，但是测试下来可以接受。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.3222222&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/1BMf5Ir754QRKRlIsGfFjTlJDQbp5EoMlj1AULzUmJoggwetGDAh5eIV58OIQ0XsNXNwnt26aicqe4SxRsfLvyg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;kafka producer partition自动剔除机制：&lt;/p&gt;&lt;p&gt;kafka producer在发送数据callback异常（绝大多数是timeout）超出一定的阈值，会将对应tp从available partition list中进行剔除，后续record将不再发送到剔除的tp。同时，被剔除tp后续将进行恢复性测试，如果数据可以正常发送，将重新放入到available partition list中。目前此机制在flink kafka sink connector和标准kafka client都进行了实现。&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/section&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;全局流量调度&lt;/p&gt;&lt;/section&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;全局流量调度的优化思路是整个传输链路层级之间的流量调配，目前我们将生产者(lancer-gateway)与消费者(flink sql kafka source)进行联动，当消费者出现tp消费lag的情况，通过注册黑名单（lag partition）到zookeeper，上游生产者感知黑名单，停止向高lag partition中继续发送数据。&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.3935185&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/1BMf5Ir754QRKRlIsGfFjTlJDQbp5EoMRLjq48JgOyDveAECchWeOTvx8rF8CwzmSEyDdAPdyxfQmDn0ctxcDA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;Flink kafka source中基于flink AggregateFunction机制，kafka source subtask上报lag到job manager，job manager基于全局lag判断注册黑名单到zookeeper&lt;/p&gt;&lt;p&gt;黑名单判断逻辑：当单tp lag &amp;gt; min(全局lag平均值，全局lag中位数）* 倍数 &amp;amp;&amp;amp; 单tp lag 大于 lag绝对值， 其中 &quot;单tp lag 大于 lag绝对值&quot; 是为了规避此机制过于敏感，&quot;单tp lag &amp;gt; min(全局lag平均值，全局lag中位数）* 倍数&quot; 用于筛选出头部的lag tp。为了防止黑名单比例过大，黑名单剔除的tp数量上限不得大于全部tp数量的一定比例。&lt;/p&gt;&lt;p&gt;局部流量调度和全局流量调度在管道热点优化效果上存在一定的互补性，但是也各有优势。&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.2888889&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/1BMf5Ir754QRKRlIsGfFjTlJDQbp5EoMd3ic3IzxicBa8dNjj1D8Qlo82Jg3DBhpPBO6kic2fGUMkcbXHj7xGibylw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt; 6.2 全链路埋点质量监控&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;数据质量是重要一环，通常数据质量包含完整性、时效性、准确性、一致性、唯一性等方面，对于数据传输场景，当面我们重点关注完整性和时效性两个方面&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.3594891&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/1BMf5Ir754QRKRlIsGfFjTlJDQbp5EoM2zgnXW6lxJGZ911vuQsibvk2FWHGDWP7D0IbS2dSefbotzoeB7qGMEA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;548&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;整体质量方案大致包含监控数据采集和规则配置两个大的方向，整体架构如下：&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.3824074&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/1BMf5Ir754QRKRlIsGfFjTlJDQbp5EoMIfptogEcMPnGgvLrAFhhicj6VmuhQSCajz0BjcqibqzjHkc9mRrp9Srw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;监控数据采集&lt;/p&gt;&lt;/section&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;我们自研了trace系统：以logid为单位，我们在数据处理流程中的每一层都进行了监控埋点&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;每层埋点包含三个方面：接收、发送、内部错误。所有埋点数据以数据创建时间（ctime）进行窗口对齐，并且通过更新utime以统计层间和层内的处理耗时。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;通过监控埋点可以实时统计出：端到端、层级间、层级内部的数据处理耗时、完整性、错误数。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;当前方案缺陷：flink sql挂掉从ck恢复，监控数据不能保证幂等，后续需要进一步改进。&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.337963&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/1BMf5Ir754QRKRlIsGfFjTlJDQbp5EoMnxuOCaLXezRRV3evZrwQn3osHtiaEcBOjubGFtE5uoCxAqWfz1iaYTAQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;监控报警规则&lt;/p&gt;&lt;/section&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;我们针对数据流进行了分级，每个等级指定了不同的保障级别（SLA），SLA破线，报警通知oncall同学处理。&lt;/p&gt;&lt;p&gt;延迟归档报警：hdfs分区提交延迟，触发报警。&lt;/p&gt;&lt;p&gt;实时完整性监控：基于trace数据，实时监控端到端的完整性，接收条数/落地条数&lt;/p&gt;&lt;p&gt;离线数据完整性：hdfs分区ready后，触发dqc规则运行，对比接收条数（trace数据）/落地条数（hive查询条数）&lt;/p&gt;&lt;p&gt;传输延迟监控：基于trace数据，计算端到端数据传输延迟的分位数。&lt;/p&gt;&lt;p&gt;DQC阻塞：离线数据完整性异常后，阻塞下游作业的调度。&lt;/p&gt;&lt;/section&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt; 6.3 kafka同步断流重复优化&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;相对比2.0方案中flume方案，基于flink sql的kafka到kafka的实现方案明显的一个变化就是作业的重启、故障恢复会导致整体的断流和一定比例的数据重复（从checkpoint恢复），因此如何降低用户对此类问题的感知，至关重要。&lt;/p&gt;&lt;/section&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;首先梳理下可能造成问题出现的原因：1）作业升级重启 2）task manager故障 3）job manager 故障 4）checkpoint连续失败，同时根据flink job整体提交流程，影响作业恢复速度的关键环节是资源的申请。根据上述分析和针对性测试，针对kafka同步场景的断流重复采用了如下优化方式：&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;checkpoint interval设置成10s：降低从checkpoint恢复导致的数据重复比例&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;基于session模式提交作业：作业重启无需重复申请资源&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;jobmanager.execution.failover-strategy=region，单个tm挂掉后，只恢复对应的region，不用恢复整个作业。集成作业DAG相对简单，可以尽量规避rebalance的出现，降低恢复的比例。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;使用小资源粒度task manager（2core cpu，8GB memory，2 slot）：同等资源规模下，tm数量变多，单tm挂掉影响程度明显变低。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;针对高优作业冗余task manager：冗余一个tm，当单个tm挂掉情况下，流量几乎没受影响&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;基于zookeeper实现job manager ha：在开启jm ha后，jm挂掉任务未断流&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;针对checkpoint连续失败的场景，我们引入了regional checkpoint，以region（而不是整个topology）作为checkpoint管理的单位，防止个别task的ck失败造成整个作业的失败，可以有效防止在个别task的ck连续失败的情况下需要回溯的数据量，减小集群波动（网络，HDFS IO等）对checkpoint的影响&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/section&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;经过上述优化，经过测试一个（50core，400GB memory，50 slot）规模的作业，优化效果如下：&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.2504708&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/1BMf5Ir754QRKRlIsGfFjTlJDQbp5EoMfDFrxyibX10iaUHiah0CsLBBaI3tLJ1ElcJsWzEQYFrLRhWSSxsetMQMw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1062&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt; 6.4 kafka流量动态failover能力&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;为了保证数据及时上报，Lancer对于数据缓冲层的kafka的发送成功率依赖性很高，经常遇到的case是高峰期或者流量抖动导致的kafka写入瓶颈。参考Netflix Hystrix 熔断原理，我们在网关层实现了一种动态 kafka failover机制：网关可以根据实时的数据发送情况计算熔断率，根据熔断率将流量在normal kafka和failover kafka之间动态调节。&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.1611111&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/1BMf5Ir754QRKRlIsGfFjTlJDQbp5EoMOxJa4wpqDMy9AR3C2U5ibclDLGLtM21jWLQFM8XA8efwKbRlBVxF5Xg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;/&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1.2722689&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/1BMf5Ir754QRKRlIsGfFjTlJDQbp5EoM6icichI5wb0CveTy8SibvOibBHnl67Jst39Gk8b0muvyvdQRH3gS7kurcA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;595&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt; 6.5 全链路流控、反压、降级&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;从端上上报到数据落地的整个流程中，为了保证稳定性和可控性，除了前述手段，我们还引入了整体流控、反压、降级等技术手段，下面综合介绍下。&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.3805556&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/1BMf5Ir754QRKRlIsGfFjTlJDQbp5EoMaskHtVVP999fXV9ZXkZg0qpAtyHD9ibNrGCqUOvampx2p5GQCaC41hw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;从后向前，分为几个环节：&lt;/p&gt;&lt;p&gt;1. 数据分发层: &lt;/p&gt;&lt;p&gt;2. 数据网关层：&lt;/p&gt;&lt;p&gt;3. 数据上报层：&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;适配数据网关的流控返回：做退避重试&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;基于本地磁盘进行数据的堆积&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;配置动态推送生效主动采样/降级堆积&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/section&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt; 6.6 开发阶段质量验证&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;为了在开发阶段保证整体服务的正确性和稳定性，开发阶段我们设计了一套完整的测试框架。&lt;/p&gt;&lt;/section&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;07 未来展望&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.4222222&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/1BMf5Ir754QRKRlIsGfFjTlJDQbp5EoMbzKWhA2NqZtZ7kvjUkAdpORh8SdlA8Zg36iazYhgJw9H4w5ZGKqjRgA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;链路架构升级，接入公司级的数据网关（Databus），架构统一并且可以涵盖更多的数据上报场景。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;云原生，拥抱K8S，面向用户quota管理，并且实现自动资源AutoScale。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;拥抱批流一体，强化增量化集成，覆盖离线批集成场景，打造统一基于Flink的统一化集成框架。&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.52&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/3EcuPIickyyEwbzUrMVnXJaXicEHYVRUz1Xar9X3Tic8ZUNJ3IfuVNP8wUpaKiafwYOY6lfXjlYbcJUJklKI7psbsg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;750&quot;/&gt;&lt;/p&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>