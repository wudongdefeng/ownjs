<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>e2437de811620049013bfb0665bb6fea</guid>
<title>推荐 4 个开源工具</title>
<link>https://toutiao.io/k/g30nqhu</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content             autoTypeSetting24psection&amp;#10;            &quot; id=&quot;js_content&quot;&gt;&lt;section data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;span&gt;Hi，艾瑞巴蒂，晚上好！今天推荐 4 个登上 GitHub 热搜的开源项目，它们分别是：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;1. 炫酷的 UI 工具：glslViewer&lt;/section&gt;&lt;p&gt;2. Textual&lt;/p&gt;&lt;p&gt;3. ToolJet：开源的低代码开发框架&lt;/p&gt;&lt;p&gt;4.  Linux 命令大全搜索工具&lt;/p&gt;&lt;hr/&gt;&lt;section&gt;&lt;span&gt;01&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;炫酷的 UI 工具：glslViewer&lt;/span&gt;&lt;/p&gt;&lt;p&gt;glslViewer 是由 @patriciogonzalezvivo 发布的，无需 UI 就能够显示 2D/3D GLSL 着色器，目前在 Github 上已经获得了 3.6k 的 stars。&lt;/p&gt;&lt;p&gt;可以使用 Python 或者任何可以和 glslViewer back/forth communication 的工具来定制喜欢的 UI。接下来，让我们一起欣赏炫酷画面~~&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.85875&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/ePw3ZeGRruw9icwlLVIghYgr2ia8bZLP3IaF1PDquP4c4k3IHpbgEkbN8epYUhSqYTYRLm1bE8yYNnTZckND3ghw/640?wx_fmt=gif&quot; data-type=&quot;gif&quot; data-w=&quot;800&quot;/&gt;&lt;/p&gt;&lt;p&gt;开源地址：https://github.com/patriciogonzalezvivo/glslViewer&lt;/p&gt;&lt;h1&gt;02&lt;/h1&gt;&lt;p&gt;&lt;span&gt;Textual&lt;/span&gt;&lt;/p&gt;&lt;p&gt;Textual 是由 @Textualize 开源基于 Python 框架搭建，可以创建能够在终端运行的交互式应用程序，作者的设计灵感来源于现代的 Web 开发，目前在 Github 上已经获得了 15.2k 的 stars。&lt;/p&gt;&lt;p&gt;Textual  使用 Rich 来渲染富文本，所以 Rich 可以渲染的任何东西都可以在 Textual 中使用。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ePw3ZeGRruw9icwlLVIghYgr2ia8bZLP3IBxx8icd0Sd6UE3ianVRBOhJOFDpttQcXeq2d4TqahHCBJJKhrpSFu9nw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1.1879629629629629&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ePw3ZeGRruw9icwlLVIghYgr2ia8bZLP3IsriaxiaEB2CKwYXUIT7t9CyuJc2LC47G94PHl3TwytgONSCwclTpAopQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/p&gt;&lt;p&gt;开源地址：https://github.com/Textualize/textual&lt;/p&gt;&lt;h1&gt;03&lt;/h1&gt;&lt;p&gt;&lt;span&gt;ToolJet：开源的低代码开发框架&lt;/span&gt;&lt;/p&gt;&lt;p&gt;ToolJet 是一个开源的低代码开发框架，拥有丰富的可视化工具，仅需要几步就可以快速构建和部署企业级工具，目前在 Github 已经获得了 14.5k 的 stars。&lt;/p&gt;&lt;p&gt;ToolJet 支持连接多种数据源，包括数据库、云平台、第三方服务接口等 40 多种数据源。在应用层可以发布到 APP、制作数据面板、表单等。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5488888888888889&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ePw3ZeGRruw9icwlLVIghYgr2ia8bZLP3IOa1Yz6lDZOrLLN9aVeyFicafqqujHmgbdbWmibpviaMzbNG9tQsTwzr8A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;900&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5731481481481482&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ePw3ZeGRruw9icwlLVIghYgr2ia8bZLP3InibyS8fu4ZmeWVXGsx1cuuNLKYT6x6ez3zV4BjYGZjxk1hwNJGKRa2w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5981481481481481&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ePw3ZeGRruw9icwlLVIghYgr2ia8bZLP3IKib0Exr4PZicK7Osgia1DPxJNWmXB4iaia87xIKJ62IeoMiadAr5PZZdsuZQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5981481481481481&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ePw3ZeGRruw9icwlLVIghYgr2ia8bZLP3I6Ly4xecOPqwDblHKT5yK2R2BichG11hULAcpsVwSuR5pJBYM8cgHMzw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/p&gt;&lt;p&gt;开源地址：https://github.com/ToolJet/ToolJet&lt;/p&gt;&lt;h1&gt;04&lt;/h1&gt;&lt;p&gt;&lt;span&gt;Linux 命令大全搜索工具&lt;/span&gt;&lt;/p&gt;&lt;p&gt;Linux Command 是 Linux 命令大全搜索工具，该工具当前搜集了 570 多个 Linux 命令，主要内容包含：Linux 基础命令、Linux 学习资源整理，例如社区网站、相关知识、软件工具、开源镜像站点等，目前在 Github 已经获得 20.8k 的 stars。&lt;/p&gt;&lt;p&gt;该工具支持移动端和 Web 搜索，默认从 A-Z 排序，每条命令都会有注释说明，带有语法、参数及命令示例~逛姐觉得非常贴心，墙裂推荐！！！&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.35600425079702447&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ePw3ZeGRruw9icwlLVIghYgr2ia8bZLP3I3QyHhWaJw8WvcBMWfjViaibVJLsUJE2egib8qFfECBzAfovjTupDHU4Hw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;941&quot;/&gt;&lt;/p&gt;&lt;p&gt;开源地址：https://wangchujiang.com/linux-command/&lt;/p&gt;&lt;p&gt;&lt;span&gt;历史盘点&lt;/span&gt;&lt;/p&gt;&lt;section&gt;逛逛 GitHub 每天推荐一个好玩有趣的开源项目。历史推荐的开源项目已经收录到 GitHub 项目，欢迎 Star：&lt;/section&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;javascript&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;https:&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.8091503267973856&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ePw3ZeGRruzicgHPfCeAsrkT2JZwiaOF05zRiaXr2dUukXKGk8CJwfrXALKJ5l0fLpV2abibCYKb7d8B7vNp2u3iccg/640?wx_fmt=png&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; data-type=&quot;png&quot; data-w=&quot;1530&quot;/&gt;&lt;br/&gt;&lt;/section&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-paragraph-type=&quot;ignored&quot;&gt;&lt;hr/&gt;&lt;/section&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;section&gt;&lt;span&gt;推荐阅读&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;&lt;em&gt;&lt;span&gt;1. &lt;/span&gt;&lt;/em&gt;&lt;/span&gt;&lt;span&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzUxNjg4NDEzNA==&amp;amp;mid=2247498662&amp;amp;idx=1&amp;amp;sn=0087c4f3b79ba3420e917e9b42d45eda&amp;amp;chksm=f9a2286fced5a1794eb9a73d0be7c2e16eaceabf3a0420647c40cb4202bd116d9a15dd57c008&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot; hasload=&quot;1&quot; wah-hotarea=&quot;click&quot;&gt;GitHub 上有什么好玩的项目？&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;em&gt;&lt;span&gt;2.&lt;/span&gt;&lt;/em&gt;&lt;span&gt; &lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzUxNjg4NDEzNA==&amp;amp;mid=2247507541&amp;amp;idx=1&amp;amp;sn=79edebda20ac94221aa641090fc9878e&amp;amp;chksm=f9a20d9cced5848a5ba699a819f52907f537e557c10c7bb24bf87b2e0212feecfb06419b2feb&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;推荐一款高颜值网易云播放器&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot; wah-hotarea=&quot;click&quot; hasload=&quot;1&quot;&gt;推荐一款高颜值网易云播放器&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;em&gt;&lt;span&gt;3. &lt;/span&gt;&lt;/em&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzUxNjg4NDEzNA==&amp;amp;mid=2247500031&amp;amp;idx=1&amp;amp;sn=b4349fc85264c255bf9a22e1f25b035a&amp;amp;chksm=f9a21336ced59a20518444a3e2bddb584f6d02266e831546ee5c00935d01d5bd61ed86ab606f&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot; hasload=&quot;1&quot; wah-hotarea=&quot;click&quot;&gt;基于 Spring Boot 的百度云高仿项目&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;em&gt;&lt;span&gt;4. &lt;/span&gt;&lt;/em&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzUxNjg4NDEzNA==&amp;amp;mid=2247498464&amp;amp;idx=1&amp;amp;sn=4f85123d6ca67578ca7bad8f7dc71453&amp;amp;chksm=f9a22929ced5a03ffded2c41fd257d3eb96be02195de3ca66a083177bf5f73e2f418728f7f06&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot; hasload=&quot;1&quot; wah-hotarea=&quot;click&quot;&gt;盘点百度 4 个牛逼哄哄的开源项目&lt;/a&gt;&lt;/p&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzUxNjg4NDEzNA==&amp;amp;mid=2247498464&amp;amp;idx=1&amp;amp;sn=4f85123d6ca67578ca7bad8f7dc71453&amp;amp;chksm=f9a22929ced5a03ffded2c41fd257d3eb96be02195de3ca66a083177bf5f73e2f418728f7f06&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot; hasload=&quot;1&quot; wah-hotarea=&quot;click&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;172&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;172&quot; data-ratio=&quot;1.005449591280654&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ePw3ZeGRruxW7LMX2Iz5DfjRIbFTS7UROhxibBmicicT0HpjIh1yniaJJibSnLFuicMHRx5NEdiaOh2OOACfr6MvR38ibQ/640?wx_fmt=png&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; data-type=&quot;png&quot; data-w=&quot;734&quot;/&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;mp-style-type data-value=&quot;3&quot;/&gt;&lt;/p&gt;&lt;/div&gt;

          
        &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>2638db18b14d1c0f423ceab33671904d</guid>
<title>认识区块链，认知区块链——Web3</title>
<link>https://toutiao.io/k/78f76n5</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;profile_inner&quot;&gt;
                  &lt;strong class=&quot;profile_nickname&quot;&gt;MavenTalk&lt;/strong&gt;
                  &lt;img class=&quot;profile_avatar&quot; id=&quot;js_profile_qrcode_img&quot; src=&quot;&quot; alt=&quot;&quot;/&gt;

                  &lt;p class=&quot;profile_meta&quot;&gt;
                  &lt;label class=&quot;profile_meta_label&quot;&gt;Weixin ID&lt;/label&gt;
                  &lt;span class=&quot;profile_meta_value&quot;&gt;mavenTalk&lt;/span&gt;
                  &lt;/p&gt;

                  &lt;p class=&quot;profile_meta&quot;&gt;
                  &lt;label class=&quot;profile_meta_label&quot;&gt;About Feature&lt;/label&gt;
                  &lt;span class=&quot;profile_meta_value&quot;&gt;创业者，关注人与自然的和谐成长.&lt;/span&gt;
                  &lt;/p&gt;
                &lt;/div&gt;
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>912e60a13dffef733e08bffd6fa38523</guid>
<title>Flink 反压原理深入浅出及解决思路</title>
<link>https://toutiao.io/k/cnvz5r1</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content             autoTypeSetting24psection&amp;#10;            &quot; id=&quot;js_content&quot;&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;1. 前言&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Apache Flink 是一个分布式大数据处理引擎，可对有限数据流和无限数据流进行有状态或无状态的计算，能够部署在各种集群环境，对各种规模大小的数据进行快速计算。既然是对流式数据进行处理，那么就要面临数据在流动计算时，上下游数据通信以及数据处理速度不一致所带来的问题。&lt;br/&gt;本文先从「生产者-消费者模式」的角度介绍了Flink中的数据传输，从而引出了「反压」的概念。接着介绍了Flink在V1.5前「基于TCP的反压机制」以及V1.5后「基于Credit的反压机制」分别如何实现网络流控。最后针对一个反压案例进行分析，介绍了如何进行反压定位和资源调优，并展示了调优结果。&lt;br/&gt;希望在阅读完本文后，读者可以深入理解Flink节点反压的概念以及背后的原理，在遇到反压场景时，能够快速定位瓶颈点，并拥有一套基本的调优思路。&lt;/p&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;2. 从Flink数据传输看「反压」&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;2.1 生产者-消费者模式&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Flink作业在运行状态时，数据会在各个TaskManager（TM）之间流动交换，上游TM到下游TM的数据传输，可以简单看作是生产者&amp;amp;消费者模式。&lt;br/&gt;下面将会介绍 Producer 和 Consumer 在吞吐率&lt;strong&gt;不同&lt;/strong&gt;时，导致的普遍性问题。&lt;br/&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.759656652360515&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/1skeHK2Gybwtm3boGkxFwnF811Jz3tzophIYg1n06lNfcOYlFiaFugJKkxGxS7jK1QRTdxq0iax9phYIIlLe7G8Q/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;932&quot;/&gt;&lt;br/&gt;假设 Producer的吞吐率为 2 MB/s，Consumer是 1 MB/s ，此时上游产生数据的速度 大于 下游处理数据的速度，且假设两端都存在Buffer，用来暂时存放数据，再假设底层网络传输速度为 2 MB/s。&lt;br/&gt;若Buffer有界，经过5s后，Consumer 端的 Receive Buffer 会被打满，后面新到达的数据就只能被丢弃掉；但在实际场景中，通常生产者在发送数据前会检查 buffer 的可用状态，若 buffer 处于不可用状态，则不会发送新的数据。&lt;br/&gt;面对上述问题，需要有一种动态反馈的机制，根据数据实时传输的情况，动态调整数据的发送速率和接收速率，从而更好的进行网络传输。&lt;br/&gt;动态反馈可以分为以下两种：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;正向反馈：当Producer的发送速率 小于 Consumer的接受速率时，需要通知 Producer可以&lt;strong&gt;提高&lt;/strong&gt;发送速率&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;负向反馈：当Producer的发送速率 大于 Consumer的接受速率时，需要通知 Producer可以&lt;strong&gt;降低&lt;/strong&gt;发送速率&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;2.2 何为「反压」&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;通过上小节的介绍，我们了解到，当上游生产数据和下游消费数据速率不一致时，会导致一些问题，这时候需要一种「动态反馈」机制，下面引入「反压」的概念&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;「反压」是流式系统中关于数据处理能力的动态反馈机制，并且是从下游到上游的反馈，一般发生在实时数据处理的过程中，上游节点的生产速度大于下游节点的消费速度的情况下。&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;下面将会介绍在Flink中，TaskManager之间如何传输数据，看看 Flink 中数据传输的生产者-消费者模式的具体形式。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;2.3 TaskManager之间的数据传输&lt;/h2&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;下图来源于Apache Flink (http://flink.apache.org) 图中相关概念： ResultPartition（RP） ResultSubPartition（RS） InputChannel（IC） InputGate（IG）&lt;/p&gt;&lt;/blockquote&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.8101851851851852&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/1skeHK2Gybwtm3boGkxFwnF811Jz3tzo2X9JBhLLAwNoxo5K21IibdMIzkZEk709qichxEj7ibYKmKQVeDHqR1Mcg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/figure&gt;&lt;p&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;figcaption&gt;&lt;span/&gt;&lt;/figcaption&gt;&lt;figcaption&gt;&lt;span&gt;MapDriver 将数据传递给 RecordWriter，之后经由 ChannelSelector 做数据分发，将数据传递到一个或多个 RecordSerializer 做序列化操作，转换为二进制流。ChannelSelector 的分发有两种模式，一种是广播模式，会将数据发送到每个序列化器进行处理，另一种是按某种逻辑进行选择，比如计算数据的hash，然后路由到命中的序列化器。&lt;/span&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;/**&lt;br/&gt; * The {&lt;span&gt;@link&lt;/span&gt; ChannelSelector} determines to which logical channels a record should be written to.&lt;br/&gt; *&lt;br/&gt; * &lt;span&gt;@param&lt;/span&gt; &amp;lt;T&amp;gt; the type of record which is sent through the attached output gate&lt;br/&gt; */&lt;/span&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;interface&lt;/span&gt; &lt;span&gt;ChannelSelector&lt;/span&gt;&amp;lt;&lt;span&gt;T&lt;/span&gt; &lt;span&gt;extends&lt;/span&gt; &lt;span&gt;IOReadableWritable&lt;/span&gt;&amp;gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;/**&lt;br/&gt;     * Initializes the channel selector with the number of output channels.&lt;br/&gt;     *&lt;br/&gt;     * &lt;span&gt;@param&lt;/span&gt; numberOfChannels the total number of output channels which are attached to respective&lt;br/&gt;     *     output gate.&lt;br/&gt;     */&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;void&lt;/span&gt; &lt;span&gt;setup&lt;/span&gt;&lt;span&gt;(&lt;span&gt;int&lt;/span&gt; numberOfChannels)&lt;/span&gt;&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;/**&lt;br/&gt;     * Returns the logical channel index, to which the given record should be written. It is illegal&lt;br/&gt;     * to call this method for broadcast channel selectors and this method can remain not&lt;br/&gt;     * implemented in that case (for example by throwing {&lt;span&gt;@link&lt;/span&gt; UnsupportedOperationException}).&lt;br/&gt;     * &lt;br/&gt;     * 选择模式&lt;br/&gt;     *&lt;br/&gt;     * &lt;span&gt;@param&lt;/span&gt; record the record to determine the output channels for.&lt;br/&gt;     * &lt;span&gt;@return&lt;/span&gt; an integer number which indicates the index of the output channel through which the&lt;br/&gt;     *     record shall be forwarded.&lt;br/&gt;     */&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;int&lt;/span&gt; &lt;span&gt;selectChannel&lt;/span&gt;&lt;span&gt;(T record)&lt;/span&gt;&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;/**&lt;br/&gt;     * Returns whether the channel selector always selects all the output channels.&lt;br/&gt;     * 广播模式&lt;br/&gt;     *&lt;br/&gt;     * &lt;span&gt;@return&lt;/span&gt; true if the selector is for broadcast mode.&lt;br/&gt;     */&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;boolean&lt;/span&gt; &lt;span&gt;isBroadcast&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt;;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;ol start=&quot;2&quot; data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;序列化输出的二进制流数据会被存放在buffer块中，之后 BufferWriter 会将这些buffer块写入到指定的ResultPartition（RP）中。RP中又包含多个子分区（ResultSubpartitions，如RS1，RS2），每个子分区只会存放特定消费者需要的数据。由图可见，一个 buffer 已经被 BufferWriter 放入了 RS2 中，这时 RS2 这个子分区已经变成了可被消费状态，接下来会通知 JobManager。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;abstract&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;ResultPartition&lt;/span&gt; &lt;span&gt;implements&lt;/span&gt; &lt;span&gt;ResultPartitionWriter&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;protected&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; ResultPartitionID partitionId;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;/** 该分区的类型，定义要使用的具体子分区实现 */&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;protected&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; ResultPartitionType partitionType;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;protected&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; ResultPartitionManager partitionManager;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;/** Subpartition 的个数 */&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;protected&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; numSubpartitions;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;// - Runtime state --------------------------------------------------------&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;/** ResultPartition 中的缓冲区 */&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;protected&lt;/span&gt; BufferPool bufferPool;&lt;br/&gt;    &lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;ol start=&quot;3&quot; data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;JobManager 会寻找 RS2 的消费者，通知TaskManager2，该数据块可以消费了。接着InputChannel会接收到该消息（图中是 IC1，用于接收上一步中存放到 RS2 中的 buffer，且 InputChannel 和 ResultSubpartition 是1-1对应的，一个 InputChannel 接收一个 ResultSubpartition 的输出），并通知 RS2 初始化网络连接，可以开始传输数据了。然后 RS2 通过 TaskManager1 的网络栈基于 Netty 进行数据传输，该网络连接是在各个TaskManager 之间长期存在的。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;/**&lt;br/&gt; * An input channel consumes a single {&lt;span&gt;@link&lt;/span&gt; ResultSubpartitionView}.&lt;br/&gt; *&lt;br/&gt; * &amp;lt;p&amp;gt;For each channel, the consumption life cycle is as follows:&lt;br/&gt; *&lt;br/&gt; * &amp;lt;ol&amp;gt;&lt;br/&gt; *   &amp;lt;li&amp;gt;{&lt;span&gt;@link&lt;/span&gt; #requestSubpartition()}&lt;br/&gt; *   &amp;lt;li&amp;gt;{&lt;span&gt;@link&lt;/span&gt; #getNextBuffer()}&lt;br/&gt; *   &amp;lt;li&amp;gt;{&lt;span&gt;@link&lt;/span&gt; #releaseAllResources()}&lt;br/&gt; * &amp;lt;/ol&amp;gt;&lt;br/&gt; */&lt;/span&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;abstract&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;InputChannel&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;/** 输入通道的信息，以便在任务中全局识别它. */&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;protected&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; InputChannelInfo channelInfo;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;/** 此通道消费接收的RP编号. */&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;protected&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; ResultPartitionID partitionId;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;/** 此通道使用的子分区的索引. */&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;protected&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; consumedSubpartitionIndex;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;protected&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; SingleInputGate inputGate;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;ol start=&quot;4&quot; data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;基于 Netty 的网络传输，buffer块被传递到 TaskManager2 网络栈，之后由 ConnectionManager 来控制将 buffer数据传递到指定的 InputChannel 中，并进入InputGate，最终进入反序列化器 （RecordDeserializer）将buffer中的数据还原成制定类型的对象，最后传递给接收数据的task。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其实这是典型的生产者-消费者模式，上游生产数据到 &lt;strong&gt;ResultPartition&lt;/strong&gt;（由&lt;strong&gt;ResultSubpartition&lt;/strong&gt;构成） 中，下游通过 &lt;strong&gt;InputGate&lt;/strong&gt; （由&lt;strong&gt;InputChannel&lt;/strong&gt;构成）消费数据。不同的 task 可能在同一个 TaskManager 中运行，此时这些task可以看做是同一个 TaskManager进程中的不同线程，可以在本地进行数据交换；不同的 task 也可能在不同的 TaskManger 中运行，此时就要通过TaskManager 间的网络通信进行数据交换。&lt;/p&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;3. Flink网络流控&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;前面介绍了 Flink 基于生产者-消费者模式的数据传输方式，且我们了解到，流式系统在处理数据时，如果上下游处理速度不一致，会出现数据堵塞等问题。这时候需要一种动态反馈的机制，根据数据实时传输的情况，动态调整数据的发送速率和接受速率，从而更好的进行网络传输，即「网络流控」。&lt;br/&gt;本章将会介绍 Flink 在V1.5前后进行网络流控的两种方式：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;基于 TCP 的反压机制&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;基于 Credit 的反压机制&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;3.1 基于TCP的反压机制&lt;/h2&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;我们先来看看Flink在V1.5前是如何做动态反馈，进而实现网络流控的。 基于TCP的反压机制底层依赖于「&lt;strong&gt;TCP的滑动窗口算法&lt;/strong&gt;」，本章不会赘述，而会重点描述反压现象的传递过程。&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.5675487465181058&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/1skeHK2Gybwtm3boGkxFwnF811Jz3tzoZVcXz9n4ribelbIS5wMVQJgDs6fLdJMmfQ6PnnFGO6htRDfGkaTY7mw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2872&quot;/&gt;&lt;br/&gt;由上图可见，每个TaskManager中都会有个被内部所有task共享的 Network Buffer Pool，它从堆外内存申请内存资源，之后可以为每个 ResultSubpartition 创建 Local Buffer Pool。&lt;br/&gt;假设生产者的速率是 2 MB/S，消费者的速率是 1 MB/S。下面会描述，由于速度不匹配，各层buffer被打满，从而引起反压的过程。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;3.1.1 InputChannel Buffer 打满&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;一段时间后，会达到下图的状态，此时 InputChannel 暂时被打满，需要向 Local Buffer Pool 申请新的 buffer，此时 Local Buffer Pool 里的一个 buffer 被标记为 Used。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5657407407407408&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/1skeHK2Gybwtm3boGkxFwnF811Jz3tzoZNxk2NTfpPAb0xvk5waLUuyDHMS0wPEOxwNuGdgbiagkkRA6aNx2qcA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;3.1.2 Consumer Local Buffer Pool 打满&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;由上下游处理速率不一致，一段时间过后，InputChannel 将 Local Buffer Pool 的内存申请完了，此时 Local Buffer Pool 的所有 buffer 都被标记为 Used，但还可以向 Network Buffer Pool 继续申请 buffer。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5648148148148148&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/1skeHK2Gybwtm3boGkxFwnF811Jz3tzorQHpEQY8elAH6iaI8EFxv3zrFbZgHftiaQkfxOEnzCnQLajXn0VNZdNA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;figcaption/&gt;&lt;/figure&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;3.1.3 Consumer Network Buffer Pool 打满&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;渐渐 Network Buffer Pool 也没有可用 buffer 了，全都变成了 Used，此时消费者无法再读取数据了，Netty也不会接收Socket的数据了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5638002773925104&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/1skeHK2Gybwtm3boGkxFwnF811Jz3tzojwfU3NoaqdZS74b8PHg6VAOYNm2cB817iaFPAkkLcanocdNtZVuAqoA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2884&quot;/&gt;&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;3.1.4 socket停止数据传输&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当消费者的 socket 被用尽，此时会将 windows=0 发送给生产者的发送端（TCP滑动窗口），此时socket会停止发送数据。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5615120274914089&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/1skeHK2Gybwtm3boGkxFwnF811Jz3tzoTqIl1xcGl3u5Wsva2j325fMnoahkgDaXr51MIBIyURPL7Cdbb8SAVg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2910&quot;/&gt;&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;3.1.5 Netty不可写&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;不久socket buffer用尽，Netty检测到后会停止向socket发送数据，之后由于 RecordWriter 还在发送数据，这些数据会堆积在Netty Buffer中，到一定程度后，Netty会变为不可写状态，ResultSubpartition 发送数据前都会检测 Netty是否可写，此时 ResultSubpartition 会停止向 Netty 中写数据。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5648148148148148&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/1skeHK2Gybwtm3boGkxFwnF811Jz3tzomVvyrm8NmAHPhia3k22ylb3pT6ib6fuS0iaqLsniaEpAg3siaicYgkNDswJQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;3.1.5 RecordWriter 停止写数据&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;ResultSubpartition 的空间很快被用尽，直到 Local Buffer Pool 和 Network Buffer Pool 的 buffer都被打满后，RecordWriter 就会停止写数据，至此，完成了跨TaskManager的反压。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5775862068965517&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/1skeHK2Gybwtm3boGkxFwnF811Jz3tzoORyE3LJliavljibAhXU1FYYv29a8jicjnXPc3jXwB0ic19fAEibCkUWaEaw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2784&quot;/&gt;&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;3.1.6 TCP反压机制的问题&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当一个 Task 的缓冲池用尽之后，网络连接就处于阻塞状态，上游 Task 无法产出数据，下游 Task 无法接收数据，也就是我们所说的「反压」状态。&lt;br/&gt;但是基于TCP的反压机制有以下问题：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;一个 TaskManager 内通常会有多个Task，它们底层会复用同一个Socket，一旦某个Task反压导致Socket阻塞不可用，即便其它 Task 关联的缓冲池仍然存在空余，但也都无法向 TCP 连接中写入数据或者从中读取数据。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;基于底层TCP流控的反压机制，从 ResultPartition 到 Netty 到 Socket整条链路较长，会导致反压行为不够灵敏，动态反馈过程比较迟钝。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;3.2 基于Credit的反压机制&lt;/h2&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;3.2.1 算法介绍&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;为了解决上述问题，Flink 1.5 重构了网络栈，引入了“基于信用值的流量控制算法”（Credit-based Flow Control），即在Flink层实现网络流控，缩短反压链路，且确保 TaskManager 之间的网络连接始终不会处于阻塞状态。&lt;br/&gt;Credit-based Flow Control 的思路其实很简单，它在接收端和发送端之间建立一种类似“信用评级”的机制，发送端向接收端发送的数据永远不会超过接收端的信用值的大小。对于 Flink来说，信用值就是接收端TaskManager 可用的 Buffer 的数量，这样就可以保证发送端 TaskManager 不会向 TCP 连接中发送超出接收端缓冲区可用容量的数据。&lt;br/&gt;基于Credit 实现流量控制 的具体机制为：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;当发送端发送 buffer 的时候，它把当前堆积数据的 buffer 数量（backlog size）告知接收端；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;接收端将根据发送端堆积的数量来申请 buffer；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;接收端向发送端声明可用的 Credit（一个可用的 buffer 对应一个 credit）；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;当接收端分配了 N 点 Credit 给发送端，表明它有 N 个空闲的 buffer 可以接收数据；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;当发送端获得了 N 点 Credit，表明它可以向网络中发送 N 个 buffer；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;只有在 Credit &amp;gt; 0 的情况下发送端才发送 buffer；发送端每发送一个 buffer，Credit 也相应地减少；&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;3.2.2 反压过程&lt;/h3&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;如图所示，当前 ResultPartition 已经堆积了两个 Buffer 的数据，所以在底层网络传输会将 要传输的数据以及backlog size = 2 发送至接收端；下游收到了之后，会计算获得credit信用值，此时接收端共剩下 6 个buffer， 接收速率是 1 个buffer，backlog size 为2个buffer， credit 为 3 个buffer（6-1-2 = 3）。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.55&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/1skeHK2Gybwtm3boGkxFwnF811Jz3tzozXDYvIgXxiaVP60TgL4299NSj81vJJcUxsjdAZsCQ4uS6Hmtiauwt7ibw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;figcaption&gt;&lt;br/&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;ol start=&quot;2&quot; data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;下图中，发送端发送的 backlog size = 2，但接收端的各级Buffer已经打满，所以下游向上游返回的 credit 为0，说明由于上下游处理速率不一致，导致了下游暂时无法处理数据；此时 ResultPartition 就不会向 Netty 传输数据，数据很快就会积压打满，从而达到反压的效果；&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5556309362279511&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/1skeHK2Gybwtm3boGkxFwnF811Jz3tzo7qaODsoAg3gfBhVCa5Tm2Q54CgvZpHoDAbBQ7dgDQJF9BZ1DGPNS7g/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2948&quot;/&gt;&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;3.2.3 优化点&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;基于Credit算法的反压机制，解决了两个问题：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;可以直接在 ResultPartition 层实现反压，而不用将压力流经过多层传递，层层反馈。提高了反压效率，降低了延迟；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;不会把底层socket打满，从而阻碍网络数据传输，不会让单个 Task 的瓶颈成为整个TaskManager 的瓶颈；&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;4. 小结&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;本文首先介绍了Flink中跨TaskManager的数据传输，引出了「生产者-消费者模式」在吞吐率&lt;strong&gt;不同&lt;/strong&gt;时，导致的普遍性问题，以及「&lt;strong&gt;动态反馈&lt;/strong&gt;」机制的必要性，并明确了「&lt;strong&gt;反压&lt;/strong&gt;」的概念，「&lt;strong&gt;反压&lt;/strong&gt;」是流式系统中关于处理能力的动态反馈机制，并且是从下游到上游的反馈。&lt;br/&gt;接着介绍了Flink的网络流控机制，Flink在V1.5前，「&lt;strong&gt;基于TCP的滑动窗口机制&lt;/strong&gt;」实现反压，但是存在单个Task反压会导致整个TaskManager共享的Socket不可用，而且反压链路较长，动态反馈机制较为迟钝等缺点。Flink在V1.5后，采用「&lt;strong&gt;基于Credit算法的反压机制&lt;/strong&gt;」，在ResultPartition层实现反压，提高了反压效率。&lt;/p&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;5. 参考资料&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;https://cwiki.apache.org/confluence/display/FLINK/Data+exchange+between+tasks&lt;br/&gt;https://www.ververica.com/blog/how-flink-handles-backpressure&lt;br/&gt;https://docs.google.com/document/d/1chTOuOqe0sBsjldA_r-wXYeSIhU2zRGpUaTaik7QZ84/edit#heading=h.pjh6mv7m2hjn&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;mp-style-type data-value=&quot;3&quot;/&gt;&lt;/p&gt;&lt;/div&gt;

          
        &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>cfe674fdf8551e91f7b0755ad8fd5a2d</guid>
<title>Go try 新提案靠谱吗？想简化错误处理了</title>
<link>https://toutiao.io/k/db1nkru</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot; data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;大家好，我是煎鱼。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在近日新的 try 提案《&lt;span&gt;proposal: Go 2: error handling: try statement with handler&lt;/span&gt;&lt;sup&gt;[1]&lt;/sup&gt;》在社区引发了热议，再战社区！！！&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;今天煎鱼和大家一起打开来看看，这能把 Go 错误处理机制给掀开重整不。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;背景&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;来自 PingCAP 的提案作者 @Greg Weber 会干这事基于两个因素，一个是在《&lt;span&gt;Go Developer Survey 2022 Q2 Results&lt;/span&gt;&lt;sup&gt;[2]&lt;/sup&gt;》中明确提到。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.7097591888466414&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/KVl0giak5ib4gcm1jvybZFOaG3fAVrVL9nBB80HwohTT9zwgq2oqbZ0BVNE69b1IwjpGTroo8G4PRO5RqIxXZluQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1578&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;随着 Go1.18 泛型的发布，原先矛盾最深的泛型已经得到一个初步的解决方案。在社区调研上，开发者在使用 Go 时面临的最大挑战已经转移到了错误处理上，需要投入精力去 “解决” 它。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;另外一个因素就是众所皆知的，Go 错误处理代码比较繁琐，常被工程师们戏称一个 Go 工程里有 30% 都 if err = nil。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如下代码：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;_, err := f()&lt;br/&gt;&lt;span&gt;if&lt;/span&gt; err != &lt;span&gt;nil&lt;/span&gt; {&lt;br/&gt;    ...&lt;br/&gt;}&lt;br/&gt;_, err = r()&lt;br/&gt;&lt;span&gt;if&lt;/span&gt; err != &lt;span&gt;nil&lt;/span&gt; {&lt;br/&gt;    ...&lt;br/&gt;}&lt;br/&gt;_, err = w()&lt;br/&gt;&lt;span&gt;if&lt;/span&gt; err != &lt;span&gt;nil&lt;/span&gt; {&lt;br/&gt;    ...&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;希望让其更优雅。也有许多小伙伴认同这个设计，确实是简单、直观的处理，在社区形成了角力。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;try-handler 提案&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;本次提案中所提到的解决方案，是增加一个新语句 try ，以此达到简洁的错误处理的作用，让 if err != nil 的处理丝滑起来。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如下代码：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;try err, handler&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;编译器翻译后生成的代码：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;if&lt;/span&gt; err != &lt;span&gt;nil&lt;/span&gt; {&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; handler(err)&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在函数中可以如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt;&lt;span&gt;(args...)&lt;/span&gt; &lt;span&gt;(rtype1, rtypes..., rtypeN, error)&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;    try err, handler&lt;br/&gt;    ...&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;翻译后生成的代码：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt;&lt;span&gt;(args...)&lt;/span&gt; &lt;span&gt;(rtype1, rtypes..., rtypeN, error)&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; err != &lt;span&gt;nil&lt;/span&gt; {&lt;br/&gt;            &lt;span&gt;return&lt;/span&gt; Zero(rtype1), Zeros(rtypes...)..., Zero(rtypeN), handler(err)&lt;br/&gt;    }&lt;br/&gt;    ...&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;也可以只针对 if err != nil 处理。如下代码：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;try err&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;翻译后生成的代码：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;if&lt;/span&gt; err != &lt;span&gt;nil&lt;/span&gt; {&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; err&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;不会调用不存在的 handler 进行处理，将会直接返回。三行（if err != nil 的逻辑）直接变 3 个单词（try）。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;不想写函数，也可以直接：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;x, err := f()&lt;br/&gt;try err, fmt.Errorf(&lt;span&gt;&quot;f fail: %w&quot;&lt;/span&gt;, err)&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;针对 defer+try 的场景可以如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;CopyFile&lt;/span&gt;&lt;span&gt;(src, dst &lt;span&gt;string&lt;/span&gt;)&lt;/span&gt; &lt;span&gt;error&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;    &lt;span&gt;defer&lt;/span&gt; try &lt;span&gt;&lt;span&gt;func&lt;/span&gt;&lt;span&gt;(err error)&lt;/span&gt; &lt;span&gt;error&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; fmt.Errorf(&lt;span&gt;&quot;copy %s %s: %w&quot;&lt;/span&gt;, src, dst, err)&lt;br/&gt;    }&lt;br/&gt;    ...&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;入参是比较灵活的，作者希望它是泛型，这样能够适配各种场景的要求。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;示例和实践&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;针对本提案，原作者给出了各类使用场景的示例。如下代码：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;import&lt;/span&gt; (&lt;br/&gt;    &lt;span&gt;&quot;fmt&quot;&lt;/span&gt;&lt;br/&gt;)&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// This helper should be defined in the fmt package&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;Handlew&lt;/span&gt;&lt;span&gt;(format &lt;span&gt;string&lt;/span&gt;, args ...any)&lt;/span&gt; &lt;span&gt;func&lt;/span&gt;&lt;span&gt;(error)&lt;/span&gt; &lt;span&gt;error&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; &lt;span&gt;return&lt;/span&gt; &lt;span&gt;&lt;span&gt;func&lt;/span&gt;&lt;span&gt;(err error)&lt;/span&gt; &lt;span&gt;error&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;  args = &lt;span&gt;append&lt;/span&gt;(args, err)&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; fmt.Errorf(format+&lt;span&gt;&quot;: %w&quot;&lt;/span&gt;, args...)&lt;br/&gt; }&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// This helper should be defined in the fmt package&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;Handlef&lt;/span&gt;&lt;span&gt;(format &lt;span&gt;string&lt;/span&gt;, args ...any)&lt;/span&gt; &lt;span&gt;func&lt;/span&gt;&lt;span&gt;(error)&lt;/span&gt; &lt;span&gt;error&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; &lt;span&gt;return&lt;/span&gt; &lt;span&gt;&lt;span&gt;func&lt;/span&gt;&lt;span&gt;(err error)&lt;/span&gt; &lt;span&gt;error&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;  args = &lt;span&gt;append&lt;/span&gt;(args, err)&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; fmt.Errorf(format+&lt;span&gt;&quot;: %v&quot;&lt;/span&gt;, args...)&lt;br/&gt; }&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;valAndError&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;span&gt;(&lt;span&gt;int&lt;/span&gt;, error)&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; &lt;span&gt;1&lt;/span&gt;, fmt.Errorf(&lt;span&gt;&quot;make error&quot;&lt;/span&gt;)&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;newGo&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;span&gt;(&lt;span&gt;int&lt;/span&gt;, error)&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;    x, err := valAndError()&lt;br/&gt;    try err&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;// Common formatting functions will already be provided&lt;/span&gt;&lt;br/&gt;    i := &lt;span&gt;2&lt;/span&gt;&lt;br/&gt;    x, err = valAndError()&lt;br/&gt;    try err, Handlew(&lt;span&gt;&quot;custom Error %d&quot;&lt;/span&gt;, i)&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;// Using a custom error type&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;// For convenience the error type can expose a method to set the error&lt;/span&gt;&lt;br/&gt;    x, err = valAndError()&lt;br/&gt;    try err, TheErrorAsHandler(i)&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;type&lt;/span&gt; TheError &lt;span&gt;struct&lt;/span&gt;{&lt;br/&gt;    num &lt;span&gt;int&lt;/span&gt;&lt;br/&gt;    err error&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;(t TheError)&lt;/span&gt; &lt;span&gt;Error&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;span&gt;String&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; fmt.Sprintf(&lt;span&gt;&quot;theError %d %v&quot;&lt;/span&gt;, t.num, t.err)&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;TheErrorAsHandler&lt;/span&gt;&lt;span&gt;(num &lt;span&gt;int&lt;/span&gt;)&lt;/span&gt; &lt;span&gt;func&lt;/span&gt;&lt;span&gt;(err)&lt;/span&gt; &lt;span&gt;TheError&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; &lt;span&gt;&lt;span&gt;func&lt;/span&gt;&lt;span&gt;(err error)&lt;/span&gt; &lt;span&gt;TheError&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; theError{ num: i, err: err }&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;另外在日常的 Go 工程中，提案作者认为 CopyFile 函数是新提案语句的一种很好的实践。为此基于 try-handler 进行了一版改造和说明。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如下代码：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;// This helper can be used with defer&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;handle&lt;/span&gt;&lt;span&gt;(err *error, handler &lt;span&gt;func&lt;/span&gt;(err error)&lt;/span&gt; &lt;span&gt;error&lt;/span&gt;)&lt;/span&gt; {&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; err == &lt;span&gt;nil&lt;/span&gt; {&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;nil&lt;/span&gt;&lt;br/&gt;    }&lt;br/&gt;    *err = handler(err)&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;CopyFile&lt;/span&gt;&lt;span&gt;(src, dst &lt;span&gt;string&lt;/span&gt;)&lt;/span&gt; &lt;span&gt;(err error)&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;    &lt;span&gt;defer&lt;/span&gt; handle(&amp;amp;err, &lt;span&gt;&lt;span&gt;func&lt;/span&gt;&lt;span&gt;(err error)&lt;/span&gt; &lt;span&gt;error&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; fmt.Errorf(&lt;span&gt;&quot;copy %s %s: %w&quot;&lt;/span&gt;, src, dst, err)&lt;br/&gt;    })&lt;br/&gt;&lt;br/&gt;    r, err := os.Open(src)&lt;br/&gt;    try err&lt;br/&gt;    &lt;span&gt;defer&lt;/span&gt; r.Close()&lt;br/&gt;&lt;br/&gt;    w, err := os.Create(dst)&lt;br/&gt;    try err, &lt;span&gt;&lt;span&gt;func&lt;/span&gt;&lt;span&gt;(err error)&lt;/span&gt; &lt;span&gt;error&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;            os.Remove(dst) &lt;span&gt;// only if Create fails&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;return&lt;/span&gt; fmt.Errorf(&lt;span&gt;&quot;dir %s: %w&quot;&lt;/span&gt;, dst, err)&lt;br/&gt;    }&lt;br/&gt;    &lt;span&gt;defer&lt;/span&gt; w.Close()&lt;br/&gt;&lt;br/&gt;    err = io.Copy(w, r)&lt;br/&gt;    try err&lt;br/&gt;    err = w.Close()&lt;br/&gt;    try err&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; &lt;span&gt;nil&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;引入 try-hanlder 后，能够做到：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;插入错误的返回语句，进行机制预设。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;在返回错误之前将错误处理函数组合在一起，便于后续的处理。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;总结&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在这个新提案中，一旦实施，就可以减少如下代码的编写：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;if&lt;/span&gt; err != nil {&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; ...&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在代码编写上会节省一些行数，且可以为错误处理机制引入一些新的 ”操作“，这是该提案的优势。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但是从 Go 开发者的角度而言，会引入一些新的副作用，例如：初学者的学习成本、Go 工具链的改造、程序理解的复杂度增加。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;另外新的语句，似乎比较难与 Go1.13 引入的 error.Is 和 As 有较好的相关联性。如果是做一个第三方用户库引入倒可以，但若是作为标准进入 Go 源代码中，似乎又有些格格不入（提案作者希望进入）。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;看了那么多提案，Go 错误处理机制的 ”升级“，似乎陷入了手心手背都是肉的阶段...&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;推荐阅读&lt;/h2&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;参考资料&lt;/span&gt;&lt;/h3&gt;&lt;section data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;span&gt;[1]&lt;/span&gt;&lt;p&gt;proposal: Go 2: error handling: try statement with handler: &lt;em&gt;https://github.com/golang/go/issues/56165&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[2]&lt;/span&gt;&lt;p&gt;Go Developer Survey 2022 Q2 Results: &lt;em&gt;https://go.dev/blog/survey2022-q2-results&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>40f16cd78d05ecef8d660225442843e5</guid>
<title>RocketMQ 重试机制详解及最佳实践</title>
<link>https://toutiao.io/k/fbw6d12</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content             autoTypeSetting24psection&amp;#10;            &quot; id=&quot;js_content&quot;&gt;&lt;p data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;108&quot; data-backw=&quot;578&quot; data-ratio=&quot;0.1875&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/yvBJb5IiafvksXNHe6554ZsjqrWjd5N5AmmH22PkwibojicVa4IqjEuaEc5qzDX4NuwibcmDibr79xJ0PeW88OorK9w/640?wx_fmt=gif&quot; data-type=&quot;gif&quot; data-w=&quot;640&quot;/&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-role=&quot;paragraph&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-role=&quot;title&quot; data-tools=&quot;135编辑器&quot; data-id=&quot;106625&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-brushtype=&quot;text&quot; hm_fix=&quot;343:395&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p&gt;&lt;span&gt;&lt;em&gt;&lt;span&gt;&lt;strong mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;em&gt;&lt;span&gt;&lt;strong mpa-from-tpl=&quot;t&quot;&gt;引言&lt;/strong&gt;&lt;/span&gt;&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-width=&quot;100%&quot; data-role=&quot;list&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p&gt;&lt;span&gt;&lt;em&gt;Cloud Native&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;本文主要介绍在使用 RocketMQ 时为什么&lt;/span&gt;&lt;span&gt;&lt;span&gt;需要&lt;/span&gt;&lt;strong&gt;&lt;span&gt;重试与兜底机制&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;，生产者与消费者触发&lt;/span&gt;&lt;strong&gt;&lt;span&gt;重试的条件和具体行为&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;，如何在 RocketMQ 中&lt;/span&gt;&lt;strong&gt;&lt;span&gt;合理使用重试机制&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;，帮助构建弹性，高可用系统的&lt;/span&gt;&lt;strong&gt;&lt;span&gt;最佳实践&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;RocketMQ 的重试机制包括三部分，分别是生产者重试，服务端内部数据复制遇到非预期问题时重试，消费者消费重试。本文中仅讨论生产者重试和消费者消费重试两种面向用户侧的实现。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;187&quot; data-backw=&quot;578&quot; data-ratio=&quot;0.3236775818639798&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/yvBJb5Iiafvl3oZeCmhub2AlQh82zA6icYlEFRcJfCibj9IJ4icUcB6pW33O3tPWxVZa46sRk1TcnyU8iciaL2J1r9EA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1588&quot;/&gt;&lt;/section&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-role=&quot;paragraph&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-role=&quot;title&quot; data-tools=&quot;135编辑器&quot; data-id=&quot;106625&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-brushtype=&quot;text&quot; hm_fix=&quot;343:395&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p&gt;&lt;span&gt;&lt;em&gt;&lt;span&gt;&lt;strong mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;em&gt;&lt;span&gt;&lt;strong mpa-from-tpl=&quot;t&quot;&gt;生产者发送重试&lt;/strong&gt;&lt;/span&gt;&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-width=&quot;100%&quot; data-role=&quot;list&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p&gt;&lt;span&gt;&lt;em&gt;Cloud Native&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;RocketMQ 的生产者在发送消息到服务端时，可能会因为网络问题，服务异常等原因导&lt;/span&gt;&lt;span&gt;致调用失败，这时候应该怎么办？&lt;/span&gt;&lt;span&gt;如何尽可能的保证消息不丢失呢？&lt;/span&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;h3&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;1. 生产者重试次数&lt;/span&gt;&lt;/h3&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;RocketMQ 在客户端中内置了请求重试逻辑，支持在初始化&lt;/span&gt;&lt;span&gt;&lt;span&gt;时配置消息发送&lt;/span&gt;&lt;strong&gt;&lt;span&gt;最大重试次数（默认为 2 次&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;），失败时会按照设置的重试次数重新发送。直到消息发送成功，或者达到最大重试次数时结束，并在最后一次失败后返回调用错误的响应。对于&lt;/span&gt;&lt;strong&gt;&lt;span&gt;同步发送和异步发送，均支持消息发送重试&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;同步发送：调用线程会一直阻塞，直到某次重试成功或最终重试失败（返回错误码或抛出异常）。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;异步发送：调用线程不会阻塞，但调用结果会通过回调的形式，以异常事件或者成功事件返回。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt; &lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;h3&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;2. 生产者重试间隔&lt;/span&gt;&lt;/h3&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;在介绍生产者重试前，我们先来了解下流控的概念，流控一般是指服务端压力过大，容量不足时服务端会限制客户端收发消息的行为，是服务端自我保护的一种设计。RocketMQ 会根据当前是否触发了流控而采用不同的&lt;/span&gt;&lt;span&gt;重试策略：&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;非流控错误场景&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;：其他触发条件触发重试后，均会&lt;strong&gt;立即进行重试，无等待间隔&lt;/strong&gt;。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;流控错误场景&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;：系统会按照预设的&lt;strong&gt;指数退避策略进行延迟重试&lt;/strong&gt;。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;如果故障是由过载流控引起的，&lt;strong&gt;重试会增加服务端负载，导致情况进一步恶化&lt;/strong&gt;，因此客户端在遇到流控时会在两次尝试之间等待一段时间。每次尝试后的等待时间都呈指数级延长。指数回退可能导致很长的回退时间，因为指数函数增长很快。指数退避算法通过以下参数控制重试行为，更多信息，请参见 &lt;/span&gt;&lt;span&gt;connection-backoff.md&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;INITIAL_BACKOFF：第一次失败重试前后需等待多久，默认值：1 秒；&lt;br/&gt;MULTIPLIER ：指数退避因子，即退避倍率，默认值：1.6；&lt;br/&gt;JITTER ：随机抖动因子，默认值：0.2；&lt;br/&gt;MAX_BACKOFF ：等待间隔时间上限，默认值：120 秒；&lt;br/&gt;MIN_CONNECT_TIMEOUT ：最短重试间隔，默认值：20 秒。&lt;/span&gt;&lt;/section&gt;&lt;pre data-language=&quot;plain&quot;&gt;&lt;section&gt;&lt;span/&gt;&lt;/section&gt;&lt;/pre&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;properties&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__attr&quot;&gt;ConnectWithBackoff()&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  &lt;span class=&quot;code-snippet__attr&quot;&gt;current_backoff&lt;/span&gt; = &lt;span class=&quot;code-snippet__string&quot;&gt;INITIAL_BACKOFF&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  &lt;span class=&quot;code-snippet__attr&quot;&gt;current_deadline&lt;/span&gt; = &lt;span class=&quot;code-snippet__string&quot;&gt;now() + INITIAL_BACKOFF&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  &lt;span class=&quot;code-snippet__attr&quot;&gt;while&lt;/span&gt; &lt;span class=&quot;code-snippet__string&quot;&gt;(TryConnect(Max(current_deadline, now() + MIN_CONNECT_TIMEOUT))!= SUCCESS)&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__attr&quot;&gt;SleepUntil(current_deadline)&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__attr&quot;&gt;current_backoff&lt;/span&gt; = &lt;span class=&quot;code-snippet__string&quot;&gt;Min(current_backoff * MULTIPLIER, MAX_BACKOFF)&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__attr&quot;&gt;current_deadline&lt;/span&gt; = &lt;span class=&quot;code-snippet__string&quot;&gt;now() + current_backoff + UniformRandom(-JITTER * current_backoff, JITTER * current_backoff)&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;特别说明&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;：对于事务消息，只会进行&lt;/span&gt;&lt;span&gt;透明重试（transparent retries）&lt;/span&gt;&lt;span&gt;，网络超时或异常等场景不会进行重试。&lt;/span&gt;&lt;/section&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;h3&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;3. 重试带来的副作用&lt;/span&gt;&lt;/h3&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;不停的重试看起来很美好，但也是有副作用的，主要包括两方面：&lt;/span&gt;&lt;strong&gt;&lt;span&gt;消息重复，服务端压力增大&lt;/span&gt;&lt;br/&gt;&lt;/strong&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;远程调用的不确定性，因请求超时触发消息发送重试流程，此时客户端无法感知服务端的处理结果；客户端进行的消息发送重试可能会导致消费方重复消费，应该按照用户ID、业务主键等信息&lt;strong&gt;幂等处理消息&lt;/strong&gt;。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt; &lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;较多的重试次数也会&lt;strong&gt;增大服务端的处理压力&lt;/strong&gt;。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt; &lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;h3&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;4. 用户的最佳实践是什么&lt;/span&gt;&lt;/h3&gt;&lt;/section&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;1）合理设置发送超时时间，发送的最大次数&lt;/span&gt;&lt;/strong&gt;&lt;span/&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;发送的最大次数在初始化客户端时配置在 ClientConfiguration；对于某些实时调用类场景，可能会导致消息发送请求链路被阻塞导致业务请求整体耗时高或耗时；需要合理评估每次调用请求的超时时间以及最大重试次数，避免影响全链路的耗时。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;2）如何保证发送消息不丢失&lt;/span&gt;&lt;/strong&gt;&lt;span/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;由于分布式环境的复杂性，例如网络不可达时 RocketMQ 客户端发送请求重试机制并不能保证消息发送一定成功。业务方需要捕获异常，并做好冗余保护处理，常见的解决方案有两种：&lt;/span&gt;&lt;/section&gt;&lt;ol class=&quot;list-paddingleft-1&quot;&gt;&lt;ol ne-level=&quot;1&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;向调用方返回业务处理失败；&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;尝试将失败的消息存储到数据库，然后由后台线程定时重试，保证业务逻辑的最终一致性。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt; &lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;/ol&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;3）关注流控异常导致无法重试&lt;/span&gt;&lt;/strong&gt;&lt;span/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;触发流控的根本原因是系统容量不足，如果因为突发原因触发消息流控，且客户端内置的重试流程执行失败，&lt;br/&gt;则建议执行服务端扩容，将请求调用临时替换到其他系统进行应急处理。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;4）早期版本客户端如何使用故障延迟机制进行发送重试？&lt;/span&gt;&lt;/strong&gt;&lt;span/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;对于 RocketMQ 4.x 和 3.x 以下客户端&lt;span&gt;开启故障延迟机制&lt;/span&gt;可以用：&lt;/span&gt;&lt;/section&gt;&lt;blockquote class=&quot;js_blockquote_wrap&quot; data-type=&quot;2&quot; data-url=&quot;&quot; data-author-name=&quot;&quot; data-content-utf8-length=&quot;41&quot; data-source-title=&quot;&quot;&gt;&lt;section class=&quot;js_blockquote_digest&quot;&gt;&lt;section&gt;producer.setSendLatencyFaultEnable(true)&lt;span/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/blockquote&gt;&lt;section&gt;&lt;span&gt;&lt;span&gt;配置重试次数使用&lt;/span&gt;&lt;span&gt;：&lt;/span&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span/&gt;&lt;/section&gt;&lt;blockquote class=&quot;js_blockquote_wrap&quot; data-type=&quot;2&quot; data-url=&quot;&quot; data-author-name=&quot;&quot; data-content-utf8-length=&quot;81&quot; data-source-title=&quot;&quot;&gt;&lt;section class=&quot;js_blockquote_digest&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;span&gt;producer.setRetryTimesWhenSendFailed()&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;producer.setRetryTimesWhenSendAsyncFailed() &lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/blockquote&gt;&lt;section&gt;&lt;span/&gt;&lt;/section&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-role=&quot;paragraph&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-role=&quot;title&quot; data-tools=&quot;135编辑器&quot; data-id=&quot;106625&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-brushtype=&quot;text&quot; hm_fix=&quot;343:395&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;em&gt;&lt;span&gt;&lt;strong mpa-from-tpl=&quot;t&quot;&gt;消费者消费重试&lt;/strong&gt;&lt;/span&gt;&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-width=&quot;100%&quot; data-role=&quot;list&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p&gt;&lt;span&gt;&lt;em&gt;Cloud Native&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;消息中间件做异步解耦时的一个典型问题是如果下游服务处理消息事件失败，那应该怎么做呢？&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;RocketMQ 的消息确认机制以及消费重试策略可以帮助分析如下问题：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;消费重试策略可以在设计实现消费者逻辑时保证每条消息处理的完整性，避免部分消息消费异常导致业务状态不一致。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;当系统出现异常（宕机故障）等场景时，处理中的消息状态如何恢复，消费重试具体行为是什么。&lt;/span&gt;&lt;/section&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;h3&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;1. 什么是消费重试？&lt;/span&gt;&lt;/h3&gt;&lt;/section&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;什么时候认为消费失败？&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;&lt;br/&gt;消费者在接收到消息后将调用用户的消费函数执行业务逻辑。如果客户端返回消费失败 ReconsumeLater，抛出非预期异常，或消息处理超时（包括在 PushConsumer 中排队超时），&lt;strong&gt;只要服务端服务端一定时间内没收到响应，将认为消费失败&lt;/strong&gt;。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt; &lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;消费重试是什么？&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;&lt;br/&gt;消费者在消费某条消息失败后，服务端会根据重试策略重新向客户端投递该消息。超过一次定数后若还未消费成功，则该消息将不再继续重试，直接被发送到死信队列中；&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt; &lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;重试过程状态机&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;：消息在重试流程中的状态和变化逻辑；&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt; &lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;重试间隔&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;：上一次消费失败或超时后，下次重新尝试消费的间隔时间；&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt; &lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;最大重试次数&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;：消息可被重试消费的最大次数。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;  &lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;h3&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;2. 消息重试的场景&lt;/span&gt;&lt;/h3&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;需要注意重试是应对异常情况，给予程序再次消费失败消息的机会，不应该被用作常态化的链路。&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;推荐使用&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;场景：&lt;/span&gt;&lt;/section&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;业务处理失败，失败原因跟当前的消息内容相关，预期一段时间后可执行成功；&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;是一个小概率事件，对于大批的消息只有很少量的失败，后面的消息大概率会消费成功，是非常态化的。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;  &lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;正例：消费逻辑是扣减库存，极少量商品因为乐观锁版本冲突导致扣减失败，重试一般立刻成功。&lt;/span&gt;&lt;/strong&gt;&lt;/section&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;错误使用&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;场景：&lt;/span&gt;&lt;/section&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;消费处理逻辑中使用消费失败来做条件判断的结果分流，是不合理的。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt; &lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;反例：订单在数据库中状态已经是已取消，此时如果收到发货的消息，处理时不应返回消费失败，而应该返回成功并标记不用发货。&lt;/span&gt;&lt;/strong&gt;&lt;/section&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;消费处理中使用消费失败来做处理速率限流，是不合理的。&lt;br/&gt;限流的目的是将超出流量的消息暂时堆积在队列中达到削峰的作用，而不是让消息进入重试链路。&lt;br/&gt;这种做法会让消息反复在服务端和客户端之间传递，增大了系统的开销，主要包括以下方面：&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;ul ne-level=&quot;1&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;RocketMQ 内部重试涉及写放大，每一次重试将生成新的重试消息，大量重试将带来严重的 IO 压力；&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;重试有复杂的退避逻辑，内部实现为梯度定时器，该定时器本身不具备高吞吐的特性，大量重试将导致重试消息无法及时出队。重试的间隔将不稳定，将导致大量重试消息延后消费，即削峰的周期被大幅度延长。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt; &lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/ul&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-role=&quot;paragraph&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;h3&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;3. 不要以重试替代限流&lt;/span&gt;&lt;/h3&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;上述误用的场景实际上是组合了限流和重试能力来进行削峰，RocketMQ 推荐的削峰最佳手段为组合&lt;/span&gt;&lt;strong&gt;限流和堆积&lt;/strong&gt;&lt;span&gt;，业务以保护自身为前提，需要对消费流量进行限流，并利用 RocketMQ 提供的堆积能力将超出业务当前处理的消息滞后消费，以达到削峰的目的。&lt;/span&gt;&lt;span&gt;下图中超过处理能力的消息都应该被堆积在服务端，而不是通过消费失败进行重试。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5293159609120521&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/yvBJb5Iiafvl3oZeCmhub2AlQh82zA6icY0ibia1UKV1YxhjdxKQX7Ym0qUAsubAIfnPP4o11dtTgpSic0702le7Ygw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;614&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;如果不想依赖额外的产品/组件来完成该功能，也可以利用一些本地工具类，比如 Guava 的 RateLimiter 来完成单机限流。如下所示，声明一个 50 QPS 的 RateLimiter，在消费前以阻塞的方式 acquire 一个令牌，获取到即处理消息，未获取到阻塞。&lt;/span&gt;&lt;/section&gt;&lt;pre data-language=&quot;plain&quot;&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;kotlin&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;RateLimiter rateLimiter = RateLimiter.create(&lt;span class=&quot;code-snippet__number&quot;&gt;50&lt;/span&gt;);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;PushConsumer pushConsumer = provider.newPushConsumerBuilder()&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    .setClientConfiguration(clientConfiguration)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    .setConsumerGroup(consumerGroup)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    .setSubscriptionExpressions(Collections.singletonMap(topic, filterExpression))&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    .setMessageListener(messageView -&amp;gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        rateLimiter.acquire();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        LOGGER.info(&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;Consume message={}&quot;&lt;/span&gt;, messageView);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__keyword&quot;&gt;return&lt;/span&gt; ConsumeResult.SUCCESS;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    })&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    .build();&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;section&gt;&lt;span/&gt;&lt;/section&gt;&lt;/pre&gt;&lt;h3&gt;&lt;span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/span&gt;&lt;/h3&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;h3&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;4. PushConsumer 消费重试策略&lt;/span&gt;&lt;/h3&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;PushConsumer 消费消息时，消息的几个主要状态如下：&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;430&quot; data-backw=&quot;578&quot; data-ratio=&quot;0.7444444444444445&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/yvBJb5Iiafvl3oZeCmhub2AlQh82zA6icYWMmKn8whHssxFnbJtDQugMzshwMLMiaFKXPcF9mmEDOHS7v78w79oqA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;720&quot;/&gt;&lt;/section&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;Ready：已就绪状态。消息在消息队列RocketMQ版服务端已就绪，可以被消费者消费；&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;Inflight：处理中状态。消息被消费者客户端获取，处于消费中还未返回消费结果的状态；&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;Commit：提交状态。消费成功的状态，消费者返回成功响应即可结束消息的状态机；&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;DLQ：死信状态&lt;br/&gt;消费逻辑的最终兜底机制，若消息一直处理失败并不断进行重试，直到超过最大重试次数还未成功，此时消息不会再重试。&lt;br/&gt;该消息会被投递至死信队列。您可以通过消费死信队列的消息进行业务恢复。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt; &lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;h4&gt;&lt;strong&gt;&lt;span&gt;最大重试次数&lt;/span&gt;&lt;/strong&gt;&lt;/h4&gt;&lt;h4&gt;&lt;strong&gt;&lt;span&gt; &lt;/span&gt;&lt;/strong&gt;&lt;span/&gt;&lt;/h4&gt;&lt;/li&gt;&lt;/ul&gt;&lt;section&gt;&lt;span&gt;PushConsumer 的最大重试次数由创建时决定。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;例如，最大重试次数为 3 次，则该消息最多可被投递 4 次，1 次为原始消息，3 次为重试投递次数。&lt;/span&gt;&lt;/section&gt;&lt;h4&gt;&lt;strong&gt;&lt;span&gt; &lt;/span&gt;&lt;/strong&gt;&lt;span/&gt;&lt;/h4&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;无序消息（非顺序消息）：重试间隔为阶梯时间，具体时间如下：&lt;br/&gt;&lt;strong&gt;说明&lt;/strong&gt;：若重试次数超过 16 次，后面每次重试间隔都为 2 小时。&lt;/span&gt;&lt;span/&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;258&quot; data-backw=&quot;578&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.44558697514995715&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/yvBJb5Iiafvl3oZeCmhub2AlQh82zA6icYfTpfr4AcXTCIm774wLuF0ibZP21odnItIRu6Qx0bTdo31K8iaud8iboNg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1167&quot;/&gt;&lt;/section&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;h3&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;5. SimpleConsumer 消费重试策略&lt;/span&gt;&lt;/h3&gt;&lt;/section&gt;&lt;h3&gt;&lt;span/&gt;&lt;/h3&gt;&lt;section&gt;&lt;span&gt;和 PushConsumer 消费重试策略不同，SimpleConsumer 消费者的重试间隔是预分配的，每次获取消息消费者会在调用 API 时设置一个不可见时间参数 &lt;strong&gt;InvisibleDuration&lt;/strong&gt;，即消息的最大处理时长。若消息消费失败触发重试，不需要设置下一次重试的时间间隔，直接复用不可见时间参数的取值。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;159&quot; data-backw=&quot;578&quot; data-ratio=&quot;0.27507163323782235&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/yvBJb5Iiafvl3oZeCmhub2AlQh82zA6icY5XkBdJnLFw25yibbqmW05UK4GZWRXLFgiarzTjy0EMhlSXoko8dT3b5Q/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1047&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;由于不可见时间为预分配的，可能和实际业务中的消息处理时间差别较大，可以通过 API 接口修改不可见时间。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;例如，预设消息处理耗时最多 20 ms，但实际业务中 20 ms内消息处理不完，可以修改消息不可见时间，延长消息处理时间，避免消息触发重试机制。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;修改消息不可见时间需要满足以下条件：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;如下图所示，消息不可见时间修改后立即生效，即从调用 API 时刻开始，重新计算消息不可见时间。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;262&quot; data-backw=&quot;578&quot; data-ratio=&quot;0.45414847161572053&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/yvBJb5Iiafvl3oZeCmhub2AlQh82zA6icYKVE1Soic9Ye3ZJBjC4sDhUrG7WicKk9UeRb5kzAXFztdU7WhcXvdjO3Q/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;687&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;与 PushConsumer 相同。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;消息重试间隔 = 不可见时间 － 消息实际处理时长&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;例如：消息不可见时间为 30 ms，实际消息处理用了 10 ms 就返回失败响应，则距下次消息重试还需要 20 ms，此时的消息重试间隔即为 20 ms；若直到 30 ms 消息还未处理完成且未返回结果，则消息超时，立即重试，此时重试间隔即为 0 ms。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;SimpleConsumer 的消费重试间隔通过消息的不可见时间控制。&lt;/span&gt;&lt;/section&gt;&lt;pre data-language=&quot;plain&quot;&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;php&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;ClientServiceProvider provider1 = ClientServiceProvider.loadService();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;String topic1 = &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;Your Topic&quot;&lt;/span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;FilterExpression filterExpression1 = &lt;span class=&quot;code-snippet__keyword&quot;&gt;new&lt;/span&gt; FilterExpression(&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;Your Filter Tag&quot;&lt;/span&gt;, FilterExpressionType.TAG);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;SimpleConsumer simpleConsumer = provider1.newSimpleConsumerBuilder()&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        .setConsumerGroup(&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;Your ConsumerGroup&quot;&lt;/span&gt;)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        .setClientConfiguration(ClientConfiguration.newBuilder().setEndpoints(&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;Your Endpoint&quot;&lt;/span&gt;).build())&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        .setSubscriptionExpressions(Collections.singletonMap(topic, filterExpression))&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        .build();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;List&lt;/span&gt;&amp;lt;MessageView&amp;gt; messageViewList = &lt;span class=&quot;code-snippet__keyword&quot;&gt;null&lt;/span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;try&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    messageViewList = simpleConsumer.receive(&lt;span class=&quot;code-snippet__number&quot;&gt;10&lt;/span&gt;, Duration.ofSeconds(&lt;span class=&quot;code-snippet__number&quot;&gt;30&lt;/span&gt;));&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    messageViewList.&lt;span class=&quot;code-snippet__keyword&quot;&gt;forEach&lt;/span&gt;(messageView -&amp;gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        System.out.println(messageView);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__keyword&quot;&gt;try&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            simpleConsumer.ack(messageView);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        } &lt;span class=&quot;code-snippet__keyword&quot;&gt;catch&lt;/span&gt; (ClientException e) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            e.printStackTrace();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    });&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;} &lt;span class=&quot;code-snippet__keyword&quot;&gt;catch&lt;/span&gt; (ClientException e) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    e.printStackTrace();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;section&gt;&lt;span/&gt;&lt;/section&gt;&lt;/pre&gt;&lt;section&gt;&lt;span&gt;案例：某产品使用消息队列来发送解耦“视频渲染”的业务逻辑，发送方发送任务编号，消费方收到编号后处理任务。由于消费方的业务逻辑耗时较长，消费者重新消费到同一个任务时，该任务未完成，只能返回消费失败。在这种全新的 API 下，用户可以调用可以通过修改不可见时间给消息续期，实现对单条消息状态的精确控制。&lt;/span&gt;&lt;/section&gt;&lt;pre data-language=&quot;plain&quot;&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;css&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__selector-tag&quot;&gt;simpleConsumer&lt;/span&gt;&lt;span class=&quot;code-snippet__selector-class&quot;&gt;.changeInvisibleDuration&lt;/span&gt;();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__selector-tag&quot;&gt;simpleConsumer&lt;/span&gt;&lt;span class=&quot;code-snippet__selector-class&quot;&gt;.changeInvisibleDurationAsync&lt;/span&gt;();&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;section&gt;&lt;span/&gt;&lt;/section&gt;&lt;/pre&gt;&lt;h3&gt;&lt;span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/span&gt;&lt;/h3&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;h3&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;6. 功能约束与最佳实践&lt;/span&gt;&lt;/h3&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;尽快明确的向服务端返回成功或失败，不要以超时（有时是异常抛出）代替消费失败。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;错误示例：&lt;/span&gt;&lt;span&gt;如果当前消费速度过高触发限流，则返回消费失败，等待下次重新消费。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;正确示例：&lt;/span&gt;&lt;span&gt;如果当前消费速度过高触发限流，则延迟获取消息，稍后再消费。&lt;/span&gt;&lt;/section&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;发送重试和消费重试会导致相同的消息&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;重复消费&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;strong&gt;&lt;span&gt;，消费方应该有一个&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;良好的幂等设计&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt; &lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;section&gt;&lt;strong&gt;&lt;span/&gt;&lt;/strong&gt;&lt;span&gt;正确示例：某系统中消费的逻辑是为某个用户发送短信，该短信已经发送成功了，当消费者应用重复收到该消息，此时应该返回消费成功。&lt;/span&gt;&lt;/section&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-role=&quot;paragraph&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-role=&quot;title&quot; data-tools=&quot;135编辑器&quot; data-id=&quot;106625&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-brushtype=&quot;text&quot; hm_fix=&quot;343:395&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p&gt;&lt;strong&gt;&lt;em&gt;总结&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-width=&quot;100%&quot; data-role=&quot;list&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p&gt;&lt;span&gt;&lt;em&gt;Cloud Native&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;本文主要介绍重试的基本概念，生产者消费者收发消息时触发重试的条件和具体行为，以及 RocketMQ 收发容错的最佳实践。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;重试策略帮助我们从随机的、短暂的瞬态故障中恢复，是在容忍错误时，提高可用性的一种强大机制。但请谨记 “重试是对于分布式系统来说自私的”，因为客户端认为其请求很重要，并要求服务端花费更多资源来处理，盲目的重试设计不可取，合理的使用重试可以帮助我们构建更加弹性且可靠的系统。&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;欢迎扫描下方二维码加入钉钉群一起沟通交流～&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/yvBJb5Iiafvl3oZeCmhub2AlQh82zA6icYicEIF2WMMAVU8pZpZDIPZaTWJuqJbMTeN3gclHJpOE32Gxwvo2mUARQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;868&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;点击阅读原文，进入官网了解更多详情～&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;mp-style-type data-value=&quot;3&quot;/&gt;&lt;/p&gt;&lt;/div&gt;

          
        &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>