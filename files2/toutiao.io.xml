<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>26c22eea2f3f46d46211b459e63263fb</guid>
<title>微服务治理热门技术揭秘：动态读写分离</title>
<link>https://toutiao.io/k/bu7lntc</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content                                       &quot; id=&quot;js_content&quot;&gt;&lt;p data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;82&quot; data-backw=&quot;578&quot; data-ratio=&quot;0.14106583072100312&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_gif/qdzZBE73hWvNG9VjIS9sOow1MoYQgibicAhyLCiagyqhMVMBR5LiaLDIwVjiayNbjG4682icRrJOrll5bkJu9kebAQHA/640?wx_fmt=gif&quot; data-type=&quot;gif&quot; data-w=&quot;638&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;我们从应用的视角出发整理抽象了我们在访问、使用数据库时场景的一些稳定性治理、性能优化、提效等方面的实战经验，对于每一个后端应用来说，数据库无疑是重中之重，我们希望通过我们的数据库治理能力，可以帮助到大家更好地使用数据库服务。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;250&quot; data-backw=&quot;578&quot; data-ratio=&quot;0.4322033898305085&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/qdzZBE73hWujuL1HP2q8gaF6BZzSFvHjcfZiamC5UIRqkAq2ib4fOrscKoB8tgJibvPjIQogyeicnwG3aBc74eibNVg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1888&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;MSE 数据库治理完整解决方案&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;本文将详细介绍 MSE 数据库治理的热点功能，动态读写分离的设计与实现。&lt;/span&gt;&lt;/section&gt;&lt;h1&gt;&lt;span/&gt;&lt;/h1&gt;&lt;p&gt;&lt;span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-role=&quot;title&quot; data-tools=&quot;135编辑器&quot; data-id=&quot;106625&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;strong mpa-from-tpl=&quot;t&quot;&gt;01&lt;/strong&gt;&lt;strong data-original-title=&quot;&quot; title=&quot;&quot; data-num=&quot;3&quot; mpa-from-tpl=&quot;t&quot;/&gt;&lt;/section&gt;&lt;section data-brushtype=&quot;text&quot; hm_fix=&quot;343:395&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p&gt;&lt;strong mpa-from-tpl=&quot;t&quot;&gt;读写分离的概述&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-width=&quot;100%&quot; data-role=&quot;list&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p&gt;&lt;span&gt;&lt;em&gt;&lt;span&gt;Aliware&lt;/span&gt;&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;数据库动态读写分离的常见场景：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;一个大客户的请求过来，查询数据库返回上万条几百 M 的数据，数据库的 CPU 直接打满。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt; &lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;微服务应用的某些业务并不是那么重要，却存在大量查询数据库的逻辑，影响数据库实例稳定性，从而导致整体服务质量的下降。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt; &lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;在业务处理过程中，如果对数据库的读操作远多于写操作，那么在做系统性能优化时就可以考虑引入读写分离的方案，一方面只读库可以承担主库的压力，另一方面能够有效的避免由数据更新导致的锁等待，提升微服务应用的性能。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt; &lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;随着业务的增长，我们在一定时机下需要对数据库实例进行扩容。根据经验大多数应用的读写比都在 5:1 以上，有些场景甚至大量的高于 10:1，在对数据库有少量写请求，但有大量读请求的应用场景下，单个实例可能无法承受读取压力，甚至对业务产生影响。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;可以了解到的是数据库读写分离方案可以满足阿里云上大多数公司的稳定性治理、性能提升以及数据库扩容的需求。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;299&quot; data-backw=&quot;578&quot; data-ratio=&quot;0.5168018539976825&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/qdzZBE73hWujuL1HP2q8gaF6BZzSFvHjp5sqmozDD2oialpHmQfL7YlSdP9cp2LPXzJPNpB3ic40IYDkTqZrbfRg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1726&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;如果了解读写分离实现的同学一定会关注以下这些问题：&lt;/span&gt;&lt;/section&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;MSE 是如何解决读写分离对业务的侵入性？如何做到业务无需改动一行代码，即可具备读写分离能力。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt; &lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;MSE 如何做到精细化动态的读写分离控制？即使我们不知道这个业务接口真实的 SQL 是什么，但我们已经可以控制这个接口的读 SQL 访问只读实例。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt; &lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;MSE 是如何解决读写分离带来的一致性问题？对于一致性敏感的业务，如何实现一致性的保障，满足业务在不同场景下对一致性级别的要求。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-role=&quot;title&quot; data-tools=&quot;135编辑器&quot; data-id=&quot;106625&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;strong mpa-from-tpl=&quot;t&quot;&gt;02&lt;/strong&gt;&lt;strong data-original-title=&quot;&quot; title=&quot;&quot; data-num=&quot;3&quot; mpa-from-tpl=&quot;t&quot;/&gt;&lt;/section&gt;&lt;section data-brushtype=&quot;text&quot; hm_fix=&quot;343:395&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p&gt;&lt;strong mpa-from-tpl=&quot;t&quot;&gt;MSE 读写分离技术揭秘&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-width=&quot;100%&quot; data-role=&quot;list&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p&gt;&lt;span&gt;&lt;em&gt;&lt;span&gt;Aliware&lt;/span&gt;&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;读写分离也就是将数据库拆分为主库和从库，即主库负责处理事务性的增删改操作，从库负责处理查询操作的数据库架构。单单看读写分离的概念，第一感觉就是对业务的侵入性一定不小，那么 MSE 是如何做到无侵入的呢？&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-role=&quot;title&quot; data-tools=&quot;135编辑器&quot; data-id=&quot;107115&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section hm_fix=&quot;320:270&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;span&gt;&lt;strong mpa-from-tpl=&quot;t&quot;&gt;01&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;&lt;strong mpa-from-tpl=&quot;t&quot;&gt;&lt;span&gt;无侵入性：无需修改一行代码&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;MSE 数据库治理能力通过 JavaAgent 技术，动态增加用户的数据源，注入动态读写分离能力，支持运行时动态将弱读请求路由至只读实例。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;251&quot; data-backw=&quot;530&quot; data-ratio=&quot;0.47358490566037736&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/qdzZBE73hWujuL1HP2q8gaF6BZzSFvHj4TYfLRfoxPdVv7bG3UA39FjmLw8mTCUyyoXoiaY0KmruEfY7x9nM1sg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1060&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;MSE 在数据源层面实现了抽象，其中 DynamicConnection、DynamicStatement 会根据具体规则从而实现 Master/Slaver 的切换，做到根据 SQL 的读写类型、事务的状态以及用户的业务规则来做 SQL 的路由，将符合条件的读 SQL 请求转发至 RDS 只读实例中。&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;325&quot; data-backw=&quot;578&quot; data-ratio=&quot;0.5631901840490797&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/qdzZBE73hWujuL1HP2q8gaF6BZzSFvHjdicBvNsLch4lrd6vb4lkQS1Etaibxxejob6AqxFQibdDiaUZjpkicUsY1icw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1630&quot;/&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-role=&quot;title&quot; data-tools=&quot;135编辑器&quot; data-id=&quot;107115&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section hm_fix=&quot;320:270&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;span&gt;&lt;strong mpa-from-tpl=&quot;t&quot;&gt;02&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;&lt;strong mpa-from-tpl=&quot;t&quot;&gt;&lt;span&gt;精细化路由：按照请求条件、接口、SQL 多层次多条件&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;很多时候我们通过编写 DAO 访问数据库，那么在一些复杂应用的场景下，我们很可能只知道 DAO 接口，在一些复杂场景下我们只知道微服务的接口，内部甚至搞不清楚到底调用的哪个 DAO 接口、SQL 语句，甚至如果是运维角色参与设计，我们很可能不知道哪个微服务接口导致的读请求导致数据库抖动，我们只知道入口应用的某个 uid。那么我们如何做到对业务接口内的读请求路由至只读实例呢？&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;MSE 数据库治理提供了应用层面完整的 callStack 信息，可以让我们站在应用的视角上清晰地看到哪些接口内部执行了哪些 SQL。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;398&quot; data-backw=&quot;578&quot; data-ratio=&quot;0.6890862944162437&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/qdzZBE73hWujuL1HP2q8gaF6BZzSFvHjNxwskwVcTrWUSrcV19iaTiaylPaCrx2iawPoeF6qTFxZA0Q4OnuicPrGGg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1576&quot;/&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;MSE 通过链路传递技术，支持在入口微服务、微服务接口、DAO 层面标记弱读请求的标记，支持标记的当前线程内的 SQL 调用、当前微服务内的 SQL 调用、符合流量条件的请求链路级别的所有 SQL 调用等多个层面的弱读标记传递，最终传递给读写分离组件的路由引擎进行  SQL 的路由依据的判断。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;204&quot; data-backw=&quot;562&quot; data-ratio=&quot;0.362555720653789&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/qdzZBE73hWujuL1HP2q8gaF6BZzSFvHjdypKTgjcJlQenVC4tmFrxOhfsfbFKEjPmrHIMSFS7pekIka2CdgcoA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;673&quot;/&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-role=&quot;title&quot; data-tools=&quot;135编辑器&quot; data-id=&quot;107115&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section hm_fix=&quot;320:270&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;span&gt;&lt;strong mpa-from-tpl=&quot;t&quot;&gt;03&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;强一致性模式：指定接口、事务&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;当数据库负载很高时，例如对大表执行 DDL（如加字段）操作或大批量插入数据的时候，延迟会非常严重，从而导致无法从只读实例中读取最新数据。MSE 提供了一些策略解决如上问题，某些接口或者某些业务对一致性比较非常高，我们可以通过规则配置告诉 MSE 在特定场景下，某些读接口标记为强读请求。&lt;/span&gt;&lt;span&gt;MSE 内部会通过一些机制保证读写分离的强一致性效果。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-role=&quot;title&quot; data-tools=&quot;135编辑器&quot; data-id=&quot;107115&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section hm_fix=&quot;320:270&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;span&gt;&lt;strong mpa-from-tpl=&quot;t&quot;&gt;04&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;&lt;strong mpa-from-tpl=&quot;t&quot;&gt;&lt;span&gt;白屏化能力：通过 AccessLog 实时感知读写分离情况&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;有读写分离能力，那么我们如何知道读写分离的执行情况，到底哪些应用，哪些请求被分离至了只读实例？MSE 白屏化能力提供了一套完整的 AccessLog。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;263&quot; data-backw=&quot;578&quot; data-ratio=&quot;0.4551422319474836&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/qdzZBE73hWujuL1HP2q8gaF6BZzSFvHjFTib4qHiaEcf0eJaUtmh6ryiagn6449dYOPoz8XlCbRUReWub4AuombyQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1828&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;229&quot; data-backw=&quot;578&quot; data-ratio=&quot;0.3950749464668094&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/qdzZBE73hWujuL1HP2q8gaF6BZzSFvHjnTQWcf3QZa2zxAbXpn6V5JGQlgfU3ZibbY7GtgrtwPQlJYic2oVrg7Xw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1868&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-role=&quot;title&quot; data-tools=&quot;135编辑器&quot; data-id=&quot;106625&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;strong mpa-from-tpl=&quot;t&quot;&gt;03&lt;/strong&gt;&lt;strong data-original-title=&quot;&quot; title=&quot;&quot; data-num=&quot;3&quot; mpa-from-tpl=&quot;t&quot;/&gt;&lt;/section&gt;&lt;section data-brushtype=&quot;text&quot; hm_fix=&quot;343:395&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p&gt;&lt;strong mpa-from-tpl=&quot;t&quot;&gt;总结&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-width=&quot;100%&quot; data-role=&quot;list&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p&gt;&lt;span&gt;&lt;em&gt;&lt;span&gt;Aliware&lt;/span&gt;&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;MSE 从应用的视角出发，结合微服务治理通用的技术，MSE 推出的是完整的数据库治理解决方案，从 SQL 洞察、SQL 流控降级与容错、连接池治理到数据库灰度、动态读写分离。我们希望通过数据库治理能力可以帮助用户的微服务可以更好地使用数据库，降低数据库使用的成本，提升数据库访问的稳定性。&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;MSE 的数据库治理能力也需要更多更加深入的客户场景与落地实践，如果您对 MSE 的数据库治理能力感兴趣，欢迎联系我们，只有经过客户打磨的产品才会愈发历久弥新。&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;在建设数据库治理能力的同时，我们也通过 OpenSergo 在与社区共同建设数据库治理的标准。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;294&quot; data-backw=&quot;578&quot; data-ratio=&quot;0.509090909090909&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/qdzZBE73hWujuL1HP2q8gaF6BZzSFvHjzLGAQicC2ibX0fYEh6FM0Vtic1HvuekwTaELjF1Rwa0V4c2azwMW1TJRg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1210&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;OpenSergo 在联合各个社区进行进一步的合作，希望通过社区来一起讨论与定义统一的服务治理标准。当前社区也在联合 bilibili、字节跳动等企业一起共建标准，也欢迎感兴趣的开发者、社区与企业一起加入到 OpenSergo 服务治理标准共建中。欢迎大家加入 OpenSergo 社区交流群（钉钉群）进行讨论：34826335&lt;/span&gt;&lt;/section&gt;&lt;/div&gt;

          

          
          &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>7853433e2012c29131f43e62ec9e14df</guid>
<title>ping 命令还能这么玩？</title>
<link>https://toutiao.io/k/j0k9n5i</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content                                       &quot; id=&quot;js_content&quot;&gt;&lt;p data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;span&gt;&lt;span&gt;点击下方“&lt;/span&gt;&lt;span&gt;IT牧场&lt;/span&gt;&lt;span&gt;”，选择“设为星标”&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;section class=&quot;mp_profile_iframe_wrp&quot;&gt;&lt;mp-common-profile data-index=&quot;0&quot; data-id=&quot;MzI4ODQ3NjE2OA==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/C93dCHmGrWzo3r2IwZzjK44WxQwhDAlhygicTbLH8Xv5wYClRpZJvoMxJIH9oPnRcGuKneSYicF3SOvJOaB34OibQ/0?wx_fmt=png&quot; data-nickname=&quot;程序员大目&quot; data-alias=&quot;itmuch_com&quot; data-signature=&quot;BAT 技术专家分享开发、架构、运维相关干货！&quot; data-origin_num=&quot;159&quot; data-is_biz_ban=&quot;0&quot; data-isban=&quot;0&quot; class=&quot;js_wx_tap_highlight&quot; data-from=&quot;2&quot; has-insert-preloading=&quot;1&quot;/&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;138861685132836864&quot; data-gallerysupplier=&quot;5&quot; data-ratio=&quot;0.6666666666666666&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/C93dCHmGrWxicPiam0hFIldlAq5aJliaV2OMnNJpcZsxA5JhicIS1picorszesol6cJ4ovDZkiaZeicpy2KWRg6vicpMHw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1023&quot;/&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-paragraph-type=&quot;ignored&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-paragraph-type=&quot;ignored&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-paragraph-type=&quot;ignored&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-paragraph-type=&quot;ignored&quot;&gt;&lt;p&gt;&lt;span&gt;说实话，我以为ping就仅仅用来判断网络通不通，哈哈哈哈~&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;作者：Pheenet菲尼特&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;https://www.toutiao.com/a6783191796659782148&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;有朋友反映，能不能讲下 ping 命令的使用，其实对于命令的使用我们之前提到过一些，但对 ping 命令没有过多讲解，一般我们用的都是它的基本功能，今天我们来详细看下 ping 命令详细使用。&lt;/span&gt;&lt;/p&gt;&lt;h3&gt;&lt;span&gt;一、ping 基本使用详解&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;&lt;span&gt;在网络中 ping 是一个十分强大的 TCP/IP 工具。它的作用主要为：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;1、用来检测网络的连通情况和分析网络速度&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;2、根据域名得到服务器 IP&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;3、根据 ping 返回的 TTL 值来判断对方所使用的操作系统及数据包经过路由器数量。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;我们通常会用它来直接 ping ip 地址，来测试网络的连通情况。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.43243243243243246&quot; data-type=&quot;jpeg&quot; data-w=&quot;592&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/9Eibnmwqk0AjNqP7bYINDpko5RNsRcq41GQibqQicJyEibDibRTuGqvO8w8mzicDfNjOP8kljqlM2jU1ib66HHgxsc7Bw/640?wx_fmt=jpeg&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;类如这种，直接 ping ip 地址或网关，ping 通会显示出以上数据，有朋友可能会问，bytes=32；time&amp;lt;1ms；TTL=128 这些是什么意思。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;bytes 值：&lt;/strong&gt;数据包大小，也就是字节。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;time 值：&lt;/strong&gt;响应时间，这个时间越小，说明你连接这个地址速度越快。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;TTL 值：&lt;/strong&gt;Time To Live, 表示 DNS 记录在 DNS 服务器上存在的时间，它是 IP 协议包的一个值，告诉路由器该数据包何时需要被丢弃。可以通过 Ping 返回的 TTL 值大小，粗略地判断目标系统类型是 Windows 系列还是 UNIX/Linux 系列。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;默认情况下，Linux 系统的 TTL 值为 64 或 255，WindowsNT/2000/XP 系统的 TTL 值为 128，Windows98 系统的 TTL 值为 32，UNIX 主机的 TTL 值为 255。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;因此一般 TTL 值：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;100~130ms 之间，Windows 系统 ；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;240~255ms 之间，UNIX/Linux 系统。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;当然，我们今天主要了解并不是这些，而是 ping 的其它参考。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;ping 命令除了直接 ping 网络的 ip 地址，验证网络畅通和速度之外，它还有这些用法。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.99375&quot; data-type=&quot;jpeg&quot; data-w=&quot;640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/9Eibnmwqk0AjNqP7bYINDpko5RNsRcq415Ir8rS0kz8Zmrhsa9YKpo1eEaE56h6cAUZZZ84gWJWKLMmatgJksfg/640?wx_fmt=jpeg&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot;/&gt;&lt;/p&gt;&lt;h3&gt;&lt;span&gt;二、ping -t 的使用&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;&lt;span&gt;不间断地 Ping 指定计算机，直到管理员中断。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.7328125&quot; data-type=&quot;jpeg&quot; data-w=&quot;640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/9Eibnmwqk0AjNqP7bYINDpko5RNsRcq41JlbCcskia5sSrGiben3f7dAOyibjU9HRcURQQkm0ckG4hiaFlZKKX4dYdg/640?wx_fmt=jpeg&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;这就说明电脑连接路由器是通的，网络效果很好。下面按按住键盘的 Ctrl+c 终止它继续 ping 下去，就会停止了，会总结出运行的数据包有多少，通断的有多少了。&lt;/span&gt;&lt;/p&gt;&lt;h3&gt;&lt;span&gt;三、ping -a 的使用&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;&lt;span&gt;ping-a 解析计算机名与 NetBios 名。就是可以通过 ping 它的 ip 地址，可以解析出主机名。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.3075980392156863&quot; data-type=&quot;jpeg&quot; data-w=&quot;816&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/9Eibnmwqk0AjNqP7bYINDpko5RNsRcq41o515kclyQA0qPcJq47XROiasdfGdjBfUADQkrqwq5KNLGBAUbPs4qXQ/640?wx_fmt=jpeg&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot;/&gt;&lt;/p&gt;&lt;h3&gt;&lt;span&gt;四、ping -n 的使用&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;&lt;span&gt;在默认情况下，一般都只发送四个数据包，通过这个命令可以自己定义发送的个数，对衡量网络速度很有帮助，比如我想测试发送 10 个数据包的返回的平均时间为多少，最快时间为多少，最慢时间为多少就可以通过以下获知：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5234375&quot; data-type=&quot;jpeg&quot; data-w=&quot;640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/9Eibnmwqk0AjNqP7bYINDpko5RNsRcq41Sd8hvpnuR1YE4nNQN80hic1aHGUcf3neiaT2UiaU5sAcgqrMQ20b2FRjg/640?wx_fmt=jpeg&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;从以上我就可以知道在给 47.93.187.142 发送 10 个数据包的过程当中，返回了 10 个，没有丢失，这 10 个数据包当中返回速度最快为 32ms，最慢为 55ms，平均速度为 37ms。说明我的网络良好。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;如果对于一些不好的网络，比如监控系统中非常卡顿，这样测试，返回的结果可能会显示出丢失出一部分，如果丢失的比较多的话，那么就说明网络不好，可以很直观的判断出网络的情况。&lt;/span&gt;&lt;/p&gt;&lt;h3&gt;&lt;span&gt;五、ping -l size 的使用&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;&lt;span&gt;-l size：发送 size 指定大小的到目标主机的数据包。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在默认的情况下 Windows 的 ping 发送的数据包大小为 32byt，最大能发送 65500byt。当一次发送的数据包大于或等于 65500byt 时，将可能导致接收方计算机宕机。所以微软限制了这一数值；这个参数配合其它参数以后危害非常强大，比如攻击者可以结合 - t 参数实施 DOS 攻击。（所以它具有危险性，不要轻易向别人计算机使用）。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;例如：ping -l 65500 -t 211.84.7.46&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;会连续对 IP 地址执行 ping 命令，直到被用户以 Ctrl+C 中断.&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.853125&quot; data-type=&quot;jpeg&quot; data-w=&quot;640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/9Eibnmwqk0AjNqP7bYINDpko5RNsRcq412EJUGiaK8YHKT7qSsvGGToD6Rdv4W8aqoQRaW0DwtwOR42WX18ZFPRQ/640?wx_fmt=jpeg&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;这样它就会不停的向 211.84.7.46 计算机发送大小为 65500byt 的数据包，如果你只有一台计算机也许没有什么效果，但如果有很多计算机那么就可以使对方完全瘫痪，网络严重堵塞，由此可见威力非同小可。&lt;/span&gt;&lt;/p&gt;&lt;h3&gt;&lt;span&gt;六、ping -r count 的使用&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;&lt;span&gt;在 “记录路由” 字段中记录传出和返回数据包的路由，探测经过的&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;路由个数，但最多只能跟踪到 9 个路由。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;ping -n 1 -r 9 202.102.224.25 （发送一个数据包，最多记录 9 个路由）&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6375&quot; data-type=&quot;jpeg&quot; data-w=&quot;640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/9Eibnmwqk0AjNqP7bYINDpko5RNsRcq41SzPiaV1KdmXd7QQnHkMpQPSymjQAGx1ib6RicD8saT8xlgeKy92ougzpw/640?wx_fmt=jpeg&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;将经过 9 个路由都显示出来了，可以看上图。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;ping 命令用的较多的就这 6 类的，大家有可能在项目中会用到的。&lt;/span&gt;&lt;/p&gt;&lt;h3&gt;&lt;span&gt;七、批量 Ping 网段&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;&lt;span&gt;对于一个网段 ip 地址众多，如果单个检测实在麻烦，那么我们可以直接批量 ping 网段检测，那个 ip 地址出了问题，一目了然。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;先看代码，直接在命令行窗口输入：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;for /L %D in (1,1,255) do ping 10.168.1.%D&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;IP 地址段修改成你要检查的 IP 地址段。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.9953125&quot; data-type=&quot;jpeg&quot; data-w=&quot;640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/9Eibnmwqk0AjNqP7bYINDpko5RNsRcq41oXFHLbWDvCniaZRWdSiazZauicUMX8yLouV9MgX474cK1jUgxRbwZGFng/640?wx_fmt=jpeg&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;当输入批量命令后，那么它就自动把网段内所有的 ip 地址都 ping 完为止。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;那么这段 “for /L %D in(1,1,255) do ping 10.168.1.%D” 代码是什么意思呢？&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;代码中的这个 &lt;strong&gt;(1,1,255)&lt;/strong&gt; 就是网段起与始，就是检测网段 192.168.1.1 到 192.168.1.255 之间的所有的 ip 地址，每次逐增 1，直接到 1 到 255 这 255 个 ip 检测完为止。&lt;/span&gt;&lt;/p&gt;&lt;pre&gt;&lt;h2&gt;干货分享&lt;/h2&gt;&lt;blockquote&gt;&lt;p&gt;最近将个人学习笔记整理成册，使用PDF分享。关注我，回复如下代码，即可获得百度盘地址，无套路领取！&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;•&lt;/span&gt;001：《Java并发与高并发解决方案》学习笔记；&lt;/span&gt;&lt;span&gt;&lt;span&gt;•&lt;/span&gt;002：《深入JVM内核——原理、诊断与优化》学习笔记；&lt;/span&gt;&lt;span&gt;&lt;span&gt;•&lt;/span&gt;003：《Java面试宝典》&lt;/span&gt;&lt;span&gt;&lt;span&gt;•&lt;/span&gt;004：《Docker开源书》&lt;/span&gt;&lt;span&gt;&lt;span&gt;•&lt;/span&gt;005：《Kubernetes开源书》&lt;/span&gt;&lt;span&gt;&lt;span&gt;•&lt;/span&gt;006：《DDD速成（领域驱动设计速成）》&lt;/span&gt;&lt;span&gt;&lt;span&gt;•&lt;/span&gt;007：&lt;strong&gt;全部&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;•&lt;/span&gt;008：&lt;strong&gt;加技术群讨论&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;h2&gt;加个关注不迷路&lt;/h2&gt;&lt;section class=&quot;mp_profile_iframe_wrp&quot;&gt;&lt;mp-common-profile data-index=&quot;1&quot; data-id=&quot;MzI4ODQ3NjE2OA==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/C93dCHmGrWzo3r2IwZzjK44WxQwhDAlhygicTbLH8Xv5wYClRpZJvoMxJIH9oPnRcGuKneSYicF3SOvJOaB34OibQ/0?wx_fmt=png&quot; data-nickname=&quot;程序员大目&quot; data-alias=&quot;itmuch_com&quot; data-signature=&quot;BAT 技术专家分享开发、架构、运维相关干货！&quot; data-origin_num=&quot;159&quot; data-is_biz_ban=&quot;0&quot; data-isban=&quot;0&quot; class=&quot;js_wx_tap_highlight&quot; data-from=&quot;2&quot; has-insert-preloading=&quot;1&quot;/&gt;&lt;/section&gt;&lt;p&gt;&lt;small&gt;喜欢就点个&quot;在看&quot;呗^_^&lt;/small&gt;&lt;/p&gt;&lt;/pre&gt;&lt;/div&gt;

          

          
          &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>10466ac7cc9d30ca7acb2189addac4c7</guid>
<title>Redis 6 中的多线程是如何实现的！？</title>
<link>https://toutiao.io/k/c3kqthc</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot; data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;section&gt;Redis 是一个高性能服务端的典范。它通过多路复用 epoll 来管理海量的用户连接，只使用一个线程来通过事件循环来处理所有用户请求，就可以达到每秒数万 QPS 的处理能力。下图是单线程版本 Redis 工作的核心原理图（参见：&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzAwNDUxOTQ5MQ==&amp;amp;mid=2247522300&amp;amp;idx=2&amp;amp;sn=620d863280a0fffc76a15f6ac7451dc8&amp;amp;chksm=9b2874d0ac5ffdc671a34c0c294c8231b5768d8ae73701b91a8fb90b843766aa692b56a7b258&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;单线程 Redis 如何做到每秒‍数万 QPS 的超高处理能力！&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;11&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;&lt;strong&gt;单线程 Redis 如何做到每秒数万 QPS 的超高处理能力！&lt;/strong&gt;&lt;/a&gt;）。&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.9217221135029354&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/BBjAFF4hcwoBSguv1EpxBnEcEVKk4tyYpDx3n42FppzUPVz6qqv9LpojMsfVic1ogesNzKaGw0jybVsgapXxbxg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;511&quot;/&gt;&lt;/p&gt;&lt;section&gt;单线程的 Redis 虽然性能很高，但是却有两个问题。一个问题是没有办法充分发挥现代 CPU 的多核处理能力，一个实例只能使用一个核的能力。二是如果某个用户请求的处理过程卡住一段时间，会导致其它所有的请求都会出现超时的情况。所以，在线上的 redis 使用过程时是明确禁止使用 keys * 等长耗时的操作的。&lt;br/&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那如何改进呢，思路和方向其实很明确。那就是和其它的主流程序一样引入多线程，用更多的线程来分担这些可能耗时的操作。事实上 Redis 也确实这么干了，在 6.0 以后的版本里，开始支持了多线程。我们今天就来领略一下 Redis 的多线程是如何实现的。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;一、多线程 Redis 服务启动&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;首先获取多线程版本 Redis 的源码&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; git &lt;span&gt;clone&lt;/span&gt; https://github.com/redis/redis&lt;/span&gt;&lt;br/&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; &lt;span&gt;cd&lt;/span&gt; redis&lt;/span&gt;&lt;br/&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; git checkout -b 6.2.0 6.2.0&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;默认情况下多线程是默认关闭的。如果想要启动多线程，需要在配置文件中做适当的修改。相关的配置项是 io-threads 和 io-threads-do-reads 两个。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;vi /usr/&lt;span&gt;local&lt;/span&gt;/soft/redis6/conf/redis.conf &lt;/span&gt;&lt;br/&gt;io-threads 4 #启用的 io 线程数量&lt;br/&gt;io-threads-do-reads yes #读请求也使用io线程&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其中 io-threads 表示要启动的 io 线程的数量。io-threads-do-reads 表示是否在读阶段也使用 io 线程，默认是只在写阶段使用 io 线程的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;现在假设我们已经打开了如上两项多线程配置。带着这个假设，让我们进入到 Redis 的 main 入口函数。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;//file: src/server.c&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;int&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;(&lt;span&gt;int&lt;/span&gt; argc, &lt;span&gt;char&lt;/span&gt; **argv)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    ......&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;// 1.1 主线程初始化&lt;/span&gt;&lt;br/&gt;    initServer();&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;// 1.2 启动 io 线程&lt;/span&gt;&lt;br/&gt;    InitServerLast();&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;// 进入事件循环&lt;/span&gt;&lt;br/&gt;    aeMain(server.el);&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;1.1 主线程初始化&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在 initServer 这个函数内，Redis 主线程做了这么几件重要的事情。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.6492890995260664&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/BBjAFF4hcwoBSguv1EpxBnEcEVKk4tyYic6MVguOxd0U1biaRkIsXddUgLXiaAib0lg3hrcQFlsQAH7V9zLJkZbBNw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;422&quot;/&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;初始化读任务队列、写任务队列&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;创建一个 epoll 对象&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;对配置的监听端口进行 listen&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;把 listen socket 让 epoll 给管理起来&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;//file: src/server.c&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;void&lt;/span&gt; &lt;span&gt;initServer&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;// 1 初始化 server 对象&lt;/span&gt;&lt;br/&gt;    server.clients_pending_write = listCreate();&lt;br/&gt;    server.clients_pending_read = listCreate();&lt;br/&gt;    ......&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;// 2 初始化回调 events，创建 epoll&lt;/span&gt;&lt;br/&gt;    server.el = aeCreateEventLoop(server.maxclients+CONFIG_FDSET_INCR);&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;// 3 绑定监听服务端口&lt;/span&gt;&lt;br/&gt;    listenToPort(server.port,server.ipfd,&amp;amp;server.ipfd_count);&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;// 4 注册 accept 事件处理器&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;for&lt;/span&gt; (j = &lt;span&gt;0&lt;/span&gt;; j &amp;lt; server.ipfd_count; j++) {&lt;br/&gt;        aeCreateFileEvent(server.el, server.ipfd[j], AE_READABLE,&lt;br/&gt;            acceptTcpHandler,&lt;span&gt;NULL&lt;/span&gt;);&lt;br/&gt;    }&lt;br/&gt;    ...&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;接下来我们分别来看。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;初始化 server 对象&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在 initServer 的一开头，先是对 server 的各种成员变量进行初始化。值得注意的是 clients_pending_write 和 clients_pending_read 这两个成员，它们分别是写任务队列和读任务队列。将来主线程产生的任务都会放在放在这两个任务队列里。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;主线程会根据这两个任务队列来进行任务哈希散列，以将任务分配到多个线程中进行处理。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;aeCreateEventLoop 处理&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们来看 aeCreateEventLoop 详细逻辑。它会初始化事件回调 event，并且创建了一个 epoll 对象出来。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;//file:src/ae.c&lt;/span&gt;&lt;br/&gt;&lt;span&gt;aeEventLoop *&lt;span&gt;aeCreateEventLoop&lt;/span&gt;&lt;span&gt;(&lt;span&gt;int&lt;/span&gt; setsize)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    aeEventLoop *eventLoop;&lt;br/&gt;    eventLoop = zmalloc(&lt;span&gt;sizeof&lt;/span&gt;(*eventLoop);&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;//将来的各种回调事件就都会存在这里&lt;/span&gt;&lt;br/&gt;    eventLoop-&amp;gt;events = zmalloc(&lt;span&gt;sizeof&lt;/span&gt;(aeFileEvent)*setsize);&lt;br/&gt;    ......&lt;br/&gt;&lt;br/&gt;    aeApiCreate(eventLoop);&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; eventLoop;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们注意一下 eventLoop-&amp;gt;events，将来在各种事件注册的时候都会保存到这个数组里。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;//file:src/ae.h&lt;/span&gt;&lt;br/&gt;&lt;span&gt;typedef&lt;/span&gt; &lt;span&gt;&lt;span&gt;struct&lt;/span&gt; &lt;span&gt;aeEventLoop&lt;/span&gt; {&lt;/span&gt;&lt;br/&gt;    ......&lt;br/&gt;    aeFileEvent *events; &lt;span&gt;/* Registered events */&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;具体创建 epoll 的过程在 ae_epoll.c 文件下的 aeApiCreate 中。在这里，真正调用了 epoll_create&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;//file:src/ae_epoll.c&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; &lt;span&gt;aeApiCreate&lt;/span&gt;&lt;span&gt;(aeEventLoop *eventLoop)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    aeApiState *state = zmalloc(&lt;span&gt;sizeof&lt;/span&gt;(aeApiState));&lt;br/&gt;    state-&amp;gt;epfd = epoll_create(&lt;span&gt;1024&lt;/span&gt;); &lt;br/&gt;    eventLoop-&amp;gt;apidata = state;&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;绑定监听服务端口&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们再来看 Redis 中的 listen 过程，它在 listenToPort 函数中。调用链条很长，依次是 listenToPort =&amp;gt; anetTcpServer =&amp;gt; _anetTcpServer =&amp;gt; anetListen。在 anetListen 中，就是简单的 bind 和 listen 的调用。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;//file:src/anet.c&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; &lt;span&gt;anetListen&lt;/span&gt;&lt;span&gt;(......)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    bind(s,sa,len);&lt;br/&gt;    listen(s, backlog);&lt;br/&gt;    ......&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;注册事件回调函数&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;前面我们调用 aeCreateEventLoop 创建了 epoll，调用 listenToPort 进行了服务端口的 bind 和 listen。接着就调用的 aeCreateFileEvent 就是来注册一个 accept 事件处理器。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们来看 aeCreateFileEvent 具体代码。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;//file: src/ae.c&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;int&lt;/span&gt; &lt;span&gt;aeCreateFileEvent&lt;/span&gt;&lt;span&gt;(aeEventLoop *eventLoop, &lt;span&gt;int&lt;/span&gt; fd, &lt;span&gt;int&lt;/span&gt; mask,&lt;br/&gt;        aeFileProc *proc, &lt;span&gt;void&lt;/span&gt; *clientData)&lt;/span&gt;&lt;br/&gt;&lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;// 取出一个文件事件结构&lt;/span&gt;&lt;br/&gt;    aeFileEvent *fe = &amp;amp;eventLoop-&amp;gt;events[fd];&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;// 监听指定 fd 的指定事件&lt;/span&gt;&lt;br/&gt;    aeApiAddEvent(eventLoop, fd, mask);&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;// 设置文件事件类型，以及事件的处理器&lt;/span&gt;&lt;br/&gt;    fe-&amp;gt;mask |= mask;&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (mask &amp;amp; AE_READABLE) fe-&amp;gt;rfileProc = proc;&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (mask &amp;amp; AE_WRITABLE) fe-&amp;gt;wfileProc = proc;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;// 私有数据&lt;/span&gt;&lt;br/&gt;    fe-&amp;gt;clientData = clientData;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;函数 aeCreateFileEvent 一开始，从 eventLoop-&amp;gt;events 获取了一个 aeFileEvent 对象。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;接下来调用 aeApiAddEvent。这个函数其实就是对 epoll_ctl 的一个封装。主要就是实际执行 epoll_ctl EPOLL_CTL_ADD。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;//file:src/ae_epoll.c&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; &lt;span&gt;aeApiAddEvent&lt;/span&gt;&lt;span&gt;(aeEventLoop *eventLoop, &lt;span&gt;int&lt;/span&gt; fd, &lt;span&gt;int&lt;/span&gt; mask)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;// add or mod&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;int&lt;/span&gt; op = eventLoop-&amp;gt;events[fd].mask == AE_NONE ?&lt;br/&gt;            EPOLL_CTL_ADD : EPOLL_CTL_MOD;&lt;br/&gt;    ......&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;// epoll_ctl 添加事件&lt;/span&gt;&lt;br/&gt;    epoll_ctl(state-&amp;gt;epfd,op,fd,&amp;amp;ee);&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;每一个 eventLoop-&amp;gt;events 元素都指向一个 aeFileEvent 对象。在这个对象上，设置了三个关键东西&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;rfileProc：读事件回调&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;wfileProc：写事件回调&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;clientData：一些额外的扩展数据&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;将来 当 epoll_wait 发现某个 fd 上有事件发生的时候，这样 redis 首先根据 fd 到 eventLoop-&amp;gt;events 中查找 aeFileEvent 对象，然后再看 rfileProc、wfileProc 就可以找到读、写回调处理函数。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;回头看 initServer 调用 aeCreateFileEvent 时传参来看。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;//file: src/server.c&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;void&lt;/span&gt; &lt;span&gt;initServer&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    ......&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;for&lt;/span&gt; (j = &lt;span&gt;0&lt;/span&gt;; j &amp;lt; server.ipfd_count; j++) {&lt;br/&gt;        aeCreateFileEvent(server.el, server.ipfd[j], AE_READABLE,&lt;br/&gt;            acceptTcpHandler,&lt;span&gt;NULL&lt;/span&gt;);&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;listen fd 对应的读回调函数 rfileProc 事实上就被设置成了 acceptTcpHandler，写回调没有设置，私有数据 client_data 也为 null。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;1.2 io 线程启动&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在主线程启动以后，会调用 InitServerLast =&amp;gt; initThreadedIO 来创建多个 io 线程。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.47379454926624737&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/BBjAFF4hcwoBSguv1EpxBnEcEVKk4tyY5o3bxXR5YavuN1pmH0EHb63DFXwtpUYgV8KhJAPY4TLKHudicPcbwLQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;477&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;将来这些 IO 线程会配合主线程一起共同来处理所有的 read 和 write 任务。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.9035639412997903&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/BBjAFF4hcwoBSguv1EpxBnEcEVKk4tyYU4OgVsrMzW6HibFTfvcXbPhZb9Fe5KxFYJMnXPOfleDE20dUGciaicaCw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;477&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们来看 InitServerLast 创建 IO 线程的过程。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;//file:src/server.c&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;void&lt;/span&gt; &lt;span&gt;InitServerLast&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    initThreadedIO();&lt;br/&gt;    ......&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;//file:src/networking.c&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;void&lt;/span&gt; &lt;span&gt;initThreadedIO&lt;/span&gt;&lt;span&gt;(&lt;span&gt;void&lt;/span&gt;)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;//如果没开启多 io 线程配置就不创建了&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (server.io_threads_num == &lt;span&gt;1&lt;/span&gt;) &lt;span&gt;return&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;//开始 io 线程的创建&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; server.io_threads_num; i++) {&lt;br/&gt;        &lt;span&gt;pthread_t&lt;/span&gt; tid;&lt;br/&gt;        pthread_create(&amp;amp;tid,&lt;span&gt;NULL&lt;/span&gt;,IOThreadMain,(&lt;span&gt;void&lt;/span&gt;*)(&lt;span&gt;long&lt;/span&gt;)i)&lt;br/&gt;        io_threads[i] = tid;&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在 initThreadedIO 中调用 pthread_create 库函数创建线程，并且注册线程回调函数 IOThreadMain。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;//file:src/networking.c&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;void&lt;/span&gt; *&lt;span&gt;IOThreadMain&lt;/span&gt;&lt;span&gt;(&lt;span&gt;void&lt;/span&gt; *myid)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;long&lt;/span&gt; id = (&lt;span&gt;unsigned&lt;/span&gt; &lt;span&gt;long&lt;/span&gt;)myid;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;while&lt;/span&gt;(&lt;span&gt;1&lt;/span&gt;) {&lt;br/&gt;        &lt;span&gt;//循环等待任务&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; j = &lt;span&gt;0&lt;/span&gt;; j &amp;lt; &lt;span&gt;1000000&lt;/span&gt;; j++) {&lt;br/&gt;            &lt;span&gt;if&lt;/span&gt; (getIOPendingCount(id) != &lt;span&gt;0&lt;/span&gt;) &lt;span&gt;break&lt;/span&gt;;&lt;br/&gt;        }&lt;br/&gt;&lt;br/&gt;        &lt;span&gt;//允许主线程来关闭自己&lt;/span&gt;&lt;br/&gt;        ......&lt;br/&gt;&lt;br/&gt;        &lt;span&gt;//遍历当前线程等待队列里的请求 client&lt;/span&gt;&lt;br/&gt;        listIter li;&lt;br/&gt;        listNode *ln;&lt;br/&gt;        listRewind(io_threads_list[id],&amp;amp;li);&lt;br/&gt;        &lt;span&gt;while&lt;/span&gt;((ln = listNext(&amp;amp;li))) {&lt;br/&gt;            client *c = listNodeValue(ln);&lt;br/&gt;            &lt;span&gt;if&lt;/span&gt; (io_threads_op == IO_THREADS_OP_WRITE) {&lt;br/&gt;                writeToClient(c,&lt;span&gt;0&lt;/span&gt;);&lt;br/&gt;            } &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (io_threads_op == IO_THREADS_OP_READ) {&lt;br/&gt;                readQueryFromClient(c-&amp;gt;conn);&lt;br/&gt;            } &lt;span&gt;else&lt;/span&gt; {&lt;br/&gt;                serverPanic(&lt;span&gt;&quot;io_threads_op value is unknown&quot;&lt;/span&gt;);&lt;br/&gt;            }&lt;br/&gt;        }&lt;br/&gt;        listEmpty(io_threads_list[id]);&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;是将当前线程等待队列 io_threads_list[id] 里所有的请求 client，依次取出处理。其中读操作通过 readQueryFromClient 处理， 写操作通过 writeToClient 处理。其中 io_threads_list[id] 中的任务是主线程分配过来的，后面我们将会看到。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;二、主线程事件循环&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;接着我们进入到 Redis 最重要的 aeMain，这个函数就是一个死循环（Redis 不退出的话），不停地执行 aeProcessEvents 函数。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;void&lt;/span&gt; &lt;span&gt;aeMain&lt;/span&gt;&lt;span&gt;(aeEventLoop *eventLoop)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    eventLoop-&amp;gt;stop = &lt;span&gt;0&lt;/span&gt;;&lt;br/&gt;    &lt;span&gt;while&lt;/span&gt; (!eventLoop-&amp;gt;stop) {&lt;br/&gt;        aeProcessEvents(eventLoop, AE_ALL_EVENTS|&lt;br/&gt;                                   AE_CALL_BEFORE_SLEEP|&lt;br/&gt;                                   AE_CALL_AFTER_SLEEP);&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其中 aeProcessEvents 就是所谓的事件分发器。它通过调用 epoll_wait 来发现所发生的各种事件，然后调用事先注册好的处理函数进行处理。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.8891352549889135&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;451&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/BBjAFF4hcwoBSguv1EpxBnEcEVKk4tyYKEicFkic3mjhF3S2Y8iabUBN5ib3BP40X20ova2QAayur30ElOfJKEUbIg/640?wx_fmt=png&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;接着看 aeProcessEvents 函数。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;//file:src/ae.c&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;int&lt;/span&gt; &lt;span&gt;aeProcessEvents&lt;/span&gt;&lt;span&gt;(aeEventLoop *eventLoop, &lt;span&gt;int&lt;/span&gt; flags)&lt;/span&gt;&lt;br/&gt;&lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;// 2.3 事件循环处理3：epoll_wait 前进行读写任务队列处理&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (eventLoop-&amp;gt;beforesleep != &lt;span&gt;NULL&lt;/span&gt; &amp;amp;&amp;amp; flags &amp;amp; AE_CALL_BEFORE_SLEEP)&lt;br/&gt;            eventLoop-&amp;gt;beforesleep(eventLoop);&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;//epoll_wait发现事件并进行处理&lt;/span&gt;&lt;br/&gt;    numevents = aeApiPoll(eventLoop, tvp);&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;// 从已就绪数组中获取事件&lt;/span&gt;&lt;br/&gt;    aeFileEvent *fe = &amp;amp;eventLoop-&amp;gt;events[eventLoop-&amp;gt;fired[j].fd];&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;//如果是读事件，并且有读回调函数&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;//2.1 如果是 listen socket 读事件，则处理新连接请求&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;//2.2 如果是客户连接socket 读事件，处理客户连接上的读请求&lt;/span&gt;&lt;br/&gt;    fe-&amp;gt;rfileProc()&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;//如果是写事件，并且有写回调函数&lt;/span&gt;&lt;br/&gt;    fe-&amp;gt;wfileProc()&lt;br/&gt;    ......&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其中 aeApiPoll 就是对 epoll_wait 的一个封装而已。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;//file: src/ae_epoll.c&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; &lt;span&gt;aeApiPoll&lt;/span&gt;&lt;span&gt;(aeEventLoop *eventLoop, struct timeval *tvp)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;// 等待事件&lt;/span&gt;&lt;br/&gt;    aeApiState *state = eventLoop-&amp;gt;apidata;&lt;br/&gt;    epoll_wait(state-&amp;gt;epfd,state-&amp;gt;events,eventLoop-&amp;gt;setsize,&lt;br/&gt;            tvp ? (tvp-&amp;gt;tv_sec*&lt;span&gt;1000&lt;/span&gt; + tvp-&amp;gt;tv_usec/&lt;span&gt;1000&lt;/span&gt;) : &lt;span&gt;-1&lt;/span&gt;);&lt;br/&gt;    ...&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;aeProcessEvents 就是调用 epoll_wait 来发现事件。当发现有某个 fd 上事件发生以后，则调为其事先注册的事件处理器函数 rfileProc 和 wfileProc。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;2.1 事件循环处理1：新连接到达&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在 1.1 节中我们看到，主线程初始化的时候，将 listen socket 上的读事件处理函数注册成了 acceptTcpHandler。也就是说如果有新连接到达的时候，acceptTcpHandler 将会被执行到。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.7018255578093306&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;493&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/BBjAFF4hcwoBSguv1EpxBnEcEVKk4tyYe5icxVGhKl5JpCPq00o1EialahwSEPTtaF5aFu8Fs0pibBCj7RCbhvLsg/640?wx_fmt=png&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在这个函数内，主要完成如下几件事情。&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;调用 accept 接收连接&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;创建一个 redisClient对象&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;添加到 epoll&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;注册读事件处理函数&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;接下来让我们进入 acceptTcpHandler 源码。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;//file:src/networking.c&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;void&lt;/span&gt; &lt;span&gt;acceptTcpHandler&lt;/span&gt;&lt;span&gt;(aeEventLoop *el, &lt;span&gt;int&lt;/span&gt; fd, &lt;span&gt;void&lt;/span&gt; *privdata, &lt;span&gt;int&lt;/span&gt; mask)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    ......&lt;br/&gt;    cfd = anetTcpAccept(server.neterr, fd, cip, &lt;span&gt;sizeof&lt;/span&gt;(cip), &amp;amp;cport);&lt;br/&gt;    acceptCommonHandler(connCreateAcceptedSocket(cfd),&lt;span&gt;0&lt;/span&gt;,cip);&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其中 netTcpAccept 调用 accept 系统调用获取连接，就不展开了。我们看 acceptCommonHandler。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;//file: src/networking.c&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;acceptCommonHandler&lt;/span&gt;&lt;span&gt;(&lt;span&gt;int&lt;/span&gt; fd, &lt;span&gt;int&lt;/span&gt; flags)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;// 创建客户端&lt;/span&gt;&lt;br/&gt;    redisClient *c;&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; ((c = createClient(fd)) == &lt;span&gt;NULL&lt;/span&gt;) {&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;client *&lt;span&gt;createClient&lt;/span&gt;&lt;span&gt;(connection *conn)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    client *c = zmalloc(&lt;span&gt;sizeof&lt;/span&gt;(client));&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;// 为用户连接注册读事件处理器&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (conn) {&lt;br/&gt;        ...&lt;br/&gt;        connSetReadHandler(conn, readQueryFromClient);&lt;br/&gt;        connSetPrivateData(conn, c);&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    selectDb(c,&lt;span&gt;0&lt;/span&gt;);&lt;br/&gt;    c-&amp;gt;id = client_id;&lt;br/&gt;    c-&amp;gt;resp = &lt;span&gt;2&lt;/span&gt;;&lt;br/&gt;    c-&amp;gt;conn = conn;&lt;br/&gt;    ......&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在上面的代码中，我们重点关注 &lt;code&gt;connSetReadHandler(conn, readQueryFromClient)&lt;/code&gt;, 这一行是将这个新连接的读事件处理函数设置成了 readQueryFromClient。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;2.2 事件循环处理2：用户命令请求到达&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在上面我们看到了， Redis 把用户连接上的读请求处理函数设置成了 readQueryFromClient，这意味着当用户连接上有命令发送过来的时候，会进入 readQueryFromClient 开始执行。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在多线程版本的 readQueryFromClient 中，处理逻辑非常简单，仅仅只是将发生读时间的 client 放到了任务队列里而已。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.7990762124711316&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;433&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/BBjAFF4hcwoBSguv1EpxBnEcEVKk4tyYxycicB3JUTMCNW0cZEKMSZB1xxD4oCQE8SWDiauPq5CNcT7YPAibXzpAw/640?wx_fmt=png&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;来详细看 readQueryFromClient 代码。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;//file:src/networking.c&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;void&lt;/span&gt; &lt;span&gt;readQueryFromClient&lt;/span&gt;&lt;span&gt;(connection *conn)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    client *c = connGetPrivateData(conn);&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;//如果启动 threaded I/O 的话，直接入队&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (postponeClientRead(c)) &lt;span&gt;return&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;//处理用户连接读请求&lt;/span&gt;&lt;br/&gt;    ......&lt;br/&gt;    c-&amp;gt;querybuf = sdsMakeRoomFor(c-&amp;gt;querybuf, readlen);&lt;br/&gt;    nread = connRead(c-&amp;gt;conn, c-&amp;gt;querybuf+qblen, readlen);&lt;br/&gt;    processInputBuffer(c);&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在 postponeClientRead 中判断，是不是开启了多 io 线程，如果开启了的话，那就将有请求数据到达的 client 直接放到读任务队列（server.clients_pending_read）中就算是完事。我们看下 postponeClientRead。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;//file:src/networking.c&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;int&lt;/span&gt; &lt;span&gt;postponeClientRead&lt;/span&gt;&lt;span&gt;(client *c)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (server.io_threads_active &amp;amp;&amp;amp;&lt;br/&gt;        server.io_threads_do_reads &amp;amp;&amp;amp;&lt;br/&gt;        !ProcessingEventsWhileBlocked &amp;amp;&amp;amp;&lt;br/&gt;        !(c-&amp;gt;flags &amp;amp; (CLIENT_MASTER|CLIENT_SLAVE|CLIENT_PENDING_READ)))&lt;br/&gt;    {&lt;br/&gt;        c-&amp;gt;flags |= CLIENT_PENDING_READ;&lt;br/&gt;        listAddNodeHead(server.clients_pending_read,c);&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;1&lt;/span&gt;;&lt;br/&gt;    } &lt;span&gt;else&lt;/span&gt; {&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;;&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;listAddNodeHead 就是把这个 client 对象添加到 server.clients_pending_read 而已。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;2.3 事件循环处理3：epoll_wait 前进行任务处理&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在 aeProcessEvents 中假如 aeApiPoll(epoll_wait)中的事件都处理完了以后，则会进入下一次的循环再次进入 aeProcessEvents。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;而这一次中 beforesleep 将会处理前面读事件处理函数添加的读任务队列了。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;//file:src/ae.c&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;int&lt;/span&gt; &lt;span&gt;aeProcessEvents&lt;/span&gt;&lt;span&gt;(aeEventLoop *eventLoop, &lt;span&gt;int&lt;/span&gt; flags)&lt;/span&gt;&lt;br/&gt;&lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;// 参见 2.4 事件循环处理3：epoll_wait 前进行任务处理&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (eventLoop-&amp;gt;beforesleep != &lt;span&gt;NULL&lt;/span&gt; &amp;amp;&amp;amp; flags &amp;amp; AE_CALL_BEFORE_SLEEP)&lt;br/&gt;            eventLoop-&amp;gt;beforesleep(eventLoop);&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;//epoll_wait发现事件并进行处理&lt;/span&gt;&lt;br/&gt;    numevents = aeApiPoll(eventLoop, tvp);&lt;br/&gt;    ......&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在 beforeSleep 里会依次处理两个任务队列。先处理读任务队列，解析其中的请求，并处理之。然后将处理结果写到缓存中，同时写到写任务队列中。紧接着 beforeSleep 会进入写任务队列处理，会将处理结果写到 socket 里，进行真正的数据发送。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.9842829076620825&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;509&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/BBjAFF4hcwoBSguv1EpxBnEcEVKk4tyY90TEFqnft5F47nVzrd1my12nMCacwicYvnr9iaSg3TkYJHKu8rG3yf4g/640?wx_fmt=png&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们来看 beforeSleep 的代码，这个函数中最重要的两个调用是 handleClientsWithPendingReadsUsingThreads（处理读任务队列），handleClientsWithPendingWritesUsingThreads（处理写任务队列）&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;//file:src/server.c&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;void&lt;/span&gt; &lt;span&gt;beforeSleep&lt;/span&gt;&lt;span&gt;(struct aeEventLoop *eventLoop)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;//处理读任务队列&lt;/span&gt;&lt;br/&gt;    handleClientsWithPendingReadsUsingThreads();&lt;br/&gt;    &lt;span&gt;//处理写任务队列&lt;/span&gt;&lt;br/&gt;    handleClientsWithPendingWritesUsingThreads();&lt;br/&gt;    ......&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;值得注意的是，如果开启了多 io 线程的话，handleClientsWithPendingReadsUsingThreads 和 handleClientsWithPendingWritesUsingThreads 中将会是主线程、io 线程一起配合来处理的。所以我们单独分两个小节来阐述。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;三、主线程 &amp;amp;&amp;amp; io 线程处理读请求&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在 handleClientsWithPendingReadsUsingThreads 中，主线程会遍历读任务队列 server.clients_pending_read，把其中的请求分配到每个 io 线程的处理队列 io_threads_list[target_id] 中。然后通知各个 io 线程开始处理。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;1.2057026476578412&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;491&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/BBjAFF4hcwoBSguv1EpxBnEcEVKk4tyYrX6zgbzGrUpx6EFficfDTHicjmeM9ibgrYU00ecRPgLP2bbx1AqefP0icQ/640?wx_fmt=png&quot;/&gt;&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;3.1 主线程分配任务&lt;span/&gt;&lt;br/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们来看 handleClientsWithPendingReadsUsingThreads 详细代码。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;//file:src/networking.c&lt;/span&gt;&lt;br/&gt;&lt;span&gt;//当开启了 reading + parsing 多线程 I/O &lt;/span&gt;&lt;br/&gt;&lt;span&gt;//read handler 仅仅只是把 clients 推到读队列里&lt;/span&gt;&lt;br/&gt;&lt;span&gt;//而这个函数开始处理该任务队列&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;int&lt;/span&gt; &lt;span&gt;handleClientsWithPendingReadsUsingThreads&lt;/span&gt;&lt;span&gt;(&lt;span&gt;void&lt;/span&gt;)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;//访问读任务队列 server.clients_pending_read&lt;/span&gt;&lt;br/&gt;    listRewind(server.clients_pending_read,&amp;amp;li);&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;//把每一个任务取出来&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;//添加到指定线程的任务队列里 io_threads_list[target_id]&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;while&lt;/span&gt;((ln = listNext(&amp;amp;li))) {&lt;br/&gt;        client *c = listNodeValue(ln);&lt;br/&gt;        &lt;span&gt;int&lt;/span&gt; target_id = item_id % server.io_threads_num;&lt;br/&gt;        listAddNodeTail(io_threads_list[target_id],c);&lt;br/&gt;        item_id++;&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;//启动Worker线程，处理读请求&lt;/span&gt;&lt;br/&gt;    io_threads_op = IO_THREADS_OP_READ;&lt;br/&gt;    &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; j = &lt;span&gt;1&lt;/span&gt;; j &amp;lt; server.io_threads_num; j++) {&lt;br/&gt;        &lt;span&gt;int&lt;/span&gt; count = listLength(io_threads_list[j]);&lt;br/&gt;        setIOPendingCount(j, count);&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;//主线程处理 0 号任务队列&lt;/span&gt;&lt;br/&gt;    listRewind(io_threads_list[&lt;span&gt;0&lt;/span&gt;],&amp;amp;li);&lt;br/&gt;    &lt;span&gt;while&lt;/span&gt;((ln = listNext(&amp;amp;li))) {&lt;br/&gt;        &lt;span&gt;//需要先干掉 CLIENT_PENDING_READ 标志&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;//否则 readQueryFromClient 并不处理，而是入队&lt;/span&gt;&lt;br/&gt;        client *c = listNodeValue(ln);&lt;br/&gt;        readQueryFromClient(c-&amp;gt;conn);&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;//主线程等待其它线程处理完毕&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;while&lt;/span&gt;(&lt;span&gt;1&lt;/span&gt;) {&lt;br/&gt;        &lt;span&gt;unsigned&lt;/span&gt; &lt;span&gt;long&lt;/span&gt; pending = &lt;span&gt;0&lt;/span&gt;;&lt;br/&gt;        &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; j = &lt;span&gt;1&lt;/span&gt;; j &amp;lt; server.io_threads_num; j++)&lt;br/&gt;            pending += getIOPendingCount(j);&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (pending == &lt;span&gt;0&lt;/span&gt;) &lt;span&gt;break&lt;/span&gt;;&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;//再跑一遍任务队列，目的是处理输入&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;while&lt;/span&gt;(listLength(server.clients_pending_read)) {&lt;br/&gt;        ......&lt;br/&gt;        processInputBuffer(c);&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (!(c-&amp;gt;flags &amp;amp; CLIENT_PENDING_WRITE) &amp;amp;&amp;amp; clientHasPendingReplies(c))&lt;br/&gt;            clientInstallWriteHandler(c);&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在主线程中将任务分别放到了 io_threads_list 的第 0 到第 N 个元素里。并对 1 : N 号线程通过 setIOPendingCount 发消息，告诉他们起来处理。这时候 io 线程将会在 IOThreadMain 中收到消息并开始处理读任务。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;//file:src/networking.c&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;void&lt;/span&gt; *&lt;span&gt;IOThreadMain&lt;/span&gt;&lt;span&gt;(&lt;span&gt;void&lt;/span&gt; *myid)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;while&lt;/span&gt;(&lt;span&gt;1&lt;/span&gt;) {&lt;br/&gt;        &lt;span&gt;//遍历当前线程等待队列里的请求 client&lt;/span&gt;&lt;br/&gt;        listRewind(io_threads_list[id],&amp;amp;li);&lt;br/&gt;        &lt;span&gt;while&lt;/span&gt;((ln = listNext(&amp;amp;li))) {&lt;br/&gt;            client *c = listNodeValue(ln);&lt;br/&gt;            &lt;span&gt;if&lt;/span&gt; (io_threads_op == IO_THREADS_OP_WRITE) {&lt;br/&gt;                writeToClient(c,&lt;span&gt;0&lt;/span&gt;);&lt;br/&gt;            } &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (io_threads_op == IO_THREADS_OP_READ) {&lt;br/&gt;                readQueryFromClient(c-&amp;gt;conn);&lt;br/&gt;            } &lt;span&gt;else&lt;/span&gt; {&lt;br/&gt;                serverPanic(&lt;span&gt;&quot;io_threads_op value is unknown&quot;&lt;/span&gt;);&lt;br/&gt;            }&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在 io 线程中，从自己的 io_threads_list[id] 中遍历获取待处理的 client。如果发现是读请求处理，则进入 readQueryFromClient 开始处理特定的 client。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;而主线程在分配完 1 ：N 任务队列让其它 io 线程处理后，自己则开始处理第 0 号任务池。同样是会进入到 readQueryFromClient 中来执行。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;//file:src/networking.c&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;int&lt;/span&gt; &lt;span&gt;handleClientsWithPendingReadsUsingThreads&lt;/span&gt;&lt;span&gt;(&lt;span&gt;void&lt;/span&gt;)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    ......&lt;br/&gt;    &lt;span&gt;//主线程处理 0 号任务队列&lt;/span&gt;&lt;br/&gt;    listRewind(io_threads_list[&lt;span&gt;0&lt;/span&gt;],&amp;amp;li);&lt;br/&gt;    &lt;span&gt;while&lt;/span&gt;((ln = listNext(&amp;amp;li))) {&lt;br/&gt;        &lt;span&gt;//需要先干掉 CLIENT_PENDING_READ 标志&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;//否则 readQueryFromClient 并不处理，而是入队&lt;/span&gt;&lt;br/&gt;        client *c = listNodeValue(ln);&lt;br/&gt;        readQueryFromClient(c-&amp;gt;conn);&lt;br/&gt;    }&lt;br/&gt;    ......&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以无论是主线程还是 io 线程，处理客户端的读事件都是会进入 readQueryFromClient。我们来看其源码。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;3.2 读请求处理&lt;span/&gt;&lt;/h3&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;//file:src/networking.c&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;void&lt;/span&gt; &lt;span&gt;readQueryFromClient&lt;/span&gt;&lt;span&gt;(connection *conn)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;//读取请求&lt;/span&gt;&lt;br/&gt;    nread = connRead(c-&amp;gt;conn, c-&amp;gt;querybuf+qblen, readlen);&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;//处理请求&lt;/span&gt;&lt;br/&gt;    processInputBuffer(c);&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在 connRead 中就是调用 read 将 socket 中的命令读取出来，就不展开看了。接着在 processInputBuffer 中将输入缓冲区中的数据解析成对应的命令。解析完命令后真正开始处理它。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;//file:src/networking.c&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;void&lt;/span&gt; &lt;span&gt;processInputBuffer&lt;/span&gt;&lt;span&gt;(client *c)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;while&lt;/span&gt;(c-&amp;gt;qb_pos &amp;lt; sdslen(c-&amp;gt;querybuf)) {&lt;br/&gt;        &lt;span&gt;//解析命令&lt;/span&gt;&lt;br/&gt;        ......&lt;br/&gt;        &lt;span&gt;//真正开始处理 command&lt;/span&gt;&lt;br/&gt;        processCommandAndResetClient(c);&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;函数 processCommandAndResetClient 会调用 processCommand，查询命令并开始执行。执行的核心方法是 call 函数，我们直接看它。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;//file:src/server.c&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;void&lt;/span&gt; &lt;span&gt;call&lt;/span&gt;&lt;span&gt;(client *c, &lt;span&gt;int&lt;/span&gt; flags)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;// 查找处理命令，&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;struct&lt;/span&gt; &lt;span&gt;redisCommand&lt;/span&gt; *&lt;span&gt;real_cmd&lt;/span&gt; = &lt;span&gt;c&lt;/span&gt;-&amp;gt;&lt;span&gt;cmd&lt;/span&gt;;&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;// 调用命令处理函数&lt;/span&gt;&lt;br/&gt;    c-&amp;gt;cmd-&amp;gt;proc(c);&lt;br/&gt;&lt;br/&gt;    ......&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在 server.c 中定义了每一个命令对应的处理函数&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;//file:src/server.c&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;struct&lt;/span&gt; &lt;span&gt;redisCommand&lt;/span&gt; &lt;span&gt;redisCommandTable&lt;/span&gt;[] = {&lt;/span&gt;&lt;br/&gt;    {&lt;span&gt;&quot;module&quot;&lt;/span&gt;,moduleCommand,&lt;span&gt;-2&lt;/span&gt;,&lt;span&gt;&quot;as&quot;&lt;/span&gt;,&lt;span&gt;0&lt;/span&gt;,&lt;span&gt;NULL&lt;/span&gt;,&lt;span&gt;0&lt;/span&gt;,&lt;span&gt;0&lt;/span&gt;,&lt;span&gt;0&lt;/span&gt;,&lt;span&gt;0&lt;/span&gt;,&lt;span&gt;0&lt;/span&gt;},&lt;br/&gt;    {&lt;span&gt;&quot;get&quot;&lt;/span&gt;,getCommand,&lt;span&gt;2&lt;/span&gt;,&lt;span&gt;&quot;rF&quot;&lt;/span&gt;,&lt;span&gt;0&lt;/span&gt;,&lt;span&gt;NULL&lt;/span&gt;,&lt;span&gt;1&lt;/span&gt;,&lt;span&gt;1&lt;/span&gt;,&lt;span&gt;1&lt;/span&gt;,&lt;span&gt;0&lt;/span&gt;,&lt;span&gt;0&lt;/span&gt;},&lt;br/&gt;    {&lt;span&gt;&quot;set&quot;&lt;/span&gt;,setCommand,&lt;span&gt;-3&lt;/span&gt;,&lt;span&gt;&quot;wm&quot;&lt;/span&gt;,&lt;span&gt;0&lt;/span&gt;,&lt;span&gt;NULL&lt;/span&gt;,&lt;span&gt;1&lt;/span&gt;,&lt;span&gt;1&lt;/span&gt;,&lt;span&gt;1&lt;/span&gt;,&lt;span&gt;0&lt;/span&gt;,&lt;span&gt;0&lt;/span&gt;},&lt;br/&gt;    {&lt;span&gt;&quot;setnx&quot;&lt;/span&gt;,setnxCommand,&lt;span&gt;3&lt;/span&gt;,&lt;span&gt;&quot;wmF&quot;&lt;/span&gt;,&lt;span&gt;0&lt;/span&gt;,&lt;span&gt;NULL&lt;/span&gt;,&lt;span&gt;1&lt;/span&gt;,&lt;span&gt;1&lt;/span&gt;,&lt;span&gt;1&lt;/span&gt;,&lt;span&gt;0&lt;/span&gt;,&lt;span&gt;0&lt;/span&gt;},&lt;br/&gt;    {&lt;span&gt;&quot;setex&quot;&lt;/span&gt;,setexCommand,&lt;span&gt;4&lt;/span&gt;,&lt;span&gt;&quot;wm&quot;&lt;/span&gt;,&lt;span&gt;0&lt;/span&gt;,&lt;span&gt;NULL&lt;/span&gt;,&lt;span&gt;1&lt;/span&gt;,&lt;span&gt;1&lt;/span&gt;,&lt;span&gt;1&lt;/span&gt;,&lt;span&gt;0&lt;/span&gt;,&lt;span&gt;0&lt;/span&gt;},&lt;br/&gt;    ......&lt;br/&gt;&lt;br/&gt;    {&lt;span&gt;&quot;mget&quot;&lt;/span&gt;,mgetCommand,&lt;span&gt;-2&lt;/span&gt;,&lt;span&gt;&quot;rF&quot;&lt;/span&gt;,&lt;span&gt;0&lt;/span&gt;,&lt;span&gt;NULL&lt;/span&gt;,&lt;span&gt;1&lt;/span&gt;,&lt;span&gt;-1&lt;/span&gt;,&lt;span&gt;1&lt;/span&gt;,&lt;span&gt;0&lt;/span&gt;,&lt;span&gt;0&lt;/span&gt;},&lt;br/&gt;    {&lt;span&gt;&quot;rpush&quot;&lt;/span&gt;,rpushCommand,&lt;span&gt;-3&lt;/span&gt;,&lt;span&gt;&quot;wmF&quot;&lt;/span&gt;,&lt;span&gt;0&lt;/span&gt;,&lt;span&gt;NULL&lt;/span&gt;,&lt;span&gt;1&lt;/span&gt;,&lt;span&gt;1&lt;/span&gt;,&lt;span&gt;1&lt;/span&gt;,&lt;span&gt;0&lt;/span&gt;,&lt;span&gt;0&lt;/span&gt;},&lt;br/&gt;    {&lt;span&gt;&quot;lpush&quot;&lt;/span&gt;,lpushCommand,&lt;span&gt;-3&lt;/span&gt;,&lt;span&gt;&quot;wmF&quot;&lt;/span&gt;,&lt;span&gt;0&lt;/span&gt;,&lt;span&gt;NULL&lt;/span&gt;,&lt;span&gt;1&lt;/span&gt;,&lt;span&gt;1&lt;/span&gt;,&lt;span&gt;1&lt;/span&gt;,&lt;span&gt;0&lt;/span&gt;,&lt;span&gt;0&lt;/span&gt;},&lt;br/&gt;    {&lt;span&gt;&quot;rpushx&quot;&lt;/span&gt;,rpushxCommand,&lt;span&gt;-3&lt;/span&gt;,&lt;span&gt;&quot;wmF&quot;&lt;/span&gt;,&lt;span&gt;0&lt;/span&gt;,&lt;span&gt;NULL&lt;/span&gt;,&lt;span&gt;1&lt;/span&gt;,&lt;span&gt;1&lt;/span&gt;,&lt;span&gt;1&lt;/span&gt;,&lt;span&gt;0&lt;/span&gt;,&lt;span&gt;0&lt;/span&gt;},&lt;br/&gt;    ......&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;对于 get 命令来说，其对应的命令处理函数就是 getCommand。也就是说当处理 GET 命令执行到 &lt;code&gt;c-&amp;gt;cmd-&amp;gt;proc&lt;/code&gt; 的时候会进入到 getCommand 函数中来。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;//file: src/t_string.c&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;void&lt;/span&gt; &lt;span&gt;getCommand&lt;/span&gt;&lt;span&gt;(client *c)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    getGenericCommand(c);&lt;br/&gt;}&lt;br/&gt;&lt;span&gt;&lt;span&gt;int&lt;/span&gt; &lt;span&gt;getGenericCommand&lt;/span&gt;&lt;span&gt;(client *c)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    robj *o;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; ((o = lookupKeyReadOrReply(c,c-&amp;gt;argv[&lt;span&gt;1&lt;/span&gt;],shared.null[c-&amp;gt;resp])) == &lt;span&gt;NULL&lt;/span&gt;)&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; C_OK;&lt;br/&gt;    ...&lt;br/&gt;    addReplyBulk(c,o);&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; C_OK;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;getGenericCommand 方法会调用 lookupKeyReadOrReply 来从内存中查找对应的 key值。如果找不到，则直接返回 C_OK；如果找到了，调用 addReplyBulk 方法将值添加到输出缓冲区中。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;//file: src/networking.c&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;void&lt;/span&gt; &lt;span&gt;addReplyBulk&lt;/span&gt;&lt;span&gt;(client *c, robj *obj)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    addReplyBulkLen(c,obj);&lt;br/&gt;    addReply(c,obj);&lt;br/&gt;    addReply(c,shared.crlf);&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;3.3 写处理结果到发送缓存区&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其主体是调用 addReply 来设置回复数据。在 addReply 方法中做了两件事情：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;prepareClientToWrite 判断是否需要返回数据，并且将当前 client 添加到等待写返回数据队列中。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;调用
_addReplyToBuffer 和 _addReplyObjectToList 方法将返回值写入到输出缓冲区中，等待写入 socekt&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;//file:src/networking.c&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;void&lt;/span&gt; &lt;span&gt;addReply&lt;/span&gt;&lt;span&gt;(client *c, robj *obj)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (prepareClientToWrite(c) != C_OK) &lt;span&gt;return&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (sdsEncodedObject(obj)) {&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (_addReplyToBuffer(c,obj-&amp;gt;ptr,sdslen(obj-&amp;gt;ptr)) != C_OK)&lt;br/&gt;            _addReplyStringToList(c,obj-&amp;gt;ptr,sdslen(obj-&amp;gt;ptr));&lt;br/&gt;    } &lt;span&gt;else&lt;/span&gt; {&lt;br/&gt;        ......        &lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;先来看 prepareClientToWrite 的详细实现，&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;//file: src/networking.c&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;int&lt;/span&gt; &lt;span&gt;prepareClientToWrite&lt;/span&gt;&lt;span&gt;(client *c)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    ......&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (!clientHasPendingReplies(c) &amp;amp;&amp;amp; !(c-&amp;gt;flags &amp;amp; CLIENT_PENDING_READ))&lt;br/&gt;        clientInstallWriteHandler(c);&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;//file:src/networking.c&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;void&lt;/span&gt; &lt;span&gt;clientInstallWriteHandler&lt;/span&gt;&lt;span&gt;(client *c)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    c-&amp;gt;flags |= CLIENT_PENDING_WRITE;&lt;br/&gt;    listAddNodeHead(server.clients_pending_write,c);&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其中 server.clients_pending_write 就是我们说的任务队列，队列中的每一个元素都是有待写返回数据的 client 对象。在 prepareClientToWrite 函数中，把 client 添加到任务队列 server.clients_pending_write 里就算完事。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;接下再来 _addReplyToBuffer，该方法是向固定缓存中写，如果写不下的话就继续调用 _addReplyStringToList 往链表里写。简单起见，我们只看 _addReplyToBuffer 的代码。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;//file:src/networking.c&lt;/span&gt;&lt;br/&gt;&lt;span&gt;int&lt;/span&gt; _addReplyToBuffer(client *c, &lt;span&gt;const&lt;/span&gt; &lt;span&gt;char&lt;/span&gt; *s, &lt;span&gt;size_t&lt;/span&gt; len) {&lt;br/&gt;    ......&lt;br/&gt;    &lt;span&gt;// 拷贝到 client 对象的 Response buffer 中&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;memcpy&lt;/span&gt;(c-&amp;gt;buf+c-&amp;gt;bufpos,s,len);&lt;br/&gt;    c-&amp;gt;bufpos+=len;&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; C_OK;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;要注意的是，本节的读请求处理过程是主线程和 io 线程在并行执行的。主线程在处理完后会等待其它的 io 线程处理。在所有的读请求都处理完后，主线程 beforeSleep 中对 handleClientsWithPendingReadsUsingThreads 的调用就结束了。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;四、主线程 &amp;amp;&amp;amp; io 线程配合处理写请求&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当所有的读请求处理完后，handleClientsWithPendingReadsUsingThreads 会退出。主线程会紧接着进入 handleClientsWithPendingWritesUsingThreads 中来处理。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;1.2032520325203253&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;492&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/BBjAFF4hcwoBSguv1EpxBnEcEVKk4tyYUJcNIVYrRCx1n2DbgykpHsVjjFvtYS84hZl2gemoia4z5FUdjice11Kw/640?wx_fmt=png&quot;/&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;//file:src/server.c&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;void&lt;/span&gt; &lt;span&gt;beforeSleep&lt;/span&gt;&lt;span&gt;(struct aeEventLoop *eventLoop)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;//处理读任务队列&lt;/span&gt;&lt;br/&gt;    handleClientsWithPendingReadsUsingThreads();&lt;br/&gt;    &lt;span&gt;//处理写任务队列&lt;/span&gt;&lt;br/&gt;    handleClientsWithPendingWritesUsingThreads();&lt;br/&gt;    ......&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;4.1 主线程分配任务&lt;span/&gt;&lt;/h3&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;//file:src/networking.c&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;int&lt;/span&gt; &lt;span&gt;handleClientsWithPendingWritesUsingThreads&lt;/span&gt;&lt;span&gt;(&lt;span&gt;void&lt;/span&gt;)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;//没有开启多线程的话，仍然是主线程自己写&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (server.io_threads_num == &lt;span&gt;1&lt;/span&gt; || stopThreadedIOIfNeeded()) {&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; handleClientsWithPendingWrites();&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    ......&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;//获取待写任务&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;int&lt;/span&gt; processed = listLength(server.clients_pending_write);&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;//在N个任务列表中分配该任务&lt;/span&gt;&lt;br/&gt;    listIter li;&lt;br/&gt;    listNode *ln;&lt;br/&gt;    listRewind(server.clients_pending_write,&amp;amp;li);&lt;br/&gt;    &lt;span&gt;int&lt;/span&gt; item_id = &lt;span&gt;0&lt;/span&gt;;&lt;br/&gt;    &lt;span&gt;while&lt;/span&gt;((ln = listNext(&amp;amp;li))) {&lt;br/&gt;        client *c = listNodeValue(ln);&lt;br/&gt;        c-&amp;gt;flags &amp;amp;= ~CLIENT_PENDING_WRITE;&lt;br/&gt;&lt;br/&gt;        &lt;span&gt;/* Remove clients from the list of pending writes since&lt;br/&gt;         * they are going to be closed ASAP. */&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (c-&amp;gt;flags &amp;amp; CLIENT_CLOSE_ASAP) {&lt;br/&gt;            listDelNode(server.clients_pending_write, ln);&lt;br/&gt;            &lt;span&gt;continue&lt;/span&gt;;&lt;br/&gt;        }&lt;br/&gt;&lt;br/&gt;        &lt;span&gt;//hash的方式进行分配&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;int&lt;/span&gt; target_id = item_id % server.io_threads_num;&lt;br/&gt;        listAddNodeTail(io_threads_list[target_id],c);&lt;br/&gt;        item_id++;&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;//告诉对应的线程该开始干活了&lt;/span&gt;&lt;br/&gt;    io_threads_op = IO_THREADS_OP_WRITE;&lt;br/&gt;    &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; j = &lt;span&gt;1&lt;/span&gt;; j &amp;lt; server.io_threads_num; j++) {&lt;br/&gt;        &lt;span&gt;int&lt;/span&gt; count = listLength(io_threads_list[j]);&lt;br/&gt;        setIOPendingCount(j, count);&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;//主线程自己也会处理一些&lt;/span&gt;&lt;br/&gt;    listRewind(io_threads_list[&lt;span&gt;0&lt;/span&gt;],&amp;amp;li);&lt;br/&gt;    &lt;span&gt;while&lt;/span&gt;((ln = listNext(&amp;amp;li))) {&lt;br/&gt;        client *c = listNodeValue(ln);&lt;br/&gt;        writeToClient(c,&lt;span&gt;0&lt;/span&gt;);&lt;br/&gt;    }&lt;br/&gt;    listEmpty(io_threads_list[&lt;span&gt;0&lt;/span&gt;]);&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;//循环等待其它线程结束处理&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;while&lt;/span&gt;(&lt;span&gt;1&lt;/span&gt;) {&lt;br/&gt;        &lt;span&gt;unsigned&lt;/span&gt; &lt;span&gt;long&lt;/span&gt; pending = &lt;span&gt;0&lt;/span&gt;;&lt;br/&gt;        &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; j = &lt;span&gt;1&lt;/span&gt;; j &amp;lt; server.io_threads_num; j++)&lt;br/&gt;            pending += getIOPendingCount(j);&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (pending == &lt;span&gt;0&lt;/span&gt;) &lt;span&gt;break&lt;/span&gt;;&lt;br/&gt;    }&lt;br/&gt;    ......&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在 io 线程中收到消息后，开始遍历自己的任务队列 io_threads_list[id]，并将其中的 client 挨个取出来开始处理。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;//file:src/networking.c&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;void&lt;/span&gt; *&lt;span&gt;IOThreadMain&lt;/span&gt;&lt;span&gt;(&lt;span&gt;void&lt;/span&gt; *myid)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;while&lt;/span&gt;(&lt;span&gt;1&lt;/span&gt;) {&lt;br/&gt;        &lt;span&gt;//遍历当前线程等待队列里的请求 client&lt;/span&gt;&lt;br/&gt;        listRewind(io_threads_list[id],&amp;amp;li);&lt;br/&gt;        &lt;span&gt;while&lt;/span&gt;((ln = listNext(&amp;amp;li))) {&lt;br/&gt;            client *c = listNodeValue(ln);&lt;br/&gt;            &lt;span&gt;if&lt;/span&gt; (io_threads_op == IO_THREADS_OP_WRITE) {&lt;br/&gt;                writeToClient(c,&lt;span&gt;0&lt;/span&gt;);&lt;br/&gt;            } &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (io_threads_op == IO_THREADS_OP_READ) {&lt;br/&gt;                readQueryFromClient(c-&amp;gt;conn);&lt;br/&gt;            } &lt;br/&gt;        }&lt;br/&gt;        listEmpty(io_threads_list[id]);&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;4.2 写请求处理&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;由于这次任务队列里都是写请求，所以 io 线程会进入 writeToClient。而主线程在分配完任务以后，自己开始处理起了 io_threads_list[0]，并也进入到 writeToClient。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;//file:src/networking.c&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;int&lt;/span&gt; &lt;span&gt;writeToClient&lt;/span&gt;&lt;span&gt;(&lt;span&gt;int&lt;/span&gt; fd, client *c, &lt;span&gt;int&lt;/span&gt; handler_installed)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;while&lt;/span&gt;(clientHasPendingReplies(c)) {&lt;br/&gt;        &lt;span&gt;// 先发送固定缓冲区&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (c-&amp;gt;bufpos &amp;gt; &lt;span&gt;0&lt;/span&gt;) {&lt;br/&gt;            nwritten = write(fd,c-&amp;gt;buf+c-&amp;gt;sentlen,c-&amp;gt;bufpos-c-&amp;gt;sentlen);&lt;br/&gt;            &lt;span&gt;if&lt;/span&gt; (nwritten &amp;lt;= &lt;span&gt;0&lt;/span&gt;) &lt;span&gt;break&lt;/span&gt;;&lt;br/&gt;            ......&lt;br/&gt;&lt;br/&gt;        &lt;span&gt;// 再发送回复链表中数据&lt;/span&gt;&lt;br/&gt;        } &lt;span&gt;else&lt;/span&gt; {&lt;br/&gt;            o = listNodeValue(listFirst(c-&amp;gt;reply));&lt;br/&gt;            nwritten = write(fd, o-&amp;gt;buf + c-&amp;gt;sentlen, objlen - c-&amp;gt;sentlen);&lt;br/&gt;            ......&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;writeToClient 中的主要逻辑就是调用 write 系统调用让内核帮其把数据发送出去即可。由于每个命令的处理结果大小是不固定的。所以 Redis 采用的做法用固定的 buf + 可变链表来储存结果字符串。这里自然发送的时候就需要分别对固定缓存区和链表来进行发送了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当所有的写请求也处理完后，beforeSleep 就退出了。主线程将会再次调用 epoll_wait 来发现请求，进入下一轮的用户请求处理。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;五、总结&lt;span/&gt;&lt;/h3&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;//file: src/server.c&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;int&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;(&lt;span&gt;int&lt;/span&gt; argc, &lt;span&gt;char&lt;/span&gt; **argv)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    ......&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;// 1.1 主线程初始化&lt;/span&gt;&lt;br/&gt;    initServer();&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;// 1.2 启动 io 线程&lt;/span&gt;&lt;br/&gt;    InitServerLast();&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;// 进入事件循环&lt;/span&gt;&lt;br/&gt;    aeMain(server.el);&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在 initServer 这个函数内，Redis 做了这么三件重要的事情。&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;创建一个 epoll 对象&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;对配置的监听端口进行 listen&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;把 listen socket 让 epoll 给管理起来&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在 initThreadedIO 中调用 pthread_create 库函数创建线程，并且注册线程回调函数 IOThreadMain。在 IOThreadMain 中等待其队列 io_threads_list[id] 产生请求，当有请求到达的时候取出 client，依次处理。其中读操作通过 readQueryFromClient 处理， 写操作通过 writeToClient 处理。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;主线程在 aeMain 函数中，是一个无休止的循环，它是 Redis 中最重要的部分。它先是调用事件分发器发现事件。如果有新连接请求到达的时候，执行 accept 接收新连接，并为其注册事件处理函数。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当用户连接上有命令请求到达的时候，主线程在 read 处理函数中将其添加到读发送队列中。然后接着在 beforeSleep 中开启对读任务队列和写任务队列的处理。总体工作过程如下图所示。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.9093701996927803&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/BBjAFF4hcwoBSguv1EpxBnEcEVKk4tyYaB7F2T5hicCh9YkbJ5hu7NuF8US7wgrokaWiaC2WiaiaxcIFy6GR62QBTA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;651&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在这个处理过程中，对读任务队列和写任务队列的处理都是多线程并行进行的（前提是开篇我们开启了多 IO 线程并且也并发处理读）。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当读任务队列和写任务队列的都处理完的时候，主线程再一次调用 epoll_wait 去发现新的待处理事件，如此往复循环进行处理。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;至此，多线程版本的 Redis 的工作原理就介绍完了。坦白讲，我觉得这种多线程模型实现的并不足够的好。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;原因是主线程是在处理读、写任务队列的时候还要等待其它的 io 线程处理完才能进入下一步。假设这时有 10 个用户请求到达，其中 9 个处理耗时需要 1 ms，而另外一个命令需要 1 s。则这时主线程仍然会等待这个 io 线程处理 1s 结束后才能进入后面的处理。整个 Redis 服务还是被一个耗时的命令给 block 住了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我倒是希望我的理解哪里有问题。因为这种方式真的是没能很好地并发起来。&lt;/p&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>205183ead10ba0291329d190f339001b</guid>
<title>彻底理解 WireGuard 的路由策略</title>
<link>https://toutiao.io/k/rcso5pk</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5248929336188437&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/qFG6mghhA4aZ05icGic1SQCCULJqExAOCIZX24Y1HrutkVOZtVeBMdjmQlukTKrB9yRnIYUibPLxyJ5DEAJDdzrNQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;3736&quot;/&gt;&lt;/figure&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;❝&lt;/span&gt;&lt;p&gt;原文链接🔗：&lt;strong&gt;https://icloudnative.io/posts/linux-routing-of-wireguard/&lt;/strong&gt;&lt;br/&gt;或者点击左下角的 &lt;strong&gt;阅读原&lt;/strong&gt;&lt;strong&gt;文 &lt;/strong&gt;直接查看原文👇&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;很久以前，我们只需要在 Linux 终端中输入 &lt;code&gt;route -n&lt;/code&gt;（后来演变出了 &lt;code&gt;ip route&lt;/code&gt;，也就是 iproute2 提供的命令），就可以知晓系统中所有数据包的走向，但是，&lt;strong&gt;大人，时代变了！&lt;/strong&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/qFG6mghhA4aZ05icGic1SQCCULJqExAOCIdGOtNajfYYDAxsLsiad40qNyhfJeHtmlZ9n1Jkn25sXaODoyyuIAfibg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;225&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果你是 WireGuard 玩家，并且所有的流量都通过 WireGuard 路由出去，但你却无法通过 &lt;code&gt;ip route&lt;/code&gt; 命令的输出中看出任何的蛛丝马迹：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;default via 192.168.100.254 dev eth0 proto dhcp src 192.168.100.63 metric 100 &lt;br/&gt;192.168.100.0/24 dev eth0 proto kernel scope link src 192.168.100.63 &lt;br/&gt;192.168.100.254 dev eth0 proto dhcp scope link src 192.168.100.63 metric 100&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;路由表告诉我们，所有的流量都是通过物理网卡出去的，并没有通过 WireGuard 虚拟网络接口。这是为什么呢？&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;路由表&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;事实上 Linux 从 2.2 版本左右的内核开始，便包含了多个路由表，而不是一个！同时，还有一套规则，&lt;strong&gt;这套规则会告诉内核如何为每个数据包选择正确的路由表。&lt;/strong&gt;&lt;/p&gt;&lt;section class=&quot;mp_profile_iframe_wrp&quot;&gt;&lt;mp-common-profile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mpprofile&quot; data-id=&quot;MzU1MzY4NzQ1OA==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/qFG6mghhA4Z1KpQSa8IH6icHMlcG2hq5AhMX1DJzRibTSdRsIFapMfnAGhdr6GF4e0PnAkPiaEk7HrDrndoWjxiciaA/0?wx_fmt=png&quot; data-nickname=&quot;云原生实验室&quot; data-alias=&quot;cloud_native_yang&quot; data-signature=&quot;战略上藐视云原生，战术上重视云原生&quot; data-from=&quot;0&quot; data-is_biz_ban=&quot;0&quot;/&gt;&lt;br/&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当你执行 &lt;code&gt;ip route&lt;/code&gt; 时，你看到的是一个特定的路由表 &lt;code&gt;main&lt;/code&gt;，除了 main 之外还有其他的路由表存在。路由表一般用整数来标识，也可以通过文本对其命名，这些命名都保存在文件 &lt;code&gt;/etc/iproute2/rt_tables&lt;/code&gt; 中。默认内容如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;$ cat /etc/iproute2/rt_tables&lt;br/&gt;&lt;span&gt;#&lt;/span&gt;&lt;br/&gt;&lt;span&gt;# reserved values&lt;/span&gt;&lt;br/&gt;&lt;span&gt;#&lt;/span&gt;&lt;br/&gt;255     &lt;span&gt;local&lt;/span&gt;&lt;br/&gt;254     main&lt;br/&gt;253     default&lt;br/&gt;0       unspec&lt;br/&gt;&lt;span&gt;#&lt;/span&gt;&lt;br/&gt;&lt;span&gt;# local&lt;/span&gt;&lt;br/&gt;&lt;span&gt;#&lt;/span&gt;&lt;br/&gt;&lt;span&gt;#1      inr.ruhep&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Linux 系统中，可以自定义从 &lt;code&gt;1－252&lt;/code&gt; 个路由表。Linux 系统默认维护了 4 个路由表：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;0&lt;/strong&gt;：系统保留表。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;253&lt;/strong&gt;：defulte table。没特别指定的默认路由都放在该表。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;254&lt;/strong&gt;：main table。没指明路由表的所有路由放在该表。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;255&lt;/strong&gt;：locale table。保存本地接口地址，广播地址、NAT 地址，由系统维护，用户不得更改。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里有一个很奇怪的单词：&lt;code&gt;inr.ruhep&lt;/code&gt;，这可能是 Alexey Kuznetsov 添加的，他负责服务质量（QoS）在Linux内核中的实现，iproute2 也是他在负责，这个单词表示“核研究/俄罗斯高能物理研究所”，是 Alexey 当时工作的地方，可能指的是他们的内部网络。当然，还有另外一种可能，有一个老式的俄罗斯计算机网络/ISP 叫做 &lt;span&gt;RUHEP/Radio-MSU&lt;/span&gt;&lt;sup&gt;[1]&lt;/sup&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;路由表的查看可有以下二种方法：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;$ ip route show table table_number&lt;br/&gt; &lt;br/&gt;$ ip route show table table_name&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;❝&lt;/span&gt;&lt;p&gt;不要把路由表和 iptables 混淆，路由表决定&lt;strong&gt;如何传输数据包&lt;/strong&gt;，而 iptables 决定&lt;strong&gt;是否传输数据包&lt;/strong&gt;，他俩的职责不一样。&lt;/p&gt;&lt;/blockquote&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;路由策略&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;内核是如何知道哪个数据包应该使用哪个路由表的呢？答案已经在前文给出来了，系统中有一套规则会告诉内核如何为每个数据包选择正确的路由表，这套规则就是&lt;strong&gt;路由策略数据库&lt;/strong&gt;。这个数据库由 &lt;code&gt;ip rule&lt;/code&gt; 命令来管理，如果不加任何参数，将会打印所有的路由规则：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;0:      from all lookup &lt;span&gt;local&lt;/span&gt;&lt;br/&gt;32766:  from all lookup main&lt;br/&gt;32767:  from all lookup default&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;左边的数字（0, 32764, ......）表示规则的优先级：&lt;strong&gt;数值越小的规则，优先级越高&lt;/strong&gt;。也就是说，数值较小的规则会被优先处理。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;❝&lt;/span&gt;&lt;p&gt;路由规则的数值范围：1 ~ &lt;span&gt;&lt;span role=&quot;presentation&quot; data-formula=&quot;2^{23}-1&quot; data-formula-type=&quot;inline-equation&quot;&gt;&lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot; role=&quot;img&quot; focusable=&quot;false&quot; viewbox=&quot;0 -833.9 2979.6 915.9&quot; aria-hidden=&quot;true&quot;&gt;&lt;g stroke=&quot;currentColor&quot; fill=&quot;currentColor&quot; stroke-width=&quot;0&quot; transform=&quot;matrix(1 0 0 -1 0 0)&quot;&gt;&lt;g data-mml-node=&quot;math&quot;&gt;&lt;g data-mml-node=&quot;msup&quot;&gt;&lt;g data-mml-node=&quot;mn&quot;&gt;&lt;path data-c=&quot;32&quot; d=&quot;M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z&quot;/&gt;&lt;/g&gt;&lt;g data-mml-node=&quot;TeXAtom&quot; transform=&quot;translate(500, 363) scale(0.707)&quot; data-mjx-texclass=&quot;ORD&quot;&gt;&lt;g data-mml-node=&quot;mn&quot;&gt;&lt;path data-c=&quot;32&quot; d=&quot;M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z&quot;/&gt;&lt;path data-c=&quot;33&quot; d=&quot;M127 463Q100 463 85 480T69 524Q69 579 117 622T233 665Q268 665 277 664Q351 652 390 611T430 522Q430 470 396 421T302 350L299 348Q299 347 308 345T337 336T375 315Q457 262 457 175Q457 96 395 37T238 -22Q158 -22 100 21T42 130Q42 158 60 175T105 193Q133 193 151 175T169 130Q169 119 166 110T159 94T148 82T136 74T126 70T118 67L114 66Q165 21 238 21Q293 21 321 74Q338 107 338 175V195Q338 290 274 322Q259 328 213 329L171 330L168 332Q166 335 166 348Q166 366 174 366Q202 366 232 371Q266 376 294 413T322 525V533Q322 590 287 612Q265 626 240 626Q208 626 181 615T143 592T132 580H135Q138 579 143 578T153 573T165 566T175 555T183 540T186 520Q186 498 172 481T127 463Z&quot; transform=&quot;translate(500, 0)&quot;/&gt;&lt;/g&gt;&lt;/g&gt;&lt;/g&gt;&lt;g data-mml-node=&quot;mo&quot; transform=&quot;translate(1479.3, 0)&quot;&gt;&lt;path data-c=&quot;2212&quot; d=&quot;M84 237T84 250T98 270H679Q694 262 694 250T679 230H98Q84 237 84 250Z&quot;/&gt;&lt;/g&gt;&lt;g data-mml-node=&quot;mn&quot; transform=&quot;translate(2479.6, 0)&quot;&gt;&lt;path data-c=&quot;31&quot; d=&quot;M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z&quot;/&gt;&lt;/g&gt;&lt;/g&gt;&lt;/g&gt;&lt;/svg&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;除了优先级之外，每个规则还有一个&lt;strong&gt;选择器&lt;/strong&gt;（selector）和对应的&lt;strong&gt;执行策略&lt;/strong&gt;（action）。选择器会判断该规则是否适用于当前的数据包，如果适用，就执行对应的策略。最常见的执行策略就是查询一个特定的路由表（参考上一节内容）。如果该路由表包含了当前数据包的路由，那么就执行该路由；否则就会跳过当前路由表，继续匹配下一个路由规则。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在 Linux 系统启动时，内核会为路由策略数据库配置三条缺省的规则：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;0&lt;/strong&gt;：匹配任何条件，查询路由表 &lt;strong&gt;local&lt;/strong&gt; (ID 255)，该表 local 是一个特殊的路由表，包含对于本地和广播地址的优先级控制路由。rule 0 非常特殊，不能被删除或者覆盖。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;32766&lt;/strong&gt;：匹配任何条件，查询路由表 &lt;strong&gt;main&lt;/strong&gt; (ID 254)，该表是一个常规的表，包含所有的无策略路由。系统管理员可以删除或者使用另外的规则覆盖这条规则。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;32767&lt;/strong&gt;：匹配任何条件，查询路由表 &lt;strong&gt;default&lt;/strong&gt; (ID 253)，该表是一个空表，它是后续处理保留。对于前面的策略没有匹配到的数据包，系统使用这个策略进行处理，这个规则也可以删除。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在默认情况下进行路由时，首先会根据规则 &lt;strong&gt;0&lt;/strong&gt; 在本地路由表里寻找路由，如果目的地址是本网络，或是广播地址的话，在这里就可以找到合适的路由；如果路由失败，就会匹配下一个不空的规则，在这里只有 &lt;strong&gt;32766&lt;/strong&gt; 规则，在这里将会在主路由表里寻找路由；如果失败，就会匹配 &lt;strong&gt;32767&lt;/strong&gt; 规则，即寻找默认路由表。如果失败，路由将失败。从这里可以看出，&lt;strong&gt;策略性路由是往前兼容的&lt;/strong&gt;。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;WireGuard 全局路由策略&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;现在回到 WireGuard，很多 WireGuard 用户会选择将本机的所有流量通过 WireGuard 对端路由，原因嘛大家都懂得😁。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1.1226415094339623&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/qFG6mghhA4aZ05icGic1SQCCULJqExAOCIicDAQtGNa8hnaibApDCVwomhfK6qUXbmlFQ6xezE2vY9Kn3ZFSicUBbwg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;212&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;配置嘛也很简单，只需将 &lt;code&gt;0.0.0.0/0&lt;/code&gt; 添加到 &lt;code&gt;AllowedIPs&lt;/code&gt; 里即可：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;# /etc/wireguard/wg0.conf&lt;br/&gt;&lt;br/&gt;[Interface]&lt;br/&gt;PrivateKey = xxxxxxxxxxxxxxxxxxxxxxxxxxxxx &lt;br/&gt;Address = 10.0.0.2/32&lt;br/&gt;# PostUp = iptables -A FORWARD -i wg0 -j ACCEPT; iptables -t nat -A POSTROUTING -o eth0 -j MASQUERADE&lt;br/&gt;# PostDown = iptables -D FORWARD -i wg0 -j ACCEPT; iptables -t nat -D POSTROUTING -o eth0 -j MASQUERADE&lt;br/&gt;# ListenPort = 51820&lt;br/&gt;&lt;br/&gt;[Peer]&lt;br/&gt;PublicKey = xxxxxxxxxxxxxxxxxxxxxxxxxxxxx&lt;br/&gt;Endpoint = 192.168.100.251:51820&lt;br/&gt;AllowedIPs = 0.0.0.0/0&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;理论上这样就可以让所有的流量都通过对端路由了，但是如果你用的 wg-quick 版本比较旧，一顿操作猛如虎（&lt;code&gt;wg-quick up wg0&lt;/code&gt;）之后，你会发现事情并不是你想象的那样，甚至可能连 WireGuard 对端都连不上了。主要还是因为 WireGuard 自身的流量也通过虚拟网络接口进行路由了，这肯定是不行的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;新版本的 &lt;code&gt;wg-quick&lt;/code&gt; 通过路由策略巧妙地解决了这个问题，我们来看看它妙在何处！&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.9198813056379822&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/qFG6mghhA4aZ05icGic1SQCCULJqExAOCIibZS5ibYibbfFbM1z8RoZCNccOtJkCqzWTUvIjxj6UKqtIa95nXibhsHdg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;674&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;首先，使用 wg-quick 启动 &lt;code&gt;wg0&lt;/code&gt; 网卡：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;$&lt;/span&gt;&lt;span&gt; wg-quick up wg0&lt;/span&gt;&lt;br/&gt;&lt;span&gt;[#&lt;/span&gt;&lt;span&gt;] ip link add wg0 &lt;span&gt;type&lt;/span&gt; wireguard&lt;/span&gt;&lt;br/&gt;&lt;span&gt;[#&lt;/span&gt;&lt;span&gt;] wg setconf wg0 /dev/fd/63&lt;/span&gt;&lt;br/&gt;&lt;span&gt;[#&lt;/span&gt;&lt;span&gt;] ip -4 address add 10.0.0.2/32 dev wg0&lt;/span&gt;&lt;br/&gt;&lt;span&gt;[#&lt;/span&gt;&lt;span&gt;] ip link &lt;span&gt;set&lt;/span&gt; mtu 1420 up dev wg0&lt;/span&gt;&lt;br/&gt;&lt;span&gt;[#&lt;/span&gt;&lt;span&gt;] wg &lt;span&gt;set&lt;/span&gt; wg0 fwmark 51820&lt;/span&gt;&lt;br/&gt;&lt;span&gt;[#&lt;/span&gt;&lt;span&gt;] ip -4 route add 0.0.0.0/0 dev wg0 table 51820&lt;/span&gt;&lt;br/&gt;&lt;span&gt;[#&lt;/span&gt;&lt;span&gt;] ip -4 rule add not fwmark 51820 table 51820&lt;/span&gt;&lt;br/&gt;&lt;span&gt;[#&lt;/span&gt;&lt;span&gt;] ip -4 rule add table main suppress_prefixlength 0&lt;/span&gt;&lt;br/&gt;&lt;span&gt;[#&lt;/span&gt;&lt;span&gt;] sysctl -q net.ipv4.conf.all.src_valid_mark=1&lt;/span&gt;&lt;br/&gt;&lt;span&gt;[#&lt;/span&gt;&lt;span&gt;] iptables-restore -n&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;嘻嘻，看到了熟悉的路由策略，这就打印所有的路由规则看看：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;$ ip rule&lt;br/&gt;0:      from all lookup &lt;span&gt;local&lt;/span&gt;&lt;br/&gt;32764:  from all lookup main suppress_prefixlength 0&lt;br/&gt;32765:  not from all fwmark 0xca6c lookup 51820&lt;br/&gt;32766:  from all lookup main&lt;br/&gt;32767:  from all lookup default&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;好家伙，多了两条规则：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;32764:  from all lookup main suppress_prefixlength 0&lt;br/&gt;32765:  not from all fwmark 0xca6c lookup 51820&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们来扒扒他们的底裤，揭开神秘面纱。先来灵魂三问：&lt;code&gt;suppress_prefixlength&lt;/code&gt; 是啥？&lt;code&gt;0xca6c&lt;/code&gt; 又是啥？数据包怎么可能 &lt;code&gt;not from all&lt;/code&gt;？&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;&lt;span/&gt;Rule 32764&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;先从规则 &lt;code&gt;32764&lt;/code&gt; 开始分析，因为它的数值比较小，会被优先匹配：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;32764:  from all lookup main suppress_prefixlength 0&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这条规则没有使用选择器，也就是说，内核会为每一个数据包去查询 &lt;code&gt;main&lt;/code&gt; 路由表。我们来看看 main 路由表内容是啥：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;$ ip route&lt;br/&gt;default via 192.168.100.254 dev eth0 proto dhcp src 192.168.100.63 metric 100 &lt;br/&gt;192.168.100.0/24 dev eth0 proto kernel scope link src 192.168.100.63 &lt;br/&gt;192.168.100.254 dev eth0 proto dhcp scope link src 192.168.100.63 metric 100&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果真的是这样，那所有的数据包都会通过 main 路由表路由，永远不会到达 wg0。你别忘了，这条规则末尾还有一个参数：&lt;code&gt;suppress_prefixlength 0&lt;/code&gt;，这是啥意思呢？参考  &lt;code&gt;ip-rule(8)&lt;/code&gt; man page：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;suppress_prefixlength NUMBER&lt;br/&gt;    reject routing decisions that have a prefix length of NUMBER or less.&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里的 &lt;code&gt;prefix&lt;/code&gt; 也就是&lt;strong&gt;前缀&lt;/strong&gt;，表示路由表中匹配的地址范围的&lt;strong&gt;掩码&lt;/strong&gt;。因此，如果路由表中包含 &lt;code&gt;10.2.3.4&lt;/code&gt; 的路由，前缀长度就是 32；如果是 &lt;code&gt;10.0.0.0/8&lt;/code&gt;，前缀长度就是 8。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;suppress&lt;/code&gt; 的意思是抑制，所以 &lt;code&gt;suppress_prefixlength 0&lt;/code&gt; 的意思是：&lt;strong&gt;拒绝前缀长度小于或等于 0 的路由策略&lt;/strong&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那么什么样的地址范围前缀长度才会小于等于 0？只有一种可能：&lt;code&gt;0.0.0.0/0&lt;/code&gt;，也就是默认路由。以我的机器为例，默认路由就是：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;default via 192.168.100.254 dev eth0 proto dhcp src 192.168.100.63 metric 100&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果数据包匹配到了默认路由，就拒绝转发；如果是其他路由，就正常转发。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这条规则的目的很简单，&lt;strong&gt;管理员手动添加到 main 路由表中的路由都会正常转发，而默认路由会被忽略，继续匹配下一条规则&lt;/strong&gt;。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;&lt;span/&gt;Rule 32765&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;下一条规则就是 &lt;code&gt;32765&lt;/code&gt;：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;32765:  not from all fwmark 0xca6c lookup 51820&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里的 &lt;code&gt;not from all&lt;/code&gt; 是 ip rule 格式化的问题，有点反人类，人类更容易理解的顺序应该是这样：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;32765:  from all not fwmark 0xca6c lookup 51820&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;从前面 &lt;code&gt;wg-quick up wg0&lt;/code&gt; 的输出来看，规则的选择器是没有添加 from 前缀（地址或者地址范围）的：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;ip -4 rule add not fwmark 51820 table 51820&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果规则选择器没有 from 前缀，&lt;code&gt;ip rule&lt;/code&gt; 就会打印出 &lt;code&gt;from all&lt;/code&gt;，所以这条规则才会是这个样子。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;51820 是一个路由表，也是由 wg-quick 创建的，只包含一条路由：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;$ ip route show table 51820&lt;br/&gt;default dev wg0 scope link&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以这条规则的效果是：&lt;strong&gt;匹配到该规则的所有数据包都通过 WireGuard 对端进行路由&lt;/strong&gt;，除了 &lt;code&gt;not fwmark 0xca6c&lt;/code&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;0xca6c 只是一个防火墙标记，wg-quick 会让 wg 标记它发出的所有数据包（&lt;strong&gt;wg set wg0 fwmark 51820&lt;/strong&gt;），这些数据包已经封装了其他数据包，如果这些数据包也通过 WireGuard 进行路由，就会形成一个无限路由环路。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以 &lt;code&gt;not from all fwmark 0xca6c lookup 51820&lt;/code&gt; 意思是说，满足条件 &lt;code&gt;from all fwmark 0xca6c&lt;/code&gt;（WireGuard 发出的都带 fwmark 0xca6c）请忽略本条规则，继续往下走。否则，请使用 51820 路由表，通过 wg0 隧道出去。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;对于 wg0 接口发包自带的 0xca6c，继续走下一条规则，也就是匹配默认的 main 路由表：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;32766:  from all lookup main&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;此时已经没有抑制器了，所有的数据包都可以自由使用 main 路由表，因此 WireGuard 对端的 Endpoint 地址会通过 eth0 接口发送出去。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;完美！&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;❝&lt;/span&gt;&lt;p&gt;wg-quick 创建的路由表和 fwmark 使用的是同一个数字：51820。0xca6c 是 51820 的十六进制表示。&lt;/p&gt;&lt;/blockquote&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;总结&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;wg-quick 这种做法的巧妙之处在于，它不会扰乱你的主路由表，而是通过规则匹配新创建的路由表。断开连接时只需删除这两条路由规则，默认路由就会被重新激活。&lt;strong&gt;你学废了吗？&lt;/strong&gt;&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;引用链接&lt;/span&gt;&lt;/h3&gt;&lt;section data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;span&gt;[1]&lt;/span&gt;&lt;p&gt;RUHEP/Radio-MSU: &lt;em&gt;http://www.radio-msu.net/about.htm&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>755b9e6b8c3f9252ca3c2027f92060e4</guid>
<title>容灾技术方案</title>
<link>https://toutiao.io/k/cwicg8f</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section&gt;&lt;blockquote&gt;&lt;p&gt;作者：Bogon&lt;br/&gt;链接：https://www.jianshu.com/p/8fd815227ab2&lt;/p&gt;&lt;/blockquote&gt;&lt;h3&gt;&lt;span&gt;一、容灾模式&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;当前市场上常见的容灾模式可分为：&lt;strong&gt;同城容灾&lt;/strong&gt;、&lt;strong&gt;异地容灾&lt;/strong&gt;、 &lt;strong&gt;双活数据中心&lt;/strong&gt;、 &lt;strong&gt;两地三中心&lt;/strong&gt;几种。&lt;/p&gt;&lt;h4&gt;&lt;span&gt;1、&lt;strong&gt;同城&lt;/strong&gt;&lt;strong&gt;容灾&lt;/strong&gt;&lt;/span&gt;&lt;/h4&gt;&lt;p&gt;同城 容灾 是在同城或相近区域内 （ ≤ 200K M ）建立两个数据中心 : 一个为数据中心，负责日常生产运行 ; 另一个为灾难备份中心，负责在灾难发生后的应用系统运行。同城灾难备份的数据中心与灾难备份中心的距离比较近，通信线路质量较好，比较容易实现数据的同步 复制 ，保证高度的数据完整性和数据零丢失。同城灾难备份一般用于防范火灾、建筑物破坏、供电故障、计算机系统及人为破坏引起的灾难。&lt;/p&gt;&lt;h4&gt;&lt;span&gt;2、&lt;strong&gt;异地&lt;/strong&gt;&lt;strong&gt;容灾&lt;/strong&gt;&lt;/span&gt;&lt;/h4&gt;&lt;p&gt;异地 容灾 主备中心之间的距离较远 （＞ 200KM ) ， 因此一般采用异步镜像，会有少量的数据丢失。异地灾难备份不仅可以防范火灾、建筑物破坏等可能遇到的风险隐患，还能够防范战争、地震、水灾等风险。由于同城灾难备份和异地灾难备份各有所长，为达到最理想的防灾效果，数据中心应考虑采用同城和异地各建立一个灾难备份中心的方式解决。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;本地容灾&lt;/strong&gt;是指在本地机房建立容灾系统，日常情况下可同时分担业务及管理系统的运行，并可切换运行；灾难情况下可在基本不丢失数据的情况下进行灾备应急切换，保持业务连续运行。与异地灾备模式相比较，本地双中心具有投资成本低、建设速度快、运维管理相对简单、可靠性更高等优点；异地灾备中心是指在异地建立一个备份的灾备中心，用于双中心的数据备份，当双中心出现自然灾害等原因而发生故障时，异地灾备中心可以用备份数据进行业务的恢复。&lt;/p&gt;&lt;p&gt;本地机房的容灾主要是用于防范生产服务器发生的故障，异地灾备中心用于防范大规模区域性灾难。本地机房的容灾由于其与生产中心处于同一个机房，可通过局域网进行连接，因此数据复制和应用切换比较容易实现，可实现生产与灾备服务器之间数据的实时复制和应用的快速切换。异地灾备中心由于其与生产中心不在同一机房，灾备端与生产端连接的网络线路带宽和质量存在一定的限制，应用系统的切换也需要一定的时间，因此异地灾备中心可以实现在业务限定的时间内进行恢复和可容忍丢失范围内的数据恢复。&lt;/p&gt;&lt;h4&gt;&lt;span&gt;3、&lt;strong&gt;两地&lt;/strong&gt;&lt;strong&gt;三中心&lt;/strong&gt;&lt;/span&gt;&lt;/h4&gt;&lt;p&gt;结合近年国内出现的大范围自然灾害，以同城双中心加异地灾备中心的 “两地三中心”的灾备模式也随之出现，这一方案兼具高可用性和灾难备份的能力。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;同城双中心&lt;/strong&gt;是指在同城或邻近城市建立两个可独立承担关键系统运行的数据中心，双中心具备基本等同的业务处理能力并通过高速链路实时同步数据，日常情况下可同时分担业务及管理系统的运行，并可切换运行；灾难情况下可在基本不丢失数据的情况下进行灾备应急切换，保持业务连续运行。与异地灾备模式相比较，同城双中心具有投资成本低、建设速度快、运维管理相对简单、可靠性更高等优点。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;异地灾备中心&lt;/strong&gt;是指在异地的城市建立一个备份的灾备中心，用于双中心的数据备份，当双中心出现自然灾害等原因而发生故障时，异地灾备中心可以用备份数据进行业务的恢复。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;两地三中心&lt;/strong&gt;：是指&lt;strong&gt;同城双中心&lt;/strong&gt;加**异地灾备 **一种商用容灾备份解决方案；&lt;/p&gt;&lt;p&gt;&lt;strong&gt;两地&lt;/strong&gt;是指同城、异地；&lt;/p&gt;&lt;p&gt;&lt;strong&gt;三中心&lt;/strong&gt;是指&lt;strong&gt;生产中心&lt;/strong&gt;、&lt;strong&gt;同城容灾中心&lt;/strong&gt;、&lt;strong&gt;异地容灾中心&lt;/strong&gt;。（ 生产中心、同城灾备中心、异地灾备中心 ）&lt;/p&gt;&lt;h4&gt;&lt;span&gt;4、&lt;strong&gt;双活&lt;/strong&gt;&lt;strong&gt;数据中心&lt;/strong&gt;&lt;/span&gt;&lt;/h4&gt;&lt;p&gt;所谓 “ 双活 ” 或 “ 多 活 ” 数据中心，区别于 传统 数据中心 和 灾备中心的模式，前者 多个 或两个数据中心都处于运行当中， 运行相同的应用，具备同样的数据，能够提供跨中心业务负载均衡运行能力，实现持续的应用可用性和灾难备份能力， 所以称为 “双活 ” 和 “ 多 活 ” ；后者是 生产 数据中心投入运行， 灾备 数据中心处在不工作状态，只有当灾难发生时，生产数据中心瘫痪，灾备中心才启动。&lt;/p&gt;&lt;p&gt;“ 双活 ” 数据中心最大的特点是 ：&lt;/p&gt;&lt;p&gt;一、充分利用资源，避免了一个数据中心常年处于闲置状态而造成浪费 ， 通过资源整合， “ 双活 ” 数据中心的服务能力是 翻 倍的 ；&lt;/p&gt;&lt;p&gt;二 、 “ 双活 ” 数据中心如果断了一个数据中心， 其 业务可以 迅速 切换到另外一个 正在 运行的数据中心， 切换 过程对用户来说是不可感知的。&lt;/p&gt;&lt;p&gt;在 “ 双活 ” 的模式中，两地数据中心同时接纳交易，技术难度很大，需要更改众多底层程序 ， 因而在现实中，国内还没有 真正 “ 双活 ” 数据中心 的成功应用案例。&lt;/p&gt;&lt;h3&gt;&lt;span&gt;&lt;strong&gt;二、数据容灾技术选择度量标准&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;容灾系统是指在相隔较远的异地，建立两套或多套功能相同的 IT 系统，互相之间可以进行健康状态监视和功能切换，当一处系统因意外 ( 如火灾、地震等 ) 停止工作时，整个应用系统可以切换到另一处，使得该系统功能可以继续正常工作。&lt;/strong&gt; &lt;/p&gt;&lt;p&gt;容灾技术是系统的高可用性技术的一个组成部分，容灾系统更加强调处理外界环境对系统的影响，特别是灾难性事件对整个 IT 节点的影响，提供节点级别的系统恢复功能。&lt;/p&gt;&lt;p&gt;在构建 容灾 系统时，首先考虑的是结合实际情况选择合理的数据复制技术。&lt;/p&gt;&lt;p&gt;在选择合理的数据复制技术时主要考虑以下因素：&lt;/p&gt;&lt;p&gt;Ø&lt;strong&gt;灾难承受程度&lt;/strong&gt;：明确计算机系统需要承受的灾难类型，系统故障、通信故障、长时间断电、火灾及地震等各种意外情况所采取的备份、保护方案不尽相同。&lt;/p&gt;&lt;p&gt;Ø&lt;strong&gt;业务影响程度&lt;/strong&gt;：必须明确当计算机系统发生意外无法工作时，导致业务停顿所造成的损失程度，也就是定义用户对于计算机系统发生故障的最大容忍时间，这是设计备份方案的重要技术指标。&lt;/p&gt;&lt;p&gt;Ø&lt;strong&gt;数据保护程度&lt;/strong&gt;：是否要求数据库恢复所有提交的交易 ， 并且要求实时同步 ，保证 数据的连续性和一致性， 这是 备份方案复杂程度的重要依据。&lt;/p&gt;&lt;h4&gt;&lt;span&gt;1.容灾系统衡量指标&lt;/span&gt;&lt;/h4&gt;&lt;p&gt;衡量容灾系统的主要指标有 RPO （ Recovery Point Object ，灾难发生时允许丢失的数据量）、 RTO （ Recovery Time Objective ，系统恢复的时间）、容灾半径（生产系统和容灾系统之间的距离）以及 ROI(Return of Investment ，容灾系统的投入产出比 ) 。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;RPO 是指业务系统所允许的灾难过程中的最大数据丢失量（以时间来度量），这是一个灾备系统所选用的数据复制技术有密切关系的指标，用以衡量灾备方案的数据冗余备份能力。&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;RTO 是指“将信息系统从灾难造成的故障或瘫痪状态恢复到可正常运行状态，并将其支持的业务功能从灾难造成的不正常状态恢复到可接受状态”所需时间，其中包括备份数据恢复到可用状态所需时间、应用系统切换时间、以及备用网络切换时间等，该指标用以衡量容灾方案的业务恢复能力。例如，灾难发生后半天内便需要恢复，则 RTO 值就是十二小时。&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;容灾半径是指生产中心和灾备中心之间的直线距离，用以衡量容灾方案所能防御的灾难影响范围。&lt;/p&gt;&lt;p&gt;容灾方案的 ROI 也是用户需要重点关注的，它用以衡量用户投入到容灾系统的资金与从中所获得的收益的比率。&lt;/p&gt;&lt;p&gt;显然，具有零 RTO 、零 RPO 和大容灾半径的灾难恢复方案是用户最期望的，但受系统性能要求、适用技术及成本等方面的约束，这种方案实际上是不大可行的。所以，用户在选择容灾方案时应该综合考虑灾难的发生概率、灾难对数据的破坏力、数据所支撑业务的重要性、适用的技术措施及自身所能承受的成本等多种因素，理性地作出选择。&lt;/p&gt;&lt;h4&gt;&lt;span&gt;2.容灾级别&lt;/span&gt;&lt;/h4&gt;&lt;p&gt;按照容灾系统对应用系统的保护程度可以分为： &lt;strong&gt;数据级容灾 、 应用级容灾 和 业务级容灾。&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;数据级容灾&lt;/strong&gt; 仅 将生产中心的数据复制到容灾中心，在生产中心出现故障时，仅能实现 存储 系统的接管或是数据的恢复 。容灾 中心的数据可以是本地生产数据的完全复制（ 一般 在同城实现） ， 也可以比生产数据略微落后，但必定是可用的 （一般 在异地实现） ， 而差异的数据 通常 可以通过一些工具（ 如 操作记录、日志等） 可以 手工补回。基于数据容灾 实现 业务恢复的速度 较慢 ，通常情况下 RTO 超过 24 小时， 但是这种 级别 的容灾系统运行维护成本较低。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;应用级容灾&lt;/strong&gt;是 在数据级容灾的基础上，进一步实现应用 可用性 ，确保业务的快速恢复。这就 要求 容灾系统 的 应用不能改变原有业务处理逻辑，是对生产中心系统的基本复制 。因此 ，容灾中心需要建立起一套和本地生产相当的备份环境，包括主机、网络、应用、 IP 等 资源均有配套，当 生产 系统发生灾难时，异地系统可以 提供 完全可用的生产环境。应用级 容灾的 RTO 通常 在 12 个 小时 以内 ，技术复杂度较高，运行维护的成本也比较高。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;业务级容灾&lt;/strong&gt; 是生产中心 与容灾中心对业务请求同时进行 处理 的容灾方式，能够确保 业务 持续可用。这种 方式 业务 恢复 过程的自动化程度高， RTO 可以 做到 30 分钟 以内 。但是 这种容灾级别 的 项目 实施难度大， 需要从 应用层对系统进行改造，比较适合流程固定 的 简单业务系统 。这种 容灾系统 的运行维护成本最高。&lt;/p&gt;&lt;h3&gt;&lt;span&gt;三、架构实践&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;对IT企业来说，传统的单数据中心，已不足以保护企业数据的安全。&lt;/p&gt;&lt;p&gt;当单数据中心存储故障后，可能会导致业务长时间中断，甚至数据丢失。&lt;/p&gt;&lt;p&gt;只做本地的数据冗余保护或容灾建设，已不能规避区域性灾难对企业数据的破坏。远程容灾保护数据及保障企业业务连续性成为了企业亟待解决的问题。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;另外，企业在远程容灾建设中，也面临网络链路租赁费用高昂和网络带宽不够的问题。&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;（1）华为的“基于华为统一存储多级跳复制技术的两地三中心方案”&lt;/strong&gt; &lt;/p&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.5756240822320118&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz/OKUeiaP72uRxtTrmXqn6rvKEnklYkCkPMYtT5RH31PeUSS8xnEqeYGHosN3YEF9aae8uOtDvp6quqWhNDI5xPcA/640?wx_fmt=other&quot; data-type=&quot;other&quot; data-w=&quot;681&quot; title=&quot;&quot;/&gt;&lt;/figure&gt;&lt;p&gt;基于华为统一存储多级跳复制技术，并结合专业的容灾管理软件实现数据的两地三中心保护。&lt;/p&gt;&lt;p&gt;该方案在生产中心、同城灾备中心和异地灾备中心分别部署华为OceanStor统一存储设备，通过异步远程复制技术，将生产中的数据复制到同城灾备中心，再到异地灾备中心，实现数据的保护，方案原理组网如图（1）所示。&lt;/p&gt;&lt;p&gt;若生产中心发生灾难，可在同城灾备中心实现业务切换，并保持与异地灾备中心的容灾关系；若生产中心和同城灾备中心均发生灾难，可在异地灾备中心实现业务切换。&lt;/p&gt;&lt;p&gt;（2）中兴通讯的“基于云计算IaaS和PaaS层面的云计算技术，推出分布式双活数据中心”&lt;/p&gt;&lt;figure&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6974664679582713&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz/OKUeiaP72uRxtTrmXqn6rvKEnklYkCkPMoM5E66hY4knVSoVbFiacoQStPHZ5XCat5pDYFcWU0dz0ZYZIWt0cv7Q/640?wx_fmt=other&quot; data-type=&quot;other&quot; data-w=&quot;671&quot; title=&quot;&quot;/&gt;&lt;/figure&gt;&lt;p&gt;中兴的分布式双活数据中心的建设和部署架构如下图所示，在同城建设两个数据中心，同时为外提供业务服务，同时在异地建设灾备中心，用于数据的备份。&lt;/p&gt;&lt;p&gt;中兴通讯分布式双活数据中心方案可以帮助客户找到优化投资利用率、保证业务连续性的新思路。&lt;/p&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>