<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>e966677c2f9bee21e4ca708cae9da564</guid>
<title>RedisJson 横空出世，这性能杀疯了！</title>
<link>https://toutiao.io/k/y4wdv6t</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;一、概述&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;近期官网给出了RedisJson（RedisSearch）的性能测试报告，可谓碾压其他NoSQL，下面是核心的报告内容，先上结论：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;对于隔离写入(isolated writes)，RedisJSON 比 MongoDB 快 5.4 倍，比 ElasticSearch 快 200 倍以上。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;对于隔离读取(isolated reads)，RedisJSON 比 MongoDB 快 12.7 倍，比 ElasticSearch 快 500 倍以上。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在混合工作负载场景中，实时更新不会影响 RedisJSON 的搜索和读取性能，而 ElasticSearch 会受到影响。以下是具体的数据：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;RedisJSON* 支持的操作数/秒比 MongoDB 高约 50 倍，比 ElasticSearch 高 7 倍/秒。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;RedisJSON* 的延迟比 MongoDB 低约 90 倍，比 ElasticSearch 低 23.7 倍。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;此外，RedisJSON 的读取、写入和负载搜索延迟在更高的百分位数中远比 ElasticSearch 和 MongoDB 稳定。当增加写入比率时，RedisJSON 还能处理越来越高的整体吞吐量，而当写入比率增加时，ElasticSearch 会降低它可以处理的整体吞吐量。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;二、查询引擎&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如前所述，reresearch和RedisJSON的开发非常强调性能。对于每一个版本，我们都想确保开发者可以体验到稳定和产品。为此，我们我们给出了一些分析工具、探测器来进行性能分析。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;并且，我们每次发行新版本时时，也在不断的提升性能。特别是对于reresearch来说，2.2版本在加载和查询性能上都比2.0快了1.7倍，同时还改进了吞吐量和数据加载的延迟。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;2.1 加载优化&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;接下来的两个图显示了运行纽约市出租车基准测试的运行结果&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.624312156078039&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/6fuT3emWI5Ipdw76Gcm7InE3HCCH8iaOouUUmLMqP94KHoG85Mpgbawqb3lXIN8UyVAfS5bJ36bRnGomLcMRTZg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1999&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.624312156078039&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/6fuT3emWI5Ipdw76Gcm7InE3HCCH8iaOo2QA3eUh1wNVHB9BrptR4y68ibjYicglGW1VCLraaN1errGw3ChXDrYaw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1999&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;从这些图表中可以看出，每一个reresearch的新版本都有一个实质性的性能改进。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;2.2 全文搜索优化&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;为了评估搜索性能，我们索引了590万篇维基百科摘要。然后我们运行一个全文搜索查询面板，得到的结果如下图所示。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.583791895947974&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/6fuT3emWI5Ipdw76Gcm7InE3HCCH8iaOoQ1bib9tUV4VWib0uXLP99O5Zv0xKzCBlwVr0LM1ngpHXmibB1eMTbstOw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1999&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.624312156078039&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/6fuT3emWI5Ipdw76Gcm7InE3HCCH8iaOoVnXV6q7ibg0IwMR40f64ia5HsWzREt0fBjuFAejFrgFq2T7Z7N7ibz5PA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1999&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;从上面的图可以看出，通过从v2.0迁移到v2.2，同样的数据，在写、读、搜索(延迟图)方面都有了大幅度的改进，从而提高了运行Search和JSON的可实现吞吐量。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;三、和其他框架的对比&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;为了评估RedisJSON的性能，我们决定将它与MongoDB和ElasticSearch进行比较。为了方便对比，我们会从文档存储、本地可用、云中可用、专业支持和提供可伸缩性、性能等方面进行全方位的对比。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们使用了完善的YCSB标准来进行测试对比，它能够基于常见的工作负载来评估不同的产品，测量延迟、吞吐量曲线直到饱和。除了CRUD YCSB操作之外，我们还添加了一个两个字的搜索操作，专门帮助开发人员、系统架构师和DevOps从业者找到适合他们用例的最佳搜索引擎。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;3.1 基准测试&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;此次测试，我们使用了如下的一些软件环境：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;MongoDB v5.0.3&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;ElasticSearch 7.15&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;RedisJSON (RediSearch 2.2+RedisJSON 2.0)&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;此次是在Amazon Web Services 实例上运行基准测试，这三种解决方案都是分布式数据库，并且最常用于生产中的分布式方式。这就是为什么所有产品都使用相同的通用 m5d.8xlarge VM 和本地 SSD，并且每个设置由四个 VM 组成：一个客户端 + 三个数据库服务器。基准测试客户端和数据库服务器都在处于最佳网络条件下的单独 m5d.8xlarge 实例上运行，将实例紧密地打包在一个可用区内，实现稳态分析所需的低延迟和稳定的网络性能。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;测试是在三节点集群上执行的，部署细节如下：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;MongoDB 5.0.3&lt;/code&gt;：三成员副本集（Primary-Secondary-Secondary）。副本用于增加读取容量并允许更低的延迟读取。为了支持对字符串内容的文本搜索查询，在搜索字段上创建了一个文本索引。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;ElasticSearch 7.15&lt;/code&gt;：15 个分片设置，启用查询缓存，并为 2 个基于 NVMe 的本地 SSD 提供 RAID 0 阵列，以实现更高级别的文件系统相关弹性操作性能。这 15 个分片为我们为 Elastic 所做的所有分片变体提供了可实现的最佳性能结果。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;RedisJSON*&lt;/code&gt;：RediSearch 2.2 and RedisJSON 2.0: OSS Redis Cluster v6.2.6，有27个分片，均匀分布在三个节点上，加载了RediSearch 2.2和RedisJSON 2.0 OSS模块。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;除了这个主要的基准/性能分析场景之外，我们还在网络、内存、CPU 和 I/O 上运行基准基准测试，以了解底层网络和虚拟机特性。在整个基准测试集期间，网络性能保持在带宽和 PPS 的测量限制以下，以产生稳定稳定的超低延迟网络传输（每个数据包 p99 &amp;lt; 100micros）。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;接下来，我们将从提供单独的操作性能 [100% 写入] 和 [100% 读取] 开始，并以一组混合工作负载结束以模拟现实工作中的应用程序场景。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;3.2 100% 写入基准&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如下图所示，该基准测试表明，RedisJSON* 的摄取速度比 ElasticSearch 快 8.8 倍，比 MongoDB 快 1.8 倍，同时保持每个操作的亚毫秒级延迟。值得注意的是，99% 的 Redis 请求在不到 1.5 毫秒的时间内完成。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;此外，RedisJSON* 是我们测试过的唯一一种在每次写入时自动更新其索引的解决方案。这意味着任何后续的搜索查询都会找到更新的文档。ElasticSearch 没有这种细粒度的容量；它将摄取的文档放在一个内部队列中，并且该队列由服务器（不受客户端控制）每 N 个文档或每 M 秒刷新一次。他们称这种方法为近实时 (NRT)。Apache Lucene 库（它实现了 ElasticSearch 的全文功能）旨在快速搜索，但索引过程复杂且繁重。如这些 WRITE 基准测试图表所示，由于这种“设计”限制，ElasticSearch 付出了巨大的代价。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;结合延迟和吞吐量改进，RedisJSON* 比 Mongodb 快 5.4 倍，比 ElasticSearch 快 200 倍以上，用于隔离写入。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5636574074074074&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/6fuT3emWI5Ipdw76Gcm7InE3HCCH8iaOo611nYGmaGGrcVeWIiaMTxFOhlSibia3uibp6RJzBIWhsMcJHGSHRCl5GnA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1728&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5636574074074074&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/6fuT3emWI5Ipdw76Gcm7InE3HCCH8iaOoY4jdTU9WZ3ibIpicV9VothEic8RZDKh3aia9WEybIMicaI70jusuXpoMe5g/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1728&quot;/&gt;&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;3.3 100% 读取基准&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;与写类似，我们可以观察到 Redis 在读取方面表现最佳，允许读取比 ElasticSearch 多 15.8 倍，比 MongoDB 多 2.8 倍，同时在整个延迟范围内保持亚毫秒级延迟，如下表所示。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在结合延迟和吞吐量改进时，RedisJSON* 比 MongoDB 快 12.7 倍，比 ElasticSearch 快 500 倍以上，用于隔离读取。&lt;/p&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.5636574074074074&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/6fuT3emWI5Ipdw76Gcm7InE3HCCH8iaOo6TfKUcIy5oaI2pqQgoQnC0CBXDw6TukKDaBqkZBmjRAU6sFHHI1z6w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1728&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.618421052631579&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/6fuT3emWI5Ipdw76Gcm7InE3HCCH8iaOovwFn6X4ALlkicQX45iallAqcaXDV7WzEFFDWTSfN5hWQxBWSSV0Jk6oQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1520&quot;/&gt;&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;3.4 混合读/写/搜索基准&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;实际应用程序工作负载几乎总是读取、写入和搜索查询的混合。因此，在接近饱和时了解由此产生的混合工作负载吞吐量曲线更为重要。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;作为起点，我们考虑了 65% 搜索和 35% 读取的场景，这代表了一个常见的现实世界场景，在该场景中，我们执行的搜索/查询比直接读取更多。65% 搜索、35% 读取和 0% 更新的初始组合也导致 ElasticSearch 和 RedisJSON* 的吞吐量相等。尽管如此，YCSB 工作负载允许您指定搜索/读取/更新之间的比率以满足您的要求。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;“搜索性能”可以指不同类型的搜索，例如“匹配查询搜索”、“分面搜索”、“模糊搜索”等等。我们所做的最初向 YCSB 增加的搜索工作负载仅专注于“匹配查询搜索”，模仿分页的两词查询匹配，按数字字段排序。“匹配查询搜索”是任何启用搜索功能的供应商进行搜索分析的起点，因此，每个支持 YCSB 的数据库/驱动程序都应该能够在其基准驱动程序上轻松启用此功能。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在每个测试变体中，我们添加了 10% 的写入，以按相同的比例混合和减少搜索和读取百分比。这些测试变体的目标是了解每个产品如何处理数据的实时更新，我们认为这是事实上的架构目标，即写入立即提交到索引，读取始终是最新的。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6423444976076556&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/6fuT3emWI5Ipdw76Gcm7InE3HCCH8iaOo0yed0ibm9bF1AplAt4TgcS42aFwUfR28C1tCuC4484bypMia942nGOTQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1672&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;正如您在图表中所看到的，在 RedisJSON* 上不断更新数据和增加写入比例不会影响读取或搜索性能并提高整体吞吐量。对数据产生的更新越多，对 ElasticSearch 性能的影响就越大，最终导致读取和搜索速度变慢。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;ElasticSearch 可实现的 ops/sec 从 0% 更新到 50% 的演变，我们注意到它在 0% 更新基准上以 10k Ops/sec 开始，并受到严重影响，减少了 5 倍的 ops/sec，在50% 更新率基准。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;与我们在上述单个操作基准中观察到的类似，MongoDB 搜索性能比 RedisJSON* 和 ElasticSearch 慢两个数量级，MongoDB 的最大总吞吐量为 424 ops/sec，而 RedisJSON* 为 16K 最大 ops/sec。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;最后，对于混合工作负载，RedisJSON* 支持的操作数/秒比 MongoDB 高 50.8 倍，比 ElasticSearch 高 7 倍。如果我们将分析集中在混合工作负载期间的每种操作类型的延迟上，与 MongoDB 相比，RedisJSON* 可将延迟降低多达 91 倍，与 ElasticSearch 相比，延迟降低 23.7 倍。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;3.5 完整延迟分析&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;与测量每个解决方案饱和之前产生的吞吐量曲线类似，在所有解决方案通用的可持续负载下进行完整的延迟分析也很重要。这将使您能够了解对于所有已发布操作在延迟方面最稳定的解决方案是什么，以及哪种解决方案不易受到应用程序逻辑引发的延迟峰值的影响（例如，弹性查询缓存未命中）。如果您想更深入地了解我们为什么要这样做，Gil Tene 提供了延迟测量注意事项的深入概述。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;查看上一节的吞吐量图表，并关注 10% 更新基准以包含所有三个操作，我们做了两种不同的可持续负载变化：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;250 ops/sec&lt;/code&gt;：比较 MongoDB、ElasticSearch 和 RedisJSON*，低于 MongoDB 的压力率。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;6000 ops/sec&lt;/code&gt;：比较 ElasticSearch 和 RedisJSON*，低于 ElasticSearch 压力率。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;3.5.1 MongoDB 与 ElasticSearch 与 RedisJSON* 的延迟分析&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在下面的第一张图片中，展示了从 p0 到 p9999 的百分位数，很明显，在每次搜索时，MongoDB 的表现都远远优于 Elastic 和 RedisJSON&lt;em&gt;。此外，关注 ElasticSearch 与 RedisJSON&lt;/em&gt;，很明显，ElasticSearch 容易受到较高延迟的影响，这很可能是由垃圾收集 (GC) 触发器或搜索查询缓存未命中引起的。RedisJSON* 的 p99 低于 2.61 毫秒，而 ElasticSearch p999 搜索达到 10.28 毫秒。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/6fuT3emWI5Ipdw76Gcm7InE3HCCH8iaOoSIgCOft3OEc0H9BW2zQQyF1diamfHdHXyxFxgBfIvy6lSBM6Ldhnu6w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1600&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在下面的读取和更新图表中，我们可以看到 RedisJSON* 在所有延迟范围内表现最佳，其次是 MongoDB 和 ElasticSearch。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;RedisJSON* 是在所有分析的延迟百分位数上保持亚毫秒级延迟的唯一解决方案。在 p99，RedisJSON* 的延迟为 0.23 毫秒，其次是 MongoDB 的 5.01 毫秒和 ElasticSearch 的 10.49 毫秒。&lt;/p&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.5&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/6fuT3emWI5Ipdw76Gcm7InE3HCCH8iaOoJN5FLx51FRmGNXYV4cJHPr2lHpha5T9RYtfZWjGnaXy5zmFw0D7k3A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1600&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在写入时，MongoDB 和 RedisJSON* 即使在 p99 时也能保持亚毫秒级的延迟。另一方面，ElasticSearch 显示出高尾延迟（&amp;gt; 10 毫秒），这很可能与导致 ElasticSearch 搜索峰值的原因 (GC) 相同。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/6fuT3emWI5Ipdw76Gcm7InE3HCCH8iaOoAicsbeISKwnTjxmRicsZ6RWjcVpib7Q32nB05bhgtc1MuHGnzoUXbzA8g/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1600&quot;/&gt;&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;3.5.2 ElasticSearch 与 RedisJSON 的延迟分析&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;仅关注 ElasticSearch 和 RedisJSON&lt;em&gt;，在保持 6K ops/sec 的可持续负载的同时，我们可以观察到 Elastic 和 RedisJSON&lt;/em&gt; 的读取和更新模式与以 250 ops/sec 进行的分析保持一致。RedisJSON* 是更稳定的解决方案，其 p99 读取时间为 3 毫秒，而 Elastic 的 p99 读取时间为 162 毫秒。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在更新时，RedisJSON* 保留了 3 毫秒的 p99，而 ElasticSearch 则保留了 167 毫秒的 p99。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/6fuT3emWI5Ipdw76Gcm7InE3HCCH8iaOoLoJVvKgRRI3rmCNLzUjCvpk1MA5l6Ioxqm7dPF6qf2vrqoSIQ2hgOA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1600&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/6fuT3emWI5Ipdw76Gcm7InE3HCCH8iaOohq9AdiaxdPAohSbybaM0Iwey2nQD6GEt0v1nwW8oxnhic8fzcdhBGvPg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1600&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;专注于搜索操作，ElasticSearch 和 RedisJSON* 以个位数 p50 延迟开始（p50 RedisJSON* 为 1.13 毫秒，而 ElasticSearch 的 p50 为 2.79 毫秒），其中 ElasticSearch 付出了 GC 触发和查询缓存未命中的代价在较高的百分位数上，在 &amp;gt;= p90 百分位数上清晰可见。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;RedisJSON* 将 p99 保持在 33 毫秒以下，而 ElasticSearch 上的 p99 百分位数为 163 毫秒，高出 5 倍。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/6fuT3emWI5Ipdw76Gcm7InE3HCCH8iaOoKUACUUMo6ttA42WSADP4nRFwA1PsibTDibRpwGAj7g5bnicy3BW0K56qw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1600&quot;/&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;四、如何开始&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;开始使用RedisJSON*，我们可以创建一个免费的数据库在所有地区的Redis云，或者使用RedisJSON docker容器。我们已经更新了redisjson的文档，以方便开发者快速的开始使用查询和搜索功能。此外，正如我们在最近的客户机库声明中提到的，以下是几种流行语言的客户机驱动程序，可以帮助您快速入门。&lt;/p&gt;&lt;section data-tool=&quot;mdnice编辑器&quot;&gt;&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;&lt;br/&gt;&lt;/th&gt;&lt;th&gt;RedisJSON*&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;Node.js&lt;/td&gt;&lt;td&gt;node-redis&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;Java&lt;/td&gt;&lt;td&gt;Jedis&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;.NET&lt;/td&gt;&lt;td&gt;NRedisJSON NRediSearch&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;Python&lt;/td&gt;&lt;td&gt;redis-py&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/section&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>99ca66fcc49e4d9f2325fbe3bfdec968</guid>
<title>看Go中的struct如何被优化，还有小插曲</title>
<link>https://toutiao.io/k/zv2dasc</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;struct中的字段顺序&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;以下面的结构为例，咱们看看下面的结构体：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;package&lt;/span&gt; main&lt;br/&gt;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; (&lt;br/&gt; &lt;span&gt;&quot;fmt&quot;&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;&quot;time&quot;&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;&quot;unsafe&quot;&lt;/span&gt;&lt;br/&gt;)&lt;br/&gt;&lt;br/&gt;&lt;span&gt;type&lt;/span&gt; People &lt;span&gt;struct&lt;/span&gt; {&lt;br/&gt;    ID          &lt;span&gt;int64&lt;/span&gt;       &lt;span&gt;// Sizeof: 8 byte  Alignof: 8  Offsetof: 0&lt;/span&gt;&lt;br/&gt;    Gender      &lt;span&gt;int8&lt;/span&gt;        &lt;span&gt;// Sizeof: 1 byte  Alignof: 1  Offsetof: 8&lt;/span&gt;&lt;br/&gt;    NickName    &lt;span&gt;string&lt;/span&gt;      &lt;span&gt;// Sizeof: 16 byte Alignof: 8 Offsetof: 16&lt;/span&gt;&lt;br/&gt;    Description &lt;span&gt;string&lt;/span&gt;      &lt;span&gt;// Sizeof: 16 byte Alignof: 8 Offsetof: 32&lt;/span&gt;&lt;br/&gt;    IsDeleted   &lt;span&gt;bool&lt;/span&gt;        &lt;span&gt;// Sizeof: 1 byte  Alignof: 1  Offsetof: 48&lt;/span&gt;&lt;br/&gt;    Created     time.Time   &lt;span&gt;// Sizeof: 24 byte Alignof: 8  Offsetof: 56&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt;{&lt;br/&gt;    p := People{}&lt;br/&gt;    fmt.Println(unsafe.Sizeof(p))&lt;br/&gt;}&lt;br/&gt;&lt;span&gt;// output&lt;/span&gt;&lt;br/&gt;&lt;span&gt;// 80&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;从上面的输出可以看出打印结果为 80 字节，但是所有字段加起来是66 字节。那额外的 14 个字节是怎么来的呢？想必大部分同学也很清楚。64 位CPU处理器每次可以以 64 位（8 字节）块的形式传输数据。32 位 CPU的话则是32 位（4 字节）。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;第一个字段&lt;code&gt;ID&lt;/code&gt;占用 8 个字节，&lt;code&gt;Gender&lt;/code&gt;字段占用了1 个字节并有 7 个未使用的字节。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;第二个和第三个字段为字符串类型为16字节，接下来是&lt;code&gt;IsDeleted&lt;/code&gt;字段，它需要 1 个字节并有 7 个未使用的字节。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;最好的情况是是按字段的大小从大到小对字段进行排序。对上述结构体进行排序，大小减少到 72 个字节。最后两个字段 &lt;code&gt;Gender&lt;/code&gt; 和 &lt;code&gt;IsDeleted&lt;/code&gt; 被放在同一个块中，从而将未使用的字节数从 14 (2x7) 减少到 6 (1 x 6)，在此过程中节省了 8 个字节。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;type&lt;/span&gt; People &lt;span&gt;struct&lt;/span&gt; {&lt;br/&gt;    CreatedAt   time.Time &lt;span&gt;// 24 bytes&lt;/span&gt;&lt;br/&gt;    NickName    &lt;span&gt;string&lt;/span&gt;    &lt;span&gt;// 16 bytes&lt;/span&gt;&lt;br/&gt;    Description &lt;span&gt;string&lt;/span&gt;    &lt;span&gt;// 16 bytes&lt;/span&gt;&lt;br/&gt;    ID          &lt;span&gt;int64&lt;/span&gt;     &lt;span&gt;// 8 bytes&lt;/span&gt;&lt;br/&gt;    Gender      &lt;span&gt;int8&lt;/span&gt;      &lt;span&gt;// 1 byte&lt;/span&gt;&lt;br/&gt;    IsDeleted   &lt;span&gt;bool&lt;/span&gt;      &lt;span&gt;// 1 byte&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt;{&lt;br/&gt;    p := People{}&lt;br/&gt;    fmt.Println(unsafe.Sizeof(p))&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;下面咱们看看&lt;span&gt;Go 白皮书&lt;/span&gt;&lt;sup&gt;[1]&lt;/sup&gt;中对字节大小保证的一些说明：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;对于&lt;span&gt;数字类型&lt;/span&gt;&lt;sup&gt;[2]&lt;/sup&gt;，有下面的大小保证：&lt;/p&gt;&lt;section data-tool=&quot;mdnice编辑器&quot;&gt;&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;类型&lt;/th&gt;&lt;th&gt;占用字节大小&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;byte, uint8, int8&lt;/td&gt;&lt;td&gt;1&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;uint16, int16&lt;/td&gt;&lt;td&gt;2&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;uint32, int32, float32&lt;/td&gt;&lt;td&gt;4&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;uint64, int64, float64, complex64&lt;/td&gt;&lt;td&gt;8&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;complex128&lt;/td&gt;&lt;td&gt;16&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;保证以下最小对齐属性：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;对于任何类型的变量&lt;code&gt;x&lt;/code&gt;：&lt;code&gt;unsafe.Alignof(x)&lt;/code&gt;至少为 1。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;对于struct 类型的变量&lt;code&gt;x&lt;/code&gt;：&lt;code&gt;unsafe.Alignof(x)&lt;/code&gt;是所有字段字节对齐的最大值&lt;code&gt;unsafe.Alignof(x.f)&lt;/code&gt;，但至少为 1。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;对于数组类型的变量&lt;code&gt;x&lt;/code&gt; ：&lt;code&gt;unsafe.Alignof(x)&lt;/code&gt;与数组元素类型的变量的对齐方式相同。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果struct或数组类型不包含大小大于零的字段（或元素），则其大小为零。两个不同的零大小变量在内存中可能具有相同的地址。&lt;/p&gt;&lt;hr data-tool=&quot;mdnice编辑器&quot;/&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可以看出占用小于8 字节的 Go 类型有：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;bool：1 个字节&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;int8/uint8：1 个字节&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;int16/uint16：2 个字节&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;int32/uint32/rune：4 字节&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;float32：4 字节&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;byte：1个字节&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那么你知道了这些小于8字节的类型，要手动检查他的大小然后对其进行排序嘛，NONONO，小土下面给大家推荐一个&lt;code&gt;linter&lt;/code&gt; &lt;span&gt;fieldalignment&lt;/span&gt;&lt;sup&gt;[3]&lt;/sup&gt;来检查并进行正确地排序。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;fieldalignment 小工具&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里小土给大家介绍一个检测和对齐结构体字段的小工具&lt;code&gt;fieldalignment&lt;/code&gt;,顾名思义就是&lt;strong&gt;字段对齐&lt;/strong&gt;的意思。下面让我们在项目中安装和运行一下&lt;code&gt;fieldalignment&lt;/code&gt;。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;安装fieldalignment&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;$go&lt;/span&gt; install golang.org/x/tools/go/analysis/passes/fieldalignment/cmd/fieldalignment@latest&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;先别着急运行，咱们先来看下filedalignment的使用，fieldalignment可以找到那些可以重新排列以减少内存的结构，并提供
建议编辑最紧凑的顺序。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;fieldalignment介绍&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;$ fieldalignment&lt;br/&gt;fieldalignment: find structs that would use less memory &lt;span&gt;if&lt;/span&gt; their fields were sorted&lt;br/&gt;&lt;br/&gt;Usage: fieldalignment [-flag] [package]&lt;br/&gt;&lt;br/&gt;This analyzer find structs that can be rearranged to use less memory, and provides&lt;br/&gt;a suggested edit with the most compact order.&lt;br/&gt;&lt;br/&gt;Note that there are two different diagnostics reported. One checks struct size,&lt;br/&gt;and the other reports &lt;span&gt;&quot;pointer bytes&quot;&lt;/span&gt; used. Pointer bytes is how many bytes of the&lt;br/&gt;object that the garbage collector has to potentially scan &lt;span&gt;for&lt;/span&gt; pointers, &lt;span&gt;for&lt;/span&gt; example:&lt;br/&gt;&lt;br/&gt;        struct { uint32; string }&lt;br/&gt;&lt;br/&gt;have 16 pointer bytes because the garbage collector has to scan up through the string&lt;span&gt;&#x27;s&lt;br/&gt;inner pointer.&lt;br/&gt;&lt;br/&gt;        struct { string; *uint32 }&lt;br/&gt;&lt;br/&gt;has 24 pointer bytes because it has to scan further through the *uint32.&lt;br/&gt;&lt;br/&gt;        struct { string; uint32 }&lt;br/&gt;&lt;br/&gt;has 8 because it can stop immediately after the string pointer.&lt;br/&gt;&lt;br/&gt;Be aware that the most compact order is not always the most efficient.&lt;br/&gt;In rare cases it may cause two variables each updated by its own goroutine&lt;br/&gt;to occupy the same CPU cache line, inducing a form of memory contention&lt;br/&gt;known as &quot;false sharing&quot; that slows down both goroutines.&lt;br/&gt;&lt;br/&gt;&lt;br/&gt;Flags:&lt;br/&gt;  -V    print version and exit&lt;br/&gt;  -all&lt;br/&gt;        no effect (deprecated)&lt;br/&gt;  -c int&lt;br/&gt;        display offending line with this many lines of context (default -1)&lt;br/&gt;  -cpuprofile string&lt;br/&gt;        write CPU profile to this file&lt;br/&gt;  -debug string&lt;br/&gt;        debug flags, any subset of &quot;fpstv&quot;&lt;br/&gt;  -fix&lt;br/&gt;        apply all suggested fixes&lt;br/&gt;  -flags&lt;br/&gt;        print analyzer flags in JSON&lt;br/&gt;  -json&lt;br/&gt;        emit JSON output&lt;br/&gt;  -memprofile string&lt;br/&gt;        write memory profile to this file&lt;br/&gt;  -source&lt;br/&gt;        no effect (deprecated)&lt;br/&gt;  -tags string&lt;br/&gt;        no effect (deprecated)&lt;br/&gt;  -test&lt;br/&gt;        indicates whether test files should be analyzed, too (default true)&lt;br/&gt;  -trace string&lt;br/&gt;        write trace log to this file&lt;br/&gt;  -v    no effect (deprecated)&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;看帮助的说明这里小土总结一下fieldalignment的介绍：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;fieldalignment 会有两个不同的报告，一个是检查结构体的大小。另一个报告所使用的指针字节数(是指gc会对struct中的这些字节进行潜在的指针扫描)。&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;struct { uint32; string } ：16个指针字节，gc会扫描字符串的内部指针。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;struct { string; *uint32 } : 24个指针字节，gc会进一步扫描 *uint32。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;struct { string; uint32 }：8个指针字节，因为扫描到string会立马停止。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可以看出最紧凑的顺序并不总是最有效的。在极少数情况下，它可能会导致两个变量分别被自己的goroutine更新占用同一个CPU缓存线，从而引起一种被称为 &quot;假共享 &quot;的内存争夺。这样会降低了两个goroutine的速度。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;运行fieldalignment&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;小土在项目中使用了&lt;code&gt;fieldalignment&lt;/code&gt;命令，可以看出检测出不少的不符合排序规则的struct，而且&lt;code&gt;fieldalignment&lt;/code&gt;将未对齐的字段进行了重新排序，再次执行可以看到就没有相关的提示了。从下面的检测信息中大家也可以看出未对齐的&lt;code&gt;struct&lt;/code&gt;中有8-64字节的空间浪费。&lt;code&gt;struct&lt;/code&gt;较多的项目，算下来也是一笔不小的开销(8B*1024=8K,觉得这些内存占用微不足道的同学也可以忽略哈)。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;$fieldalignment&lt;/span&gt; -fix ./...        &lt;br/&gt;... &lt;span&gt;# 前面代码就省略了&lt;/span&gt;&lt;br/&gt;struct with 2568 pointer bytes could be 2560&lt;br/&gt;struct with 56 pointer bytes could be 48&lt;br/&gt;struct with 16 pointer bytes could be 8&lt;br/&gt;struct with 16 pointer bytes could be 8&lt;br/&gt;struct of size 80 could be 72&lt;br/&gt;struct with 200 pointer bytes could be 176&lt;br/&gt;struct with 104 pointer bytes could be 72&lt;br/&gt;struct with 80 pointer bytes could be 72&lt;br/&gt;struct with 32 pointer bytes could be 24&lt;br/&gt;struct with 40 pointer bytes could be 32&lt;br/&gt;struct with 104 pointer bytes could be 40&lt;br/&gt;struct with 72 pointer bytes could be 56&lt;br/&gt;struct of size 256 could be 248&lt;br/&gt;struct with 64 pointer bytes could be 48&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;fieldalignment的小bug&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;经过小土前面一顿操作执行，在准备commit的时候发现之前struct中的注释居然变没了，于是小土也给Go官方提了一个小issue，&lt;span&gt;https://github.com/golang/go/issues/54333&lt;/span&gt;，都好几天了也都没给回复，sad😭，看来这问题有点微不足道。希望在大家使用&lt;code&gt;fieldalignment&lt;/code&gt;的时候注意这一点，小土是在fix之后进行了一些注释恢复。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;小结&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;简单总结一下，小土开始对struct中的字段字节对齐做了一些分析并推荐了一个对struct中的字段顺序错乱fix的工具fieldalignment。希望今天的文章对大家有一些帮助，如有相关看法欢迎留言讨论。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;参考资料&lt;/span&gt;&lt;/h3&gt;&lt;section data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;span&gt;[1]&lt;/span&gt;&lt;p&gt;Go 白皮书: &lt;em&gt;https://go.dev/ref/spec#Size_and_alignment_guarantees&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[2]&lt;/span&gt;&lt;p&gt;数字类型: &lt;em&gt;https://go.dev/ref/spec#Numeric_types&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[3]&lt;/span&gt;&lt;p&gt;fieldalignment: &lt;em&gt;https://pkg.go.dev/golang.org/x/tools/go/analysis/passes/fieldalignment&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>03f9ddb7fd8f282f6a57ada300643fca</guid>
<title>go错误处理的一种实践</title>
<link>https://toutiao.io/k/oqb90id</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot; data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;最近写了个程序，因为是急活（貌似没有不急的...），所以这个程序又是我东拷一段，西粘一块拼出来的。代码写完了后，感觉这代码屎一样，都快把自己看哭了。真的是在心里边写别骂，先是骂以前做这个项目的人蠢，项目搞的跟屎一样，后来代码跑起来了，顺利交工后，变成了骂我自己蠢，这么写又不是不能用！&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5616161616161616&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/z4pQ0O5h0f66PibzcbHs0m7xhJoicYzPPicIFviaPQ7ACCjbrNlyFRqlKKia5fmgxWZWGWY6a17gH7RaliaSDKma7KkA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;495&quot;/&gt;&lt;figcaption&gt;又不是不能用&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;不过在这个过程中，先不提项目里的业务逻辑、接口设计合不合理的事儿，这个我觉得在时间紧，加上人员更迭快的时候，正常人都会能粘就粘，不行了就再包一层，别改出线上问题了就行。有一点我把自己蠢哭的是，Go 的这个错误处理也太TM蠢了，一个程序我写了七八个错误判断，我给你们用伪代码描述一下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;err, file :=  接收传文件(文件)&lt;br/&gt;&lt;span&gt;if&lt;/span&gt; err != &lt;span&gt;nil&lt;/span&gt; {&lt;br/&gt;  记日志&lt;br/&gt;  返回错误码相应&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;err, fh :=  打开上传文件(file)&lt;br/&gt;&lt;span&gt;if&lt;/span&gt; err != &lt;span&gt;nil&lt;/span&gt; {&lt;br/&gt;  记日志&lt;br/&gt;  返回错误码相应&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;err, data := 把文件里的行记录解析/转换一下(row)&lt;br/&gt;&lt;span&gt;if&lt;/span&gt; err != &lt;span&gt;nil&lt;/span&gt; {&lt;br/&gt;  记日志&lt;br/&gt;  返回错误码相应&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;err, data3 := 调一下第三方接口拿数据&lt;br/&gt;&lt;span&gt;if&lt;/span&gt; err != &lt;span&gt;nil&lt;/span&gt; {&lt;br/&gt;  记日志&lt;br/&gt;  返回错误码相应&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;err, data2 := 调一下内部其他服务拿数据&lt;br/&gt;&lt;span&gt;if&lt;/span&gt; err != &lt;span&gt;nil&lt;/span&gt; {&lt;br/&gt;  记日志&lt;br/&gt;  返回错误码相应&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;err := 写库&lt;br/&gt;&lt;span&gt;if&lt;/span&gt; err != &lt;span&gt;nil&lt;/span&gt; {&lt;br/&gt;  记日志&lt;br/&gt;  返回错误码相应&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上面这个例子毫不夸张，我相信各位在自己的项目里一定见过，如果你是做业务开发的会更常见。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里有人肯定会问，Go的错误处理就这样你难道第一天见吗，还能被蠢哭。诶，这不是降本提效后人员少了一半，我们这帮级别没混上去的虚线Leader，这不又开始自己写代码了嘛，以前蠢又蠢不到自己。再加上以前的系统、项目分层、服务隔离整的还凑活，不会像上面这样，在控制层调这么多业务对象，把蠢瓜代码集中在了一起…… 官感马上不一样了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;于是乎我就在思考，有没有什么设计模式什么的，能把这些东西隐藏下去，应该有吧，没有什么是包一层代码解决不了的吧，实在不行就包两层……诶，咋一不小心把设计模式的精髓给说出来了。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;Go 优雅处理错误的几种方案&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我这几天在网上看了不少说，Go 错误处理的，但基本上都是说怎么自定义包装 error 、传递error 之类的，讲怎么在写 Go 代码时能更优雅更好看的文章比较少，写的最好的是左耳朵耗子老师在自己博客里介绍的两种方式。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;下面的部分代码参考自老师的博客：https://coolshell.cn/articles/21140.html&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;一种是用函数式编程的 Closure 把相同的 if err !=nil 之类的代码抽象出来重新定义一个函数，但是这种方式会导致新的问题--在每个函数里都需要引入内部函数和一个 error 变量，所以咱就不多说了，有兴趣的可以去原博文查看。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里直接介绍另外一种更好的，对项目侵入不是很大的方案给大家。在 Go 语言官方库 &lt;code&gt;bufio&lt;/code&gt; 中 &lt;code&gt;Scanner&lt;/code&gt;对象的错处理的实现方式可以给我们一点启发，它大概是这么实现的。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;scanner := bufio.NewScanner(input)&lt;br/&gt;&lt;br/&gt;&lt;span&gt;for&lt;/span&gt; scanner.Scan() {&lt;br/&gt;    token := scanner.Text()&lt;br/&gt;    &lt;span&gt;// process token&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;if&lt;/span&gt; err := scanner.Err(); err != &lt;span&gt;nil&lt;/span&gt; {&lt;br/&gt;    &lt;span&gt;// process the error&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上面的代码我们可以看到，&lt;code&gt;scanner&lt;/code&gt;在操作底层的I/O的时候，那个for-loop中没有任何的 &lt;code&gt;if err !=nil&lt;/code&gt; 的情况，退出循环后有一个 &lt;code&gt;scanner.Err()&lt;/code&gt; 的检查。看来使用了结构体的方式。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们来看一下 &lt;code&gt;Scanner&lt;/code&gt;类型的定义&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;type&lt;/span&gt; Scanner &lt;span&gt;struct&lt;/span&gt; {&lt;br/&gt; r            io.Reader&lt;br/&gt;  ...&lt;span&gt;//其他字段省略&lt;/span&gt;&lt;br/&gt; err          error    &lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个类型内部持有一个&lt;code&gt;error&lt;/code&gt; 在迭代执行 Scan 方法时，遇到错误后会往这个 error 中记录错误。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;(s *Scanner)&lt;/span&gt; &lt;span&gt;Scan&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;span&gt;bool&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;  ...&lt;span&gt;// 其余代码省略&lt;/span&gt;&lt;br/&gt; &lt;span&gt;for&lt;/span&gt; {&lt;br/&gt;   &lt;span&gt;if&lt;/span&gt; err != &lt;span&gt;nil&lt;/span&gt; {&lt;br/&gt;    s.setErr(err)&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;br/&gt;   }&lt;br/&gt;}&lt;br/&gt;  &lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;(s *Scanner)&lt;/span&gt; &lt;span&gt;Err&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;span&gt;error&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; &lt;span&gt;if&lt;/span&gt; s.err == io.EOF {&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; &lt;span&gt;nil&lt;/span&gt;&lt;br/&gt; }&lt;br/&gt; &lt;span&gt;return&lt;/span&gt; s.err&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以我们可以参考这个思路继续搞下去。比如来一个读取业务对象的&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;2.0905797101449277&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/z4pQ0O5h0f66PibzcbHs0m7xhJoicYzPPiclkub7qO0hvlyqqop6sdYicVSXLY83m6F4jedVFqFuCgZUWZMuOdssqA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1104&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上面这个示例相信大家很容易看懂，不过，其使用场景也就只能在对于同一个业务对象的不断操作下可以简化错误处理，对于多个业务对象的话，还是得需要各种 &lt;code&gt;if err != nil&lt;/code&gt;的方式。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那有什么办法呢，咱们之前说过一次：没有什么是包一层代码解决不了的吧，实在不行就包两层。那么接下来我们再做一层包装，以下是我对解决这个问题的一点点理解，会借鉴一点DDD中分层的概念解决这个事情。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;更容易落地的方案&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;刚才那个例子的问题是只适合减少单个业务对象逻辑操作中的 if err != nill 判断，那么针对这块呢，咱们可以把涉及多个业务对象的操作放在一个应用服务里，把刚才在业务对象做的错误处理判断拿到应用服务里，这样业务对象里，比如Model之类的下层模块里，就还能按照正常的流程写代码了，不用每个方法开头都要先判断一下。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里提前说一下，在一些架构设计里会分应用服务和领域服务，这两者的概念完全不一样，应用服务是面向产品需求的用例实现的，负责业务用例流的任务协调，就是我们实现API时，往往会控制层调应用服务，多个不同的业务对象可以放到一个应用服务里。而领域服务是专一给一个领域的，这块我就不多解释了，DDD这些我也是看了几本书，看过COLA框架的实现，还在似懂非懂的水平。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;总之记住一点，通过应用服务可以协调多个业务对象执行任务，同时我们上面业务对象加的那些错误处理抽离到应用服务层里，让业务对象更专注自己的职责。这样的话，你的服务层代码，可能就得变成了这样&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1.7468531468531467&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/z4pQ0O5h0f66PibzcbHs0m7xhJoicYzPPicLT9DGCBN8n1SS9yt6xCe1Zkq3WafDmHws5Kx3RF1hmFO2CD22jibtww/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1430&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;然后我们的控制层呢，调用应用服务层拿到结果，并且在这个时候判断整个需求任务执行的过程中有没有错误，有的话记录错误，返回错误响应给客户端。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.7300177619893428&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/z4pQ0O5h0f66PibzcbHs0m7xhJoicYzPPic8TuLH1LiaDZKvRLQJVtfTRdqsZVCzyKtfOITGkkCh3DyjhOOKiaMzG5g/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1126&quot;/&gt;&lt;/figure&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;Go 错误处理的基础&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;之前分享过一篇文章  &lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzUzNTY5MzU2MA==&amp;amp;mid=2247489442&amp;amp;idx=1&amp;amp;sn=1805944e5acbe8629fdfa534c53a27dd&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;关于Go程序错误处理的一些建议&lt;/a&gt; 说的是我们应该怎么用好 Go 的error 接口，自定义错误，包装整个错误链等相关的技能。跟本文的内容关联起来看，可能会对错误处理有个更全局的理解，在这里也推荐给大家。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;总结&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;今天给大家分享了一些在让Go代码的错误处理更优雅上，我学到和&lt;span data-change-font=&quot;1&quot;/&gt;想到的一些东西。其实大家可以发现，我们是把多个 if err != nil 分散到了多个方法里，这样代码最起码从感官上看起来比在一个方法里写七八个错误判断更好一点。&lt;/p&gt;&lt;section class=&quot;mp_profile_iframe_wrp&quot;&gt;&lt;mp-common-profile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-id=&quot;MzUzNTY5MzU2MA==&quot; data-pluginname=&quot;mpprofile&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/z4pQ0O5h0f4pGhLz2xEbRFHnAQon2QLYgbBibCJo1ibJHesLWshPJeRibateRtAqkaf6BgjlbhYiaxHLq6Zu07CRPw/0?wx_fmt=png&quot; data-nickname=&quot;网管叨bi叨&quot; data-alias=&quot;kevin_tech&quot; data-signature=&quot;分享软件开发和系统架构设计基础、Go 语言和Kubernetes。&quot; data-from=&quot;0&quot; data-is_biz_ban=&quot;0&quot;/&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;对错误处理方面你有哪些见解呢，欢迎在评论区里积极发言，喜欢这篇文章还请帮忙来个点赞在看加分享吧，接下来内容还在向你们招手🙋‍♂️。&lt;/p&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>5e7d93e2f2bcd53ad69f84a1d65a48af</guid>
<title>一文看懂大数据生态圈完整知识体系（文末赠书）</title>
<link>https://toutiao.io/k/j95wj12</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content                                       &quot; id=&quot;js_content&quot;&gt;&lt;section class=&quot;mp_profile_iframe_wrp&quot; data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;mp-common-profile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mpprofile&quot; data-id=&quot;MzA3NTM0MTYyMQ==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/7iaMpruNx3Afic1pUJiat0zez4aPTUCyHDAs7PzvDuIO6GRh5jhGImRAicoUsg240UM4w7zooIKAiaqwnAiaU2BMNl0Q/0?wx_fmt=png&quot; data-nickname=&quot;志明与数据&quot; data-alias=&quot;zhiming_data&quot; data-signature=&quot;专注于数据管理、数据治理、项目管理、大数据等相关领域的知识内容、实践经验、心得感悟分享。&quot; data-from=&quot;0&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;新书推荐，先看看正文介绍，文末赠书2本&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.05669291338582677&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;635&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PW0wIHxgg3nr1VNxfeqxVOw2nPJHVH4xeZibzPY5F4ibOuOZLMsUMrzIibGB6KMw7EurSKv6DkrtLzuhYdBa30A9Q/640?wx_fmt=png&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;随着大数据行业的发展，大数据生态圈中相关的技术也在一直迭代进步，作者有幸亲身经历了国内大数据行业从零到一的发展历程，通过本文希望能够帮助大家快速构建大数据生态圈完整知识体系。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;目前大数据生态圈中的核心技术总结下来如图1所示，分为以下9类，下面分别介绍。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;314&quot; data-backw=&quot;562&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;562&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;291&quot; data-ratio=&quot;0.5589798087141339&quot; data-type=&quot;png&quot; data-w=&quot;941&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PW0wIHxgg3nPJpjtezpjPicR4yfx7ARx6XaT8kkJSbzXTy2icxdzqADqgzibo9MhfPbsHbQI2ueueNibkDXcaaPbVg/640?wx_fmt=png&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-id=&quot;98856&quot; data-tools=&quot;135编辑器&quot;&gt;&lt;section&gt;&lt;section hm_fix=&quot;158:346&quot;&gt;&lt;section data-original-title=&quot;&quot; title=&quot;&quot;&gt;&lt;strong&gt;1&lt;/strong&gt;&lt;/section&gt;&lt;section data-width=&quot;15%&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-brushtype=&quot;text&quot;&gt;&lt;span&gt;&lt;strong&gt;数据采集技术框架&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;数据采集也被称为数据同步。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;随着互联网、移动互联网、物联网等技术的兴起，产生了海量数据。这些数据散落在各个地方，我们需要将这些数据融合到一起，然后从这些海量数据中计算出一些有价值的内容。&lt;/span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;此时第一步需要做的是把数据采集过来。&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;数据采集是大数据的基础，没有数据采集，何谈大数据！&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;数据采集技术框架包括以几种。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;86005&quot;&gt;&lt;section data-autoskip=&quot;1&quot; data-role=&quot;list&quot;&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;Flume、Logstash和FileBeat&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;常用于日志数据实时监控采集，它们之间的细节区别见表1；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;Sqoop和Datax&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;常用于关系型数据库离线数据采集，它们之间的细节区别见表2；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;Cannal和Maxwell&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;常用于关系型数据库实时数据采集，它们之间的细节区别见表3。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;表1&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.47286012526096033&quot; data-type=&quot;png&quot; data-w=&quot;958&quot; data-backw=&quot;578&quot; data-backh=&quot;273&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PW0wIHxgg3lcYIbxWw19Z0lTlaCgjaqniccsib9fPTXx9LnBJD8NdrWGicfbnaicJ8icsa08Uo2wujOrMCzpprqdTZg/640?wx_fmt=png&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;表2&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.42250740375123397&quot; data-type=&quot;png&quot; data-w=&quot;1013&quot; data-backw=&quot;578&quot; data-backh=&quot;244&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PW0wIHxgg3lcYIbxWw19Z0lTlaCgjaqnC1DEGW6yGMv8LEuNnRM5Ur4NS07IQBiaxLLIFIDIO8Mv3icFre7iagI2Q/640?wx_fmt=png&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;表3&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.41544477028348&quot; data-type=&quot;png&quot; data-w=&quot;1023&quot; data-backw=&quot;578&quot; data-backh=&quot;240&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PW0wIHxgg3lcYIbxWw19Z0lTlaCgjaqn6YryQHLFhOEesvjNcEZiclDicaX6LUBjqv1fw2h2pdXMhfkDkFJjribFg/640?wx_fmt=png&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Flume、Logstash和FileBeat的技术选型如图2所示。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;357&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;232&quot; data-ratio=&quot;0.7052896725440806&quot; data-type=&quot;png&quot; data-w=&quot;794&quot; data-backw=&quot;357&quot; data-backh=&quot;252&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PW0wIHxgg3nPJpjtezpjPicR4yfx7ARx63uGZToJNQrgIqqhkkKoEYsMIibiceSVdRfAXe8MYj0MzOvOLBQpv1diaQ/640?wx_fmt=png&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Sqoop和Datax之间的技术选型如图3所示。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img data-ratio=&quot;1&quot; data-type=&quot;gif&quot; data-w=&quot;1&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PW0wIHxgg3lcYIbxWw19Z0lTlaCgjaqnFCSZy1z2yZ9r5zrqLP9FXKQQsJG3Ihq7ohboUWIlibu7SrEdAzqn1Tw/640?wx_fmt=jpeg&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot;/&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;364&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;213&quot; data-ratio=&quot;0.66015625&quot; data-type=&quot;png&quot; data-w=&quot;768&quot; data-backw=&quot;364&quot; data-backh=&quot;240&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PW0wIHxgg3nPJpjtezpjPicR4yfx7ARx6v0Vqc8wxibCNoHxYq41CRqFcIHvMugfEWXNUwRgCJQWFLkzjyJMF8EA/640?wx_fmt=png&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Cannal和Maxwell之间的技术选型如图4所示。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;356&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;210&quot; data-ratio=&quot;0.6729222520107239&quot; data-type=&quot;png&quot; data-w=&quot;746&quot; data-backw=&quot;354&quot; data-backh=&quot;238&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PW0wIHxgg3nPJpjtezpjPicR4yfx7ARx6MY1tfEued4icp1LQE1JxWiaicQdG9uib5S2Uq0lfjkxgQ5b4FbjYbObr5g/640?wx_fmt=png&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot;/&gt;&lt;/p&gt;&lt;h2/&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-id=&quot;98856&quot; data-tools=&quot;135编辑器&quot;&gt;&lt;section&gt;&lt;section hm_fix=&quot;270:746&quot;&gt;&lt;section data-original-title=&quot;&quot; title=&quot;&quot; data-num=&quot;2&quot;&gt;2&lt;/section&gt;&lt;section data-width=&quot;15%&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-brushtype=&quot;text&quot;&gt;&lt;span&gt;&lt;strong&gt;数据存储技术框架&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;h2&gt;&lt;span&gt;数据的快速增长推动了技术的发展，涌现出了一批优秀的、支持分布式的存储系统。&lt;/span&gt;&lt;br/&gt;&lt;/h2&gt;&lt;p&gt;&lt;span&gt;数据存储技术框架包括HDFS、HBase、Kudu、Kafka等。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;86005&quot;&gt;&lt;section data-autoskip=&quot;1&quot; data-role=&quot;list&quot;&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;HDFS&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;它可以解决海量数据存储的问题，但是其最大的缺点是不支持单条数据的修改操作，因为它毕竟不是数据库。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;HBase&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;是一个基于HDFS的分布式NoSQL数据库。这意味着，HBase可以利用HDFS的海量数据存储能力，并支持修改操作。但HBase并不是关系型数据库，所以它无法支持传统的SQL语法。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;Kudu&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;是介于HDFS和HBase之间的技术组件，既支持数据修改，也支持基于SQL的数据分析功能；目前Kudu的定位比较尴尬，属于一个折中的方案，在实际工作中应用有限。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;Kafka&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;常用于海量数据的临时缓冲存储，对外提供高吞吐量的读写能力。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-id=&quot;98856&quot; data-tools=&quot;135编辑器&quot;&gt;&lt;section&gt;&lt;section hm_fix=&quot;258:664&quot;&gt;&lt;section data-original-title=&quot;&quot; title=&quot;&quot; data-num=&quot;3&quot;&gt;3&lt;/section&gt;&lt;section data-width=&quot;15%&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-brushtype=&quot;text&quot;&gt;&lt;span&gt;&lt;strong&gt;分布式资源管理框架&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在传统的IT领域中，企业的服务器资源（内存、CPU等）是有限的，也是固定的。但是，服务器的应用场景却是灵活多变的。例如，今天临时上线了一个系统，需要占用几台服务器；过了几天，需要把这个系统下线，把这几台服务器清理出来。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在大数据时代到来之前，服务器资源的变更对应的是系统的上线和下线，这些变动是有限的。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;随着大数据时代的到来，临时任务的需求量大增，这些任务往往需要大量的服务器资源。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;如果此时还依赖运维人员人工对接服务器资源的变更，显然是不现实的。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;因此，分布式资源管理系统应运而生，常见的包括YARN、Kubernetes和Mesos，它们的典型应用领域如图5所示。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img data-ratio=&quot;1&quot; data-type=&quot;gif&quot; data-w=&quot;1&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PW0wIHxgg3lcYIbxWw19Z0lTlaCgjaqnFCSZy1z2yZ9r5zrqLP9FXKQQsJG3Ihq7ohboUWIlibu7SrEdAzqn1Tw/640?wx_fmt=jpeg&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot;/&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;402&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;112&quot; data-ratio=&quot;0.3933002481389578&quot; data-type=&quot;png&quot; data-w=&quot;806&quot; data-backw=&quot;402&quot; data-backh=&quot;158&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PW0wIHxgg3nPJpjtezpjPicR4yfx7ARx6zdlI6GXE0r1HEuq7SZAQmk7xrdsic13bic9KIYmKXF4Od26AKsJnwGqA/640?wx_fmt=png&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-id=&quot;98856&quot; data-tools=&quot;135编辑器&quot;&gt;&lt;section&gt;&lt;section hm_fix=&quot;245:670&quot;&gt;&lt;section data-original-title=&quot;&quot; title=&quot;&quot; data-num=&quot;4&quot;&gt;4&lt;/section&gt;&lt;section data-width=&quot;15%&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-brushtype=&quot;text&quot;&gt;&lt;span&gt;&lt;strong&gt;数据计算技术框架&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;h2&gt;&lt;span&gt;数据计算分为离线数据计算和实时数据计算。&lt;/span&gt;&lt;br/&gt;&lt;/h2&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;（1）离线数据计算&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;大数据中的离线数据计算引擎经过十几年的发展，到目前为止主要发生了3次大的变更。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;86005&quot;&gt;&lt;section data-autoskip=&quot;1&quot; data-role=&quot;list&quot;&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;MapReduce&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;可以称得上是大数据行业的第一代离线数据计算引擎，主要用于解决大规模数据集的分布式并行计算。MapReduce计算引擎的核心思想是，将计算逻辑抽象成Map和Reduce两个阶段进行处理。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;Tez计算引擎&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;在大数据技术生态圈中的存在感较弱，实际工作中很少会单独使用Tez去开发计算程序。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;Spark&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;最大的特点就是内存计算：任务执行阶段的中间结果全部被放在内存中，不需要读写磁盘，极大地提高了数据的计算性能。Spark提供了大量高阶函数（也可以称之为算子），可以实现各种复杂逻辑的迭代计算，非常适合应用在海量数据的快速且复杂计算需求中。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;（2）实时数据计算&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;业内最典型的实时数据计算场景是天猫“双十一”的数据大屏。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;数据大屏中展现的成交总金额、订单总量等数据指标，都是实时计算出来的。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;用户购买商品后，商品的金额就会被实时增加到数据大屏中的成交总金额中。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;用于实时数据计算的工具主要有以下3种。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;86005&quot;&gt;&lt;section data-autoskip=&quot;1&quot; data-role=&quot;list&quot;/&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Spark Streaming&lt;/span&gt;&lt;span&gt;和Storm、Flink之间的区别见表4。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;表4&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.23055555555555557&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot; data-backw=&quot;578&quot; data-backh=&quot;133&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PW0wIHxgg3lcYIbxWw19Z0lTlaCgjaqnk1E8LOn0GfPaAN9AbViaVGU2sqY2waH6fic5WlI8gnL4cD4g5GrrZggQ/640?wx_fmt=png&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Storm、Spark、Flink 之间的技术选型如图6所示。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img data-ratio=&quot;1&quot; data-type=&quot;gif&quot; data-w=&quot;1&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PW0wIHxgg3lcYIbxWw19Z0lTlaCgjaqnFCSZy1z2yZ9r5zrqLP9FXKQQsJG3Ihq7ohboUWIlibu7SrEdAzqn1Tw/640?wx_fmt=jpeg&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot;/&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;398&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;101&quot; data-ratio=&quot;0.35434007134363854&quot; data-type=&quot;png&quot; data-w=&quot;841&quot; data-backw=&quot;398&quot; data-backh=&quot;141&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PW0wIHxgg3nPJpjtezpjPicR4yfx7ARx6DE07erCBzl0ZTAoWoyvfvajuFsHT5QdibNq33PQjJPvQB0eoodpRjug/640?wx_fmt=png&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;目前企业中离线计算主要使用Spark，实时计算主要使用Flink。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-id=&quot;98856&quot; data-tools=&quot;135编辑器&quot;&gt;&lt;section&gt;&lt;section hm_fix=&quot;222:661&quot;&gt;&lt;section data-original-title=&quot;&quot; title=&quot;&quot; data-num=&quot;5&quot;&gt;5&lt;/section&gt;&lt;section data-width=&quot;15%&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-brushtype=&quot;text&quot;&gt;&lt;span&gt;&lt;strong&gt;数据分析技术框架&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;数据分析技术框架包括Hive、Impala、Kylin、Clickhouse、Druid、Doris等，它们的典型应用场景如图7所示。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;406&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;228&quot; data-ratio=&quot;0.6544117647058824&quot; data-type=&quot;png&quot; data-w=&quot;816&quot; data-backw=&quot;406&quot; data-backh=&quot;266&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PW0wIHxgg3nPJpjtezpjPicR4yfx7ARx6RRE5Qic6tLXASrzNF75LA02DfRRKO4clAGMNUUDSZXwLoiafWuDcWKaw/640?wx_fmt=png&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot;/&gt;&lt;img data-ratio=&quot;1&quot; data-type=&quot;gif&quot; data-w=&quot;1&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PW0wIHxgg3lcYIbxWw19Z0lTlaCgjaqnFCSZy1z2yZ9r5zrqLP9FXKQQsJG3Ihq7ohboUWIlibu7SrEdAzqn1Tw/640?wx_fmt=jpeg&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Hive、Impala和Kylin属于典型的离线OLAP数据分析引擎，主要应用在离线数据分析领域，它们之间的区别见表5。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;86005&quot;&gt;&lt;section data-autoskip=&quot;1&quot; data-role=&quot;list&quot;/&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;表5&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.16342412451361868&quot; data-type=&quot;png&quot; data-w=&quot;1028&quot; data-backw=&quot;578&quot; data-backh=&quot;94&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PW0wIHxgg3lcYIbxWw19Z0lTlaCgjaqnqQIezGPaTf0nvmCPWiaY4TdtODj0fgvicRzSmJwiahYL7DucX0rX7kLBw/640?wx_fmt=png&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Clickhouse、Druid和Doris属于典型的实时OLAP数据分析引擎，主要应用在实时数据分析领域，它们之间的区别见表6。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;86005&quot;&gt;&lt;section data-autoskip=&quot;1&quot; data-role=&quot;list&quot;/&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;表6&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.19166666666666668&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot; data-backw=&quot;578&quot; data-backh=&quot;111&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PW0wIHxgg3lcYIbxWw19Z0lTlaCgjaqnGQVnQUtiaMrApOPbAMP2xr47d5UO2rJ0LeHYBMiaq15stoibvMGuA3yibA/640?wx_fmt=png&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot;/&gt;&lt;/p&gt;&lt;h2/&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-id=&quot;98856&quot; data-tools=&quot;135编辑器&quot;&gt;&lt;section&gt;&lt;section hm_fix=&quot;231:651&quot;&gt;&lt;section data-original-title=&quot;&quot; title=&quot;&quot; data-num=&quot;6&quot;&gt;6&lt;/section&gt;&lt;section data-width=&quot;15%&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-brushtype=&quot;text&quot;&gt;&lt;span&gt;&lt;strong&gt;任务调度技术框架&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;h2&gt;&lt;span&gt;任务调度技术框架包括&lt;/span&gt;&lt;strong&gt;&lt;span&gt;Azkaban、Ooize、DolphinScheduler等&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;。&lt;/span&gt;&lt;/h2&gt;&lt;h2&gt;&lt;span&gt;它们适用于普通定时执行的例行化任务，以及包含复杂依赖关系的多级任务进行调度，支持分布式，保证调度系统的性能和稳定性，它们之间的区别见表7。&lt;/span&gt;&lt;br/&gt;&lt;/h2&gt;&lt;p&gt;&lt;span&gt;表7&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.4140625&quot; data-type=&quot;png&quot; data-w=&quot;1024&quot; data-backw=&quot;578&quot; data-backh=&quot;239&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PW0wIHxgg3lcYIbxWw19Z0lTlaCgjaqnJbs1CophuTiapiaMcLGqibWTav8nYhibKg4vRUicutxnOznK1AQjXH0647Q/640?wx_fmt=png&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;它们之前的技术选型如图8所示。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt; &lt;img class=&quot;rich_pages wxw-img&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;419&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;117&quot; data-ratio=&quot;0.3951332560834299&quot; data-type=&quot;png&quot; data-w=&quot;863&quot; data-backw=&quot;419&quot; data-backh=&quot;166&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PW0wIHxgg3nPJpjtezpjPicR4yfx7ARx6pJHKwia2ha5vDOsSLtN5wSLN4VibCGEQZfuO0WrlKHRic9n7H0opbibdxA/640?wx_fmt=png&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-id=&quot;98856&quot; data-tools=&quot;135编辑器&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section data-original-title=&quot;&quot; title=&quot;&quot; data-num=&quot;7&quot;&gt;7&lt;/section&gt;&lt;section data-width=&quot;15%&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-brushtype=&quot;text&quot; hm_fix=&quot;220:684&quot;&gt;&lt;span&gt;&lt;strong&gt;大数据底层基础技术框架&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;h2&gt;&lt;span&gt;大数据底层基础技术框架主要是指&lt;/span&gt;&lt;strong&gt;&lt;span&gt;Zookeeper&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;。&lt;/span&gt;&lt;/h2&gt;&lt;h2&gt;&lt;span&gt;Zookeepe主要提供常用的基础功能（例如：命名空间、配置服务等），大数据生态圈中的Hadoop（HA）、HBase、Kafka等技术组件的运行都会用到Zookeeper。&lt;/span&gt;&lt;br/&gt;&lt;/h2&gt;&lt;h2/&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-id=&quot;98856&quot; data-tools=&quot;135编辑器&quot;&gt;&lt;section&gt;&lt;section hm_fix=&quot;173:675&quot;&gt;&lt;section data-original-title=&quot;&quot; title=&quot;&quot; data-num=&quot;8&quot;&gt;8&lt;/section&gt;&lt;section data-width=&quot;15%&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-brushtype=&quot;text&quot;&gt;&lt;span&gt;&lt;strong&gt;数据检索技术框架&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;h2&gt;&lt;span&gt;随着企业中数据的逐步积累，针对海量数据的统计分析需求会变得越来越多样化：不仅要进行分析，还要实现多条件快速复杂查询。例如，电商网站中的商品搜索功能，以及各种搜索引擎中的信息检索功能，这些功能都属于多条件快速复杂查询的范畴。&lt;/span&gt;&lt;br/&gt;&lt;/h2&gt;&lt;p&gt;&lt;span&gt;在选择全文检索引擎工具时，可以从易用性、扩展性、稳定性、集群运维难度、项目集成程度、社区活跃度这几个方面进行对比。Lucene、Solr和Elasticsearch的对比见表8。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;表8&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.2667964946445959&quot; data-type=&quot;png&quot; data-w=&quot;1027&quot; data-backw=&quot;578&quot; data-backh=&quot;154&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PW0wIHxgg3lcYIbxWw19Z0lTlaCgjaqnE9tCQxsG6lNNOIL6D0pLrC1oaqzyV8G96C25MYibrduIzpfdj6qyK4g/640?wx_fmt=png&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot;/&gt;&lt;/p&gt;&lt;h2/&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-id=&quot;98856&quot; data-tools=&quot;135编辑器&quot;&gt;&lt;section&gt;&lt;section hm_fix=&quot;227:671&quot;&gt;&lt;section data-original-title=&quot;&quot; title=&quot;&quot; data-num=&quot;9&quot;&gt;9&lt;/section&gt;&lt;section data-width=&quot;15%&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-brushtype=&quot;text&quot;&gt;&lt;span&gt;&lt;strong&gt;大数据集群安装管理框架&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;h2&gt;&lt;span&gt;企业如果想从传统的数据处理转型到大数据处理，首先要做就是搭建一个稳定可靠的大数据平台。&lt;/span&gt;&lt;br/&gt;&lt;/h2&gt;&lt;p&gt;&lt;span&gt;一个完整的大数据平台需要包含数据采集、数据存储、数据计算、数据分析、集群监控等功能，这就意味着其中需要包含Flume、Kafka、HaDoop、Hive、HBase、Spark、Flink等组件，这些组件需要部署到上百台甚至上千台机器中。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;如果依靠运维人员单独安装每一个组件，则工作量比较大，而且需要考虑版本之间的匹配问题及各种冲突问题，并且后期集群维护工作也会给运维人员造成很大的压力。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;于是，国外一些厂商就对大数据中的组件进行了封装，提供了一体化的大数据平台，利用它可以快速安装大数据组件。目前业内最常见的是包括CDH、HDP、CDP等。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;86005&quot;&gt;&lt;section data-autoskip=&quot;1&quot; data-role=&quot;list&quot;&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;HDP：&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;全称是 Hortonworks Data Platform。它由 Hortonworks 公司基于 Apache Hadoop 进行了封装，借助于 Ambari 工具提供界面化安装和管理，并且集成了大数据中的常见组件， 可以提供一站式集群管理。HDP 属于开源版免费大数据平台，没有提供商业化服务；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;CDH：&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;全称是 Cloudera Distribution Including Apache Hadoop。它由 Cloudera 公司基于 Apache Hadoop 进行了商业化，借助于 Cloudera Manager 工具提供界面化安装和管理，并且集成了大数据中的常见组件，可以提供一站式集群管理。CDH 属于商业化收费大 数据平台，默认可以试用 30 天。之后，如果想继续使用高级功能及商业化服务，则需要付费购买授权，如果只使用基础功能，则可以继续免费使用；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;CDP：&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;Cloudera 公司在 2018 年 10 月份收购了 Hortonworks，之后推出了新一代的大数据平台产品 CDP（Cloudera Data Center）。CDP 的版本号延续了之前 CDH 的版本号。从 7.0 版本开始， CDP 支持 Private Cloud（私有云）和 Hybrid Cloud（混合云）。CDP 将 HDP 和 CDH 中比较优秀的组件进行了整合，并且增加了一些新的组件。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;三者的关系如图9所示。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;562&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;150&quot; data-ratio=&quot;0.4074074074074074&quot; data-type=&quot;png&quot; data-w=&quot;918&quot; data-backw=&quot;562&quot; data-backh=&quot;229&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PW0wIHxgg3nPJpjtezpjPicR4yfx7ARx6jfzkLgZnnicCtibjlHXlh8G0mvfFWGicMXCH4oSH3LDesFUFqUeVsty4w/640?wx_fmt=png&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;7&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;p data-autoskip=&quot;1&quot; hm_fix=&quot;310:479&quot;&gt;以上内容出自于《大数据技术及架构图解实战派》一书，欢迎阅读此书了解更多相关内容！&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1.8533333333333333&quot; data-type=&quot;jpeg&quot; data-w=&quot;750&quot; data-backw=&quot;578&quot; data-backh=&quot;1071&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/PW0wIHxgg3lcYIbxWw19Z0lTlaCgjaqnAITwE7ON3WBib2lqbRoPxqvgicqOxaGDEUpZbzE0JNticds6dj0hy1hVw/640?wx_fmt=jpeg&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;2446&quot; data-backw=&quot;460&quot; data-ratio=&quot;5.317391304347826&quot; data-type=&quot;png&quot; data-w=&quot;460&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PW0wIHxgg3lcYIbxWw19Z0lTlaCgjaqn4o2gR4W8mGOVc2YqLTyexzvVK87vbr7lS8NHoTiafGfjJ2fLqicvJpWg/640?wx_fmt=png&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot;/&gt;&lt;/p&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1&quot; data-type=&quot;png&quot; data-w=&quot;300&quot; data-width=&quot;155px&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PW0wIHxgg3lcYIbxWw19Z0lTlaCgjaqnUB3ciagotcysgpIxZq8uMReOXx9XHvUGnNWPD6Zceviaic0U6icg0iaXCUg/640?wx_fmt=png&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;粉丝专享六折购书码，快快扫码抢购吧！&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;mpcps class=&quot;js_editor_new_cps&quot; data-traceid=&quot;575b8c6b-c343-456f-a1da-14fc844368d4&quot; data-goodssouce=&quot;1&quot; data-pid=&quot;101_10056709578969&quot; data-appuin=&quot;3075341621&quot; data-buffer=&quot;{&amp;quot;category_id&amp;quot;:10,&amp;quot;pid&amp;quot;:&amp;quot;101_10056709578969&amp;quot;,&amp;quot;biz_uin&amp;quot;:&amp;quot;3075341621&amp;quot;,&amp;quot;trace_id&amp;quot;:&amp;quot;575b8c6b-c343-456f-a1da-14fc844368d4&amp;quot;,&amp;quot;sku_id&amp;quot;:&amp;quot;101_10056709578969&amp;quot;,&amp;quot;source_id&amp;quot;:2,&amp;quot;source_name&amp;quot;:&amp;quot;京东&amp;quot;,&amp;quot;audit_state&amp;quot;:1,&amp;quot;main_img&amp;quot;:&amp;quot;https://img.zhls.qq.com/3/8cae711c1834414aa80a09af0b1d990e.jpg&amp;quot;,&amp;quot;product_name&amp;quot;:&amp;quot;大数据技术及架构图解实战派 徐葳 体系完整 从零起步 丰富实战案例 衔接运维 覆盖大数据生态圈完整技术体系 电子工业出版社&amp;quot;,&amp;quot;current_price&amp;quot;:8800,&amp;quot;first_category_id&amp;quot;:&amp;quot;10&amp;quot;,&amp;quot;appuin&amp;quot;:&amp;quot;3075341621&amp;quot;,&amp;quot;isNewCpsKOL&amp;quot;:1}&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-croporisrc=&quot;https://mmbiz.qpic.cn/mmbiz_png/PW0wIHxgg3ntPMYAJur3UuYzhSDgO7Puv74VHDtgNjyJbpQvt1gicgSpjrlpDy6BheYoAmtjiaF7cdIuPkuUlFkw/0?wx_fmt=png&quot; data-cropx1=&quot;0&quot; data-cropx2=&quot;1920&quot; data-cropy1=&quot;0&quot; data-cropy2=&quot;29.8961937716263&quot; data-fileid=&quot;503655759&quot; data-ratio=&quot;0.01574074074074074&quot; data-s=&quot;300,640&quot; data-type=&quot;jpeg&quot; data-w=&quot;1080&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/PW0wIHxgg3ntPMYAJur3UuYzhSDgO7Pu8DQL5f0FQIuDZC87yrAuNLy4frEdlMeWkthrlzczb0RbMOBQCAwDrA/640?wx_fmt=jpeg&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot;/&gt;&lt;span&gt; &lt;/span&gt;&lt;/section&gt;&lt;section class=&quot;mp_profile_iframe_wrp&quot;&gt;&lt;mp-common-profile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mpprofile&quot; data-id=&quot;MzA3NTM0MTYyMQ==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/7iaMpruNx3Afic1pUJiat0zez4aPTUCyHDAs7PzvDuIO6GRh5jhGImRAicoUsg240UM4w7zooIKAiaqwnAiaU2BMNl0Q/0?wx_fmt=png&quot; data-nickname=&quot;志明与数据&quot; data-alias=&quot;zhiming_data&quot; data-signature=&quot;专注于数据管理、数据治理、项目管理、大数据等相关领域的知识内容、实践经验、心得感悟分享。&quot; data-from=&quot;0&quot;/&gt;&lt;/section&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;赠书规则&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;评论区走心留言&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;1&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;名+获赞数(&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;28+&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;)第&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;1&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;名&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;strong&gt;&lt;span/&gt;&lt;/strong&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;截止&lt;/span&gt;&lt;/strong&gt;&lt;strong&gt;&lt;span&gt;时间&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;2022年08月28日周日晚22点&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;欢迎转发分享到你的&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;数据圈&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1&quot; data-type=&quot;png&quot; data-w=&quot;20&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/7iaMpruNx3Af5F8mdTheAvIIM9ftyBDVMSOnias7b1QyR3JpT6EicOPWLB0lp5fbXwxTma580ibzbJljhUzJ4UnqZA/640?wx_fmt=png&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot;/&gt;&lt;/section&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;关注志明 | 新书不断 | 好书不停&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;/pre&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;325&quot; data-backw=&quot;578&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.562037037037037&quot; data-s=&quot;300,640&quot; data-type=&quot;jpeg&quot; data-w=&quot;1080&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/7iaMpruNx3AfEoklpib3AX98zT5icTZvhAVic9xvcDrE4EGtHNlWdAyRc4rqLcxrRuVyefpRpakRPuIgQXeOfHRCZQ/640?wx_fmt=jpeg&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;新到实物书，随机翻开看，感觉还不错。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;/div&gt;

          

          
          &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>1667b5ea5d879639341656e1a920c1a0</guid>
<title>尤雨溪解读 2022 Web 前端生态趋势</title>
<link>https://toutiao.io/k/kublb5y</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;尤大大从下面的三个前端领域的不同层次来展开了介绍：&lt;/strong&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;开发范式&amp;amp;底层框架（注：大家比较熟悉的Vue、React这些框架层面）&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;工具链（注：像webpack这样的构建工具）&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;上层框架（注：例如Next.js、Nuxt.js）&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;section&gt;正式分享之前，尤大大提出声明：“本分享只代表讲着个人观点，因为自己是框架和构建工具的作者，肯定会包含利益相关和个人的偏见，但是分享中会尽可能做客观的看法，大家多多多包涵”，下面就让我们饱享这顿“美味”吧！&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;下面的内容是根据尤大大的分享进行了一定的抽离和少许的个人总结，如果内容出现歧义可以在评论区留言！&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;开发范式&amp;amp;底层框架方面趋势&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;过去几年中影响最大的开发范式层面的变化肯定就是我们的 &lt;code&gt;React Hooks&lt;/code&gt; 随着他的推出可以说是启发了很多组件逻辑表达和逻辑复用的新范式，在 &lt;code&gt;React&lt;/code&gt; 生态中彻底取代了 &lt;code&gt;Class Components&lt;/code&gt; ，包括现在其实很少能够在 &lt;code&gt;React&lt;/code&gt; 中看到 &lt;code&gt;Class Components&lt;/code&gt; 了，&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;不仅如此，其实在其他的框架中 &lt;code&gt;React Hooks&lt;/code&gt; 也产生了很大的影响，比如说我们 &lt;code&gt;Vue&lt;/code&gt; 推出的 &lt;code&gt;Vue Composition API&lt;/code&gt; 组合式API，还包括受到 &lt;code&gt;React Hooks&lt;/code&gt; 的启发的 &lt;code&gt;Svelte3&lt;/code&gt; ，更有 &lt;code&gt;SolidJS&lt;/code&gt; 他是语法上相似于 &lt;code&gt;React Hooks&lt;/code&gt; 实现上更相似于 &lt;code&gt;Vue Composition API&lt;/code&gt; 。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.4015625&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz/H8M5QJDxMHr1Cgjk13Johy76vQPPe18gq5rxbHKofP3VpvKJqL6D5yQjTG6MWo8LRrP6JtHHKJr8sLX33Xrqag/640?wx_fmt=jpeg&quot; data-w=&quot;640&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;随着 React Hooks 的推广和开发者对其的广泛使用，他开发中的一些体验问题也逐渐被正视，这里不可回避的一些体验问题的根本原因有以下几点：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;Hooks&lt;/code&gt; 执行原理和原生JS的心智模型的差异：因为 &lt;code&gt;React Hooks&lt;/code&gt; 是通过把组件的代码每一次更新都进行重复调用来模拟一些行为，从而导致反直觉的一些限制；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;不可以条件式的调用 &lt;code&gt;React force&lt;/code&gt; ；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;Stale Closure&lt;/code&gt; 的心智负担：如果你不传正确的依赖数组，那么就会产生过期闭包；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;必须手动声明 &lt;code&gt;use Effect&lt;/code&gt; 依赖；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;如何‘正确’使用 &lt;code&gt;use Effect&lt;/code&gt; 是个复杂的问题；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;需要 &lt;code&gt;useMemo/useCallback&lt;/code&gt; 等手动优化，否则的话就会不知不觉的导致一些性能问题；&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;尤大大表示作为竞争框架的作者，对 React Hooks 框架的看法可能相对更直接一些，但这些也并非尤大大一个人的看法，而是近年来 React 社区和 React 团队也已经意识到的问题，当然 React 团队针对这些问题也在做改善的努力，据代表性的改善从下三个方面：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.3359375&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz/H8M5QJDxMHr1Cgjk13Johy76vQPPe18g6KibhXGLu2j77cK28PCcCM0icZwDSmfjLClgtq0mvvOg33AicaQOtLOBA/640?wx_fmt=jpeg&quot; data-w=&quot;640&quot;/&gt;&lt;/figure&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;基于依赖追踪范式&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在上面的这些改进之前，其实很多 React 的社区成员也包括一些本身就不适用 React 的用户来说，虽然 React Hooks 产生了重大的影响但是大家也意识到了他的一些问题，反而是一些跟 React Hooks 相似的一些逻辑组合能力，另一方面基于依赖追踪的范式开始重新得到了重视；比如在 React 内部的 Recoil ，当然在社区之外就有更多了比如：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.2890625&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz/H8M5QJDxMHr1Cgjk13Johy76vQPPe18gS0KhdlGrqPCqawK1X0pGhXZLOrlOkXeeR5cia7FMzahva4c6r9JLFUA/640?wx_fmt=jpeg&quot; data-w=&quot;640&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们可以看一下就基于依赖追踪的范式而言上面三个方案的代码：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;SolidJS&lt;/strong&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;//状态&lt;br/&gt;const [count,setCount] = createSignal(0)&lt;br/&gt;//副作用&lt;br/&gt;createEffect(() =&amp;gt; console.log(`&lt;span&gt;${count()`}&lt;/span&gt;&lt;br/&gt;//状态更新&lt;br/&gt;setCount(count() + 1)&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;能够看出其实 SolidJS 和 React Hooks 非常相似&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;副作用中的 createEffect 跟 React 中的 use Effect 其实是类似的，但是 createEffect 并不需要去声明依赖，在调用 count 函数的时候其实帮你收集了依赖；&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;状态更新的时候我们也并不需要用到 useCallback 这种额外的方式去创造函数来去传递给我们的事件侦听器；这些都是非常符合直觉的；&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;Vue Composition API&lt;/strong&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;//状态&lt;br/&gt;const count = ref(0)&lt;br/&gt;//副作用&lt;br/&gt;watchEffect(() =&amp;gt; console.log(count.value))&lt;br/&gt;//状态更新&lt;br/&gt;count.value++&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其实 &lt;code&gt;Vue&lt;/code&gt; 中使用的 &lt;code&gt;Composition API&lt;/code&gt; 跟 &lt;code&gt;SolidJS&lt;/code&gt; 本质上的内部实现几乎是一样的，只不过 &lt;code&gt;SolidJS&lt;/code&gt; 看起来更像是 &lt;code&gt;React&lt;/code&gt; ，而 &lt;code&gt;Vue&lt;/code&gt; 是通过一个 ref 对象，对象上的 value 机可以读也可以写，在读和写之中就会自动的追踪和更新依赖。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;Ember Starbeam&lt;/strong&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;//状态&lt;br/&gt;const count = Cell(0)&lt;br/&gt;//副作用&lt;br/&gt;DEBUG_RENDERER.render({render: () =&amp;gt; console.log(count.current)})&lt;br/&gt;//状态更新&lt;br/&gt;count.set(prev =&amp;gt; prev + 1)&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;Ember Starbeam&lt;/code&gt; 中的这个 &lt;code&gt;Cell&lt;/code&gt; 其实就和 &lt;code&gt;Vue&lt;/code&gt; 中的 &lt;code&gt;ref&lt;/code&gt; api 几乎是一样的，暴露出 &lt;code&gt;count&lt;/code&gt; 为当前的值和 &lt;code&gt;set&lt;/code&gt; 方法来进行状态的更新&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;基于依赖追踪范式—共同点&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上面提到的三种基于依赖追踪的范式他们的共同点有什么呢？&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.346875&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz/H8M5QJDxMHr1Cgjk13Johy76vQPPe18gv2YM3IIfibR2uWkTfX0FZcMnrsNqofPe6uWkS7UjvmHKDTp1Ll6KiaqA/640?wx_fmt=jpeg&quot; data-w=&quot;640&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;同时以依赖追踪为一等功名概念的框架中，本身组件的设计肯定也是跟依赖追踪有紧密的结合，所以组件的更新渲染也会有自动的依赖追踪，也就是说组件的更新会更精确，而不再依赖于一个状态从父组件到子组件一层层传递下去，而是每一个即使是深层嵌套的组件也可以自发的更新，整体上的性能会更好。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在 &lt;code&gt;react&lt;/code&gt; 生态中的 &lt;code&gt;Recoil&lt;/code&gt; 这样的方案，虽然也提供了依赖自动的依赖追踪和一定程度的逐渐的更新优化，但是因为他们仍然是需要在 &lt;code&gt;React Hooks&lt;/code&gt; 的这个大的体系中使用的，所以在很多其他的方面依然会受制于 &lt;code&gt;hooks&lt;/code&gt; 的问题，那么 &lt;code&gt;Hooks&lt;/code&gt; 本身在这些方案之外，还是会存在过期闭包等等 user fact 这些问题。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;React Hooks&lt;/code&gt; 确实是启发了一个新范式的时代，但是慢慢的我们也发现他自己自身存在的一些问题，当然 &lt;code&gt;React&lt;/code&gt; 团队正在试图解决这些问题，同时在 &lt;code&gt;React&lt;/code&gt; 体系之外，开始有一些其他的具有同等的逻辑组合能力，但同时避免了 &lt;code&gt;React Hooks&lt;/code&gt; 这些问题的这些方案存在，也渐渐的收到了前端社区的重视。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;基于编译的响应式系统&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.3046875&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz/H8M5QJDxMHr1Cgjk13Johy76vQPPe18gMvZeXMKwWAeaA2ia76ECCDLibVB5FIsW5Bb0UYpIzuWCndB4ibh8qhnNw/640?wx_fmt=jpeg&quot; data-w=&quot;640&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;不过即使是基于依赖追踪的方案，我们也可以进行一些基于编译时的这个优化，那这里首当其冲的就是 &lt;code&gt;Svelte3&lt;/code&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;Svelte&lt;/strong&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.453125&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz/H8M5QJDxMHr1Cgjk13Johy76vQPPe18gfHaiaSkvHEtAXwPPVtxlrJ67g2ZSE98NTgYRDRCia0ib1YBThnfGHONuw/640?wx_fmt=jpeg&quot; data-w=&quot;640&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;Svelte3&lt;/code&gt; 从一开始就是一个编译时优化方案，上面就是 &lt;code&gt;Svelte&lt;/code&gt; 组件中的一个使用状态的代码，我们看到他跟他的状态就是这个 &lt;code&gt;javaScript&lt;/code&gt; 的这个 &lt;code&gt;let&lt;/code&gt; 这样声明一个变量，就是一个响应式的状态，那么你要更新这个状态就直接去操作这个变量就可以，&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;副作用是用一个神奇的编译式的魔法，也就是这个 &lt;code&gt;$&lt;/code&gt; ，&lt;span&gt;这个 &lt;/span&gt;&lt;code&gt;$&lt;/code&gt;&lt;span&gt; 的一个label，这其实是 &lt;/span&gt;&lt;code&gt;javaScript&lt;/code&gt;&lt;span&gt; 的一个label语法来声明， &lt;/span&gt;&lt;code&gt;$&lt;/code&gt;&lt;span&gt; 之后的这个语句会自动去追踪&lt;/span&gt;&lt;code&gt;count&lt;/code&gt;&lt;span&gt;这个变量的变化，当&lt;/span&gt;&lt;code&gt;count&lt;/code&gt;&lt;span&gt;变化的时候，这个语句就会自动重新执行，那么我们可以看到这个跟我们之前的这个几个代码范例，他所达成的目标其实是一致的，只是他使用编译的手段使代码变的更加简洁，但也正是因为简洁所以存在下面的限制：&lt;/span&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.35&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz/H8M5QJDxMHr1Cgjk13Johy76vQPPe18gnnMvLyWLIkrAcwibRWia7g0QrwVYQ36vebYpONZ36ZBOgAicOSu2fHUWg/640?wx_fmt=jpeg&quot; data-w=&quot;640&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;Vue Reactivity Transform&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;也正是受到上方的限制的启发，Vue 在3.2的时候引入了一个实现性的功能 &lt;code&gt;Vue Reactivity Transform&lt;/code&gt; 响应式转换 ，下面就是 Vue 转化后的一段代码：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.45625&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz/H8M5QJDxMHr1Cgjk13Johy76vQPPe18gIfwYbJy3rqtB8SZEJD3w2c4YYLye4OSiage6KeW4pibA4Vr84cBRIytA/640?wx_fmt=jpeg&quot; data-w=&quot;640&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;还是一个简单的变量声明，但是我们用一个 $ref 这样的一个函数，这个函数其实是一个编译时的一个宏的概念，这个函数并不是真实存在的，只是给编译一个提示，那编译器通过编译之后就会把它转化成我们之前看到的基于真实的 ref 的代码。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但是在使用时候，体验就变成了只是声明一个函数，然后使用这个变量和更新这个变量就跟使用一个普通 &lt;code&gt;javaScript&lt;/code&gt; 变量没有区别。同时这个语法因为在声明的时候会显式的声明，说哪个变量是响应声，哪个变量不是响应式。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以这个语法可以在嵌套的函数中使用，也可以在 TS/JS 文件中使用，他并不限制于 Vue 文件，所以这是一个更加朴实的编译响应式模型。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;Solid -labels&lt;/strong&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.4421875&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz/H8M5QJDxMHr1Cgjk13Johy76vQPPe18gESWtnqvT1mic4PJ1Kooj8XiaBXEucgW2JncTQCzKuHaJSFVIGl6x2Ezw/640?wx_fmt=jpeg&quot; data-w=&quot;640&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在 &lt;code&gt;Solid&lt;/code&gt; 的生态中，其实也受启发于 &lt;code&gt;Vue Reactivity Transform&lt;/code&gt; ，他的社区用户做的一个 &lt;code&gt;Solid-label&lt;/code&gt;，也是基于 &lt;code&gt;Solid&lt;/code&gt; 的响应式方案，然后再做一层编译式的优化，那么可以看到跟 &lt;code&gt;Reactivity Transform&lt;/code&gt; 能够达成的效果是非常相似的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那最终的目的就是让大家可以用更简洁的代码去表达组件逻辑，同时又不放弃这个逻辑组合，像 &lt;code&gt;React Hooks&lt;/code&gt; 那样进行自由的逻辑组合的这些能力啊。所以说这也是一个很有意思的探索方向。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;统一模型的优势和代价&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.35&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz/H8M5QJDxMHr1Cgjk13Johy76vQPPe18gdhibliclic7ibdVhUv4iavmlMId5Tu0EG9lJNiaXGBNcvicEhickib0RKg5uu3w/640?wx_fmt=jpeg&quot; data-w=&quot;640&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;优势：&lt;/strong&gt; 和&lt;code&gt;Svelte&lt;/code&gt;相比，Vue的 &lt;code&gt;Reactivity Transform&lt;/code&gt; 和 &lt;code&gt;Solid \-labels&lt;/code&gt; 都属于统一模型，也就是他不受限于组件上下文，它可以在组建内使用，也可以在组建外使用，优势就是有利于长期的重构和复用，因为很多时候我们的大型项目中的逻辑复用都是在我们一个组件写着写着发现这个组件变得很臃肿，很大的时候我们才开始考虑要把逻辑开始重新组织抽取复用，那么由于 &lt;code&gt;Svelte&lt;/code&gt; 的语法只能在组件内使用，就使得把逻辑挪到组件外成为一个代价相当大的一个行为，并不是一个简单把文把这个逻辑拷贝复制出去，而是需要进行一次彻底的重构，&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;因为组件外用的是完全一套不同的系统，但是像用 &lt;code&gt;Reactivity Transform&lt;/code&gt; 和 &lt;code&gt;Solid \-labels&lt;/code&gt; 这样的方案呢，我们就可以把组件内的这些逻辑原封不动的直接拷贝到组件外，然后把它包在一个函数里面，抽取就完成了，那么这样重构时的这个代价就非常小，也就更鼓励团队的这样的优化，对于长期的维护性更有帮助。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;代价：&lt;/strong&gt; 因为我们需要显示的去声明响应式的变量，所以它会有一定程度的底层实现的抽象泄露，也就是说，用户其实是需要先了解底层的响应式模型的实现，然后才能更好地理解这个语法糖是如何运作的，而不像 &lt;code&gt;Svelte&lt;/code&gt; 组建中的这个语法，即使你完全不了解他底层如何运作的也可以，几乎可以零成本的上手，这就是一个长期的可维护性和一个初期的上手成本之间的一个平衡和取舍。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;基于编译的运行是优化&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.340625&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz/H8M5QJDxMHr1Cgjk13Johy76vQPPe18g5jnlUKJzfoCic2JW9xJE04icm06yYU0TQzVLTOZOiaZ54sFUJfTHxxvmg/640?wx_fmt=jpeg&quot; data-w=&quot;640&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;讲完了状态管理，我们在还可以聊一聊关于基于编译的运行时优化，编译的运行时优化又是三个主要的代表，如上图所示，那首先我们可以看一下不同的这个策略：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.4&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz/H8M5QJDxMHr1Cgjk13Johy76vQPPe18guZBqmq53DSdTg14tubvGUicUiaGp0wBiaZqvwpQOTTLFy2vL9hPLicGT3A/640?wx_fmt=jpeg&quot; data-w=&quot;640&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;Svelte&lt;/code&gt; 的这个代码生成策略相对更更繁琐一些，而 &lt;code&gt;Solid&lt;/code&gt; 是基于先生成一个基本的HTML字符串，然后在里面找到对应的 &lt;code&gt;DOM&lt;/code&gt; 节点进行绑定，而 &lt;code&gt;Svelte&lt;/code&gt; 是通过生成一这个命令式的一个一个节点，然后把节点拼接的这些 &lt;code&gt;javaScript&lt;/code&gt; 代码，但这个策略就导致掉同等的这个组件源码之下 &lt;code&gt;Svelte&lt;/code&gt; 的每个组件的编译输出会更臃肿，所以虽然大家感觉 &lt;code&gt;Svelte&lt;/code&gt; 是以轻量出名的，&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但其实我们会发现在相对大型的项目中，在项目中组建超过15个之后，&lt;code&gt;Svelte&lt;/code&gt; 的整体的打包体积优势就已经几乎不存在了，那么当组建超过50个，甚至是达到100个的时候，所有的体积会越来越越来越臃肿。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;而相对于而言，我们可以看到 &lt;code&gt;Vue&lt;/code&gt; 和 &lt;code&gt;Solid&lt;/code&gt; 的编译这个输出啊，整体的这个曲线就平缓很多，所以其实在越大型的项目中。反而是 &lt;code&gt;Svelte&lt;/code&gt; 的体积优势反而是一个劣势，据我所知，&lt;code&gt;Svelte&lt;/code&gt; 团队也有在想要优化这一方面的，可能会在下一个大版本中才能实现，那么我们也会拭目以待。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;同时尤大大提出 &lt;code&gt;Solid&lt;/code&gt; 的编译性能确实是非常的猛，其实在我们的 Vue 引入了很多编译时的优化以后我们的性能已经比 &lt;code&gt;Svelte&lt;/code&gt; 好了，但是离 &lt;code&gt;Solid&lt;/code&gt; 还是有一定的距离。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;Vue Vapor Mode（input）&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;就上面提及到的编译时性能优化，其实我们的 Vue 在早期的时候也做了这方面的探索，如还在试验中的一个项目 &lt;code&gt;Vue Vapor Mode&lt;/code&gt; 。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.45&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz/H8M5QJDxMHr1Cgjk13Johy76vQPPe18g73DAAicz73Ixp8fVvmFhEGRt69exou9EibjzJ3sTFhlFeBc3nmBPHWMw/640?wx_fmt=jpeg&quot; data-w=&quot;640&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那同样的这个只有单文件组件输入，我们现在是通过把模板编译成虚拟&lt;code&gt;DOM&lt;/code&gt; 的一个渲染函数来进行运行时的实现。但是因为模板是一个编译源，所以我们也可以选择在另一个模式下把它编译成不同的输出，也就是一个更类似于 &lt;code&gt;Svelte&lt;/code&gt; 输出。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.446875&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz/H8M5QJDxMHr1Cgjk13Johy76vQPPe18gg6coowy7x3XhlS4HdXQNP1M8BEWfHv46YsZHuJicCa8DRrmHZjxGBUQ/640?wx_fmt=jpeg&quot; data-w=&quot;640&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里这个输出的代码只是一个示例代码。并不一定是最终的代码，也不是你需要书写的代码，它完全是一个编译器的输出啊，它的整体的思路就是一次性生成这个模板的静态结构、静态节点，然后再去生成命令式的，找到动态节点，并对把它跟状态进行响应式的绑定的这样一些代码，这个策略本质上就是 &lt;code&gt;Solid&lt;/code&gt; 所采用的策略，&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那么其实呢，这个策略可以被所有的模板引擎所使用，我们也在探索某个版本的 &lt;code&gt;Vue&lt;/code&gt; 当中会引入一个可选的这样的一个模式，把模板编译成这样的，性能更优的，运行时的这个体积也更小的一个模式，当然这不会是一个破坏性更新，因为我们的目标是可以让你渐进式的去使用这个功能。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;工具链&lt;/span&gt;&lt;/h2&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;原生语言在前端工具链中的使用&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.3765625&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz/H8M5QJDxMHr1Cgjk13Johy76vQPPe18gEKAFibmSv3O0wfbQWt4Prialobd5HEdMOiaGMds8qjBxbDykiaNYYXWcZg/640?wx_fmt=jpeg&quot; data-w=&quot;640&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;关于原生语言在前端工具链中的使用尤大大提出下面几个见解：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.36875&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz/H8M5QJDxMHr1Cgjk13Johy76vQPPe18g56icQnpFDbPhr7kJHCeibDGOiazdPb7wLcEcFCXmlEMCicL94jCAc6Gd2Q/640?wx_fmt=jpeg&quot; data-w=&quot;640&quot;/&gt;&lt;/figure&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;工具链的抽象层次&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.396875&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz/H8M5QJDxMHr1Cgjk13Johy76vQPPe18gXmSjXlWrj7I39K7QDN013rltaOYKu5RFSy6j0M3kLjzKiaQwoq8jySQ/640?wx_fmt=jpeg&quot; data-w=&quot;640&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;最早的打包工具，包括 &lt;code&gt;brow/webpack/rollup&lt;/code&gt; 他们都是专注于打包的，他们的抽象层次相对低，当你想要用这些工具去做一个真正的应用的时候，你需要使用大量第三方插件，以及大量的配置来达到一个满足你自己要求的最终的形态。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那么在这个基础上就产生了像 &lt;code&gt;Parcel/Vue-cli/CRA&lt;/code&gt; ，这样的一些所谓的脚手架，更高抽象层次的这些工具，这些工具的特点是他们的抽象层的高，也就说他们专注于应用，专注于解决一个完整的应用方案呢，它的相对而言的缺点就是它是一个比较复杂、比较庞大的一个黑盒儿。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当你需要去进行自定义的定制的时候，你就会不可避免的遇到一些问题，比如说你跟他默认的功能产生一些意见上的冲突的时候，你就会比较痛苦。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那么我们现在做的这个新项目 &lt;code&gt;Vite&lt;/code&gt; 其实可能有一些同学已经在用了，其实我们是在思考过这个抽象层次的问题之后才决定的他要走一个怎么样的路线，也就是说 &lt;code&gt;Vite&lt;/code&gt; 的 &lt;code&gt;CLI&lt;/code&gt; 它是专注于应用层次啊，它的抽象层次高，它有很多的开箱记，就是事先帮你寄配置好的功能，那么大部分的情况下，你开箱即用就可以达到跟 &lt;code&gt;Parcel/Vue-cli/CRA&lt;/code&gt; 几乎同等的这些功能啊，但是我们的&lt;code&gt;API&lt;/code&gt;层面啊，这个可能用到的同学会少一些，&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但是它的&lt;code&gt;API&lt;/code&gt;层面其实是专注于支持上层框架，我们这个抽象层次会更低一点，我们只解决一些所有的够 &lt;code&gt;meta framework&lt;/code&gt; 都必须要解决的问题，但是对于上层框架，你用什么，我们并不会做过多的限制，反而是要做的更尽可能的灵活，能够支持任何上层框架的用例，所以这也是为什么 &lt;code&gt;Vite&lt;/code&gt; 现在几乎成为了下一代的&lt;code&gt;meta framework&lt;/code&gt; 共同的一个基底层选择。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;基于 Vite 的上层框架&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.3515625&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz/H8M5QJDxMHr1Cgjk13Johy76vQPPe18gANSPEae6Sog2NtAUJFZJLNX6EsjNoiaXlKW6cBJmt4cmWHXg4tXWbCQ/640?wx_fmt=jpeg&quot; data-w=&quot;640&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们看到上面这么多的上层框架都在基于 &lt;code&gt;Vite&lt;/code&gt; 说明我们 &lt;code&gt;Vite&lt;/code&gt; 走的路线还是相对成功的。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;上层框架 Meta Frameworks&lt;/span&gt;&lt;/h2&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;JS全栈的意义是什么 ？&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果我们讲到这个 &lt;code&gt;Meta Frameworks&lt;/code&gt;，也就是最典型的例子，也就是&lt;code&gt;NextJS 、NuxtJS&lt;/code&gt;、以及现在React社区中的新秀 &lt;code&gt;Remix&lt;/code&gt; 等等，那么当我们思考这样类型的JS全栈的时候，我们做全栈的意义是什么？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那么相信在国内很多大企业的朋友都知道，因为我们可以用同一个语言去做前后的连接，我们可以做一些纯前端和纯后端都各自做不到的事情，或者说之前需要很复杂的联调才能达成的一些事情，那么JS全栈可以更好的去完成一个语言让我们可以把前后打通。那么我们能够打通什么呢？&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;数据的前后端打通&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.3109375&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz/H8M5QJDxMHr1Cgjk13Johy76vQPPe18grUczecZ66icSgR3DhpRhJO4Cj3pzzh9iav0HPIHL9uEdIsJblrjeiazAQ/640?wx_fmt=jpeg&quot; data-w=&quot;640&quot;/&gt;&lt;/figure&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;类型的前后端打通&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.321875&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz/H8M5QJDxMHr1Cgjk13Johy76vQPPe18gT5ea0ibn25XtUmLQzWd6AX74IbCXxrtdEvzhVO45e6QNzqB5fwR6r5w/640?wx_fmt=jpeg&quot; data-w=&quot;640&quot;/&gt;&lt;/figure&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;JS全栈的代价&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.3609375&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz/H8M5QJDxMHr1Cgjk13Johy76vQPPe18gQGemAI7w4ic8437zeJk4UeoS6sGiaZbOFZ2lEVGFgbBXj2HkYT4A83Qw/640?wx_fmt=jpeg&quot; data-w=&quot;640&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;一些新的全栈框架，现在在试图去改善的一些问题首先。我们现有的这些前端框架，比如说像主流的像 &lt;code&gt;React、Vue&lt;/code&gt; 我们在做了服务端渲染之后，还需要在前端要进行一次所谓的注水，也就是 &lt;code&gt;Hydrate&lt;/code&gt; 在追寻的过程中，我们要确保在客户端和前端有同样的数据，所以其实虽然我们的数据已经用于渲染HTML，&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这些数据理论上在HTML里面已经都用过了，但是我们还得再把这个数据再发送一次，一起发送到前端，让前端去进行 &lt;code&gt;Hydrate&lt;/code&gt; 这样一个过程。因为没有这个数据，我们在前端就没有办法保证 &lt;code&gt;Hydrate&lt;/code&gt; 的正确性啊。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在客户端，有些组件它可能在客户端是不，需要交互的是静态的，但是他在服务端用到了动态的这个数据，但这个组件依然会被发到服务端，它依然会可能产生这个&lt;code&gt;javascript&lt;/code&gt; 运行时的代价啊，以及缓慢的这个 &lt;code&gt;Hydrate&lt;/code&gt; 会影响页面的交互指标，也就是 time to interactive。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;有一些比较复杂的庞大的项目，他可能这个注水的过程会把页面卡顿，以至于虽然能看到页面，但是没法交互，要等个一秒钟才能交互等等，会产生这样的问题。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;社区探索的方向&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.3578125&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz/H8M5QJDxMHr1Cgjk13Johy76vQPPe18gl5eS6VXV2vCMRpicrMTGFjRBm5PepicvZkxTmwDwHSibr2Htiafsf3DvYw/640?wx_fmt=jpeg&quot; data-w=&quot;640&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;社区现在新一代的这些全栈框架都在试图解决这些问题啊，比如说像 &lt;code&gt;React&lt;/code&gt; 提出了 &lt;code&gt;server only components&lt;/code&gt; 其实从这个定义上，我们就发现他是没有一个全栈框架，围绕一个全栈框架去做，其实用户是没有办法简单地使用的一个概念，所以 &lt;code&gt;React server only components&lt;/code&gt; 其实是一个必须要全站才能做的概念，Next 当然也会去做，&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;然后，其实 Nuxt 最近也开了一个 &lt;code&gt;server only components&lt;/code&gt; 的一个提案，所以说这个已经就是说 &lt;code&gt;server only components&lt;/code&gt; 其实不仅仅是一个 &lt;code&gt;React&lt;/code&gt; 独有的概念，在很多其他的框架中，我们可能慢慢都会出现类似的这个类似的东西。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;还有一个方向就是减少注水，&lt;code&gt;hydration&lt;/code&gt; 的这个成本，那么也就是局部的注水，或者也叫 &lt;code&gt;island architecture&lt;/code&gt; 就像大海中一个小岛，只有这些小岛去对他进行注水，让他交可交互啊。那么比较代表性的就是 &lt;code&gt;astro、isles&lt;/code&gt; 和生态里面的 &lt;code&gt;fresh&lt;/code&gt; 这些框架。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;然后呢，还有一个探索方向，就是所谓的 &lt;code&gt;fine-grained+resumabl hydration&lt;/code&gt;，就是细粒度懒加载，这个数据其实是&lt;code&gt;Qwik&lt;/code&gt;这个框架所发明的，&lt;code&gt;Quick&lt;/code&gt; 的作者就是 &lt;code&gt;Misko Hevery&lt;/code&gt;，也就是 &lt;code&gt;Angular&lt;/code&gt; 的原作者，离开Google之后，现在新开发的这个框架啊，那么 &lt;code&gt;Qwik&lt;/code&gt; 它主打的就是说它的特点就是不需要再把数据重新发送一遍。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;他是直接在生成的渲染的html里面嵌入所需的数据从而使得客户端的js可以直接在html里面获得所要的数据，甚至是可以跳过一些需要执行的js步骤，直接跳到一个已经完成的状态上面去，这就是所谓的&lt;code&gt;resumable&lt;/code&gt; ，也是一个比较值得关注的一个方向。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;以及我们的 Vue 生态里面生态里面有一个我们的 &lt;code&gt;VitePress&lt;/code&gt;，我们其实探索的是一个在我们页面的核心内容：其实是静态的MD文件的前提下如何做高效率的 &lt;code&gt;hydration&lt;/code&gt; 那么我们做的是所谓的 &lt;code&gt;hydration&lt;/code&gt; 就是整个的外部的这个一个框架内容外包着的这一层ui是动态的，然后呢在内部静态的里继续进行局部的注水，然后这样的话，我们依然可以获得一个单页应用的体验，但又获得很好的客户端注水的性能。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;写在最后&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;到这里呢尤大大的分享就结束了，本总结的内容中如果存在争议大家可以在评论区进行留言，希望能够给大家带来一定的收获和成长！&lt;/p&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>