<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>9ae64c6a9363e32b922d1ada3e5c28fb</guid>
<title>四个步骤，教你落地稳定性保障工作</title>
<link>https://toutiao.io/k/30q3q6w</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content js_underline_content             autoTypeSetting24psection&amp;#10;            &quot; id=&quot;js_content&quot;&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.625&quot; data-s=&quot;300,640&quot; data-type=&quot;jpeg&quot; data-w=&quot;1024&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/Z6bicxIx5naKcXB6s7weLV6aCPK0jVPU2EWv8cAzu93UQTQJtkWjymmK6gUETiaxRHF193Ijxpmul0Z2c4l3G2Xw/640?wx_fmt=jpeg&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;序-好记性不如烂笔头&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;h1&gt;&lt;span/&gt;&lt;/h1&gt;&lt;section&gt;&lt;span&gt;稳定性是个啥？&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;第一次接触稳定性这个词是在加入阿里第一年的双十一KO会上。接触到限流、扩容、压测等词汇，只觉得稳定性工作是琐碎的、繁杂的、无流程性的、无明确衡量指标的、无从下手的。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;今年，我和两个小伙伴一起在稳定性保障工作中投入了大量的精力，我也从他们那里学到了不少关于稳定性保障相关知识，开始对稳定性工作有了一定的理解。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;稳定性工作也是有条理有步骤的，按照步骤一步步来，就能够轻松将稳定性保障工作做全、做对、做好。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;所谓好记性不如烂笔头。趁机梳理记录下来，以便后续使用时能够信手拈来。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;什么是稳定性保障&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;h1&gt;&lt;span/&gt;&lt;/h1&gt;&lt;section&gt;&lt;span&gt;那么到底什么是稳定性保障呢？&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;根据前人总结，稳定性保障就是保障系统的稳定，在各种不可预知的情况发生时仍然能够持续稳定的运行和提供服务。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;个人感觉稳定性保障很像一个水利工程。在应用系统中，水可以是用户流量，也可以是资金流。而稳定性工作就是保障这些水能够按照预定的渠道路径流淌，保障没有渗水、漏水、渠道垮塌的现象，或者出现这类现象也能够及时修复将损失降到最低。&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.35509904622157007&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;1363&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Z6bicxIx5naKcXB6s7weLV6aCPK0jVPU2biaWTYVEnVDfdgL6s9yZL8azsnpeUzqqRMSGiaWQVn34tIu1UYhiaUrwQ/640?wx_fmt=png&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;稳定性保障工作做什么&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;h1&gt;&lt;span/&gt;&lt;/h1&gt;&lt;section&gt;&lt;span&gt;稳定性保障工作到底做什么？自然是实现稳定性保障目标。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;根据前文稳定性保障的定义可知“&lt;strong&gt;在各种不可预知的情况发生时仍然能够持续稳定的运行和提供服务&lt;/strong&gt;”就是稳定性保障工作的目标。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;这个目标怎么实现？还是一头雾水，无从下手。那是因为这个目标太大太虚了。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;遇到一个大而虚的目标，可以使用目标细化分而治之的方式。&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;需要如下图的红色虚线箭头所示的几个步骤。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.8867579908675799&quot; data-type=&quot;png&quot; data-w=&quot;2190&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Z6bicxIx5naKcXB6s7weLV6aCPK0jVPU2IicoMurZZzsoWYSChjBsKQteAIicOC7oicBo0DhPakSW8IPhDMHGYdUMA/640?wx_fmt=png&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;首先，将目标细分为子目标，可以通过&lt;strong&gt;抽取目标中的关键字定义子目标&lt;/strong&gt;。从“在各种不可预知的情况发生时仍然能够持续稳定的运行和提供服务”中可提取出 &lt;strong&gt;不可预知的情况、发生时、持续稳定、运行、提供服务&lt;/strong&gt;。这五个关键字就是稳定性保障工作的子目标。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;然后，针对每个子目标进行提问，凡是自己有疑问的都罗列出来。包括但不限于对目标的理解类疑问、对目标实现的方法类疑问、对目标实现的标准类疑问。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;之后，对自己所有的疑问找出答案或解决方案。就像上学期间导师给出课题，自己去理解去解决的过程。这可能需要查阅资料、现状分析、方案选择、最终决策、实际落地。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;如此，所有的子目标都将逐一实现，最终，子目标的实现进而完成终极目标的整体实现。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;综上，上图中最外层的淡蓝色圈中的内容就是我们为了实现稳定性保障目标所需要做的工作了。初看起来很多，细看下来隐有规律，再看之下发现本质就是这几点：什么现象？如何发现？什么影响？如何处理？现象、影响、处理方式都与具体异常耦合，发现靠监控告警。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;总结起来就是：&lt;strong&gt;梳理异常情况-&amp;gt;配置监控告警-&amp;gt;评估影响面-&amp;gt;预定解决方案&lt;/strong&gt;。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;接下来，将从这四个步骤入手阐述稳定性保障工作具体如何落地。大框架先展示如下图所示：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6402378592666006&quot; data-type=&quot;png&quot; data-w=&quot;2018&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Z6bicxIx5naKcXB6s7weLV6aCPK0jVPU2cnAr4dxuQoBhyuzkzd3NglMV68GsaWKr4rdbnuMuUPpAHTsSiaZsOyA/640?wx_fmt=png&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;梳理异常情况&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;h2&gt;&lt;span/&gt;&lt;/h2&gt;&lt;section&gt;&lt;span&gt;那么什么是异常情况？异常情况很多很琐碎啊，像RT飙高、消息队列阻塞、FullGC、NPE、数据异常、数据不一致、资金金额计算出错、数据库连接超时、网络异常、代码出现bug造成异常等等，这么多梳理起来如何保证覆盖率？&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;继续使用前文的目标细化分而治之的方式，但此时目标细化无法通过拆分关键字实现了，此时可以&lt;strong&gt;通过类目细化的方式定义子目标&lt;/strong&gt;。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;对异常情况进行类目细化。从上面列出的这些异常情况可进行归类梳理，可见消息队列、数据库连接、FullGC等都是中间件导致的异常，而代码bug、数据不一致、资金金额算错这类异常属于开发写出的bug或者产品设计缺陷。综上，可将中间件这类异常定义为基础设施异常，bug和产品缺陷类的异常定义为业务功能异常。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;再反向梳理一下，基础设施异常包括网络、容量、连接、磁盘、缓存、JVM等等中间件或者底层硬件设施产生的异常；这类异常日常一般不会发生，只可能发生在大而突然的流量变化时，基础设施扛不住过大的流量导致异常。因此多发生在大促期间。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;业务功能异常包括代码逻辑异常和资金异常。与业务功能息息相关，因此这类异常一般出现在每次业务逻辑的变更后，与日常需求相对应。可在每次业务需求开发的同时进行梳理，也可根据异常梳理结果在代码中预置开关和订正工具，万一上线后异常情况出现，就可使用预置开关和订正工具进行止血和修复。&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;顺便提一下，根据异常的分类，平日里大家习惯性将稳定性保障工作分为日常稳定性保障和大促稳定性保障。&lt;/span&gt;&lt;/p&gt;&lt;h2&gt;&lt;br/&gt;&lt;/h2&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;strong/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;配置监控告警&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;h2&gt;&lt;span/&gt;&lt;/h2&gt;&lt;section&gt;&lt;span&gt;监控告警分为三类，基础设施监控告警、业务功能监控告警、资金安全监控告警。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;基础设施监控告警一般都是在应用创建之初进行配置的，涵盖应用和所有的中间件、网络等。集团对基础监控告警的覆盖范围有明确规定。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;业务功能监控告警都是在日常业务功能开发时由开发人员配置的，用于监控特定的业务场景。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;资金安全监控告警主要面向与资金相关的应用，例如下单支付。如果没有就需要从0到1的创建，之后就随着每次业务功能开发进行增量式设置。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;大促前夕一般会对所有的监控告警进行梳理并查漏补缺。&lt;/span&gt;&lt;/section&gt;&lt;h3&gt;&lt;span&gt;数据流向图&lt;/span&gt;&lt;/h3&gt;&lt;section&gt;&lt;span&gt;监控告警配置其实是个省略句，其完整的表达应该是：监控告警数据源的准备、监控告警配置。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6875912408759124&quot; data-type=&quot;png&quot; data-w=&quot;1370&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Z6bicxIx5naKcXB6s7weLV6aCPK0jVPU2Zz6oA1hssvEd71dQ0nepePEYl7acDtPClZaPXdcjibCgNdicyKkfyS5g/640?wx_fmt=png&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;监控告警的整体数据流向如上图所示。主要通过日志、消息、持久化数据作为数据源，将数据收集起来后用于监控告警的配置。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;其中日志主要用于监控大盘展示，实时反应线上真是情况；消息主要用于实时核对的触发媒介，触发资金安全核对，资金安全核对通过采用旁路核对、资金一致性核对、两两核对等方式核对线上逻辑；持久化数据主要用于离线核对，通过两两核对的方式校验数据正确性。具体核对逻辑后文详述。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;最终，监控核对都将告警信息汇总到告警系统，触发告警。同步到告警响应人进行处理。&lt;/span&gt;&lt;/section&gt;&lt;h3&gt;&lt;span&gt;配置步骤&lt;/span&gt;&lt;/h3&gt;&lt;section&gt;&lt;span&gt;综上对监控告警的数据源及其流向有了了解，就可以按照以下步骤配置监控告警了：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6222760290556901&quot; data-type=&quot;png&quot; data-w=&quot;1652&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Z6bicxIx5naKcXB6s7weLV6aCPK0jVPU2UeE43lbu4nPtKrfiaiapBLkDZp4LuwFickyoxhSicAzIseLMyrEcyicVicUQ/640?wx_fmt=png&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;值得一提的是，虽然先要有数据，才能配置监控。但是其实&lt;strong&gt;数据准备和监控配置这两者应该是并行的&lt;/strong&gt;。根据监控项的大概规划准备监控数据，然后进行监控告警配置，有任何数据不满足配置的情况都要返回进行数据准备步骤。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;个人认为一个监控的好坏评判标准主要通过三个指标：正确性、覆盖率、直观性。正确性保证监控的基本功能，能够正确的反应真实情况。没有正确性的监控毫无存在意义。覆盖率是衡量一个监控系统成功与否的关键指标，覆盖率越高，监控系统就越能够完美的体现系统的实际运行情况。直观的展示监控指标有助于快速发现异常、快速定位问题。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;对于告警，个人认为告警的配置最重要的是：及时性、有效性、责任制。告警出现一般都是有异常情况，可能涉及到资损或者故障，发现越及时，止血越及时，损失就越小。告警最终都是人工处理，无效的告警会浪费人力成本，因此告警配置要注意过滤噪音，保障告警的有效性，保证报出的确实是问题。至于责任制则是强调告警必须要有人响应，每条告警最好分配到人。有响应的告警才是最终有效的。&lt;/span&gt;&lt;/section&gt;&lt;h3&gt;&lt;span&gt;资金安全核对&lt;/span&gt;&lt;/h3&gt;&lt;section&gt;&lt;span&gt;资金安全核对的本质是检查是否有资损事件的发生，做到及时报警快速止血，最终达到资损防控的目的。资金逻辑相比一般的业务逻辑存在一些共性，因此我们能够针对这些共性思考出一些通用的资金安全核对方法和资损防控措施。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;对于资金安全核对的方法论，根据前辈们的总结概括，资金安全问题主要是对资金关键要素的处理过程中出现异常导致的。资金关键要素的生命周期主要包含三个重要节点：生产、传递和消费。三个节点分别可能出现的错误为生产错误、漏传错传、消费错误。针对这些错误，前辈们提出三大核对方法，所谓核对，都是寻找有一个正确数据作为预期，将实际情况与预期数据进行对比核对。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.7189384800965019&quot; data-type=&quot;png&quot; data-w=&quot;1658&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Z6bicxIx5naKcXB6s7weLV6aCPK0jVPU2Bnicu7Vfhyr50qaodoticBmYsjFIxCG6EdvFHRdOGqia73LiaP6Zs29Z1g/640?wx_fmt=png&quot;/&gt;&lt;/section&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;基线核对是将历史数据作为预期进行对比核对，这种方式依赖历史数据的正确性，投入少，实效低，可发现大的资金问题。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;两两核对将上游作为预期，进行对比核对，精准度高，时效性高，成本比较高，难以覆盖全面。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;业务逻辑核对将业务专家的经验作为预期进行核对，需要大量人力投入，对经验的依赖度高，但是精准度高，时效性高。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;section&gt;&lt;span&gt;面对资损防控，我们可以采用哪些具体的落地措施呢？&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;我的专攻资损防控的小伙伴做了很全面的总结归纳，如下图所示，资损防控的策略包括保存量、盘增量、控高危、盯特有。资损防控是一个长期的过程，需要时常维护，对存量布控不断优化保鲜；对新增变更进行资损评估，发布前卡点确认，保证有对应的核对规则；对于易资损场景和数据进行专项重保；对大促特有逻辑或者场景进行特别关注。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.8437047756874095&quot; data-type=&quot;png&quot; data-w=&quot;1382&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Z6bicxIx5naKcXB6s7weLV6aCPK0jVPU23bsPUfHaIXsclhArI3Yzj452Rm0s8GPkK51ReV7clXYzuyGxANic9rA/640?wx_fmt=png&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;资损防控，需要对全链路资金安全风险场景进行梳理，从失血类型、规则表达、规则类型、依赖因子等多方面分析资损场景，建立相应的失血模型。为保证快速、精确，可监听异步消息来进行实时核对，同时结合特定的错误日志告警，再加上小时级离线持久化数据核对兜底来保障资金安全。对于核对脚本，可通过组织review和攻防验证保障其正确性。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;建立资损大盘，在大促高峰期值班期间安排专人盯盘，及时响应问题处理，同时对于高资损风险项预置必要的应急预案，在紧急情况发生时可以及时熔断止血以保障资金安全。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;预估影响面&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;h2&gt;&lt;span/&gt;&lt;/h2&gt;&lt;section&gt;&lt;span&gt;影响面自然也是和异常相关的。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;基础设施的异常分多种，例如程度较轻的仅仅是短期内的负载高，严重的某个中间件（例如MetaQ）不可用、机房断电，光缆被挖断。其异常的严重程度直接决定了影响面，可能错误率飙高、RT飙高、消息阻塞、FullGC频繁，影响到系统的持续稳定性，也可能系统瘫痪不可用、网络不可用、流量跌零。不过对于这种严重的异常一般不会发生。机房都是多机房部署，硬件容灾考虑有专门的团队去保障。中间件也要专门的团队运维保障。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;稳定性保障工作对于基础设施异常一般只考虑大促流量激增引起的容量不足、系统压力大等问题。这类问题的原因明确，就是流量过大。直接现象就是错误率飙高、RT飙高、消息阻塞、FullGC频繁等，较严重的情况下会引起客诉和舆情。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;业务功能异常就是错误，无论是逻辑异常还是资金计算错误，资金流转错误，本质上就是产品设计有缺、开发留下的bug或者某处配置有误。这类异常与具体的业务场景有关，小则仅影响某一个局部小功能，大则影响核心功能。可能引起客诉和舆情，资金异常可能导致资损。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;strong/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;预定解决方案&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;h2&gt;&lt;span/&gt;&lt;/h2&gt;&lt;section&gt;&lt;span&gt;前文大框架中，我们已经知道了预定的解决方案大概有限流、压测、扩容、预案等措施，那么这些解决方案具体如何落地呢？他们之间是否存在一定的顺序？&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;解决方案与异常类型强相关。不同的类型有不同的解决方案。因此解决方案也分为业务功能异常的解决方案和基础设施异常的解决方案。&lt;/span&gt;&lt;/section&gt;&lt;h3&gt;&lt;span&gt;业务异常的解决方案&lt;/span&gt;&lt;/h3&gt;&lt;section&gt;&lt;span&gt;稳定性保障对于业务异常主要是从“万一发生了怎么办”这个角度出发去思考解决方案的。因此需要提前准备锦囊，以备不时之需。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;业务类异常的解决方案一般分为三类，止血解决方案、临时解决方案和长期解决方案。需要消耗的时间逐渐增多，对问题的解决程度逐渐增加。都是问题发生后的应对方案。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;止血解决方案一般不需要走代码变更发布，通过预案、设置、开关等实现，通常也是需要提前有所计划，有所准备的。临时解决方案和长期解决方案一般需要走代码变更发布，耗时较长。因此遇到问题一般都先执行效率最高的止血解决方案，如果止血解决方案依旧承受较大的损失，就需要快速拿出临时方案来解决问题，临时方案虽然一定程度上解决了问题，但是可能存在一些小功能问题、性能问题或者优雅性方面的瑕疵。因此需要在问题得以缓解之后思考出一个稳定优雅的长期解决方案。当然，那已经是后话了，不属于稳定性保障的工作范畴。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;对于业务功能异常，在日常开发时就需要提前打算，准备好能够多维度多程度降级的开关或者设置，留作异常发生时紧急止血使用。也就是预案。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;预案需要预演进行验证，保证预案配置和执行的正确性。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.3316008316008316&quot; data-type=&quot;png&quot; data-w=&quot;1924&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Z6bicxIx5naKcXB6s7weLV6aCPK0jVPU24lsbNsWXaKxQWhMvkTnaZb8XSCzTLamicuuIx32XTxdPvbnoT6qqSzQ/640?wx_fmt=png&quot;/&gt;&lt;/section&gt;&lt;h4&gt;&lt;strong&gt;&lt;span&gt;预案&lt;/span&gt;&lt;/strong&gt;&lt;span/&gt;&lt;/h4&gt;&lt;section&gt;&lt;span&gt;预案的本质是一个或者多个能够快速改变代码逻辑的设置。例如开关、diamond配置或者其他工具，将这些配置跳过繁琐的审批流程、实现快速执行就是预案，&lt;strong&gt;是用于大促前期关闭非核心功能、大促期间紧急问题及时止血保障主要功能而选择断尾某些功能的操作配置。&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;预案按照执行时间分为提前预案和应急预案。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;提前预案是大促前期自动执行用于关闭非核心功能以保障核心功能的预案，例如日志降级等；这类预案一般不会造成损失，风险可控，影响面是业务和消费者都可接受的。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;应急预案是大促期间发现线上问题，经过大促负责人审批同意后由相关测试或者开发人员手动执行，用于及时止血以保障主要功能的预案。这类预案类似于壁虎断尾的行为，舍弃小的损失，保留大的功能，因此一般都存在一定的损失。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;预案项需要提前梳理清楚，对功能无影响但是对性能无影响的锦上添花的部分在大促期间是是可以作为提前预案降级；对于可能出现异常情况的代码逻辑，或者评估风险较高的逻辑都要不吝增加开关设置，实现多维度降级（业务身份维度、商品类目维度、商家维度等等），在大促前夕配置好紧急预案。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;预案设置越多越好，但是预案执行须谨慎。&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;预案越多，能够快速应对的异常场景就越多，就越能够快速止血，当然也要考虑维护成本。但是配置预案的时候就要全面细致的评估清楚其执行影响，这样到了执行的时候才能正确选择合适大小的创可贴应对止血伤口。执行预案时须谨慎，按照大促要求走相应的流程，保证有double check。&lt;/span&gt;&lt;/section&gt;&lt;h4&gt;&lt;strong&gt;&lt;span&gt;预演&lt;/span&gt;&lt;/strong&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p&gt;&lt;span&gt;预演就是预先演练一遍。包括功能预演、活动预演、预案预演等。&lt;/span&gt;&lt;/p&gt;&lt;h3&gt;&lt;br/&gt;&lt;/h3&gt;&lt;h3&gt;&lt;span&gt;基础设施异常的解决方案&lt;/span&gt;&lt;/h3&gt;&lt;section&gt;&lt;span&gt;稳定性保障对于基础设施异常主要是从“如何才能不发生”这个角度出发去思考解决方案的。因此需要提前修炼内功，增强自身实力。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;对于基础设施异常，一旦发生，难以快速止血和修复。因此一般都是在大促前夕就要做足稳定性保障工作保证大促时不发生或者少发生这类异常，可通过压测、预演提前发现异常，提前提出解决方案进行修复处理。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;如前文所述，对于基础设施异常，稳定性保障工作仅考虑流量过大导致的异常。因此这类异常的原因明确就是流量过大。其解决方案也就明确是解决流量问题，分为对外解决方案和对内解决方案。对外限流拒绝过多流量对自身进行保护，但限流需要基于容量预估，有考量有依据的设置。对内扩容增强自身实力，并提前预热做好应对准备。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;内外解决方案通过压测相互协调配合，最终达到一种权衡利弊后的和谐。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.4368231046931408&quot; data-type=&quot;png&quot; data-w=&quot;1662&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Z6bicxIx5naKcXB6s7weLV6aCPK0jVPU2pN4NUTYCplGj8FD0YHRuibS7tyHMCRiaEFB7xLFib0PtxCwUibZFJG31bg/640?wx_fmt=png&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;综上，先要进行容量预估，预估外部流量峰值，再根据预估容量进行限流设置，然后进行压测，评估内部容量是否能够支撑预估容量，如果无法支撑，就要考虑扩容，扩容后根据机器数量进行限流调整，然后再次压测，压测后能够支撑预估容量甚至游刃有余时可以考虑再次调整限流，承载更多的流量。最后可以考虑在大促前进行缓存预热防止流量峰值击穿缓存。&lt;/span&gt;&lt;/section&gt;&lt;h4&gt;&lt;strong&gt;&lt;span&gt;容量预估&lt;/span&gt;&lt;/strong&gt;&lt;span/&gt;&lt;/h4&gt;&lt;section&gt;&lt;span&gt;容量评估要做的事情总结起来就是三件：&lt;/span&gt;&lt;/section&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;1、&lt;strong&gt;对上游：&lt;/strong&gt;询问预估流量，即他们要求我们的保障值。上游需要调用我们的服务，因此我们提供的服务量级需要满足他们的诉求。简言之，我们的水渠需要能够容纳得住从他们那里流下来的水流量。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;2、&lt;strong&gt;对自身：&lt;/strong&gt;梳理自身上下游链路，基于自身预估，根据上游诉求，预估对下游的诉求。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;3、&lt;strong&gt;对下游：&lt;/strong&gt;提供自己的预估容量，要求下游提供足够的容量。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;span&gt;自身容量如何预估呢？一般是通过以下几个方法进行：&lt;/span&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;1、&lt;strong&gt;梳理业务变化对流量影响：&lt;/strong&gt;业务逻辑每年都在变化，进而对流量有所影响。因此要梳理去年同一大促结束到今年大促之前这段时间内的业务变化，预估其对流量的影响量。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;2、&lt;strong&gt;参考往年同一大促容量值：&lt;/strong&gt;梳理往年同一大促的流量、峰值发生时间、整体流量走势；参考预估，没有影响流量的业务变化的情况下（理想情况），基本可以直接用来作为预估值。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;3、&lt;strong&gt;参考同年之前的大促容量值：&lt;/strong&gt;梳理同年前一次大促的流量参考预估。对比往年两次大促的流量比例来预估，例如，如果去年618与双11的的流量比是1:2，那么可以将今年618的容量乘以2的值来作为今年双11的容量预估值。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;4、结合上游诉求：收集到所有上游的诉求保障值，总结归纳。再对比自身预估容量。一般是两者取大。但是如果差异很大，就需要再认真核对，可能有预估错误或者遗漏。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.501&quot; data-type=&quot;png&quot; data-w=&quot;2000&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Z6bicxIx5naKcXB6s7weLV6aCPK0jVPU27cxsmicib4l21IvAn0RP3SnicGEmCTEKT6g9BwmpPSdAtUn6RByoZwu3g/640?wx_fmt=png&quot;/&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;对下游的诉求保障值如何预估呢？&lt;/span&gt;&lt;/p&gt;&lt;h4&gt;&lt;strong&gt;&lt;span&gt;限流&lt;/span&gt;&lt;/strong&gt;&lt;span/&gt;&lt;/h4&gt;&lt;section&gt;&lt;span&gt;限流类似于水渠源头的闸门，这个闸门开的大小直接决定了水渠中的水流量。将闸门开启到一定程度，而非完全打开，保障水渠不至于被冲垮的行为就是限流。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;无论有没有扩容，&lt;strong&gt;无论系统是游刃有余还是苦苦支撑，都需要对系统进行限流。&lt;/strong&gt;限流是系统的门卫，超出的容量可以被拦截在外。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;我们一般都使用单机限流，即设置单台机器最大可接受的QPS，超过则触发限流，限流可以直接拒绝，即快速失败，也可以排队等待。单机限流可以进行调用来源应用维度的限流，可以对所有上游应用一概而论（流控应用设置为default），也可以因人而异保障主要业务（针对核心的应用限流设置较大，非核心的应用限流设置较小）。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;也可以考虑集群限流，对整个集群进行限流。&lt;/span&gt;&lt;/section&gt;&lt;h4&gt;&lt;strong&gt;&lt;span&gt;压测&lt;/span&gt;&lt;/strong&gt;&lt;span/&gt;&lt;/h4&gt;&lt;section&gt;&lt;span&gt;所谓压测，就是构造数据流量通过几台压力机模拟用户持续并发请求系统接口，测试系统的性能和承受能力的过程。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;集团的压测分为单链路压测和全链路压测。所谓单链路压测，即自己的应用服务入口作为压测入口进行触发压测，主要面对的仅限于单个应用，涉及应用少，涉及人员少。全链路压测则从用户实际操作入口作为压测入口，这个操作涉及到的所有应用服务全部参与压测，是一个跨部门跨应用的过程，每次全链路压测，涉及到链路上所有团队的协调参与共同努力。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;全链路压测更能反应线上真是情况。条件允许的情况下都选择全链路压测。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;集团的压测都会提前构造影子链路，即真实链路的影子，和真实链路一模一样，却又不会对真实链路产生影响。库表也是使用影子表，将压测的持久化数据与真实持久化数据分开。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;压测是一个复杂的过程，需要专业的压测团队的同学支撑。对于一个从未参加过压测的应用而言，要做的工作简要概括如下：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.4264018691588785&quot; data-type=&quot;png&quot; data-w=&quot;1712&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Z6bicxIx5naKcXB6s7weLV6aCPK0jVPU2Jx3ApdvVNJ654UrXXb5vMlympVdRaITzny9n9YI26XBVpDY8RSNP8Q/640?wx_fmt=png&quot;/&gt;&lt;/section&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;1、&lt;strong&gt;应用适配改造：&lt;/strong&gt;要走通压测链路，涉及改动较多，包括应用系统改造、nginx升级、中间件改造、缓存端升级、DB端升级等等。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;2、&lt;strong&gt;构造压测数据：&lt;/strong&gt;压测数据构造需要根据具体的业务。例如价保的压测，需要构造的压测数据是处于价保有效期内的订单。如果要压到申请链路，还要构造优惠制造差价。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;3、&lt;strong&gt;创建压测模型：&lt;/strong&gt;所谓压测模型是指压测数据的分布情况，压测模型要能够反应线上真实流量占比。要覆盖到所有链路，不同业务的流量占比等同线上真实情况，中心机房和单元机房的流量比例也要按照线上比例分配。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;4、&lt;strong&gt;进行压测：&lt;/strong&gt;压测分为单链路压测和全链路压测，单链路压测是指仅仅对自己关注的系统进行压测；全链路压测是从用户发起请求开始到整个业务逻辑结束的全部链路压测。压测入口也分为http接口压测和端上接口压测，具体根据系统情况而定。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;5、&lt;strong&gt;观测与总结：&lt;/strong&gt;在压测的过程中，要时刻盯盘，观测系统水位。压测后总结梳理出压测报告。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;section&gt;&lt;span&gt;压测一般不是一次就能够完成的，可能因为各种原因导致压测结果不理想，因此要多次压测，每次根据压测问题进行修复后再次压测，直到压测结果符合预期为止。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;上图中只绘制了压测适配原因导致的重新压测，如前文所示扩容和限流后也要进行压测。&lt;/span&gt;&lt;/section&gt;&lt;h4&gt;&lt;strong&gt;&lt;span&gt;扩容&lt;/span&gt;&lt;/strong&gt;&lt;span/&gt;&lt;/h4&gt;&lt;section&gt;&lt;span&gt;扩容，就是暴力增加机器。所以也要考虑成本。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;如果压测的结果，系统无法达到上游诉求，为了保证业务的顺利进行。就需要扩容，并再次压测，直到系统能够保障目标容量。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;如果压测的结果皆大欢喜，满足了上游诉求，那么就不需要扩容了。&lt;/span&gt;&lt;/section&gt;&lt;h4&gt;&lt;strong&gt;&lt;span&gt;预热&lt;/span&gt;&lt;/strong&gt;&lt;span/&gt;&lt;/h4&gt;&lt;section&gt;&lt;span&gt;预热可简单的理解为参赛前的热身。让容器、缓存、数据库等都准备好迎接大促的流量峰值。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6673228346456693&quot; data-type=&quot;png&quot; data-w=&quot;2032&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Z6bicxIx5naKcXB6s7weLV6aCPK0jVPU2RAxGD5raPxba1hBD1yiciaBm8HZX0oK7NMH8MjY66VMFhDthYAkG78nA/640?wx_fmt=png&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;预热分为缓存预热和启动预热。缓存预热属于大促稳定性保障工作，但是启动预热属于一种日常的性能优化。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;集团每年大促的商品预热是被人所熟知的。就是将热点商品提前加载进缓存中，避免大促期间缓存击穿，流量直接打挂db的情况。这就是缓存预热。多用于大量依赖缓存的应用。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;启动预热一般是处理服务刚启动时服务RT较大甚至超时的问题，处理方式是在启动时通过构造参数，模拟真实请求的方式把代码跑热后再对外提供服务。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;总结&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;h1&gt;&lt;span/&gt;&lt;/h1&gt;&lt;section&gt;&lt;span&gt;稳定性保障工作从时间上来说，包括日常业务需求开发时的监控告警配置和开关预留，大促前夕的容量预估、压测、限流、扩容和预热，其实还有一部分，上文未及提及，那便是大促值班。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;建议在值班前写一个值班手册，将可能出现的问题，解决方案，需要使用到的工具链接全部罗列清楚，避免值班时手忙脚乱找资料找工具。还有必要的权限申请在值班前申请好。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;在大促期间，严阵以待，这个时候需要做到两动，主动关注监控大盘，注意流量变化，监控基础设施指标；被动关注告警，一旦被告警提醒就是有异常情况了，要立刻投入定位解决。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;最后，稳定性保障工作是没有尽头的，其重要性不言而喻，但是也要在业务功能与稳定性之间做好权衡，如果稳定性核对的调用流量都超过了业务流量，那么稳定性工作就有点过了，从机器成本、人力成本上都没有这个必要。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;本文整理了自己对稳定性保障的认识和理解，可能存在理解有误或者认识不足的情况欢迎指正，也期待更多的学习逐渐修正和完善自己的稳定性相关知识。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;语雀产品评测，免费体验！&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;🚀🚀🚀参与语雀产品评测，赢取语雀专业会员1年、语雀周边礼盒、阿里云定制冲锋衣等多重好礼🎁&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;点击阅读原文查看详情。&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;span/&gt;&lt;/section&gt;&lt;p&gt;&lt;mp-style-type data-value=&quot;3&quot;/&gt;&lt;/p&gt;&lt;/div&gt;

          
        &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>dfaaac837bdfa6e89357bae52e427261</guid>
<title>深入理解 Linux 中进程控制</title>
<link>https://toutiao.io/k/dg3d0k8</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content js_underline_content             autoTypeSetting24psection&amp;#10;            &quot; id=&quot;js_content&quot;&gt;&lt;section data-tools=&quot;新媒体管家&quot; data-label=&quot;powered by xmt.cn&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;p data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;span&gt;↓&lt;/span&gt;&lt;span&gt;推荐关注↓&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;&lt;section&gt;&lt;mp-common-profile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-id=&quot;MzAwNjMxMTgwNw==&quot; data-pluginname=&quot;mpprofile&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/IgylNib7ZE2L6Kv5EcGWb5mYVbzlgzP2R6qdGee7kZ03T7nia7rtkSnKvEvEOwnGxX4Zf2VVrlQNwWVrLlEhn4OQ/0?wx_fmt=png&quot; data-nickname=&quot;Go开发大全&quot; data-alias=&quot;goprogrammer&quot; data-signature=&quot;点击获取6万star的Go开源库。[ Go开发大全 ] 日常分享 Go, 云原生、k8s、Docker和微服务方面的技术文章和行业动态。&quot; data-from=&quot;0&quot; data-is_biz_ban=&quot;0&quot; data-weui-theme=&quot;light&quot;/&gt;&lt;/section&gt;&lt;blockquote&gt;&lt;p&gt;&lt;span&gt;转自：一口Linux&lt;/span&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;h1 data-track=&quot;1&quot;&gt;&lt;span&gt;一、进程创建&lt;/span&gt;&lt;/h1&gt;&lt;h1&gt;&lt;span&gt;fork函数初识&lt;/span&gt;&lt;/h1&gt;&lt;p data-track=&quot;3&quot;&gt;&lt;span&gt;在Linux中，fork函数是非常重要的函数，它从已存在进程中创建一个新进程。新进程为子进程，而原进程为父进程。&lt;/span&gt;&lt;/p&gt;&lt;p data-track=&quot;4&quot;&gt;&lt;span&gt;返回值：&lt;/span&gt;&lt;/p&gt;&lt;p data-track=&quot;5&quot;&gt;&lt;span&gt;在子进程中返回0，父进程中返回子进程的PID，子进程创建失败返回-1。&lt;/span&gt;&lt;/p&gt;&lt;p data-track=&quot;6&quot;&gt;&lt;span&gt;进程调用fork，当控制转移到内核中的fork代码后，内核做：&lt;/span&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;分配新的内存块和内核数据结构给子进程。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;将父进程部分数据结构内容拷贝至子进程。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;添加子进程到系统进程列表当中。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;fork返回，开始调度器调度。&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-track=&quot;11&quot;&gt;&lt;span&gt;fork之后，父子进程代码共享。例如：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.4985563041385948&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/icRxcMBeJfc9llX5bCjZubbh0woHLt8e0uSVmBK30ibog59xeIyWkNRdVngX1LibuhYerjlzJiaq4l6D8icgKZPibqicA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1039&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p data-track=&quot;15&quot;&gt;&lt;span&gt;运行结果如下：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.23735810113519093&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/icRxcMBeJfc9llX5bCjZubbh0woHLt8e0qM7s6G6Go6Qg8MsxVVibjX7ctvmqImKtsJpFtoXbWriasqQLylBvVtZw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;969&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p data-track=&quot;17&quot;&gt;&lt;span&gt;这里可以看到，Before只输出了一次，而After输出了两次。其中，Before是由父进程打印的，而调用fork函数之后打印的两个After，则分别由父进程和子进程两个进程执行。也就是说，fork之前父进程独立执行，而fork之后父子两个执行流分别执行。&lt;/span&gt;&lt;/p&gt;&lt;p data-track=&quot;18&quot;&gt;&lt;span&gt;注意： fork之后，父进程和子进程谁先执行完全由调度器决定。&lt;/span&gt;&lt;/p&gt;&lt;h1 data-track=&quot;19&quot;&gt;&lt;span&gt;fork函数返回值&lt;/span&gt;&lt;/h1&gt;&lt;blockquote&gt;&lt;p data-track=&quot;22&quot;&gt;&lt;span&gt;fork函数为什么要给子进程返回0，给父进程返回子进程的PID？&lt;/span&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-track=&quot;23&quot;&gt;&lt;span&gt;一个父进程可以创建多个子进程，而一个子进程只能有一个父进程。因此，对于子进程来说，父进程是不需要被标识的；而对于父进程来说，子进程是需要被标识的，因为父进程创建子进程的目的是让其执行任务的，父进程只有知道了子进程的PID才能很好的对该子进程指派任务。&lt;/span&gt;&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;&lt;span&gt;为什么fork函数有两个返回值？&lt;/span&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-track=&quot;25&quot;&gt;&lt;span&gt;父进程调用fork函数后，为了创建子进程，fork函数内部将会进行一系列操作，包括创建子进程的进程控制块、创建子进程的进程地址空间、创建子进程对应的页表等等。子进程创建完毕后，操作系统还需要将子进程的进程控制块添加到系统进程列表当中，此时子进程便创建完毕了。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.3890160183066362&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/icRxcMBeJfc9llX5bCjZubbh0woHLt8e00aMlFaCRCDHj0Znj3EGdtru6bpric4uicQUG8fXFnFhpHUe7X4NUkCJg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1311&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p data-track=&quot;31&quot;&gt;&lt;span&gt;也就是说，在fork函数内部执行return语句之前，子进程就已经创建完毕了，那么之后的return语句不仅父进程需要执行，子进程也同样需要执行，这就是fork函数有两个返回值的原因。&lt;/span&gt;&lt;/p&gt;&lt;h1&gt;&lt;span&gt;写时拷贝&lt;/span&gt;&lt;/h1&gt;&lt;p data-track=&quot;33&quot;&gt;&lt;span&gt;当子进程刚刚被创建时，子进程和父进程的数据和代码是共享的，即父子进程的代码和数据通过页表映射到物理内存的同一块空间。只有当父进程或子进程需要修改数据时，才将父进程的数据在内存当中拷贝一份，然后再进行修改。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.31975867269984914&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/icRxcMBeJfc9llX5bCjZubbh0woHLt8e0uue4nSX5VcWvRrarTfaNGoHeQDiaCHufOr9P9VyNhfmRH3eKO4Ml7icQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1326&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p data-track=&quot;37&quot;&gt;&lt;span&gt;这种在需要进行数据修改时再进行拷贝的技术，称为写时拷贝技术。&lt;/span&gt;&lt;/p&gt;&lt;p data-track=&quot;38&quot;&gt;&lt;span&gt;1、为什么数据要进行写时拷贝？&lt;/span&gt;&lt;/p&gt;&lt;p data-track=&quot;39&quot;&gt;&lt;span&gt;进程具有独立性。多进程运行，需要独享各种资源，多进程运行期间互不干扰，不能让子进程的修改影响到父进程。&lt;/span&gt;&lt;/p&gt;&lt;p data-track=&quot;40&quot;&gt;&lt;span&gt;2、为什么不在创建子进程的时候就进行数据的拷贝？&lt;/span&gt;&lt;/p&gt;&lt;p data-track=&quot;41&quot;&gt;&lt;span&gt;子进程不一定会使用父进程的所有数据，并且在子进程不对数据进行写入的情况下，没有必要对数据进行拷贝，我们应该按需分配，在需要修改数据的时候再分配（延时分配），这样可以高效的使用内存空间。&lt;/span&gt;&lt;/p&gt;&lt;p data-track=&quot;42&quot;&gt;&lt;span&gt;3、代码会不会进行写时拷贝？&lt;/span&gt;&lt;/p&gt;&lt;p data-track=&quot;43&quot;&gt;&lt;span&gt;90%的情况下是不会的，但这并不代表代码不能进行写时拷贝，例如在进行进程替换的时候，则需要进行代码的写时拷贝。&lt;/span&gt;&lt;/p&gt;&lt;h1&gt;&lt;span&gt;fork常规用法&lt;/span&gt;&lt;/h1&gt;&lt;ol start=&quot;1&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;一个进程希望复制自己，使子进程同时执行不同的代码段。例如父进程等待客户端请求，生成子进程来处理请求。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;一个进程要执行一个不同的程序。例如子进程从fork返回后，调用exec函数。&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h1&gt;&lt;span&gt;fork调用失败的原因&lt;/span&gt;&lt;/h1&gt;&lt;p data-track=&quot;50&quot;&gt;&lt;span&gt;fork函数创建子进程也可能会失败，有以下两种情况：&lt;/span&gt;&lt;/p&gt;&lt;ol start=&quot;1&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;系统中有太多的进程，内存空间不足，子进程创建失败。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;实际用户的进程数超过了限制，子进程创建失败。&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h1 data-track=&quot;53&quot;&gt;&lt;span&gt;二、进程终止&lt;/span&gt;&lt;/h1&gt;&lt;h1 data-track=&quot;56&quot;&gt;&lt;span&gt;进程退出场景&lt;/span&gt;&lt;/h1&gt;&lt;p data-track=&quot;57&quot;&gt;&lt;span&gt;进程退出只有三种情况：&lt;/span&gt;&lt;/p&gt;&lt;ol start=&quot;1&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;代码运行完毕，结果正确。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;代码运行完毕，结果不正确。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;代码异常终止（进程崩溃）。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h1&gt;&lt;span&gt;进程退出码&lt;/span&gt;&lt;/h1&gt;&lt;p data-track=&quot;63&quot;&gt;&lt;span&gt;我们都知道main函数是代码的入口，但实际上main函数只是用户级别代码的入口，main函数也是被其他函数调用的，例如在VS2013当中main函数就是被一个名为__tmainCRTStartup的函数所调用，而__tmainCRTStartup函数又是通过加载器被操作系统所调用的，也就是说main函数是间接性被操作系统所调用的。&lt;/span&gt;&lt;/p&gt;&lt;p data-track=&quot;64&quot;&gt;&lt;span&gt;既然main函数是间接性被操作系统所调用的，那么当main函数调用结束后就应该给操作系统返回相应的退出信息，而这个所谓的退出信息就是以退出码的形式作为main函数的返回值返回，我们一般以0表示代码成功执行完毕，以非0表示代码执行过程中出现错误，这就是为什么我们都在main函数的最后返回0的原因。&lt;/span&gt;&lt;/p&gt;&lt;p data-track=&quot;65&quot;&gt;&lt;span&gt;当我们的代码运行起来就变成了进程，当进程结束后main函数的返回值实际上就是该进程的进程退出码，我们可以使用echo $?命令查看最近一次进程退出的退出码信息。&lt;/span&gt;&lt;/p&gt;&lt;p data-track=&quot;66&quot;&gt;&lt;span&gt;例如，对于下面这个简单的代码：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.3952205882352941&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/icRxcMBeJfc9llX5bCjZubbh0woHLt8e08Vrl4NUl6Zkh0agQK4zD2VJMmU3Nh30wZwVNALVeCHia6xE4pZChqew/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1088&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p data-track=&quot;70&quot;&gt;&lt;span&gt;代码运行结束后，我们可以查看该进程的进程退出码。&lt;/span&gt;&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;[cl@VM-&lt;span&gt;0&lt;/span&gt;-&lt;span&gt;15&lt;/span&gt;-centos procTermination]$ echo $?&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.29850746268656714&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/icRxcMBeJfc9llX5bCjZubbh0woHLt8e0tHicNwC085LtUuHo6vLibuvXoSvhXMNCUvlMolpL5msrCFhY5thKEeYA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;804&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p data-track=&quot;73&quot;&gt;&lt;span&gt;这时便可以确定main函数是顺利执行完毕了。&lt;/span&gt;&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;&lt;span&gt;为什么以0表示代码执行成功，以非0表示代码执行错误？&lt;/span&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-track=&quot;75&quot;&gt;&lt;span&gt;因为代码执行成功只有一种情况，成功了就是成功了，而代码执行错误却有多种原因，例如内存空间不足、非法访问以及栈溢出等等，我们就可以用这些非0的数字分别表示代码执行错误的原因。&lt;/span&gt;&lt;/p&gt;&lt;p data-track=&quot;76&quot;&gt;&lt;span&gt;C语言当中的strerror函数可以通过错误码，获取该错误码在C语言当中对应的错误信息：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.3635371179039301&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/icRxcMBeJfc9llX5bCjZubbh0woHLt8e0rxPR5FIHS3peFjFTJIjBL6lX8qNv1mQ73JZ5oiaMEGicicdBdXpj0LE0g/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;916&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;运行代码后我们就可以看到各个错误码所对应的错误信息：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.675&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/icRxcMBeJfc9llX5bCjZubbh0woHLt8e0Umgf0MMCjNPhYRK85kiaYibjicC0ZwMrhLCR2heQEQsHlnUI1dxSV12fA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1120&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;实际上Linux中的ls、pwd等命令都是可执行程序，使用这些命令后我们也可以查看其对应的退出码。&lt;/span&gt;&lt;/p&gt;&lt;p data-track=&quot;86&quot;&gt;&lt;span&gt;可以看到，这些命令成功执行后，其退出码也是0。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.32684824902723736&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/icRxcMBeJfc9llX5bCjZubbh0woHLt8e0aaibRzTMKrL1R8bQQsdPt9HAtjShgF8Qk7xMOPZef5cSkJnEz9yywrQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1028&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p data-track=&quot;85&quot;&gt;&lt;span&gt;但是命令执行错误后，其退出码就是非0的数字，该数字具体代表某一错误信息。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.2891278375149343&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/icRxcMBeJfc9llX5bCjZubbh0woHLt8e0LhtsNibpTSoVu07T2Rgro03FxT2j9r3xH1G1htPJW9RR5ueJ33q7ibNQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;837&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p data-track=&quot;87&quot;&gt;&lt;span&gt;&lt;span&gt;注意：&lt;/span&gt;&lt;span&gt; 退出码都有对应的字符串含义，帮助用户确认执行失败的原因，而这些退出码具体代表什么含义是人为规定的，不同环境下相同的退出码的字符串含义可能不同。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;h1 data-track=&quot;88&quot;&gt;&lt;span&gt;进程正常退出&lt;/span&gt;&lt;/h1&gt;&lt;h1 data-track=&quot;89&quot;&gt;&lt;span&gt;return退出&lt;/span&gt;&lt;/h1&gt;&lt;p data-track=&quot;90&quot;&gt;&lt;span&gt;在main函数中使用return退出进程是我们常用的方法。&lt;/span&gt;&lt;/p&gt;&lt;p data-track=&quot;91&quot;&gt;&lt;span&gt;例如，在main函数最后使用return退出进程。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.3952205882352941&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/icRxcMBeJfc9llX5bCjZubbh0woHLt8e0Emr9YgsZibV2ojjfP9dbQPg5crsyJkyP8RKXpnakl2ey9OFAKEIXDsw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1088&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;运行结果：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.24242424242424243&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/icRxcMBeJfc9llX5bCjZubbh0woHLt8e0wxkreZaTKzG1pibFvdubGkQezfnMYf7RibLtIuZLFIDEL9wTWfqiazziaA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;957&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;h1 data-track=&quot;93&quot;&gt;&lt;span&gt;exit函数&lt;/span&gt;&lt;/h1&gt;&lt;p data-track=&quot;94&quot;&gt;&lt;span&gt;使用exit函数退出进程也是我们常用的方法，exit函数可以在代码中的任何地方退出进程，并且exit函数在退出进程前会做一系列工作：&lt;/span&gt;&lt;/p&gt;&lt;ol start=&quot;1&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;执行用户通过atexit或on_exit定义的清理函数。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;关闭所有打开的流，所有的缓存数据均被写入。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;调用_exit函数终止进程。&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-track=&quot;98&quot;&gt;&lt;span&gt;例如，以下代码中exit终止进程前会将缓冲区当中的数据输出。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.43521594684385384&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/icRxcMBeJfc9llX5bCjZubbh0woHLt8e0siarW6qCTfx7zUA2nUICC8CVAvh3Z42icaZ9RS7Tfm4Bibhv1QqxToPWQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;903&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;运行结果：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.24401913875598086&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/icRxcMBeJfc9llX5bCjZubbh0woHLt8e051rk5tgdicUBG3icjMbgKiabaglh1zicibziaibXibxw1Z8JicfJRB62aZNficYA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1045&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;h1 data-track=&quot;103&quot;&gt;&lt;span&gt;_exit函数&lt;/span&gt;&lt;/h1&gt;&lt;p data-track=&quot;104&quot;&gt;&lt;span&gt;使用_exit函数退出进程的方法我们并不经常使用，_exit函数也可以在代码中的任何地方退出进程，但是_exit函数会直接终止进程，并不会在退出进程前会做任何收尾工作。&lt;/span&gt;&lt;/p&gt;&lt;p data-track=&quot;105&quot;&gt;&lt;span&gt;例如，以下代码中使用_exit终止进程，则缓冲区当中的数据将不会被输出。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.41455696202531644&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/icRxcMBeJfc9llX5bCjZubbh0woHLt8e0rqL7RgJBpXKpq3iaFo0NYJwSzUNyIj7zSljvTWkQD3vQ2aVahNsRBFg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;948&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p data-track=&quot;305&quot;&gt;&lt;span&gt;运行结果：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.24633699633699635&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/icRxcMBeJfc9llX5bCjZubbh0woHLt8e0v15YnBs242j8wRmKMFnqFDmcJV4IgMxtfKMbjynFO60xXrqyGHxdIg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1092&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;h1 data-track=&quot;108&quot;&gt;&lt;span&gt;return、exit和_exit之间的区别与联系&lt;/span&gt;&lt;/h1&gt;&lt;blockquote&gt;&lt;p&gt;&lt;span&gt;return、exit和_exit之间的区别&lt;/span&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-track=&quot;110&quot;&gt;&lt;span&gt;只有在main函数当中的return才能起到退出进程的作用，子函数当中return不能退出进程，而exit函数和_exit函数在代码中的任何地方使用都可以起到退出进程的作用。&lt;/span&gt;&lt;/p&gt;&lt;p data-track=&quot;111&quot;&gt;&lt;span&gt;使用exit函数退出进程前，exit函数会执行用户定义的清理函数、冲刷缓冲，关闭流等操作，然后再终止进程，而_exit函数会直接终止进程，不会做任何收尾工作。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.49860205032618826&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/icRxcMBeJfc9llX5bCjZubbh0woHLt8e00f8kRlxeJuufeAgficpXwwm3QNNnLrwlJb7Ribqb4UXNCwwSYJibkT0kA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1073&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;&lt;span&gt;return、exit和_exit之间的联系&lt;/span&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-track=&quot;117&quot;&gt;&lt;span&gt;执行return num等同于执行exit(num)，因为调用main函数运行结束后，会将main函数的返回值当做exit的参数来调用exit函数。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.09536784741144415&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/icRxcMBeJfc9llX5bCjZubbh0woHLt8e0e0oFkiajFiaBGQ7nZicQ9wubRYhCOYXSSIV0PuCQpZlD4JXZbmJ7xp96w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;734&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p data-track=&quot;118&quot;&gt;&lt;span&gt;使用exit函数退出进程前，exit函数会先执行用户定义的清理函数、冲刷缓冲，关闭流等操作，然后再调用_exit函数终止进程。&lt;/span&gt;&lt;/p&gt;&lt;h1&gt;&lt;span&gt;进程异常退出&lt;/span&gt;&lt;/h1&gt;&lt;p data-track=&quot;123&quot;&gt;&lt;span&gt;情况一：向进程发生信号导致进程异常退出。&lt;/span&gt;&lt;/p&gt;&lt;p data-track=&quot;124&quot;&gt;&lt;span&gt;例如，在进程运行过程中向进程发生kill -9信号使得进程异常退出，或是使用Ctrl+C使得进程异常退出等。&lt;/span&gt;&lt;/p&gt;&lt;p data-track=&quot;125&quot;&gt;&lt;span&gt;情况二：代码错误导致进程运行时异常退出。&lt;/span&gt;&lt;/p&gt;&lt;p data-track=&quot;126&quot;&gt;&lt;span&gt;例如，代码当中存在野指针问题使得进程运行时异常退出，或是出现除0的情况使得进程运行时异常退出等。&lt;/span&gt;&lt;/p&gt;&lt;h1 data-track=&quot;127&quot;&gt;&lt;span&gt;三、进程等待&lt;/span&gt;&lt;/h1&gt;&lt;h1 data-track=&quot;130&quot;&gt;&lt;span&gt;进程等待的必要性&lt;/span&gt;&lt;/h1&gt;&lt;ol start=&quot;1&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;子进程退出，父进程如果不读取子进程的退出信息，子进程就会变成僵尸进程，进而造成内存泄漏。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;进程一旦变成僵尸进程，那么就算是kill -9命令也无法将其杀死，因为谁也无法杀死一个已经死去的进程。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;对于一个进程来说，最关心自己的就是其父进程，因为父进程需要知道自己派给子进程的任务完成的如何。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;父进程需要通过进程等待的方式，回收子进程资源，获取子进程的退出信息。&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h1&gt;&lt;span&gt;获取子进程status&lt;/span&gt;&lt;/h1&gt;&lt;p data-track=&quot;138&quot;&gt;&lt;span&gt;下面进程等待所使用的两个函数wait和waitpid，都有一个status参数，该参数是一个输出型参数，由操作系统进行填充。&lt;/span&gt;&lt;/p&gt;&lt;p data-track=&quot;139&quot;&gt;&lt;span&gt;如果对status参数传入NULL，表示不关心子进程的退出状态信息。否则，操作系统会通过该参数，将子进程的退出信息反馈给父进程。&lt;/span&gt;&lt;/p&gt;&lt;p data-track=&quot;140&quot;&gt;&lt;span&gt;status是一个整型变量&lt;span&gt;，但status不能简单的当作整型来看待，status的不同比特位所代表的信息不同，具体细节如下（只研究status低16比特位）：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.1681503461918892&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/icRxcMBeJfc9llX5bCjZubbh0woHLt8e0K1v5QnPoESSMH2XV56FcicfD4HpDt2wyTymSViafxtxwhUGoFIj6GdGw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1011&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p data-track=&quot;144&quot;&gt;&lt;span&gt;在status的低16比特位当中，高8位表示进程的退出状态，即退出码。进程若是被信号所杀，则低7位表示终止信号，而第8位比特位是core dump标志。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.243639167309175&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/icRxcMBeJfc9llX5bCjZubbh0woHLt8e0MCbH5ItCh429KNia5vOtDTG0GxrwzSRQRuhDmZfW6oicpg898lFKNJlg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1297&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;我们通过一系列位操作，就可以根据status得到进程的退出码和退出信号。&lt;/span&gt;&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;exitCode&lt;/span&gt; = (status &amp;gt;&amp;gt; &lt;span&gt;8&lt;/span&gt;) &amp;amp; &lt;span&gt;0&lt;/span&gt;xFF&lt;span&gt;; //退出码&lt;/span&gt;&lt;br/&gt;&lt;span&gt;exitSignal&lt;/span&gt; = status &amp;amp; &lt;span&gt;0&lt;/span&gt;x7F&lt;span&gt;;      //退出信号&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-track=&quot;148&quot;&gt;&lt;span&gt;对于此，系统当中提供了两个宏来获取退出码和退出信号。&lt;/span&gt;&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;exitNormal&lt;/span&gt; = WIFEXITED(status)&lt;span&gt;;  //是否正常退出&lt;/span&gt;&lt;br/&gt;&lt;span&gt;exitCode&lt;/span&gt; = WEXITSTATUS(status)&lt;span&gt;;  //获取退出码&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-track=&quot;153&quot;&gt;&lt;span&gt;需要注意的是，当一个进程非正常退出时，说明该进程是被信号所杀，那么该进程的退出码也就没有意义了。&lt;/span&gt;&lt;/p&gt;&lt;h1 data-track=&quot;154&quot;&gt;&lt;span&gt;进程等待的方法&lt;/span&gt;&lt;/h1&gt;&lt;h1 data-track=&quot;155&quot;&gt;&lt;span&gt;wait方法&lt;/span&gt;&lt;/h1&gt;&lt;p data-track=&quot;156&quot;&gt;&lt;span&gt;函数原型：pid_t wait(int* status);&lt;/span&gt;&lt;/p&gt;&lt;p data-track=&quot;157&quot;&gt;&lt;span&gt;作用：等待任意子进程。&lt;/span&gt;&lt;/p&gt;&lt;p data-track=&quot;158&quot;&gt;&lt;span&gt;返回值：等待成功返回被等待进程的pid，等待失败返回-1。&lt;/span&gt;&lt;/p&gt;&lt;p data-track=&quot;159&quot;&gt;&lt;span&gt;参数：输出型参数，获取子进程的退出状态，不关心可设置为NULL。&lt;/span&gt;&lt;/p&gt;&lt;p data-track=&quot;160&quot;&gt;&lt;span&gt;例如，创建子进程后，父进程可使用wait函数一直等待子进程，直到子进程退出后读取子进程的退出信息。&lt;/span&gt;&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;#include &amp;lt;stdio.h&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;#include &amp;lt;stdlib.h&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;#include &amp;lt;unistd.h&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;#include &amp;lt;sys/wait.h&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;#include &amp;lt;sys/types.h&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;int main()&lt;br/&gt;&lt;/span&gt;{&lt;br/&gt;&lt;span&gt;pid_t&lt;/span&gt; id = fork();&lt;br/&gt;&lt;span&gt;if&lt;/span&gt;(id == &lt;span&gt;0&lt;/span&gt;){&lt;br/&gt;&lt;span&gt;//child&lt;/span&gt;&lt;br/&gt;&lt;span&gt;int&lt;/span&gt; count = &lt;span&gt;10&lt;/span&gt;;&lt;br/&gt;&lt;span&gt;while&lt;/span&gt;(count--){&lt;br/&gt;&lt;span&gt;printf&lt;/span&gt;(&lt;span&gt;&quot;I am child...PID:%d, PPID:%d\n&quot;&lt;/span&gt;, getpid(), getppid());&lt;br/&gt;sleep(&lt;span&gt;1&lt;/span&gt;);&lt;br/&gt;}&lt;br/&gt;&lt;span&gt;exit&lt;/span&gt;(&lt;span&gt;0&lt;/span&gt;);&lt;br/&gt;}&lt;br/&gt;&lt;span&gt;//father&lt;/span&gt;&lt;br/&gt;&lt;span&gt;int&lt;/span&gt; status = &lt;span&gt;0&lt;/span&gt;;&lt;br/&gt;&lt;span&gt;pid_t&lt;/span&gt; ret = wait(&amp;amp;status);&lt;br/&gt;&lt;span&gt;if&lt;/span&gt;(ret &amp;gt; &lt;span&gt;0&lt;/span&gt;){&lt;br/&gt;&lt;span&gt;//wait success&lt;/span&gt;&lt;br/&gt;&lt;span&gt;printf&lt;/span&gt;(&lt;span&gt;&quot;wait child success...\n&quot;&lt;/span&gt;);&lt;br/&gt;&lt;span&gt;if&lt;/span&gt;(WIFEXITED(status)){&lt;br/&gt;&lt;span&gt;//exit normal&lt;/span&gt;&lt;br/&gt;&lt;span&gt;printf&lt;/span&gt;(&lt;span&gt;&quot;exit code:%d\n&quot;&lt;/span&gt;, WEXITSTATUS(status));&lt;br/&gt;}&lt;br/&gt;}&lt;br/&gt;sleep(&lt;span&gt;3&lt;/span&gt;);&lt;br/&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;;&lt;br/&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-track=&quot;164&quot;&gt;&lt;span&gt;我们可以使用以下监控脚本对进程进行实时监控：&lt;/span&gt;&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;[cl@VM-&lt;span&gt;0&lt;/span&gt;-&lt;span&gt;15&lt;/span&gt;-centos procWait]$ &lt;span&gt;while&lt;/span&gt; :; &lt;span&gt;do&lt;/span&gt; ps axj | head -&lt;span&gt;1&lt;/span&gt; &amp;amp;&amp;amp; ps axj | &lt;span&gt;grep&lt;/span&gt; proc | &lt;span&gt;grep&lt;/span&gt; -v &lt;span&gt;grep&lt;/span&gt;;echo &lt;span&gt;&quot;######################&quot;&lt;/span&gt;;&lt;span&gt;sleep&lt;/span&gt; &lt;span&gt;1&lt;/span&gt;;done&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-track=&quot;167&quot;&gt;&lt;span&gt;这时我们可以看到，当子进程退出后，父进程读取了子进程的退出信息，子进程也就不会变成僵尸进程了。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.4423380726698262&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/icRxcMBeJfc9llX5bCjZubbh0woHLt8e0dROiaww4ssm2fkp9X2kNic0PptEU9hcc0ibfKHUuZPkIbxABYHjtcUs6w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1899&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;h1 data-track=&quot;171&quot;&gt;&lt;span&gt;waitpid方法&lt;/span&gt;&lt;/h1&gt;&lt;p data-track=&quot;172&quot;&gt;&lt;span&gt;函数原型：pid_t waitpid(pid_t pid, int* status, int options);&lt;/span&gt;&lt;/p&gt;&lt;p data-track=&quot;173&quot;&gt;&lt;span&gt;作用：等待指定子进程或任意子进程。&lt;/span&gt;&lt;/p&gt;&lt;p data-track=&quot;174&quot;&gt;&lt;span&gt;返回值：&lt;/span&gt;&lt;/p&gt;&lt;p data-track=&quot;175&quot;&gt;&lt;span&gt;1、等待成功返回被等待进程的pid。&lt;/span&gt;&lt;/p&gt;&lt;p data-track=&quot;176&quot;&gt;&lt;span&gt;2、如果设置了选项WNOHANG，而调用中waitpid发现没有已退出的子进程可收集，则返回0。&lt;/span&gt;&lt;/p&gt;&lt;p data-track=&quot;177&quot;&gt;&lt;span&gt;3、如果调用中出错，则返回-1，这时errno会被设置成相应的值以指示错误所在。&lt;/span&gt;&lt;/p&gt;&lt;p data-track=&quot;178&quot;&gt;&lt;span&gt;参数：&lt;/span&gt;&lt;/p&gt;&lt;p data-track=&quot;179&quot;&gt;&lt;span&gt;1、pid：待等待子进程的pid，若设置为-1，则等待任意子进程。&lt;/span&gt;&lt;/p&gt;&lt;p data-track=&quot;180&quot;&gt;&lt;span&gt;2、status：输出型参数，获取子进程的退出状态，不关心可设置为NULL。&lt;/span&gt;&lt;/p&gt;&lt;p data-track=&quot;181&quot;&gt;&lt;span&gt;3、options：当设置为WNOHANG时，若等待的子进程没有结束，则waitpid函数直接返回0，不予以等待。若正常结束，则返回该子进程的pid。&lt;/span&gt;&lt;/p&gt;&lt;p data-track=&quot;182&quot;&gt;&lt;span&gt;例如，创建子进程后，父进程可使用waitpid函数一直等待子进程（此时将waitpid的第三个参数设置为0），直到子进程退出后读取子进程的退出信息。&lt;/span&gt;&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;#include &amp;lt;stdio.h&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;#include &amp;lt;stdlib.h&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;#include &amp;lt;unistd.h&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;#include &amp;lt;sys/wait.h&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;#include &amp;lt;sys/types.h&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;int main()&lt;br/&gt;&lt;/span&gt;{&lt;br/&gt;&lt;span&gt;pid_t&lt;/span&gt; id = fork();&lt;br/&gt;&lt;span&gt;if&lt;/span&gt; (id == &lt;span&gt;0&lt;/span&gt;){&lt;br/&gt;&lt;span&gt;//child          &lt;/span&gt;&lt;br/&gt;&lt;span&gt;int&lt;/span&gt; count = &lt;span&gt;10&lt;/span&gt;;&lt;br/&gt;&lt;span&gt;while&lt;/span&gt; (count--){&lt;br/&gt;&lt;span&gt;printf&lt;/span&gt;(&lt;span&gt;&quot;I am child...PID:%d, PPID:%d\n&quot;&lt;/span&gt;, getpid(), getppid());&lt;br/&gt;sleep(&lt;span&gt;1&lt;/span&gt;);&lt;br/&gt;}&lt;br/&gt;&lt;span&gt;exit&lt;/span&gt;(&lt;span&gt;0&lt;/span&gt;);&lt;br/&gt;}&lt;br/&gt;&lt;span&gt;//father           &lt;/span&gt;&lt;br/&gt;&lt;span&gt;int&lt;/span&gt; status = &lt;span&gt;0&lt;/span&gt;;&lt;br/&gt;&lt;span&gt;pid_t&lt;/span&gt; ret = waitpid(id, &amp;amp;status, &lt;span&gt;0&lt;/span&gt;);&lt;br/&gt;&lt;span&gt;if&lt;/span&gt; (ret &amp;gt;= &lt;span&gt;0&lt;/span&gt;){&lt;br/&gt;&lt;span&gt;//wait success                    &lt;/span&gt;&lt;br/&gt;&lt;span&gt;printf&lt;/span&gt;(&lt;span&gt;&quot;wait child success...\n&quot;&lt;/span&gt;);&lt;br/&gt;&lt;span&gt;if&lt;/span&gt; (WIFEXITED(status)){&lt;br/&gt;&lt;span&gt;//exit normal                                 &lt;/span&gt;&lt;br/&gt;&lt;span&gt;printf&lt;/span&gt;(&lt;span&gt;&quot;exit code:%d\n&quot;&lt;/span&gt;, WEXITSTATUS(status));&lt;br/&gt;}&lt;br/&gt;&lt;span&gt;else&lt;/span&gt;{&lt;br/&gt;&lt;span&gt;//signal killed                              &lt;/span&gt;&lt;br/&gt;&lt;span&gt;printf&lt;/span&gt;(&lt;span&gt;&quot;killed by siganl %d\n&quot;&lt;/span&gt;, status &amp;amp; &lt;span&gt;0x7F&lt;/span&gt;);&lt;br/&gt;}&lt;br/&gt;}&lt;br/&gt;sleep(&lt;span&gt;3&lt;/span&gt;);&lt;br/&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;;&lt;br/&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-track=&quot;186&quot;&gt;&lt;span&gt;在父进程运行过程中，我们可以尝试使用kill -9命令将子进程杀死，这时父进程也能等待子进程成功。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.4409282700421941&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/icRxcMBeJfc9llX5bCjZubbh0woHLt8e03ibAmtxNL98yoBzUScIm81XznaMk20FrwNWlqTKX8VBpvV2LDYCRPMg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1896&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p data-track=&quot;187&quot;&gt;&lt;span&gt;&lt;span&gt;注意：&lt;/span&gt;&lt;span&gt; 被信号杀死而退出的进程，其退出码将没有意义。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;h1 data-track=&quot;188&quot;&gt;&lt;span&gt;多进程创建以及等待的代码模型&lt;/span&gt;&lt;/h1&gt;&lt;p data-track=&quot;189&quot;&gt;&lt;span&gt;上面演示的都是父进程创建以及等待一个子进程的例子，实际上我们还可以同时创建多个子进程，然后让父进程依次等待子进程退出，这叫做多进程创建以及等待的代码模型。&lt;/span&gt;&lt;/p&gt;&lt;p data-track=&quot;190&quot;&gt;&lt;span&gt;例如，以下代码中同时创建了10个子进程，同时将子进程的pid放入到ids数组当中，并将这10个子进程退出时的退出码设置为该子进程pid在数组ids中的下标，之后父进程再使用waitpid函数指定等待这10个子进程。&lt;/span&gt;&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;#include &amp;lt;stdio.h&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;#include &amp;lt;stdlib.h&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;#include &amp;lt;unistd.h&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;#include &amp;lt;sys/types.h&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;#include &amp;lt;sys/wait.h&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;int main()&lt;br/&gt;&lt;/span&gt;{&lt;br/&gt;&lt;span&gt;pid_t&lt;/span&gt; ids[&lt;span&gt;10&lt;/span&gt;];&lt;br/&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; &lt;span&gt;10&lt;/span&gt;; i++){&lt;br/&gt;&lt;span&gt;pid_t&lt;/span&gt; id = fork();&lt;br/&gt;&lt;span&gt;if&lt;/span&gt; (id == &lt;span&gt;0&lt;/span&gt;){&lt;br/&gt;&lt;span&gt;//child&lt;/span&gt;&lt;br/&gt;&lt;span&gt;printf&lt;/span&gt;(&lt;span&gt;&quot;child process created successfully...PID:%d\n&quot;&lt;/span&gt;, getpid());&lt;br/&gt;sleep(&lt;span&gt;3&lt;/span&gt;);&lt;br/&gt;&lt;span&gt;exit&lt;/span&gt;(i); &lt;span&gt;//将子进程的退出码设置为该子进程PID在数组ids中的下标&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;span&gt;//father&lt;/span&gt;&lt;br/&gt;ids[i] = id;&lt;br/&gt;}&lt;br/&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; &lt;span&gt;10&lt;/span&gt;; i++){&lt;br/&gt;&lt;span&gt;int&lt;/span&gt; status = &lt;span&gt;0&lt;/span&gt;;&lt;br/&gt;&lt;span&gt;pid_t&lt;/span&gt; ret = waitpid(ids[i], &amp;amp;status, &lt;span&gt;0&lt;/span&gt;);&lt;br/&gt;&lt;span&gt;if&lt;/span&gt; (ret &amp;gt;= &lt;span&gt;0&lt;/span&gt;){&lt;br/&gt;&lt;span&gt;//wait child success&lt;/span&gt;&lt;br/&gt;&lt;span&gt;printf&lt;/span&gt;(&lt;span&gt;&quot;wiat child success..PID:%d\n&quot;&lt;/span&gt;, ids[i]);&lt;br/&gt;&lt;span&gt;if&lt;/span&gt; (WIFEXITED(status)){&lt;br/&gt;&lt;span&gt;//exit normal&lt;/span&gt;&lt;br/&gt;&lt;span&gt;printf&lt;/span&gt;(&lt;span&gt;&quot;exit code:%d\n&quot;&lt;/span&gt;, WEXITSTATUS(status));&lt;br/&gt;}&lt;br/&gt;&lt;span&gt;else&lt;/span&gt;{&lt;br/&gt;&lt;span&gt;//signal killed&lt;/span&gt;&lt;br/&gt;&lt;span&gt;printf&lt;/span&gt;(&lt;span&gt;&quot;killed by signal %d\n&quot;&lt;/span&gt;, status &amp;amp; &lt;span&gt;0x7F&lt;/span&gt;);&lt;br/&gt;}&lt;br/&gt;}&lt;br/&gt;}&lt;br/&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;;&lt;br/&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-track=&quot;194&quot;&gt;&lt;span&gt;运行代码，这时我们便可以看到父进程同时创建多个子进程，当子进程退出后，父进程再依次读取这些子进程的退出信息。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5123495883470551&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/icRxcMBeJfc9llX5bCjZubbh0woHLt8e0iaGafSPUtJvspJ7bJXSaCC9hCeV5y6qf94ApXo1PhcI6YMPicZfhOYdw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1579&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;h1 data-track=&quot;195&quot;&gt;&lt;span&gt;基于非阻塞接口的轮询检测方案&lt;/span&gt;&lt;/h1&gt;&lt;p data-track=&quot;196&quot;&gt;&lt;span&gt;上述所给例子中，当子进程未退出时，父进程都在一直等待子进程退出，在等待期间，父进程不能做任何事情，这种等待叫做阻塞等待。&lt;/span&gt;&lt;/p&gt;&lt;p data-track=&quot;197&quot;&gt;&lt;span&gt;实际上我们可以让父进程不要一直等待子进程退出，而是当子进程未退出时父进程可以做一些自己的事情，当子进程退出时再读取子进程的退出信息，即非阻塞等待。&lt;/span&gt;&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;&lt;span&gt;做法很简单，向waitpid函数的第三个参数potions传入WNOHANG，这样一来，等待的子进程若是没有结束，那么waitpid函数将直接返回0，不予以等待。而等待的子进程若是正常结束，则返回该子进程的pid。&lt;/span&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-track=&quot;199&quot;&gt;&lt;span&gt;例如，父进程可以隔一段时间调用一次waitpid函数，若是等待的子进程尚未退出，则父进程可以先去做一些其他事，过一段时间再调用waitpid函数读取子进程的退出信息。&lt;/span&gt;&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;#include &amp;lt;stdio.h&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;#include &amp;lt;stdlib.h&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;#include &amp;lt;unistd.h&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;#include &amp;lt;sys/types.h&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;#include &amp;lt;sys/wait.h&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;int main()&lt;br/&gt;&lt;/span&gt;{&lt;br/&gt;&lt;span&gt;pid_t&lt;/span&gt; id = fork();&lt;br/&gt;&lt;span&gt;if&lt;/span&gt; (id == &lt;span&gt;0&lt;/span&gt;){&lt;br/&gt;&lt;span&gt;//child&lt;/span&gt;&lt;br/&gt;&lt;span&gt;int&lt;/span&gt; count = &lt;span&gt;3&lt;/span&gt;;&lt;br/&gt;&lt;span&gt;while&lt;/span&gt; (count--){&lt;br/&gt;&lt;span&gt;printf&lt;/span&gt;(&lt;span&gt;&quot;child do something...PID:%d, PPID:%d\n&quot;&lt;/span&gt;, getpid(), getppid());&lt;br/&gt;sleep(&lt;span&gt;3&lt;/span&gt;);&lt;br/&gt;}&lt;br/&gt;&lt;span&gt;exit&lt;/span&gt;(&lt;span&gt;0&lt;/span&gt;);&lt;br/&gt;}&lt;br/&gt;&lt;span&gt;//father&lt;/span&gt;&lt;br/&gt;&lt;span&gt;while&lt;/span&gt; (&lt;span&gt;1&lt;/span&gt;){&lt;br/&gt;&lt;span&gt;int&lt;/span&gt; status = &lt;span&gt;0&lt;/span&gt;;&lt;br/&gt;&lt;span&gt;pid_t&lt;/span&gt; ret = waitpid(id, &amp;amp;status, WNOHANG);&lt;br/&gt;&lt;span&gt;if&lt;/span&gt; (ret &amp;gt; &lt;span&gt;0&lt;/span&gt;){&lt;br/&gt;&lt;span&gt;printf&lt;/span&gt;(&lt;span&gt;&quot;wait child success...\n&quot;&lt;/span&gt;);&lt;br/&gt;&lt;span&gt;printf&lt;/span&gt;(&lt;span&gt;&quot;exit code:%d\n&quot;&lt;/span&gt;, WEXITSTATUS(status));&lt;br/&gt;&lt;span&gt;break&lt;/span&gt;;&lt;br/&gt;}&lt;br/&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (ret == &lt;span&gt;0&lt;/span&gt;){&lt;br/&gt;&lt;span&gt;printf&lt;/span&gt;(&lt;span&gt;&quot;father do other things...\n&quot;&lt;/span&gt;);&lt;br/&gt;sleep(&lt;span&gt;1&lt;/span&gt;);&lt;br/&gt;}&lt;br/&gt;&lt;span&gt;else&lt;/span&gt;{&lt;br/&gt;&lt;span&gt;printf&lt;/span&gt;(&lt;span&gt;&quot;waitpid error...\n&quot;&lt;/span&gt;);&lt;br/&gt;&lt;span&gt;break&lt;/span&gt;;&lt;br/&gt;}&lt;br/&gt;}&lt;br/&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;;&lt;br/&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-track=&quot;204&quot;&gt;&lt;span&gt;运行结果就是，父进程每隔一段时间就去查看子进程是否退出，若未退出，则父进程先去忙自己的事情，过一段时间再来查看，直到子进程退出后读取子进程的退出信息。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.3833910034602076&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/icRxcMBeJfc9llX5bCjZubbh0woHLt8e0LwDjs9ribo3KkVklQXlL1PwO5PW4al18gZzticKNvQN37UZ13ic6wTkgA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1445&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;h1 data-track=&quot;205&quot;&gt;&lt;span&gt;四、进程程序替换&lt;/span&gt;&lt;/h1&gt;&lt;h1 data-track=&quot;206&quot;&gt;&lt;span&gt;替换原理&lt;/span&gt;&lt;/h1&gt;&lt;p data-track=&quot;207&quot;&gt;&lt;span&gt;用fork创建子进程后，子进程执行的是和父进程相同的程序（但有可能执行不同的代码分支），若想让子进程执行另一个程序，往往需要调用一种exec函数。&lt;/span&gt;&lt;/p&gt;&lt;p data-track=&quot;208&quot;&gt;&lt;span&gt;当进程调用一种exec函数时，该进程的用户空间代码和数据完全被新程序替换，并从新程序的启动例程开始执行。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.3689095127610209&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/icRxcMBeJfc9llX5bCjZubbh0woHLt8e0u3XQfG9hNQBPTWDKVrUwBVPvyHwNsHbDbFFP4AU6hYe0a8PLpPMzhw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1293&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;&lt;span&gt;当进行进程程序替换时，有没有创建新的进程？&lt;/span&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-track=&quot;216&quot;&gt;&lt;span&gt;进程程序替换之后，该进程对应的PCB、进程地址空间以及页表等数据结构都没有发生改变，只是进程在物理内存当中的数据和代码发生了改变，所以并没有创建新的进程，而且进程程序替换前后该进程的pid并没有改变。&lt;/span&gt;&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;&lt;span&gt;子进程进行进程程序替换后，会影响父进程的代码和数据吗？&lt;/span&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-track=&quot;223&quot;&gt;&lt;span&gt;子进程刚被创建时，与父进程共享代码和数据，但当子进程需要进行进程程序替换时，也就意味着子进程需要对其数据和代码进行写入操作，这时便需要将父子进程共享的代码和数据进行写时拷贝，此后父子进程的代码和数据也就分离了，因此子进程进行程序替换后不会影响父进程的代码和数据。&lt;/span&gt;&lt;/p&gt;&lt;h1 data-track=&quot;225&quot;&gt;&lt;span&gt;替换函数&lt;/span&gt;&lt;/h1&gt;&lt;p data-track=&quot;226&quot;&gt;&lt;span&gt;替换函数有六种以exec开头的函数，它们统称为exec函数：&lt;/span&gt;&lt;/p&gt;&lt;p data-track=&quot;231&quot;&gt;&lt;span&gt;一、int execl(const char *path, const char *arg, ...);&lt;/span&gt;&lt;/p&gt;&lt;p data-track=&quot;232&quot;&gt;&lt;span&gt;第一个参数是要执行程序的路径，第二个参数是可变参数列表，表示你要如何执行这个程序，并以NULL结尾。&lt;/span&gt;&lt;/p&gt;&lt;p data-track=&quot;233&quot;&gt;&lt;span&gt;例如，要执行的是ls程序。&lt;/span&gt;&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;execl(&lt;span&gt;&quot;/usr/bin/ls&quot;&lt;/span&gt;, &lt;span&gt;&quot;ls&quot;&lt;/span&gt;, &lt;span&gt;&quot;-a&quot;&lt;/span&gt;, &lt;span&gt;&quot;-i&quot;&lt;/span&gt;, &lt;span&gt;&quot;-l&quot;&lt;/span&gt;, &lt;span&gt;NULL&lt;/span&gt;);&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-track=&quot;236&quot;&gt;&lt;span&gt;二、int execlp(const char *file, const char *arg, ...);&lt;/span&gt;&lt;/p&gt;&lt;p data-track=&quot;237&quot;&gt;&lt;span&gt;第一个参数是要执行程序的名字，第二个参数是可变参数列表，表示你要如何执行这个程序，并以NULL结尾。&lt;/span&gt;&lt;/p&gt;&lt;p data-track=&quot;238&quot;&gt;&lt;span&gt;例如，要执行的是ls程序。&lt;/span&gt;&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;execlp(&lt;span&gt;&quot;ls&quot;&lt;/span&gt;, &lt;span&gt;&quot;ls&quot;&lt;/span&gt;, &lt;span&gt;&quot;-a&quot;&lt;/span&gt;, &lt;span&gt;&quot;-i&quot;&lt;/span&gt;, &lt;span&gt;&quot;-l&quot;&lt;/span&gt;, &lt;span&gt;NULL&lt;/span&gt;);&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-track=&quot;241&quot;&gt;&lt;span&gt;三、int execle(const char *path, const char *arg, ..., char *const envp[]);&lt;/span&gt;&lt;/p&gt;&lt;p data-track=&quot;242&quot;&gt;&lt;span&gt;第一个参数是要执行程序的路径，第二个参数是可变参数列表，表示你要如何执行这个程序，并以NULL结尾，第三个参数是你自己设置的环境变量。&lt;/span&gt;&lt;/p&gt;&lt;p data-track=&quot;243&quot;&gt;&lt;span&gt;例如，你设置了MYVAL环境变量，在mycmd程序内部就可以使用该环境变量。&lt;/span&gt;&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;char&lt;/span&gt;* myenvp[] = { &lt;span&gt;&quot;MYVAL=2021&quot;&lt;/span&gt;, &lt;span&gt;NULL&lt;/span&gt; };&lt;br/&gt;execle(&lt;span&gt;&quot;./mycmd&quot;&lt;/span&gt;, &lt;span&gt;&quot;mycmd&quot;&lt;/span&gt;, &lt;span&gt;NULL&lt;/span&gt;, myenvp);&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-track=&quot;248&quot;&gt;&lt;span&gt;四、int execv(const char *path, char *const argv[]);&lt;/span&gt;&lt;/p&gt;&lt;p data-track=&quot;249&quot;&gt;&lt;span&gt;第一个参数是要执行程序的路径，第二个参数是一个指针数组，数组当中的内容表示你要如何执行这个程序，数组以NULL结尾。&lt;/span&gt;&lt;/p&gt;&lt;p data-track=&quot;250&quot;&gt;&lt;span&gt;例如，要执行的是ls程序。&lt;/span&gt;&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;char&lt;/span&gt;* myargv[] = { &lt;span&gt;&quot;ls&quot;&lt;/span&gt;, &lt;span&gt;&quot;-a&quot;&lt;/span&gt;, &lt;span&gt;&quot;-i&quot;&lt;/span&gt;, &lt;span&gt;&quot;-l&quot;&lt;/span&gt;, &lt;span&gt;NULL&lt;/span&gt; };&lt;br/&gt;execv(&lt;span&gt;&quot;/usr/bin/ls&quot;&lt;/span&gt;, myargv);&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-track=&quot;255&quot;&gt;&lt;span&gt;五、int execvp(const char *file, char *const argv[]);&lt;/span&gt;&lt;/p&gt;&lt;p data-track=&quot;256&quot;&gt;&lt;span&gt;第一个参数是要执行程序的名字，第二个参数是一个指针数组，数组当中的内容表示你要如何执行这个程序，数组以NULL结尾。&lt;/span&gt;&lt;/p&gt;&lt;p data-track=&quot;257&quot;&gt;&lt;span&gt;例如，要执行的是ls程序。&lt;/span&gt;&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;char&lt;/span&gt;* myargv[] = { &lt;span&gt;&quot;ls&quot;&lt;/span&gt;, &lt;span&gt;&quot;-a&quot;&lt;/span&gt;, &lt;span&gt;&quot;-i&quot;&lt;/span&gt;, &lt;span&gt;&quot;-l&quot;&lt;/span&gt;, &lt;span&gt;NULL&lt;/span&gt; };&lt;br/&gt;execvp(&lt;span&gt;&quot;ls&quot;&lt;/span&gt;, myargv);&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-track=&quot;262&quot;&gt;&lt;span&gt;六、int execve(const char *path, char *const argv[], char *const envp[]);&lt;/span&gt;&lt;/p&gt;&lt;p data-track=&quot;263&quot;&gt;&lt;span&gt;第一个参数是要执行程序的路径，第二个参数是一个指针数组，数组当中的内容表示你要如何执行这个程序，数组以NULL结尾，第三个参数是你自己设置的环境变量。&lt;/span&gt;&lt;/p&gt;&lt;p data-track=&quot;264&quot;&gt;&lt;span&gt;例如，你设置了MYVAL环境变量，在mycmd程序内部就可以使用该环境变量。&lt;/span&gt;&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;char&lt;/span&gt;* myargv[] = { &lt;span&gt;&quot;mycmd&quot;&lt;/span&gt;, &lt;span&gt;NULL&lt;/span&gt; };&lt;br/&gt;&lt;span&gt;char&lt;/span&gt;* myenvp[] = { &lt;span&gt;&quot;MYVAL=2021&quot;&lt;/span&gt;, &lt;span&gt;NULL&lt;/span&gt; };&lt;br/&gt;execve(&lt;span&gt;&quot;./mycmd&quot;&lt;/span&gt;, myargv, myenvp);&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h1 data-track=&quot;268&quot;&gt;&lt;span&gt;函数解释&lt;/span&gt;&lt;/h1&gt;&lt;p data-track=&quot;273&quot;&gt;&lt;span&gt;也就是说，exec系列函数只要返回了，就意味着调用失败。&lt;/span&gt;&lt;/p&gt;&lt;h1&gt;&lt;span&gt;命名理解&lt;/span&gt;&lt;/h1&gt;&lt;p data-track=&quot;275&quot;&gt;&lt;span&gt;这六个exec系列函数的函数名都以exec开头，其后缀的含义如下：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.2793103448275862&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/icRxcMBeJfc9llX5bCjZubbh0woHLt8e0slsVoorNCQhtSGTSKjpAYC5DeIEJXDwunraibjQoWk3GjJUA98GYHMg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;870&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p data-track=&quot;284&quot;&gt;&lt;span&gt;事实上，只有execve才是真正的系统调用，其它五个函数最终都是调用的execve，所以execve在man手册的第2节，而其它五个函数在man手册的第3节，也就是说其他五个函数实际上是对系统调用execve进行了封装，以满足不同用户的不同调用场景的。&lt;/span&gt;&lt;/p&gt;&lt;p data-track=&quot;285&quot;&gt;&lt;span&gt;下图为exec系列函数族之间的关系：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.33580018501387604&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/icRxcMBeJfc9llX5bCjZubbh0woHLt8e0HbiaE9pNhSo6Oenw2dCIKfHnAVkvLLDeNCQI4uyoGmLt9AIhhyGxpqw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1081&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;h1 data-track=&quot;289&quot;&gt;&lt;span&gt;做一个简易的shell&lt;/span&gt;&lt;/h1&gt;&lt;p data-track=&quot;290&quot;&gt;&lt;span&gt;shell也就是命令行解释器，其运行原理就是：当有命令需要执行时，shell创建子进程，让子进程执行命令，而shell只需等待子进程退出即可。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.18407212622088656&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/icRxcMBeJfc9llX5bCjZubbh0woHLt8e0sibpnhMDzXIRK3EsCqMyCDYjHGL9wVakZibGZz4TeicBGwY9qL4b7faFQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1331&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;其实shell需要执行的逻辑非常简单，其只需循环执行以下步骤：&lt;/span&gt;&lt;/p&gt;&lt;ol start=&quot;1&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;获取命令行。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;解析命令行。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;创建子进程。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;替换子进程。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;等待子进程退出。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-track=&quot;299&quot;&gt;&lt;span&gt;其中，创建子进程使用fork函数，替换子进程使用exec系列函数，等待子进程使用wait或者waitpid函数。&lt;/span&gt;&lt;/p&gt;&lt;p data-track=&quot;300&quot;&gt;&lt;span&gt;于是我们可以很容易实现一个简易的shell，代码如下：&lt;/span&gt;&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;#include &amp;lt;stdio.h&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;#include &amp;lt;pwd.h&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;#include &amp;lt;string.h&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;#include &amp;lt;unistd.h&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;#include &amp;lt;stdlib.h&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;#include &amp;lt;sys/types.h&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;#include &amp;lt;sys/wait.h&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;#define LEN 1024 //命令最大长度&lt;/span&gt;&lt;br/&gt;&lt;span&gt;#define NUM 32 //命令拆分后的最大个数&lt;/span&gt;&lt;br/&gt;&lt;span&gt;int main()&lt;br/&gt;&lt;/span&gt;{&lt;br/&gt;&lt;span&gt;char&lt;/span&gt; cmd[LEN]; &lt;span&gt;//存储命令&lt;/span&gt;&lt;br/&gt;&lt;span&gt;char&lt;/span&gt;* myargv[NUM]; &lt;span&gt;//存储命令拆分后的结果&lt;/span&gt;&lt;br/&gt;&lt;span&gt;char&lt;/span&gt; hostname[&lt;span&gt;32&lt;/span&gt;]; &lt;span&gt;//主机名&lt;/span&gt;&lt;br/&gt;&lt;span&gt;char&lt;/span&gt; pwd[&lt;span&gt;128&lt;/span&gt;]; &lt;span&gt;//当前目录&lt;/span&gt;&lt;br/&gt;&lt;span&gt;while&lt;/span&gt; (&lt;span&gt;1&lt;/span&gt;){&lt;br/&gt;&lt;span&gt;//获取命令提示信息&lt;/span&gt;&lt;br/&gt;&lt;span&gt;struct passwd* pass = getpwuid(getuid());&lt;/span&gt;&lt;br/&gt;gethostname(hostname, &lt;span&gt;sizeof&lt;/span&gt;(hostname)&lt;span&gt;-1&lt;/span&gt;);&lt;br/&gt;getcwd(pwd, &lt;span&gt;sizeof&lt;/span&gt;(pwd)&lt;span&gt;-1&lt;/span&gt;);&lt;br/&gt;&lt;span&gt;int&lt;/span&gt; len = &lt;span&gt;strlen&lt;/span&gt;(pwd);&lt;br/&gt;&lt;span&gt;char&lt;/span&gt;* p = pwd + len - &lt;span&gt;1&lt;/span&gt;;&lt;br/&gt;&lt;span&gt;while&lt;/span&gt; (*p != &lt;span&gt;&#x27;/&#x27;&lt;/span&gt;){&lt;br/&gt;p--;&lt;br/&gt;}&lt;br/&gt;p++;&lt;br/&gt;&lt;span&gt;//打印命令提示信息&lt;/span&gt;&lt;br/&gt;&lt;span&gt;printf&lt;/span&gt;(&lt;span&gt;&quot;[%s@%s %s]$ &quot;&lt;/span&gt;, pass-&amp;gt;pw_name, hostname, p);&lt;br/&gt;&lt;span&gt;//读取命令&lt;/span&gt;&lt;br/&gt;fgets(cmd, LEN, &lt;span&gt;stdin&lt;/span&gt;);&lt;br/&gt;cmd[&lt;span&gt;strlen&lt;/span&gt;(cmd) - &lt;span&gt;1&lt;/span&gt;] = &lt;span&gt;&#x27;\0&#x27;&lt;/span&gt;;&lt;br/&gt;&lt;span&gt;//拆分命令&lt;/span&gt;&lt;br/&gt;myargv[&lt;span&gt;0&lt;/span&gt;] = strtok(cmd, &lt;span&gt;&quot; &quot;&lt;/span&gt;);&lt;br/&gt;&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;1&lt;/span&gt;;&lt;br/&gt;&lt;span&gt;while&lt;/span&gt; (myargv[i] = strtok(&lt;span&gt;NULL&lt;/span&gt;, &lt;span&gt;&quot; &quot;&lt;/span&gt;)){&lt;br/&gt;i++;&lt;br/&gt;}&lt;br/&gt;&lt;span&gt;pid_t&lt;/span&gt; id = fork(); &lt;span&gt;//创建子进程执行命令&lt;/span&gt;&lt;br/&gt;&lt;span&gt;if&lt;/span&gt; (id == &lt;span&gt;0&lt;/span&gt;){&lt;br/&gt;&lt;span&gt;//child&lt;/span&gt;&lt;br/&gt;execvp(myargv[&lt;span&gt;0&lt;/span&gt;], myargv); &lt;span&gt;//child进行程序替换&lt;/span&gt;&lt;br/&gt;&lt;span&gt;exit&lt;/span&gt;(&lt;span&gt;1&lt;/span&gt;); &lt;span&gt;//替换失败的退出码设置为1&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;span&gt;//shell&lt;/span&gt;&lt;br/&gt;&lt;span&gt;int&lt;/span&gt; status = &lt;span&gt;0&lt;/span&gt;;&lt;br/&gt;&lt;span&gt;pid_t&lt;/span&gt; ret = waitpid(id, &amp;amp;status, &lt;span&gt;0&lt;/span&gt;); &lt;span&gt;//shell等待child退出&lt;/span&gt;&lt;br/&gt;&lt;span&gt;if&lt;/span&gt; (ret &amp;gt; &lt;span&gt;0&lt;/span&gt;){&lt;br/&gt;&lt;span&gt;printf&lt;/span&gt;(&lt;span&gt;&quot;exit code:%d\n&quot;&lt;/span&gt;, WEXITSTATUS(status)); &lt;span&gt;//打印child的退出码&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;}&lt;br/&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;;&lt;br/&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-track=&quot;302&quot;&gt;&lt;span&gt;效果展示：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.42526315789473684&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/icRxcMBeJfc9llX5bCjZubbh0woHLt8e0RHAwr06icPv20OE9sWeDiaseeSXyLiaTDfDOfMbMaMWdk2GzhZI1JicqUw/640?wx_fmt=gif&quot; data-type=&quot;gif&quot; data-w=&quot;1900&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;说明：&lt;/span&gt;&lt;/p&gt;&lt;p data-track=&quot;304&quot;&gt;&lt;span&gt;&lt;span&gt;当执行&lt;/span&gt;&lt;span&gt;./myshell&lt;/span&gt;&lt;span&gt;命令后，便是我们自己实现的shell在进行命令行解释，我们自己实现的shell在子进程退出后都打印了子进程的退出码，我们可以根据这一点来区分我们当前使用的是Linux操作系统的shell还是我们自己实现的shell。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;- EOF -&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section mp-original-font-size=&quot;16&quot; mp-original-line-height=&quot;25.600000381469727&quot;&gt;&lt;section mp-original-font-size=&quot;16&quot; mp-original-line-height=&quot;25.600000381469727&quot;&gt;&lt;section mp-original-font-size=&quot;16&quot; mp-original-line-height=&quot;25.600000381469727&quot;&gt;&lt;section mp-original-font-size=&quot;16&quot; mp-original-line-height=&quot;25.600000381469727&quot;&gt;&lt;section mp-original-font-size=&quot;16&quot; mp-original-line-height=&quot;25.600000381469727&quot;&gt;&lt;section mp-original-font-size=&quot;16&quot; mp-original-line-height=&quot;25.600000381469727&quot;&gt;&lt;section mp-original-font-size=&quot;16&quot; mp-original-line-height=&quot;25.600000381469727&quot;&gt;&lt;section mp-original-font-size=&quot;16&quot; mp-original-line-height=&quot;8&quot;&gt;&lt;section mp-original-font-size=&quot;16&quot; mp-original-line-height=&quot;8&quot;&gt;&lt;section mp-original-font-size=&quot;16&quot; mp-original-line-height=&quot;0&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1&quot; data-type=&quot;svg&quot; data-w=&quot;150&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_svg/SQd7RF5caa2sRkiaG4Lib8FHMVW1Ne13lrN37SiaB2ibEDF4OD31Vxh71vWXuOC2VaWME2CltDJsGdA5LnsdhdJianUR3GkoXe1Nx/640?wx_fmt=svg&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section mp-original-font-size=&quot;16&quot; mp-original-line-height=&quot;25.600000381469727&quot;&gt;&lt;section mp-original-font-size=&quot;15&quot; mp-original-line-height=&quot;30&quot;&gt;&lt;p mp-original-font-size=&quot;15&quot; mp-original-line-height=&quot;30&quot;&gt;&lt;strong mp-original-font-size=&quot;15&quot; mp-original-line-height=&quot;30&quot;&gt;加主页君微信，不仅Linux技能+1&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section mp-original-font-size=&quot;16&quot; mp-original-line-height=&quot;0&quot;&gt;&lt;section mp-original-font-size=&quot;16&quot; mp-original-line-height=&quot;0&quot;&gt;&lt;section mp-original-font-size=&quot;16&quot; mp-original-line-height=&quot;8&quot;&gt;&lt;section mp-original-font-size=&quot;16&quot; mp-original-line-height=&quot;8&quot;&gt;&lt;section mp-original-font-size=&quot;16&quot; mp-original-line-height=&quot;0&quot;&gt;&lt;img data-ratio=&quot;1&quot; data-type=&quot;svg&quot; data-w=&quot;150&quot; class=&quot;rich_pages wxw-img&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_svg/SQd7RF5caa2sRkiaG4Lib8FHMVW1Ne13lr4b5vuiaNBnGZKzQI3kAgC4XOZVFnBxvvrXI2GOpiaH06UjrJSc4fqoPBZDKzPVRicCN/640?wx_fmt=svg&quot;/&gt;&lt;img class=&quot;rich_pages&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.8666666666666667&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;720&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/UzDNI6O6hCFBc2O6VZiaHtzQn9pYBAmTD9EaEHCDBLkxE8Pln85fKLpIy3sRib8FX0Lzoagbs8TYxC5aAgTubZyw/640?wx_fmt=png&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section mp-original-font-size=&quot;16&quot; mp-original-line-height=&quot;25.600000381469727&quot;&gt;&lt;section mp-original-font-size=&quot;16&quot; mp-original-line-height=&quot;25.600000381469727&quot;&gt;&lt;section mp-original-font-size=&quot;16&quot; mp-original-line-height=&quot;25.600000381469727&quot;&gt;&lt;section mp-original-font-size=&quot;15&quot; mp-original-line-height=&quot;24&quot;&gt;&lt;p mp-original-font-size=&quot;15&quot; mp-original-line-height=&quot;24&quot;&gt;主页君日常还会在个人微信分享&lt;span&gt;&lt;strong&gt;Linux相关&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;&lt;strong&gt;工具&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;&lt;strong&gt;、&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;&lt;strong&gt;资源&lt;/strong&gt;&lt;/span&gt;和&lt;strong&gt;精选&lt;/strong&gt;&lt;span&gt;&lt;strong&gt;技术文章&lt;/strong&gt;&lt;/span&gt;，不定期分享一些&lt;span&gt;&lt;strong&gt;有意思的活动&lt;/strong&gt;&lt;/span&gt;、&lt;span&gt;&lt;strong&gt;岗位内推&lt;/strong&gt;&lt;/span&gt;以及&lt;span&gt;&lt;strong&gt;如何用技术做业余项目&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section mp-original-font-size=&quot;15&quot; mp-original-line-height=&quot;24&quot;&gt;&lt;p mp-original-font-size=&quot;15&quot; mp-original-line-height=&quot;24&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;147&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;147&quot; data-galleryid=&quot;&quot; data-ratio=&quot;1&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/9aPYe0E1fb19JTKibRMq2ZEp7XsU1dfgNDoHYFn1ic1ibOHjHFlADWjicibkZgL5XG60vbokfpic28IfLUe3Lj6k2uzQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;512&quot;/&gt;&lt;/p&gt;&lt;p mp-original-font-size=&quot;15&quot; mp-original-line-height=&quot;24&quot;&gt;&lt;span&gt;加个微信，打开一扇窗&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;section donone=&quot;shifuMouseDownCard(&#x27;shifu_c_030&#x27;)&quot; label=&quot;Copyright Reserved by PLAYHUDONG.&quot;&gt;&lt;section&gt;&lt;span&gt;推荐阅读&lt;/span&gt;  &lt;span&gt;点击标题可跳转&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;p&gt;&lt;span&gt;1、&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzAxODI5ODMwOA==&amp;amp;mid=2666567079&amp;amp;idx=1&amp;amp;sn=f1ed714a027ef6d4e9c75c4295039569&amp;amp;chksm=80dc510cb7abd81ab64760672bb675781350fc46c6c44d745101413d86e72691eebcce590219&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;全新 QQ Linux 3.0 正式上线&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;全新 QQ Linux 3.0 正式上线&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;2、&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzAxODI5ODMwOA==&amp;amp;mid=2666566845&amp;amp;idx=2&amp;amp;sn=979c6e1eea65a136422631be10ef36f9&amp;amp;chksm=80dc5016b7abd9008aaeadf6968af66e48a6d7e5212c870255b130b677ba6be7d30ff993493e&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;关于 Linux 下的 crontab，你不知道的那些知识点&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;关于 Linux 下的 crontab，你不知道的那些知识点&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;3、&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzAxODI5ODMwOA==&amp;amp;mid=2666566701&amp;amp;idx=1&amp;amp;sn=52030d2c01931983799969c7b426a888&amp;amp;chksm=80dc5086b7abd990467fa3af5069cab32e0a4e0b993620f003b1f7f9c3f9b9f47c86e922ba84&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;16 张图硬核讲解 Kubernetes 网络&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;16 张图硬核讲解 Kubernetes 网络&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;看完&lt;/span&gt;&lt;span&gt;本文有收获？请分享给更多人&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;推荐关注「Linux 爱好者」，提升Linux技能&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;mp-common-profile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-id=&quot;MzAxODI5ODMwOA==&quot; data-pluginname=&quot;mpprofile&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/9aPYe0E1fb3sjicd8JxDra10FRIqT54Zke2sfhibTDdtdnVhv5Qh3wLHZmKPjiaD7piahMAzIH6Cnltd1Nco17Ihjw/0?wx_fmt=png&quot; data-nickname=&quot;Linux爱好者&quot; data-alias=&quot;LinuxHub&quot; data-signature=&quot;点击获取《每天一个Linux命令》系列和精选Linux技术资源。「Linux爱好者」日常分享 Linux/Unix 相关内容，包括：工具资源、使用技巧、课程书籍等。&quot; data-from=&quot;0&quot; data-is_biz_ban=&quot;0&quot; data-weui-theme=&quot;light&quot;/&gt;&lt;/section&gt;&lt;p&gt;&lt;span/&gt;&lt;span&gt;点赞和在看就是最大的支持❤️&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;mp-style-type data-value=&quot;3&quot;/&gt;&lt;/p&gt;&lt;/div&gt;

          
        &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>ff0bde726e3a5622def98373f11a0d67</guid>
<title>聊聊使用@RefreshScope与nacos2整合踩到的坑</title>
<link>https://toutiao.io/k/yyocnft</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content js_underline_content             &quot; id=&quot;js_content&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot; data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;img data-ratio=&quot;0.90625&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/W665dT4Q22VeAFzkuQ167BDbRK4SUIL75D5j57hTayQuafoIDfFKUq7XELU5u2KLSsiaDkAic1YQoEk7V8v6tSRg/640?wx_fmt=png&quot; data-w=&quot;64&quot;/&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p data-mid=&quot;&quot;&gt;点击上方&lt;span data-mid=&quot;&quot;&gt;蓝字&lt;/span&gt;关注我们&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p data-mid=&quot;&quot;&gt;1&lt;/p&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p data-mid=&quot;&quot;&gt;&lt;span&gt;前言&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;本文的素材来源于朋友整合nacos2作为配置中心进行动态刷新时，踩到的坑。他当时遇到的问题，如下截图&lt;/span&gt;&lt;br/&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6254901960784314&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/NW0r9OxcmxIVgG66ZroYQwrNibTvYDrvCcP1py1ogD0ahfJxesfhYG321AibUYTwoyicDrHrZYLvEdzncjdtDUMfA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;510&quot;/&gt;&lt;br/&gt;&lt;span&gt;因为那段时间比较忙，于是我在没看朋友项目代码的基础上，就找个了看似解决方案的答案，扔了过去&lt;/span&gt;&lt;br/&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.8086785009861933&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/NW0r9OxcmxIVgG66ZroYQwrNibTvYDrvCZ68cHmEWW3zTGmnKKCTCRqdKkwFj03pWPAcY29La7BD99Ls7DSIaxQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;507&quot;/&gt;&lt;br/&gt;&lt;span&gt;后面朋友加了这个配置，问题果然没有解决。后面就抽了一点时间，要了他的项目代码来看下。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p data-mid=&quot;&quot;&gt;2&lt;/p&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p data-mid=&quot;&quot;&gt;&lt;span&gt;代码示例&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;因为他这个项目主要是他自学nacos的项目，也没涉及啥敏感信息。本文就直接拿他的项目示例演示&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p data-mid=&quot;&quot;&gt;&lt;span&gt;1、项目pom依赖&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-preserve=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;&amp;lt;&lt;span&gt;properties&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    &lt;span&gt;&amp;lt;&lt;span&gt;maven.compiler.source&lt;/span&gt;&amp;gt;&lt;/span&gt;8&lt;span&gt;&amp;lt;/&lt;span&gt;maven.compiler.source&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    &lt;span&gt;&amp;lt;&lt;span&gt;maven.compiler.target&lt;/span&gt;&amp;gt;&lt;/span&gt;8&lt;span&gt;&amp;lt;/&lt;span&gt;maven.compiler.target&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    &lt;span&gt;&amp;lt;&lt;span&gt;java.version&lt;/span&gt;&amp;gt;&lt;/span&gt;1.8&lt;span&gt;&amp;lt;/&lt;span&gt;java.version&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    &lt;span&gt;&amp;lt;&lt;span&gt;spring-boot.version&lt;/span&gt;&amp;gt;&lt;/span&gt;2.3.12.RELEASE&lt;span&gt;&amp;lt;/&lt;span&gt;spring-boot.version&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    &lt;span&gt;&amp;lt;&lt;span&gt;spring-cloud.version&lt;/span&gt;&amp;gt;&lt;/span&gt;Hoxton.SR12&lt;span&gt;&amp;lt;/&lt;span&gt;spring-cloud.version&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    &lt;span&gt;&amp;lt;&lt;span&gt;spring-cloud-alibaba.version&lt;/span&gt;&amp;gt;&lt;/span&gt;2.2.8.RELEASE&lt;span&gt;&amp;lt;/&lt;span&gt;spring-cloud-alibaba.version&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;  &lt;span&gt;&amp;lt;/&lt;span&gt;properties&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;  &lt;span&gt;&amp;lt;&lt;span&gt;dependencies&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    &lt;span&gt;&amp;lt;&lt;span&gt;dependency&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;      &lt;span&gt;&amp;lt;&lt;span&gt;groupId&lt;/span&gt;&amp;gt;&lt;/span&gt;org.springframework.boot&lt;span&gt;&amp;lt;/&lt;span&gt;groupId&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;      &lt;span&gt;&amp;lt;&lt;span&gt;artifactId&lt;/span&gt;&amp;gt;&lt;/span&gt;spring-boot-starter-web&lt;span&gt;&amp;lt;/&lt;span&gt;artifactId&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    &lt;span&gt;&amp;lt;/&lt;span&gt;dependency&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    &lt;span&gt;&amp;lt;&lt;span&gt;dependency&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;      &lt;span&gt;&amp;lt;&lt;span&gt;groupId&lt;/span&gt;&amp;gt;&lt;/span&gt;org.springframework.boot&lt;span&gt;&amp;lt;/&lt;span&gt;groupId&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;      &lt;span&gt;&amp;lt;&lt;span&gt;artifactId&lt;/span&gt;&amp;gt;&lt;/span&gt;spring-boot-starter-test&lt;span&gt;&amp;lt;/&lt;span&gt;artifactId&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;      &lt;span&gt;&amp;lt;&lt;span&gt;scope&lt;/span&gt;&amp;gt;&lt;/span&gt;test&lt;span&gt;&amp;lt;/&lt;span&gt;scope&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    &lt;span&gt;&amp;lt;/&lt;span&gt;dependency&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;  &lt;span&gt;&amp;lt;/&lt;span&gt;dependencies&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;  &lt;span&gt;&amp;lt;&lt;span&gt;dependencyManagement&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    &lt;span&gt;&amp;lt;&lt;span&gt;dependencies&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;      &lt;span&gt;&amp;lt;&lt;span&gt;dependency&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;        &lt;span&gt;&amp;lt;&lt;span&gt;groupId&lt;/span&gt;&amp;gt;&lt;/span&gt;com.alibaba.cloud&lt;span&gt;&amp;lt;/&lt;span&gt;groupId&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;        &lt;span&gt;&amp;lt;&lt;span&gt;artifactId&lt;/span&gt;&amp;gt;&lt;/span&gt;spring-cloud-alibaba-dependencies&lt;span&gt;&amp;lt;/&lt;span&gt;artifactId&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;        &lt;span&gt;&amp;lt;&lt;span&gt;version&lt;/span&gt;&amp;gt;&lt;/span&gt;${spring-cloud-alibaba.version}&lt;span&gt;&amp;lt;/&lt;span&gt;version&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;        &lt;span&gt;&amp;lt;&lt;span&gt;type&lt;/span&gt;&amp;gt;&lt;/span&gt;pom&lt;span&gt;&amp;lt;/&lt;span&gt;type&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;        &lt;span&gt;&amp;lt;&lt;span&gt;scope&lt;/span&gt;&amp;gt;&lt;/span&gt;import&lt;span&gt;&amp;lt;/&lt;span&gt;scope&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;      &lt;span&gt;&amp;lt;/&lt;span&gt;dependency&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;      &lt;span&gt;&amp;lt;&lt;span&gt;dependency&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;        &lt;span&gt;&amp;lt;&lt;span&gt;groupId&lt;/span&gt;&amp;gt;&lt;/span&gt;org.springframework.boot&lt;span&gt;&amp;lt;/&lt;span&gt;groupId&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;        &lt;span&gt;&amp;lt;&lt;span&gt;artifactId&lt;/span&gt;&amp;gt;&lt;/span&gt;spring-boot-dependencies&lt;span&gt;&amp;lt;/&lt;span&gt;artifactId&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;        &lt;span&gt;&amp;lt;&lt;span&gt;version&lt;/span&gt;&amp;gt;&lt;/span&gt;${spring-boot.version}&lt;span&gt;&amp;lt;/&lt;span&gt;version&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;        &lt;span&gt;&amp;lt;&lt;span&gt;type&lt;/span&gt;&amp;gt;&lt;/span&gt;pom&lt;span&gt;&amp;lt;/&lt;span&gt;type&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;        &lt;span&gt;&amp;lt;&lt;span&gt;scope&lt;/span&gt;&amp;gt;&lt;/span&gt;import&lt;span&gt;&amp;lt;/&lt;span&gt;scope&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;      &lt;span&gt;&amp;lt;/&lt;span&gt;dependency&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;      &lt;span&gt;&amp;lt;&lt;span&gt;dependency&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;        &lt;span&gt;&amp;lt;&lt;span&gt;groupId&lt;/span&gt;&amp;gt;&lt;/span&gt;org.springframework.cloud&lt;span&gt;&amp;lt;/&lt;span&gt;groupId&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;        &lt;span&gt;&amp;lt;&lt;span&gt;artifactId&lt;/span&gt;&amp;gt;&lt;/span&gt;spring-cloud-dependencies&lt;span&gt;&amp;lt;/&lt;span&gt;artifactId&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;        &lt;span&gt;&amp;lt;&lt;span&gt;version&lt;/span&gt;&amp;gt;&lt;/span&gt;${spring-cloud.version}&lt;span&gt;&amp;lt;/&lt;span&gt;version&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;        &lt;span&gt;&amp;lt;&lt;span&gt;type&lt;/span&gt;&amp;gt;&lt;/span&gt;pom&lt;span&gt;&amp;lt;/&lt;span&gt;type&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;        &lt;span&gt;&amp;lt;&lt;span&gt;scope&lt;/span&gt;&amp;gt;&lt;/span&gt;import&lt;span&gt;&amp;lt;/&lt;span&gt;scope&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;      &lt;span&gt;&amp;lt;/&lt;span&gt;dependency&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    &lt;span&gt;&amp;lt;/&lt;span&gt;dependencies&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;  &lt;span&gt;&amp;lt;/&lt;span&gt;dependencyManagement&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt; &lt;span&gt;&amp;lt;&lt;span&gt;dependencies&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;        &lt;span&gt;&amp;lt;&lt;span&gt;dependency&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;            &lt;span&gt;&amp;lt;&lt;span&gt;groupId&lt;/span&gt;&amp;gt;&lt;/span&gt;org.springframework.boot&lt;span&gt;&amp;lt;/&lt;span&gt;groupId&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;            &lt;span&gt;&amp;lt;&lt;span&gt;artifactId&lt;/span&gt;&amp;gt;&lt;/span&gt;spring-boot-starter-web&lt;span&gt;&amp;lt;/&lt;span&gt;artifactId&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;        &lt;span&gt;&amp;lt;/&lt;span&gt;dependency&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;        &lt;span&gt;&amp;lt;&lt;span&gt;dependency&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;            &lt;span&gt;&amp;lt;&lt;span&gt;groupId&lt;/span&gt;&amp;gt;&lt;/span&gt;com.alibaba.cloud&lt;span&gt;&amp;lt;/&lt;span&gt;groupId&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;            &lt;span&gt;&amp;lt;&lt;span&gt;artifactId&lt;/span&gt;&amp;gt;&lt;/span&gt;spring-cloud-starter-alibaba-nacos-config&lt;span&gt;&amp;lt;/&lt;span&gt;artifactId&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;        &lt;span&gt;&amp;lt;/&lt;span&gt;dependency&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    &lt;span&gt;&amp;lt;/&lt;span&gt;dependencies&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;注：&lt;/strong&gt;&lt;span&gt; nacos服务端版本为2.1.1&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p data-mid=&quot;&quot;&gt;&lt;span&gt;2、nacos配置中心地址，配置在bootstrap.yml里面&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-preserve=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;spring&lt;/span&gt;:&lt;br mpa-from-tpl=&quot;t&quot;/&gt;  &lt;span&gt;cloud&lt;/span&gt;:&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    &lt;span&gt;nacos&lt;/span&gt;:&lt;br mpa-from-tpl=&quot;t&quot;/&gt;      &lt;span&gt;server-addr&lt;/span&gt;: &lt;span&gt;localhost&lt;/span&gt;:&lt;span&gt;8848&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p data-mid=&quot;&quot;&gt;&lt;span&gt;3、项目的基本信息配置在application.yml里面&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-preserve=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;spring&lt;/span&gt;:&lt;br mpa-from-tpl=&quot;t&quot;/&gt;  &lt;span&gt;application&lt;/span&gt;:&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    &lt;span&gt;name&lt;/span&gt;: nacos-config&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;span&gt;server&lt;/span&gt;:&lt;br mpa-from-tpl=&quot;t&quot;/&gt;  &lt;span&gt;port&lt;/span&gt;: &lt;span&gt;8030&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p data-mid=&quot;&quot;&gt;&lt;span&gt;4、编写一个需要动态刷新获取值的controller&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-preserve=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;@RestController&lt;/span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;span&gt;@RequestMapping&lt;/span&gt;(&lt;span&gt;&quot;/config&quot;&lt;/span&gt;)&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;span&gt;@RefreshScope&lt;/span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;public class ConfigController {&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    &lt;span&gt;@Value&lt;/span&gt;(&lt;span&gt;&quot;${user.userName:123}&quot;&lt;/span&gt;)&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    private String userName;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    &lt;span&gt;@RequestMapping&lt;/span&gt;(&lt;span&gt;&quot;/get&quot;&lt;/span&gt;)&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    private String get(){&lt;br mpa-from-tpl=&quot;t&quot;/&gt;        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;userName&lt;/span&gt;;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    }&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;}&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p data-mid=&quot;&quot;&gt;&lt;span&gt;5、业务项目在nacos服务端上配置如下&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5995955510616785&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/NW0r9OxcmxIVgG66ZroYQwrNibTvYDrvCyX7ZAiblCAqqetOTkQHp3USDhvNZQ25x9FL6NxicbxlKCJkgib3ICrxdQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;989&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;以上就是朋友完整的代码例子。我们运行一下代码，会发现controller的userName取不到值。感兴趣的朋友，可以走查一下上述的代码，查找一下原因&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p data-mid=&quot;&quot;&gt;3&lt;/p&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p data-mid=&quot;&quot;&gt;&lt;span&gt;取不到值的原因&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;理论知识铺垫&lt;/strong&gt;：&lt;/p&gt;&lt;p&gt;当我们使用cglib动态代理调用目标方法时，当方法被private修饰时，this为动态代理对象。当方法被public或者protected修饰时，this为目标对象。此外属性刷新刷的是目标对象的属性，controller的get方法可以看成是&lt;/p&gt;&lt;p&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-preserve=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;@RequestMapping&lt;/span&gt;(&lt;span&gt;&quot;/get&quot;&lt;/span&gt;)&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;String&lt;/span&gt; &lt;span&gt;get&lt;/span&gt;(){&lt;br mpa-from-tpl=&quot;t&quot;/&gt;        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;.userName;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    }&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;当我们在controller加上@RefreshScope注解时，如果不改变变proxyMode这个属性值时，他默认就会生成一个cglib动态代理。当我们调用get方法，因为get为私有方法，我们可以看成&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-preserve=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;@RequestMapping&lt;/span&gt;(&lt;span&gt;&quot;/get&quot;&lt;/span&gt;)&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;String&lt;/span&gt; &lt;span&gt;get&lt;/span&gt;(){&lt;br mpa-from-tpl=&quot;t&quot;/&gt;        &lt;span&gt;return&lt;/span&gt; cglibProxy.userName;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    }&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.34204630321135177&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/NW0r9OxcmxIVgG66ZroYQwrNibTvYDrvCM4bTp9uYSNmZA3ib8ZicvZs0DgBxmgPCGQym5SMJTlmyjqvIqd2QRHuw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1339&quot;/&gt;&lt;br/&gt;&lt;span&gt;此时的this是代理对象，而此时userName是代理对象的userName，代理对象的userName是空值。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p data-mid=&quot;&quot;&gt;4&lt;/p&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p data-mid=&quot;&quot;&gt;&lt;span&gt;解决方法&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p data-mid=&quot;&quot;&gt;&lt;span&gt;方法一、修改@RefreshScope的proxyMode属性&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/p&gt;&lt;p&gt;将proxyMode改为ScopedProxyMode.DEFAULT或者ScopedProxyMode.NO&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5443864229765013&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/NW0r9OxcmxIVgG66ZroYQwrNibTvYDrvCbKOZRic8xS2MIwLNMRwicacTgicUzQCdq3BZw1l2LHtbpXfAvzLATMCug/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;766&quot;/&gt;&lt;br/&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.41214351425942963&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/NW0r9OxcmxIVgG66ZroYQwrNibTvYDrvCYyKRXV0VPZc9u0ChL9eicl4j0Q5V05RovqzbYj1iagJuUicCgqDzFO5GA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1087&quot;/&gt;&lt;br/&gt;此时this为目标对象，因此能取到值&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p data-mid=&quot;&quot;&gt;&lt;span&gt;方法二：将目标方法的修饰符改为public或者protected&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;示例&lt;/strong&gt;：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.7938931297709924&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/NW0r9OxcmxIVgG66ZroYQwrNibTvYDrvCwdEp4C6naKOwDBG4xafG9GB3l2ibC1HwATfUTbguNPFAa0Y6d3UMG7A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;524&quot;/&gt;&lt;br/&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.43756145526057033&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/NW0r9OxcmxIVgG66ZroYQwrNibTvYDrvCzWicmMvQ1JibuB2Tg9PdvRdibgWgpfvdUwiaOzoicIg7CEeSf5VhQCTC1pg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1017&quot;/&gt;&lt;br/&gt;此时this为目标对象，因此能取到值&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p data-mid=&quot;&quot;&gt;&lt;span&gt;&lt;span&gt;3、方法三：使用属性配置类&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-preserve=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;@Configuration&lt;/span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;span&gt;@ConfigurationProperties&lt;/span&gt;(prefix = &lt;span&gt;&quot;user&quot;&lt;/span&gt;)&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; UserProperties {&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;String&lt;/span&gt; userName;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;String&lt;/span&gt; getUserName() {&lt;br mpa-from-tpl=&quot;t&quot;/&gt;        &lt;span&gt;return&lt;/span&gt; userName;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    }&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; setUserName(&lt;span&gt;String&lt;/span&gt; userName) {&lt;br mpa-from-tpl=&quot;t&quot;/&gt;        &lt;span&gt;this&lt;/span&gt;.userName = userName;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    }&lt;br mpa-from-tpl=&quot;t&quot;/&gt;}&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;controller调整成&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-preserve=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;@RestController&lt;/span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;span&gt;@RequestMapping&lt;/span&gt;(&lt;span&gt;&quot;/config&quot;&lt;/span&gt;)&lt;br mpa-from-tpl=&quot;t&quot;/&gt;public class ConfigController {&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    &lt;span&gt;@Autowired&lt;/span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    private UserProperties userProperties;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    &lt;span&gt;@RequestMapping&lt;/span&gt;(&lt;span&gt;&quot;/get&quot;&lt;/span&gt;)&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    public String get(){&lt;br mpa-from-tpl=&quot;t&quot;/&gt;        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;userProperties&lt;/span&gt;&lt;span&gt;.getUserName&lt;/span&gt;();&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    }&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    &lt;br mpa-from-tpl=&quot;t&quot;/&gt;}&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;此时controller不用加@RefreshScope也能实现动态刷新。因为属性类上的@ConfigurationProperties本身就具有动态刷新的特性&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p data-mid=&quot;&quot;&gt;5&lt;/p&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p data-mid=&quot;&quot;&gt;&lt;span&gt;总结&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;本文不算是@RefreshScope与nacos2整合踩到的坑，主要还是动态代理方面的知识，题目有点标题党了。&lt;/p&gt;&lt;p&gt;有些视频讲nacos动态刷新时，基本上都是举controller上@RerfreshScope +@value来讲解。其实利用@ConfigurationProperties也是可以达到类似的效果。如果没和springcloud整合，引入nacos配置中心的starter，使用@NacosPropertySource + @NacosValue或者@NacosRefresh也是可以实现动态刷新，感兴趣的朋友可以试一下&lt;/p&gt;&lt;p&gt;最后，朋友之前在nacos2搭建过程中，也踩到了一些坑。感兴趣的朋友可以查看如下文章&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzI1MTY1Njk4NQ==&amp;amp;mid=2247505367&amp;amp;idx=1&amp;amp;sn=09108bf846131e954a225035f6c11c50&amp;amp;chksm=e9ed3ba1de9ab2b7a96829947f9a4cb64d7270ef10cb96ce09c320ee2d737cc9703cd7b9f91d&amp;amp;token=1802849363&amp;amp;lang=zh_CN&amp;amp;scene=21#wechat_redirect&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot; data-linktype=&quot;2&quot;&gt;记一次使用nacos2踩到的坑&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;section data-recommend-type=&quot;list-title&quot; data-mpa-template=&quot;t&quot; data-recommend-tid=&quot;7&quot; data-mid=&quot;&quot; data-from=&quot;yb-recommend&quot;&gt;&lt;section data-mid=&quot;&quot;&gt;&lt;section data-mid=&quot;&quot;&gt;&lt;section data-mid=&quot;&quot;&gt;&lt;section data-mid=&quot;&quot;&gt;&lt;p data-mid=&quot;&quot;&gt;往期推荐&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot;&gt;&lt;section data-mid=&quot;&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; data-recommend-article-type=&quot;list-title&quot; data-recomment-template-id=&quot;7&quot; data-recommend-article-id=&quot;2247503181_1&quot; data-recommend-article-time=&quot;1654387443&quot; data-recommend-article-cover=&quot;https://mmbiz.qlogo.cn/mmbiz_jpg/NW0r9OxcmxJXW4o5rcRYz4drUYjmsc2viaR1AGKfdYkiaoIzjnxzEJraPWnLSN95nvK3iaia5v78zEqvovpErqicShw/0?wx_fmt=jpeg&quot; data-recommend-article-title=&quot;聊聊基于docker部署的mysql如何进行数据恢复&quot; data-recommend-article-content-url=&quot;https://mp.weixin.qq.com/s?__biz=MzI1MTY1Njk4NQ==&amp;amp;mid=2247503181&amp;amp;idx=1&amp;amp;sn=f05e6458d260c487fd564e3152763e29&amp;amp;chksm=e9ed233bde9aaa2de31e70abef843a918679a7b2430deea5a26a562ac63f1f8dc36e4e44edb5#rd&quot;&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzI1MTY1Njk4NQ==&amp;amp;mid=2247503181&amp;amp;idx=1&amp;amp;sn=f05e6458d260c487fd564e3152763e29&amp;amp;chksm=e9ed233bde9aaa2de31e70abef843a918679a7b2430deea5a26a562ac63f1f8dc36e4e44edb5&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;&lt;section data-recommend-title=&quot;t&quot; data-recommend-content=&quot;t&quot; data-mid=&quot;&quot;&gt;&lt;p data-mid=&quot;&quot;&gt;聊聊基于docker部署的mysql如何进行数据恢复&lt;/p&gt;&lt;/section&gt;&lt;/a&gt;&lt;/section&gt;&lt;section data-mpa-template=&quot;t&quot; data-recommend-article-type=&quot;list-title&quot; data-recomment-template-id=&quot;7&quot; data-recommend-article-id=&quot;2247497025_1&quot; data-recommend-article-time=&quot;1621123200&quot; data-recommend-article-cover=&quot;https://mmbiz.qlogo.cn/mmbiz_jpg/NW0r9OxcmxKGnUcib5qIhE29YFGGuxWIMHlZhzpbiaRbQoQV7otjU0oEvKACWWRCQ5AVvOZbAzrgWC4Ju4QlE95g/0?wx_fmt=jpeg&quot; data-recommend-article-title=&quot;聊聊部署在docker容器里面的springboot项目如何启用arthas&quot; data-recommend-article-content-url=&quot;https://mp.weixin.qq.com/s?__biz=MzI1MTY1Njk4NQ==&amp;amp;mid=2247497025&amp;amp;idx=1&amp;amp;sn=9717c58aa01b1dc4ab5a6640f3d57bbb&amp;amp;chksm=e9ed1b37de9a9221efb10c15452f97d5c57dcd63cac479a4c9d62234be1241d16a67a0bbe4e3#rd&quot;&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzI1MTY1Njk4NQ==&amp;amp;mid=2247497025&amp;amp;idx=1&amp;amp;sn=9717c58aa01b1dc4ab5a6640f3d57bbb&amp;amp;chksm=e9ed1b37de9a9221efb10c15452f97d5c57dcd63cac479a4c9d62234be1241d16a67a0bbe4e3&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;&lt;section data-recommend-title=&quot;t&quot; data-recommend-content=&quot;t&quot; data-mid=&quot;&quot;&gt;&lt;p data-mid=&quot;&quot;&gt;聊聊部署在docker容器里面的springboot项目如何启用arthas&lt;/p&gt;&lt;/section&gt;&lt;/a&gt;&lt;/section&gt;&lt;section data-mpa-template=&quot;t&quot; data-recommend-article-type=&quot;list-title&quot; data-recomment-template-id=&quot;7&quot; data-recommend-article-id=&quot;2247505433_2&quot; data-recommend-article-time=&quot;1661385600&quot; data-recommend-article-cover=&quot;https://mmbiz.qlogo.cn/mmbiz_jpg/NW0r9OxcmxJNHLXB5siaR2oQGfRjXQUvFw9VC8kRlaicZh8E6bBYB4e3DjViaHu7UoD6PW1EwBQele5o7NbjhMSFw/0?wx_fmt=jpeg&quot; data-recommend-article-title=&quot;这可能是网上最全的Docker工具集合&quot; data-recommend-article-content-url=&quot;https://mp.weixin.qq.com/s?__biz=MzI1MTY1Njk4NQ==&amp;amp;mid=2247505433&amp;amp;idx=2&amp;amp;sn=0277c5f911906ffa15d2570cde81b15e&amp;amp;chksm=e9ed386fde9ab179dabb93f411b715d21fd829f0527c02d44729f1898077e378f0a5aa50b49d#rd&quot;&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzI1MTY1Njk4NQ==&amp;amp;mid=2247505433&amp;amp;idx=2&amp;amp;sn=0277c5f911906ffa15d2570cde81b15e&amp;amp;chksm=e9ed386fde9ab179dabb93f411b715d21fd829f0527c02d44729f1898077e378f0a5aa50b49d&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;&lt;section data-recommend-title=&quot;t&quot; data-recommend-content=&quot;t&quot; data-mid=&quot;&quot;&gt;&lt;p data-mid=&quot;&quot;&gt;这可能是网上最全的Docker工具集合&lt;/p&gt;&lt;/section&gt;&lt;/a&gt;&lt;/section&gt;&lt;section data-mpa-template=&quot;t&quot; data-recommend-article-type=&quot;list-title&quot; data-recomment-template-id=&quot;7&quot; data-recommend-article-id=&quot;2247505514_1&quot; data-recommend-article-time=&quot;1662508800&quot; data-recommend-article-cover=&quot;https://mmbiz.qlogo.cn/mmbiz_jpg/NW0r9OxcmxLWAbicVuqAsxsfaiaib40V67cU7TCZrvdJBicBtqpgNhEy4Ly1Cj2YxKBIx2Nn26zkUDMZ7EHTlJZgHQ/0?wx_fmt=jpeg&quot; data-recommend-article-title=&quot;怎么给生产环境的docker容器 “减肥”？&quot; data-recommend-article-content-url=&quot;https://mp.weixin.qq.com/s?__biz=MzI1MTY1Njk4NQ==&amp;amp;mid=2247505514&amp;amp;idx=1&amp;amp;sn=b6934ff0349c9d245ea24003733e1e11&amp;amp;chksm=e9ed381cde9ab10a6d06a5dbc220fcd974ee5de1fc79c52e99f9df1967e5c0e511e40500154f#rd&quot;&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzI1MTY1Njk4NQ==&amp;amp;mid=2247505514&amp;amp;idx=1&amp;amp;sn=b6934ff0349c9d245ea24003733e1e11&amp;amp;chksm=e9ed381cde9ab10a6d06a5dbc220fcd974ee5de1fc79c52e99f9df1967e5c0e511e40500154f&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;&lt;section data-recommend-title=&quot;t&quot; data-recommend-content=&quot;t&quot; data-mid=&quot;&quot;&gt;&lt;p data-mid=&quot;&quot;&gt;怎么给生产环境的docker容器 “减肥”？&lt;/p&gt;&lt;/section&gt;&lt;/a&gt;&lt;/section&gt;&lt;section data-mpa-template=&quot;t&quot; data-recommend-article-type=&quot;list-title&quot; data-recomment-template-id=&quot;7&quot; data-recommend-article-id=&quot;2247505514_2&quot; data-recommend-article-time=&quot;1662508800&quot; data-recommend-article-cover=&quot;https://mmbiz.qlogo.cn/mmbiz_jpg/NW0r9OxcmxLWAbicVuqAsxsfaiaib40V67cU7TCZrvdJBicBtqpgNhEy4Ly1Cj2YxKBIx2Nn26zkUDMZ7EHTlJZgHQ/0?wx_fmt=jpeg&quot; data-recommend-article-title=&quot;Docker清理的常用方法&quot; data-recommend-article-content-url=&quot;https://mp.weixin.qq.com/s?__biz=MzI1MTY1Njk4NQ==&amp;amp;mid=2247505514&amp;amp;idx=2&amp;amp;sn=94a36e473df8a64b62130f254f0fe8b6&amp;amp;chksm=e9ed381cde9ab10a50fc1fb741f5a3ed2ffbe44a4ebeb1f0f2fb469dec8f16dfb78a8dddc515#rd&quot;&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzI1MTY1Njk4NQ==&amp;amp;mid=2247505514&amp;amp;idx=2&amp;amp;sn=94a36e473df8a64b62130f254f0fe8b6&amp;amp;chksm=e9ed381cde9ab10a50fc1fb741f5a3ed2ffbe44a4ebeb1f0f2fb469dec8f16dfb78a8dddc515&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;&lt;section data-recommend-title=&quot;t&quot; data-recommend-content=&quot;t&quot; data-mid=&quot;&quot;&gt;&lt;p data-mid=&quot;&quot;&gt;Docker清理的常用方法&lt;/p&gt;&lt;/section&gt;&lt;/a&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;/div&gt;

          
        &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>83f6f87bb91caf1562eb5ee980759659</guid>
<title>万字总结 Redis 常见面试题！（上）</title>
<link>https://toutiao.io/k/ysgqxgz</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;theme-hope-content&quot;&gt;&lt;h2 id=&quot;redis-基础&quot; tabindex=&quot;-1&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#redis-基础&quot; aria-hidden=&quot;true&quot;&gt;#&lt;/a&gt; Redis 基础&lt;/h2&gt;&lt;h3 id=&quot;什么是-redis&quot; tabindex=&quot;-1&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#什么是-redis&quot; aria-hidden=&quot;true&quot;&gt;#&lt;/a&gt; 什么是 Redis？&lt;/h3&gt;&lt;p&gt;&lt;a href=&quot;https://redis.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener noreferrer&quot;&gt;Redis&lt;span&gt;&lt;svg class=&quot;external-link-icon&quot; xmlns=&quot;http://www.w3.org/2000/svg&quot; aria-hidden=&quot;true&quot; focusable=&quot;false&quot; x=&quot;0px&quot; y=&quot;0px&quot; viewbox=&quot;0 0 100 100&quot;&gt;&lt;path fill=&quot;currentColor&quot; d=&quot;M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z&quot;/&gt;&lt;polygon fill=&quot;currentColor&quot; points=&quot;45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9&quot;/&gt;&lt;/svg&gt;&lt;span class=&quot;external-link-icon-sr-only&quot;&gt;open in new window&lt;/span&gt;&lt;/span&gt;&lt;/a&gt; 是一个基于 C 语言开发的开源数据库（BSD 许可），与传统数据库不同的是 Redis 的数据是存在内存中的（内存数据库），读写速度非常快，被广泛应用于缓存方向。并且，Redis 存储的是 KV 键值对数据。&lt;/p&gt;&lt;p&gt;为了满足不同的业务场景，Redis 内置了多种数据类型实现（比如 String、Hash、Sorted Set、Bitmap）。并且，Redis 还支持事务 、持久化、Lua 脚本、多种开箱即用的集群方案（Redis Sentinel、Redis Cluster）。&lt;/p&gt;&lt;p&gt;Redis 没有外部依赖，Linux 和 OS X 是 Redis 开发和测试最多的两个操作系统，官方推荐生产环境使用 Linux 部署 Redis。&lt;/p&gt;&lt;p&gt;个人学习的话，你可以自己本机安装 Redis 或者通过 Redis 官网提供的&lt;a href=&quot;https://try.redis.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener noreferrer&quot;&gt;在线 Redis 环境&lt;span&gt;&lt;svg class=&quot;external-link-icon&quot; xmlns=&quot;http://www.w3.org/2000/svg&quot; aria-hidden=&quot;true&quot; focusable=&quot;false&quot; x=&quot;0px&quot; y=&quot;0px&quot; viewbox=&quot;0 0 100 100&quot;&gt;&lt;path fill=&quot;currentColor&quot; d=&quot;M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z&quot;/&gt;&lt;polygon fill=&quot;currentColor&quot; points=&quot;45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9&quot;/&gt;&lt;/svg&gt;&lt;span class=&quot;external-link-icon-sr-only&quot;&gt;open in new window&lt;/span&gt;&lt;/span&gt;&lt;/a&gt;来实际体验 Redis。&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/database/redis/try.redis.io.png&quot; alt=&quot;try-redis&quot;/&gt;&lt;/p&gt;&lt;p&gt;全世界有非常多的网站使用到了 Redis ，&lt;a href=&quot;https://techstacks.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener noreferrer&quot;&gt;techstacks.io&lt;span&gt;&lt;svg class=&quot;external-link-icon&quot; xmlns=&quot;http://www.w3.org/2000/svg&quot; aria-hidden=&quot;true&quot; focusable=&quot;false&quot; x=&quot;0px&quot; y=&quot;0px&quot; viewbox=&quot;0 0 100 100&quot;&gt;&lt;path fill=&quot;currentColor&quot; d=&quot;M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z&quot;/&gt;&lt;polygon fill=&quot;currentColor&quot; points=&quot;45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9&quot;/&gt;&lt;/svg&gt;&lt;span class=&quot;external-link-icon-sr-only&quot;&gt;open in new window&lt;/span&gt;&lt;/span&gt;&lt;/a&gt; 专门维护了一个&lt;a href=&quot;https://techstacks.io/tech/redis&quot; target=&quot;_blank&quot; rel=&quot;noopener noreferrer&quot;&gt;使用 Redis 的热门站点列表&lt;span&gt;&lt;svg class=&quot;external-link-icon&quot; xmlns=&quot;http://www.w3.org/2000/svg&quot; aria-hidden=&quot;true&quot; focusable=&quot;false&quot; x=&quot;0px&quot; y=&quot;0px&quot; viewbox=&quot;0 0 100 100&quot;&gt;&lt;path fill=&quot;currentColor&quot; d=&quot;M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z&quot;/&gt;&lt;polygon fill=&quot;currentColor&quot; points=&quot;45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9&quot;/&gt;&lt;/svg&gt;&lt;span class=&quot;external-link-icon-sr-only&quot;&gt;open in new window&lt;/span&gt;&lt;/span&gt;&lt;/a&gt; ，感兴趣的话可以看看。&lt;/p&gt;&lt;h3 id=&quot;redis-为什么这么快&quot; tabindex=&quot;-1&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#redis-为什么这么快&quot; aria-hidden=&quot;true&quot;&gt;#&lt;/a&gt; Redis 为什么这么快？&lt;/h3&gt;&lt;p&gt;Redis 内部做了非常多的性能优化，比较重要的主要有下面 3 点：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;Redis 基于内存，内存的访问速度是磁盘的上千倍；&lt;/li&gt;&lt;li&gt;Redis 基于 Reactor 模式设计开发了一套高效的事件处理模型，主要是单线程事件循环和 IO 多路复用（Redis 线程模式后面会详细介绍到）；&lt;/li&gt;&lt;li&gt;Redis 内置了多种优化过后的数据结构实现，性能非常高。&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;下面这张图片总结的挺不错的，分享一下，出自 &lt;a href=&quot;https://twitter.com/alexxubyte/status/1498703822528544770&quot; target=&quot;_blank&quot; rel=&quot;noopener noreferrer&quot;&gt;Why is Redis so fast?&lt;span&gt;&lt;svg class=&quot;external-link-icon&quot; xmlns=&quot;http://www.w3.org/2000/svg&quot; aria-hidden=&quot;true&quot; focusable=&quot;false&quot; x=&quot;0px&quot; y=&quot;0px&quot; viewbox=&quot;0 0 100 100&quot;&gt;&lt;path fill=&quot;currentColor&quot; d=&quot;M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z&quot;/&gt;&lt;polygon fill=&quot;currentColor&quot; points=&quot;45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9&quot;/&gt;&lt;/svg&gt;&lt;span class=&quot;external-link-icon-sr-only&quot;&gt;open in new window&lt;/span&gt;&lt;/span&gt;&lt;/a&gt; 。&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;/assets/why-redis-so-fast.d3507ae8.png&quot; alt=&quot;why-redis-so-fast&quot;/&gt;&lt;/p&gt;&lt;h3 id=&quot;分布式缓存常见的技术选型方案有哪些&quot; tabindex=&quot;-1&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#分布式缓存常见的技术选型方案有哪些&quot; aria-hidden=&quot;true&quot;&gt;#&lt;/a&gt; 分布式缓存常见的技术选型方案有哪些？&lt;/h3&gt;&lt;p&gt;分布式缓存的话，比较老牌同时也是使用的比较多的还是 &lt;strong&gt;Memcached&lt;/strong&gt; 和 &lt;strong&gt;Redis&lt;/strong&gt;。不过，现在基本没有看过还有项目使用 &lt;strong&gt;Memcached&lt;/strong&gt; 来做缓存，都是直接用 &lt;strong&gt;Redis&lt;/strong&gt;。&lt;/p&gt;&lt;p&gt;Memcached 是分布式缓存最开始兴起的那会，比较常用的。后来，随着 Redis 的发展，大家慢慢都转而使用更加强大的 Redis 了。&lt;/p&gt;&lt;p&gt;另外，腾讯也开源了一款类似于 Redis 的分布式高性能 KV 存储数据库，基于知名的开源项目 &lt;a href=&quot;https://github.com/facebook/rocksdb&quot; target=&quot;_blank&quot; rel=&quot;noopener noreferrer&quot;&gt;RocksDB&lt;span&gt;&lt;svg class=&quot;external-link-icon&quot; xmlns=&quot;http://www.w3.org/2000/svg&quot; aria-hidden=&quot;true&quot; focusable=&quot;false&quot; x=&quot;0px&quot; y=&quot;0px&quot; viewbox=&quot;0 0 100 100&quot;&gt;&lt;path fill=&quot;currentColor&quot; d=&quot;M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z&quot;/&gt;&lt;polygon fill=&quot;currentColor&quot; points=&quot;45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9&quot;/&gt;&lt;/svg&gt;&lt;span class=&quot;external-link-icon-sr-only&quot;&gt;open in new window&lt;/span&gt;&lt;/span&gt;&lt;/a&gt; 作为存储引擎 ，100% 兼容 Redis 协议和 Redis4.0 所有数据模型，名为 &lt;a href=&quot;https://github.com/Tencent/Tendis&quot; target=&quot;_blank&quot; rel=&quot;noopener noreferrer&quot;&gt;Tendis&lt;span&gt;&lt;svg class=&quot;external-link-icon&quot; xmlns=&quot;http://www.w3.org/2000/svg&quot; aria-hidden=&quot;true&quot; focusable=&quot;false&quot; x=&quot;0px&quot; y=&quot;0px&quot; viewbox=&quot;0 0 100 100&quot;&gt;&lt;path fill=&quot;currentColor&quot; d=&quot;M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z&quot;/&gt;&lt;polygon fill=&quot;currentColor&quot; points=&quot;45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9&quot;/&gt;&lt;/svg&gt;&lt;span class=&quot;external-link-icon-sr-only&quot;&gt;open in new window&lt;/span&gt;&lt;/span&gt;&lt;/a&gt;。&lt;/p&gt;&lt;p&gt;关于 Redis 和 Tendis 的对比，腾讯官方曾经发过一篇文章：&lt;a href=&quot;https://mp.weixin.qq.com/s/MeYkfOIdnU6LYlsGb24KjQ&quot; target=&quot;_blank&quot; rel=&quot;noopener noreferrer&quot;&gt;Redis vs Tendis：冷热混合存储版架构揭秘&lt;span&gt;&lt;svg class=&quot;external-link-icon&quot; xmlns=&quot;http://www.w3.org/2000/svg&quot; aria-hidden=&quot;true&quot; focusable=&quot;false&quot; x=&quot;0px&quot; y=&quot;0px&quot; viewbox=&quot;0 0 100 100&quot;&gt;&lt;path fill=&quot;currentColor&quot; d=&quot;M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z&quot;/&gt;&lt;polygon fill=&quot;currentColor&quot; points=&quot;45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9&quot;/&gt;&lt;/svg&gt;&lt;span class=&quot;external-link-icon-sr-only&quot;&gt;open in new window&lt;/span&gt;&lt;/span&gt;&lt;/a&gt; ，可以简单参考一下。&lt;/p&gt;&lt;p&gt;从这个项目的 Github 提交记录可以看出，Tendis 开源版几乎已经没有被维护更新了，加上其关注度并不高，使用的公司也比较少。因此，不建议你使用 Tendis 来实现分布式缓存。&lt;/p&gt;&lt;h3 id=&quot;说一下-redis-和-memcached-的区别和共同点&quot; tabindex=&quot;-1&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#说一下-redis-和-memcached-的区别和共同点&quot; aria-hidden=&quot;true&quot;&gt;#&lt;/a&gt; 说一下 Redis 和 Memcached 的区别和共同点&lt;/h3&gt;&lt;p&gt;现在公司一般都是用 Redis 来实现缓存，而且 Redis 自身也越来越强大了！不过，了解 Redis 和 Memcached 的区别和共同点，有助于我们在做相应的技术选型的时候，能够做到有理有据！&lt;/p&gt;&lt;p&gt;&lt;strong&gt;共同点&lt;/strong&gt; ：&lt;/p&gt;&lt;ol&gt;&lt;li&gt;都是基于内存的数据库，一般都用来当做缓存使用。&lt;/li&gt;&lt;li&gt;都有过期策略。&lt;/li&gt;&lt;li&gt;两者的性能都非常高。&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;&lt;strong&gt;区别&lt;/strong&gt; ：&lt;/p&gt;&lt;ol&gt;&lt;li&gt;&lt;strong&gt;Redis 支持更丰富的数据类型（支持更复杂的应用场景）&lt;/strong&gt;。Redis 不仅仅支持简单的 k/v 类型的数据，同时还提供 list，set，zset，hash 等数据结构的存储。Memcached 只支持最简单的 k/v 数据类型。&lt;/li&gt;&lt;li&gt;&lt;strong&gt;Redis 支持数据的持久化，可以将内存中的数据保持在磁盘中，重启的时候可以再次加载进行使用,而 Memcached 把数据全部存在内存之中。&lt;/strong&gt;&lt;/li&gt;&lt;li&gt;&lt;strong&gt;Redis 有灾难恢复机制。&lt;/strong&gt; 因为可以把缓存中的数据持久化到磁盘上。&lt;/li&gt;&lt;li&gt;&lt;strong&gt;Redis 在服务器内存使用完之后，可以将不用的数据放到磁盘上。但是，Memcached 在服务器内存使用完之后，就会直接报异常。&lt;/strong&gt;&lt;/li&gt;&lt;li&gt;&lt;strong&gt;Memcached 没有原生的集群模式，需要依靠客户端来实现往集群中分片写入数据；但是 Redis 目前是原生支持 cluster 模式的。&lt;/strong&gt;&lt;/li&gt;&lt;li&gt;&lt;strong&gt;Memcached 是多线程，非阻塞 IO 复用的网络模型；Redis 使用单线程的多路 IO 复用模型。&lt;/strong&gt; （Redis 6.0 引入了多线程 IO ）&lt;/li&gt;&lt;li&gt;&lt;strong&gt;Redis 支持发布订阅模型、Lua 脚本、事务等功能，而 Memcached 不支持。并且，Redis 支持更多的编程语言。&lt;/strong&gt;&lt;/li&gt;&lt;li&gt;&lt;strong&gt;Memcached 过期数据的删除策略只用了惰性删除，而 Redis 同时使用了惰性删除与定期删除。&lt;/strong&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;相信看了上面的对比之后，我们已经没有什么理由可以选择使用 Memcached 来作为自己项目的分布式缓存了。&lt;/p&gt;&lt;h3 id=&quot;为什么要用-redis-为什么要用缓存&quot; tabindex=&quot;-1&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#为什么要用-redis-为什么要用缓存&quot; aria-hidden=&quot;true&quot;&gt;#&lt;/a&gt; 为什么要用 Redis/为什么要用缓存？&lt;/h3&gt;&lt;p&gt;下面我们主要从“高性能”和“高并发”这两点来回答这个问题。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;高性能&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;假如用户第一次访问数据库中的某些数据的话，这个过程是比较慢，毕竟是从硬盘中读取的。但是，如果说，用户访问的数据属于高频数据并且不会经常改变的话，那么我们就可以很放心地将该用户访问的数据存在缓存中。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;这样有什么好处呢？&lt;/strong&gt; 那就是保证用户下一次再访问这些数据的时候就可以直接从缓存中获取了。操作缓存就是直接操作内存，所以速度相当快。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;高并发&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;一般像 MySQL 这类的数据库的 QPS 大概都在 1w 左右（4 核 8g） ，但是使用 Redis 缓存之后很容易达到 10w+，甚至最高能达到 30w+（就单机 Redis 的情况，Redis 集群的话会更高）。&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;QPS（Query Per Second）：服务器每秒可以执行的查询次数；&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;由此可见，直接操作缓存能够承受的数据库请求数量是远远大于直接访问数据库的，所以我们可以考虑把数据库中的部分数据转移到缓存中去，这样用户的一部分请求会直接到缓存这里而不用经过数据库。进而，我们也就提高了系统整体的并发。&lt;/p&gt;&lt;h3 id=&quot;redis-除了做缓存-还能做什么&quot; tabindex=&quot;-1&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#redis-除了做缓存-还能做什么&quot; aria-hidden=&quot;true&quot;&gt;#&lt;/a&gt; Redis 除了做缓存，还能做什么？&lt;/h3&gt;&lt;ul&gt;&lt;li&gt;&lt;strong&gt;分布式锁&lt;/strong&gt; ： 通过 Redis 来做分布式锁是一种比较常见的方式。通常情况下，我们都是基于 Redisson 来实现分布式锁。关于 Redis 实现分布式锁的详细介绍，可以看我写的这篇文章：&lt;a href=&quot;https://javaguide.cn/distributed-system/distributed-lock.html&quot; target=&quot;_blank&quot; rel=&quot;noopener noreferrer&quot;&gt;分布式锁详解&lt;span&gt;&lt;svg class=&quot;external-link-icon&quot; xmlns=&quot;http://www.w3.org/2000/svg&quot; aria-hidden=&quot;true&quot; focusable=&quot;false&quot; x=&quot;0px&quot; y=&quot;0px&quot; viewbox=&quot;0 0 100 100&quot;&gt;&lt;path fill=&quot;currentColor&quot; d=&quot;M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z&quot;/&gt;&lt;polygon fill=&quot;currentColor&quot; points=&quot;45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9&quot;/&gt;&lt;/svg&gt;&lt;span class=&quot;external-link-icon-sr-only&quot;&gt;open in new window&lt;/span&gt;&lt;/span&gt;&lt;/a&gt; 。&lt;/li&gt;&lt;li&gt;&lt;strong&gt;限流&lt;/strong&gt; ：一般是通过 Redis + Lua 脚本的方式来实现限流。相关阅读：&lt;a href=&quot;https://mp.weixin.qq.com/s/kyFAWH3mVNJvurQDt4vchA&quot; target=&quot;_blank&quot; rel=&quot;noopener noreferrer&quot;&gt;《我司用了 6 年的 Redis 分布式限流器，可以说是非常厉害了！》&lt;span&gt;&lt;svg class=&quot;external-link-icon&quot; xmlns=&quot;http://www.w3.org/2000/svg&quot; aria-hidden=&quot;true&quot; focusable=&quot;false&quot; x=&quot;0px&quot; y=&quot;0px&quot; viewbox=&quot;0 0 100 100&quot;&gt;&lt;path fill=&quot;currentColor&quot; d=&quot;M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z&quot;/&gt;&lt;polygon fill=&quot;currentColor&quot; points=&quot;45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9&quot;/&gt;&lt;/svg&gt;&lt;span class=&quot;external-link-icon-sr-only&quot;&gt;open in new window&lt;/span&gt;&lt;/span&gt;&lt;/a&gt;。&lt;/li&gt;&lt;li&gt;&lt;strong&gt;消息队列&lt;/strong&gt; ：Redis 自带的 list 数据结构可以作为一个简单的队列使用。Redis 5.0 中增加的 Stream 类型的数据结构更加适合用来做消息队列。它比较类似于 Kafka，有主题和消费组的概念，支持消息持久化以及 ACK 机制。&lt;/li&gt;&lt;li&gt;&lt;strong&gt;复杂业务场景&lt;/strong&gt; ：通过 Redis 以及 Redis 扩展（比如 Redisson）提供的数据结构，我们可以很方便地完成很多复杂的业务场景比如通过 bitmap 统计活跃用户、通过 sorted set 维护排行榜。&lt;/li&gt;&lt;li&gt;......&lt;/li&gt;&lt;/ul&gt;&lt;h3 id=&quot;redis-可以做消息队列么&quot; tabindex=&quot;-1&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#redis-可以做消息队列么&quot; aria-hidden=&quot;true&quot;&gt;#&lt;/a&gt; Redis 可以做消息队列么？&lt;/h3&gt;&lt;p&gt;Redis 5.0 新增加的一个数据结构 &lt;code&gt;Stream&lt;/code&gt; 可以用来做消息队列，&lt;code&gt;Stream&lt;/code&gt; 支持：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;发布 / 订阅模式&lt;/li&gt;&lt;li&gt;按照消费者组进行消费&lt;/li&gt;&lt;li&gt;消息持久化（ RDB 和 AOF）&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;不过，和专业的消息队列相比，还是有很多欠缺的地方比如消息丢失和堆积问题不好解决。因此，我们通常建议是不使用 Redis 来做消息队列的，你完全可以选择市面上比较成熟的一些消息队列比如 RocketMQ、Kafka。&lt;/p&gt;&lt;p&gt;相关文章推荐：&lt;a href=&quot;https://javakeeper.starfish.ink/data-management/Redis/Redis-MQ.html&quot; target=&quot;_blank&quot; rel=&quot;noopener noreferrer&quot;&gt;Redis 消息队列的三种方案（List、Streams、Pub/Sub）&lt;span&gt;&lt;svg class=&quot;external-link-icon&quot; xmlns=&quot;http://www.w3.org/2000/svg&quot; aria-hidden=&quot;true&quot; focusable=&quot;false&quot; x=&quot;0px&quot; y=&quot;0px&quot; viewbox=&quot;0 0 100 100&quot;&gt;&lt;path fill=&quot;currentColor&quot; d=&quot;M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z&quot;/&gt;&lt;polygon fill=&quot;currentColor&quot; points=&quot;45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9&quot;/&gt;&lt;/svg&gt;&lt;span class=&quot;external-link-icon-sr-only&quot;&gt;open in new window&lt;/span&gt;&lt;/span&gt;&lt;/a&gt;。&lt;/p&gt;&lt;h3 id=&quot;如何基于-redis-实现分布式锁&quot; tabindex=&quot;-1&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#如何基于-redis-实现分布式锁&quot; aria-hidden=&quot;true&quot;&gt;#&lt;/a&gt; 如何基于 Redis 实现分布式锁？&lt;/h3&gt;&lt;p&gt;关于 Redis 实现分布式锁的详细介绍，可以看我写的这篇文章：&lt;a href=&quot;https://javaguide.cn/distributed-system/distributed-lock.html&quot; target=&quot;_blank&quot; rel=&quot;noopener noreferrer&quot;&gt;分布式锁详解&lt;span&gt;&lt;svg class=&quot;external-link-icon&quot; xmlns=&quot;http://www.w3.org/2000/svg&quot; aria-hidden=&quot;true&quot; focusable=&quot;false&quot; x=&quot;0px&quot; y=&quot;0px&quot; viewbox=&quot;0 0 100 100&quot;&gt;&lt;path fill=&quot;currentColor&quot; d=&quot;M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z&quot;/&gt;&lt;polygon fill=&quot;currentColor&quot; points=&quot;45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9&quot;/&gt;&lt;/svg&gt;&lt;span class=&quot;external-link-icon-sr-only&quot;&gt;open in new window&lt;/span&gt;&lt;/span&gt;&lt;/a&gt; 。&lt;/p&gt;&lt;h2 id=&quot;redis-数据结构&quot; tabindex=&quot;-1&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#redis-数据结构&quot; aria-hidden=&quot;true&quot;&gt;#&lt;/a&gt; Redis 数据结构&lt;/h2&gt;&lt;h3 id=&quot;redis-常用的数据结构有哪些&quot; tabindex=&quot;-1&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#redis-常用的数据结构有哪些&quot; aria-hidden=&quot;true&quot;&gt;#&lt;/a&gt; Redis 常用的数据结构有哪些？&lt;/h3&gt;&lt;ul&gt;&lt;li&gt;&lt;strong&gt;5 种基础数据结构&lt;/strong&gt; ：String（字符串）、List（列表）、Set（集合）、Hash（散列）、Zset（有序集合）。&lt;/li&gt;&lt;li&gt;&lt;strong&gt;3 种特殊数据结构&lt;/strong&gt; ：HyperLogLogs（基数统计）、Bitmap （位存储）、Geospatial (地理位置)。&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;关于 5 种基础数据结构的详细介绍请看这篇文章：&lt;a href=&quot;/database/redis/redis-data-structures-01.html&quot; class=&quot;&quot;&gt;Redis 5 种基本数据结构详解&lt;/a&gt;。&lt;/p&gt;&lt;p&gt;关于 3 种特殊数据结构的详细介绍请看这篇文章：&lt;a href=&quot;/database/redis/redis-data-structures-02.html&quot; class=&quot;&quot;&gt;Redis 3 种特殊数据结构详解&lt;/a&gt;。&lt;/p&gt;&lt;h3 id=&quot;string-的应用场景有哪些&quot; tabindex=&quot;-1&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#string-的应用场景有哪些&quot; aria-hidden=&quot;true&quot;&gt;#&lt;/a&gt; String 的应用场景有哪些？&lt;/h3&gt;&lt;ul&gt;&lt;li&gt;常规数据（比如 session、token、、序列化后的对象）的缓存；&lt;/li&gt;&lt;li&gt;计数比如用户单位时间的请求数（简单限流可以用到）、页面单位时间的访问数；&lt;/li&gt;&lt;li&gt;分布式锁(利用 &lt;code&gt;SETNX key value&lt;/code&gt; 命令可以实现一个最简易的分布式锁)；&lt;/li&gt;&lt;li&gt;......&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;关于 String 的详细介绍请看这篇文章：&lt;a href=&quot;/database/redis/redis-data-structures-01.html&quot; class=&quot;&quot;&gt;Redis 5 种基本数据结构详解&lt;/a&gt;。&lt;/p&gt;&lt;h3 id=&quot;string-还是-hash-存储对象数据更好呢&quot; tabindex=&quot;-1&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#string-还是-hash-存储对象数据更好呢&quot; aria-hidden=&quot;true&quot;&gt;#&lt;/a&gt; String 还是 Hash 存储对象数据更好呢？&lt;/h3&gt;&lt;ul&gt;&lt;li&gt;String 存储的是序列化后的对象数据，存放的是整个对象。Hash 是对对象的每个字段单独存储，可以获取部分字段的信息，也可以修改或者添加部分字段，节省网络流量。如果对象中某些字段需要经常变动或者经常需要单独查询对象中的个别字段信息，Hash 就非常适合。&lt;/li&gt;&lt;li&gt;String 存储相对来说更加节省内存，缓存相同数量的对象数据，String 消耗的内存约是 Hash 的一半。并且，存储具有多层嵌套的对象时也方便很多。如果系统对性能和资源消耗非常敏感的话，String 就非常适合。&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;在绝大部分情况，我们建议使用 String 来存储对象数据即可！&lt;/p&gt;&lt;h3 id=&quot;string-的底层实现是什么&quot; tabindex=&quot;-1&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#string-的底层实现是什么&quot; aria-hidden=&quot;true&quot;&gt;#&lt;/a&gt; String 的底层实现是什么？&lt;/h3&gt;&lt;p&gt;Redis 是基于 C 语言编写的，但 Redis 的 String 类型的底层实现并不是 C 语言中的字符串（即以空字符 &lt;code&gt;\0&lt;/code&gt; 结尾的字符数组），而是自己编写了 &lt;a href=&quot;https://github.com/antirez/sds&quot; target=&quot;_blank&quot; rel=&quot;noopener noreferrer&quot;&gt;SDS&lt;span&gt;&lt;svg class=&quot;external-link-icon&quot; xmlns=&quot;http://www.w3.org/2000/svg&quot; aria-hidden=&quot;true&quot; focusable=&quot;false&quot; x=&quot;0px&quot; y=&quot;0px&quot; viewbox=&quot;0 0 100 100&quot;&gt;&lt;path fill=&quot;currentColor&quot; d=&quot;M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z&quot;/&gt;&lt;polygon fill=&quot;currentColor&quot; points=&quot;45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9&quot;/&gt;&lt;/svg&gt;&lt;span class=&quot;external-link-icon-sr-only&quot;&gt;open in new window&lt;/span&gt;&lt;/span&gt;&lt;/a&gt;（Simple Dynamic String，简单动态字符串） 来作为底层实现。&lt;/p&gt;&lt;p&gt;SDS 最早是 Redis 作者为日常 C 语言开发而设计的 C 字符串，后来被应用到了 Redis 上，并经过了大量的修改完善以适合高性能操作。&lt;/p&gt;&lt;p&gt;Redis7.0 的 SDS 的部分源码如下（https://github.com/redis/redis/blob/7.0/src/sds.h）：&lt;/p&gt;&lt;div class=&quot;language-c line-numbers-mode&quot; data-ext=&quot;c&quot;&gt;&lt;pre class=&quot;language-c&quot;&gt;&lt;code&gt;&lt;span class=&quot;token comment&quot;&gt;/* Note: sdshdr5 is never used, we just access the flags byte directly.
 * However is here to document the layout of type 5 SDS strings. */&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;__attribute__&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;__packed__&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;sdshdr5&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;token keyword&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;char&lt;/span&gt; flags&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;token comment&quot;&gt;/* 3 lsb of type, and 5 msb of string length */&lt;/span&gt;
    &lt;span class=&quot;token keyword&quot;&gt;char&lt;/span&gt; buf&lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;__attribute__&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;__packed__&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;sdshdr8&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;token class-name&quot;&gt;uint8_t&lt;/span&gt; len&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;token comment&quot;&gt;/* used */&lt;/span&gt;
    &lt;span class=&quot;token class-name&quot;&gt;uint8_t&lt;/span&gt; alloc&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;token comment&quot;&gt;/* excluding the header and null terminator */&lt;/span&gt;
    &lt;span class=&quot;token keyword&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;char&lt;/span&gt; flags&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;token comment&quot;&gt;/* 3 lsb of type, 5 unused bits */&lt;/span&gt;
    &lt;span class=&quot;token keyword&quot;&gt;char&lt;/span&gt; buf&lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;__attribute__&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;__packed__&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;sdshdr16&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;token class-name&quot;&gt;uint16_t&lt;/span&gt; len&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;token comment&quot;&gt;/* used */&lt;/span&gt;
    &lt;span class=&quot;token class-name&quot;&gt;uint16_t&lt;/span&gt; alloc&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;token comment&quot;&gt;/* excluding the header and null terminator */&lt;/span&gt;
    &lt;span class=&quot;token keyword&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;char&lt;/span&gt; flags&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;token comment&quot;&gt;/* 3 lsb of type, 5 unused bits */&lt;/span&gt;
    &lt;span class=&quot;token keyword&quot;&gt;char&lt;/span&gt; buf&lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;__attribute__&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;__packed__&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;sdshdr32&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;token class-name&quot;&gt;uint32_t&lt;/span&gt; len&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;token comment&quot;&gt;/* used */&lt;/span&gt;
    &lt;span class=&quot;token class-name&quot;&gt;uint32_t&lt;/span&gt; alloc&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;token comment&quot;&gt;/* excluding the header and null terminator */&lt;/span&gt;
    &lt;span class=&quot;token keyword&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;char&lt;/span&gt; flags&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;token comment&quot;&gt;/* 3 lsb of type, 5 unused bits */&lt;/span&gt;
    &lt;span class=&quot;token keyword&quot;&gt;char&lt;/span&gt; buf&lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;__attribute__&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;__packed__&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;sdshdr64&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;token class-name&quot;&gt;uint64_t&lt;/span&gt; len&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;token comment&quot;&gt;/* used */&lt;/span&gt;
    &lt;span class=&quot;token class-name&quot;&gt;uint64_t&lt;/span&gt; alloc&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;token comment&quot;&gt;/* excluding the header and null terminator */&lt;/span&gt;
    &lt;span class=&quot;token keyword&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;char&lt;/span&gt; flags&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;token comment&quot;&gt;/* 3 lsb of type, 5 unused bits */&lt;/span&gt;
    &lt;span class=&quot;token keyword&quot;&gt;char&lt;/span&gt; buf&lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;通过源码可以看出，SDS 共有五种实现方式 SDS_TYPE_5（并未用到）、SDS_TYPE_8、SDS_TYPE_16、SDS_TYPE_32、SDS_TYPE_64，其中只有后四种实际用到。Redis 会根据初始化的长度决定使用哪种类型，从而减少内存的使用。&lt;/p&gt;&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;类型&lt;/th&gt;&lt;th&gt;字节&lt;/th&gt;&lt;th&gt;位&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;sdshdr5&lt;/td&gt;&lt;td&gt;&amp;lt; 1&lt;/td&gt;&lt;td&gt;&amp;lt;8&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;sdshdr8&lt;/td&gt;&lt;td&gt;1&lt;/td&gt;&lt;td&gt;8&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;sdshdr16&lt;/td&gt;&lt;td&gt;2&lt;/td&gt;&lt;td&gt;16&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;sdshdr32&lt;/td&gt;&lt;td&gt;4&lt;/td&gt;&lt;td&gt;32&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;sdshdr64&lt;/td&gt;&lt;td&gt;8&lt;/td&gt;&lt;td&gt;64&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;对于后四种实现都包含了下面这 4 个属性：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;code&gt;len&lt;/code&gt; ：字符串的长度也就是已经使用的字节数&lt;/li&gt;&lt;li&gt;&lt;code&gt;alloc&lt;/code&gt;：总共可用的字符空间大小，alloc-len 就是 SDS 剩余的空间大小&lt;/li&gt;&lt;li&gt;&lt;code&gt;buf[]&lt;/code&gt; ：实际存储字符串的数组&lt;/li&gt;&lt;li&gt;&lt;code&gt;flags&lt;/code&gt; ：低三位保存类型标志&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;SDS 相比于 C 语言中的字符串有如下提升：&lt;/p&gt;&lt;ol&gt;&lt;li&gt;&lt;strong&gt;可以避免缓冲区溢出&lt;/strong&gt; ：C 语言中的字符串被修改（比如拼接）时，一旦没有分配足够长度的内存空间，就会造成缓冲区溢出。SDS 被修改时，会先根据 len 属性检查空间大小是否满足要求，如果不满足，则先扩展至所需大小再进行修改操作。&lt;/li&gt;&lt;li&gt;&lt;strong&gt;获取字符串长度的复杂度较低&lt;/strong&gt; ： C 语言中的字符串的长度通常是经过遍历计数来实现的，时间复杂度为 O(n)。SDS 的长度获取直接读取 len 属性即可，时间复杂度为 O(1)。&lt;/li&gt;&lt;li&gt;&lt;strong&gt;减少内存分配次数&lt;/strong&gt; ： 为了避免修改（增加/减少）字符串时，每次都需要重新分配内存（C 语言的字符串是这样的），SDS 实现了空间预分配和惰性空间释放两种优化策略。当 SDS 需要增加字符串时，Redis 会为 SDS 分配好内存，并且根据特定的算法分配多余的内存，这样可以减少连续执行字符串增长操作所需的内存重分配次数。当 SDS 需要减少字符串时，这部分内存不会立即被回收，会被记录下来，等待后续使用（支持手动释放，有对应的 API）。&lt;/li&gt;&lt;li&gt;&lt;strong&gt;二进制安全&lt;/strong&gt; ：C 语言中的字符串以空字符 &lt;code&gt;\0&lt;/code&gt; 作为字符串结束的标识，这存在一些问题，像一些二进制文件（比如图片、视频、音频）就可能包括空字符，C 字符串无法正确保存。SDS 使用 len 属性判断字符串是否结束，不存在这个问题。&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;多提一嘴，很多文章里 SDS 的定义是下面这样的：&lt;/p&gt;&lt;div class=&quot;language-c line-numbers-mode&quot; data-ext=&quot;c&quot;&gt;&lt;pre class=&quot;language-c&quot;&gt;&lt;code&gt;&lt;span class=&quot;token keyword&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;sdshdr&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;token keyword&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;int&lt;/span&gt; len&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;token keyword&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;int&lt;/span&gt; free&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;token keyword&quot;&gt;char&lt;/span&gt; buf&lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;这个也没错，Redis 3.2 之前就是这样定义的。后来，由于这种方式的定义存在问题，&lt;code&gt;len&lt;/code&gt; 和 &lt;code&gt;free&lt;/code&gt; 的定义用了 4 个字节，造成了浪费。Redis 3.2 之后，Redis 改进了 SDS 的定义，将其划分为了现在的 5 种类型。&lt;/p&gt;&lt;h3 id=&quot;购物车信息用-string-还是-hash-存储更好呢&quot; tabindex=&quot;-1&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#购物车信息用-string-还是-hash-存储更好呢&quot; aria-hidden=&quot;true&quot;&gt;#&lt;/a&gt; 购物车信息用 String 还是 Hash 存储更好呢?&lt;/h3&gt;&lt;p&gt;由于购物车中的商品频繁修改和变动，购物车信息建议使用 Hash 存储：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;用户 id 为 key&lt;/li&gt;&lt;li&gt;商品 id 为 field，商品数量为 value&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;/assets/hash-shopping-cart.b8c84954.png&quot; alt=&quot;Hash维护简单的购物车信息&quot;/&gt;&lt;/p&gt;&lt;p&gt;那用户购物车信息的维护具体应该怎么操作呢？&lt;/p&gt;&lt;ul&gt;&lt;li&gt;用户添加商品就是往 Hash 里面增加新的 field 与 value；&lt;/li&gt;&lt;li&gt;查询购物车信息就是遍历对应的 Hash；&lt;/li&gt;&lt;li&gt;更改商品数量直接修改对应的 value 值（直接 set 或者做运算皆可）；&lt;/li&gt;&lt;li&gt;删除商品就是删除 Hash 中对应的 field；&lt;/li&gt;&lt;li&gt;清空购物车直接删除对应的 key 即可。&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;这里只是以业务比较简单的购物车场景举例，实际电商场景下，field 只保存一个商品 id 是没办法满足需求的。&lt;/p&gt;&lt;h3 id=&quot;使用-redis-实现一个排行榜怎么做&quot; tabindex=&quot;-1&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#使用-redis-实现一个排行榜怎么做&quot; aria-hidden=&quot;true&quot;&gt;#&lt;/a&gt; 使用 Redis 实现一个排行榜怎么做？&lt;/h3&gt;&lt;p&gt;Redis 中有一个叫做 &lt;code&gt;sorted set&lt;/code&gt; 的数据结构经常被用在各种排行榜的场景，比如直播间送礼物的排行榜、朋友圈的微信步数排行榜、王者荣耀中的段位排行榜、话题热度排行榜等等。&lt;/p&gt;&lt;p&gt;相关的一些 Redis 命令: &lt;code&gt;ZRANGE&lt;/code&gt; (从小到大排序) 、 &lt;code&gt;ZREVRANGE&lt;/code&gt; （从大到小排序）、&lt;code&gt;ZREVRANK&lt;/code&gt; (指定元素排名)。&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/2021060714195385.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://www.yuque.com/docs/share/f37fc804-bfe6-4b0d-b373-9c462188fec7&quot; target=&quot;_blank&quot; rel=&quot;noopener noreferrer&quot;&gt;《Java 面试指北》&lt;span&gt;&lt;svg class=&quot;external-link-icon&quot; xmlns=&quot;http://www.w3.org/2000/svg&quot; aria-hidden=&quot;true&quot; focusable=&quot;false&quot; x=&quot;0px&quot; y=&quot;0px&quot; viewbox=&quot;0 0 100 100&quot;&gt;&lt;path fill=&quot;currentColor&quot; d=&quot;M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z&quot;/&gt;&lt;polygon fill=&quot;currentColor&quot; points=&quot;45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9&quot;/&gt;&lt;/svg&gt;&lt;span class=&quot;external-link-icon-sr-only&quot;&gt;open in new window&lt;/span&gt;&lt;/span&gt;&lt;/a&gt; 的「技术面试题篇」就有一篇文章详细介绍如何使用 Sorted Set 来设计制作一个排行榜。&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/database/redis/image-20220719071115140.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;&lt;h3 id=&quot;使用-set-实现抽奖系统需要用到什么命令&quot; tabindex=&quot;-1&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#使用-set-实现抽奖系统需要用到什么命令&quot; aria-hidden=&quot;true&quot;&gt;#&lt;/a&gt; 使用 Set 实现抽奖系统需要用到什么命令？&lt;/h3&gt;&lt;ul&gt;&lt;li&gt;&lt;code&gt;SPOP key count&lt;/code&gt; ： 随机移除并获取指定集合中一个或多个元素，适合不允许重复中奖的场景。&lt;/li&gt;&lt;li&gt;&lt;code&gt;SRANDMEMBER key count&lt;/code&gt; : 随机获取指定集合中指定数量的元素，适合允许重复中奖的场景。&lt;/li&gt;&lt;/ul&gt;&lt;h3 id=&quot;使用-bitmap-统计活跃用户怎么做&quot; tabindex=&quot;-1&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#使用-bitmap-统计活跃用户怎么做&quot; aria-hidden=&quot;true&quot;&gt;#&lt;/a&gt; 使用 Bitmap 统计活跃用户怎么做？&lt;/h3&gt;&lt;p&gt;使用日期（精确到天）作为 key，然后用户 ID 为 offset，如果当日活跃过就设置为 1。&lt;/p&gt;&lt;p&gt;初始化数据：&lt;/p&gt;&lt;div class=&quot;language-bash line-numbers-mode&quot; data-ext=&quot;sh&quot;&gt;&lt;pre class=&quot;language-bash&quot;&gt;&lt;code&gt;&lt;span class=&quot;token operator&quot;&gt;&amp;gt;&lt;/span&gt; SETBIT &lt;span class=&quot;token number&quot;&gt;20210308&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;1&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;integer&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;0&lt;/span&gt;
&lt;span class=&quot;token operator&quot;&gt;&amp;gt;&lt;/span&gt; SETBIT &lt;span class=&quot;token number&quot;&gt;20210308&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;2&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;1&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;integer&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;0&lt;/span&gt;
&lt;span class=&quot;token operator&quot;&gt;&amp;gt;&lt;/span&gt; SETBIT &lt;span class=&quot;token number&quot;&gt;20210309&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;1&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;integer&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;0&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;统计 20210308~20210309 总活跃用户数:&lt;/p&gt;&lt;div class=&quot;language-bash line-numbers-mode&quot; data-ext=&quot;sh&quot;&gt;&lt;pre class=&quot;language-bash&quot;&gt;&lt;code&gt;&lt;span class=&quot;token operator&quot;&gt;&amp;gt;&lt;/span&gt; BITOP and desk1 &lt;span class=&quot;token number&quot;&gt;20210308&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;20210309&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;integer&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;1&lt;/span&gt;
&lt;span class=&quot;token operator&quot;&gt;&amp;gt;&lt;/span&gt; BITCOUNT desk1
&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;integer&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;1&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;统计 20210308~20210309 在线活跃用户数:&lt;/p&gt;&lt;div class=&quot;language-bash line-numbers-mode&quot; data-ext=&quot;sh&quot;&gt;&lt;pre class=&quot;language-bash&quot;&gt;&lt;code&gt;&lt;span class=&quot;token operator&quot;&gt;&amp;gt;&lt;/span&gt; BITOP or desk2 &lt;span class=&quot;token number&quot;&gt;20210308&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;20210309&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;integer&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;1&lt;/span&gt;
&lt;span class=&quot;token operator&quot;&gt;&amp;gt;&lt;/span&gt; BITCOUNT desk2
&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;integer&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;2&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&quot;使用-hyperloglog-统计页面-uv-怎么做&quot; tabindex=&quot;-1&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#使用-hyperloglog-统计页面-uv-怎么做&quot; aria-hidden=&quot;true&quot;&gt;#&lt;/a&gt; 使用 HyperLogLog 统计页面 UV 怎么做？&lt;/h3&gt;&lt;p&gt;1、将访问指定页面的每个用户 ID 添加到 &lt;code&gt;HyperLogLog&lt;/code&gt; 中。&lt;/p&gt;&lt;div class=&quot;language-bash line-numbers-mode&quot; data-ext=&quot;sh&quot;&gt;&lt;pre class=&quot;language-bash&quot;&gt;&lt;code&gt;PFADD PAGE_1:UV USER1 USER2 &lt;span class=&quot;token punctuation&quot;&gt;..&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;..&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;..&lt;/span&gt; USERn
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;2、统计指定页面的 UV。&lt;/p&gt;&lt;h2 id=&quot;redis-线程模型&quot; tabindex=&quot;-1&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#redis-线程模型&quot; aria-hidden=&quot;true&quot;&gt;#&lt;/a&gt; Redis 线程模型&lt;/h2&gt;&lt;p&gt;对于读写命令来说，Redis 一直是单线程模型。不过，在 Redis 4.0 版本之后引入了多线程来执行一些大键值对的异步删除操作， Redis 6.0 版本之后引入了多线程来处理网络请求（提高网络 IO 读写性能）。&lt;/p&gt;&lt;h3 id=&quot;redis-单线程模型了解吗&quot; tabindex=&quot;-1&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#redis-单线程模型了解吗&quot; aria-hidden=&quot;true&quot;&gt;#&lt;/a&gt; Redis 单线程模型了解吗？&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;Redis 基于 Reactor 模式设计开发了一套高效的事件处理模型&lt;/strong&gt; （Netty 的线程模型也基于 Reactor 模式，Reactor 模式不愧是高性能 IO 的基石），这套事件处理模型对应的是 Redis 中的文件事件处理器（file event handler）。由于文件事件处理器（file event handler）是单线程方式运行的，所以我们一般都说 Redis 是单线程模型。&lt;/p&gt;&lt;p&gt;《Redis 设计与实现》有一段话是如是介绍文件事件处理器的，我觉得写得挺不错。&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;Redis 基于 Reactor 模式开发了自己的网络事件处理器：这个处理器被称为文件事件处理器（file event handler）。&lt;/p&gt;&lt;ul&gt;&lt;li&gt;文件事件处理器使用 I/O 多路复用（multiplexing）程序来同时监听多个套接字，并根据套接字目前执行的任务来为套接字关联不同的事件处理器。&lt;/li&gt;&lt;li&gt;当被监听的套接字准备好执行连接应答（accept）、读取（read）、写入（write）、关 闭（close）等操作时，与操作相对应的文件事件就会产生，这时文件事件处理器就会调用套接字之前关联好的事件处理器来处理这些事件。&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;虽然文件事件处理器以单线程方式运行，但通过使用 I/O 多路复用程序来监听多个套接字&lt;/strong&gt;，文件事件处理器既实现了高性能的网络通信模型，又可以很好地与 Redis 服务器中其他同样以单线程方式运行的模块进行对接，这保持了 Redis 内部单线程设计的简单性。&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;strong&gt;既然是单线程，那怎么监听大量的客户端连接呢？&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;Redis 通过 &lt;strong&gt;IO 多路复用程序&lt;/strong&gt; 来监听来自客户端的大量连接（或者说是监听多个 socket），它会将感兴趣的事件及类型（读、写）注册到内核中并监听每个事件是否发生。&lt;/p&gt;&lt;p&gt;这样的好处非常明显： &lt;strong&gt;I/O 多路复用技术的使用让 Redis 不需要额外创建多余的线程来监听客户端的大量连接，降低了资源的消耗&lt;/strong&gt;（和 NIO 中的 &lt;code&gt;Selector&lt;/code&gt; 组件很像）。&lt;/p&gt;&lt;p&gt;文件事件处理器（file event handler）主要是包含 4 个部分：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;多个 socket（客户端连接）&lt;/li&gt;&lt;li&gt;IO 多路复用程序（支持多个客户端连接的关键）&lt;/li&gt;&lt;li&gt;文件事件分派器（将 socket 关联到相应的事件处理器）&lt;/li&gt;&lt;li&gt;事件处理器（连接应答处理器、命令请求处理器、命令回复处理器）&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/database/redis/redis-event-handler.png&quot; alt=&quot;文件事件处理器&quot;/&gt;&lt;/p&gt;&lt;p&gt;相关阅读：&lt;a href=&quot;http://remcarpediem.net/article/1aa2da89/&quot; target=&quot;_blank&quot; rel=&quot;noopener noreferrer&quot;&gt;Redis 事件机制详解&lt;span&gt;&lt;svg class=&quot;external-link-icon&quot; xmlns=&quot;http://www.w3.org/2000/svg&quot; aria-hidden=&quot;true&quot; focusable=&quot;false&quot; x=&quot;0px&quot; y=&quot;0px&quot; viewbox=&quot;0 0 100 100&quot;&gt;&lt;path fill=&quot;currentColor&quot; d=&quot;M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z&quot;/&gt;&lt;polygon fill=&quot;currentColor&quot; points=&quot;45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9&quot;/&gt;&lt;/svg&gt;&lt;span class=&quot;external-link-icon-sr-only&quot;&gt;open in new window&lt;/span&gt;&lt;/span&gt;&lt;/a&gt; 。&lt;/p&gt;&lt;h3 id=&quot;redis6-0-之前为什么不使用多线程&quot; tabindex=&quot;-1&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#redis6-0-之前为什么不使用多线程&quot; aria-hidden=&quot;true&quot;&gt;#&lt;/a&gt; Redis6.0 之前为什么不使用多线程？&lt;/h3&gt;&lt;p&gt;虽然说 Redis 是单线程模型，但是，实际上，&lt;strong&gt;Redis 在 4.0 之后的版本中就已经加入了对多线程的支持。&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;不过，Redis 4.0 增加的多线程主要是针对一些大键值对的删除操作的命令，使用这些命令就会使用主线程之外的其他线程来“异步处理”。&lt;/p&gt;&lt;p&gt;为此，Redis 4.0 之后新增了&lt;code&gt;UNLINK&lt;/code&gt;（可以看作是 &lt;code&gt;DEL&lt;/code&gt; 的异步版本）、&lt;code&gt;FLUSHALL ASYNC&lt;/code&gt;（清空所有数据库的所有 key，不仅仅是当前 &lt;code&gt;SELECT&lt;/code&gt; 的数据库）、&lt;code&gt;FLUSHDB ASYNC&lt;/code&gt;（清空当前 &lt;code&gt;SELECT&lt;/code&gt; 数据库中的所有 key）等异步命令。&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/database/redis/redis4.0-more-thread.png&quot; alt=&quot;redis4.0 more thread&quot;/&gt;&lt;/p&gt;&lt;p&gt;大体上来说，Redis 6.0 之前主要还是单线程处理。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;那 Redis6.0 之前为什么不使用多线程？&lt;/strong&gt; 我觉得主要原因有 3 点：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;单线程编程容易并且更容易维护；&lt;/li&gt;&lt;li&gt;Redis 的性能瓶颈不在 CPU ，主要在内存和网络；&lt;/li&gt;&lt;li&gt;多线程就会存在死锁、线程上下文切换等问题，甚至会影响性能。&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;相关阅读：&lt;a href=&quot;https://draveness.me/whys-the-design-redis-single-thread/&quot; target=&quot;_blank&quot; rel=&quot;noopener noreferrer&quot;&gt;为什么 Redis 选择单线程模型&lt;span&gt;&lt;svg class=&quot;external-link-icon&quot; xmlns=&quot;http://www.w3.org/2000/svg&quot; aria-hidden=&quot;true&quot; focusable=&quot;false&quot; x=&quot;0px&quot; y=&quot;0px&quot; viewbox=&quot;0 0 100 100&quot;&gt;&lt;path fill=&quot;currentColor&quot; d=&quot;M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z&quot;/&gt;&lt;polygon fill=&quot;currentColor&quot; points=&quot;45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9&quot;/&gt;&lt;/svg&gt;&lt;span class=&quot;external-link-icon-sr-only&quot;&gt;open in new window&lt;/span&gt;&lt;/span&gt;&lt;/a&gt; 。&lt;/p&gt;&lt;h3 id=&quot;redis6-0-之后为何引入了多线程&quot; tabindex=&quot;-1&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#redis6-0-之后为何引入了多线程&quot; aria-hidden=&quot;true&quot;&gt;#&lt;/a&gt; Redis6.0 之后为何引入了多线程？&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;Redis6.0 引入多线程主要是为了提高网络 IO 读写性能&lt;/strong&gt;，因为这个算是 Redis 中的一个性能瓶颈（Redis 的瓶颈主要受限于内存和网络）。&lt;/p&gt;&lt;p&gt;虽然，Redis6.0 引入了多线程，但是 Redis 的多线程只是在网络数据的读写这类耗时操作上使用了，执行命令仍然是单线程顺序执行。因此，你也不需要担心线程安全问题。&lt;/p&gt;&lt;p&gt;Redis6.0 的多线程默认是禁用的，只使用主线程。如需开启需要设置IO线程数 &amp;gt; 1，需要修改 redis 配置文件 &lt;code&gt;redis.conf&lt;/code&gt; ：&lt;/p&gt;&lt;div class=&quot;language-bash line-numbers-mode&quot; data-ext=&quot;sh&quot;&gt;&lt;pre class=&quot;language-bash&quot;&gt;&lt;code&gt;io-threads &lt;span class=&quot;token number&quot;&gt;4&lt;/span&gt; &lt;span class=&quot;token comment&quot;&gt;#设置1的话只会开启主线程，官网建议4核的机器建议设置为2或3个线程，8核的建议设置为6个线程&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;另外：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;io-threads的个数一旦设置，不能通过config动态设置&lt;/li&gt;&lt;li&gt;当设置ssl后，io-threads将不工作&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;开启多线程后，默认只会使用多线程进行IO写入writes，即发送数据给客户端，如果需要开启多线程IO读取reads，同样需要修改 redis 配置文件 &lt;code&gt;redis.conf&lt;/code&gt; :&lt;/p&gt;&lt;p&gt;但是官网描述开启多线程读并不能有太大提升，因此一般情况下并不建议开启&lt;/p&gt;&lt;p&gt;相关阅读：&lt;/p&gt;&lt;h2 id=&quot;redis-内存管理&quot; tabindex=&quot;-1&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#redis-内存管理&quot; aria-hidden=&quot;true&quot;&gt;#&lt;/a&gt; Redis 内存管理&lt;/h2&gt;&lt;h3 id=&quot;redis-给缓存数据设置过期时间有啥用&quot; tabindex=&quot;-1&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#redis-给缓存数据设置过期时间有啥用&quot; aria-hidden=&quot;true&quot;&gt;#&lt;/a&gt; Redis 给缓存数据设置过期时间有啥用？&lt;/h3&gt;&lt;p&gt;一般情况下，我们设置保存的缓存数据的时候都会设置一个过期时间。为什么呢？&lt;/p&gt;&lt;p&gt;因为内存是有限的，如果缓存中的所有数据都是一直保存的话，分分钟直接 Out of memory。&lt;/p&gt;&lt;p&gt;Redis 自带了给缓存数据设置过期时间的功能，比如：&lt;/p&gt;&lt;div class=&quot;language-bash line-numbers-mode&quot; data-ext=&quot;sh&quot;&gt;&lt;pre class=&quot;language-bash&quot;&gt;&lt;code&gt;&lt;span class=&quot;token number&quot;&gt;127.0&lt;/span&gt;.0.1:637&lt;span class=&quot;token operator&quot;&gt;&lt;span class=&quot;token file-descriptor important&quot;&gt;9&lt;/span&gt;&amp;gt;&lt;/span&gt; expire key &lt;span class=&quot;token number&quot;&gt;60&lt;/span&gt; &lt;span class=&quot;token comment&quot;&gt;# 数据在 60s 后过期&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;integer&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;1&lt;/span&gt;
&lt;span class=&quot;token number&quot;&gt;127.0&lt;/span&gt;.0.1:637&lt;span class=&quot;token operator&quot;&gt;&lt;span class=&quot;token file-descriptor important&quot;&gt;9&lt;/span&gt;&amp;gt;&lt;/span&gt; setex key &lt;span class=&quot;token number&quot;&gt;60&lt;/span&gt; value &lt;span class=&quot;token comment&quot;&gt;# 数据在 60s 后过期 (setex:[set] + [ex]pire)&lt;/span&gt;
OK
&lt;span class=&quot;token number&quot;&gt;127.0&lt;/span&gt;.0.1:637&lt;span class=&quot;token operator&quot;&gt;&lt;span class=&quot;token file-descriptor important&quot;&gt;9&lt;/span&gt;&amp;gt;&lt;/span&gt; ttl key &lt;span class=&quot;token comment&quot;&gt;# 查看数据还有多久过期&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;integer&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;56&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;注意：&lt;strong&gt;Redis 中除了字符串类型有自己独有设置过期时间的命令 &lt;code&gt;setex&lt;/code&gt; 外，其他方法都需要依靠 &lt;code&gt;expire&lt;/code&gt; 命令来设置过期时间 。另外， &lt;code&gt;persist&lt;/code&gt; 命令可以移除一个键的过期时间。&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;过期时间除了有助于缓解内存的消耗，还有什么其他用么？&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;很多时候，我们的业务场景就是需要某个数据只在某一时间段内存在，比如我们的短信验证码可能只在 1 分钟内有效，用户登录的 token 可能只在 1 天内有效。&lt;/p&gt;&lt;p&gt;如果使用传统的数据库来处理的话，一般都是自己判断过期，这样更麻烦并且性能要差很多。&lt;/p&gt;&lt;h3 id=&quot;redis-是如何判断数据是否过期的呢&quot; tabindex=&quot;-1&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#redis-是如何判断数据是否过期的呢&quot; aria-hidden=&quot;true&quot;&gt;#&lt;/a&gt; Redis 是如何判断数据是否过期的呢？&lt;/h3&gt;&lt;p&gt;Redis 通过一个叫做过期字典（可以看作是 hash 表）来保存数据过期的时间。过期字典的键指向 Redis 数据库中的某个 key(键)，过期字典的值是一个 long long 类型的整数，这个整数保存了 key 所指向的数据库键的过期时间（毫秒精度的 UNIX 时间戳）。&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/database/redis/redis-expired-dictionary.png&quot; alt=&quot;redis过期字典&quot;/&gt;&lt;/p&gt;&lt;p&gt;过期字典是存储在 redisDb 这个结构里的：&lt;/p&gt;&lt;div class=&quot;language-c line-numbers-mode&quot; data-ext=&quot;c&quot;&gt;&lt;pre class=&quot;language-c&quot;&gt;&lt;code&gt;&lt;span class=&quot;token keyword&quot;&gt;typedef&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;redisDb&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;

    dict &lt;span class=&quot;token operator&quot;&gt;*&lt;/span&gt;dict&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;     &lt;span class=&quot;token comment&quot;&gt;//数据库键空间,保存着数据库中所有键值对&lt;/span&gt;
    dict &lt;span class=&quot;token operator&quot;&gt;*&lt;/span&gt;expires   &lt;span class=&quot;token comment&quot;&gt;// 过期字典,保存着键的过期时间&lt;/span&gt;
    &lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt; redisDb&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&quot;过期的数据的删除策略了解么&quot; tabindex=&quot;-1&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#过期的数据的删除策略了解么&quot; aria-hidden=&quot;true&quot;&gt;#&lt;/a&gt; 过期的数据的删除策略了解么？&lt;/h3&gt;&lt;p&gt;如果假设你设置了一批 key 只能存活 1 分钟，那么 1 分钟后，Redis 是怎么对这批 key 进行删除的呢？&lt;/p&gt;&lt;p&gt;常用的过期数据的删除策略就两个（重要！自己造缓存轮子的时候需要格外考虑的东西）：&lt;/p&gt;&lt;ol&gt;&lt;li&gt;&lt;strong&gt;惰性删除&lt;/strong&gt; ：只会在取出 key 的时候才对数据进行过期检查。这样对 CPU 最友好，但是可能会造成太多过期 key 没有被删除。&lt;/li&gt;&lt;li&gt;&lt;strong&gt;定期删除&lt;/strong&gt; ： 每隔一段时间抽取一批 key 执行删除过期 key 操作。并且，Redis 底层会通过限制删除操作执行的时长和频率来减少删除操作对 CPU 时间的影响。&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;定期删除对内存更加友好，惰性删除对 CPU 更加友好。两者各有千秋，所以 Redis 采用的是 &lt;strong&gt;定期删除+惰性/懒汉式删除&lt;/strong&gt; 。&lt;/p&gt;&lt;p&gt;但是，仅仅通过给 key 设置过期时间还是有问题的。因为还是可能存在定期删除和惰性删除漏掉了很多过期 key 的情况。这样就导致大量过期 key 堆积在内存里，然后就 Out of memory 了。&lt;/p&gt;&lt;p&gt;怎么解决这个问题呢？答案就是：&lt;strong&gt;Redis 内存淘汰机制。&lt;/strong&gt;&lt;/p&gt;&lt;h3 id=&quot;redis-内存淘汰机制了解么&quot; tabindex=&quot;-1&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#redis-内存淘汰机制了解么&quot; aria-hidden=&quot;true&quot;&gt;#&lt;/a&gt; Redis 内存淘汰机制了解么？&lt;/h3&gt;&lt;blockquote&gt;&lt;p&gt;相关问题：MySQL 里有 2000w 数据，Redis 中只存 20w 的数据，如何保证 Redis 中的数据都是热点数据?&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;Redis 提供 6 种数据淘汰策略：&lt;/p&gt;&lt;ol&gt;&lt;li&gt;&lt;strong&gt;volatile-lru（least recently used）&lt;/strong&gt;：从已设置过期时间的数据集（server.db[i].expires）中挑选最近最少使用的数据淘汰&lt;/li&gt;&lt;li&gt;&lt;strong&gt;volatile-ttl&lt;/strong&gt;：从已设置过期时间的数据集（server.db[i].expires）中挑选将要过期的数据淘汰&lt;/li&gt;&lt;li&gt;&lt;strong&gt;volatile-random&lt;/strong&gt;：从已设置过期时间的数据集（server.db[i].expires）中任意选择数据淘汰&lt;/li&gt;&lt;li&gt;&lt;strong&gt;allkeys-lru（least recently used）&lt;/strong&gt;：当内存不足以容纳新写入数据时，在键空间中，移除最近最少使用的 key（这个是最常用的）&lt;/li&gt;&lt;li&gt;&lt;strong&gt;allkeys-random&lt;/strong&gt;：从数据集（server.db[i].dict）中任意选择数据淘汰&lt;/li&gt;&lt;li&gt;&lt;strong&gt;no-eviction&lt;/strong&gt;：禁止驱逐数据，也就是说当内存不足以容纳新写入数据时，新写入操作会报错。这个应该没人使用吧！&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;4.0 版本后增加以下两种：&lt;/p&gt;&lt;ol start=&quot;7&quot;&gt;&lt;li&gt;&lt;strong&gt;volatile-lfu（least frequently used）&lt;/strong&gt;：从已设置过期时间的数据集（server.db[i].expires）中挑选最不经常使用的数据淘汰&lt;/li&gt;&lt;li&gt;&lt;strong&gt;allkeys-lfu（least frequently used）&lt;/strong&gt;：当内存不足以容纳新写入数据时，在键空间中，移除最不经常使用的 key&lt;/li&gt;&lt;/ol&gt;&lt;h2 id=&quot;redis-持久化机制&quot; tabindex=&quot;-1&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#redis-持久化机制&quot; aria-hidden=&quot;true&quot;&gt;#&lt;/a&gt; Redis 持久化机制&lt;/h2&gt;&lt;h3 id=&quot;怎么保证-redis-挂掉之后再重启数据可以进行恢复&quot; tabindex=&quot;-1&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#怎么保证-redis-挂掉之后再重启数据可以进行恢复&quot; aria-hidden=&quot;true&quot;&gt;#&lt;/a&gt; 怎么保证 Redis 挂掉之后再重启数据可以进行恢复？&lt;/h3&gt;&lt;p&gt;很多时候我们需要持久化数据也就是将内存中的数据写入到硬盘里面，大部分原因是为了之后重用数据（比如重启机器、机器故障之后恢复数据），或者是为了防止系统故障而将数据备份到一个远程位置。&lt;/p&gt;&lt;p&gt;Redis 不同于 Memcached 的很重要一点就是，Redis 支持持久化，而且支持两种不同的持久化操作。&lt;strong&gt;Redis 的一种持久化方式叫快照（snapshotting，RDB），另一种方式是只追加文件（append-only file, AOF）&lt;/strong&gt;。这两种方法各有千秋，下面我会详细这两种持久化方法是什么，怎么用，如何选择适合自己的持久化方法。&lt;/p&gt;&lt;h3 id=&quot;什么是-rdb-持久化&quot; tabindex=&quot;-1&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#什么是-rdb-持久化&quot; aria-hidden=&quot;true&quot;&gt;#&lt;/a&gt; 什么是 RDB 持久化？&lt;/h3&gt;&lt;p&gt;Redis 可以通过创建快照来获得存储在内存里面的数据在某个时间点上的副本。Redis 创建快照之后，可以对快照进行备份，可以将快照复制到其他服务器从而创建具有相同数据的服务器副本（Redis 主从结构，主要用来提高 Redis 性能），还可以将快照留在原地以便重启服务器的时候使用。&lt;/p&gt;&lt;p&gt;快照持久化是 Redis 默认采用的持久化方式，在 &lt;code&gt;redis.conf&lt;/code&gt; 配置文件中默认有此下配置：&lt;/p&gt;&lt;div class=&quot;language-clojure line-numbers-mode&quot; data-ext=&quot;clojure&quot;&gt;&lt;pre class=&quot;language-clojure&quot;&gt;&lt;code&gt;save &lt;span class=&quot;token number&quot;&gt;900&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;1&lt;/span&gt;           &lt;span class=&quot;token operator&quot;&gt;#&lt;/span&gt;在&lt;span class=&quot;token number&quot;&gt;900&lt;/span&gt;秒&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token number&quot;&gt;15&lt;/span&gt;分钟&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;之后，如果至少有&lt;span class=&quot;token number&quot;&gt;1&lt;/span&gt;个key发生变化，Redis就会自动触发bgsave命令创建快照。

save &lt;span class=&quot;token number&quot;&gt;300&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;10&lt;/span&gt;          &lt;span class=&quot;token operator&quot;&gt;#&lt;/span&gt;在&lt;span class=&quot;token number&quot;&gt;300&lt;/span&gt;秒&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token number&quot;&gt;5&lt;/span&gt;分钟&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;之后，如果至少有&lt;span class=&quot;token number&quot;&gt;10&lt;/span&gt;个key发生变化，Redis就会自动触发bgsave命令创建快照。

save &lt;span class=&quot;token number&quot;&gt;60&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;10000&lt;/span&gt;        &lt;span class=&quot;token operator&quot;&gt;#&lt;/span&gt;在&lt;span class=&quot;token number&quot;&gt;60&lt;/span&gt;秒&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token number&quot;&gt;1&lt;/span&gt;分钟&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;之后，如果至少有&lt;span class=&quot;token number&quot;&gt;10000&lt;/span&gt;个key发生变化，Redis就会自动触发bgsave命令创建快照。
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&quot;rdb-创建快照时会阻塞主线程吗&quot; tabindex=&quot;-1&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#rdb-创建快照时会阻塞主线程吗&quot; aria-hidden=&quot;true&quot;&gt;#&lt;/a&gt; RDB 创建快照时会阻塞主线程吗？&lt;/h3&gt;&lt;p&gt;Redis 提供了两个命令来生成 RDB 快照文件：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;code&gt;save&lt;/code&gt; : 主线程执行，会阻塞主线程；&lt;/li&gt;&lt;li&gt;&lt;code&gt;bgsave&lt;/code&gt; : 子线程执行，不会阻塞主线程，默认选项。&lt;/li&gt;&lt;/ul&gt;&lt;h3 id=&quot;什么是-aof-持久化&quot; tabindex=&quot;-1&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#什么是-aof-持久化&quot; aria-hidden=&quot;true&quot;&gt;#&lt;/a&gt; 什么是 AOF 持久化？&lt;/h3&gt;&lt;p&gt;与快照持久化相比，AOF 持久化的实时性更好，因此已成为主流的持久化方案。默认情况下 Redis 没有开启 AOF（append only file）方式的持久化，可以通过 appendonly 参数开启：&lt;/p&gt;&lt;p&gt;开启 AOF 持久化后每执行一条会更改 Redis 中的数据的命令，Redis 就会将该命令写入到内存缓存 &lt;code&gt;server.aof_buf&lt;/code&gt; 中，然后再根据 &lt;code&gt;appendfsync&lt;/code&gt; 配置来决定何时将其同步到硬盘中的 AOF 文件。&lt;/p&gt;&lt;p&gt;AOF 文件的保存位置和 RDB 文件的位置相同，都是通过 dir 参数设置的，默认的文件名是 &lt;code&gt;appendonly.aof&lt;/code&gt;。&lt;/p&gt;&lt;p&gt;在 Redis 的配置文件中存在三种不同的 AOF 持久化方式，它们分别是：&lt;/p&gt;&lt;div class=&quot;language-bash line-numbers-mode&quot; data-ext=&quot;sh&quot;&gt;&lt;pre class=&quot;language-bash&quot;&gt;&lt;code&gt;appendfsync always    &lt;span class=&quot;token comment&quot;&gt;#每次有数据修改发生时都会写入AOF文件,这样会严重降低Redis的速度&lt;/span&gt;
appendfsync everysec  &lt;span class=&quot;token comment&quot;&gt;#每秒钟同步一次，显式地将多个写命令同步到硬盘&lt;/span&gt;
appendfsync no        &lt;span class=&quot;token comment&quot;&gt;#让操作系统决定何时进行同步&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;为了兼顾数据和写入性能，用户可以考虑 &lt;code&gt;appendfsync everysec&lt;/code&gt; 选项 ，让 Redis 每秒同步一次 AOF 文件，Redis 性能几乎没受到任何影响。而且这样即使出现系统崩溃，用户最多只会丢失一秒之内产生的数据。当硬盘忙于执行写入操作的时候，Redis 还会优雅的放慢自己的速度以便适应硬盘的最大写入速度。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;相关 issue&lt;/strong&gt; ：&lt;/p&gt;&lt;h3 id=&quot;aof-日志是如何实现的&quot; tabindex=&quot;-1&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#aof-日志是如何实现的&quot; aria-hidden=&quot;true&quot;&gt;#&lt;/a&gt; AOF 日志是如何实现的？&lt;/h3&gt;&lt;p&gt;关系型数据库（如 MySQL）通常都是执行命令之前记录日志（方便故障恢复），而 Redis AOF 持久化机制是在执行完命令之后再记录日志。&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;/assets/redis-aof-write-log-disc.ca22bd65.png&quot; alt=&quot;AOF 记录日志过程&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;为什么是在执行完命令之后记录日志呢？&lt;/strong&gt;&lt;/p&gt;&lt;ul&gt;&lt;li&gt;避免额外的检查开销，AOF 记录日志不会对命令进行语法检查；&lt;/li&gt;&lt;li&gt;在命令执行完之后再记录，不会阻塞当前的命令执行。&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;这样也带来了风险（我在前面介绍 AOF 持久化的时候也提到过）：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;如果刚执行完命令 Redis 就宕机会导致对应的修改丢失；&lt;/li&gt;&lt;li&gt;可能会阻塞后续其他命令的执行（AOF 记录日志是在 Redis 主线程中进行的）。&lt;/li&gt;&lt;/ul&gt;&lt;h3 id=&quot;aof-重写了解吗&quot; tabindex=&quot;-1&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#aof-重写了解吗&quot; aria-hidden=&quot;true&quot;&gt;#&lt;/a&gt; AOF 重写了解吗？&lt;/h3&gt;&lt;p&gt;当 AOF 变得太大时，Redis 能够在后台自动重写 AOF 产生一个新的 AOF 文件，这个新的 AOF 文件和原有的 AOF 文件所保存的数据库状态一样，但体积更小。&lt;/p&gt;&lt;p&gt;AOF 重写是一个有歧义的名字，该功能是通过读取数据库中的键值对来实现的，程序无须对现有 AOF 文件进行任何读入、分析或者写入操作。&lt;/p&gt;&lt;p&gt;在执行 &lt;code&gt;BGREWRITEAOF&lt;/code&gt; 命令时，Redis 服务器会维护一个 AOF 重写缓冲区，该缓冲区会在子进程创建新 AOF 文件期间，记录服务器执行的所有写命令。当子进程完成创建新 AOF 文件的工作之后，服务器会将重写缓冲区中的所有内容追加到新 AOF 文件的末尾，使得新的 AOF 文件保存的数据库状态与现有的数据库状态一致。最后，服务器用新的 AOF 文件替换旧的 AOF 文件，以此来完成 AOF 文件重写操作。&lt;/p&gt;&lt;p&gt;Redis 7.0 版本之前，如果在重写期间有写入命令，AOF 可能会使用大量内存，重写期间到达的所有写入命令都会写入磁盘两次。&lt;/p&gt;&lt;h3 id=&quot;如何选择-rdb-和-aof&quot; tabindex=&quot;-1&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#如何选择-rdb-和-aof&quot; aria-hidden=&quot;true&quot;&gt;#&lt;/a&gt; 如何选择 RDB 和 AOF？&lt;/h3&gt;&lt;p&gt;关于 RDB 和 AOF 的优缺点，官网上面也给了比较详细的说明&lt;a href=&quot;https://redis.io/docs/manual/persistence/&quot; target=&quot;_blank&quot; rel=&quot;noopener noreferrer&quot;&gt;Redis persistence&lt;span&gt;&lt;svg class=&quot;external-link-icon&quot; xmlns=&quot;http://www.w3.org/2000/svg&quot; aria-hidden=&quot;true&quot; focusable=&quot;false&quot; x=&quot;0px&quot; y=&quot;0px&quot; viewbox=&quot;0 0 100 100&quot;&gt;&lt;path fill=&quot;currentColor&quot; d=&quot;M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z&quot;/&gt;&lt;polygon fill=&quot;currentColor&quot; points=&quot;45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9&quot;/&gt;&lt;/svg&gt;&lt;span class=&quot;external-link-icon-sr-only&quot;&gt;open in new window&lt;/span&gt;&lt;/span&gt;&lt;/a&gt;，这里结合自己的理解简单总结一下。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;RDB 比 AOF 优秀的地方&lt;/strong&gt; ：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;RDB 文件存储的内容是经过压缩的二进制数据， 保存着某个时间点的数据集，文件很小，适合做数据的备份，灾难恢复。AOF 文件存储的是每一次写命令，类似于 MySQL 的 binlog 日志，通常会必 RDB 文件大很多。当 AOF 变得太大时，Redis 能够在后台自动重写 AOF。新的 AOF 文件和原有的 AOF 文件所保存的数据库状态一样，但体积更小。不过， Redis 7.0 版本之前，如果在重写期间有写入命令，AOF 可能会使用大量内存，重写期间到达的所有写入命令都会写入磁盘两次。&lt;/li&gt;&lt;li&gt;使用 RDB 文件恢复数据，直接解析还原数据即可，不需要一条一条地执行命令，速度非常快。而 AOF 则需要依次执行每个写命令，速度非常慢。也就是说，与 AOF 相比，恢复大数据集的时候，RDB 速度更快。&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;AOF 比 RDB 优秀的地方&lt;/strong&gt; ：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;RDB 的数据安全性不如 AOF，没有办法实时或者秒级持久化数据。生成 RDB 文件的过程是比繁重的， 虽然 BGSAVE 子进程写入 RDB 文件的工作不会阻塞主线程，但会对机器的 CPU 资源和内存资源产生影响，严重的情况下甚至会直接把 Redis 服务干宕机。AOF 支持秒级数据丢失（取决 fsync 策略，如果是 everysec，最多丢失 1 秒的数据），仅仅是追加命令到 AOF 文件，操作轻量。&lt;/li&gt;&lt;li&gt;RDB 文件是以特定的二进制格式保存的，并且在 Redis 版本演进中有多个版本的 RDB，所以存在老版本的 Redis 服务不兼容新版本的 RDB 格式的问题。&lt;/li&gt;&lt;li&gt;AOF 以一种易于理解和解析的格式包含所有操作的日志。你可以轻松地导出 AOF 文件进行分析，你也可以直接操作 AOF 文件来解决一些问题。比如，如果执行&lt;code&gt;FLUSHALL&lt;/code&gt;命令意外地刷新了所有内容后，只要 AOF 文件没有被重写，删除最新命令并重启即可恢复之前的状态。&lt;/li&gt;&lt;/ul&gt;&lt;h3 id=&quot;redis-4-0-对于持久化机制做了什么优化&quot; tabindex=&quot;-1&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#redis-4-0-对于持久化机制做了什么优化&quot; aria-hidden=&quot;true&quot;&gt;#&lt;/a&gt; Redis 4.0 对于持久化机制做了什么优化？&lt;/h3&gt;&lt;p&gt;由于 RDB 和 AOF 各有优势，于是，Redis 4.0 开始支持 RDB 和 AOF 的混合持久化（默认关闭，可以通过配置项 &lt;code&gt;aof-use-rdb-preamble&lt;/code&gt; 开启）。&lt;/p&gt;&lt;p&gt;如果把混合持久化打开，AOF 重写的时候就直接把 RDB 的内容写到 AOF 文件开头。这样做的好处是可以结合 RDB 和 AOF 的优点, 快速加载同时避免丢失过多的数据。当然缺点也是有的， AOF 里面的 RDB 部分是压缩格式不再是 AOF 格式，可读性较差。&lt;/p&gt;&lt;p&gt;官方文档地址：https://redis.io/topics/persistence&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/database/redis/redis4.0-persitence.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;&lt;h2 id=&quot;参考&quot; tabindex=&quot;-1&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#参考&quot; aria-hidden=&quot;true&quot;&gt;#&lt;/a&gt; 参考&lt;/h2&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>591255694af7a793f2e2584819f4f6d4</guid>
<title>Foundry 中文文档</title>
<link>https://toutiao.io/k/yswf266</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;RichText ztext Post-RichText css-1g0fqss&quot; options=&quot;[object Object]&quot;&gt;&lt;p data-first-child=&quot;&quot; data-pid=&quot;5mZG_iwU&quot;&gt;Foundry是一个Solidity智能合约开发工具链。Foundry管理您的依赖关系、编译项目、运行测试、部署，并允许您通过命令行和Solidity 脚本与链交互。&lt;/p&gt;&lt;p data-pid=&quot;ZQ8Qzogy&quot;&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//learnblockchain.cn/docs/foundry/i18n/zh/&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;Foundry 中文文档&lt;/a&gt;是基于官方 Foundry book 的翻译，全面介绍 Foundry 所有功能。&lt;/p&gt;&lt;h3&gt;使用Foundry的好处&lt;/h3&gt;&lt;ul&gt;&lt;li data-pid=&quot;ryQ9Npt0&quot;&gt;Foundry 全面支持 solidity，可有效减少上下文切换 与 hardhat+ethers 组合工具相比，hardhat+ethers 合约使用 solidity，而部署测试等使用 js 或者 ts。而对于 foundry 工具，合约、部署、测试等都使用 solidity，不需要在多种编程语言之间进行切换。&lt;/li&gt;&lt;li data-pid=&quot;Mlyo-bRB&quot;&gt;功能更齐全。如 cast 命令可以直接从 etherscan 下载源代码，可以直接从 abi 生成 interface 等功能。&lt;/li&gt;&lt;li data-pid=&quot;hhsHqoD6&quot;&gt;运行速度更快。&lt;/li&gt;&lt;/ul&gt;&lt;h3&gt;Foundry 组成&lt;/h3&gt;&lt;p data-pid=&quot;lllKrzhH&quot;&gt;Forge: 以太坊测试框架（如Truffle，Hardhat和DappTools）， 包含命令函及&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//learnblockchain.cn/docs/foundry/i18n/zh/forge/forge-std.html&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;标准库&lt;/a&gt; &lt;a href=&quot;https://link.zhihu.com/?target=https%3A//learnblockchain.cn/docs/foundry/i18n/zh/cast/index.html&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;Cast&lt;/a&gt;: 用于与EVM智能合约交互，发送交易和获取链数据. &lt;a href=&quot;https://link.zhihu.com/?target=https%3A//learnblockchain.cn/docs/foundry/i18n/zh/anvil/index.html&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;Anvil&lt;/a&gt;: 本地以太坊节点，类似于Ganache或Hardhat网络.&lt;/p&gt;&lt;p data-pid=&quot;NXLmcFgg&quot;&gt;Foundry 中文文档由登链社区组织翻译，代码库在：&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//github.com/lbc-team/foundry-book-in-chinese&quot; class=&quot; external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;&lt;span class=&quot;invisible&quot;&gt;https://&lt;/span&gt;&lt;span class=&quot;visible&quot;&gt;github.com/lbc-team/fou&lt;/span&gt;&lt;span class=&quot;invisible&quot;&gt;ndry-book-in-chinese&lt;/span&gt;&lt;span class=&quot;ellipsis&quot;/&gt;&lt;/a&gt; ， 欢迎大家提交 PR。 &lt;/p&gt;&lt;p data-pid=&quot;Z_zpASZb&quot;&gt;Foundry 中文文档链接：&lt;/p&gt;&lt;a target=&quot;_blank&quot; href=&quot;https://link.zhihu.com/?target=https%3A//learnblockchain.cn/docs/foundry/i18n/zh/&quot; data-draft-node=&quot;block&quot; data-draft-type=&quot;link-card&quot; data-image=&quot;https://pic3.zhimg.com/v2-5f9267254cdfd1b914031c64074319ea_180x120.jpg&quot; data-image-width=&quot;2048&quot; data-image-height=&quot;1032&quot; data-text=&quot;Foundry 官方文档中文版&quot; class=&quot;LinkCard new&quot;&gt;&lt;span class=&quot;LinkCard-contents&quot;&gt;&lt;span class=&quot;LinkCard-title loading&quot; data-text=&quot;true&quot;/&gt;&lt;span class=&quot;LinkCard-desc loading&quot;/&gt;&lt;/span&gt;&lt;span class=&quot;LinkCard-image LinkCard-image--default&quot;/&gt;&lt;/a&gt;&lt;h3&gt;Foundry 中文预览&lt;/h3&gt;&lt;p class=&quot;ztext-empty-paragraph&quot;&gt;&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-b5ac17863df5959dc505a4f5798c220a_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1763&quot; data-rawheight=&quot;835&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic3.zhimg.com/v2-b5ac17863df5959dc505a4f5798c220a_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1763&quot; data-rawheight=&quot;835&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic3.zhimg.com/v2-b5ac17863df5959dc505a4f5798c220a_r.jpg&quot; data-actualsrc=&quot;https://pic3.zhimg.com/v2-b5ac17863df5959dc505a4f5798c220a_b.jpg&quot;/&gt;&lt;figcaption&gt;在这里插入图片描述&lt;/figcaption&gt;&lt;/figure&gt;&lt;p class=&quot;ztext-empty-paragraph&quot;&gt;&lt;/p&gt;&lt;h3&gt;Foundry 文档内容导航&lt;/h3&gt;&lt;p data-pid=&quot;ZZET0hlI&quot;&gt;&lt;b&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//learnblockchain.cn/docs/foundry/i18n/zh/getting-started/installation.html&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;开始使用Foundry&lt;/a&gt;&lt;/b&gt;&lt;/p&gt;&lt;p data-pid=&quot;kdcBhyOk&quot;&gt;要开始使用Foundry，请安装Foundry并设置第一个项目。&lt;/p&gt;&lt;p data-pid=&quot;PepR0Qfl&quot;&gt;&lt;b&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//learnblockchain.cn/docs/foundry/i18n/zh/projects/creating-a-new-project.html&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;启动Foundry项目&lt;/a&gt;&lt;/b&gt;&lt;/p&gt;&lt;p data-pid=&quot;DejG1URQ&quot;&gt;本节将向您概述如何创建和使用现有项目。&lt;/p&gt;&lt;p data-pid=&quot;6s5HvNXT&quot;&gt;&lt;b&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//learnblockchain.cn/docs/foundry/i18n/zh/forge&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;Forge 概述&lt;/a&gt;&lt;/b&gt;&lt;/p&gt;&lt;p data-pid=&quot;oxIyeuC3&quot;&gt;本节概述将为您提供有关如何使用“伪造”来开发、测试和部署智能合约所需的所有知识。&lt;/p&gt;&lt;p data-pid=&quot;nN5clZFR&quot;&gt;&lt;b&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//learnblockchain.cn/docs/foundry/i18n/zh/cast&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;Cast 概述&lt;/a&gt;&lt;/b&gt;&lt;/p&gt;&lt;p data-pid=&quot;tbAqdglZ&quot;&gt;了解如何使用“cast”与智能合约交互、发送交易以及从命令行获取链上数据。&lt;/p&gt;&lt;p data-pid=&quot;-OaC1qqP&quot;&gt;&lt;b&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//learnblockchain.cn/docs/foundry/i18n/zh/anvil&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;Anvil 概述&lt;/a&gt;&lt;/b&gt;&lt;/p&gt;&lt;p data-pid=&quot;wq5K3Ql4&quot;&gt;了解 &lt;code&gt;anvil&lt;/code&gt;, Foundry的本地节点。&lt;/p&gt;&lt;p data-pid=&quot;n8HBgiNC&quot;&gt;&lt;b&gt;Foundry 配置&lt;/b&gt;&lt;/p&gt;&lt;p data-pid=&quot;GOiMI23F&quot;&gt;Foundry配置指引:&lt;/p&gt;&lt;p data-pid=&quot;L9hm0vRA&quot;&gt;&lt;b&gt;教程&lt;/b&gt;&lt;/p&gt;&lt;p data-pid=&quot;_TrVXFBi&quot;&gt;与Foundry建立智能合约的教程。&lt;/p&gt;&lt;p data-pid=&quot;0RxVVYCg&quot;&gt;&lt;b&gt;附录&lt;/b&gt;&lt;/p&gt;&lt;p data-pid=&quot;7nLkzYiq&quot;&gt;参考手册, 疑难解答等等&lt;/p&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>