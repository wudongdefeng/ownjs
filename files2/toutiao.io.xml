<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>0583022516052871c2858945bd1e7bd8</guid>
<title>基于 Apache Flink 的实时计算数据流业务引擎在京东零售的实践和落地</title>
<link>https://toutiao.io/k/ed87kju</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;RichText ztext Post-RichText css-1g0fqss&quot; options=&quot;[object Object]&quot;&gt;&lt;blockquote data-first-child=&quot;&quot; data-pid=&quot;bREqKCiZ&quot;&gt;&lt;b&gt;摘要：&lt;/b&gt;本文整理自京东零售-技术研发与数据中心张颖&amp;amp;闫莉刚在 ApacheCon Asia 2022 的分享。内容主要包括五个方面：&lt;br/&gt;&lt;br/&gt;1. 京东零售实时计算的现状&lt;br/&gt;2. 实时计算框架&lt;br/&gt;3. 场景优化：TopN&lt;br/&gt;4. 场景优化：动线分析&lt;br/&gt;5. 场景优化：FLINK 一站式机器学习&lt;/blockquote&gt;&lt;p data-pid=&quot;Rcr1FB5z&quot;&gt;&lt;br/&gt;&lt;br/&gt;&lt;u&gt;&lt;b&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//flink-learning.org.cn/&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;点击查看更多技术内容&lt;/a&gt;&lt;/b&gt;&lt;/u&gt;&lt;/p&gt;&lt;p data-pid=&quot;fsv0BYSt&quot;&gt;&lt;br/&gt;&lt;br/&gt;一、京东零售实时计算的现状&lt;/p&gt;&lt;p data-pid=&quot;W24GyCNG&quot;&gt;&lt;br/&gt;1.1 现状&lt;/p&gt;&lt;ul&gt;&lt;li data-pid=&quot;vwvOiRgq&quot;&gt;技术门槛高、学习成本大、开发周期长。行业内实时开发能力只有少数人能够掌握的现状；&lt;/li&gt;&lt;li data-pid=&quot;NmhA9HJj&quot;&gt;数据开发迭代效率比较低，重复逻辑反复的开发缺少复用；&lt;/li&gt;&lt;li data-pid=&quot;nFgceY0Q&quot;&gt;测试运维难，复杂业务逻辑难以局部测试。&lt;/li&gt;&lt;/ul&gt;&lt;p data-pid=&quot;V7Wlsb4V&quot;&gt;1.2 动力&lt;/p&gt;&lt;ul&gt;&lt;li data-pid=&quot;ZoaBHnVk&quot;&gt;降本增效、节省人力，助力高效开发；&lt;/li&gt;&lt;li data-pid=&quot;2VlCf7dW&quot;&gt;多角色数据开发，不同角色对应不同的开发方式，非数据人员也能做数据开发的工作。&lt;/li&gt;&lt;/ul&gt;&lt;p data-pid=&quot;SkJp5lLA&quot;&gt;1.3 目标&lt;/p&gt;&lt;ul&gt;&lt;li data-pid=&quot;wVvc8uoA&quot;&gt;降低数据开发门槛，通过标准化积木式的开发，实现低代码配置化数据加工，进一步实现图形化清晰表达数据流转；&lt;/li&gt;&lt;li data-pid=&quot;kvWUhP3u&quot;&gt;通过算子库组件的沉淀，提升开发效率，提高复用性，一站式加工；&lt;/li&gt;&lt;li data-pid=&quot;AlpIwLU5&quot;&gt;通过单元测试以及沉淀用例，提高开发质量。&lt;/li&gt;&lt;/ul&gt;&lt;p data-pid=&quot;efyrAZcY&quot;&gt;二、实时计算框架&lt;/p&gt;&lt;p data-pid=&quot;ndXXFHoP&quot;&gt;&lt;br/&gt;2.1 为什么做数据流框架&lt;/p&gt;&lt;ul&gt;&lt;li data-pid=&quot;FFG22WC7&quot;&gt;数据流框架：9N-Tamias/9N-Combustor，数据流框架基于计算引擎之上，提供一种易用高效的数据开发方式，包括：tamias，是基于 Flink 的引擎的开发框架；combustor：基于 Spark 引擎的开发框架。基于 9N-Tamias 和 9N-Combustor 提供数据流开发工具；&lt;/li&gt;&lt;li data-pid=&quot;lKh8dbqZ&quot;&gt;支持实时离线统一的表达；&lt;/li&gt;&lt;li data-pid=&quot;wJqaIEt9&quot;&gt;多种使用方式：图形化、配置化、SDK 等；&lt;/li&gt;&lt;li data-pid=&quot;kl-v1vk1&quot;&gt;算子、组件复用：数据流算子、转换算子、自定义算子、目标源算子，灵活的组合，沉淀常用的算子组合，组件化包括数据流组件和自定义组件，通过数据流开发沉淀数据流组件，同时也开放自主开发自定义组件方式，通过算子、组件的复用，提高开发效率。&lt;/li&gt;&lt;/ul&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-eacc4ba335648e6791c4b06991db8437_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;2290&quot; data-rawheight=&quot;1138&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic4.zhimg.com/v2-eacc4ba335648e6791c4b06991db8437_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;2290&quot; data-rawheight=&quot;1138&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic4.zhimg.com/v2-eacc4ba335648e6791c4b06991db8437_r.jpg&quot; data-actualsrc=&quot;https://pic4.zhimg.com/v2-eacc4ba335648e6791c4b06991db8437_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p data-pid=&quot;p0xOpyuU&quot;&gt;&lt;br/&gt;数据流框架上层各业务场景基于数据流组件化，实现业务数据的加工，包括样本中心、京享值、搜索等一些业务。&lt;br/&gt;2.2 怎么做实时计算框架？&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-1d36774ef62e6f75b535ab112e062f6d_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;2196&quot; data-rawheight=&quot;988&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic2.zhimg.com/v2-1d36774ef62e6f75b535ab112e062f6d_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;2196&quot; data-rawheight=&quot;988&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic2.zhimg.com/v2-1d36774ef62e6f75b535ab112e062f6d_r.jpg&quot; data-actualsrc=&quot;https://pic2.zhimg.com/v2-1d36774ef62e6f75b535ab112e062f6d_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p data-pid=&quot;GanR8b_0&quot;&gt;&lt;br/&gt;实时计算框架分成四层：&lt;/p&gt;&lt;ul&gt;&lt;li data-pid=&quot;9iScisji&quot;&gt;Function 层：实现比如 Json 解析、RPC 调用、以及数据流的链接；&lt;/li&gt;&lt;li data-pid=&quot;bQ41QHrK&quot;&gt;Process 层：对 Flink 引擎、Data Stream、Data Set、SQL 等 API 进行封装；&lt;/li&gt;&lt;li data-pid=&quot;tYXKsmoS&quot;&gt;Function 和 Process 组合生成 Operator，对具体的处理逻辑进行封装，比如实现 Source、Sink、Filter、Join 等常用的算子；&lt;/li&gt;&lt;li data-pid=&quot;haGpjYct&quot;&gt;一个或者多个 Operator 构成不同的场景，比如多流拼接导数的 Top N、动线分析，这些构成了 JSON 的配置文件，然后再通过通用的引擎解析配置文件提交任务。&lt;/li&gt;&lt;/ul&gt;&lt;p data-pid=&quot;VaI38dTL&quot;&gt;2.3 实时框架：公用 Ops 和 Function&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-8f0356e30210410b2a3c6ce3ef72b2c1_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;2286&quot; data-rawheight=&quot;1260&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic2.zhimg.com/v2-8f0356e30210410b2a3c6ce3ef72b2c1_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;2286&quot; data-rawheight=&quot;1260&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic2.zhimg.com/v2-8f0356e30210410b2a3c6ce3ef72b2c1_r.jpg&quot; data-actualsrc=&quot;https://pic2.zhimg.com/v2-8f0356e30210410b2a3c6ce3ef72b2c1_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p data-pid=&quot;9FFRNioL&quot;&gt;&lt;br/&gt;数据接入 Source 和 Sink 层：实现了实时离线、近线常用的数据源；&lt;/p&gt;&lt;p data-pid=&quot;DJ-m01TK&quot;&gt;&lt;br/&gt;数据解析 Function：是为了将公用的计算逻辑进一步细化，在算子里封装多个 Function，进行灵活实现业务的逻辑；&lt;/p&gt;&lt;p data-pid=&quot;chckc4Xg&quot;&gt;&lt;br/&gt;算子 Template：如多流拼接、TopN、Count Time Window，业务自己实现会比较复杂，因此框架提供了这些算子的 Template，业务只需要在 Template 的基础上增加业务代码即可，不需要再对这些通用的算子进行学习、开发、调试等工作；&lt;/p&gt;&lt;p data-pid=&quot;JiYIWsG0&quot;&gt;&lt;br/&gt;业务算子：可以基于 Template 已有的业务算子，重写得到新的业务算子，也可以自定义组合 Function，形成业务算子。&lt;/p&gt;&lt;p data-pid=&quot;3PJAYywE&quot;&gt;&lt;br/&gt;优点如下：&lt;/p&gt;&lt;ul&gt;&lt;li data-pid=&quot;OsJjksqe&quot;&gt;开发标准化：基于框架提供的公用算子，组合完成业务标准化的开发；&lt;/li&gt;&lt;li data-pid=&quot;Xaue3Nce&quot;&gt;易用性提升：框架提供一些常用且难以实现的算子，使业务的开发变得简单；&lt;/li&gt;&lt;li data-pid=&quot;_hyX85aq&quot;&gt;开发迭代效率提升：业务只需要关注业务逻辑，从而提高开发迭代效率质量的提升；&lt;/li&gt;&lt;li data-pid=&quot;czCLqmFM&quot;&gt;质量提升：框架提供的公共算子都是经过严格的测试，并经过长期的业务验证，从而提高开发质量。&lt;/li&gt;&lt;/ul&gt;&lt;p data-pid=&quot;LvgDUPt2&quot;&gt;三、场景优化：TopN&lt;/p&gt;&lt;p data-pid=&quot;aTrBwnAI&quot;&gt;&lt;br/&gt;3.1 复用算子&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-f975b41d73e8a53d77139f552da61f34_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;2268&quot; data-rawheight=&quot;1132&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic1.zhimg.com/v2-f975b41d73e8a53d77139f552da61f34_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;2268&quot; data-rawheight=&quot;1132&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic1.zhimg.com/v2-f975b41d73e8a53d77139f552da61f34_r.jpg&quot; data-actualsrc=&quot;https://pic1.zhimg.com/v2-f975b41d73e8a53d77139f552da61f34_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p data-pid=&quot;IO8Nux6b&quot;&gt;&lt;br/&gt;首先不仅仅是 TopN，包括所有业务场景，数据接入和数据写出都是可以共用的，比如针对流计算，像 Kafka 或 JMQ 的接入和写出，都是可以复用的。&lt;/p&gt;&lt;p data-pid=&quot;0HgYeDrS&quot;&gt;&lt;br/&gt;然后是数据解析的算子，包括 JSON 解析、CSV 解析都是可以复用的，但是如果每一个 JSON 解析和 CSV 解析都抽象成一个 Operator，会需要很多的 Operator，因此抽象了 Function 概念，然后 Function 可以组合成公用的算子。&lt;/p&gt;&lt;p data-pid=&quot;gpvyRsHw&quot;&gt;&lt;br/&gt;【案例】以榜单计算为例，首先用订单榜单的一个元素值作为一个计算，然后 KeyBy 时用榜单 ID 加元素，接下来再进行一次订单榜单元素值的计算，把榜单 ID 和元素值进行一次 KeyBy，产生的 TopN 的排序。&lt;br/&gt;在这里需要 KeyBy 两次，因为在京东的固有的场景下，有业务上的数据倾斜，只能采用多次聚合，或者是多次排序的方式来解决问题。&lt;/p&gt;&lt;p data-pid=&quot;7T_WSmVp&quot;&gt;&lt;br/&gt;3.2 任务优化&lt;/p&gt;&lt;p data-pid=&quot;05N9Rzbr&quot;&gt;&lt;br/&gt;HDFS 小文件的问题：因为数据量非常大，因此在写 HDFS 时，如果 Rolling 策略设置不合理，会导致 HDFS 产生很多的小文件，可能会把 HDFS Name Node 的 RPC 请求队列打满。通过源码及其任务机制发现，HDFS 的文件 Rolling 的策略与 Checkpoint 的时间以及 Sink 的并行度相关，因此合理设置 Checkpoint 的时间和 Sink 的并行度，可以有效解决 Sink HDFS 的小文件的问题。&lt;/p&gt;&lt;p data-pid=&quot;EzJ-wvO5&quot;&gt;&lt;br/&gt;RocksDB 优化：通过查看官方文档可以发现，针对 RocksDB 相关的优化有很多，但是如何有效优化 RocksDB 的设置，核心就在于合理地设置 BlockCache 和 WriteBuffer 的大小，还可以添加 BloomFilter，相应调整这些参数，具体采用哪些配置都可以。&lt;/p&gt;&lt;p data-pid=&quot;QOeEENKq&quot;&gt;&lt;br/&gt;Checkpoint 优化：主要是超时时间、间隔时间、最小停顿时间。比如超时时间是半个小时，这个任务产生了 Fail 了，假如它是在 29 分钟的时候，进行 Failover 的时候，需要从上个 Checkpoint 开始恢复，需要很快消费前 29 分钟的数据。这种情况下如果数据量非常大，对任务是一个不小的冲击。但是如果把 Checkpoint 的时间设置为更合适的 5 分钟或者 10 分钟，这个冲击量会少很多。&lt;/p&gt;&lt;p data-pid=&quot;yeX4Rn_z&quot;&gt;&lt;br/&gt;数据倾斜：造成数据的倾斜的情况有很多种，比较难解决的是数据源中引发的数据倾斜问题，因此可以采用多次聚合或者多次排序模式解决；另外一个是机器问题，是由于某台机器问题造成的数据倾斜，通常的表现是这台机器上所有的 Subtask 或者 TM 都会产生问题。&lt;/p&gt;&lt;p data-pid=&quot;6JPrriZf&quot;&gt;&lt;br/&gt;四、场景优化：动线分析&lt;/p&gt;&lt;p data-pid=&quot;beykdiaa&quot;&gt;&lt;br/&gt;4.1 什么是动线&lt;/p&gt;&lt;p data-pid=&quot;ZX-nr8_j&quot;&gt;&lt;br/&gt;用户点击以及页面展现的浏览路径称之为是动线；以搜索词举例，在京东平台首先搜索台灯，然后又搜索台灯学习，最后搜索儿童学习护眼台灯，从台灯到台灯学习，到儿童学习护眼台灯，这样搜索词的线称为搜索词动线。&lt;br/&gt;动线分析的作用：寻找决定转化的关键路径点以理解用户决策习惯；经常相邻查询的搜索词通过导流工具串联，发现趋势动线；同一个用户对不同排序策略的接受程度，最终从细分的用户类型，提出个性化的导购布局和策略建议；&lt;/p&gt;&lt;p data-pid=&quot;SauzucdF&quot;&gt;&lt;br/&gt;4.2 数据建模&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-a9b81ce4be89996e60de32c8f990ecf5_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;2266&quot; data-rawheight=&quot;1266&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic2.zhimg.com/v2-a9b81ce4be89996e60de32c8f990ecf5_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;2266&quot; data-rawheight=&quot;1266&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic2.zhimg.com/v2-a9b81ce4be89996e60de32c8f990ecf5_r.jpg&quot; data-actualsrc=&quot;https://pic2.zhimg.com/v2-a9b81ce4be89996e60de32c8f990ecf5_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p data-pid=&quot;whwuQvD6&quot;&gt;&lt;br/&gt;涉及到串联相邻的搜索词问题，需要从宏观的角度进行数据建模。&lt;/p&gt;&lt;p data-pid=&quot;JQvRhwS1&quot;&gt;&lt;br/&gt;首先在京东每天 PB 数据量的动线数据分析下，现有的图结构是没有办法解决这个问题。目前最常用的一个分析方法，是把大批量的这种数据全部同时灌到数据库里，然后等离线数据运行一段时间，拿到分析的结果从结果上去分析。&lt;/p&gt;&lt;p data-pid=&quot;Z4u-Nm3C&quot;&gt;&lt;br/&gt;当前业界在线图数据库进行这种大数据量的图分析，会严重地影响数据库的运行和对外提供服务，因此引入 Flink Gelly 技术栈，通过类似 MySQL 与 Hive 的模式，解决这种大规模图分析问题。&lt;/p&gt;&lt;p data-pid=&quot;J8M-5Lxd&quot;&gt;&lt;br/&gt;&lt;b&gt;解决方案：&lt;/b&gt;首先是把图的源数据通过 Flink SQL 从 Hive 里取出数据，通过 Left Join 把每个 Session ID 下面的 Query 链连起来，然后导入到 HDFS 里；从 HDFS 里读动线的数据，并且把动线的数据生成一个 Graph，根据数据科学家提出的分析条件，将图的分析的结果，直接灌到 OLAP 里进行多维的分析；数据流实时计算的框架，从 Hive 或者 HDFS 里读数据，然后通过数据的 Join，包括写 HDFS、Graph Generate、Graph Analyse 等以可配置化的形式，生成公用算子放到算子库里，对于搜索、推荐或者是广告等所有涉及到动线分析的部门，都可以用到。&lt;/p&gt;&lt;p data-pid=&quot;3ovHkeyS&quot;&gt;4.3 模型建模&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-34532573f9026bd0b10b9a6e0a2817c4_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;2288&quot; data-rawheight=&quot;1278&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic1.zhimg.com/v2-34532573f9026bd0b10b9a6e0a2817c4_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;2288&quot; data-rawheight=&quot;1278&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic1.zhimg.com/v2-34532573f9026bd0b10b9a6e0a2817c4_r.jpg&quot; data-actualsrc=&quot;https://pic1.zhimg.com/v2-34532573f9026bd0b10b9a6e0a2817c4_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p data-pid=&quot;4hec8AFW&quot;&gt;&lt;br/&gt;如果要对用户进行细分和个性化的分析，就涉及到模型建模。&lt;/p&gt;&lt;p data-pid=&quot;vbf9yoQ7&quot;&gt;&lt;br/&gt;首先是样本生产的过程，需要把数据从 Hive 里拿到，针对搜索词动线分析需要拿到用户搜索词的表，然后和相应的订单表里决定下单的 Query 进行左连接，生成样本放到 HDFS 里。&lt;/p&gt;&lt;p data-pid=&quot;tTPr-zsu&quot;&gt;&lt;br/&gt;训练任务是从 HDFS 里把这些数据灌到 Alink 里进行 Shaply Value 建模，最终的 Query 重要度写到 Hive 里。&lt;br/&gt;全链路是以公用算子的方式提供，目前京东采用这种离线训练的方式，相当于是天级，之后希望天级训练的模式实时化，做成分钟级的或者流式的 Join。&lt;/p&gt;&lt;p data-pid=&quot;8xlFoYue&quot;&gt;&lt;br/&gt;五、场景优化：FLINK 一站式机器学习&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-9b082e16b114ba7a44f39ccad6ba4435_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;2316&quot; data-rawheight=&quot;1260&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic2.zhimg.com/v2-9b082e16b114ba7a44f39ccad6ba4435_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;2316&quot; data-rawheight=&quot;1260&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic2.zhimg.com/v2-9b082e16b114ba7a44f39ccad6ba4435_r.jpg&quot; data-actualsrc=&quot;https://pic2.zhimg.com/v2-9b082e16b114ba7a44f39ccad6ba4435_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p data-pid=&quot;XOKAe2Kv&quot;&gt;&lt;br/&gt;机器学习可以从四个方面来描述：特征、样本、训练、预估，而每个方面都有相应的问题（如上图）。&lt;/p&gt;&lt;p data-pid=&quot;GCwzMCMp&quot;&gt;5.1 特征&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-fd7bb37bcb6e4602b20dc47b7828bcd9_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;2280&quot; data-rawheight=&quot;1048&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic2.zhimg.com/v2-fd7bb37bcb6e4602b20dc47b7828bcd9_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;2280&quot; data-rawheight=&quot;1048&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic2.zhimg.com/v2-fd7bb37bcb6e4602b20dc47b7828bcd9_r.jpg&quot; data-actualsrc=&quot;https://pic2.zhimg.com/v2-fd7bb37bcb6e4602b20dc47b7828bcd9_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p data-pid=&quot;RrsaKb-F&quot;&gt;&lt;br/&gt;从生成的角度，特征分为实时特征和离线特征；从特征的特性分为静态特征和动态特征。&lt;/p&gt;&lt;ul&gt;&lt;li data-pid=&quot;pTUPvhB3&quot;&gt;静态特征是相对变化不太大的特征，比如用户的年龄、店铺评分、商品金额，可以把静态特征和离线特征相对应；&lt;/li&gt;&lt;li data-pid=&quot;A_7eBeKs&quot;&gt;动态特征比如近一个小时内的点赞量，或者近一个小时内的点击量，动态特征和实时特征相对应。&lt;/li&gt;&lt;/ul&gt;&lt;p data-pid=&quot;D-Ayj9bi&quot;&gt;离线特征可以分为特征的整体生成过程。&lt;/p&gt;&lt;ul&gt;&lt;li data-pid=&quot;ATQNMx7B&quot;&gt;特征一般是放到 Hive 里，会涉及到一些特征的解析以及计算，最终生成一个特征的大宽表，然后把这些特征放到 Redis 里，如果是实时特征，涉及到数据接入以及数据解析行为。&lt;/li&gt;&lt;li data-pid=&quot;S7PfvsES&quot;&gt;特征生成可以认为是业务化的过程，特征写入可以直接写入 Redis 里。&lt;/li&gt;&lt;li data-pid=&quot;rOZkJq3I&quot;&gt;FeatureOPS 主要是专注于特征生成，如果特征解析涉及到业务算子，也可以用 FeatureOPS 来做。&lt;/li&gt;&lt;/ul&gt;&lt;p data-pid=&quot;TFwDmyeh&quot;&gt;5.2 样本&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-b1f28aff2473851580446bf5670c06b0_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;2270&quot; data-rawheight=&quot;1092&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic1.zhimg.com/v2-b1f28aff2473851580446bf5670c06b0_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;2270&quot; data-rawheight=&quot;1092&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic1.zhimg.com/v2-b1f28aff2473851580446bf5670c06b0_r.jpg&quot; data-actualsrc=&quot;https://pic1.zhimg.com/v2-b1f28aff2473851580446bf5670c06b0_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p data-pid=&quot;4QKfNql2&quot;&gt;&lt;br/&gt;样本分为实时样本拼接和离线样本拼接两个链路；针对样本的特性，有离线的样本和实时的样本两个链路。&lt;/p&gt;&lt;ul&gt;&lt;li data-pid=&quot;vHvnKqaS&quot;&gt;离线的样本拼接：通过 Join 存到数仓里，从数仓里拿取用户的曝光以及行为日志后，通过一系列的 Join 操作，形成样本的宽表，每个业务可以从样本宽表拿到属于自己的样本进行模型的训练。&lt;/li&gt;&lt;li data-pid=&quot;Ix1uFfg2&quot;&gt;实时的链路拼接也是相同的，区别是样本拼接为实时的。Flink 样本基本上都是双流的，采用 Unit 和 Timer 模式，适配多流的样本拼接，会涉及到大状态的优化，大状态目前用的 State Backend 是 Roll SDB。Watermark 更新机制是采用最慢的时间作为更新的机制，如果某一个行为流的数据量比较少，则会导致 Watermark 不更新的问题。&lt;/li&gt;&lt;li data-pid=&quot;hfHRNetC&quot;&gt;实时样本拼接针相对离线的样本拼接更加困难，包括一个窗口的选择、一些业务上的样本拼接等。&lt;/li&gt;&lt;/ul&gt;&lt;p data-pid=&quot;0EIYV3Rs&quot;&gt;Sample OPS 做样本质量的校验：首先在样本生成的阶段，需要做样本的分布，如正负样本的分布；其次在做实时样本或者是离线样本拼接时，需要对拼接率做监测；观察任务的延时率，即每一条样本的延时情况。&lt;br/&gt;模型升级定义为只有模型进行模型校正时，才会认为它升级了，而增量训练不是模型升级。&lt;/p&gt;&lt;p data-pid=&quot;KCZ-j94J&quot;&gt;5.3 模型 online learning&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-453e78635570837b70da37f59b90a4c2_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;2268&quot; data-rawheight=&quot;980&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic3.zhimg.com/v2-453e78635570837b70da37f59b90a4c2_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;2268&quot; data-rawheight=&quot;980&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic3.zhimg.com/v2-453e78635570837b70da37f59b90a4c2_r.jpg&quot; data-actualsrc=&quot;https://pic3.zhimg.com/v2-453e78635570837b70da37f59b90a4c2_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p data-pid=&quot;x-LwQMEU&quot;&gt;&lt;br/&gt;模型 online learning 是指数据科学方向，并非大模型的方向。按照特征和样本实时离线的 Template，把模型分为实时和离线两种。&lt;/p&gt;&lt;p data-pid=&quot;IDH_K1yx&quot;&gt;&lt;br/&gt;实时训练涉及到模型实时参数的更新，但并非每一条数据训练一次，由超时时间 CountWindow 解决这个问题，比如 Count 达到 1 万条或者超时时间 5 分钟，来解决 Mini Batch 的问题。&lt;/p&gt;&lt;p data-pid=&quot;j2SDymab&quot;&gt;&lt;br/&gt;针对 Online Learning，目前没有办法离线地做 AB，因此当一批数据进来时，可以先训练出一个模型，同样用这一批数据做 AB，以达到训练和 AB 的一体化。同时用离线的大数据量训练出来的模型，去及时校正实时训练出来的模型，防止模型训偏了；然后任务内部采用 Keyby 方式实现数据并行，解决模型分布式的问题。&lt;/p&gt;&lt;p data-pid=&quot;F9HWcqHe&quot;&gt;&lt;br/&gt;举例，如 Profit 模型，是采用报警维度指标来设置，同时在模型产出时将模型推到模型库，然后 Parameter Server 会不停地在模型库里面把当前的模型的参数快照打到模型库里。&lt;/p&gt;&lt;p data-pid=&quot;xP0qAIfO&quot;&gt;&lt;br/&gt;5.4 预估&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-1bb5e74261d2cfec86989a9b10370a83_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;2262&quot; data-rawheight=&quot;1006&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic4.zhimg.com/v2-1bb5e74261d2cfec86989a9b10370a83_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;2262&quot; data-rawheight=&quot;1006&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic4.zhimg.com/v2-1bb5e74261d2cfec86989a9b10370a83_r.jpg&quot; data-actualsrc=&quot;https://pic4.zhimg.com/v2-1bb5e74261d2cfec86989a9b10370a83_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p data-pid=&quot;TMamHkUk&quot;&gt;&lt;br/&gt;Flink 做预估目前有两种方案：&lt;/p&gt;&lt;p data-pid=&quot;Fz0qxgAv&quot;&gt;&lt;br/&gt;方案 A 是将模型如 Tensorflow 或者 PyTorch 模型，通过 RPC 的方式或者 HTTP 的方式部署 Server，由 Flink Task 去远程 Invoke RPC 或者 HTTP，会有网络的开销。因为 Flink Task 可能是实时的，也有可能是离线的，所以在 invoke RPC 时，不可能让它随着 Flink 任务的启动而启动，或者随着 Flink 任务的停止而停止，需要有人来运维该 Server。&lt;/p&gt;&lt;p data-pid=&quot;NM0lBluA&quot;&gt;&lt;br/&gt;方案 B 是将模型 Load 到 Flink TM 内部，即在 Flink TM 内部 Inference 该模型，其优点是不用去维护 RPC 或者 HTTP 的 Server，从资源的角度减少了网络开销，节省了资源。&lt;/p&gt;&lt;p data-pid=&quot;a_6ZhyIN&quot;&gt;&lt;br/&gt;&lt;br/&gt;&lt;u&gt;&lt;b&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//flink-learning.org.cn/&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;点击查看更多技术内容&lt;/a&gt;&lt;/b&gt;&lt;/u&gt;&lt;br/&gt;&lt;/p&gt;&lt;hr/&gt;&lt;p data-pid=&quot;WZGAPc1Q&quot;&gt;更多内容&lt;br/&gt;&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-a9d00a78c4908885be3f6b9d8be1618b_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1920&quot; data-rawheight=&quot;675&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic4.zhimg.com/v2-a9d00a78c4908885be3f6b9d8be1618b_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1920&quot; data-rawheight=&quot;675&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic4.zhimg.com/v2-a9d00a78c4908885be3f6b9d8be1618b_r.jpg&quot; data-actualsrc=&quot;https://pic4.zhimg.com/v2-a9d00a78c4908885be3f6b9d8be1618b_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;br/&gt;&lt;hr/&gt;&lt;p data-pid=&quot;-iVa8XM3&quot;&gt;&lt;b&gt;活动推荐&lt;/b&gt;&lt;br/&gt;阿里云基于 Apache Flink 构建的企业级产品-实时计算Flink版现开启活动：&lt;br/&gt;99 元试用 &lt;a href=&quot;https://link.zhihu.com/?target=https%3A//www.aliyun.com/product/bigdata/sc&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;实时计算Flink版&lt;/a&gt;（包年包月、10CU）即有机会获得 Flink 独家定制卫衣；另包 3 个月及以上还有 85 折优惠！&lt;br/&gt;了解活动详情：&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//www.aliyun.com/product/bigdata/sc&quot; class=&quot; external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;&lt;span class=&quot;invisible&quot;&gt;https://www.&lt;/span&gt;&lt;span class=&quot;visible&quot;&gt;aliyun.com/product/bigd&lt;/span&gt;&lt;span class=&quot;invisible&quot;&gt;ata/sc&lt;/span&gt;&lt;span class=&quot;ellipsis&quot;/&gt;&lt;/a&gt;&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-0ee7e368a68b6f2dd023bdc0683e9397_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;5653&quot; data-rawheight=&quot;3144&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic4.zhimg.com/v2-0ee7e368a68b6f2dd023bdc0683e9397_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;5653&quot; data-rawheight=&quot;3144&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic4.zhimg.com/v2-0ee7e368a68b6f2dd023bdc0683e9397_r.jpg&quot; data-actualsrc=&quot;https://pic4.zhimg.com/v2-0ee7e368a68b6f2dd023bdc0683e9397_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p/&gt;&lt;p/&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>e581157b02f9c701c2f12d94000aa19d</guid>
<title>React 正式推出全新官方文档！</title>
<link>https://toutiao.io/k/8ccy85p</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content js_underline_content               autoTypeSetting24psection&amp;#10;            &quot; id=&quot;js_content&quot;&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;3 月 17 日，在 React 新文档的 Beta 版上线一年之后，React 终于正式发布了全新的 React 官方文档！新文档已启用新的域名：&lt;span&gt;&lt;strong&gt;https://react.dev/&lt;/strong&gt;&lt;/span&gt;&lt;strong&gt;&lt;strong&gt;。不过，目前&lt;/strong&gt;新文档只发布了英文版&lt;/strong&gt;，中文版并未上线。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1.0212962962962964&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/EO58xpw5UMNvUY9G1LVlR5t6Eymp8TWvG8Nia2teDBFZZ6UjAtQG9hkGsgFX2kIdAno6Lvq6OSDUhCMFyPW3t7w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;目前，访问 Beta 版文档（&lt;span&gt;&lt;strong&gt;https://beta.reactjs.org/&lt;/strong&gt;&lt;/span&gt;）和英文文档（&lt;span&gt;&lt;strong&gt;https://reactjs.org/&lt;/strong&gt;&lt;/span&gt;）时，都会重定向到新域名（&lt;span&gt;&lt;strong&gt;https://react.dev/&lt;/strong&gt;&lt;/span&gt;）。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.4203703703703704&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/EO58xpw5UMNvUY9G1LVlR5t6Eymp8TWvSgAxuqmh8iaNickqbpVa3FDN78W1QxuYXYTyXEHBAwlXWgZjywDEJQ6A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;新的文档目前并未提供其他语言的文档入口。&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;如需访问旧的&lt;strong&gt;中文版&lt;/strong&gt;文档，可以访问：&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;https://zh-hans.reactjs.org/&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;如需访问旧的&lt;strong&gt;英文版&lt;/strong&gt;文档，可以访问：&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;https://legacy.reactjs.org/&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;新文档主要包含以下部分：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;教程和指南&lt;/strong&gt;：提供了大量的教程和指南，帮助开发者从零开始学习React或深入研究特定主题。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;代码示例和演示&lt;/strong&gt;：提供了一系列的代码示例和演示，展示了React的强大和灵活性。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;最佳实践和技巧&lt;/strong&gt;：了解最新的 React 最佳实践和技巧，学习如何优化代码以实现更好的性能。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;社区论坛&lt;/strong&gt;：与其他 React 开发人员联系，在项目中获得帮助或在社区分享专业知识。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;新闻和更新&lt;/strong&gt;：第一时间了解 React 开发团队的最新版本、更新和新闻。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;下面就来看看全新的 React 文档都有哪些特色！&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;全面拥抱 Hooks&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当 2018 年发布 Hooks 时，Hooks 文档假设读者已经熟悉类组件。这有助于社区迅速采用 Hooks，但过了一段时间，旧文档就无法满足新读者的需求。新读者必须要学习两次React：&lt;strong&gt;先学习类组件，再学习 Hooks。&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;而新文档全面拥抱 Hooks，从开始就教授如何使用 Hooks 来学习 React。文档分为两个主要部分：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;Learn React&lt;/span&gt;&lt;sup&gt;[1]&lt;/sup&gt;：一个自学课程，从零开始教授React。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;API Reference&lt;/span&gt;&lt;sup&gt;[2]&lt;/sup&gt;：提供了每个 React API 的详细信息和使用示例。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;&lt;strong&gt;注意&lt;/strong&gt;：目前仍有一些类组件用例没有基于 Hook 的实现。类组件仍然得到支持，并在新站点的 &lt;span&gt;Legacy API&lt;/span&gt;&lt;sup&gt;[3]&lt;/sup&gt; 部分进行了记录。&lt;/p&gt;&lt;/blockquote&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;Learn&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Learn 包含两部分：Quick Start 和 Learn React。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;Quick Start&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;React 学习教程的入门部分，介绍了 React 的基本概念和语法，例如组件、属性和状态等。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果希望通过实践学习，文档还提供了一个井字棋教程。该教程使用 React 构建了一个井字棋小游戏，并教授了一些开发技能。这是一个在线交互式教程，可以自己尝试修改：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.496&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/EO58xpw5UMNvUY9G1LVlR5t6Eymp8TWvFEbxhicEQkCLt8JPzZ64zrCQLrPRJE0x4Z7HXQjPTnlxia0BUkSC5GSQ/640?wx_fmt=gif&quot; data-type=&quot;gif&quot; data-w=&quot;1000&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;除了井字棋教程之外，这一部分还包含了一个 Thinking in React 教程，帮助用户更深刻的理解 React。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上面的井字棋沙箱只是新文档众多示例的其中之一，整个网站添加了超过 &lt;strong&gt;600&lt;/strong&gt; 个沙箱！可以编辑任何沙箱，或在右上角按“Fork”将其在一个单独的选项卡中打开。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;Learn React&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Quick Start 部分并没有详细介绍如何使用 React。可以在 Learn React 部分一步步学习 如何使用 React。该部分包含四个模块：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;Describing the UI&lt;/strong&gt;：如何用组件显示信息&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;Adding Interactivity&lt;/strong&gt;：如何响应用户输入更新屏幕&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;Managing State&lt;/strong&gt;：如何在应用变得越来越复杂时组织逻辑&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;Escape Hatches&lt;/strong&gt;：如何“走出”React，以及什么时候这样做最有意义&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Learn 部分的大多数页面都以一些挑战结尾，以检查理解程度。例如，以下是有关条件渲染页面的挑战：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6398148148148148&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/EO58xpw5UMNvUY9G1LVlR5t6Eymp8TWvUMC1FLGI3J4fux9cWcmAt0t6WibBm3cY7ADNP2gnL5VN4tkkAvGOsvQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在每个挑战的左下角都有一个 Show solution 按钮，可以点击查看挑战的解决方案。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在教程中，通过了很多更直观的图表，以帮助快速快速理解。例如，这是 Preserving and Resetting State 中的一张图表：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.44074074074074077&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/EO58xpw5UMNvUY9G1LVlR5t6Eymp8TWvXpAKMbxhoWEVGBkVNDleXuoHA3lgwPNxzMyqITrGWvT9CWm7YUb1Fw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot; title=&quot;当 section 变为 div 时，section 被删除并添加新的 div&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们还可以在新文档中看到一些插图，下面是绘制屏幕的浏览器：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6305555555555555&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/EO58xpw5UMNvUY9G1LVlR5t6Eymp8TWvAnju1wEALMXzWf0ZsXlwGicBqV0pekRibT5dt7XkibqGSObQ7UqNNpTfQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/figure&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;API Reference&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在 API Reference 中，每个 React API 现在都有一个专用的页面。这包括各种 API：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;内置 Hooks，如 &lt;code&gt;useState&lt;/code&gt;。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;内置组件，如 &lt;code&gt;&amp;lt;Suspense&amp;gt;&lt;/code&gt;。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;内置浏览器组件，如 &lt;code&gt;&amp;lt;input&amp;gt;&lt;/code&gt;。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;面向框架的 API，例如 &lt;code&gt;renderToPipeableStream&lt;/code&gt;。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;其他 React API，例如 &lt;code&gt;memo&lt;/code&gt;。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;每个 API 页面都至少分为两个部分：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;Reference&lt;/strong&gt;：通过列出其参数和返回值来描述 API 的签名。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;Usage&lt;/strong&gt;：显示了为什么以及如何在实践中使用此 API。它显示了 React 团队如何使用每个 API 的典型场景。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6453703703703704&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/EO58xpw5UMNvUY9G1LVlR5t6Eymp8TWvO1J0UWfIHXdVYN53IznLBibXdBz9tNq6UFWxagxVr3RGSYD8W6w1t1A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;除此之外，一些 API 页面还包括故障排除（针对常见问题）和备选方案（针对已弃用的 API）。希望这种方法将使 API Reference 不仅作为一种查找参数的方式，而且作为一种方式来查看可以使用任何给定的 API 执行的所有不同的事情——以及它如何连接到其他 API。&lt;/p&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;Community&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;React 拥有一个由数百万开发人员组成的社区，Community 部分包含了一些可以加入的 React 相关社区。除此之外，还包含了React 会议、React 视频、React 聚会、React 团队、React 文档贡献者、致谢以及版本控制策略。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5462962962962963&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/EO58xpw5UMNvUY9G1LVlR5t6Eymp8TWvOicyuRbGIbicmLxQLYh4dJMRvN3KCOG4jTDUtwvAJXrPjia8xAzsRsXqw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/figure&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;未来&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;React 团队花了很长时间才发布新文档。希望保持 React 社区应得的高质量标准。在编写这些文档和创建所有示例时，React 团队发现了自己的一些解释中的错误、React 中的错误，甚至现在正在努力解决的 React 设计中的漏洞。希望新文档能帮助 React 团队在未来将 React 提升到一个更高的标准。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;社区中还有许多对扩展网站内容和功能的要求，例如：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;为所有示例提供 TypeScript 版本；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;创建更新的性能、测试和可访问性指南；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;独立于支持它们的框架记录 React 服务端组件；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;与国际社区合作翻译新文档；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;向新网站添加缺少的功能（例如，博客的 RSS）。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;现在新文档已经发布了，未来 React 团队的重点就是添加新信息和进一步改进新网站。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;最后，期待新文档中文版能尽快上线！&lt;/span&gt;&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;span&gt;相关链接&lt;/span&gt;&lt;/span&gt;&lt;/h3&gt;&lt;section data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;span&gt;[1]&lt;/span&gt;&lt;p&gt;&lt;strong&gt;Learn React&lt;/strong&gt;: &lt;em&gt;https://react.dev/learn&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[2]&lt;/span&gt;&lt;p&gt;&lt;strong&gt;API Reference&lt;/strong&gt;: &lt;em&gt;https://react.dev/reference&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[3]&lt;/span&gt;&lt;p&gt;&lt;strong&gt;Legacy API&lt;/strong&gt;: &lt;em&gt;https://react.dev/reference/react/legacy&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;mp-style-type data-value=&quot;3&quot;/&gt;&lt;/p&gt;&lt;/div&gt;

          
        &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>981d860ad1f70cf4bf7c30a2743320bc</guid>
<title>实现异步的 8 种方式</title>
<link>https://toutiao.io/k/4bu3bsv</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content js_underline_content               defaultNoSetting&amp;#10;            &quot; id=&quot;js_content&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot; data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1.2857142857142858&quot; data-w=&quot;14&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/YK9e7vHy9IQATwibKVicOpXZibX8VOvBrnF39NdpXQMwdpyIgN0ibicEwRdge0mXthxjHagHgwpWhrsibvMZFibaQC6vQ/640?wx_fmt=png&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot;/&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p data-mid=&quot;&quot; mpa-is-content=&quot;t&quot;&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;一、前言&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;img data-ratio=&quot;1.2857142857142858&quot; data-w=&quot;14&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/orc2J6rib40bATuJM23UiaHQ0tsVpvjgyuhk7To5zFqb2fyL9pCr1U7hfeKJELCht0KxWnuias6TLibMdcRhM7QhyQ/640?wx_fmt=png&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;section&gt;❝&lt;/section&gt;&lt;section&gt;异步执行对于开发者来说并不陌生，在实际的开发过程中，很多场景多会使用到异步，相比同步执行，异步可以大大缩短请求链路耗时时间，比如：&lt;strong&gt;「发送短信、邮件、异步更新等」&lt;/strong&gt;，这些都是典型的可以通过异步实现的场景。&lt;/section&gt;&lt;section&gt;❞&lt;/section&gt;&lt;/section&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/h2&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1.2857142857142858&quot; data-w=&quot;14&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/YK9e7vHy9IQATwibKVicOpXZibX8VOvBrnF39NdpXQMwdpyIgN0ibicEwRdge0mXthxjHagHgwpWhrsibvMZFibaQC6vQ/640?wx_fmt=png&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot;/&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p data-mid=&quot;&quot; mpa-is-content=&quot;t&quot;&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;二、异步的八种实现方式&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;img data-ratio=&quot;1.2857142857142858&quot; data-w=&quot;14&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/orc2J6rib40bATuJM23UiaHQ0tsVpvjgyuhk7To5zFqb2fyL9pCr1U7hfeKJELCht0KxWnuias6TLibMdcRhM7QhyQ/640?wx_fmt=png&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;section&gt;线程Thread&lt;/section&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;section&gt;Future&lt;/section&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;section&gt;异步框架CompletableFuture&lt;/section&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;section&gt;Spring注解@Async&lt;/section&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;section&gt;Spring ApplicationEvent事件&lt;/section&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;section&gt;消息队列&lt;/section&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;section&gt;第三方异步框架，比如Hutool的ThreadUtil&lt;/section&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;section&gt;Guava异步&lt;/section&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/h2&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;img class=&quot;rich_pages wxw-img js_img_placeholder&quot; data-ratio=&quot;1.2857142857142858&quot; data-w=&quot;14&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/YK9e7vHy9IQATwibKVicOpXZibX8VOvBrnF39NdpXQMwdpyIgN0ibicEwRdge0mXthxjHagHgwpWhrsibvMZFibaQC6vQ/640?wx_fmt=png&quot;/&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p data-mid=&quot;&quot; mpa-is-content=&quot;t&quot;&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;三、什么是异步？&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;img data-ratio=&quot;1.2857142857142858&quot; data-w=&quot;14&quot; class=&quot;js_img_placeholder&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/orc2J6rib40bATuJM23UiaHQ0tsVpvjgyuhk7To5zFqb2fyL9pCr1U7hfeKJELCht0KxWnuias6TLibMdcRhM7QhyQ/640?wx_fmt=png&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;首先我们先看一个常见的用户下单的场景：&lt;/section&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1.304&quot; data-type=&quot;other&quot; data-w=&quot;500&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz/ibnDyTicARr36XPaQevboOpibdoeXpWpG5eX9bYSMOZVs0eZUicX1uFluq3VOSmhG0s73icK1Jr5hLjew4fYwiaSS5CA/640?wx_fmt=jpeg&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;什么是异步&lt;/span&gt;&lt;/strong&gt;&lt;/section&gt;&lt;section&gt;在同步操作中，我们执行到 &lt;strong&gt;「发送短信」&lt;/strong&gt; 的时候，我们必须等待这个方法彻底执行完才能执行 &lt;strong&gt;「赠送积分」&lt;/strong&gt; 这个操作，如果 &lt;strong&gt;「赠送积分」&lt;/strong&gt; 这个动作执行时间较长，发送短信需要等待，这就是典型的同步场景。&lt;/section&gt;&lt;section&gt;实际上，发送短信和赠送积分没有任何的依赖关系，通过异步，我们可以实现&lt;code&gt;赠送积分&lt;/code&gt;和&lt;code&gt;发送短信&lt;/code&gt;这两个操作能够同时进行，比如：&lt;/section&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.9203125&quot; data-type=&quot;other&quot; data-w=&quot;640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz/ibnDyTicARr36XPaQevboOpibdoeXpWpG5eQgFibhVgOicDzjjSN1o5avGrw9PqAyqasAbXXiaXkFfH1Epz2I0vxbIjQ/640?wx_fmt=jpeg&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot;/&gt;&lt;strong&gt;&lt;span&gt;异步&lt;/span&gt;&lt;/strong&gt;&lt;/section&gt;&lt;section&gt;这就是所谓的异步，是不是非常简单，下面就说说异步的几种实现方式吧。&lt;/section&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/h2&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1.2857142857142858&quot; data-w=&quot;14&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/YK9e7vHy9IQATwibKVicOpXZibX8VOvBrnF39NdpXQMwdpyIgN0ibicEwRdge0mXthxjHagHgwpWhrsibvMZFibaQC6vQ/640?wx_fmt=png&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot;/&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p data-mid=&quot;&quot; mpa-is-content=&quot;t&quot;&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;四、异步编程&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;img data-ratio=&quot;1.2857142857142858&quot; data-w=&quot;14&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/orc2J6rib40bATuJM23UiaHQ0tsVpvjgyuhk7To5zFqb2fyL9pCr1U7hfeKJELCht0KxWnuias6TLibMdcRhM7QhyQ/640?wx_fmt=png&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;4.1 线程异步&lt;/span&gt;&lt;/h2&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;public class AsyncThread extends Thread {&lt;br/&gt;&lt;br/&gt;    @Override&lt;br/&gt;    public void &lt;span&gt;run&lt;/span&gt;() {&lt;br/&gt;        System.out.println(&lt;span&gt;&quot;Current thread name:&quot;&lt;/span&gt; + Thread.currentThread().getName() + &lt;span&gt;&quot; Send email success!&quot;&lt;/span&gt;);&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    public static void main(String[] args) {&lt;br/&gt;        AsyncThread asyncThread = new AsyncThread();&lt;br/&gt;        asyncThread.start();&lt;br/&gt;    }&lt;br/&gt;}&lt;/p&gt;&lt;/pre&gt;&lt;section&gt;当然如果每次都创建一个&lt;code&gt;Thread&lt;/code&gt;线程，频繁的创建、销毁，浪费系统资源，我们可以采用线程池：&lt;/section&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;private ExecutorService executorService = Executors.newCachedThreadPool();&lt;br/&gt;&lt;br/&gt;public void &lt;span&gt;fun&lt;/span&gt;() {&lt;br/&gt;    executorService.submit(new &lt;span&gt;Runnable&lt;/span&gt;() {&lt;br/&gt;        @Override&lt;br/&gt;        public void &lt;span&gt;run&lt;/span&gt;() {&lt;br/&gt;            log.info(&lt;span&gt;&quot;执行业务逻辑...&quot;&lt;/span&gt;);&lt;br/&gt;        }&lt;br/&gt;    });&lt;br/&gt;}&lt;/p&gt;&lt;/pre&gt;&lt;section&gt;可以将业务逻辑封装到&lt;code&gt;Runnable&lt;/code&gt;或&lt;code&gt;Callable&lt;/code&gt;中，交由线程池来执行。&lt;/section&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;4.2 Future异步&lt;/span&gt;&lt;/h2&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;@Slf4j&lt;br/&gt;public class FutureManager {&lt;br/&gt;&lt;br/&gt;    public String execute() throws Exception {&lt;br/&gt;&lt;br/&gt;        ExecutorService executor = Executors.newFixedThreadPool(1);&lt;br/&gt;        Future&amp;lt;String&amp;gt; future = executor.submit(new Callable&amp;lt;String&amp;gt;() {&lt;br/&gt;            @Override&lt;br/&gt;            public String call() throws Exception {&lt;br/&gt;&lt;br/&gt;                System.out.println(&lt;span&gt;&quot; --- task start --- &quot;&lt;/span&gt;);&lt;br/&gt;                Thread.sleep(3000);&lt;br/&gt;                System.out.println(&lt;span&gt;&quot; --- task finish ---&quot;&lt;/span&gt;);&lt;br/&gt;                &lt;span&gt;return&lt;/span&gt; &lt;span&gt;&quot;this is future execute final result!!!&quot;&lt;/span&gt;;&lt;br/&gt;            }&lt;br/&gt;        });&lt;br/&gt;&lt;br/&gt;        //这里需要返回值时会阻塞主线程&lt;br/&gt;        String result = future.get();&lt;br/&gt;        log.info(&lt;span&gt;&quot;Future get result: {}&quot;&lt;/span&gt;, result);&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; result;&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    @SneakyThrows&lt;br/&gt;    public static void main(String[] args) {&lt;br/&gt;        FutureManager manager = new FutureManager();&lt;br/&gt;        manager.execute();&lt;br/&gt;    }&lt;br/&gt;}&lt;/p&gt;&lt;/pre&gt;&lt;section&gt;输出结果：&lt;/section&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt; --- task start --- &lt;br/&gt; --- task finish ---&lt;br/&gt; Future get result: this is future execute final result!!!&lt;/p&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;4.2.1 Future的不足之处&lt;/h3&gt;&lt;section&gt;Future的不足之处的包括以下几点：&lt;/section&gt;&lt;section&gt;1️⃣ 无法被动接收异步任务的计算结果：虽然我们可以主动将异步任务提交给线程池中的线程来执行，但是待异步任务执行结束之后，主线程无法得到任务完成与否的通知，它需要通过get方法主动获取任务执行的结果。&lt;/section&gt;&lt;section&gt;2️⃣ Future件彼此孤立：有时某一个耗时很长的异步任务执行结束之后，你想利用它返回的结果再做进一步的运算，该运算也会是一个异步任务，两者之间的关系需要程序开发人员手动进行绑定赋予，Future并不能将其形成一个任务流（pipeline），每一个Future都是彼此之间都是孤立的，所以才有了后面的CompletableFuture，CompletableFuture就可以将多个Future串联起来形成任务流。&lt;/section&gt;&lt;section&gt;3️⃣ Futrue没有很好的错误处理机制：截止目前，如果某个异步任务在执行发的过程中发生了异常，调用者无法被动感知，必须通过捕获get方法的异常才知晓异步任务执行是否出现了错误，从而在做进一步的判断处理。&lt;/section&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;4.3 CompletableFuture实现异步&lt;/span&gt;&lt;/h2&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;public class CompletableFutureCompose {&lt;br/&gt;&lt;br/&gt;    /**&lt;br/&gt;     * thenAccept子任务和父任务公用同一个线程&lt;br/&gt;     */&lt;br/&gt;    @SneakyThrows&lt;br/&gt;    public static void &lt;span&gt;thenRunAsync&lt;/span&gt;() {&lt;br/&gt;        CompletableFuture&amp;lt;Integer&amp;gt; cf1 = CompletableFuture.supplyAsync(() -&amp;gt; {&lt;br/&gt;            System.out.println(Thread.currentThread() + &lt;span&gt;&quot; cf1 do something....&quot;&lt;/span&gt;);&lt;br/&gt;            &lt;span&gt;return&lt;/span&gt; 1;&lt;br/&gt;        });&lt;br/&gt;        CompletableFuture&amp;lt;Void&amp;gt; cf2 = cf1.thenRunAsync(() -&amp;gt; {&lt;br/&gt;            System.out.println(Thread.currentThread() + &lt;span&gt;&quot; cf2 do something...&quot;&lt;/span&gt;);&lt;br/&gt;        });&lt;br/&gt;        //等待任务1执行完成&lt;br/&gt;        System.out.println(&lt;span&gt;&quot;cf1结果-&amp;gt;&quot;&lt;/span&gt; + cf1.get());&lt;br/&gt;        //等待任务2执行完成&lt;br/&gt;        System.out.println(&lt;span&gt;&quot;cf2结果-&amp;gt;&quot;&lt;/span&gt; + cf2.get());&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    public static void main(String[] args) {&lt;br/&gt;        thenRunAsync();&lt;br/&gt;    }&lt;br/&gt;}&lt;/p&gt;&lt;/pre&gt;&lt;section&gt;我们不需要显式使用ExecutorService，CompletableFuture 内部使用了&lt;code&gt;ForkJoinPool&lt;/code&gt;来处理异步任务，如果在某些业务场景我们想自定义自己的异步线程池也是可以的。&lt;/section&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;4.4 Spring的@Async异步&lt;/span&gt;&lt;/h2&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;4.4.1 自定义异步线程池&lt;/h3&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;/**&lt;br/&gt; * 线程池参数配置，多个线程池实现线程池隔离，@Async注解，默认使用系统自定义线程池，可在项目中设置多个线程池，在异步调用的时候，指明需要调用的线程池名称，比如：@Async(&lt;span&gt;&quot;taskName&quot;&lt;/span&gt;)&lt;br/&gt;@EnableAsync&lt;br/&gt;@Configuration&lt;br/&gt;public class TaskPoolConfig {&lt;br/&gt;    /**&lt;br/&gt;     * 自定义线程池&lt;br/&gt;     *&lt;br/&gt;     **/&lt;br/&gt;    @Bean(&lt;span&gt;&quot;taskExecutor&quot;&lt;/span&gt;)&lt;br/&gt;    public Executor &lt;span&gt;taskExecutor&lt;/span&gt;() {&lt;br/&gt;        //返回可用处理器的Java虚拟机的数量 12&lt;br/&gt;        int i = Runtime.getRuntime().availableProcessors();&lt;br/&gt;        System.out.println(&lt;span&gt;&quot;系统最大线程数  ： &quot;&lt;/span&gt; + i);&lt;br/&gt;        ThreadPoolTaskExecutor executor = new ThreadPoolTaskExecutor();&lt;br/&gt;        //核心线程池大小&lt;br/&gt;        executor.setCorePoolSize(16);&lt;br/&gt;        //最大线程数&lt;br/&gt;        executor.setMaxPoolSize(20);&lt;br/&gt;        //配置队列容量，默认值为Integer.MAX_VALUE&lt;br/&gt;        executor.setQueueCapacity(99999);&lt;br/&gt;        //活跃时间&lt;br/&gt;        executor.setKeepAliveSeconds(60);&lt;br/&gt;        //线程名字前缀&lt;br/&gt;        executor.setThreadNamePrefix(&lt;span&gt;&quot;asyncServiceExecutor -&quot;&lt;/span&gt;);&lt;br/&gt;        //设置此执行程序应该在关闭时阻止的最大秒数，以便在容器的其余部分继续关闭之前等待剩余的任务完成他们的执行&lt;br/&gt;        executor.setAwaitTerminationSeconds(60);&lt;br/&gt;        //等待所有的任务结束后再关闭线程池&lt;br/&gt;        executor.setWaitForTasksToCompleteOnShutdown(&lt;span&gt;true&lt;/span&gt;);&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; executor;&lt;br/&gt;    }&lt;br/&gt;}&lt;/p&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;4.4.2 AsyncService&lt;/h3&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;public interface AsyncService {&lt;br/&gt;&lt;br/&gt;    MessageResult sendSms(String callPrefix, String mobile, String actionType, String content);&lt;br/&gt;&lt;br/&gt;    MessageResult sendEmail(String email, String subject, String content);&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;@Slf4j&lt;br/&gt;@Service&lt;br/&gt;public class AsyncServiceImpl implements AsyncService {&lt;br/&gt;&lt;br/&gt;    @Autowired&lt;br/&gt;    private IMessageHandler mesageHandler;&lt;br/&gt;&lt;br/&gt;    @Override&lt;br/&gt;    @Async(&lt;span&gt;&quot;taskExecutor&quot;&lt;/span&gt;)&lt;br/&gt;    public MessageResult sendSms(String callPrefix, String mobile, String actionType, String content) {&lt;br/&gt;        try {&lt;br/&gt;&lt;br/&gt;            Thread.sleep(1000);&lt;br/&gt;            mesageHandler.sendSms(callPrefix, mobile, actionType, content);&lt;br/&gt;&lt;br/&gt;        } catch (Exception e) {&lt;br/&gt;            log.error(&lt;span&gt;&quot;发送短信异常 -&amp;gt; &quot;&lt;/span&gt;, e)&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;    &lt;br/&gt;    @Override&lt;br/&gt;    @Async(&lt;span&gt;&quot;taskExecutor&quot;&lt;/span&gt;)&lt;br/&gt;    public sendEmail(String email, String subject, String content) {&lt;br/&gt;        try {&lt;br/&gt;&lt;br/&gt;            Thread.sleep(1000);&lt;br/&gt;            mesageHandler.sendsendEmail(email, subject, content);&lt;br/&gt;&lt;br/&gt;        } catch (Exception e) {&lt;br/&gt;            log.error(&lt;span&gt;&quot;发送email异常 -&amp;gt; &quot;&lt;/span&gt;, e)&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;}&lt;/p&gt;&lt;/pre&gt;&lt;section&gt;在实际项目中， 使用&lt;code&gt;@Async&lt;/code&gt;调用线程池，推荐等方式是是使用自定义线程池的模式，不推荐直接使用@Async直接实现异步。&lt;/section&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;4.5 Spring ApplicationEvent事件实现异步&lt;/span&gt;&lt;/h2&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;4.5.1 定义事件&lt;/h3&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;public class AsyncSendEmailEvent extends ApplicationEvent {&lt;br/&gt;&lt;br/&gt;    /**&lt;br/&gt;     * 邮箱&lt;br/&gt;     **/&lt;br/&gt;    private String email;&lt;br/&gt;&lt;br/&gt;   /**&lt;br/&gt;     * 主题&lt;br/&gt;     **/&lt;br/&gt;    private String subject;&lt;br/&gt;&lt;br/&gt;    /**&lt;br/&gt;     * 内容&lt;br/&gt;     **/&lt;br/&gt;    private String content;&lt;br/&gt;  &lt;br/&gt;    /**&lt;br/&gt;     * 接收者&lt;br/&gt;     **/&lt;br/&gt;    private String targetUserId;&lt;br/&gt;&lt;br/&gt;}&lt;/p&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;4.5.2 定义事件处理器&lt;/h3&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;@Slf4j&lt;br/&gt;@Component&lt;br/&gt;public class AsyncSendEmailEventHandler implements ApplicationListener&amp;lt;AsyncSendEmailEvent&amp;gt; {&lt;br/&gt;&lt;br/&gt;    @Autowired&lt;br/&gt;    private IMessageHandler mesageHandler;&lt;br/&gt;    &lt;br/&gt;    @Async(&lt;span&gt;&quot;taskExecutor&quot;&lt;/span&gt;)&lt;br/&gt;    @Override&lt;br/&gt;    public void onApplicationEvent(AsyncSendEmailEvent event) {&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (event == null) {&lt;br/&gt;            &lt;span&gt;return&lt;/span&gt;;&lt;br/&gt;        }&lt;br/&gt;&lt;br/&gt;        String email = event.getEmail();&lt;br/&gt;        String subject = event.getSubject();&lt;br/&gt;        String content = event.getContent();&lt;br/&gt;        String targetUserId = event.getTargetUserId();&lt;br/&gt;        mesageHandler.sendsendEmailSms(email, subject, content, targerUserId);&lt;br/&gt;      }&lt;br/&gt;}&lt;/p&gt;&lt;/pre&gt;&lt;section&gt;另外，可能有些时候采用ApplicationEvent实现异步的使用，当程序出现异常错误的时候，需要考虑补偿机制，那么这时候可以结合Spring Retry重试来帮助我们避免这种异常造成数据不一致问题。&lt;/section&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;4.6 消息队列&lt;/span&gt;&lt;/h2&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;4.6.1 回调事件消息生产者&lt;/h3&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;@Slf4j&lt;br/&gt;@Component&lt;br/&gt;public class CallbackProducer {&lt;br/&gt;&lt;br/&gt;    @Autowired&lt;br/&gt;    AmqpTemplate amqpTemplate;&lt;br/&gt;&lt;br/&gt;    public void sendCallbackMessage(CallbackDTO allbackDTO, final long delayTimes) {&lt;br/&gt;&lt;br/&gt;        log.info(&lt;span&gt;&quot;生产者发送消息，callbackDTO，{}&quot;&lt;/span&gt;, callbackDTO);&lt;br/&gt;&lt;br/&gt;        amqpTemplate.convertAndSend(CallbackQueueEnum.QUEUE_GENSEE_CALLBACK.getExchange(), CallbackQueueEnum.QUEUE_GENSEE_CALLBACK.getRoutingKey(), JsonMapper.getInstance().toJson(genseeCallbackDTO), new &lt;span&gt;MessagePostProcessor&lt;/span&gt;() {&lt;br/&gt;            @Override&lt;br/&gt;            public Message postProcessMessage(Message message) throws AmqpException {&lt;br/&gt;                //给消息设置延迟毫秒值，通过给消息设置x-delay头来设置消息从交换机发送到队列的延迟时间&lt;br/&gt;                message.getMessageProperties().setHeader(&lt;span&gt;&quot;x-delay&quot;&lt;/span&gt;, delayTimes);&lt;br/&gt;                message.getMessageProperties().setCorrelationId(callbackDTO.getSdkId());&lt;br/&gt;                &lt;span&gt;return&lt;/span&gt; message;&lt;br/&gt;            }&lt;br/&gt;        });&lt;br/&gt;    }&lt;br/&gt;}&lt;/p&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;4.6.2 回调事件消息消费者&lt;/h3&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;section&gt;@Slf4j&lt;br/&gt;@Component&lt;br/&gt;@RabbitListener(queues = &lt;span&gt;&quot;message.callback&quot;&lt;/span&gt;, containerFactory = &lt;span&gt;&quot;rabbitListenerContainerFactory&quot;&lt;/span&gt;)&lt;br/&gt;public class CallbackConsumer {&lt;br/&gt;&lt;br/&gt;    @Autowired&lt;br/&gt;    private IGlobalUserService globalUserService;&lt;br/&gt;&lt;br/&gt;    @RabbitHandler&lt;br/&gt;    public void handle(String json, Channel channel, @Headers Map&amp;lt;String, Object&amp;gt; map) throws Exception {&lt;br/&gt;&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (map.get(&lt;span&gt;&quot;error&quot;&lt;/span&gt;) != null) {&lt;br/&gt;            //否认消息&lt;br/&gt;            channel.basicNack((Long) map.get(AmqpHeaders.DELIVERY_TAG), &lt;span&gt;false&lt;/span&gt;, &lt;span&gt;true&lt;/span&gt;);&lt;br/&gt;            &lt;span&gt;return&lt;/span&gt;;&lt;br/&gt;        }&lt;br/&gt;&lt;br/&gt;        try {&lt;br/&gt;        &lt;br/&gt;            CallbackDTO callbackDTO = JsonMapper.getInstance().fromJson(json, CallbackDTO.class);&lt;br/&gt;            //执行业务逻辑&lt;br/&gt;            globalUserService.execute(callbackDTO);&lt;br/&gt;            //消息消息成功手动确认，对应消息确认模式acknowledge-mode: manual&lt;br/&gt;            channel.basicAck((Long) map.get(AmqpHeaders.DELIVERY_TAG), &lt;span&gt;false&lt;/span&gt;);&lt;br/&gt;&lt;br/&gt;        } catch (Exception e) {&lt;br/&gt;            log.error(&lt;span&gt;&quot;回调失败 -&amp;gt; {}&quot;&lt;/span&gt;, e);&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/section&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;4.7 ThreadUtil异步工具类&lt;/span&gt;&lt;/h2&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;@Slf4j&lt;br/&gt;public class ThreadUtils {&lt;br/&gt;&lt;br/&gt;    public static void main(String[] args) {&lt;br/&gt;        &lt;span&gt;for&lt;/span&gt; (int i = 0; i &amp;lt; 3; i++) {&lt;br/&gt;            ThreadUtil.execAsync(() -&amp;gt; {&lt;br/&gt;                ThreadLocalRandom threadLocalRandom = ThreadLocalRandom.current();&lt;br/&gt;                int number = threadLocalRandom.nextInt(20) + 1;&lt;br/&gt;                System.out.println(number);&lt;br/&gt;            });&lt;br/&gt;            log.info(&lt;span&gt;&quot;当前第：&quot;&lt;/span&gt; + i + &lt;span&gt;&quot;个线程&quot;&lt;/span&gt;);&lt;br/&gt;        }&lt;br/&gt;&lt;br/&gt;        log.info(&lt;span&gt;&quot;task finish!&quot;&lt;/span&gt;);&lt;br/&gt;    }&lt;br/&gt;}&lt;/p&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;4.8 Guava异步&lt;/span&gt;&lt;/h2&gt;&lt;section&gt;&lt;code&gt;Guava&lt;/code&gt;的&lt;code&gt;ListenableFuture&lt;/code&gt;顾名思义就是可以监听的&lt;code&gt;Future&lt;/code&gt;，是对java原生Future的扩展增强。我们知道Future表示一个异步计算任务，当任务完成时可以得到计算结果。如果我们希望一旦计算完成就拿到结果展示给用户或者做另外的计算，就必须使用另一个线程不断的查询计算状态。这样做，代码复杂，而且效率低下。使用&lt;strong&gt;「Guava ListenableFuture」&lt;/strong&gt;可以帮我们检测Future是否完成了，不需要再通过get()方法苦苦等待异步的计算结果，如果完成就自动调用回调函数，这样可以减少并发程序的复杂度。&lt;/section&gt;&lt;section&gt;&lt;code&gt;ListenableFuture&lt;/code&gt;是一个接口，它从&lt;code&gt;jdk&lt;/code&gt;的&lt;code&gt;Future&lt;/code&gt;接口继承，添加了&lt;code&gt;void addListener(Runnable listener, Executor executor)&lt;/code&gt;方法。&lt;/section&gt;&lt;section&gt;我们看下如何使用ListenableFuture。首先需要定义ListenableFuture的实例:&lt;/section&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt; ListeningExecutorService executorService = MoreExecutors.listeningDecorator(Executors.newCachedThreadPool());&lt;br/&gt;        final ListenableFuture&amp;lt;Integer&amp;gt; listenableFuture = executorService.submit(new Callable&amp;lt;Integer&amp;gt;() {&lt;br/&gt;            @Override&lt;br/&gt;            public Integer call() throws Exception {&lt;br/&gt;                log.info(&lt;span&gt;&quot;callable execute...&quot;&lt;/span&gt;)&lt;br/&gt;                TimeUnit.SECONDS.sleep(1);&lt;br/&gt;                &lt;span&gt;return&lt;/span&gt; 1;&lt;br/&gt;            }&lt;br/&gt;        });&lt;/p&gt;&lt;/pre&gt;&lt;section&gt;首先通过&lt;code&gt;MoreExecutors&lt;/code&gt;类的静态方法&lt;code&gt;listeningDecorator&lt;/code&gt;方法初始化一个&lt;code&gt;ListeningExecutorService&lt;/code&gt;的方法，然后使用此实例的&lt;code&gt;submit&lt;/code&gt;方法即可初始化&lt;code&gt;ListenableFuture&lt;/code&gt;对象。&lt;/section&gt;&lt;section&gt;&lt;code&gt;ListenableFuture&lt;/code&gt;要做的工作，在Callable接口的实现类中定义，这里只是休眠了1秒钟然后返回一个数字1，有了ListenableFuture实例，可以执行此Future并执行Future完成之后的回调函数。&lt;/section&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt; Futures.addCallback(listenableFuture, new FutureCallback&amp;lt;Integer&amp;gt;() {&lt;br/&gt;    @Override&lt;br/&gt;    public void onSuccess(Integer result) {&lt;br/&gt;        //成功执行...&lt;br/&gt;        System.out.println(&lt;span&gt;&quot;Get listenable future&#x27;s result with callback &quot;&lt;/span&gt; + result);&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    @Override&lt;br/&gt;    public void onFailure(Throwable t) {&lt;br/&gt;        //异常情况处理...&lt;br/&gt;        t.printStackTrace();&lt;br/&gt;    }&lt;br/&gt;});&lt;/p&gt;&lt;/pre&gt;&lt;section&gt;那么，以上就是本期介绍的实现异步的8种方式了。&lt;/section&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;作者：austin流川枫&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;来源：https://juejin.cn/post/7165147306688249870&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;欢迎大家加入苏三的知识星球&lt;span&gt;【&lt;/span&gt;&lt;strong&gt;Java突击队&lt;/strong&gt;&lt;span&gt;】&lt;/span&gt;，一起学习。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;星球中有很多独家的干货内容，比如：Java后端学习路线，分享实战项目，源码分析，百万级系统设计，系统上线的一些坑，MQ专题，真实面试题，每天都会回答大家提出的问题。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这几天星球开通了3个优质专栏：痛点问题、高频面试题 和 性能优化。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;每一个专栏都是大家非常关心，和非常有价值的话题，我相信在专栏中你会学到很多东西，值回票价。过几天还会涨价，现在入手比较合适。&lt;/p&gt;&lt;/pre&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;img data-ratio=&quot;1.215625&quot; data-type=&quot;jpg&quot; data-w=&quot;640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/ibJZVicC7nz5hIJADJhGE0U1tZqHWQrQibVcXL6NPmtOYDDSZoGdwiatibZvCdopCv7Vj5whLUgnCu8J3bbQFoe16nA/640?wx_fmt=jpeg&quot;/&gt;&lt;/section&gt;​&lt;/section&gt;&lt;p&gt;星球中最近更新了很多大厂的内推机会。&lt;/p&gt;&lt;p&gt;&lt;mp-style-type data-value=&quot;10000&quot;/&gt;&lt;/p&gt;&lt;/div&gt;

          
        &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>b3e72a6653cfe0f57918c3ac5f1f106b</guid>
<title>「降本」有可能，「增效」不确定</title>
<link>https://toutiao.io/k/7oggdkp</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content js_underline_content               autoTypeSetting24psection&amp;#10;            &quot; id=&quot;js_content&quot;&gt;&lt;blockquote&gt;&lt;p&gt;&lt;span&gt;降本手段一招鲜，增效方法吃遍天；&lt;/span&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;01&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;互联网行业里；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;降本策略千奇百怪，手段却出奇一致；增效方法五花八门，手段更是花里胡哨；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;对于企业来说；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;商业的基本形式，就是围绕供需产生的利益关系；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;很多决策的执行，都是基于利益最大化考虑的；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;什么是 &lt;strong&gt;利益最大化&lt;/strong&gt;？&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;更低的成本、更高的效率、更优的质量、更好的结果，没有&lt;strong&gt;最&lt;/strong&gt;的说法，只有&lt;strong&gt;更&lt;/strong&gt;的追求；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;好听的讲，叫降本增效；不好听的讲，叫唯利是图；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;企业对于降本增效的追求，感性上说底线没有，理性上说逻辑严密；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;02&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;先来聊一聊：&lt;strong&gt;降本&lt;/strong&gt;，最直接有效的手段：&lt;strong&gt;裁员&lt;/strong&gt;；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;不论是营收压力，还是业务瓶颈，都首选裁员来缓解困境；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;人力资源的成本降低，保障公司运营的可持续，在策略上极具确定性，只是手段比较魔幻；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;最近几年，某某厂裁员的热搜常有，网上吐槽的小作文也接二连三；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;更离谱的是&lt;/strong&gt;，裁员之后的降薪动作；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;虽然，月薪直接打折的操作不多见；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;但是，奖金上的闷棍却一通神操作，要么被打折，要么被打水漂；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;为啥不是降薪，而是裁员？&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;降薪影响整体的氛围；&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;如果操作不当，很大概率会先把有能力的人打包送走；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;裁员影响范围相对较低；&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;而且针对性明显，把混不动的人送走，倾向于做人做事都有问题的；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;最骚包的是&lt;/strong&gt;，裁员之后再招聘新人；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;被裁的人还没签字，接替的面试者已到会议室；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;越防线暴击，半点武德都不讲；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;新人入职之后还可以给团队一些压力，保持一定卷的氛围，对公司而言何乐而不为？&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;裁员这件事，对于普通选手来说；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;总有很多感性上不能接受的理由，但是都无法替代理性层面上的客观逻辑；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;职场上，清醒很重要；&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;面对当下的互联网行业，裁员风波中，具备留下的能力，也有选择走的实力，才算稳妥；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;03&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;相对于&lt;strong&gt;降本&lt;/strong&gt;这个潜藏在暗线的策略，&lt;strong&gt;增效&lt;/strong&gt;则是明面上常说的话题；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;这里的效是指常说的&lt;strong&gt;效能&lt;/strong&gt;，既有&lt;strong&gt;效率&lt;/strong&gt;，也有&lt;strong&gt;效果&lt;/strong&gt;；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;效能的概念比较抽象，可以将其放在具体的实践中去理解，基于常规的事务执行流程即可；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.334913112164297&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/uUIibyNXbAvAqGjNr6dNk31nXibQtrwXGKo2F6gzEbS8ibH3NKG6gcXaqNcop1Dt0TLWG1b1vku7hSicue8UslIwibg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1266&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;无论是公司顶层的战略规划，还是项目层面的管理策略，又或是团队或者个人层面的具体事务推进；&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在效能方面，都需要对齐的几个节点；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;目标和过程的正确，结果和产生的效果反馈，即效能；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;所以，效能围绕工作各个环节，比如：规划、决策、项目、业务、技术等；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;效能的实践，是一个长期的过程；&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;对于效能的衡量也没有绝对标准，从实践中看，需要客观的相对标准；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在环境的不同时期，不同事务中，应对的策略也各不相同，效能的追求自然也要审时度势；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在企业中，不同层级的角色，看待事务角度不同，流程也有差异；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;下面围绕研发这个视角，从事务推进的各个关键环节，来分析效能方面的问题；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;04&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;【数字化转型战略】&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;互联网企业，围绕&lt;strong&gt;数字化&lt;/strong&gt;体系的转型，是近些年的热门话题；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;完整的路径：&lt;strong&gt;信息化&lt;/strong&gt;，&lt;strong&gt;数字化&lt;/strong&gt;，&lt;strong&gt;智能化&lt;/strong&gt;；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;此前，在数据服务公司待过两年，对数字化的应用和业务赋能有过一些实践经验；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.5&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/uUIibyNXbAvAqGjNr6dNk31nXibQtrwXGKVynGp6Qo7VGjNudIkPhLUnGtxVL02r6eabYouGyJiaZ53iaUld8FmXrw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;从个人的实践来看；&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;信息化&lt;/strong&gt;可以简单的理解为：组织、运营、&lt;strong&gt;业务流程&lt;/strong&gt;的线上数据化过程；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;数字化&lt;/strong&gt;可以简单的理解为：基于数据的统筹分析，再反向驱动组织、运营、业务的能力体系；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;智能化&lt;/strong&gt;可以简单的理解为：基于信息化和数字化之上，更加智能的分析、决策能力；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;随着数字化概念的普及和推广，大部分企业理解数字化的重要；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;但是企业的数字化转型之路，实践的过程是曲折和漫长的；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;对于转型来说，不同的企业有不同的业务和特点，并没有一套相对完整的标准来衡量成功与否；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;从一个比较理想的状态来描述：实现全流程全场景的数字化管理；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在发展的过程中，通过对数据层面的客观分析，快速发现问题，支撑决策的制定和执行；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;05&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;【组织决策层面】&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;站在企业层面来看，也许能接受短暂时间内走的慢，但是不太能接受方向上的错误；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;走的慢，只意味付出的回报可能迟到；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;方向错误，则意味付出没有回报；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;很显然，对于互联网这个行业；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;大部分的中小型公司，并没有试错的资本和时间，错过可能就是结束；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;所以，组织在做决策时；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;需要进行统筹分析和规划，极力追求&lt;strong&gt;目标的正确性&lt;/strong&gt;和&lt;strong&gt;方向的准确性&lt;/strong&gt;；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;以研发过程中重大版本为例，来分析决策的流程；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.731239092495637&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/uUIibyNXbAvAqGjNr6dNk31nXibQtrwXGKErJI2djPrM8244VEwlibEiap8ZIpECKLE0qnqGx1H4IJZro40zewz9ibg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1146&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;组织针对事务的决策会议，通常控制在三次，目的就是对齐事务核心人员的认知；&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;决策正确与否的关键；&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在于关键信息是否充分的表达和分析，从而形成影响决策的核心因素；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;个人所在的企业中，对于那些以月或者季度为周期的重大业务版本；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在进行决策会议的&lt;strong&gt;前三天&lt;/strong&gt;，就会下发相关的材料文档；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;所有参与的人员&lt;/strong&gt;；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;会议上都必须表达对事务的看法，执行时可能出现的问题，由项目经理进行统筹；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;然后各个团队分析问题，给出解决的方案和成本；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;最终，完成对事务的各个维度统筹或取舍，形成预期规划，转入立项执行阶段；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在决策时；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;如果信息不全面不充分，无法形成广度和深度的综合分析；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;很容易产生错误的预期规划，后续的执行和结果自然也会出现偏差；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;06&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;【项目执行层面】&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;项目推进的流程，通常追求&lt;strong&gt;质量、成本、时间&lt;/strong&gt;的平衡；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在不降低质量的情况下，同时降低时间和成本，故而形成现在互联网的内卷状态；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.53828125&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/uUIibyNXbAvAqGjNr6dNk31nXibQtrwXGKIJOBG4PGkVjBp5uUPm5HeWCRuGhcicfyrNChYHDYiaWuNdfiabeAQ7Y6Q/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在项目经理的视角下；&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;各阶段的并行推进，人力资源的介入时间，不同节点的转换，问题的协调和风险的规避；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;都会对项目的周期产生较大的影响；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;曾有一个预期为三个月的版本；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;通过项目经理的精细规划，提前二十天完成交付，并且不削减各方的评估时间；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;从项目的&lt;strong&gt;执行过程&lt;/strong&gt;看；&lt;/span&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;• 可并行的流程，合并到一个周期内；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;• 节点转换节奏中，不允许隔天交付，周期结束必须即时向下交付；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;• 过程中所有问题和风险，在各自阶段内快速协调并解决，没有影响整体排期；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;• 对于可能出现的加班情况，各种福利都提前安排好，避免情绪问题；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;span&gt;从项目的&lt;strong&gt;最终结果&lt;/strong&gt;看；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;围绕需求的目标和指标体系，去衡量结果以及产生的效果；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;形成项目的复盘总结文档，以及后续的优化方案，沉淀项目管理经验和&lt;strong&gt;知识体系&lt;/strong&gt;；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;07&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;【业务管理层面】&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;业务，企业的绝对核心；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;很多组织架构、团队结构、流程机制，都是围绕业务设计的；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;业务的完整周期；&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;业务的发展周期：孵化期、验证期、成长期、成熟期、衰退期、转型或者消亡期；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.275&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/uUIibyNXbAvAqGjNr6dNk31nXibQtrwXGKtFpnLRt2B5XbPEcM0fn4jRAMbLdCORyRup9yaVxsBpqiauU0EVialrJw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在周期性的变化中，很多特征会多次重复出现，问题也会持续出现；&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;深入业务的本质；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在不同的周期阶段中，抓住关键的问题和矛盾，设计和落实相应的解决方案；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;问题必然会一直出现；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;可能是对业务的洞察分析，客户的真实反馈，业务落地的各个过程；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在任何时间下都存在问题；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;但是发现很多问题，却没有抓住和解决关键的问题，对业务的建设来说是致命的；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;业务的流程路径；&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;以互联网业务的生意模式来看：流量获客、转化销售、围绕产品做持续运营；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.29375&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/uUIibyNXbAvAqGjNr6dNk31nXibQtrwXGKgr8Uou0LtlNLo5ZK5sRicUY7dt4zPxNoyGNAHmj8iamhutiazh68Jv1ibw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在不同的业务场景下，其运作流程会有差异，但其本质上的逻辑是相通的；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;业务体系的搭建过程中；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;除了各环节的核心能力建设，还要围绕流程的推进做持续的优化管理；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;追求业务流程中协作的&lt;strong&gt;顺畅和高效&lt;/strong&gt;，降低业务流中不必要的人为操作，是增效的常用手段；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;业务的细节刻画；&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;深入洞察业务画像，不断的挖掘和处理其内部的细节问题，助力业务发挥更高的价值；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;对于业务的细节问题处理，更多是具体场景具体分析，这里抛一个场景案例；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.41484375&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/uUIibyNXbAvAqGjNr6dNk31nXibQtrwXGK3Dt9unhq7vGRAKkdlUZMwlXbATbvr6b26jnrGyjrEHmUsGRY01FRFw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在企业中，很少只存在一个业务线，而不同协作团队之间存在一定的壁垒，也是常见的问题；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;对于服务客户来说；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在转化的过程中，商务人员通常更专注于自身负责的业务，从而忽略业务之间的联动性；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;经过论证后，通过标签能力，尽可能的联动不同的业务线；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;对这种细节问题的处理；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;需要精确的把握业务场景，其解决方案的实现成本可能很低，但产生的业务价值却很高；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;08&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;【技术研发层面】&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;研发体系，既要面对业务的复杂度，还要应对技术的复杂度；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;团队分工角度；&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;首先从团队的分工角度来看，技术依赖很大的专注性，所以分工明确比较重要；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.5390749601275917&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/uUIibyNXbAvAqGjNr6dNk31nXibQtrwXGKDUSzBETMmuibmm1jVtIztoj0A0uEgbEVabJziaEuUoLuHiasNtd0VHeQA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1254&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;团队的分工，主要是以成员的能力为依据，业务开发可以根据个人的主观意愿进行适当的调整；&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;通过合理的分工设计；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;让不同的成员都可以持续专注在一个方向内，从而避免节奏混乱引发的各种问题；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;业务体系搭建；&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;于研发来说，通过技术手段完成业务到产品的落地，是工作的最高优先级；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;但是从长期来看；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;需要对业务深入分析和洞察，建立精确有效的指标体系，支撑决策，挖掘更高的业务价值；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;技术体系搭建；&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;从业务维度来看；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在业务体系的搭建过程中，不断的拆分降低耦合度，沉淀公共复用的业务能力；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;从架构维度来看；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;持续追求业务和技术的分离，系统的分层设计，即使部分或整体的业务消亡，但是沉淀的技术价值还在；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;09&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;从实践经验中来看；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;企业对于降本的手段和策略，通常是比较直接的，并且具备确定性，从而规避不确定的风险；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;虽然增效的呼声时常不绝于耳；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;但是站在现状去考虑，提升效率依赖于组织对于各种事务的熟悉程度；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;那么，问题来了；&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;对于当下的互联网行业来说，环境中的&lt;strong&gt;人和事&lt;/strong&gt;变化频率非常高，&lt;strong&gt;增效&lt;/strong&gt;的手段能否真正发挥其作用？&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;END&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section data-support=&quot;96编辑器&quot; data-style-id=&quot;30792&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;97816&quot; data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;section data-role=&quot;outer&quot; label=&quot;Powered by 135editor.com&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;mp-style-type data-value=&quot;3&quot;/&gt;&lt;/p&gt;&lt;/div&gt;

          
        &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>68dfec1f30193bcf60a31411bd3006f9</guid>
<title>这才是现代 JavaScript 库打包指南</title>
<link>https://toutiao.io/k/0p0jhgj</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot; data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;blockquote&gt;&lt;p&gt;&lt;span/&gt;原文：&lt;/p&gt;&lt;p&gt;https://github.com/frehner/modern-guide-to-packaging-js-library/blob/main/README-zh_CN.md&lt;span/&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;span&gt;本指南旨在提供一些大多数库都应该遵循的一目了然的建议。以及一些额外的信息，用来帮助你了解这些建议被提出的原因，或帮助你判断是否不需要遵循某些建议。这个指南仅适用于 &lt;/span&gt;&lt;strong&gt;「库（libraries）」&lt;/strong&gt;&lt;span&gt;，不适用于应用（app）。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;要强调的是，这只是一些&lt;strong&gt;「建议」&lt;/strong&gt;，并不是所有库都必须要遵循的。每个库都是独特的，它们可能有充足的理由不采用本文中的任何建议。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;最后，这个指南不针对某一个特定的打包工具 —— 已经有许多指南来说明如何在配置特定的打包工具。相反我们聚焦于每个库和打包工具（或不用打包工具）都适用的事项。&lt;/p&gt;&lt;hr data-tool=&quot;mdnice编辑器&quot;/&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;输出 &lt;code&gt;esm&lt;/code&gt;、&lt;code&gt;cjs&lt;/code&gt; 和 &lt;code&gt;umd&lt;/code&gt; 格式&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;esm&lt;/code&gt; 是“EcmaScript module”的缩写。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;cjs&lt;/code&gt; 是“CommonJS module”的缩写。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;umd&lt;/code&gt; 是“Universal Module Definition”的缩写，它可以在 &lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt; 标签中执行、被 &lt;code&gt;CommonJS&lt;/code&gt; 模块加载器加载、被 &lt;code&gt;AMD&lt;/code&gt; 模块加载器加载。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;esm&lt;/code&gt; 被认为是“未来”，但 &lt;code&gt;cjs&lt;/code&gt; 仍然在社区和生态系统中占有重要地位。&lt;code&gt;esm&lt;/code&gt; 对打包工具来说更容易正确地进行 treeshaking，因此对于库来说，拥有这种格式很重要。或许在将来的某一天，你的库只需要输出 &lt;code&gt;esm&lt;/code&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;你可能已经注意到，&lt;code&gt;umd&lt;/code&gt; 已经与 CommonJS 模块加载器兼容 —— 所以为什么还要同时具备 &lt;code&gt;cjs&lt;/code&gt; 和 &lt;code&gt;umd&lt;/code&gt; 输出呢？一个原因是，与 &lt;code&gt;umd&lt;/code&gt; 文件相比，CommonJS 文件在对依赖进行条件导入时通常表现更好；例如：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;if&lt;/span&gt; (process.env.NODE_ENV === &lt;span&gt;&quot;production&quot;&lt;/span&gt;) {&lt;br/&gt;  module.exports = require(&lt;span&gt;&quot;my-lib.production.js&quot;&lt;/span&gt;);&lt;br/&gt;} &lt;span&gt;else&lt;/span&gt; {&lt;br/&gt;  module.exports = require(&lt;span&gt;&quot;my-lib.development.js&quot;&lt;/span&gt;);&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上面的例子，当使用 CommonJS 模块时，只会引入 &lt;code&gt;production&lt;/code&gt; 或 &lt;code&gt;development&lt;/code&gt; 包中的一个。但是，对于 UMD 模块，最终可能会将两个包全部引入。有关更多信息，请参阅此讨论。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;最后还需要注意是，开发者可能会在其应用中同时使用 &lt;code&gt;cjs&lt;/code&gt; 和 &lt;code&gt;esm&lt;/code&gt;，发生双包危险。dual package hazard 一文介绍了一些缓解该问题的方法，利用 &lt;code&gt;package.json#exports&lt;/code&gt; 进行 package exports 也可以帮助防止这种情况的发生。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;输出多文件&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;通过保留文件结构更好地支持 treeshaking&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果你对你的库使用了打包工具或编译器，可以对其进行配置以保留源文件目录结构。这样可以更容易地对特定文件进行 side effects 标记，有助于开发者的打包工具进行 threeshaking。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;一个例外是，如果你要创建一个不依赖任何打包工具可以直接在浏览器中使用的产出（通常是 &lt;code&gt;umd&lt;/code&gt; 格式，但也可能是现代的 &lt;code&gt;esm&lt;/code&gt; 格式）。在这种情况下，最好让浏览器请求一个大文件，而不是请求多个小文件。此外，你应该进行代码压缩并为其创建 sourcemap。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;要不要压缩代码&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;你可以将一些层面的代码压缩应用到你的库中，这取决于你对你的代码最终通过开发者的打包工具后的大小的追求程度。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;例如，大多数编译器已经配置了删除空白符等其他简单的优化，即使是来自 NPM 模块的代码（在这里指的是你的库）。使用 terser —— 一个流行的 JavaScript 代码压缩工具 —— 这类压缩工具可以将包的最终大小减少 95%。在某些情况下，你可能会对这些优化感到满意，且不需要你来付出任何努力。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但如果在发布前对你的库进行代码压缩，这可以得到一些额外的好处，但需要深入了解压缩工具的配置和副作用。压缩工具通常不会将这类压缩用于 NPM 模块，因此，如果你不自己来做的话，你会错过这些节省。请参阅这个 issue了解更多信息。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;最后，如果你正创建一个不依赖任何打包工具可以直接在浏览器中使用的产出（通常是 &lt;code&gt;umd&lt;/code&gt; 格式，但也可以是现代的 &lt;code&gt;esm&lt;/code&gt; 格式）。在这种情况下，你应该对代码进行压缩，并创建 sourcemap，并输出到一个单文件。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;创建 sourcemap&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;对源代码进行任何形式的编译，都将导致未来某个异常的位置，无法与源码对应起来。为了帮助未来的自己，创建 sourcemap，即使只进行了很少的编译工作。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;创建 TypeScript 类型&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;随着使用 TypeScript 的开发者数量不断增长，将类型内置到你的库中将有助于改善开发体验 (DX)。此外，不使用 TypeScript 的开发者在使用支持类型的编辑器（例如 VSCode，它使用类型来支持其 Intellisense 功能）时也会获得更好的 DX。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但是，创建类型并不意味着你必须使用 TypeScript 来编写你的库。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;一种选择是继续在源代码中使用 JavaScript，然后通过 JSDoc 注释来支持类型。然后，你可以将 TypeScript 配置为仅从你的 JavaScript 源代码中构建类型文件。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;另一种选择是直接在 &lt;code&gt;index.d.ts&lt;/code&gt; 文件中编写 TypeScript 类型文件。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;获得类型文件后，请确保设置了 &lt;code&gt;package.json#exports&lt;/code&gt; 和 &lt;code&gt;package.json#types&lt;/code&gt; 字段.&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;外置框架&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;不要将 React、Vue 等框架打包在你的库中&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当构建的库依赖某个框架（例如 React、Vue 等），或是作为另一个库的插件，你可能需要将框架配置到“externals”中。这可以使你的库引用这个框架，但不会将其打包到最终的产出中。这会避免产生一些 bug，并减少库的体积。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;你应该还需要将框架添加到库的 &lt;code&gt;package.json&lt;/code&gt; 的 peer dependencies 中，这将帮助开发者发现你依赖于某个框架。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;面向现代浏览器&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;使用现代的新特性，如果有需要，让开发者支持旧的浏览器这篇 web.dev 上的文章提供了一个很好的案例，并提供了相关的指导原则：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;当使用你的库时，能够让开发者去支持老版本的浏览器。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;输出多个产出来支持不同版本的浏览器。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;举个例子，如果你使用 TypeScript，你可以创建两个版本的包代码：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;通过在 &lt;code&gt;tsconfig.json&lt;/code&gt; 中设置 &lt;code&gt;&quot;target&quot;=&quot;esnext&quot;&lt;/code&gt;，生成一个用现代 JavaScript 的 &lt;code&gt;esm&lt;/code&gt; 版本&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;通过在 &lt;code&gt;tsconfig.json&lt;/code&gt; 中设置 &lt;code&gt;&quot;target&quot;=&quot;es5&quot;&lt;/code&gt; 生成一个兼容低版本 JavaScript 的 &lt;code&gt;umd&lt;/code&gt; 版本&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;有了这些设置，大多数用户将获得现代版本的代码，但那些使用老的打包工具配置或使用 &lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt; 加载代码的用户，将获得进行了额外编译来支持老版本浏览器的版本。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;必要的编译&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;编译 TypeScript、将 JSX 转换为函数调用&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果库的源码是需要进行编译的形式，如 TypeScript、React 或 Vue 组件等，那么你库需要输出的是编译后的代码。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;例如：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;你的 TypeScript 代码应该输出为 JavaScript。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;你的 React 组件，例如 &lt;code&gt;&amp;lt;Example /&amp;gt;&lt;/code&gt;，应该在输出中使用 &lt;code&gt;jsx()&lt;/code&gt; 或 &lt;code&gt;createElement()&lt;/code&gt; 来替换 JSX 语法。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;进行这样的编译时，请确保同时也创建 sourcemap&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;维护 changelog&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;记录更新和变更&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;只要能让开发者了解到有哪些变更和对他们的影响，至于是通过自动化工具还是通过亲自动手的方式来处理，这都无关紧要。理想情况下，库的每次版本变更都应该在 changelog 中进行相应的更新。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;拆分出你的 CSS 文件&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;让开发者能够按需引入 CSS&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果你正在创建一个 CSS 库（如 Bootstrap、Tailwind 等），最简单的方式就是提供单一文件，包含库的所有功能。然而，在这种情况下，你的 CSS 产出最终可能会变得很大，影响开发者网站的性能。为了避免这种情况，库通常会提供自定义生成 CSS 产出的功能，让产出中只包含开发者正在使用的必要 CSS（例如，参考 Bootstrap 和 Tailwind 是怎么做的）。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果 CSS 只是你的库的一部分（例如，具有默认样式的组件库），那么最好将 CSS 按组件分离单独构建产出，在使用相应的组件时按需导入。这方面的一个例子是 react-component。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;配置 &lt;code&gt;package.json&lt;/code&gt;&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;package.json&lt;/code&gt; 中有许多重要的配置字段值得讨论；我在这里将着重讨论其中最为重要的一些，这还有很多额外的字段，你同样可以进行配置。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;设置 &lt;code&gt;name&lt;/code&gt; 字段&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;给你的库取一个名&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;name&lt;/code&gt; 字段将决定你的包在 &lt;code&gt;npm&lt;/code&gt; 上的名字，开发者可以通过这个名字去安装并使用你的库。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;注意，库的命名是有限制的，如果你的代码库属于某个组织，你还可以创建一个命名空间。更多细节可以参考 name docs on npm。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;name&lt;/code&gt; 和 version 的组合为库每次迭代创建一个唯一标识。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;设置 &lt;code&gt;version&lt;/code&gt; 字段&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;通过更改 version 来对你的库发布更新&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;正如 name 部分所说，&lt;code&gt;name&lt;/code&gt; 和 &lt;code&gt;version&lt;/code&gt; 的组合为你的库在 npm 上创建一个唯一标识。当你更新库中的代码时，你可以更新 &lt;code&gt;version&lt;/code&gt; 字段并发布以允许开发者获取该新代码。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;推荐使用 semver 版本控制策略，但要注意的是有些库选择 calver 或使用他们自己特有的版本控制策略。无论你选择使用哪种策略，都应该记录下来，以便开发者了解你的库是如何进行版本控制的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;你还应该在 changelog 中记录你的更改。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;定义你的 &lt;code&gt;exports&lt;/code&gt;&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;exports 为你的库定义公共 API&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;package.json&lt;/code&gt; 中的 &lt;code&gt;exports&lt;/code&gt; 字段 - 有时被称为“package exports” - 是一个非常有用的补充，尽管它确实引入了一些复杂性。它做的最重要的两件事是：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;定义哪些东西可以从你的库中导入，哪些则不可以，以及可导入的内容的名字。如果没有在 &lt;code&gt;exports&lt;/code&gt; 中被列出，那么开发者就不可以 &lt;code&gt;import&lt;/code&gt; 或 &lt;code&gt;require&lt;/code&gt; 它们。换句话说，&lt;code&gt;exports&lt;/code&gt; 的表现像是给你的库用户查看的公共 API，帮助定义哪些是外部的哪些是内部的。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;允许你根据不同的条件（你可以定义）去选择那个文件是被导入的，例如“文件是被 &lt;code&gt;import&lt;/code&gt; 还是被 &lt;code&gt;require&lt;/code&gt;？开发人员需要的是 &lt;code&gt;development&lt;/code&gt; 版本的库还是 &lt;code&gt;production&lt;/code&gt; 版本等等。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;关于这部分的内容NodeJS 团队和Webpack 团队提供了一些很优秀的文档。在此我列出一个涵盖大部分常见场景的例子：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;{&lt;br/&gt;  &lt;span&gt;&quot;exports&quot;&lt;/span&gt;: {&lt;br/&gt;    &lt;span&gt;&quot;.&quot;&lt;/span&gt;: {&lt;br/&gt;      &lt;span&gt;&quot;types&quot;&lt;/span&gt;: &lt;span&gt;&quot;index.d.ts&quot;&lt;/span&gt;,&lt;br/&gt;      &lt;span&gt;&quot;module&quot;&lt;/span&gt;: &lt;span&gt;&quot;index.js&quot;&lt;/span&gt;,&lt;br/&gt;      &lt;span&gt;&quot;import&quot;&lt;/span&gt;: &lt;span&gt;&quot;index.js&quot;&lt;/span&gt;,&lt;br/&gt;      &lt;span&gt;&quot;require&quot;&lt;/span&gt;: &lt;span&gt;&quot;index.cjs&quot;&lt;/span&gt;,&lt;br/&gt;      &lt;span&gt;&quot;default&quot;&lt;/span&gt;: &lt;span&gt;&quot;index.js&quot;&lt;/span&gt;&lt;br/&gt;    },&lt;br/&gt;    &lt;span&gt;&quot;./package.json&quot;&lt;/span&gt;: &lt;span&gt;&quot;./package.json&quot;&lt;/span&gt;&lt;br/&gt;  }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;让我们深入了解这些字段的含义以及我选择这个例子的原因：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;&quot;.&quot;&lt;/code&gt; 表示你的库的默认入口&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;解析过程是&lt;strong&gt;「从上往下」&lt;/strong&gt;的，并在找到匹配的字段后立即停止；所以入口的顺序是非常重要的&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;types&lt;/code&gt; 字段应始终放在第一位，帮助 TypeScript 查找类型文件&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;module&lt;/code&gt; 是一个“非官方”字段，它被 Webpack 和 Rollup 等打包工具所支持。它应该被放在 &lt;code&gt;import&lt;/code&gt; 和 &lt;code&gt;require&lt;/code&gt; 之前，并且指向 &lt;code&gt;esm&lt;/code&gt; 格式的产出 -- 如果你的源代码是纯 &lt;code&gt;esm&lt;/code&gt; 的，它也可以指向你的源代码。正如在格式部分中指出的那样，它旨在帮助打包工具只包含你的库的一个副本，无论它是通过 &lt;code&gt;import&lt;/code&gt; 还是 &lt;code&gt;require&lt;/code&gt; 方式引入的。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;import&lt;/code&gt; 用于当有人通过 &lt;code&gt;import&lt;/code&gt; 使用你的库时&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;require&lt;/code&gt; 用于当有人通过 &lt;code&gt;require&lt;/code&gt; 使用你的库时&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;default&lt;/code&gt; 字段用于兜底，在没有任何条件匹配时使用。虽然目前可能并不会匹配到它，但为了面对“未知的未来场景”，使用它是好的&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当一个打包工具或者运行时支持 &lt;code&gt;exports&lt;/code&gt; 字段的时候，那么 &lt;code&gt;package.json&lt;/code&gt; 中的顶级字段 main、types、module 还有 browser 将被忽略，被 &lt;code&gt;exports&lt;/code&gt; 取代。但是，对于尚不支持 &lt;code&gt;exports&lt;/code&gt; 字段的工具或运行时来说，设置这些字段仍然很重要。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果你有一个 &quot;development&quot; 和一个 &quot;production&quot; 的产出（例如，你有一些警告在 development 产出中有但在 production 产出中没有），那么你可以通过在 &lt;code&gt;exports&lt;/code&gt; 字段中 &lt;code&gt;&quot;development&quot;&lt;/code&gt; 和 &lt;code&gt;&quot;production&quot;&lt;/code&gt; 来设置它们。注意一些打包工具例如 &lt;code&gt;webpack&lt;/code&gt; 和 &lt;code&gt;vite&lt;/code&gt; 将会自动识别这些导出条件，而 Rollup 也可以通过配置来识别它们，你需要提醒开发者在他们自己打包工具的配置中去做这些事。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;列出要发布的 &lt;code&gt;files&lt;/code&gt;&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;files&lt;/code&gt; 定义你的 NPM 包中要包含哪些文件&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;files&lt;/code&gt; 决定 &lt;code&gt;npm&lt;/code&gt; CLI 在打包库时哪些文件和目录包含到最终的 NPM 包中。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;例如，如果你将代码从 TypeScript 编译为 JavaScript，你可能就不想在 NPM 包中包含 TypeScript 的源代码。（相反，你应该包含 sourcemap）。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;files&lt;/code&gt; 可以接受一个字符串数组（如果需要，这些字符串可以包含类似 glob 的语法），例如：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;{&lt;br/&gt;  &lt;span&gt;&quot;files&quot;&lt;/span&gt;: [&lt;span&gt;&quot;dist&quot;&lt;/span&gt;]&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;注意，文件数组不接受相对路径表示；&lt;code&gt;&quot;files&quot;: [&quot;./dist&quot;]&lt;/code&gt; 将无法正常工作。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;验证你已正确设置 &lt;code&gt;files&lt;/code&gt; 的一种好方法是运行 &lt;code&gt;npm publish --dry-run&lt;/code&gt;，它将根据此设置列出将会包含的文件。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;为你的 JS 文件设置默认的模块 &lt;code&gt;type&lt;/code&gt;&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;type&lt;/code&gt; 规定你的 &lt;code&gt;.js&lt;/code&gt; 文件使用哪个模块系统&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;运行时和打包工具需要一种方法来确定你的 &lt;code&gt;.js&lt;/code&gt; 文件采用哪种模块系统 —— ESM 还是 CommonJS。因为 CommonJS 首先出现，所以它被打包工具视为默认的 - 但你可以通过在你的 &lt;code&gt;package.json&lt;/code&gt; 中添加 &lt;code&gt;&quot;type&quot;&lt;/code&gt; 来控制这种行为。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;你可以选择 &lt;code&gt;&quot;type&quot;:&quot;module&quot;&lt;/code&gt; 或 &lt;code&gt;&quot;type&quot;:&quot;commonjs&quot;&lt;/code&gt;，也可以不添加该字段（默认为 CommonJS），但仍强烈建议你进行设置，显式地声明你正在使用哪一个。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;请注意，你可以通过几个技巧在项目中混用模块类型：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;.mjs&lt;/code&gt; 文件总是 ESM 模块，即使你的 &lt;code&gt;package.json&lt;/code&gt; 有 &lt;code&gt;&quot;type&quot;: &quot;commonjs&quot;&lt;/code&gt;（或者没有 &lt;code&gt;type&lt;/code&gt;）&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;.cjs&lt;/code&gt; 文件总是 CommonJS 模块，即使你的 &lt;code&gt;package.json&lt;/code&gt; 有 &lt;code&gt;&quot;type&quot;: &quot;module&quot;&lt;/code&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;你可以在子目录下添加其他 &lt;code&gt;package.json&lt;/code&gt; 文件；运行时和打包工具将向上遍历文件目录，直到寻找到最近的 &lt;code&gt;package.json&lt;/code&gt;。这意味着你可以有两个不同的文件夹，都使用 &lt;code&gt;.js&lt;/code&gt; 文件，但每个文件夹都有自己的 &lt;code&gt;package.json&lt;/code&gt; 并设置为不同的 &lt;code&gt;type&lt;/code&gt; 以获得基于 CommonJS 和 ESM 的文件夹。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;列出哪些模块有 &lt;code&gt;sideEffects&lt;/code&gt;&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;设置 &lt;code&gt;sideEffects&lt;/code&gt; 来允许 treeshaking&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;创建一个“纯模块”带来的优点与创建一个纯函数十分类似；打包工具能够对你的库更好的进行 treeshaking。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;通过设置 &lt;code&gt;sideEffects&lt;/code&gt; 让打包工具知道你的模块是否是“纯”的。不设置这个字段，打包工具将不得不假设你&lt;strong&gt;「所有」&lt;/strong&gt;的模块都是有副作用。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;sideEffects&lt;/code&gt; 可以设为 &lt;code&gt;false&lt;/code&gt;，表示没有任何模块具有副作用，也可以设置为字符串数组来列出哪些文件具有副作用。例如：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;{&lt;br/&gt;  // 所有模块都是“纯”的&lt;br/&gt;  &lt;span&gt;&quot;sideEffects&quot;&lt;/span&gt;: &lt;span&gt;false&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;或&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;{&lt;br/&gt;  // 除了 &lt;span&gt;&quot;module.js&quot;&lt;/span&gt;，所有模块都是“纯”的&lt;br/&gt;  &lt;span&gt;&quot;sideEffects&quot;&lt;/span&gt;: [&lt;span&gt;&quot;module.js&quot;&lt;/span&gt;]&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以，什么让一个模块具有副作用？例如修改一个全局变量，发送 API 请求，或导出 CSS，而且开发人员不需要做任何事情这些动作就会被执行。例如：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;// 具有副作用的模块&lt;br/&gt;&lt;br/&gt;&lt;span&gt;export&lt;/span&gt; const myVar = &lt;span&gt;&quot;hello&quot;&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;window.example = &lt;span&gt;&quot;testing&quot;&lt;/span&gt;;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;导入 &lt;code&gt;myVar&lt;/code&gt; 时，你的模块自动设置 &lt;code&gt;window.example&lt;/code&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;例如：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;import { myVar } from &lt;span&gt;&quot;library&quot;&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;console.log(window.example);&lt;br/&gt;// 打印 &lt;span&gt;&quot;testing&quot;&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在某些情况下，如 polyfill，这种行为是有意的。然而，如果我们想让这个模块是“纯”的，我们可以将对 &lt;code&gt;window.example&lt;/code&gt; 的赋值移动到一个函数中。例如：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;// 一个“纯”模块&lt;br/&gt;&lt;br/&gt;&lt;span&gt;export&lt;/span&gt; const myVar = &lt;span&gt;&quot;hello&quot;&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;export&lt;/span&gt; &lt;span&gt;function&lt;/span&gt; &lt;span&gt;&lt;span&gt;setExample&lt;/span&gt;&lt;/span&gt;() {&lt;br/&gt;  window.example = &lt;span&gt;&quot;testing&quot;&lt;/span&gt;;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;现在这是一个“纯”模块。注意，从开发者的角度来看会有不同：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;import { myVar, setExample } from &lt;span&gt;&quot;library&quot;&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;console.log(window.example);&lt;br/&gt;// 打印 &lt;span&gt;&quot;undefined&quot;&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;setExample();&lt;br/&gt;&lt;br/&gt;console.log(window.example);&lt;br/&gt;// 打印 &lt;span&gt;&quot;testing&quot;&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;设置 &lt;code&gt;main&lt;/code&gt; 字段&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;main&lt;/code&gt; 定义 CommonJS 入口&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;main&lt;/code&gt; 是一个当打包工具或运行时不支持 &lt;code&gt;package.json#exports&lt;/code&gt; 时的兜底方案；如果打包工具或运行时支持 package exports，则不会使用 &lt;code&gt;main&lt;/code&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;main&lt;/code&gt; 应该指向一个兼容 CommonJS 格式的产出；它应该与 package exports 中的 &lt;code&gt;require&lt;/code&gt; 保持一致。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;设置 &lt;code&gt;module&lt;/code&gt; 字段&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;module&lt;/code&gt; 定义 ESM 入口&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;module&lt;/code&gt; 是一个当打包工具或运行时不支持 &lt;code&gt;package.json#exports&lt;/code&gt; 时的兜底方案；如果打包工具或运行时支持 package exports，则不会使用 &lt;code&gt;module&lt;/code&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;module&lt;/code&gt; 应该指向一个兼容 ESM 格式的产出；它应该与 package exports 中的 &lt;code&gt;module&lt;/code&gt; 或 &lt;code&gt;import&lt;/code&gt; 保持一致。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;设置给 CDN 使用的附加字段&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;支持 CDN，例如 &lt;code&gt;unpkg&lt;/code&gt; 和 &lt;code&gt;jsdelivr&lt;/code&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;为让你的库在 CDN 上“以默认的方式正常工作”，如 unpkg 和 jsdelivr，你可以设置它们的特定字段指向你的 &lt;code&gt;umd&lt;/code&gt; 产出。例如：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;{&lt;br/&gt;  &lt;span&gt;&quot;unpkg&quot;&lt;/span&gt;: &lt;span&gt;&quot;./dist/index.umd.js&quot;&lt;/span&gt;,&lt;br/&gt;  &lt;span&gt;&quot;jsdelivr&quot;&lt;/span&gt;: &lt;span&gt;&quot;./dist/index.umd.js&quot;&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;设置 &lt;code&gt;browser&lt;/code&gt; 字段&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;browser&lt;/code&gt; 指向能在浏览器中工作的产出&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;browser&lt;/code&gt; 是一个当打包工具或运行时不支持 &lt;code&gt;package.json#exports&lt;/code&gt; 时的兜底方案；如果打包工具或运行时支持 package exports， 则不会使用 &lt;code&gt;browser&lt;/code&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;browser&lt;/code&gt; 应该指向能在浏览器中工作的 &lt;code&gt;esm&lt;/code&gt; 产出。但是，只有在为浏览器和服务器（等其他非浏览器环境）创建不同的产出时，才需要设置该字段。如果你没有为多个环境创建多个产出，或者你的产出是“纯 JavaScript”或“通用”的，可以在任何 JavaScript 环境中运行，那么你就不需要设置 &lt;code&gt;browser&lt;/code&gt; 字段。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果你确实需要设置该字段，这里有一个优秀的指南，介绍了配置它的不同方法。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;注意，&lt;code&gt;browser&lt;/code&gt; 字段不应该指向 &lt;code&gt;umd&lt;/code&gt; 产出，因为那样的话，你的库就不会被打包工具（如 Webpack）进行 treeshaking，这些打包工具会优先考虑这个字段，而不是其他字段，比如 module 和 main。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;设置 &lt;code&gt;types&lt;/code&gt; 字段&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;types&lt;/code&gt; 定义 TypeScript 类型&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;types&lt;/code&gt; 是一个当打包工具或运行时不支持 &lt;code&gt;package.json#exports&lt;/code&gt; 时的兜底方案；如果打包工具或运行时支持 package exports，则不会使用 &lt;code&gt;types&lt;/code&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;types&lt;/code&gt; 应该指向你的 TypeScript 入口文件，例如 &lt;code&gt;index.d.ts&lt;/code&gt;；它应该与 package exports 中的 &lt;code&gt;types&lt;/code&gt; 字段指向同一个文件。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;列出 &lt;code&gt;peerDependencies&lt;/code&gt;&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果你依赖别的框架或库，将它设置为 peer dependency&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;你应该外置框架。然而，这样做后，你的库只有在开发人员自行安装你需要的框架后才能工作。设置 &lt;code&gt;peerDependencies&lt;/code&gt; 让他们知道他们需要安装的框架。- 例如，如果你在创建一个 React 库：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;{&lt;br/&gt;  &lt;span&gt;&quot;peerDependencies&quot;&lt;/span&gt;: {&lt;br/&gt;    &lt;span&gt;&quot;react&quot;&lt;/span&gt;: &lt;span&gt;&quot;^18.2.0&quot;&lt;/span&gt;,&lt;br/&gt;    &lt;span&gt;&quot;react-dom&quot;&lt;/span&gt;: &lt;span&gt;&quot;^18.2.0&quot;&lt;/span&gt;&lt;br/&gt;  }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;你应该以书面形式来体现这些依赖；例如，&lt;code&gt;npm v3-v6&lt;/code&gt; 不安装 peer dependencies，而 &lt;code&gt;npm v7+&lt;/code&gt; 将自动安装 peer dependencies。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;说明你的库使用哪个&lt;code&gt;许可证&lt;/code&gt;&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;保护你自己和其他的贡献者&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;开源许可证用于保护贡献者和用户。没有这种保护，企业和有经验的开发者不会使用该项目。&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上述引用自 Choose a License，这也是一篇很好的文章，帮助你来决定哪个许可证适合你的项目。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当你决定了许可证，关于许可证的 npm 文档中描述了许可证字段的格式。例如：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;{&lt;br/&gt;  &lt;span&gt;&quot;license&quot;&lt;/span&gt;: &lt;span&gt;&quot;MIT&quot;&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;除此之外，你可以在项目的根目录下创建一个 &lt;code&gt;LICENSE.txt&lt;/code&gt; 文件，并将许可证的文本复制到这里。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果这篇文章帮助到了你，欢迎点赞和关注。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;- EOF -&lt;/span&gt;&lt;/p&gt;&lt;section donone=&quot;shifuMouseDownCard(&#x27;shifu_c_030&#x27;)&quot; label=&quot;Copyright Reserved by PLAYHUDONG.&quot;&gt;&lt;section&gt;&lt;span&gt;推荐阅读&lt;/span&gt;  &lt;span&gt;点击标题可跳转&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;p&gt;&lt;span&gt;1、&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzA5NjUxMTM2MQ==&amp;amp;mid=2247495032&amp;amp;idx=2&amp;amp;sn=3df2f0aa5037d9231cf473fbceae3f03&amp;amp;chksm=90ac5996a7dbd0809fb1e4fc1e7ef86077995953175980f1da35e5b2e9014d48f0fcf5edfab0&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;纯 JS 实现语雀的划词高亮功能&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;纯 JS 实现语雀的划词高亮功能&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;2、&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzA5NjUxMTM2MQ==&amp;amp;mid=2247494632&amp;amp;idx=1&amp;amp;sn=2990189b6680c624bc27551538bdde25&amp;amp;chksm=90ac5f06a7dbd610a01469613d060ff43ebd9949eec850aac8003459af429de178a63c0e9b4a&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;万字总结 JS 数据结构与常用的算法&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;万字总结 JS 数据结构与常用的算法&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;3、&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzA5NjUxMTM2MQ==&amp;amp;mid=2247492878&amp;amp;idx=1&amp;amp;sn=3d6340e32ef54384f98d8b9fb2e83425&amp;amp;chksm=90ac51e0a7dbd8f60aa9cb50e928421fc64de18c6fe9d577e4c0069c7aa7a90da07743ed3f35&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;浅谈 JS 内存机制&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;11&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;浅谈 JS 内存机制&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;觉得本文对你有帮助？请分享给更多人&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;关注「大前端技术之路」加星标，提升前端技能&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;&lt;mp-common-profile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mpprofile&quot; data-weui-theme=&quot;light&quot; data-id=&quot;MzA5NjUxMTM2MQ==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/mshqAkialV7FvgHwjwFbEbT0nNZU2AVPsmAuuZfXfp0Yc8H3FNkbiaKZYUJNichcJ3lZj4HiceOTXAeTnPHJrLFklA/0?wx_fmt=png&quot; data-nickname=&quot;大前端技术之路&quot; data-alias=&quot;frontroute&quot; data-signature=&quot;分享Web前端，Node.js、React Native等大前端技术栈精选&quot; data-from=&quot;1&quot; data-is_biz_ban=&quot;0&quot;/&gt;&lt;/section&gt;&lt;p&gt;&lt;span/&gt;&lt;span&gt;点赞和在看就是最大的支持&lt;/span&gt;&lt;span&gt;❤️&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>