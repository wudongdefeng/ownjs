<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>e888f9330727d5077f4358dd0da03d65</guid>
<title>Rust 的内存安全以及 move、copy、clone 语义</title>
<link>https://toutiao.io/k/yy1bv27</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;img src=&quot;https://oss-emcsprod-public.modb.pro/image/auto/modb_20221226_0800345a-850e-11ed-a8a4-fa163eb4f6be.png&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;p&gt;&lt;span&gt;楔子&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;img src=&quot;https://oss-emcsprod-public.modb.pro/image/auto/modb_20221226_0804418a-850e-11ed-a8a4-fa163eb4f6be.png&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;最近看到了两篇文章，觉得写得非常好。这里将其翻译一下，并结合自己的理解，对内容做一些补充。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;文章链接如下：&lt;/span&gt;&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;&lt;span&gt;https://hashrust.com/blog/memory-safety-in-rust-part-2/&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;https://hashrust.com/blog/moves-copies-and-clones-in-rust/&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;img src=&quot;https://oss-emcsprod-public.modb.pro/image/auto/modb_20221226_0800345a-850e-11ed-a8a4-fa163eb4f6be.png&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;p&gt;&lt;span&gt;堆内存应该什么时候释放&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;img src=&quot;https://oss-emcsprod-public.modb.pro/image/auto/modb_20221226_0804418a-850e-11ed-a8a4-fa163eb4f6be.png&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;前面在介绍栈与堆的时候说过，大小在编译期间即可确定、并且后续不会改变的对象，一般会在栈上申请内存；而大小在编译期间未知、或者后续会动态改变的对象，要在堆上为其分配内存。当然啦，虽然是在堆上分配的内存，但对象本身还是在栈上的，只是实际的数据在堆上，并通过指针指向。我们以动态数组为例：&lt;/span&gt;&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;let&lt;/span&gt; v: &lt;span&gt;Vec&lt;/span&gt;&amp;lt;&lt;span&gt;i32&lt;/span&gt;&amp;gt; = &lt;span&gt;Vec&lt;/span&gt;::new();&lt;/span&gt;&lt;/code&gt;&lt;br/&gt;&lt;/pre&gt;&lt;p&gt;&lt;span&gt;我们知道动态数组是申请在堆上的，但动态数组我们应该分成两部分来看，一部分是动态数组这个结构本身，另一部分是数组里的元素。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://oss-emcsprod-public.modb.pro/image/auto/modb_20221226_08106e38-850e-11ed-a8a4-fa163eb4f6be.png&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;任何一个可变的对象，都由两部分组成。栈上存储不会发生变化的结构本身，比如这里就是指针、容量、长度；然后栈上的指针指向一块堆区内存，这块堆内存负责存放实际的数据，当前就是动态数组里的元素。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;栈上申请的内存不需要我们关心，操作系统会维护它。但堆就不一样了，堆内存的释放，则需要由编译器、解释器或者开发者调用某个函数去释放，因此这就涉及到了时机的问题，我们应该什么时候去释放堆内存呢。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;显然要释放堆内存，那么就必须确保没有任何指向它的引用，否则就会出现悬空指针。我们举个例子：&lt;/span&gt;&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;fn&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;/span&gt;() {&lt;br/&gt;    {&lt;br/&gt;        &lt;span&gt;let&lt;/span&gt; v = &lt;span&gt;vec!&lt;/span&gt;[&lt;span&gt;1&lt;/span&gt;, &lt;span&gt;2&lt;/span&gt;, &lt;span&gt;3&lt;/span&gt;];&lt;br/&gt;        &lt;span&gt;// 此时堆内存显然还没有释放，也不能释放&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;// 因为变量 v 在引用它&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;println!&lt;/span&gt;(&lt;span&gt;&quot;{:?}&quot;&lt;/span&gt;, v);&lt;br/&gt;    } &lt;span&gt;// 此处堆内存会被释放&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;// 因为变量 v 离开了作用域，那么它在栈上的内存会被回收&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;// 并且这一步是由操作系统完成的。既然栈上的内存被回收了&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;// 那么就没有指向堆内存的引用了，因此堆内存也会被回收&lt;/span&gt;&lt;br/&gt;}&lt;/span&gt;&lt;/code&gt;&lt;br/&gt;&lt;/pre&gt;&lt;p&gt;&lt;span&gt;但 Rust 怎么判断堆内存还有没有变量在引用呢？我们知道在 Python 里面每一个分配在堆上的对象都有一个引用计数，多一个引用，数值加 1；少一个引用，数值减 1；当数值为 0 时，会被销毁。但 Rust 是没有 GC 的，那它是怎么判断的呢？答案是不需要判断，因为 Rust 通过所有权机制保证了一块堆内存在同一时刻只能被一个变量所引用。&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;img src=&quot;https://oss-emcsprod-public.modb.pro/image/auto/modb_20221226_0800345a-850e-11ed-a8a4-fa163eb4f6be.png&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;p&gt;&lt;span&gt;所有权&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;img src=&quot;https://oss-emcsprod-public.modb.pro/image/auto/modb_20221226_0804418a-850e-11ed-a8a4-fa163eb4f6be.png&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;当你在 Rust 当中创建一个对象时，被赋值的变量将成为该对象的所有者。换句话说，变量拥有对象的所有权。&lt;/span&gt;&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;let&lt;/span&gt; v: &lt;span&gt;Vec&lt;/span&gt;&amp;lt;&lt;span&gt;i32&lt;/span&gt;&amp;gt; = &lt;span&gt;Vec&lt;/span&gt;::new();&lt;/span&gt;&lt;/code&gt;&lt;br/&gt;&lt;/pre&gt;&lt;p&gt;&lt;span&gt;同一时刻，一个对象只能有一个所有者，这就保证了只有当所有者离开作用域才能释放堆内存，不会出现二次释放的问题。比如当前动态数组所使用的堆内存是否被释放，就看变量 v 是否离开了自己的作用域。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;如果将变量 v 赋值给它其它变量呢？&lt;/span&gt;&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;fn&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;/span&gt;() {&lt;br/&gt;    &lt;span&gt;let&lt;/span&gt; v: &lt;span&gt;Vec&lt;/span&gt;&amp;lt;&lt;span&gt;i32&lt;/span&gt;&amp;gt; = &lt;span&gt;Vec&lt;/span&gt;::new();&lt;br/&gt;    &lt;span&gt;let&lt;/span&gt; v1 = v;&lt;br/&gt;}&lt;/span&gt;&lt;/code&gt;&lt;br/&gt;&lt;/pre&gt;&lt;p&gt;&lt;span&gt;栈上数据在传递的时候一律拷贝一份，但堆数据不会，于是就变成了如下这个样子：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://oss-emcsprod-public.modb.pro/image/auto/modb_20221226_081d3ba4-850e-11ed-a8a4-fa163eb4f6be.png&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;显然&lt;/span&gt;&lt;span&gt;此时对象（在堆上的&lt;/span&gt;&lt;span&gt;内存）有了&lt;/span&gt;&lt;span&gt;两个所有者，&lt;/span&gt;但 Rust 要求同一时刻，一个对象只能有一个所有者。或者说 Rust 要求堆内存在同一时刻只能被一个变量所引用，而现在有了两个变量。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;于是 Rust 在面对这种情况时，会转移所有权，让 v1 成为对象的新所有者。而 v 就不允许再访问了，因为它已经失去了操作堆内存的权利（所有权）。&lt;/span&gt;&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;fn&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;/span&gt;() {&lt;br/&gt;    &lt;span&gt;let&lt;/span&gt; v = &lt;span&gt;vec!&lt;/span&gt;[&lt;span&gt;1&lt;/span&gt;, &lt;span&gt;2&lt;/span&gt;, &lt;span&gt;3&lt;/span&gt;];&lt;br/&gt;    &lt;span&gt;let&lt;/span&gt; v1 = v;&lt;br/&gt;    &lt;span&gt;// 再使用变量 v 就会报错&lt;/span&gt;&lt;br/&gt;    v;  &lt;span&gt;// value used here after move&lt;/span&gt;&lt;br/&gt;}&lt;/span&gt;&lt;/code&gt;&lt;br/&gt;&lt;/pre&gt;&lt;p&gt;&lt;span&gt;这里我们看到一个报错：value used here after move，意思是 &lt;/span&gt;&lt;span&gt;value 在移动之后又被使用了&lt;/span&gt;&lt;span&gt;，我们稍后会详细解释它。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;但从开发者的角度来看，如果每次传递都要转移所有权的话，那么无疑会很麻烦。比如我想将 v 传到一个函数里面做一些事情，但当函数调用完毕之后 v 还能继续用。于是我们可以考虑引用。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;img src=&quot;https://oss-emcsprod-public.modb.pro/image/auto/modb_20221226_0800345a-850e-11ed-a8a4-fa163eb4f6be.png&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;p&gt;&lt;span&gt;引用&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;img src=&quot;https://oss-emcsprod-public.modb.pro/image/auto/modb_20221226_0804418a-850e-11ed-a8a4-fa163eb4f6be.png&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&amp;amp;v 表示对 v 的引用，我们可以通过 v 去访问动态数组，也可以通过 &amp;amp;v 去访问。而将引用赋值给别的变量这一行为就叫做借用，相当于给别的变量提供了访问的权利，但是又不会转移所有权。&lt;/span&gt;&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;fn&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;/span&gt;() {&lt;br/&gt;    &lt;span&gt;let&lt;/span&gt; v = &lt;span&gt;vec!&lt;/span&gt;[&lt;span&gt;1&lt;/span&gt;, &lt;span&gt;2&lt;/span&gt;, &lt;span&gt;3&lt;/span&gt;];&lt;br/&gt;    &lt;span&gt;let&lt;/span&gt; v1 = &amp;amp;v;&lt;br/&gt;    &lt;span&gt;println!&lt;/span&gt;(&lt;span&gt;&quot;{}&quot;&lt;/span&gt;, v.len());  &lt;span&gt;// 3&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;println!&lt;/span&gt;(&lt;span&gt;&quot;{}&quot;&lt;/span&gt;, v1.len()); &lt;span&gt;// 3&lt;/span&gt;&lt;br/&gt;}&lt;/span&gt;&lt;/code&gt;&lt;br/&gt;&lt;/pre&gt;&lt;p&gt;&lt;span&gt;而引用可以赋给很多个变量，换句话说可以有多个借用者：&lt;/span&gt;&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;fn&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;/span&gt;() {&lt;br/&gt;    &lt;span&gt;let&lt;/span&gt; v = &lt;span&gt;vec!&lt;/span&gt;[&lt;span&gt;1&lt;/span&gt;, &lt;span&gt;2&lt;/span&gt;, &lt;span&gt;3&lt;/span&gt;];&lt;br/&gt;    &lt;span&gt;let&lt;/span&gt; v1 = &amp;amp;v;&lt;br/&gt;    &lt;span&gt;let&lt;/span&gt; v2 = &amp;amp;v;&lt;br/&gt;    &lt;span&gt;println!&lt;/span&gt;(&lt;span&gt;&quot;{}&quot;&lt;/span&gt;, v.len());  &lt;span&gt;// 3&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;println!&lt;/span&gt;(&lt;span&gt;&quot;{}&quot;&lt;/span&gt;, v1.len()); &lt;span&gt;// 3&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;println!&lt;/span&gt;(&lt;span&gt;&quot;{}&quot;&lt;/span&gt;, v2.len()); &lt;span&gt;// 3&lt;/span&gt;&lt;br/&gt;}&lt;/span&gt;&lt;/code&gt;&lt;br/&gt;&lt;/pre&gt;&lt;p&gt;&lt;span&gt;但借用者不能在所有者离开作用域之后（内存被释放），继续访问相应内存，否则会出现错误。&lt;/span&gt;&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;fn&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;/span&gt;() {&lt;br/&gt;    &lt;span&gt;let&lt;/span&gt; v1;&lt;br/&gt;    {&lt;br/&gt;        &lt;span&gt;let&lt;/span&gt; v = &lt;span&gt;vec!&lt;/span&gt;[&lt;span&gt;1&lt;/span&gt;, &lt;span&gt;2&lt;/span&gt;, &lt;span&gt;3&lt;/span&gt;];&lt;br/&gt;        v1 = &amp;amp;v;&lt;br/&gt;    }  &lt;span&gt;// v 在此处会被释放&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;// 但我们仍然操作了它的引用&lt;/span&gt;&lt;br/&gt;    v1.len();&lt;br/&gt;}&lt;/span&gt;&lt;/code&gt;&lt;br/&gt;&lt;/pre&gt;&lt;p&gt;&lt;span&gt;Rust 编译器足够聪明，它会确保借用者的使用范围不会超过所有者的存活时间。如果我们将上面的 v1.len() 给删掉，那么程序是没有问题的。&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;img src=&quot;https://oss-emcsprod-public.modb.pro/image/auto/modb_20221226_0800345a-850e-11ed-a8a4-fa163eb4f6be.png&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;p&gt;&lt;span&gt;可变引用&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;img src=&quot;https://oss-emcsprod-public.modb.pro/image/auto/modb_20221226_0804418a-850e-11ed-a8a4-fa163eb4f6be.png&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&amp;amp;v 表示获取 v 的不可变引用，&amp;amp;mut v 表示获取 v 的可变引用。而将不可变引用赋值给别的变量叫做不可变借用，将可变引用赋值给别的变量叫做可变借用。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;然后可变引用表达的含义是：允许通过引用去修改指向的值。所以获取变量的可变引用有一个前提，变量本身必须是可变的。&lt;/span&gt;&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;fn&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;/span&gt;() {&lt;br/&gt;    &lt;span&gt;let&lt;/span&gt; &lt;span&gt;mut&lt;/span&gt; v = &lt;span&gt;vec!&lt;/span&gt;[&lt;span&gt;1&lt;/span&gt;, &lt;span&gt;2&lt;/span&gt;, &lt;span&gt;3&lt;/span&gt;];&lt;br/&gt;    &lt;span&gt;let&lt;/span&gt; v1 = &amp;amp;&lt;span&gt;mut&lt;/span&gt; v;&lt;br/&gt;    v1.push(&lt;span&gt;4&lt;/span&gt;);&lt;br/&gt;    &lt;span&gt;println!&lt;/span&gt;(&lt;span&gt;&quot;{:?}&quot;&lt;/span&gt;, v1);&lt;br/&gt;    &lt;span&gt;// [1, 2, 3, 4]&lt;/span&gt;&lt;br/&gt;}&lt;/span&gt;&lt;/code&gt;&lt;br/&gt;&lt;/pre&gt;&lt;p&gt;&lt;span&gt;一个变量的不可变引用可以有任意&lt;/span&gt;&lt;span&gt;多个，但一个变量的可变引用在同一作用域当中只能有一个。并且在获得可变引用之后，就不能再获取不可变引用了。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;不可变引用和可变引用的存在关系就类似于读锁和写锁，读锁可以有很多个，但写锁具有排他性。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;img src=&quot;https://oss-emcsprod-public.modb.pro/image/auto/modb_20221226_0800345a-850e-11ed-a8a4-fa163eb4f6be.png&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;p&gt;&lt;span&gt;move 和 copy&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;img src=&quot;https://oss-emcsprod-public.modb.pro/image/auto/modb_20221226_0804418a-850e-11ed-a8a4-fa163eb4f6be.png&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;前面说了，将一个变量赋值给另一个变量的时候会转移所有权。&lt;/span&gt;&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;fn&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;/span&gt;() {&lt;br/&gt;    &lt;span&gt;let&lt;/span&gt; v = &lt;span&gt;vec!&lt;/span&gt;[&lt;span&gt;1&lt;/span&gt;, &lt;span&gt;2&lt;/span&gt;, &lt;span&gt;3&lt;/span&gt;];&lt;br/&gt;    &lt;span&gt;let&lt;/span&gt; v1 = v;  &lt;span&gt;// v1 成为了新的所有者&lt;/span&gt;&lt;br/&gt;}&lt;/span&gt;&lt;/code&gt;&lt;br/&gt;&lt;/pre&gt;&lt;p&gt;&lt;span&gt;我们将 v 赋值给 v1 之后，会出现两个栈指针指向同一份堆内存，如下图所示：&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://oss-emcsprod-public.modb.pro/image/auto/modb_20221226_081d3ba4-850e-11ed-a8a4-fa163eb4f6be.png&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;所以此时会发生所有权的转移，以后这块堆内存就由变量 v1 来负责，v 再也无权染指，于是我们就说 v 发生了移动，它被移动到了 v1 上。并且 v 在移动之后，就不可以再使用了，当然它的引用也是如此，因为 Rust 不允许有两个栈指针指向同一块堆内存。&lt;/span&gt;&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;fn&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;/span&gt;() {&lt;br/&gt;    &lt;span&gt;let&lt;/span&gt; v = &lt;span&gt;vec!&lt;/span&gt;[&lt;span&gt;1&lt;/span&gt;, &lt;span&gt;2&lt;/span&gt;, &lt;span&gt;3&lt;/span&gt;];&lt;br/&gt;    &lt;span&gt;// v 发生了移动&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;let&lt;/span&gt; v1 = v;&lt;br/&gt;    &lt;span&gt;// 移动之后 v 不可以再使用&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;// 但这里使用了，因此报错&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;// value used here after move&lt;/span&gt;&lt;br/&gt;    v;&lt;br/&gt;}&lt;/span&gt;&lt;/code&gt;&lt;br/&gt;&lt;/pre&gt;&lt;p&gt;&lt;span&gt;相信你对这段报错的理解应该更加深刻了，然后还有一个与之相似的错误：&lt;/span&gt;&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;fn&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;/span&gt;() {&lt;br/&gt;    &lt;span&gt;let&lt;/span&gt; v = &lt;span&gt;vec!&lt;/span&gt;[&lt;span&gt;1&lt;/span&gt;, &lt;span&gt;2&lt;/span&gt;, &lt;span&gt;3&lt;/span&gt;];&lt;br/&gt;    &lt;span&gt;let&lt;/span&gt; v1 = v;&lt;br/&gt;    &lt;span&gt;// 报错：value borrowed here after move&lt;/span&gt;&lt;br/&gt;    v.len();&lt;br/&gt;}&lt;/span&gt;&lt;/code&gt;&lt;br/&gt;&lt;/pre&gt;&lt;p&gt;&lt;span&gt;变量在移动之后，它和它的引用都不能再使用。但在调用 v.len() 的时候，会将 v 的引用赋值给 len 方法的第一个参数，因此相当于发生了借用。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;这两个错误是类似的，本质上都是使用了一个已经转移所有权的变量（或者变量的引用）。&lt;/span&gt;&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;fn&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;/span&gt;() {&lt;br/&gt;    &lt;span&gt;let&lt;/span&gt; v = &lt;span&gt;vec!&lt;/span&gt;[&lt;span&gt;1&lt;/span&gt;, &lt;span&gt;2&lt;/span&gt;, &lt;span&gt;3&lt;/span&gt;];&lt;br/&gt;    &lt;span&gt;// v 发生了转移&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;let&lt;/span&gt; v1 = v;&lt;br/&gt;    &lt;span&gt;// 使用了转移之后的变量&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;// value used here after move&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;let&lt;/span&gt; v2 = v;&lt;br/&gt;    &lt;span&gt;// 使用了转移之后的变量的引用&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;// value borrowed here after move&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;let&lt;/span&gt; v3 = &amp;amp;v;&lt;br/&gt;}&lt;/span&gt;&lt;/code&gt;&lt;br/&gt;&lt;/pre&gt;&lt;p&gt;&lt;span&gt;另外除了赋值会导致变量移动之外，作为参数和返回值也是可以的，因为这个过程本质上也是赋值。&lt;/span&gt;&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;fn&lt;/span&gt; &lt;span&gt;sum&lt;/span&gt;&lt;/span&gt;(v: &lt;span&gt;Vec&lt;/span&gt;&amp;lt;&lt;span&gt;i32&lt;/span&gt;&amp;gt;) -&amp;gt; &lt;span&gt;i32&lt;/span&gt; {&lt;br/&gt;    &lt;span&gt;let&lt;/span&gt; &lt;span&gt;mut&lt;/span&gt; s = &lt;span&gt;0&lt;/span&gt;;&lt;br/&gt;    &lt;span&gt;for&lt;/span&gt; item &lt;span&gt;in&lt;/span&gt; v {&lt;br/&gt;        s += item;&lt;br/&gt;    }&lt;br/&gt;    s&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;fn&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;/span&gt;() {&lt;br/&gt;    &lt;span&gt;let&lt;/span&gt; v = &lt;span&gt;vec!&lt;/span&gt;[&lt;span&gt;1&lt;/span&gt;, &lt;span&gt;2&lt;/span&gt;, &lt;span&gt;3&lt;/span&gt;];&lt;br/&gt;    &lt;span&gt;// v 作为了 sum 函数的参数&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;// 相当于发生了移动&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;println!&lt;/span&gt;(&lt;span&gt;&quot;{}&quot;&lt;/span&gt;, sum(v));  &lt;span&gt;// 6&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;// 之后 v 不可以再被使用&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;// 如果希望 v 依然保持有效&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;// 那么 sum 的第一个参数的类型应该是 &amp;amp;Vec&amp;lt;i32&amp;gt;&lt;/span&gt;&lt;br/&gt;}&lt;/span&gt;&lt;/code&gt;&lt;br/&gt;&lt;/pre&gt;&lt;p&gt;&lt;span&gt;然后让我们将类型做一下修改：&lt;/span&gt;&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;fn&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;/span&gt;() {&lt;br/&gt;    &lt;span&gt;/*&lt;br/&gt;        let v = vec![1, 2, 3];&lt;br/&gt;        let v1 = v;&lt;br/&gt;        // 此处 v 不再有效&lt;br/&gt;        println!(&quot;{:?}&quot;, v);&lt;br/&gt;    */&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;let&lt;/span&gt; v = &lt;span&gt;123&lt;/span&gt;;&lt;br/&gt;    &lt;span&gt;let&lt;/span&gt; v1 = v;&lt;br/&gt;    &lt;span&gt;println!&lt;/span&gt;(&lt;span&gt;&quot;{} {}&quot;&lt;/span&gt;, v, v1)  &lt;span&gt;// 123 123&lt;/span&gt;&lt;br/&gt;}&lt;/span&gt;&lt;/code&gt;&lt;br/&gt;&lt;/pre&gt;&lt;p&gt;&lt;span&gt;咦，为啥将动态数组换成普通的 i32 整数，v 就能在赋值之后依旧保持有效呢？或者说，赋值语句为啥没有把 v 移动到 v1 上呢？&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;很简单，因为整数默认完全分配在栈上，根本不涉及到堆。而栈上的数据在传递的时候一律拷贝一份，所以 &lt;/span&gt;&lt;span&gt;let v1  = v&lt;/span&gt;&lt;span&gt; 之后两个变量拥有的数据都是各自独立的，我们没有理由去阻止 v 继续保持有效。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://oss-emcsprod-public.modb.pro/image/auto/modb_20221226_0876ff90-850e-11ed-a8a4-fa163eb4f6be.png&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;像这种不涉及到堆，传递之后彼此独立的类型称之为&lt;/span&gt;&lt;span&gt;可 Copy 类型&lt;/span&gt;&lt;span&gt;，或者说其实现了 Copy 这个 trait。所有的基础类型：像整数、浮点数、字符等都是可 Copy 的，而元组和数组则取决于内部的元素，如果内部的元素都是可 Copy 的，那么元组/数组也是可 Copy 的。&lt;/span&gt;&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;fn&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;/span&gt;() {&lt;br/&gt;    &lt;span&gt;// v 里的元素都是可 Copy 的&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;// 那么 v 也是可 Copy 的&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;let&lt;/span&gt; v = [&lt;span&gt;1&lt;/span&gt;, &lt;span&gt;2&lt;/span&gt;, &lt;span&gt;3&lt;/span&gt;];&lt;br/&gt;    &lt;span&gt;let&lt;/span&gt; v1 = v;&lt;br/&gt;    &lt;span&gt;println!&lt;/span&gt;(&lt;span&gt;&quot;{:?}&quot;&lt;/span&gt;, v);&lt;br/&gt;    &lt;span&gt;/*&lt;br/&gt;    [1, 2, 3]&lt;br/&gt;    */&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;// v 里面的元素不是可 Copy 的&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;// 所以 v 不是可 Copy 的&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;let&lt;/span&gt; v = [&lt;span&gt;String&lt;/span&gt;::from(&lt;span&gt;&quot;古明地觉&quot;&lt;/span&gt;)];&lt;br/&gt;    &lt;span&gt;let&lt;/span&gt; v1 = v;&lt;br/&gt;    &lt;span&gt;// 赋值之后 v 不再有效，或者说发生了转移&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;// 但我们却将它的引用传给了宏 println!&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;// println!(&quot;{:?}&quot;, v);&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;/*&lt;br/&gt;    value borrowed here after move&lt;br/&gt;    */&lt;/span&gt;&lt;br/&gt;}&lt;/span&gt;&lt;/code&gt;&lt;br/&gt;&lt;/pre&gt;&lt;p&gt;&lt;span&gt;然后是 struct 和 enum，它们默认不是可 Copy 的，但可以为其派生相应的 trait。&lt;/span&gt;&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;// 让结构体可以通过 &quot;{:?}&quot; 打印&lt;/span&gt;&lt;br/&gt;&lt;span&gt;#[derive(Debug)]&lt;/span&gt;&lt;br/&gt;&lt;span&gt;// 让结构体是可 Copy 的&lt;/span&gt;&lt;br/&gt;&lt;span&gt;// 事实上这个三个 trait 可以写在一行&lt;/span&gt;&lt;br/&gt;&lt;span&gt;// #[derive(Degug, Clone, Copy)]&lt;/span&gt;&lt;br/&gt;&lt;span&gt;#[derive(Clone, Copy)]&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;struct&lt;/span&gt; &lt;span&gt;Point&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;    x: &lt;span&gt;i32&lt;/span&gt;,&lt;br/&gt;    y: &lt;span&gt;i32&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;fn&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;/span&gt;() {&lt;br/&gt;    &lt;span&gt;let&lt;/span&gt; p = Point{x: &lt;span&gt;5&lt;/span&gt;, y: &lt;span&gt;6&lt;/span&gt;};&lt;br/&gt;    &lt;span&gt;let&lt;/span&gt; p1 = p;&lt;br/&gt;    &lt;span&gt;println!&lt;/span&gt;(&lt;span&gt;&quot;{:?}&quot;&lt;/span&gt;, p);&lt;br/&gt;    &lt;span&gt;println!&lt;/span&gt;(&lt;span&gt;&quot;{:?}&quot;&lt;/span&gt;, p1);&lt;br/&gt;    &lt;span&gt;/*&lt;br/&gt;    Point { x: 5, y: 6 }&lt;br/&gt;    Point { x: 5, y: 6 }&lt;br/&gt;    */&lt;/span&gt;&lt;br/&gt;}&lt;/span&gt;&lt;/code&gt;&lt;br/&gt;&lt;/pre&gt;&lt;p&gt;&lt;span&gt;这里会有人好奇，不是实现 Copy 吗，为啥把 Clone 也带上了。这个问题暂时先不考虑，以后再解释，只需要知道 Clone 是必须的即可。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;如果实现了 Copy trait，那么结构体或者枚举的每个成员都要是可 Copy 的，像下面这段代码就不合法。&lt;/span&gt;&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;#[derive(Clone, Copy)]&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;struct&lt;/span&gt; &lt;span&gt;Point&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;    x: &lt;span&gt;Vec&lt;/span&gt;&amp;lt;&lt;span&gt;i32&lt;/span&gt;&amp;gt;&lt;br/&gt;}&lt;/span&gt;&lt;/code&gt;&lt;br/&gt;&lt;/pre&gt;&lt;p&gt;&lt;span&gt;x 是 Vec&amp;lt;i32&amp;gt; 类型，它没有实现 Copy。&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;img src=&quot;https://oss-emcsprod-public.modb.pro/image/auto/modb_20221226_0800345a-850e-11ed-a8a4-fa163eb4f6be.png&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;p&gt;&lt;span&gt;clone&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;img src=&quot;https://oss-emcsprod-public.modb.pro/image/auto/modb_20221226_0804418a-850e-11ed-a8a4-fa163eb4f6be.png&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;如果只拷贝栈数据、不拷贝堆数据，那么称之为浅拷贝；既拷贝栈数据、又拷贝堆数据，那么称之为深拷贝。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Rust 默认是浅拷贝，这对可 Copy 的类型来说是没问题的，因为它们的数据都在栈上。但像字符串、动态数组就不行了，它们内部的实际数据是存在堆上的，此时会发生变量的移动，或者说所有权的转移。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;那么问题来了，可不可以将堆数据也拷贝一份呢？也就是进行深度拷贝，答案是可以的。&lt;/span&gt;&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;fn&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;/span&gt;() {&lt;br/&gt;    &lt;span&gt;let&lt;/span&gt; v = &lt;span&gt;vec!&lt;/span&gt;[&lt;span&gt;1&lt;/span&gt;, &lt;span&gt;2&lt;/span&gt;, &lt;span&gt;3&lt;/span&gt;];&lt;br/&gt;    &lt;span&gt;let&lt;/span&gt; v1 = v.clone();&lt;br/&gt;    &lt;span&gt;println!&lt;/span&gt;(&lt;span&gt;&quot;{:?}&quot;&lt;/span&gt;, v);&lt;br/&gt;    &lt;span&gt;println!&lt;/span&gt;(&lt;span&gt;&quot;{:?}&quot;&lt;/span&gt;, v1);&lt;br/&gt;    &lt;span&gt;/*&lt;br/&gt;    [1, 2, 3]&lt;br/&gt;    [1, 2, 3]&lt;br/&gt;    */&lt;/span&gt;&lt;br/&gt;}&lt;/span&gt;&lt;/code&gt;&lt;br/&gt;&lt;/pre&gt;&lt;p&gt;&lt;span&gt;如果是 let v1 = v，那么是浅拷贝，而 v.clone() 则表示深拷贝，此时内存布局示意图如下：&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;https://oss-emcsprod-public.modb.pro/image/auto/modb_20221226_08a0f17e-850e-11ed-a8a4-fa163eb4f6be.png&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;像这种数据存储在堆上的类型，都有 clone 方法，或者说它们都实现了 Clone 这个 trait。举个例子：&lt;/span&gt;&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;#[derive(Debug)]&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;struct&lt;/span&gt; &lt;span&gt;Point&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;    x: &lt;span&gt;i32&lt;/span&gt;,&lt;br/&gt;    y: &lt;span&gt;i32&lt;/span&gt;,&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// 实现了 Clone trait，便可调用 clone 方法&lt;/span&gt;&lt;br/&gt;&lt;span&gt;impl&lt;/span&gt; &lt;span&gt;Clone&lt;/span&gt; &lt;span&gt;for&lt;/span&gt; Point {&lt;br/&gt;    &lt;span&gt;&lt;span&gt;fn&lt;/span&gt; &lt;span&gt;clone&lt;/span&gt;&lt;/span&gt;(&amp;amp;&lt;span&gt;self&lt;/span&gt;) -&amp;gt; &lt;span&gt;Self&lt;/span&gt; {&lt;br/&gt;        Point {&lt;br/&gt;            x: &lt;span&gt;self&lt;/span&gt;.x + &lt;span&gt;1&lt;/span&gt;,&lt;br/&gt;            y: &lt;span&gt;self&lt;/span&gt;.y + &lt;span&gt;1&lt;/span&gt;,&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;fn&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;/span&gt;() {&lt;br/&gt;    &lt;span&gt;let&lt;/span&gt; v = Point{x: &lt;span&gt;3&lt;/span&gt;, y: &lt;span&gt;4&lt;/span&gt;};&lt;br/&gt;    &lt;span&gt;let&lt;/span&gt; v1 = v.clone();&lt;br/&gt;    &lt;span&gt;println!&lt;/span&gt;(&lt;span&gt;&quot;{:?}&quot;&lt;/span&gt;, v);&lt;br/&gt;    &lt;span&gt;println!&lt;/span&gt;(&lt;span&gt;&quot;{:?}&quot;&lt;/span&gt;, v1);&lt;br/&gt;    &lt;span&gt;/*&lt;br/&gt;    Point { x: 3, y: 4 }&lt;br/&gt;    Point { x: 4, y: 5 }&lt;br/&gt;    */&lt;/span&gt;&lt;br/&gt;}&lt;/span&gt;&lt;/code&gt;&lt;br/&gt;&lt;/pre&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;Rust 一切皆类型，并由 trait 掌握类型的行为逻辑。通过实现 Clone trait，&lt;/span&gt;此时的 Point 结构体也拥有了 clone 方法。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;img src=&quot;https://oss-emcsprod-public.modb.pro/image/auto/modb_20221226_0800345a-850e-11ed-a8a4-fa163eb4f6be.png&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;p&gt;&lt;span&gt;小结&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;img src=&quot;https://oss-emcsprod-public.modb.pro/image/auto/modb_20221226_0804418a-850e-11ed-a8a4-fa163eb4f6be.png&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;因此要注意 Rust 当中的赋值语句，由于 Rust 默认是浅拷贝，如果数据在浅拷贝之后彼此独立，那么说明数据全部在栈上。而这样的类型实现了 Copy trait，比如整数类型、浮点型等等。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;如果栈上存储的是指针，指针指向了一块堆内存，那么浅拷贝之后，就会有两个栈指针指向同一块堆内存。因此这时候就会出现变量的移动，用于赋值的变量在赋值之后就不能再用了，除非显示地调用 clone 方法进行深度拷贝。而这样类型实现了 Clone trait，比如字符串、动态数组。&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;mp-style-type/&gt;&lt;/p&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>fb1eb1cd75f939fd0eed3855ff448538</guid>
<title>MACH架构的质量工程指南</title>
<link>https://toutiao.io/k/funf42q</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;&lt;em&gt;MACH是快速创建高质量应用的最佳实践，同时也意味着有助于团队内的质量工程。本文介绍了MACH在质量工程领域所起的作用，并介绍了成功的MACH架构必备的8个要素。原文: &lt;span&gt;MACH Architecture: The Quality Engineering Guide&lt;/span&gt;&lt;sup&gt;[1]&lt;/sup&gt;&lt;/em&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.750814332247557&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/9utHkjMdE0UVJj2yQEAmE4LsPXIDFHj2bqCZy0SEqRBPw6lHIDB4ZItnBB5Zc4hRBxggkS0mo69m9USPymKYmA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;614&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;MACH和质量工程有关。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在过去几年里，关于微服务的定义、粒度和最佳实践的争论层出不穷，这些讨论甚至会让我们忽视最初构建微服务的动机。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;MACH的出现是&lt;em&gt;Microservices&lt;/em&gt;、&lt;em&gt;API&lt;/em&gt;、&lt;em&gt;Cloud-native SaaS&lt;/em&gt;和&lt;em&gt;Headless&lt;/em&gt;的缩写，即模块化服务的所有组件都是可组合、可伸缩的。这一缩写的发音和&quot;MAC&quot;一样，从而能够帮助其传播。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这篇文章分享了MACH在质量工程范式中如何适应持续快速交付高质量软件的原因、内容和方法。在文章的第二部分，分享了成功的MACH服务的8个要素。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.752442996742671&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/9utHkjMdE0UVJj2yQEAmE4LsPXIDFHj2z6HF9FBoxSzHHZUVEiaBrAktiaPgpqaVjhLznia5ibP0JMoRnJJ2dA9ldw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;614&quot;/&gt;&lt;/figure&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;为什么需要MACH?&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;为了在加速创新和竞争的生态系统中生存，企业面临越来越大的数字化转型压力，科技浪潮正通过软件重塑每一个行业和部门，并成为其&lt;span&gt;生存的先决条件&lt;/span&gt;&lt;sup&gt;[2]&lt;/sup&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;转型不能等上几个月，企业在构建数字平台的过程中需要看到短期收益和中期增量。主要的挑战使最初的增量可扩展，从而使其不仅在第一天有价值，而且能够在以后可复制。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;今天所做的一切都是为明天打下的坚实基础，而这一切需要&quot;设计&quot;。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5241545893719807&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/9utHkjMdE0UVJj2yQEAmE4LsPXIDFHj264WqRg2D3WjAhd5MzdDiaEyaMncib1xjDTSG0TK8TTbVtIeK5iaibIBvJg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;828&quot;/&gt;&lt;figcaption&gt;图1: MACH来自于基于可组合的API的新兴趋势。图片来自MACH Alliance。&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;数字化组织希望向一组用户和合作伙伴提供服务，使他们能够像在市场中那样通过协作获取价值，业务服务需要在设计上对大量消费者来说都是可插拔、可扩展，要确保这一点并不容易。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这就是MACH这个首字母缩写所发挥作用的地方，从而能够共享&lt;em&gt;微服务&lt;/em&gt;、&lt;em&gt;API&lt;/em&gt;、&lt;em&gt;云&lt;/em&gt;和&lt;em&gt;Headless&lt;/em&gt;的需求，这是构建具有高度可组合性和可伸缩性的服务的4个关键元素，以支持基于软件平台进行的业务再造。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;什么是MACH?&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;MACH是一个缩略语，提出了为数字组织构建服务的本质，尤其是那些在生态系统中需要大量集成的组织。此外它同样适用于业务和内部服务，如CI/CD平台，以提供自助化服务体验。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;MACH&lt;/strong&gt;的4个关键要素是:&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;微服务(Microservices)&lt;/strong&gt; ，强调了模块化。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;API&lt;/strong&gt;，强调接口的使用。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;原生云(Cloud-native)SaaS&lt;/strong&gt;，推动托管服务。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;Headless&lt;/strong&gt;，意味与前端没有耦合。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.4601449275362319&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/9utHkjMdE0UVJj2yQEAmE4LsPXIDFHj25joTpJbvxdzz7icn3icL0ATib8UqmR7B3BSKIsVzon4eR57jfwiaBD1pIg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;828&quot;/&gt;&lt;figcaption&gt;图2:来自MACH Alliance的MACH缩写介绍。&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;MACH中的&lt;span&gt;微服务&lt;/span&gt;&lt;sup&gt;[3]&lt;/sup&gt;强调了构建模块化服务，这些服务可以很好的与所解决的业务领域保持一致。&lt;span&gt;DDD&lt;/span&gt;&lt;sup&gt;[4]&lt;/sup&gt;是一种可以用来构建具有&quot;高内聚、低耦合&quot;的均衡服务的实践。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;API&lt;/strong&gt;通过显式接口提供抽象，帮助分离功能的生产者和消费者。在线版本控制、文档和REST等标准协议有助于改善服务的连通性。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;原生云SaaS&lt;/strong&gt;的重点是云上的托管服务，而不是构建在一开始就可用的完整的内部解决方案，这样的解决方案有可能当组织需要专注于其业务时，无法根据必要的特性、规模和维护进行扩展。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;Headless&lt;/strong&gt;遵循在MACH其他属性中发现的关注点分离，强调提供技术API，以便任何消费者都可以在自己的上下文中调用服务，比如headless工作流、web或移动应用，通过开放实现互联互通的最大化。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;MACH对质量和速度的意义&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;MACH服务的价值始于对备选方案的权衡。一个例子是建立一个与网站直连的内容管理系统(CMS)的传统方法，因为电子商务在当时只与网站有关。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这么做的好处是部署单个单元很简单，但当业务需求发生变化时，就会出现许多问题，需要对核心架构进行调整，例如相同的服务需要连接现有网站之外的移动应用程序。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.5277777777777778&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/9utHkjMdE0UVJj2yQEAmE4LsPXIDFHj25P5sqP3SjEkID1JG0uSFja04TEalMx4wo8E9eNuGmeicGo1tZBymldA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;828&quot;/&gt;&lt;figcaption&gt;图3:一个headless CMS向多个消费者提供API。&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;一种解决方案是复制手机的服务以及部分后端，这在数据管理和成本方面是一种相当有风险的操作。另一种是尝试让新渠道适应现有渠道，只为CMS构建web界面，但总有一天系统会变得越来越复杂，并开始崩溃，这只是时间问题。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;公司最终将不得不将其内容管理服务转换为模块化服务，从而可以连接不同的前端。然后，该组织可以将web和移动应用连接相同的服务，并轻松扩展为全渠道体验，提供可以连接多个消费者的单一后端。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;实现这种有价值的增量转换的方法之一是通过MACH服务，从第一天开始就交付可以&lt;span&gt;在生态系统中进行连接&lt;/span&gt;&lt;sup&gt;[5]&lt;/sup&gt;的微小增量，采用现成解决方案还可以帮助简化与特定业务领域的MACH服务的集成(如全渠道购物车)。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.75&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/9utHkjMdE0UVJj2yQEAmE4LsPXIDFHj2mZeOXuTtRkiblbBQnzh22IYjjj3FlPHgUt1ia5tMhQu394picG3sdwO3w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;828&quot;/&gt;&lt;figcaption&gt;图4: MACH模块化和可组合架构示例。图片来自MACH Alliance。&lt;/figcaption&gt;&lt;/figure&gt;&lt;hr data-tool=&quot;mdnice编辑器&quot;/&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;MACH成功要素&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;MACH做了&quot;正确的事&quot;，从而为快速交付高质量微服务提供了参考框架。但要有效实施这些措施，必须确保&quot;做正确的事&quot;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;以下是MACH服务想要成功的8个要素:&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;业务驱动(Business-driven)&lt;/strong&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;从宏服务开始(Start with macroservices)&lt;/strong&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;标准的互操作技术(Interoperable standards)&lt;/strong&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;真正的云原生(Cloud-Native for real)&lt;/strong&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;有目的的Headless(Headless with a purpose)&lt;/strong&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;异步优于同步(Asynchronous over synchronous)&lt;/strong&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;前向兼容(Retro compatibl)&lt;/strong&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;可自助服务(Available in self-service)&lt;/strong&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.752442996742671&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/9utHkjMdE0UVJj2yQEAmE4LsPXIDFHj2z6HF9FBoxSzHHZUVEiaBrAktiaPgpqaVjhLznia5ibP0JMoRnJJ2dA9ldw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;614&quot;/&gt;&lt;/figure&gt;&lt;hr data-tool=&quot;mdnice编辑器&quot;/&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;1. 业务驱动(Business-driven)&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;团队在专注于技术名词和&quot;MACH&quot;体系架构时，可能会忽略业务焦点。这种疏离会影响服务粒度和交付的潜在价值，最终会让团队将重点放在技术上，而不是业务上。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;因此作为团队，保持系统业务优先的心态是很重要的。应用领域驱动设计(DDD)方法是保持业务领域和要构建的MACH服务之间的一致性的很好的方法。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当团队几乎无法讨论为什么要构建某个服务，或者无法确定用户和目的时，是时候停下来，回到业务愿景上。&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;2. 从宏服务开始(Start with macroservices)&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&quot;微服务&quot;是一个充满歧义的词。有些人会理解为，所有业务功能都应该作为&quot;功能&quot;去实现，利用云原生生态系统的容器，甚至函数作为服务，而忽略了应用程序的边界。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;过于细粒度的方法的危险在于所构建的服务集过于复杂，并且在没有必要的自动化、可观察性以及和该细粒度级别复杂性相匹配的其他需求的情况下，运维这些服务时发生故障的可能性会很高。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;因此，首先是按照&quot;高内聚、低耦合&quot;和&quot;关注点分离&quot;原则构建具有强模块化的细粒度应用程序。从这里开始，构建粒度已经考虑到了微服务。&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;3. 标准的互操作技术(Interoperable standards)&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;将功能解耦并通过接口开放是在MACH中构建服务的正确方式，但如果所用技术在生态系统中是非标准的，那么在寻求快速迭代的生态系统中，采用该技术的潜力就会急剧下降。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;确保在服务中使用标准互操作技术是快速构建高质量服务的要求。一个建议是，对大多数适合同步交互的服务使用REST/JSON，加上事件处理，并在某些情况下使用GraphQL。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在某些行业中，互操作标准也作用于功能层，例如工业数据字典和接口格式。如果所在行业是这种情况，请仔细考虑使用这些标准。&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;4. 真正的云原生(Cloud-Native for real)&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&quot;原生&quot;一词在&quot;云原生SaaS&quot;中有其重要性。许多采用了云的业务使用直接迁移(lift &amp;amp; shift)的方式，以减少风险并提升对云的使用。但这种迁移方式很少创建或受益于&quot;云原生&quot;功能。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如[12因素应用(12-factor application)](https://12factor.net &quot;12因素应用(12-factor application &quot;12因素应用(12-factor application)&quot;)&quot;)这样的云原生服务遵循最佳实践，例如将所有配置外部化，提供跨环境的可移植部署，并可扩展到多个实例。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;缺乏云原生特性的MACH服务迟早会遇到集成问题、迭代速度变慢以及可伸缩性方面的限制。了解了其中的利害关系后，最好确保云原生是设计需求。&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;5. 有目的的Headless(Headless with a purpose)&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;为多个使用者构建的headless服务，随着时间的推移，由于小的更改的积累，可能会变得越来越臃肿，无法适应越来越多的使用者。其挑战在于如何在演进过程中保持模块化，并在必要时创建新的组件。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;从历史上来看，IT界的&quot;重用&quot;和&quot;优化&quot;文化可以引导团队尝试通过将所有更改添加到现有服务中来节省创建新服务的成本。这种行为表明缺乏云文化，从中期来看是危险的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;决策标准不应该是创建服务的成本，这个成本一定是基于适当的自动化之后的剩余成本。主要决策标准应该是模块化和解耦原则，即使是headless，也总是需要考虑用户需求。&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;6. 异步优于同步(Asynchronous over synchronous)&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;API会给人一种感觉，认为所有交互都是通过同步API调用完成的，这与REST的使用标准或之前SOA体系架构中的SOAP API的使用标准存在偏差。问题在于我们其实很少需要同步调用，而且同步调用很快就会达到可伸缩性的极限。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;MACH服务的成功要素在于通过web hook和事件驱动模式实现默认的异步交互机制，这些模式仍然提供可以嵌入API门户的服务。同步模式只有在例外和真正需要的情况下才会出现。&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;7. 前向兼容(Retro compatibl)&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;即使基于MACH架构原则构建和交付了所有东西，交付的质量和速度仍然是首要的业务目标。随着用户数量增加，意味着软件需要发生变化。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;对MACH服务的更改需要通过不中断的变更模式来确保前向兼容性。当服务被发布，并与其他应用(无论内部还是外部)连接时，变更将变得更加困难。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;主要问题在于如何将使用者从一个版本迁移到另一个版本，这涉及到在优先级不同的分布式用户之间进行代价高昂的协调。因此，通过具有前向兼容性的设计最小化变更就成为了一种需求。&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;8. 可自助服务(Available in self-service)&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;数字化的竞争要求我们为达成用户和合作伙伴的目标而快速部署成功的产品。这种速度的追求需要我们在生命周期的每个阶段实现最大程度的自动化，特别是在集成和服务运维方面。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;为业务提供自助服务需要在用户友好的门户中提供API，并提供适当的文档、用例和必要的信息来帮助用户使用服务，并为其付费，所有这些都将最小化人工交互。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;交付自助服务需要从设计阶段就考虑，理想情况下是内建在代码存储库。对于某些服务，还需要对该领域专业人员进行技术写作方面的投资。毕竟，这和发展数字化业务有关。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;MACH在MAMOS&lt;sup&gt;[1]&lt;/sup&gt;中的影响&lt;span/&gt;&lt;/h4&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;[1] MAMOS是创建快速交付质量生态系统的5个领域，也有助于在组织中创建和传播质量工程文化，分别是Methods, Architecture, Management, Organization, Skills。&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;MACH首字母缩写的本质简单而有力。微服务、API、云原生SaaS和Headless这4个构建块都是快速设计和交付优质服务时需要考虑的有效需求。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;MACH的主要贡献者是headless CMS供应商，它们与提供电子商务、移动应用、数据分析和物联网体验的公司有更强的市场机会。但其他参与者也在采用MACH架构，包括成功的初创公司。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;MACH可以被所有愿意推进质量工程的组织所采用，它不属于新成立的公司，不属于技术栈最先进的公司，只和按照MACH的成功要素构建有价值的服务有关。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;为MACH准备好了吗？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;em&gt;你好，我是俞凡，在Motorola做过研发，现在在Mavenir做技术工作，对通信、网络、后端架构、云原生、DevOps、CICD、区块链、AI等技术始终保持着浓厚的兴趣，平时喜欢阅读、思考，相信持续学习、终身成长，欢迎一起交流学习。&lt;br/&gt;微信公众号：DeepNoMind&lt;/em&gt;&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;参考资料&lt;/span&gt;&lt;/h3&gt;&lt;section data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;span&gt;[1]&lt;/span&gt;&lt;p&gt;MACH Architecture: The Quality Engineering Guide: &lt;em&gt;https://medium.com/qe-unit/mach-architecture-the-quality-engineering-guide-9e28d37da936&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[2]&lt;/span&gt;&lt;p&gt;On Defining Quality Engineering: &lt;em&gt;https://qeunit.com/book&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[3]&lt;/span&gt;&lt;p&gt;The Three Pillars of Quality Engineering Microservices: &lt;em&gt;https://qeunit.com/blog/the-three-pillars-of-quality-engineering-microservices&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[4]&lt;/span&gt;&lt;p&gt;The Quality Engineering Structure of a Digital Platform: &lt;em&gt;https://qeunit.com/blog/the-quality-engineering-structure-of-a-digital-platform&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[5]&lt;/span&gt;&lt;p&gt;Business Composability. Maximum Flexibility.: &lt;em&gt;https://qeunit.com/blog/business-composability-maximum-flexibility&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;/section&gt;&lt;span&gt;- END -&lt;/span&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>66599cdbad85132ee5e54582680f4cb7</guid>
<title>优质网站同好者周刊（第 098 期）</title>
<link>https://toutiao.io/k/8ihikuy</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;content&quot;&gt;&lt;p&gt;&lt;a href=&quot;https://nicelinks.site/?utm_source=weekly&quot;&gt;倾城之链&lt;/a&gt;作为一个开放平台，旨在云集全球&lt;strong&gt;优秀网站&lt;/strong&gt;，探索互联网中更广阔的世界。此周刊，将汇聚过去一周&lt;a href=&quot;https://nicelinks.site/?utm_source=weekly&quot;&gt;倾城&lt;/a&gt;所收录的内容，以飨同好；欢迎推荐或自荐（仅限有独立域名的网站，可以是二级域名）。您如果要了解收录要求，请参见&lt;a href=&quot;https://nicelinks.site/about?utm_source=weekly&quot;&gt;关于倾城&lt;/a&gt;。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;备注&lt;/strong&gt;：本周刊&lt;strong&gt;每周五&lt;/strong&gt;生成，首发于个人微信公众号&lt;a href=&quot;https://mp.weixin.qq.com/mp/appmsgalbum?__biz=MzI5MDIwMzM2Mg==&amp;amp;action=getalbum&amp;amp;album_id=1530765143352082433&amp;amp;scene=173&amp;amp;from_msgid=2650641087&amp;amp;from_itemidx=1&amp;amp;count=3#wechat_redirect&quot;&gt;晚晴幽草轩&lt;/a&gt;、博客&lt;a href=&quot;https://www.jeffjade.com&quot;&gt;晚晴幽草轩&lt;/a&gt;，以及&lt;a href=&quot;https://forum.lovejade.cn/&quot;&gt;悠然宜想亭&lt;/a&gt;社区；此一键生成脚本基于 &lt;a href=&quot;https://nicelinks.site/post/602d30aad099ff5688618591&quot;&gt;Deno&lt;/a&gt; 编写，并在 Github 开源：&lt;a href=&quot;https://github.com/nicejade/nicelinks-weekly&quot;&gt;nicejade/nicelinks-weekly&lt;/a&gt;。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;标签&lt;/strong&gt;：&lt;a href=&quot;https://nicelinks.site/tags/%E6%A1%86%E6%9E%B6&quot;&gt;&lt;code&gt;框架&lt;/code&gt;&lt;/a&gt; · &lt;a href=&quot;https://nicelinks.site/tags/Web%E5%BC%80%E5%8F%91&quot;&gt;&lt;code&gt;Web开发&lt;/code&gt;&lt;/a&gt; · &lt;a href=&quot;https://nicelinks.site/tags/React&quot;&gt;&lt;code&gt;React&lt;/code&gt;&lt;/a&gt;&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;Blitz picks up where Next.js leaves off, providing battle-tested libraries and conventions for shipping and scaling world wide applications.&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;img src=&quot;https://oss.nicelinks.site/blitzjs.com.png?x-oss-process=style/png2jpg&quot; alt=&quot;倾城之链 - Blitz.js - The Missing Fullstack Toolkit for Next.js&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;推荐语&lt;/strong&gt;：&lt;a href=&quot;https://nicelinks.site/redirect?url=https://blitzjs.com/&quot;&gt;Blitz&lt;/a&gt; 是一个基于 &lt;a href=&quot;https://nicelinks.site/post/5b1294b5e93ed2618cfac134&quot;&gt;React&lt;/a&gt;、功能齐备，并提供一个能消除 REST/&lt;a href=&quot;https://nicelinks.site/tags/GraphQL&quot;&gt;GraphQL&lt;/a&gt; 依赖的零 API 数据抽象层的框架，受到了 Ruby on Rails 的启发。它接续了 Next.js 的不足，提供了经过实战检验的库和约定，用于交付和扩展全球应用程序。它具有如下功能特征：&lt;/p&gt;&lt;h3 id=&quot;全栈--一体化&quot;&gt;&lt;a href=&quot;#%E5%85%A8%E6%A0%88--%E4%B8%80%E4%BD%93%E5%8C%96&quot; aria-label=&quot;全栈  一体化 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; version=&quot;1.1&quot; viewbox=&quot;0 0 16 16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;/&gt;&lt;/svg&gt;&lt;/a&gt;全栈 &amp;amp; 一体化&lt;/h3&gt;&lt;p&gt;在一个单独的应用中包含了从数据库到前端的一切内容。只需在一处开发，只需在一处部署。并且你可以部署到一个服务器或 Serverless 上。&lt;/p&gt;&lt;h3 id=&quot;类型安全-api-层&quot;&gt;&lt;a href=&quot;#%E7%B1%BB%E5%9E%8B%E5%AE%89%E5%85%A8-api-%E5%B1%82&quot; aria-label=&quot;类型安全 api 层 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; version=&quot;1.1&quot; viewbox=&quot;0 0 16 16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;/&gt;&lt;/svg&gt;&lt;/a&gt;类型安全 API 层&lt;/h3&gt;&lt;p&gt;使用 Blitz RPC 构建和迭代功能比 REST、GraphQL 或普通 API 路由快 10 倍。以完全类型安全的方式从客户端读取和写入数据，而不会干扰 HTTP 或序列化。&lt;/p&gt;&lt;h3 id=&quot;宽松的限制&quot;&gt;&lt;a href=&quot;#%E5%AE%BD%E6%9D%BE%E7%9A%84%E9%99%90%E5%88%B6&quot; aria-label=&quot;宽松的限制 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; version=&quot;1.1&quot; viewbox=&quot;0 0 16 16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;/&gt;&lt;/svg&gt;&lt;/a&gt;宽松的限制&lt;/h3&gt;&lt;p&gt;开箱即用的体验将引导你走上适合大多数应用的完美路线。哪怕当你需要偏离常规路线时，你也可以完全自由地进行转换。同时几乎任何东西都是可插拔的。例如，我们不强制要求你使用哪种样式或表单库。&lt;/p&gt;&lt;h3 id=&quot;验证&quot;&gt;&lt;a href=&quot;#%E9%AA%8C%E8%AF%81&quot; aria-label=&quot;验证 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; version=&quot;1.1&quot; viewbox=&quot;0 0 16 16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;/&gt;&lt;/svg&gt;&lt;/a&gt;验证&lt;/h3&gt;&lt;p&gt;Next.js 的强大、灵活且经过实战测试的身份验证和授权。与替代方案相比，您可以通过更简单的 API 获得更多控制权。轻松添加社交第三方集成，例如 Google、Github 和 Auth0。&lt;/p&gt;&lt;h3 id=&quot;约定大于配置&quot;&gt;&lt;a href=&quot;#%E7%BA%A6%E5%AE%9A%E5%A4%A7%E4%BA%8E%E9%85%8D%E7%BD%AE&quot; aria-label=&quot;约定大于配置 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; version=&quot;1.1&quot; viewbox=&quot;0 0 16 16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;/&gt;&lt;/svg&gt;&lt;/a&gt;约定大于配置&lt;/h3&gt;&lt;p&gt;Blitz 为你处理了所有繁琐的设置和配置。通用的项目结构和架构模式可以让你轻松地从一个 Blitz 应用移动宾至如归地移动到另一个应用上。&lt;/p&gt;&lt;h3 id=&quot;易于开始便捷拓展&quot;&gt;&lt;a href=&quot;#%E6%98%93%E4%BA%8E%E5%BC%80%E5%A7%8B%E4%BE%BF%E6%8D%B7%E6%8B%93%E5%B1%95&quot; aria-label=&quot;易于开始便捷拓展 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; version=&quot;1.1&quot; viewbox=&quot;0 0 16 16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;/&gt;&lt;/svg&gt;&lt;/a&gt;易于开始，便捷拓展&lt;/h3&gt;&lt;p&gt;对初学者友好，也很容易将现有的 Next.js 应用程序迁移到 Blitz。易于以各种形式拓展：代码行数、在代码库中协同的人数以及执行代码。&lt;/p&gt;&lt;p&gt;除此之外，Blitz 还提供更多支持，涵盖数据库至前端；诸如后台架构、TypeScript 支持、周边生态（tailwind、chakra-ui）等；宣称是 ⚡️Next.js 缺失的全栈工具包。如果您对 Blitz 感兴趣，可移步至 &lt;a href=&quot;https://github.com/blitz-js/blitz&quot;&gt;blitz 开源仓库&lt;/a&gt; 以了解更多。&lt;/p&gt;&lt;p&gt;── 出自&lt;a href=&quot;https://nicelinks.site/post/63ad71fce524a8432ed24751&quot;&gt;倾城之链 - Blitz.js - The Missing Fullstack Toolkit for Next.js&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;标签&lt;/strong&gt;：&lt;a href=&quot;https://nicelinks.site/tags/%E6%9C%8D%E5%8A%A1&quot;&gt;&lt;code&gt;服务&lt;/code&gt;&lt;/a&gt; · &lt;a href=&quot;https://nicelinks.site/tags/Nginx&quot;&gt;&lt;code&gt;Nginx&lt;/code&gt;&lt;/a&gt; · &lt;a href=&quot;https://nicelinks.site/tags/%E5%BC%80%E6%BA%90&quot;&gt;&lt;code&gt;开源&lt;/code&gt;&lt;/a&gt;&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;Expose your services easily and securely&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;img src=&quot;https://oss.nicelinks.site/nginxproxymanager.com.png?x-oss-process=style/png2jpg&quot; alt=&quot;倾城之链 - Nginx Proxy Manager&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;推荐语&lt;/strong&gt;：&lt;a href=&quot;https://nicelinks.site/redirect?url=https://nginxproxymanager.com/&quot;&gt;Nginx Proxy Manager&lt;/a&gt; ，用于管理 Nginx 代理主机的 Docker 容器，具有简单、强大的界面，可轻松安全地公开您的服务。该项目作为预构建的 docker 镜像提供，使您能够轻松转发到您在家中或其他地方运行的网站，包括免费 SSL，而无需了解太多有关 Nginx 或 Letsencrypt 的信息。&lt;/p&gt;&lt;h3 id=&quot;取得联系&quot;&gt;&lt;a href=&quot;#%E5%8F%96%E5%BE%97%E8%81%94%E7%B3%BB&quot; aria-label=&quot;取得联系 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; version=&quot;1.1&quot; viewbox=&quot;0 0 16 16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;/&gt;&lt;/svg&gt;&lt;/a&gt;取得联系&lt;/h3&gt;&lt;p&gt;在您的网络上公开 Web 服务 · 使用 Let&#x27;s Encrypt 免费 SSL · 设计时考虑了安全性 · 非常适合家庭网络。&lt;/p&gt;&lt;h3 id=&quot;代理主机&quot;&gt;&lt;a href=&quot;#%E4%BB%A3%E7%90%86%E4%B8%BB%E6%9C%BA&quot; aria-label=&quot;代理主机 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; version=&quot;1.1&quot; viewbox=&quot;0 0 16 16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;/&gt;&lt;/svg&gt;&lt;/a&gt;代理主机&lt;/h3&gt;&lt;p&gt;公开您的专用网络 Web 服务并随时随地连接。&lt;/p&gt;&lt;h3 id=&quot;漂亮的用户界面&quot;&gt;&lt;a href=&quot;#%E6%BC%82%E4%BA%AE%E7%9A%84%E7%94%A8%E6%88%B7%E7%95%8C%E9%9D%A2&quot; aria-label=&quot;漂亮的用户界面 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; version=&quot;1.1&quot; viewbox=&quot;0 0 16 16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;/&gt;&lt;/svg&gt;&lt;/a&gt;漂亮的用户界面&lt;/h3&gt;&lt;p&gt;基于 Tabler，该界面使用起来很愉快。配置服务器从未如此有趣。&lt;/p&gt;&lt;h3 id=&quot;免费-ssl&quot;&gt;&lt;a href=&quot;#%E5%85%8D%E8%B4%B9-ssl&quot; aria-label=&quot;免费 ssl permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; version=&quot;1.1&quot; viewbox=&quot;0 0 16 16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;/&gt;&lt;/svg&gt;&lt;/a&gt;免费 SSL&lt;/h3&gt;&lt;p&gt;内置的 Let&#x27;s Encrypt 支持允许您免费保护您的 Web 服务。证书甚至可以自行更新！&lt;/p&gt;&lt;h3 id=&quot;码头工人-ftw&quot;&gt;&lt;a href=&quot;#%E7%A0%81%E5%A4%B4%E5%B7%A5%E4%BA%BA-ftw&quot; aria-label=&quot;码头工人 ftw permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; version=&quot;1.1&quot; viewbox=&quot;0 0 16 16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;/&gt;&lt;/svg&gt;&lt;/a&gt;码头工人 FTW&lt;/h3&gt;&lt;p&gt;作为 Docker 镜像构建，Nginx 代理管理器只需要一个数据库。&lt;/p&gt;&lt;h3 id=&quot;多个用户&quot;&gt;&lt;a href=&quot;#%E5%A4%9A%E4%B8%AA%E7%94%A8%E6%88%B7&quot; aria-label=&quot;多个用户 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; version=&quot;1.1&quot; viewbox=&quot;0 0 16 16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;/&gt;&lt;/svg&gt;&lt;/a&gt;多个用户&lt;/h3&gt;&lt;p&gt;配置其他用户查看或管理他们自己的主机。可以使用完全访问权限。&lt;/p&gt;&lt;p&gt;作者创建这个&lt;a href=&quot;https://github.com/NginxProxyManager/nginx-proxy-manager&quot;&gt;开源项目&lt;/a&gt;是为了满足其个人需要，为用户提供一种简单的方法来完成带有 SSL 终止的反向代理主机，而且它必须非常简单，以至于猴子都能做到。这个目标没有改变。虽然可能有高级选项，但它们是可选的，并且项目应该尽可能简单，以便进入这里的门槛很低。如果您有类似需求，可以考虑；其内置的 Let&#x27;s Encrypt 支持自动更新，相比使用其他家免费服务（定期 1 年更新一次），要方便许多。&lt;/p&gt;&lt;p&gt;── 出自&lt;a href=&quot;https://nicelinks.site/post/63ad6b6ce524a8432ed245f6&quot;&gt;倾城之链 - Nginx Proxy Manager&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;标签&lt;/strong&gt;：&lt;a href=&quot;https://nicelinks.site/tags/%E5%BD%95%E5%88%B6%E8%A7%86%E9%A2%91&quot;&gt;&lt;code&gt;录制视频&lt;/code&gt;&lt;/a&gt; · &lt;a href=&quot;https://nicelinks.site/tags/Mac&quot;&gt;&lt;code&gt;Mac&lt;/code&gt;&lt;/a&gt; · &lt;a href=&quot;https://nicelinks.site/tags/%E8%BD%AF%E4%BB%B6&quot;&gt;&lt;code&gt;软件&lt;/code&gt;&lt;/a&gt;&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;Screen Studio makes it easy to create beautiful, professional screen recordings. No video editing skills required.&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;img src=&quot;https://oss.nicelinks.site/www.screen.studio.png?x-oss-process=style/png2jpg&quot; alt=&quot;倾城之链 - Screen Studio — Beautiful screen recordings in minutes&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;推荐语&lt;/strong&gt;：&lt;a href=&quot;https://nicelinks.site/redirect?url=https://www.screen.studio/&quot;&gt;Screen Studio&lt;/a&gt; 一款屏幕录制软件，使创建漂亮、专业的屏幕录像变得容易，不需要视频编辑技能。它使您的鼠标移动流畅，&lt;strong&gt;点击时自动放大&lt;/strong&gt;，对所有动画应用电影运动模糊，并为您的录制添加漂亮的背景。在一分钟内，您的录音将成为高质量的宣传视频。更详细介绍，Screen Studio 具有如下功能特征：&lt;/p&gt;&lt;h3 id=&quot;流畅的光标移动&quot;&gt;&lt;a href=&quot;#%E6%B5%81%E7%95%85%E7%9A%84%E5%85%89%E6%A0%87%E7%A7%BB%E5%8A%A8&quot; aria-label=&quot;流畅的光标移动 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; version=&quot;1.1&quot; viewbox=&quot;0 0 16 16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;/&gt;&lt;/svg&gt;&lt;/a&gt;流畅的光标移动&lt;/h3&gt;&lt;p&gt;消除了鼠标光标的所有抖动，立即提供工作室品质的感觉。&lt;/p&gt;&lt;h3 id=&quot;缩放并跟随鼠标点击&quot;&gt;&lt;a href=&quot;#%E7%BC%A9%E6%94%BE%E5%B9%B6%E8%B7%9F%E9%9A%8F%E9%BC%A0%E6%A0%87%E7%82%B9%E5%87%BB&quot; aria-label=&quot;缩放并跟随鼠标点击 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; version=&quot;1.1&quot; viewbox=&quot;0 0 16 16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;/&gt;&lt;/svg&gt;&lt;/a&gt;缩放并跟随鼠标点击&lt;/h3&gt;&lt;p&gt;选择您想要关注鼠标操作的视频部分，Screen Studio 将创建所有动画。&lt;/p&gt;&lt;h3 id=&quot;电影运动模糊&quot;&gt;&lt;a href=&quot;#%E7%94%B5%E5%BD%B1%E8%BF%90%E5%8A%A8%E6%A8%A1%E7%B3%8A&quot; aria-label=&quot;电影运动模糊 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; version=&quot;1.1&quot; viewbox=&quot;0 0 16 16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;/&gt;&lt;/svg&gt;&lt;/a&gt;电影运动模糊&lt;/h3&gt;&lt;p&gt;动画的每个移动片段都将应用运动模糊，使视频感觉更流畅，感知到的 FPS 更高。&lt;/p&gt;&lt;h3 id=&quot;壁纸和窗框&quot;&gt;&lt;a href=&quot;#%E5%A3%81%E7%BA%B8%E5%92%8C%E7%AA%97%E6%A1%86&quot; aria-label=&quot;壁纸和窗框 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; version=&quot;1.1&quot; viewbox=&quot;0 0 16 16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;/&gt;&lt;/svg&gt;&lt;/a&gt;壁纸和窗框&lt;/h3&gt;&lt;p&gt;背景填充增加了视频的广度。发布到社交媒体时 - 视频会感觉不那么忙碌和嘈杂。&lt;/p&gt;&lt;h3 id=&quot;更改布局和光标&quot;&gt;&lt;a href=&quot;#%E6%9B%B4%E6%94%B9%E5%B8%83%E5%B1%80%E5%92%8C%E5%85%89%E6%A0%87&quot; aria-label=&quot;更改布局和光标 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; version=&quot;1.1&quot; viewbox=&quot;0 0 16 16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;/&gt;&lt;/svg&gt;&lt;/a&gt;更改布局和光标&lt;/h3&gt;&lt;p&gt;在 Mac 上录制 iPhone 模拟器并裁剪它 - 所有动画都会自动调整。更改光标，您的移动应用程序演示已准备就绪。&lt;/p&gt;&lt;h3 id=&quot;自动尺寸平衡&quot;&gt;&lt;a href=&quot;#%E8%87%AA%E5%8A%A8%E5%B0%BA%E5%AF%B8%E5%B9%B3%E8%A1%A1&quot; aria-label=&quot;自动尺寸平衡 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; version=&quot;1.1&quot; viewbox=&quot;0 0 16 16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;/&gt;&lt;/svg&gt;&lt;/a&gt;自动尺寸平衡&lt;/h3&gt;&lt;p&gt;只需单击一下，您就可以切换水平/垂直/方形输出大小，所有动画都将重新计算。它非常适合在 Instagram、TikTok 等平台上发布。&lt;/p&gt;&lt;h3 id=&quot;自拍相机支持&quot;&gt;&lt;a href=&quot;#%E8%87%AA%E6%8B%8D%E7%9B%B8%E6%9C%BA%E6%94%AF%E6%8C%81&quot; aria-label=&quot;自拍相机支持 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; version=&quot;1.1&quot; viewbox=&quot;0 0 16 16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;/&gt;&lt;/svg&gt;&lt;/a&gt;自拍相机支持&lt;/h3&gt;&lt;p&gt;录制您自己并在您和/或屏幕之间切换 - 使用惊人的动画。&lt;/p&gt;&lt;h3 id=&quot;全屏幻灯片和点击说明&quot;&gt;&lt;a href=&quot;#%E5%85%A8%E5%B1%8F%E5%B9%BB%E7%81%AF%E7%89%87%E5%92%8C%E7%82%B9%E5%87%BB%E8%AF%B4%E6%98%8E&quot; aria-label=&quot;全屏幻灯片和点击说明 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; version=&quot;1.1&quot; viewbox=&quot;0 0 16 16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;/&gt;&lt;/svg&gt;&lt;/a&gt;全屏幻灯片和点击说明&lt;/h3&gt;&lt;p&gt;添加介绍、停顿或点击标签来解释屏幕上发生的事情。&lt;/p&gt;&lt;p&gt;Screen Studio，专为 macOS 设计（作者并没有添加 Windows 支持的计划），高达 120 FPS 的视频、4K、无损质量。构建和设计快速、可靠且易于使用。如果您对它感兴趣，可以参见 &lt;a href=&quot;https://www.screen.studio/roadmap&quot;&gt;Screen Studio 路线图&lt;/a&gt;。&lt;/p&gt;&lt;p&gt;── 出自&lt;a href=&quot;https://nicelinks.site/post/63ac56b5e524a8432ed23fa4&quot;&gt;倾城之链 - Screen Studio — Beautiful screen recordings in minutes&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;标签&lt;/strong&gt;：&lt;a href=&quot;https://nicelinks.site/tags/%E8%B5%84%E6%BA%90&quot;&gt;&lt;code&gt;资源&lt;/code&gt;&lt;/a&gt; · &lt;a href=&quot;https://nicelinks.site/tags/%E7%9F%A5%E8%AF%86&quot;&gt;&lt;code&gt;知识&lt;/code&gt;&lt;/a&gt; · &lt;a href=&quot;https://nicelinks.site/tags/%E8%AF%BE%E7%A8%8B&quot;&gt;&lt;code&gt;课程&lt;/code&gt;&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;关键字&lt;/strong&gt;：知识麦田, 知识麦田资源库, 知识麦田库, UI 设计教程, 平面设计教程, 摄影教程, 三维设计教程, 交互设计教程, 产品经理学习, 职场提升, 技术教程, 职场技能, 电子资源, 编程开发, 赚钱致富, 运营策略, 创业, 沟通技巧&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;知识麦田旨在收集网络上最新最全的各类别课程资源，美好已经播种，等待你来收获。在这里，你期待的可能是对知识的收获，而我们期待的是你收获后喜悦满足的笑容。&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;img src=&quot;https://oss.nicelinks.site/zhishimt.com.png?x-oss-process=style/png2jpg&quot; alt=&quot;倾城之链 - 知识麦田-美好已经播种，等待你来收获&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;推荐语&lt;/strong&gt;：&lt;a href=&quot;https://nicelinks.site/redirect?url=https://zhishimt.com/&quot;&gt;知识麦田&lt;/a&gt;，基于 &lt;a href=&quot;https://nicelinks.site/post/602e4a576eaf2a7660805af1&quot;&gt;WordPress&lt;/a&gt;、&lt;a href=&quot;https://nicelinks.site/post/5b1a221c0526c920d6dfaada&quot;&gt;Vue.js&lt;/a&gt; 所搭建的网站，旨在收集网络上最新最全的各类别课程资源，不乏包括创意设计、影视与摄影、产品与运营、职场提升、编程开发、资源样机、设计插件等等。&lt;/p&gt;&lt;p&gt;── 出自&lt;a href=&quot;https://nicelinks.site/post/63ac430ae524a8432ed23d76&quot;&gt;倾城之链 - 知识麦田-美好已经播种，等待你来收获&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://nicelinks.site/theme/colligate&quot;&gt;综合&lt;/a&gt; &lt;a href=&quot;https://nicelinks.site/tags/%E6%96%B0%E9%97%BB&quot;&gt;新闻&lt;/a&gt;&lt;a href=&quot;https://nicelinks.site/tags/%E8%B5%84%E8%AE%AF&quot;&gt;资讯&lt;/a&gt;&lt;a href=&quot;https://nicelinks.site/tags/%E6%9F%A5%E8%AF%A2&quot;&gt;查询&lt;/a&gt;&lt;/p&gt;&lt;p&gt;有据是中国首个独立的事实核查计划，专注于核查中文世界的国际资讯。&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;https://oss.nicelinks.site/chinafactcheck.com.png?x-oss-process=style/png2jpg&quot; alt=&quot;有据 | 国际新闻事实核查 倾城之链&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;推荐语：&lt;/strong&gt;&lt;a href=&quot;https://nicelinks.site/redirect?url=https://chinafactcheck.com/&quot;&gt;有据 China Fact Check&lt;/a&gt; ，是中国首个独立的事实核查计划，专注于核查中文世界的国际资讯。该团队认为：一个崛起大国的国民，应有与之相匹配的世界观；而要形成理性、开放、包容的世界观，不能没有准确的国际新闻报道和国际资讯。&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://nicelinks.site/redirect?url=https://chinafactcheck.com/&quot;&gt;有据&lt;/a&gt; ，是基于志愿原则的网络协作计划，没有运作实体。有据与中国大学的新闻学院、外语学院的学生和老师建立合作，有志于从事新闻业或其他相关行业的学生在老师和媒体人指导下，进行有关事实核查的训练与实践。&lt;/p&gt;&lt;p&gt;与此同时，也有越来越多的来自其他领域的志愿者加入有据核查员行列。受过专业训练的媒体人组成质量审定委员会，对来自大学和社会的核查员进行指导和培训，对核查过程和结果进行质量监督。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;有据&lt;/strong&gt;，遵守国际事实核查网络（IFCN）的基本运作原则，即致力于公正性、透明度和准确性。他们不核查观点，只核查事实。您如果有意核查国际新闻事实， &lt;a href=&quot;https://nicelinks.site/redirect?url=https://chinafactcheck.com/&quot;&gt;有据&lt;/a&gt;  是非常值得关注的网站。详情可参见  &lt;a href=&quot;https://chinafactcheck.com/about-us/&quot;&gt;关于有据&lt;/a&gt; 。 ── 出自&lt;a href=&quot;https://nicelinks.site/post/63a42de0e524a8432ed21654&quot;&gt;倾城之链 | 有据 | 国际新闻事实核查&lt;/a&gt;。&lt;/p&gt;&lt;p&gt;对倾城之链感兴趣的朋友，可通过 Web，小程序，快应用等渠道进行访问(后续将支持更多，如 VsCode 插件，Chrome 扩展等)。您有任何问题，欢迎随时向我们反馈（您可以通过官网反馈渠道，或添加如下客服微信），🤲 。&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;https://image.nicelinks.site/%E5%80%BE%E5%9F%8E%E4%B9%8B%E9%93%BE-%E5%BE%AE%E4%BF%A1-mini.jpeg&quot; alt=&quot;倾城之链 - 客服微信&quot;/&gt;&lt;/p&gt;&lt;h2 id=&quot;本期文末寄语&quot;&gt;&lt;a href=&quot;#%E6%9C%AC%E6%9C%9F%E6%96%87%E6%9C%AB%E5%AF%84%E8%AF%AD&quot; aria-label=&quot;本期文末寄语 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; version=&quot;1.1&quot; viewbox=&quot;0 0 16 16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;/&gt;&lt;/svg&gt;&lt;/a&gt;本期文末寄语&lt;/h2&gt;&lt;p&gt;夫佳兵者，不祥之器。物或恶（wù）之，故有道者不处（chǔ）。君子居则贵左，用兵则贵右。兵者，不祥之器，非君子之器。不得已而用之，恬淡为上，胜而不美。而美之者，是乐(yào)杀人。夫乐(yào)杀人者，则不可以得志于天下矣。吉事尚左，凶事尚右。偏将军居左，上将军居右，言以丧（sāng）礼处之。杀人之众，以哀悲泣之，战胜，以丧礼处之。── 春秋末期人 · 老子李耳《道德经》第三十一章&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;&lt;a href=&quot;https://nicelinks.site/?utm_source=weekly&quot;&gt;倾城之链&lt;/a&gt;作为一个开放平台，旨在云集全球&lt;strong&gt;优秀网站&lt;/strong&gt;，探索互联网中更广阔的世界；在这里，你可以轻松发现、学习、分享更多有用或有趣的事物。&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;img src=&quot;https://image.nicelinks.site/nicelinks-miniprogram-code.jpeg?imageView2/1/w/250/h/250/interlace/1/ignore-error/1&quot; alt=&quot;小程序码 - 倾城之链&quot;/&gt;&lt;/p&gt;&lt;h2 id=&quot;您可能感兴趣的文章&quot;&gt;&lt;a href=&quot;#%E6%82%A8%E5%8F%AF%E8%83%BD%E6%84%9F%E5%85%B4%E8%B6%A3%E7%9A%84%E6%96%87%E7%AB%A0&quot; aria-label=&quot;您可能感兴趣的文章 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; version=&quot;1.1&quot; viewbox=&quot;0 0 16 16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;/&gt;&lt;/svg&gt;&lt;/a&gt;您可能感兴趣的文章&lt;/h2&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>d24c48adf2f12708174c7dc7a2151460</guid>
<title>cfox：面向以太坊开发者的 shell</title>
<link>https://toutiao.io/k/ub6clki</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content js_underline_content             autoTypeSetting24psection&amp;#10;            &quot; id=&quot;js_content&quot;&gt;&lt;section data-tool=&quot;markdown编辑器&quot; data-website=&quot;https://markdown.com.cn/editor&quot;&gt;&lt;p data-tool=&quot;markdown.com.cn编辑器&quot;&gt;注：请点击【原文链接】访问文中的 npm 或 github 链接。&lt;/p&gt;&lt;p data-tool=&quot;markdown.com.cn编辑器&quot;&gt;cfox 的第一个版本（npm 链接）终于在元旦前发布了！&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.46475195822454307&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Kh4dSb0w5FWaB3BgbcTK6hBWguywJKfB2a8NmxNA8NSKEW6c2POx6I2z21wf4MLIK6A8LN3jAFS8QCY5Bj08oA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;766&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;markdown.com.cn编辑器&quot;&gt;简单来讲，正如其 README（github 链接） 中所言，cfox （github 链接） 是一个面向以太坊开发者的 shell，提供了以太坊开发中一些可能会用到的命令集合，而且这个集合还在不断地增长。&lt;/p&gt;&lt;p data-tool=&quot;markdown.com.cn编辑器&quot;&gt;典型的特色命令：&lt;/p&gt;&lt;ul data-tool=&quot;markdown.com.cn编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;nonce&lt;/code&gt;，用来检查一个 wallet 是否被阻塞&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;cancel&lt;/code&gt; / &lt;code&gt;push&lt;/code&gt;，用来取消和加速被阻塞的 transaction&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;peek&lt;/code&gt;，用于查看合约的元数据&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;query&lt;/code&gt;，用于查询合约发出的任意事件&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;upload&lt;/code&gt;，用于将数据上传至 IPFS&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;markdown.com.cn编辑器&quot;&gt;关于如何上手使用，READM 已经写得比较清楚了，按蘭山师兄的说法：典型的中式表达，所以相信阅读起来应该不会有大的问题，这里就不再赘述。&lt;/p&gt;&lt;p data-tool=&quot;markdown.com.cn编辑器&quot;&gt;除了依赖 ethers，cfox 还用到了其他第三方的服务，如 morails 和 nft.storage，对于后者，代码覆盖了典型的使用场景：&lt;/p&gt;&lt;p data-tool=&quot;markdown.com.cn编辑器&quot;&gt;因此，除了作为 shell，cfox 代码本身从某种程度上也可以作为开发者常用库的 cookbook 来参考，目前主要就是：ethers 和 nft.storage。&lt;/p&gt;&lt;p data-tool=&quot;markdown.com.cn编辑器&quot;&gt;最后，如果您想提供支持或帮助，不妨考虑以下方式之一或全部 😄。&lt;/p&gt;&lt;ul data-tool=&quot;markdown.com.cn编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;加 ⭐️&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;转发&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;考虑购买 ethers 相关的微信付费文章：&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/section&gt;&lt;p&gt;&lt;mp-style-type data-value=&quot;3&quot;/&gt;&lt;/p&gt;&lt;/div&gt;

          
        &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>3f8846127b30d80b2aa858ce07da436a</guid>
<title>尤雨溪：回顾2022，展望2023</title>
<link>https://toutiao.io/k/crrg0zv</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content js_underline_content             autoTypeSetting24psection&amp;#10;            &quot; id=&quot;js_content&quot;&gt;&lt;section data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;mp-common-profile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mpprofile&quot; data-weui-theme=&quot;light&quot; data-id=&quot;MzIwNDMyMTg4Ng==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/wIDSOebZK4NvWoUN1gSpNiaxwF4VLvroSV4fibB1a5iaLEaR23sVIW9ickg4StvsXlxnPpslKAltA6mvJUhkT2PsaA/0?wx_fmt=png&quot; data-nickname=&quot;JavaScript 每日一练&quot; data-alias=&quot;&quot; data-signature=&quot;每天一道JavaScript 实战题，让大家平时多多积累实用的知识，提高开发效率，才有更多的时间摸鱼。&quot; data-from=&quot;0&quot; data-is_biz_ban=&quot;0&quot;/&gt;&lt;/section&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;祝大家新年快乐呀~&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;2023 年 1 月 1 日，尤雨溪发布博客 &lt;strong&gt;《2022 Year In Review》，&lt;/strong&gt; 文中回顾了 2022 年发生的事，并讨论了 2023 年的期望。下面就来看看详细内容吧！&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;回顾 2022 年&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;2022 年 2 月，Vue.js 团队将 Vue 的默认版本切换为 3.x。这标志着框架 v3 版本的所有官方部分都已经准备就绪，包括对提供最新最佳实践指南的文档进行了重大修改。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;现在仍处于生态系统迁移到 Vue 3 的过渡期。因此，在切换之后，Vue.js 团队更专注于通过投资工具来改善 Vue 开发人员的体验。团队成员一直积极参与 Vite 的开发，通过发布 Volar 1.0，对 Vue 的 IDE 和 TypeScript 支持进行了重大改进。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在 2022 年，Vue 3 的 NPM 使用率增长了近 200%。在社区方面，Vue 3 生态系统现在已经成熟，提供了有助于提高生产力的出色解决方案。Nuxt 3 和 Vuetify 3 均在 2022 年 11 月达到稳定状态，NativeScript for Vue 3 最近推出了测试版。此外，还有很多已经支持 Vue 3 相当长一段时间的伟大项目：Quasar、NaiveUI、Ionic Vue、PrimeVue、InkLine、Element Plus 等。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;尽管 Vue 3 现在是默认版本，但是由于迁移成本的原因，许多用户不得不继续使用 Vue 2。为了确保 Vue 2 用户从框架的进步中受益，Vue.js 团队决定将 Vue 2 的源代码迁移到 TypeScript，并在 Vue 2.7 中向后移植了一些重要的 Vue 3 功能。并且确保 Vite、Vue Devtools 和 Volar 都同时支持 Vue 2 和 Vue 3。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;展望 2023 年&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;更小和更频繁的次要版本&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;随着最后一个 Vue 2 次要版本 (2.7) 的发布，预计将在 2023 年全速推出 Vue 3 核心的功能。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Vue.js 想要改进的一件事就是发布节奏。Vue 遵循 semver，这意味着应该只发布次要版本的功能。过去，采用了“大次要”的方法，将许多功能组合在一个大的、不频繁发布的次要版本中。这导致在处理其他高复杂性功能时，相当多的低复杂性功能被阻碍。&lt;strong&gt;在 2023 年，希望发布更小、更频繁的次要版本，以便能够更快地推出更多功能。&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这也意味着将调整 v3.3 中的内容。原本计划在 v3.3 中将 Suspense 和 Reactivity Transform 从实验状态结束。但是，Vue.js 团队认为两者仍需要进一步的 RFC 讨论，并且它们不应阻碍其他更直接的功能落地。现在，v3.3 的目标是实现明确且不需要 RFC 讨论的提议/计划功能。例如，支持 &lt;code&gt;&amp;lt;script setup&amp;gt;&lt;/code&gt; 宏中的外部导入类型。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;与此同时，Vue.js 团队将：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;进一步评估 Suspense 和 Reactivity Transform 的准备情况；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;评估未完成的用户提交的 RFC 和功能请求；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;发布计划在 3.4 及更高版本中实现的功能的 RFC，例如 SSR 懒惰水合。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;另一件需要注意的事情是，在可预见的未来，没有重大突破性变化的计划。意识到用户在 v2 到 v3 过渡期间面临的挑战，希望 Vue 有一个更好的长期升级过程。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;Vapor Mode&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Vapor Mode 是一直在试验的另一种编译策略，其灵感来自于 Solid。给定相同的 Vue SFC，与当前基于虚拟 DOM 的输出相比，Vapor Mode 将其编译成性能更高、使用更少内存且需要更少运行时支持代码的 JavaScript 输出。它仍处于早期阶段，这里有一些相关的要点：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;Vapor Mode 适用于主要关注性能的用例。它是可选的，不会影响现有的代码库。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;开发者将能够将 Vapor 组件子树嵌入到任何现有的 Vue 3 应用中。在理想情况下，希望可以在组件级别实现粒度选择，这意味着可以在同一个应用中自由混合 Vapor 组件和非 Vapor 组件。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;仅使用 Vapor 组件构建应用允许从 bundle 中删除虚拟 DOM 运行时，从而显著减少 baseline 运行时大小。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;为了获得最佳性能，Vapor Mode 将仅支持 Vue 功能的一个子集。特别是，Vapor Mode 组件将仅支持 Composition API 和 &lt;code&gt;&amp;lt;script setup&amp;gt;&lt;/code&gt;。但是，这个受支持的子集在 Vapor 和非 Vapor 组件之间的工作方式完全相同。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;会议&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;2023 年将有许多&lt;strong&gt;面对面&lt;/strong&gt;的 Vue 会议：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;Vue.js Amsterdam：2 月 9 日至 10 日，荷兰阿姆斯特丹；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Vue.js Live：5 月 12 日至 15 日，英国伦敦；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;VueConf US：5 月 24 日至 26 日，美国新奥尔良；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;VueFes Japan：10 月 28 日，日本东京。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;尤雨溪计划亲自参与所有这些活动，在缺席三年之后，迫不及待想要再次见到社区！&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;距 Vue 2 结束支持剩余一年&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;今天距离 Vue 2 结束支持恰好剩余一年。Vue.js 团队创建了一个页面来解释这一点的含义，并概述了那些希望在结束支持日期之后使用 Vue 2 的开发者的选项：&lt;span&gt;Vue 2 结束支持和扩展支持的详细信息。&lt;/span&gt;&lt;sup&gt;[1]&lt;/sup&gt;&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;&lt;strong&gt;原文：&lt;/strong&gt; https://blog.vuejs.org/posts/2022-year-in-review.html&lt;/p&gt;&lt;/blockquote&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;strong/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/h3&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;span&gt;欢迎&lt;/span&gt;&lt;code&gt;长按图片加刷碗智为好友，定时分享 Vue React Ts 等。&lt;/code&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-cropselx1=&quot;68&quot; data-cropselx2=&quot;361&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;385&quot; data-fileid=&quot;100021057&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.8948194662480377&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/LDPLltmNy55d6jntYlvCrOVACPvqJkZuaOwJiaecIvQdzSq8lLVBibrGRZPxlWKvV7sGqC3CtOjZ1QxHu56tWZwg/640?wx_fmt=png&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; data-type=&quot;png&quot; data-w=&quot;637&quot;/&gt;&lt;span/&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;最后：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;a target=&quot;_blank&quot; href=&quot;https://mp.weixin.qq.com/mp/appmsgalbum?action=getalbum&amp;amp;__biz=MzI0NDQ0ODU3MA==&amp;amp;scene=1&amp;amp;album_id=2509459125236416515&amp;amp;count=3#wechat_redirect&quot; textvalue=&quot;vue2与vue3技巧合集&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;vue2与vue3技巧合集&lt;/a&gt;&lt;/section&gt;&lt;p&gt;&lt;mp-style-type data-value=&quot;3&quot;/&gt;&lt;/p&gt;&lt;/div&gt;

          
        &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>