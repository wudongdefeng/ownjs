<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>9de39cc2de785cf4bc3c499df51ab237</guid>
<title>专项测试系列：缓存击穿、穿透、雪崩专项测试</title>
<link>https://toutiao.io/k/lv6coxq</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;preview&quot;&gt;&lt;p&gt;&lt;strong&gt;作者：刘须华&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;一、背景概述：&lt;/strong&gt;  R2M 缓存的使用，极大的提升了应用程序的性能和效率，特别是数据查询方面。而缓存最常见的问题是缓存穿透、击穿和雪崩，在高并发下这三种情况都会有大量请求落到数据库，导致数据库资源占满，引起数据库故障。平时对缓存测试时除了关注增删修改查询等基本功能，应该要重点关注缓存穿透、击穿和雪崩三种异常场景的测试覆盖，避免出现线上事故。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;二、基本概念说明&lt;/strong&gt;：&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;1、缓存击穿：&lt;/strong&gt; 是指在超级热点数据突然过期，导致针对超级热点的数据请求在过期期间直接打到数据库，这样数据库服务器会因为某一超热数据导致压力过大而崩掉。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8cd1980c4d9d48f09061f07305db8794%7Etplv-k3u1fbpfcp-zoom-1.image&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;﻿﻿&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;2、缓存穿透：&lt;/strong&gt; 是指查找的数据在缓存和数据库中都不存在，导致每一次请求数据从缓存中都获取不到，而将请求打到数据库服务器，但数据库中也没有对应的数据，最后每一次请求都到数据库；如果在高并发场景或有人恶意攻击，就会导致后台数据库服务器压力增大，最终系统可能崩掉。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f6e40c13bb354616b220f35a978f0fc0%7Etplv-k3u1fbpfcp-zoom-1.image&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;﻿﻿&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;3、缓存雪崩：&lt;/strong&gt; 是指突然缓存层不可用，导致大量请求直接打到数据库，最终由于数据库压力过大可能导致系统崩掉。缓存层不可用指以下两方面：缓存服务器宕机，系统将请求打到数据库； 缓存数据突然大范围集中过期失效，导致大量请求打到数据库重新加载数据，与缓存击穿的区别在于这里针对很多 key 缓存，前者则是某一个 key。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/46d0cb4e411e4a90b08d2a1a1f55a110%7Etplv-k3u1fbpfcp-zoom-1.image&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;﻿﻿&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;三、测试工具 (非必须)&lt;/strong&gt; ：&lt;/p&gt;

&lt;p&gt;1、使用 Titan 压测平台进行并发请求测试&lt;/p&gt;

&lt;p&gt;2、使用 jmeter 工具模拟并发请求&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;四、测试方法举例说明 (非必须)&lt;/strong&gt; ：&lt;/p&gt;

&lt;p&gt;环境：测试环境&lt;/p&gt;

&lt;p&gt;工具：jmeter&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;（1）缓存穿透场景&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;测试方法：查询一个根本不存在的数据，缓存层和存储层都不会命中。&lt;/p&gt;

&lt;p&gt;查询接口相关代码实现：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2d82a57ec72e4b1d96ac0c2badd4e972%7Etplv-k3u1fbpfcp-zoom-1.image&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;﻿﻿&lt;/p&gt;

&lt;p&gt;通过 JMETER 模拟多次重复调用：单线程重复调用&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ea519ff2769a4d2bbbeae05bd64558d7%7Etplv-k3u1fbpfcp-zoom-1.image&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;﻿﻿&lt;/p&gt;

&lt;p&gt;查看日志结果：从日志可以看出：执行并发请求后， 所有请求每次都走向了数据库。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d3cc033bc50b42d0abe7436924b3e728%7Etplv-k3u1fbpfcp-zoom-1.image&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;﻿﻿&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;预防方案：&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;当数据库查询为空时，将缓存赋值默认值，后续查询都走缓存，减少数据库压力。&lt;/p&gt;

&lt;p&gt;上述接口，增加赋值为 empty，则第一次查询到数据库为空，后续查询都查询到缓存中，缓存值为 empty。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7b9dadd0fb57484cae321a83d50c7927%7Etplv-k3u1fbpfcp-zoom-1.image&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;﻿﻿&lt;/p&gt;

&lt;p&gt;再次执行并发测试：从日志可以看出，可以看出每个 ID 都只执行了一次数据库查询并设置缓存，之后请求都命中了缓存，有效防止了缓存穿透问题。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/84e0ccd477364b1bb057da5b7862f528%7Etplv-k3u1fbpfcp-zoom-1.image&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;﻿﻿&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;（2）缓存击穿场景&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;测试方法：对某个 Key 有大量的并发请求，这时从缓存中删除这个 key。模拟热 key 过期失效的场景。这个时候大并发的请求可能会瞬间把后端 DB 压垮。&lt;/p&gt;

&lt;p&gt;接口相关部分代码实现：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f0e84217b23749c2be4c617e240ec2ee%7Etplv-k3u1fbpfcp-zoom-1.image&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;﻿﻿&lt;/p&gt;

&lt;p&gt;操作步骤：&lt;/p&gt;

&lt;p&gt;1、查询 pin 为 liuxuhua 的请求，这时 pin 为 liuxuhua 的数据会加载到缓存&lt;/p&gt;

&lt;p&gt;2、再次查询 pin 为 liuxuhua 的请求，命中缓存&lt;/p&gt;

&lt;p&gt;3、50 并发请求 pin 为 liuxuhua 的数据，这个时候请求全部命中缓存&lt;/p&gt;

&lt;p&gt;4、将 pin 为 liuxuhua 的缓存手动删除，模拟缓存失效&lt;/p&gt;

&lt;p&gt;5、50 并发请求 pin 为 liuxuhua 的数据，这个时候大量请求走向数据库，pin 为 liuxuhua 的缓存被击穿&lt;/p&gt;

&lt;p&gt; &lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c7ee1ad20ec249f59feae2a27924430a%7Etplv-k3u1fbpfcp-zoom-1.image&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;﻿﻿﻿&lt;/p&gt;

&lt;p&gt;查看日志结果:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/cfd820a9376f43c6ada175234a3c7edc%7Etplv-k3u1fbpfcp-zoom-1.image&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;﻿﻿&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;预防方案：&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;在设置默认缓存值的基础上，进行加锁处理。只有拿到锁的第一个线程去请求数据库，然后插入缓存，当然每次拿到锁的时候都要去查询一下缓存有没有。﻿&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/35ee6edde2f549f989cf17c052568546%7Etplv-k3u1fbpfcp-zoom-1.image&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;﻿﻿&lt;/p&gt;

&lt;p&gt;从日志记录可以看到只有一个请求执行了数据库查询并设置缓存，其他请求都命中了缓存， 有效防止了缓存的击穿。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/934dc8c583804db5ab51f4f597ef9e5c%7Etplv-k3u1fbpfcp-zoom-1.image&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;﻿﻿&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;（3）缓存雪崩&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;测试方法：对多个使用到缓存的接口进行并发调用，设置这些缓存时间已过期（即删除缓存），调用时这些接口查询缓存时无数据，去查询数据库，这些请求都指向数据库，数据库压力增大，耗时增加。&lt;/p&gt;

&lt;p&gt;模拟接口：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fde4a68daf544edd8be29d78ef578bd0%7Etplv-k3u1fbpfcp-zoom-1.image&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;﻿﻿&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a865db6d42ac42959fc469a0f41430d1%7Etplv-k3u1fbpfcp-zoom-1.image&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;﻿﻿&lt;/p&gt;

&lt;p&gt;通过 JMETER 模拟多次重复调用：单线程多接口重复调用&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5e0648d58c874a40b3169bf819c20bf8%7Etplv-k3u1fbpfcp-zoom-1.image&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;﻿﻿&lt;/p&gt;

&lt;p&gt;查看日志结果：可以看出大量请求到达数据库，并且同一个 pin 或 id 执行了多次数据库查询&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/36260e1239e7491a82f731c180349993%7Etplv-k3u1fbpfcp-zoom-1.image&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;﻿﻿&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;预防方案：&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;增加限流操作，即接口频繁调用时，增加一个缓存，设置时间为 3s，3s 内处理一定次数的请求，超过限制次数的请求直接返回结果，不做处理。&lt;/p&gt;

&lt;p&gt;接口：3s 内处理 6 次请求，超过则不处理；&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/71305d673cf14ff6b763d923fae45804%7Etplv-k3u1fbpfcp-zoom-1.image&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;﻿﻿&lt;/p&gt;

&lt;p&gt;从日志可以看出：可以看到每个都只查询了一次数据库并设置缓存，之后的请求都命中了缓存&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d57b5b0564a444bf8c5a77cb3b56fd6d%7Etplv-k3u1fbpfcp-zoom-1.image&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;﻿﻿﻿&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;五、测试指标&lt;/strong&gt;：(或者叫通过标准，包括关注点以及意义)&lt;/p&gt;

&lt;p&gt;1、模拟缓存穿透场景测试，每个不存在的数据都只执行了一次数据库查询并设置缓存，之后请求都命中了缓存，有效防止了缓存穿透问题。&lt;/p&gt;

&lt;p&gt;2、模拟缓存雪崩场景测试，每个缓存失效的数据都只执行了一次数据库查询并设置缓存，之后请求都命中了缓存。&lt;/p&gt;

&lt;p&gt;3、模拟缓存击穿场景测试，缓存失效的那个数据只有一个请求执行了数据库查询并设置缓存，其他请求都命中了缓存。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;六、适用业务场景：&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;1、秒杀活动&lt;/p&gt;

&lt;p&gt;2、热门营销活动&lt;/p&gt;

&lt;p&gt;3、618 和双 11 大促&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;七、研发侧常见解决方案（参考）：&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;1、缓存穿透解决方案：&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;1、缓存空值 之所以发生穿透，是因为缓存中没有存储这些数据的 key，从而每次都查询数据库 我们可以为这些 key 在缓存中设置对应的值为 null，后面查询这个 key 的时候就不用查询数据库了 当然为了健壮性，我们要对这些 key 设置过期时间，以防止真的有数据&lt;/p&gt;

&lt;p&gt;2、BloomFilter BloomFilter 类似于一个 hbase set 用来判断某个元素（key）是否存在于某个集合中 我们把有数据的 key 都放到 BloomFilter 中，每次查询的时候都先去 BloomFilter 判断，如果没有就直接返回 null 注意 BloomFilter 没有删除操作，对于删除的 key，查询就会经过 BloomFilter 然后查询缓存再查询数据库，所以 BloomFilter 可以结合缓存空值用，对于删除的 key，可以在缓存中缓存 null 缓存击穿&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;2、缓存击穿解决方案：&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;采用分布式锁，只有拿到锁的第一个线程去请求数据库，然后插入缓存，当然每次拿到锁的时候都要去查询一下缓存有没有&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;3、缓存雪崩解决方案：&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;1、采用集群，降低服务宕机的概率&lt;/p&gt;

&lt;p&gt;2、ehcache 本地缓存 + 限流 &amp;amp; 降级&lt;/p&gt;

&lt;p&gt;3、均匀过期，通常可以为有效期增加随机值&lt;/p&gt;
&lt;/div&gt;
  &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>083ccdee35e90742c3372b81df6e9062</guid>
<title>万字长文细说 Code Review 的正确姿势</title>
<link>https://toutiao.io/k/cxf9ver</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content js_underline_content             autoTypeSetting24psection&amp;#10;            &quot; id=&quot;js_content&quot;&gt;&lt;section class=&quot;mp_profile_iframe_wrp&quot; data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;mp-common-profile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mpprofile&quot; data-id=&quot;MzA3MDg5MDkzOA==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/Z2bVaFK6CgQmUQ0Aca9qSYNFn0tQEXQc5EibBkqQLYtibYBj1hXuagwXkNc3kVwplHxIl7KQfBIiagysgn9GDUUibw/0?wx_fmt=png&quot; data-nickname=&quot;架构精进之路&quot; data-alias=&quot;jiagou_jingjin&quot; data-signature=&quot;十年研发风雨路，大厂架构师，CSDN博客专家，InfoQ写作社区签约作者。专注软件架构研究，技术学习与职业成长，坚持分享接地气儿的架构技术干货文章！&quot; data-from=&quot;0&quot; data-is_biz_ban=&quot;0&quot;/&gt;&lt;/section&gt;&lt;h3 data-pm-slice=&quot;1 1 []&quot;&gt;&lt;span&gt;hello，大家好，我是张张，「架构精进之路」公号作者。&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;随着研发团队规模的逐步扩大，新项目及新成员越来越多，如何做好 code review，把控研发人员的代码质量很是关键。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;相信大部分团队，谈到 code review 时候就会面漏哀状：&lt;/span&gt;&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;&lt;em&gt;“上线时间倒排，研发工期这么紧，连码代码的时间都不够了，你还要我CR？”&lt;/em&gt;&lt;/p&gt;&lt;p&gt;&lt;em&gt;“上版的需求，这版就变了，代码生命周期太短，烂就烂吧，反正能用就行啦”&lt;/em&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;本文是我在腾讯工作时结识的一位朋友，也是我为代码委员会 Golang 分会首批选中的理事。他这个人呀，讨论问题，总是喜欢追根问底，考古论今～ :D&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;span&gt;他在2020年写下的一篇关于 Code Review 的长篇文章。本文&lt;/span&gt;&lt;span&gt;的特点是：一看就是仍旧奋战在一线的工程师写的，不但给出了一些真实代码的示例，还将他对代码的想法与思路写了出来。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;希望能给大家的工作带来一些借鉴和思考~&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.6082121471343028&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/Z2bVaFK6CgSMHICGib2SwuGF8IT83WLr6vGNOYMz3JI0icNdSWicdCdqJ04j0vM2rSvh6lRmTJxjavZVQlxsJZDHQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1169&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;前言&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;作为公司代码委员会 golang 分会的理事，我 review 了很多代码，看了很多别人的 review 评论。发现不少同学 code review 与写出好代码的水平有待提高。在这里，想分享一下我的一些理念和思路。 &lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;为什么技术人员包括 leader 都要做 code review&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt; &#x27;Talk Is Cheap, Show Me The Code&#x27;。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;知易行难，知行合一更难。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;嘴里要讲出来总是轻松，把别人讲过的话记住，组织一下语言，再讲出来，很容易。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;绝知此事要躬行。设计理念你可能道听途说了一些，以为自己掌握了，但是你会做么？有能力去思考、改进自己当前的实践方式和实践中的代码细节么？不客气地说，很多人仅仅是知道并且认同了某个设计理念，进而产生了一种虚假的安心感---自己的技术并不差。但是，他根本没有去实践这些设计理念，甚至根本实践不了这些设计理念，从结果来说，他懂不懂这些道理/理念，有什么差别？变成了自欺欺人。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;span&gt;代码，是设计理念落地的地方，是技术的呈现和根本。&lt;/span&gt;&lt;span&gt;同学们可以在 review 过程中做到落地沟通，不再是空对空的讨论，可以在实际问题中产生思考的碰撞，互相学习，大家都掌握团队里积累出来最好的实践方式！&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;span&gt;当然，如果 leader 没时间写代码，仅仅是 review 代码，指出其他同学某些实践方式不好，&lt;/span&gt;&lt;span&gt;要给出好的实践的意见&lt;/span&gt;&lt;span&gt;，即使没亲手写代码，也是对最佳实践要有很多思考。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;为什么同学们要在 review 中思考和总结最佳实践&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;span&gt;我这里先给一个我自己的总结：&lt;/span&gt;&lt;span&gt;所谓架构师，就是掌握大量设计理念和原则、落地到各种语言及附带工具链（生态）下的实践方法、垂直行业模型理解，定制系统模型设计和工程实践规范细则。进而控制 30+万行代码项目的开发便利性、可维护性、可测试性、运营质量&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;厉害的技术人，主要可以分为下面几个方向：&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;掌握很多技巧，以及发现技巧一系列思路，比如很多编程大赛，比的就是这个。但是，这个对工程，用处好像并不是很大。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;比如约翰*卡马克，他创造出了现代计算机图形高效渲染的方法论。不论如果没有他，后面会不会有人发明，他就是第一个发明了。1999 年，卡马克登上了美国时代杂志评选出来的科技领域 50 大影响力人物榜单，并且名列第 10 位。但是，类似的殿堂级位置，没有几个，不够大家分，没我们的事儿。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;八十年代李开复博士坚持采用隐含马尔可夫模型的框架，成功地开发了世界上第一个大词汇量连续语音识别系统 Sphinx。我辈工程师，好像擅长这个的很少。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;小龙哥（注：微信缔造者 张小龙）是标杆。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;这个是大家都可以做到，按照上面架构师的定义。在这条路上走得好，就能为任何公司组建技术团队，组织建设高质量的系统。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;从上面的讨论中，可以看出，我们普通工程师的进化之路，就是不断打磨最佳实践方法论、落地细节。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;代码变坏的根源&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;在讨论什么代码是好代码之前，我们先讨论什么是不好的。计算机是人造的学科，我们自己制造了很多问题，进而去思考解法。&lt;/span&gt;&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;重复的代码&lt;/span&gt;&lt;/h4&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;// BatchGetQQTinyWithAdmin 获取QQ uin的tinyID, 需要主uin的tiny和登录态&lt;/span&gt;&lt;br/&gt;&lt;span&gt;// friendUins 可以是空列表, 只要admin uin的tiny&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;BatchGetQQTinyWithAdmin&lt;/span&gt;&lt;span&gt;(ctx context.Context, adminUin &lt;span&gt;uint64&lt;/span&gt;, friendUin []&lt;span&gt;uint64&lt;/span&gt;)&lt;/span&gt; &lt;span&gt;(&lt;br/&gt; adminTiny &lt;span&gt;uint64&lt;/span&gt;, sig []&lt;span&gt;byte&lt;/span&gt;, frdTiny &lt;span&gt;map&lt;/span&gt;[&lt;span&gt;uint64&lt;/span&gt;]&lt;span&gt;uint64&lt;/span&gt;, err error)&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; &lt;span&gt;var&lt;/span&gt; friendAccountList []*basedef.AccountInfo&lt;br/&gt; &lt;span&gt;for&lt;/span&gt; _, v := &lt;span&gt;range&lt;/span&gt; friendUin {&lt;br/&gt;  friendAccountList = &lt;span&gt;append&lt;/span&gt;(friendAccountList, &amp;amp;basedef.AccountInfo{&lt;br/&gt;   AccountType: proto.String(def.StrQQU),&lt;br/&gt;   Userid:      proto.String(fmt.Sprint(v)),&lt;br/&gt;  })&lt;br/&gt; }&lt;br/&gt;&lt;br/&gt; req := &amp;amp;cmd0xb91.ReqBody{&lt;br/&gt;  Appid:       proto.Uint32(model.DocAppID),&lt;br/&gt;  CheckMethod: proto.String(CheckQQ),&lt;br/&gt;  AdminAccount: &amp;amp;basedef.AccountInfo{&lt;br/&gt;   AccountType: proto.String(def.StrQQU),&lt;br/&gt;   Userid:      proto.String(fmt.Sprint(adminUin)),&lt;br/&gt;  },&lt;br/&gt;  FriendAccountList: friendAccountList,&lt;br/&gt; }&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;因为最开始协议设计得不好，第一个使用接口的人，没有类似上面这个函数的代码，自己实现了一个嵌入逻辑代码的填写请求结构结构体的代码。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;span&gt;一开始，挺好的。但当有第二个人，第三个人干了类似的事情，我们将无法再重构这个协议，必须做到麻烦的向前兼容。&lt;/span&gt;&lt;span&gt;而且每个同学，都要理解一遍上面这个协议怎么填，理解有问题，就触发 bug。或者，如果某个错误的理解，普遍存在，我们就得找到所有这些重复的片段，都修改一遍。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;当你要读一个数据，发现两个地方有，不知道该选择哪个。当你要实现一个功能，发现两个 rpc 接口、两个函数能做到，你不知道选哪一个。你有面临过这样的&#x27;人生难题&#x27;么？其实怎么选并不重要了，你写的这个代码已经在走向 shit 的道路上迈出了坚实的一步。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;但是，&lt;/span&gt;&lt;span&gt;A little copying is better than a little dependency&lt;/span&gt;&lt;span&gt;。这里提一嘴，不展开。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;这里，我必须额外说一句。大家使用 trpc。感觉自己被鼓励&#x27;每个服务搞一个 git&#x27;。那，你这个服务里访问 db 的代码，rpc 的代码，各种可以复用的代码，是用的大家都复用的 git 下的代码么？每次都重复写一遍，db 字段细节改了，每个使用过 db 的 server 对应的 git 都改一遍？这个通用 git 已经写好的接口应该不知道哪些 git 下的代码因为自己不向前兼容的修改而永远放弃了向前不兼容的修改？&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;早期有效的决策不再有效&lt;/span&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;很多时候，我们第一版代码写出来，是没有太大的问题的。比如，下面这个代码&lt;/span&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;// Update 增量更新&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;(s *FilePrivilegeStore)&lt;/span&gt; &lt;span&gt;Update&lt;/span&gt;&lt;span&gt;(key def.PrivilegeKey,&lt;br/&gt; clear, isMerge &lt;span&gt;bool&lt;/span&gt;, subtract []*access.AccessInfo, increment []*access.AccessInfo,&lt;br/&gt; policy *&lt;span&gt;uint32&lt;/span&gt;, adv *access.AdvPolicy, shareKey &lt;span&gt;string&lt;/span&gt;, importQQGroupID &lt;span&gt;uint64&lt;/span&gt;)&lt;/span&gt; &lt;span&gt;error&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; &lt;span&gt;// 获取之前的数据&lt;/span&gt;&lt;br/&gt; info, err := s.Get(key)&lt;br/&gt; &lt;span&gt;if&lt;/span&gt; err != &lt;span&gt;nil&lt;/span&gt; {&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; err&lt;br/&gt; }&lt;br/&gt;&lt;br/&gt; incOnlyModify := update(info, &amp;amp;key, clear, subtract,&lt;br/&gt;  increment, policy, adv, shareKey, importQQGroupID)&lt;br/&gt; stat := statAndUpdateAccessInfo(info)&lt;br/&gt; &lt;span&gt;if&lt;/span&gt; !incOnlyModify {&lt;br/&gt;  &lt;span&gt;if&lt;/span&gt; stat.groupNumber &amp;gt; model.FilePrivilegeGroupMax {&lt;br/&gt;   &lt;span&gt;return&lt;/span&gt; errors.Errorf(errors.PrivilegeGroupLimit,&lt;br/&gt;    &lt;span&gt;&quot;group num %d larger than limit %d&quot;&lt;/span&gt;,&lt;br/&gt;    stat.groupNumber, model.FilePrivilegeGroupMax)&lt;br/&gt;  }&lt;br/&gt; }&lt;br/&gt;&lt;br/&gt; &lt;span&gt;if&lt;/span&gt; !isMerge {&lt;br/&gt;  &lt;span&gt;if&lt;/span&gt; key.DomainID == &lt;span&gt;uint64&lt;/span&gt;(access.SPECIAL_FOLDER_DOMAIN_ID) &amp;amp;&amp;amp;&lt;br/&gt;   &lt;span&gt;len&lt;/span&gt;(info.AccessInfos) &amp;gt; model.FilePrivilegeMaxFolderNum {&lt;br/&gt;   &lt;span&gt;return&lt;/span&gt; errors.Errorf(errors.PrivilegeFolderLimit,&lt;br/&gt;    &lt;span&gt;&quot;folder owner num %d larger than limit %d&quot;&lt;/span&gt;,&lt;br/&gt;    &lt;span&gt;len&lt;/span&gt;(info.AccessInfos), model.FilePrivilegeMaxFolderNum)&lt;br/&gt;  }&lt;br/&gt;  &lt;span&gt;if&lt;/span&gt; &lt;span&gt;len&lt;/span&gt;(info.AccessInfos) &amp;gt; model.FilePrivilegeMaxNum {&lt;br/&gt;   &lt;span&gt;return&lt;/span&gt; errors.Errorf(errors.PrivilegeUserLimit,&lt;br/&gt;    &lt;span&gt;&quot;file owner num %d larger than limit %d&quot;&lt;/span&gt;,&lt;br/&gt;    &lt;span&gt;len&lt;/span&gt;(info.AccessInfos), model.FilePrivilegeMaxNum)&lt;br/&gt;  }&lt;br/&gt; }&lt;br/&gt;&lt;br/&gt; pbDataSt := infoToData(info, &amp;amp;key)&lt;br/&gt; &lt;span&gt;var&lt;/span&gt; updateBuf []&lt;span&gt;byte&lt;/span&gt;&lt;br/&gt; &lt;span&gt;if&lt;/span&gt; updateBuf, err = proto.Marshal(pbDataSt); err != &lt;span&gt;nil&lt;/span&gt; {&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; errors.Wrapf(err, errors.MarshalPBError,&lt;br/&gt;   &lt;span&gt;&quot;FilePrivilegeStore.Update Marshal data error, key[%v]&quot;&lt;/span&gt;, key)&lt;br/&gt; }&lt;br/&gt; &lt;span&gt;if&lt;/span&gt; err = s.setCKV(generateKey(&amp;amp;key), updateBuf); err != &lt;span&gt;nil&lt;/span&gt; {&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; errors.Wrapf(err, errors.Code(err),&lt;br/&gt;   &lt;span&gt;&quot;FilePrivilegeStore.Update setCKV error, key[%v]&quot;&lt;/span&gt;, key)&lt;br/&gt; }&lt;br/&gt; &lt;span&gt;return&lt;/span&gt; &lt;span&gt;nil&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;span&gt;现在看，这个代码挺好的，长度没超过 80 行，逻辑比价清晰。但是当 isMerge 这里判断逻辑，&lt;/span&gt;&lt;span&gt;如果加入更多的逻辑，把局部行数撑到 50 行以上，这个函数，味道就坏了。出现两个问题：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;1）函数内代码不在一个逻辑层次上，阅读代码，本来在阅读着顶层逻辑，突然就掉入了长达 50 行的 isMerge 的逻辑处理细节，还没看完，读者已经忘了前面的代码讲了什么，需要来回看，挑战自己大脑的 cache 尺寸。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;2）代码有问题后，再新加代码的同学，是改还是不改前人写好的代码呢？出 bug 谁来背？这是一个灵魂拷问。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;过早的优化&lt;/span&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;这个大家听了很多了，这里不赘述。&lt;/span&gt;&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;对合理性没有苛求&lt;/span&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&#x27;两种写法都 ok，你随便挑一种吧&#x27;，&#x27;我这样也没什么吧&#x27;，这是我经常听到的话。&lt;/span&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;// Get 获取IP&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;(i *IPGetter)&lt;/span&gt; &lt;span&gt;Get&lt;/span&gt;&lt;span&gt;(cardName &lt;span&gt;string&lt;/span&gt;)&lt;/span&gt; &lt;span&gt;string&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; i.l.RLock()&lt;br/&gt; ip, found := i.m[cardName]&lt;br/&gt; i.l.RUnlock()&lt;br/&gt;&lt;br/&gt; &lt;span&gt;if&lt;/span&gt; found {&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; ip&lt;br/&gt; }&lt;br/&gt;&lt;br/&gt; i.l.Lock()&lt;br/&gt; &lt;span&gt;var&lt;/span&gt; err error&lt;br/&gt; ip, err = getNetIP(cardName)&lt;br/&gt; &lt;span&gt;if&lt;/span&gt; err == &lt;span&gt;nil&lt;/span&gt; {&lt;br/&gt;  i.m[cardName] = ip&lt;br/&gt; }&lt;br/&gt;&lt;br/&gt;  i.l.Unlock()&lt;br/&gt; &lt;span&gt;return&lt;/span&gt; ip&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;i.l.Unlock()可以放在当前的位置，也可以放在 i.l.Lock()下面，做成 defer。两种在最初构造的时候，好像都行。这个时候，很多同学态度就变得不坚决。实际上，这里必须是 defer 的。&lt;/span&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;  i.l.Lock()&lt;br/&gt; &lt;span&gt;defer&lt;/span&gt; i.l.Unlock()&lt;br/&gt;&lt;br/&gt; &lt;span&gt;var&lt;/span&gt; err error&lt;br/&gt; ip, err = getNetIP(cardName)&lt;br/&gt; &lt;span&gt;if&lt;/span&gt; err != &lt;span&gt;nil&lt;/span&gt; {&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; &lt;span&gt;&quot;127.0.0.1&quot;&lt;/span&gt;&lt;br/&gt; }&lt;br/&gt;&lt;br/&gt; i.m[cardName] = ip&lt;br/&gt; &lt;span&gt;return&lt;/span&gt; ip&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;这样的修改，是极有可能发生的，它还是要变成 defer，那，为什么不一开始就是 defer，进入最合理的状态？不一开始就进入最合理的状态，在后续协作中，其他同学很可能犯错！&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;总是面向对象/总喜欢封装&lt;/span&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;我是软件工程科班出身，学的第一门编程语言是 c++。当时自己读完教材，初入程序设计之门，对于里面讲的&#x27;封装&#x27;，惊为天人，多么美妙的设计啊，面向对象，多么智慧的设计啊。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;span&gt;但是，这些年来，我看到了大牛&#x27;云风&#x27;对于&#x27;毕业生使用 mysql api 就喜欢搞个 class 封装再用&#x27;的嘲讽；看到了各种莫名其妙的 class 定义；体会到了经常要去看一个莫名其妙的继承树，必须要把整个继承树整体读明白才能确认一个细小的逻辑分支；多次体会到了我需要辛苦地压抑住自己的抵触情绪，去细度一个自作聪明的被封装的代码，确认我的 bug。除了 UI 类场景，我认为&lt;/span&gt;&lt;span&gt;少用继承、多用组合。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;template&lt;/span&gt;&amp;lt;&lt;span&gt;&lt;span&gt;class&lt;/span&gt; _&lt;span&gt;PKG_TYPE&lt;/span&gt;&amp;gt;&lt;br/&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;CSuperAction&lt;/span&gt; :&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; CSuperActionBase {&lt;br/&gt;  &lt;span&gt;public&lt;/span&gt;:&lt;br/&gt;    &lt;span&gt;typedef&lt;/span&gt; _PKG_TYPE pkg_type;&lt;br/&gt;    &lt;span&gt;typedef&lt;/span&gt; CSuperAction&amp;lt;pkg_type&amp;gt; this_type;&lt;br/&gt;    ...&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;这是 sspp 的代码。CSuperAction 和 CSuperActionBase，一会儿 super，一会儿 base，Super 和 SuperBase 是在怎样的两个抽象层次上，不通读代码，没人能读明白。我想确认任何细节，都要把多个层次的代码都通读了，有什么封装性可言？&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;好，你说是作者没有把 class name 取得好。那，问题是，你能取得好么？一个刚入职的 T1.2 的同学能把 class name、class 树设计得好么？即使是对简单的业务模型，也需要无数次&#x27;坏&#x27;的对象抽象实践，才能培养出一个具有合格的 class 抽象能力的同学，这对于大型却松散的团队协作，不是破坏性的？已经有了一套继承树，想要添加功能就只能在这个继承树里添加，以前的继承树不再适合新的需求，这个继承树上所有的 class，以及使用它们的地方，你都去改？不，是个正常人都会放弃，开始堆屎山。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;封装，就是我可以不关心实现。但是，做一个稳定的系统，每一层设计都可能出问题。例如，API 总有合适的用法和不合适的用法。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;span&gt;真的存在我们能完全不关心封装的部分是怎么实现的？不，你不能&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;span&gt;bug 和性能问题，常常就出现在：你用了错误的用法去使用一个封装好的函数。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;即使是 android、ios 的 api，golang、java 现成的 api，我们常常都要去探究实现，才能把 api 用好。那，我们是不是该一上来，就做一个透明性很强的函数，才更为合理？使用者想知道细节，进来吧，我的实现很易读，你看看就明白，使用时不会迷路！对于逻辑复杂的函数，我们还要强调函数内部工作方式&#x27;可以让读者在大脑里想象呈现完整过程&#x27;的可现性，让使用者轻松读懂，有把握，使用时，不迷路！&lt;/span&gt;&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;根本没有设计&lt;/span&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;这个最可怕，所有需求，上手就是一顿撸，&#x27;设计是什么东西？我一个文件 5w 行，一个函数 5k 行，干不完需求？&#x27;从第一行代码开始，就是无设计的，随意地踩着满地的泥坑，对于旁人的眼光没有感觉，一个人独舞，产出的代码，完成了需求，毁灭了接手自己代码的人。这个就不举例了，每个同学应该都能在自己的项目类发现这种代码。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;必须形而上的思考&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;常常，同学们听演讲，公开课，就喜欢听一些细枝末节的&#x27;干活&#x27;。这没有问题。但是，你干了几年活，学习了多少干货知识点？构建起自己的技术思考&#x27;面&#x27;，进入立体的&#x27;工程思维&#x27;，把技术细节和系统要满足的需求在思考上连接起来了么？当听一个需求的时候，你能思考到自己的 code package 该怎么组织，函数该怎么组织了么？&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;span&gt;那，技术点要怎么和需求连接起来呢？答案很简单，&lt;/span&gt;&lt;span&gt;你需要在时间里总结，总结出一些明确的原则、思维过程。思考怎么去总结，特别像是在思考哲学问题。从一些琐碎的细节中，由具体情况上升到一些原则、公理&lt;/span&gt;&lt;span&gt;。同时，大家在接受原则时，不应该是接受和记住原则本身，而应该是结构原则，让这个原则在自己这里重新推理一遍，自己完全掌握这个原则的适用范围。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;再进一步具体地说，对于工程最佳实践的形而上的思考过程，就是：&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;把工程实践中遇到的问题，从问题类型和解法类型，两个角度去归类，总结出一些有限适用的原则，就从点到了面。把诸多总结出的原则，组合应用到自己的项目代码中，就是把多个面结合起来构建了一套立体的最佳实践的方案。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;当你这套方案能适应 30w+行代码的项目，超过 30 人的项目，你就架构师入门了！当你这个项目，是多端，多语言，代码量超过 300w 行，参与人数超过 300 人，代码质量依然很高，代码依然在高效地自我迭代，每天消除掉过时的代码，填充高质量的替换旧代码和新生的代码。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;恭喜你，你已经是一个很高级的架构师了！再进一步，你对某个业务模型有独到或者全面的理解，构建了一套行业第一的解决方案，结合刚才高质量实现的能力，实现了这么一个项目。没啥好说的，你已经是专家工程师了。级别再高，我就不了解了，不在这里讨论。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;那么，我们要重头开始积累思考和总结？不，有一本书叫做《unix 编程艺术》，我在不同的时期分别读了 3 遍，等一会，我讲一些里面提到的，我觉得在腾讯尤其值得拿出来说的原则。这些原则，正好就能作为 code review 时大家判定代码质量的准绳。但，在那之前，我得讲一下另外一个很重要的话题，模型设计。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;model 设计&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;没读过 oauth2.0 RFC，就去设计第三方授权登陆的人，终归还要再发明一个撇脚的 oauth。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;2012 年我刚毕业，我和一个去了广州联通公司的华南理工毕业生聊天。当时他说他工作很不开心，因为工作里不经常写代码，而且认为自己有 ACM 竞赛金牌级的算法熟练度+对 CPP 代码的熟悉，写下一个个指针操作内存，什么程序写不出来，什么事情做不好。当时我觉得，挺有道理，编程工具在手，我什么事情做不了？&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;span&gt;现在，我会告诉他，复杂如 linux 操作系统、Chromium 引擎、windows office，你做不了。原因是，他根本没进入软件工程的工程世界。&lt;/span&gt;&lt;span&gt;不是会搬砖就能修出港珠澳大桥。&lt;/span&gt;&lt;span&gt;但是，这么回答并不好，举证用的论据离我们太遥远了。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;见微知著。我现在会回答，你做不了，简单如一个权限系统，你知道怎么做么？堆积一堆逻辑层次一维展开的 if else？简单如一个共享文件管理，你知道怎么做么？堆积一堆逻辑层次一维展开的 ife lse？你联通有上万台服务器，你要怎么写一个管理平台？堆积一堆逻辑层次一维展开的 ife lse？&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;上来就是干，能实现上面提到的三个看似简单的需求？&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;想一想，亚马逊、阿里云折腾了多少年，最后才找到了容器 + Kubernetes 的大杀器。谷歌用了多少年才在 BORG 系统上的实践，提出了优秀的服务编排领域模型。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;权限领域，有 RBAC、DAC、MAC 等等模型，到了业务，又会有细节的不同。如 Domain Driven Design 说的，没有良好的领域思考和模型抽象，逻辑复杂度就是 n^2 指数级的，你得写多少 ifelse，得思考多少可能的 if 路径，来 cover 所有的不合符预期的情况。你必须要有 Domain 思考探索、model 拆解/抽象/构建的能力。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;span&gt;有人问过我，要怎么有效地获得这个能力？这个问题我没能回答，就像是在问我，怎么才能获得 MIT 博士的学术能力？我无法回答。唯一回答就是，&lt;/span&gt;&lt;span&gt;进入某个领域，就是首先去看前人的思考，站在前人的肩膀上，再用上自己的通识能力&lt;/span&gt;&lt;span&gt;，去进一步思考。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;至于怎么建立好的通识思考能力，可能得去常青藤读个书吧：）或者，就在工程实践中思考和锻炼自己的这个能力！&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;同时，基于 model 设计的代码，能更好地适应产品经理不断变更的需求。比如说，一个 calendar(日历)应用，简单来想，不要太简单！&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;以&#x27;userid_date&#x27;为 key 记录一个用户的每日安排不就完成了么？只往前走一小步，设计一个任务，上限分发给 100w 个人。创建这么一个任务，是往 100w 个人下面添加一条记录？你得改掉之前的设计，换 db。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;再往前走一步，要拉出某个用户和某个人一起要参与的所有事务，是把两个人的所有任务来做 join？好像还行。如果是和 100 个人一起参与的所有任务呢？100 个人的任务来 join？不现实了吧。好，你引入一个群组 id，那么，你最开始的&#x27;userid_date&#x27;为 key 的设计，是不是又要修改和做数据迁移了？&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;经常来一个需求，你就得把系统推翻重来，或者根本就只能拒绝用户的需求，这样的战斗力，还好意思叫自己工程师？你一开始就应该思考自己面对的业务领域，思考自己的日历应用可能的模型边界，把可能要做的能力都拿进来思考，构建一个 model，设计一套通用的 store 层接口，基于通用接口的逻辑代码。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;当产品不断发展，就是不停往模型里填内容，而不是推翻重来。这，思考模型边界，构建模型细节，就是两个很重要的能力，也是绝大多数腾讯产品经理不具备的能力，你得具备，对整个团队都是极其有益的。你面对产品经理时，就听取他们出于对用户体验负责思考出的需求点，到你自己这里，用一个完整的模型去涵盖这些零碎的点。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;model 设计，是形而上思考中的一个方面，一个特别重要的方面。接下来，我们来抄袭抄袭 unix 操作系统构建的实践为我们提出的前人实践经验和&#x27;公理&#x27;总结。在自己的 coding/code review 中，站在巨人的肩膀上去思考。不重复地发现经典力学，而是往相对论挺进。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;UNIX 设计哲学&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;不懂 Unix 的人注定最终还要重复发明一个撇脚的 Unix。--Henry Spenncer, 1987.11&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;下面这一段话太经典，我必须要摘抄一遍(自《UNIX 编程艺术》)：&lt;/span&gt;&lt;/p&gt;&lt;blockquote class=&quot;js_blockquote_wrap&quot; data-type=&quot;2&quot; data-url=&quot;&quot; data-author-name=&quot;&quot; data-content-utf8-length=&quot;260&quot; data-source-title=&quot;&quot;&gt;&lt;section class=&quot;js_blockquote_digest&quot;&gt;&lt;section&gt;&lt;span&gt;工程和设计的每个分支都有自己的技术文化。在大多数工程领域中，就一个专业人员的素养组成来说，有些不成文的行业素养具有与标准手册及教科书同等重要的地位(并且随着专业人员经验的日积月累，这些经验常常会比书本更重要)。资深工程师们在工作中会积累大量的隐性知识，他们用类似禅宗&#x27;教外别传&#x27;的方式，通过言传身教传授给后辈。软件工程算是此规则的一个例外：技术变革如此之快，软件环境日新月异，软件技术文化暂如朝露。然而，例外之中也有例外。确有极少数软件技术被证明经久耐用，足以演进为强势的技术文化、有鲜明特色的艺术和世代相传的设计哲学。&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;接下来，我用我的理解，讲解一下几个我们常常做不到的原则。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;原则 1 ：&lt;/span&gt;Keep It Simple and Stupid!&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;KISS 原则，大家应该是如雷贯耳了。但是，你真的在遵守？什么是 Simple？简单？golang 语言主要设计者之一的 Rob Pike 说&#x27;大道至简&#x27;，这个&#x27;简&#x27;和简单是一个意思么？&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;首先，简单不是面对一个问题，我们印入眼帘第一映像的解法为简单。我说一句，感受一下。&quot;把一个事情做出来容易，把事情用最简单有效的方法做出来，是一个很难的事情。&quot;比如，做一个三方授权，oauth2.0 很简单，所有概念和细节都是紧凑、完备、易用的。你觉得要设计到 oauth2.0 这个效果很容易么？要做到简单，就要对自己处理的问题有全面的了解，然后需要不断积累思考，才能做到从各个角度和层级去认识这个问题，打磨出一个通俗、紧凑、完备的设计，就像 ios 的交互设计。简单不是容易做到的，需要大家在不断的时间和 code review 过程中去积累思考，pk 中触发思考，交流中总结思考，才能做得愈发地好，接近&#x27;大道至简&#x27;。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;两张经典的模型图，简单又全面，感受一下，没看懂，可以立即自行 google 学习一下：RBAC:&lt;/span&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5752808988764045&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/j3gficicyOvateFibZunwicamXNtmtrXYQ6TJME4nHnTKJ2BAnU4eDRjsjIYzMMSUeIFUPoQLUq9sGUmoO0WCPfdvA/640?wx_fmt=png&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; data-type=&quot;png&quot; data-w=&quot;890&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;logging:&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.43802083333333336&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/j3gficicyOvateFibZunwicamXNtmtrXYQ6TeE8VCDD3htjWxgBIPrSibzOXqXY0n7gb82LuMAfDBTOzeFXGiaVzactA/640?wx_fmt=png&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; data-type=&quot;png&quot; data-w=&quot;1920&quot;/&gt;&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;br/&gt;&lt;/h4&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;原则 2 组合原则: 设计时考虑拼接组合&lt;/span&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;关于 OOP，关于继承，我前面已经说过了。那我们怎么组织自己的模块？对，用组合的方式来达到。linux 操作系统离我们这么近，它是怎么架构起来的？往小里说，我们一个串联一个业务请求的数据集合，如果使用 BaseSession，XXXSession inherit BaseSession 的设计，其实，这个继承树，很难适应层出不穷的变化。但是如果使用组合，就可以拆解出 UserSignature 等等各种可能需要的部件，在需要的时候组合使用，不断添加新的部件而没有对老的继承树的记忆这个心智负担。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;span&gt;使用组合，其实就是要让你明确清楚自己现在所拥有的是哪个部件。&lt;/span&gt;&lt;span&gt;如果部件过于多，其实完成组合最终成品这个步骤，就会有较高的心智负担，每个部件展开来，琳琅满目，眼花缭乱。比如 QT 这个通用 UI 框架，看它的Class 列表，有 1000 多个。如果不用继承树把它组织起来，平铺展开，组合出一个页面，将会变得心智负担高到无法承受。OOP 在&#x27;需要无数元素同时展现出来&#x27;这种复杂度极高的场景，有效的控制了复杂度 。&#x27;那么，古尔丹，代价是什么呢？&#x27;代价就是，一开始做出这个自上而下的设计，牵一发而动全身，每次调整都变得异常困难。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;实际项目中，各种职业级别不同的同学一起协作修改一个 server 的代码，就会出现，职级低的同学改哪里都改不对，根本没能力进行修改，高级别的同学能修改对，也不愿意大规模修改，整个项目变得愈发不合理。对整个继承树没有完全认识的同学都没有资格进行任何一个对继承树有调整的修改，协作变得寸步难行。代码的修改，都变成了依赖一个高级架构师高强度监控继承体系的变化，低级别同学们束手束脚的结果。组合，就很好的解决了这个问题，把问题不断细分，每个同学都可以很好地攻克自己需要攻克的点，实现一个 package。产品逻辑代码，只需要去组合各个 package，就能达到效果。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;这是 golang 标准库里 http request 的定义，它就是 Http 请求所有特性集合出来的结果。其中通用/异变/多种实现的部分，通过 duck interface 抽象，比如 Body io.ReadCloser。你想知道哪些细节，就从组合成 request 的部件入手，要修改，只需要修改对应部件。[这段代码后，对比.NET 的 HTTP 基于 OOP 的抽象]&lt;/span&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;// A Request represents an HTTP request received by a server&lt;br/&gt;// or to be sent by a client.&lt;br/&gt;//&lt;br/&gt;// The field semantics differ slightly between client and server&lt;br/&gt;// usage. In addition to the notes on the fields below, see the&lt;br/&gt;// documentation for Request.Write and RoundTripper.&lt;br/&gt;type Request struct {&lt;br/&gt;// Method specifies the HTTP method (GET, POST, PUT, etc.).&lt;br/&gt;// For client requests, an empty string means GET.&lt;br/&gt;//&lt;br/&gt;// Go&#x27;s HTTP client does not support sending a request with&lt;br/&gt;// the CONNECT method. See the documentation on Transport for&lt;br/&gt;// details.&lt;br/&gt;Method string&lt;br/&gt;&lt;br/&gt;// URL specifies either the URI being requested (for server&lt;br/&gt;// requests) or the URL to access (for client requests).&lt;br/&gt;//&lt;br/&gt;// For server requests, the URL is parsed from the URI&lt;br/&gt;// supplied on the Request-Line as stored in RequestURI.  For&lt;br/&gt;// most requests, fields other than Path and RawQuery will be&lt;br/&gt;// empty. (See RFC 7230, Section 5.3)&lt;br/&gt;//&lt;br/&gt;// For client requests, the URL&#x27;s Host specifies the server to&lt;br/&gt;// connect to, while the Request&#x27;s Host field optionally&lt;br/&gt;// specifies the Host header value to send in the HTTP&lt;br/&gt;// request.&lt;br/&gt;URL *url.URL&lt;br/&gt;&lt;br/&gt;// The protocol version for incoming server requests.&lt;br/&gt;//&lt;br/&gt;// For client requests, these fields are ignored. The HTTP&lt;br/&gt;// client code always uses either HTTP/1.1 or HTTP/2.&lt;br/&gt;// See the docs on Transport for details.&lt;br/&gt;Proto      string // &quot;HTTP/1.0&quot;&lt;br/&gt;ProtoMajor int    // 1&lt;br/&gt;ProtoMinor int    // 0&lt;br/&gt;&lt;br/&gt;// Header contains the request header fields either received&lt;br/&gt;// by the server or to be sent by the client.&lt;br/&gt;//&lt;br/&gt;// If a server received a request with header lines,&lt;br/&gt;//&lt;br/&gt;//Host: example.com&lt;br/&gt;//accept-encoding: gzip, deflate&lt;br/&gt;//Accept-Language: en-us&lt;br/&gt;//fOO: Bar&lt;br/&gt;//foo: two&lt;br/&gt;//&lt;br/&gt;// then&lt;br/&gt;//&lt;br/&gt;//Header = map[string][]string{&lt;br/&gt;//&quot;Accept-Encoding&quot;: {&quot;gzip, deflate&quot;},&lt;br/&gt;//&quot;Accept-Language&quot;: {&quot;en-us&quot;},&lt;br/&gt;//&quot;Foo&quot;: {&quot;Bar&quot;, &quot;two&quot;},&lt;br/&gt;//}&lt;br/&gt;//&lt;br/&gt;// For incoming requests, the Host header is promoted to the&lt;br/&gt;// Request.Host field and removed from the Header map.&lt;br/&gt;//&lt;br/&gt;// HTTP defines that header names are case-insensitive. The&lt;br/&gt;// request parser implements this by using CanonicalHeaderKey,&lt;br/&gt;// making the first character and any characters following a&lt;br/&gt;// hyphen uppercase and the rest lowercase.&lt;br/&gt;//&lt;br/&gt;// For client requests, certain headers such as Content-Length&lt;br/&gt;// and Connection are automatically written when needed and&lt;br/&gt;// values in Header may be ignored. See the documentation&lt;br/&gt;// for the Request.Write method.&lt;br/&gt;Header Header&lt;br/&gt;&lt;br/&gt;// Body is the request&#x27;s body.&lt;br/&gt;//&lt;br/&gt;// For client requests, a nil body means the request has no&lt;br/&gt;// body, such as a GET request. The HTTP Client&#x27;s Transport&lt;br/&gt;// is responsible for calling the Close method.&lt;br/&gt;//&lt;br/&gt;// For server requests, the Request Body is always non-nil&lt;br/&gt;// but will return EOF immediately when no body is present.&lt;br/&gt;// The Server will close the request body. The ServeHTTP&lt;br/&gt;// Handler does not need to.&lt;br/&gt;Body io.ReadCloser&lt;br/&gt;&lt;br/&gt;// GetBody defines an optional func to return a new copy of&lt;br/&gt;// Body. It is used for client requests when a redirect requires&lt;br/&gt;// reading the body more than once. Use of GetBody still&lt;br/&gt;// requires setting Body.&lt;br/&gt;//&lt;br/&gt;// For server requests, it is unused.&lt;br/&gt;GetBody func() (io.ReadCloser, error)&lt;br/&gt;&lt;br/&gt;// ContentLength records the length of the associated content.&lt;br/&gt;// The value -1 indicates that the length is unknown.&lt;br/&gt;// Values &amp;gt;= 0 indicate that the given number of bytes may&lt;br/&gt;// be read from Body.&lt;br/&gt;//&lt;br/&gt;// For client requests, a value of 0 with a non-nil Body is&lt;br/&gt;// also treated as unknown.&lt;br/&gt;ContentLength int64&lt;br/&gt;&lt;br/&gt;// TransferEncoding lists the transfer encodings from outermost to&lt;br/&gt;// innermost. An empty list denotes the &quot;identity&quot; encoding.&lt;br/&gt;// TransferEncoding can usually be ignored; chunked encoding is&lt;br/&gt;// automatically added and removed as necessary when sending and&lt;br/&gt;// receiving requests.&lt;br/&gt;TransferEncoding []string&lt;br/&gt;&lt;br/&gt;// Close indicates whether to close the connection after&lt;br/&gt;// replying to this request (for servers) or after sending this&lt;br/&gt;// request and reading its response (for clients).&lt;br/&gt;//&lt;br/&gt;// For server requests, the HTTP server handles this automatically&lt;br/&gt;// and this field is not needed by Handlers.&lt;br/&gt;//&lt;br/&gt;// For client requests, setting this field prevents re-use of&lt;br/&gt;// TCP connections between requests to the same hosts, as if&lt;br/&gt;// Transport.DisableKeepAlives were set.&lt;br/&gt;Close bool&lt;br/&gt;&lt;br/&gt;// For server requests, Host specifies the host on which the&lt;br/&gt;// URL is sought. For HTTP/1 (per RFC 7230, section 5.4), this&lt;br/&gt;// is either the value of the &quot;Host&quot; header or the host name&lt;br/&gt;// given in the URL itself. For HTTP/2, it is the value of the&lt;br/&gt;// &quot;:authority&quot; pseudo-header field.&lt;br/&gt;// It may be of the form &quot;host:port&quot;. For international domain&lt;br/&gt;// names, Host may be in Punycode or Unicode form. Use&lt;br/&gt;// golang.org/x/net/idna to convert it to either format if&lt;br/&gt;// needed.&lt;br/&gt;// To prevent DNS rebinding attacks, server Handlers should&lt;br/&gt;// validate that the Host header has a value for which the&lt;br/&gt;// Handler considers itself authoritative. The included&lt;br/&gt;// ServeMux supports patterns registered to particular host&lt;br/&gt;// names and thus protects its registered Handlers.&lt;br/&gt;//&lt;br/&gt;// For client requests, Host optionally overrides the Host&lt;br/&gt;// header to send. If empty, the Request.Write method uses&lt;br/&gt;// the value of URL.Host. Host may contain an international&lt;br/&gt;// domain name.&lt;br/&gt;Host string&lt;br/&gt;&lt;br/&gt;// Form contains the parsed form data, including both the URL&lt;br/&gt;// field&#x27;s query parameters and the PATCH, POST, or PUT form data.&lt;br/&gt;// This field is only available after ParseForm is called.&lt;br/&gt;// The HTTP client ignores Form and uses Body instead.&lt;br/&gt;Form url.Values&lt;br/&gt;&lt;br/&gt;// PostForm contains the parsed form data from PATCH, POST&lt;br/&gt;// or PUT body parameters.&lt;br/&gt;//&lt;br/&gt;// This field is only available after ParseForm is called.&lt;br/&gt;// The HTTP client ignores PostForm and uses Body instead.&lt;br/&gt;PostForm url.Values&lt;br/&gt;&lt;br/&gt;// MultipartForm is the parsed multipart form, including file uploads.&lt;br/&gt;// This field is only available after ParseMultipartForm is called.&lt;br/&gt;// The HTTP client ignores MultipartForm and uses Body instead.&lt;br/&gt;MultipartForm *multipart.Form&lt;br/&gt;&lt;br/&gt;// Trailer specifies additional headers that are sent after the request&lt;br/&gt;// body.&lt;br/&gt;//&lt;br/&gt;// For server requests, the Trailer map initially contains only the&lt;br/&gt;// trailer keys, with nil values. (The client declares which trailers it&lt;br/&gt;// will later send.)  While the handler is reading from Body, it must&lt;br/&gt;// not reference Trailer. After reading from Body returns EOF, Trailer&lt;br/&gt;// can be read again and will contain non-nil values, if they were sent&lt;br/&gt;// by the client.&lt;br/&gt;//&lt;br/&gt;// For client requests, Trailer must be initialized to a map containing&lt;br/&gt;// the trailer keys to later send. The values may be nil or their final&lt;br/&gt;// values. The ContentLength must be 0 or -1, to send a chunked request.&lt;br/&gt;// After the HTTP request is sent the map values can be updated while&lt;br/&gt;// the request body is read. Once the body returns EOF, the caller must&lt;br/&gt;// not mutate Trailer.&lt;br/&gt;//&lt;br/&gt;// Few HTTP clients, servers, or proxies support HTTP trailers.&lt;br/&gt;Trailer Header&lt;br/&gt;&lt;br/&gt;// RemoteAddr allows HTTP servers and other software to record&lt;br/&gt;// the network address that sent the request, usually for&lt;br/&gt;// logging. This field is not filled in by ReadRequest and&lt;br/&gt;// has no defined format. The HTTP server in this package&lt;br/&gt;// sets RemoteAddr to an &quot;IP:port&quot; address before invoking a&lt;br/&gt;// handler.&lt;br/&gt;// This field is ignored by the HTTP client.&lt;br/&gt;RemoteAddr string&lt;br/&gt;&lt;br/&gt;// RequestURI is the unmodified request-target of the&lt;br/&gt;// Request-Line (RFC 7230, Section 3.1.1) as sent by the client&lt;br/&gt;// to a server. Usually the URL field should be used instead.&lt;br/&gt;// It is an error to set this field in an HTTP client request.&lt;br/&gt;RequestURI string&lt;br/&gt;&lt;br/&gt;// TLS allows HTTP servers and other software to record&lt;br/&gt;// information about the TLS connection on which the request&lt;br/&gt;// was received. This field is not filled in by ReadRequest.&lt;br/&gt;// The HTTP server in this package sets the field for&lt;br/&gt;// TLS-enabled connections before invoking a handler;&lt;br/&gt;// otherwise it leaves the field nil.&lt;br/&gt;// This field is ignored by the HTTP client.&lt;br/&gt;TLS *tls.ConnectionState&lt;br/&gt;&lt;br/&gt;// Cancel is an optional channel whose closure indicates that the client&lt;br/&gt;// request should be regarded as canceled. Not all implementations of&lt;br/&gt;// RoundTripper may support Cancel.&lt;br/&gt;//&lt;br/&gt;// For server requests, this field is not applicable.&lt;br/&gt;//&lt;br/&gt;// Deprecated: Set the Request&#x27;s context with NewRequestWithContext&lt;br/&gt;// instead. If a Request&#x27;s Cancel field and context are both&lt;br/&gt;// set, it is undefined whether Cancel is respected.&lt;br/&gt;Cancel &amp;lt;-chan struct{}&lt;br/&gt;&lt;br/&gt;// Response is the redirect response which caused this request&lt;br/&gt;// to be created. This field is only populated during client&lt;br/&gt;// redirects.&lt;br/&gt;Response *Response&lt;br/&gt;&lt;br/&gt;// ctx is either the client or server context. It should only&lt;br/&gt;// be modified via copying the whole Request using WithContext.&lt;br/&gt;// It is unexported to prevent people from using Context wrong&lt;br/&gt;// and mutating the contexts held by callers of the same request.&lt;br/&gt;ctx context.Context&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;看看.NET 里对于 web 服务的抽象，仅仅看到末端，不去看完整个继承树的完整图景，我根本无法知道我关心的某个细节在什么位置。进而，我要往整个 http 服务体系里修改任何功能，都无法抛开对整体完整设计的理解和熟悉，还极容易没有知觉地破坏者整体的设计。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;说到组合，还有一个关系很紧密的词，叫插件化。大家都用 vscode 用得很开心，它比 visual studio 成功在哪里？如果 vscode 通过添加一堆插件达到 visual studio 具备的能力，那么它将变成另一个和 visual studio 差不多的东西，叫做 vs studio 吧。大家应该发现问题了，我们很多时候其实并不需要 visual studio 的大多数功能，而且希望灵活定制化一些比较小众的能力，用一些小众的插件。甚至，我们希望选择不同实现的同类型插件。这就是组合的力量，各种不同的组合，它简单，却又满足了各种需求，灵活多变，要实现一个插件，不需要事先掌握一个庞大的体系。体现在代码上，也是一样的道理。至少后端开发领域，组合，比 OOP，&#x27;香&#x27;很多。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;原则 3 吝啬原则: 除非确无它法, 不要编写庞大的程序&lt;/span&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;可能有些同学会觉得，把程序写得庞大一些才好拿得出手去评 T11、T12。leader 们一看评审方案就容易觉得：很大，很好，很全面。但是，我们真的需要写这么大的程序么？&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;我又要说了&quot;那么，古尔丹，代价是什么呢？&quot;。代价是代码越多，越难维护，难调整。说&quot;&quot;。&lt;/span&gt;&lt;/p&gt;&lt;section data-role=&quot;outer&quot; label=&quot;Powered by 135editor.com&quot;&gt;&lt;blockquote&gt;&lt;p&gt;&lt;span&gt;删除一行代码，给我带来的成就感要比添加一行要大&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;—— C 语言之父 Ken Thompson &lt;/span&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;我们对于代码，要吝啬。能把系统做小，就不要做大。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;腾讯不乏 200w+行的客户端，很大，很牛。但是，同学们自问，现在还调整得动架构么。手 Q 的同学们，看看自己代码，曾经叹息过么?&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;能小做的事情就小做，寻求通用化，通过 duck interface(甚至多进程，用于隔离能力的多线程)把模块、能力隔离开，时刻想着删减代码量，才能保持代码的可维护性和面对未来的需求、架构，调整自身的活力。客户端代码，UI 渲染模块可以复杂吊炸天，非 UI 部分应该追求最简单，能力接口化，可替换、重组合能力强。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;落地到大家的代码，review 时，就应该最关注核心 struct 定义，构建起一个完备的模型，核心 interface，明确抽象 model 对外部的依赖，明确抽象 model 对外提供的能力。其他代码，就是要用最简单、平平无奇的代码实现模型内部细节。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;原则 4 透明性原则: 设计要可见，以便审查和调试&lt;/span&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;首先，定义一下，什么是透明性和可显性。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&quot;如果没有阴暗的角落和隐藏的深度，软件系统就是透明的。透明性是一种被动的品质。如果实际上能预测到程序行为的全部或大部分情况，并能建立简单的心理模型，这个程序就是透明的，因为可以看透机器究竟在干什么。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;如果软件系统所包含的功能是为了帮助人们对软件建立正确的&#x27;做什么、怎么做&#x27;的心理模型而设计，这个软件系统就是可显的。因此，举例来说，对用户而言，良好的文档有助于提高可显性；对程序员而言，良好的变量和函数名有助于提高可显性。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;可显性是一种主动品质。在软件中要达到这一点，仅仅做到不晦涩是不够的，还必须要尽力做到有帮助。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;我们要写好程序，减少 bug，就要增强自己对代码的控制力。你始终做到，理解自己调用的函数/复用的代码大概是怎么实现的。不然，你可能就会在单线程状态机的 server 里调用有 IO 阻塞的函数，让自己的 server 吞吐量直接掉到底。进而，为了保证大家能对自己代码能做到有控制力，所有人写的函数，就必须具备很高的透明性。而不是写一些看了一阵看不明白的函数/代码，结果被迫使用你代码的人，直接放弃了对掌控力的追取，甚至放弃复用你的代码，另起炉灶，走向了&#x27;制造重复代码&#x27;的深渊。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;透明性其实相对容易做到的，大家有意识地锻炼一两个月，就能做得很好。可显性就不容易了。有一个现象是，你写的每一个函数都不超过 80 行，每一行我都能看懂，但是你层层调用，很多函数调用，组合起来怎么就实现了某个功能，看两遍，还是看不懂。第三遍可能才能大概看懂。大概看懂了，但太复杂，很难在大脑里构建起你实现这个功能的整体流程。结果就是，阅读者根本做不到对你的代码有好的掌控力。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;可显性的标准很简单，大家看一段代码，懂不懂，一下就明白了。但是，如何做好可显性？那就是要追求合理的函数分组，合理的函数上下级层次，同一层次的代码才会出现在同一个函数里，追求通俗易懂的函数分组分层方式，是通往可显性的道路。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;当然，复杂如 linux 操作系统，office 文档，问题本身就很复杂，拆解、分层、组合得再合理，都难建立心理模型。这个时候，就需要完备的文档了。完备的文档还需要出现在离代码最近的地方，让人&#x27;知道这里复杂的逻辑有文档&#x27;，而不是其实文档，但是阅读者不知道。再看看上面 golang 标准库里的 http.Request，感受到它在可显性上的努力了么？对，就去学它。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;原则 5 通俗原则: 接口设计避免标新立异&lt;/span&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;设计程序过于标新立异的话，可能会提升别人理解的难度。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;一般，我们这么定义一个&#x27;点&#x27;，使用 x 表示横坐标，用 y 表示纵坐标：&lt;/span&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;/&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;go&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;type Point struct {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt; X float64&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt; Y float64&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;你就是要不同、精准：&lt;/span&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;type&lt;/span&gt; Point &lt;span&gt;struct&lt;/span&gt; {&lt;br/&gt; VerticalOrdinate   &lt;span&gt;float64&lt;/span&gt;&lt;br/&gt; HorizontalOrdinate &lt;span&gt;float64&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;很好，你用词很精准，一般人还驳斥不了你。但是，多数人读你的 VerticalOrdinate 就是没有读 X 理解来得快，来得容易懂、方便。你是在刻意制造协作成本。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;上面的例子常见，但还不是最小立异原则最想说明的问题。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;想想一下，一个程序里，你把用&#x27;+&#x27;这个符号表示数组添加元素，而不是数学&#x27;加&#x27;，&#x27;result := 1+2&#x27; --&amp;gt; &#x27;result = []int{1, 2}&#x27;而不是&#x27;result=3&#x27;，那么，你这个标新立异，对程序的破坏性，简直无法想象。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section data-role=&quot;outer&quot; label=&quot;Powered by 135editor.com&quot;&gt;&lt;blockquote&gt;&lt;p&gt;&lt;span&gt;最小立异原则的另一面是避免表象想死而实际却略有不同。这会极端危险，因为表象相似往往导致人们产生错误的假定。所以最好让不同事物有明显区别，而不要看起来几乎一模一样。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;-- Henry Spencer&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;你实现一个 db.Add()函数却做着 db.AddOrUpdate()的操作，有人使用了你的接口，错误地把数据覆盖了。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;原则 6 缄默原则: 如果一个程序没什么好说的，就沉默&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;这个原则，应该是大家最经常破坏的原则之一。一段简短的代码里插入了各种&#x27;log(&quot;cmd xxx enter&quot;)&#x27;, &#x27;log(&quot;req data &quot; + req.String())&#x27;，非常害怕自己信息打印得不够。害怕自己不知道程序执行成功了，总要最后&#x27;log(&quot;success&quot;)&#x27;。但是，我问一下大家，你们真的耐心看过别人写的代码打的一堆日志么？不是自己需要哪个，就在一堆日志里，再打印一个日志出来一个带有特殊标记的日志&#x27;log(&quot;this_is_my_log_&quot; + xxxxx)&#x27;？结果，第一个作者打印的日志，在代码交接给其他人或者在跟别人协作的时候，这个日志根本没有价值，反而提升了大家看日志的难度。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;一个服务一跑起来，就疯狂打日志，请求处理正常也打一堆日志。滚滚而来的日志，把错误日志淹没在里面。错误日志失去了效果，简单地 tail 查看日志，眼花缭乱，看不出任何问题，这不就成了&#x27;为了捕获问题&#x27;而让自己&#x27;根本无法捕获问题&#x27;了么？&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;沉默是金。除了简单的 stat log，如果你的程序&#x27;发声&#x27;了，那么它抛出的信息就一定要有效！打印一个 log(&#x27;process fail&#x27;)也是毫无价值，到底什么 fail 了？是哪个用户带着什么参数在哪个环节怎么 fail 了？如果发声，就要把必要信息给全。不然就是不发声，表示自己好好地 work 着呢。不发声就是最好的消息，现在我的 work 一切正常！&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&quot;设计良好的程序将用户的注意力视为有限的宝贵资源，只有在必要时才要求使用。&quot;程序员自己的主力，也是宝贵的资源！只有有必要的时候，日志才跑来提醒程序员&#x27;我有问题，来看看&#x27;，而且，必须要给到足够的信息，让一把讲明白现在发生了什么。而不是程序员还需要很多辅助手段来搞明白到底发生了什么。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;每当我发布程序 ，我抽查一个机器，看它的日志。发现只有每分钟外部接入、内部 rpc 的个数/延时分布日志的时候，我就心情很愉悦。我知道，这一分钟，它的成功率又是 100%，没任何问题！&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;原则 7 补救原则: 出现异常时，马上退出并给出足够错误信息&lt;/span&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;其实这个问题很简单，如果出现异常，异常并不会因为我们尝试掩盖它，它就不存在了。所以，程序错误和逻辑错误要严格区分对待。这是一个态度问题。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&#x27;异常是互联网服务器的常态&#x27;。逻辑错误通过 metrics 统计，我们做好告警分析。对于程序错误 ，我们就必须要严格做到在问题最早出现的位置就把必要的信息搜集起来，高调地告知开发和维护者&#x27;我出现异常了，请立即修复我!&#x27;。可以是直接就没有被捕获的 panic 了。也可以在一个最上层的位置统一做好 recover 机制，但是在 recover 的时候一定要能获得准确异常位置的准确异常信息。不能有中间 catch 机制，catch 之后丢失很多信息再往上传递。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;很多 Java 开发的同学，不区分程序错误和逻辑错误，要么都很宽容，要么都很严格，对代码的可维护性是毁灭性的破坏。&quot;我的程序没有程序错误，如果有，我当时就解决了。&quot;只有这样，才能保持程序代码质量的相对稳定，在火苗出现时扑灭火灾是最好的扑灭火灾的方式。当然，更有效的方式是全面自动化测试的预防：）&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;具体实践点&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;前面提了好多思考方向的问题。大的原则问题和方向。我这里，再来给大家简单列举几个细节执行点吧。毕竟，大家要上手，是从执行开始，然后才是总结思考，能把我的思考方式抄过去。下面是针对 golang 语言的，其他语言略有不同。以及，我一时也想不全我所执行的 所有细则，这就是我强调&#x27;原则&#x27;的重要性，原则是可枚举的。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;span&gt;对于代码格式规范，100%严格执行，严重容不得一点沙。&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;span&gt;文件绝不能超过 800 行，如何超过了800行，一定要思考怎么拆文件。没有足够好的理由，就不应该超过 800 行。工程思维，就在于拆文件的时候积累。&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;span&gt;函数对绝不能超过 80 行。如何超过了80行，一定要思考怎么拆函数，思考函数分组，层次。没有足够好的理由，就不应该超过 80 行。工程思维，就在于拆文件的时候积累。&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;span&gt;代码嵌套层次不能超过 4 层，超过了就得改。多想想能不能 early return。工程思维，就在于拆文件的时候积累。&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;if&lt;/span&gt; !needContinue {&lt;br/&gt; doA()&lt;br/&gt; &lt;span&gt;return&lt;/span&gt;&lt;br/&gt;} &lt;span&gt;else&lt;/span&gt; {&lt;br/&gt; doB()&lt;br/&gt; &lt;span&gt;return&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;if&lt;/span&gt; !needContinue {&lt;br/&gt; doA()&lt;br/&gt; &lt;span&gt;return&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;doB()&lt;br/&gt;&lt;span&gt;return&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;下面这个就是 early return，把两端代码从逻辑上解耦了。&lt;/span&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;从目录、package、文件、struct、function 一层层下来 ，信息一定不能出现冗余。比如 file.FileProperty 这种定义。只有每个&#x27;定语&#x27;只出现在一个位置，才为&#x27;做好逻辑、定义分组/分层&#x27;提供了可能性。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;多用多级目录来组织代码所承载的信息，即使某一些中间目录只有一个子目录。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;随着代码的扩展，老的代码违反了一些设计原则，应该立即原地局部重构，维持住代码质量不滑坡。比如:拆文件；拆函数；用 Session 来保存一个复杂的流程型函数的所有信息；重新调整目录结构。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;基于上一点考虑，我们应该尽量让项目的代码有一定的组织、层次关系。我个人的当前实践是除了特别通用的代码，都放在一个 git 里。特别通用、修改少的代码，逐渐独立出 git，作为子 git 连接到当前项目 git，让 goland 的 Refactor 特性、各种 Refactor 工具能帮助我们快速、安全局部重构。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;自己的项目代码，应该有一个内生的层级和逻辑关系。flat 平铺展开是非常不利于代码复用的。怎么复用、怎么组织复用，肯定会变成&#x27;人生难题&#x27;。T4-T7 的同学根本无力解决这种难题。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;如果被 review 的代码虽然简短，但是你看了一眼却发现不咋懂，那就一定有问题。自己看不出来，就找高级别的同学交流。这是你和别 review 代码的同学成长的时刻。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;日志要少打。要打日志就要把关键索引信息带上。必要的日志必须打。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;有疑问就立即问，不要怕问错。让代码作者给出解释。不要怕问出极低问题。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;不要说&#x27;建议&#x27;，提问题，就是刚，你 pk 不过我，就得改！&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;请积极使用 trpc。总是要和老板站在一起！只有和老板达成的对于代码质量建设的共识，才能在团队里更好地做好代码质量建设。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;消灭重复！消灭重复！消灭重复！&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;主干开发&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;最后，我来为&#x27;主干开发&#x27;多说一句话。道理很简单，只有每次被 review 代码不到 500 行，reviewer 才能快速地看完，而且几乎不会看漏。超过 500 行，reviewer 就不能仔细看，只能大概浏览了。而且，让你调整 500 行代码内的逻辑比调整 3000 行甚至更多的代码，容易很多，降低不仅仅是 6 倍，而是一到两个数量级。有问题，在刚出现的时候就调整了，不会给被 revew 的人带来大的修改负担。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;关于 持续集成（CI，continuous integration)，还有很多好的资料和书籍，大家应该及时去学习学习。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;《unix 编程艺术》&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;建议大家把这本书找出来读一读。特别是，T7 及更高级别的同学。你们已经积累了大量的代码实践，亟需对&#x27;工程性&#x27;做思考总结。很多工程方法论都过时了，这本书的内容，是例外中的例外。它所表达出的内容没有因为软件技术的不断更替而过时。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;佛教禅宗讲&#x27;不立文字&#x27;(不立文字，教外别传，直指人心，见性成佛)，很多道理和感悟是不能用文字传达的，文字的表达能力，不能表达。大家常常因为&quot;自己听说过、知道某个道理&quot;而产生一种安心感，认为&quot;我懂了这个道理&quot;，但是自己却不能在实践中做到。知易行难，知道却做不到，在工程实践里，就和&#x27;不懂这个道理&#x27;没有任何区别了。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;我面试过一个别的公司的总监，讲得好像一套一套，代码拉出来遛一遛，根本就没做到，仅仅会道听途说。他在工程实践上的探索前路可以说已经基本断绝了。我只能祝君能做好向上管理，走自己的纯管理道路吧。请不要再说自己对技术有追求，是个技术人了！&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;所以，大家不仅仅是看看我这篇文章，而是在实践中去不断践行和积累自己的&#x27;教外别传&#x27;吧。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;hr/&gt;&lt;p data-type=&quot;paragraph&quot;&gt;&lt;/p&gt;&lt;p data-type=&quot;paragraph&quot;&gt;&lt;span&gt;希望今天的讲解对大家有所帮助，谢谢！&lt;/span&gt;&lt;/p&gt;&lt;p data-type=&quot;paragraph&quot;&gt;&lt;span&gt;Thanks for reading!&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section class=&quot;mp_profile_iframe_wrp&quot;&gt;&lt;mp-common-profile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-id=&quot;MzA3MDg5MDkzOA==&quot; data-pluginname=&quot;mpprofile&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/Z2bVaFK6CgQmUQ0Aca9qSYNFn0tQEXQc5EibBkqQLYtibYBj1hXuagwXkNc3kVwplHxIl7KQfBIiagysgn9GDUUibw/0?wx_fmt=png&quot; data-nickname=&quot;架构精进之路&quot; data-alias=&quot;jiagou_jingjin&quot; data-signature=&quot;十年研发风雨路，大厂架构师，CSDN博客专家，InfoQ写作平台签约作者。专注软件架构研究，技术学习与职业成长，坚持分享接地气儿的架构技术干货文章！&quot; data-from=&quot;2&quot; data-is_biz_ban=&quot;0&quot;/&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;关注公众号，免费领学习资料&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;87502&quot;&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;28&quot;&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;28&quot;&gt;&lt;p data-brushtype=&quot;text&quot;&gt;&lt;span&gt;如果您觉得还不错，欢迎关注和转发~     &lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5163398692810458&quot; data-type=&quot;png&quot; data-w=&quot;306&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/9TPn66HT930CzevNBb2yMhKjOn9yuJqsCPbyzicCBx6Zm9sNJCWibo6VzGRYbxrSfjJaaGibSRuyZFQmr3KcX07sw/640?wx_fmt=png&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;mp-style-type data-value=&quot;3&quot;/&gt;&lt;/p&gt;&lt;/div&gt;

          
        &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>1dad9db263bec875950766cccb1f7645</guid>
<title>深度解读「隐语」密态计算设备 SPU</title>
<link>https://toutiao.io/k/j3jjhen</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content js_underline_content             &quot; id=&quot;js_content&quot;&gt;&lt;section data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;SPU&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;是&lt;em&gt;Secretflow Processing Unit&lt;/em&gt;的简称，它作为隐语平台的&lt;strong&gt;密态计算单元&lt;/strong&gt;，为隐语提供安全的计算服务。&lt;/span&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.48954489544895446&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/rczZsXZbI36fYZDdjEibwGbxq2WPknjgic5yWcO4gfaPcxh0AcVH1LYqGE5CLmydVmvXNd5UlrNic68OkRNN1VK0w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1626&quot;/&gt;&lt;/section&gt;&lt;h3&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;1.SPU概念理解&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;&lt;h3/&gt;&lt;section&gt;&lt;span&gt;密态计算单元这个概念听起来比较晦涩，我们用一个实际的例子&lt;strong&gt;介绍一下SPU的作用&lt;/strong&gt;。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;假设要用 JAX 写逻辑回归（SPU不依赖JAX，选择JAX因为简单），代码如下：&lt;/span&gt;&lt;/section&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;python&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;import&lt;/span&gt; jax&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;import&lt;/span&gt; jax.numpy &lt;span class=&quot;code-snippet__keyword&quot;&gt;as&lt;/span&gt; jnp&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;sigmoid&lt;/span&gt;&lt;span class=&quot;code-snippet__params&quot;&gt;(x)&lt;/span&gt;:&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;code-snippet__number&quot;&gt;1&lt;/span&gt; / (&lt;span class=&quot;code-snippet__number&quot;&gt;1&lt;/span&gt; + jnp.exp(-x))&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;loss&lt;/span&gt;&lt;span class=&quot;code-snippet__params&quot;&gt;(x, y, w)&lt;/span&gt;:&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    pred = sigmoid(jnp.dot(x, w))&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    label_prob = pred * y + (&lt;span class=&quot;code-snippet__number&quot;&gt;1&lt;/span&gt; - pred) * (&lt;span class=&quot;code-snippet__number&quot;&gt;1&lt;/span&gt; - y)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;return&lt;/span&gt; -jnp.sum(jnp.log(label_prob))&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;logit_regression&lt;/span&gt;&lt;span class=&quot;code-snippet__params&quot;&gt;(x, y, epochs=&lt;span class=&quot;code-snippet__number&quot;&gt;3&lt;/span&gt;, step_size=&lt;span class=&quot;code-snippet__number&quot;&gt;0.1&lt;/span&gt;)&lt;/span&gt;:&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    w = jnp.zeros(x.shape[&lt;span class=&quot;code-snippet__number&quot;&gt;1&lt;/span&gt;])&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;for&lt;/span&gt; _ &lt;span class=&quot;code-snippet__keyword&quot;&gt;in&lt;/span&gt; range(epochs):&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        grad = jax.grad(loss, &lt;span class=&quot;code-snippet__number&quot;&gt;2&lt;/span&gt;)(x, y, w)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        w -= grad * step_size&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;return&lt;/span&gt; w&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;x, y = load_full_dataset()&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;w = fit(x, y)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;em&gt;【注】L15 使用了JAX的自动求导功能，对loss function进行了求导&lt;/em&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;对于上述程序，JAX提供了jit（全称Just In Time，是编译技术的一种）方法，&lt;strong&gt;在不用任何算法改动的前提下将上述程序编译到GPU上，从而加速执行&lt;/strong&gt;。&lt;/span&gt;&lt;/section&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;css&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__selector-tag&quot;&gt;jax&lt;/span&gt;&lt;span class=&quot;code-snippet__selector-class&quot;&gt;.jit&lt;/span&gt;(&lt;span class=&quot;code-snippet__selector-tag&quot;&gt;logit_regression&lt;/span&gt;)(&lt;span class=&quot;code-snippet__selector-tag&quot;&gt;x&lt;/span&gt;, &lt;span class=&quot;code-snippet__selector-tag&quot;&gt;y&lt;/span&gt;)  # &lt;span class=&quot;code-snippet__selector-tag&quot;&gt;jax&lt;/span&gt;&lt;span class=&quot;code-snippet__selector-class&quot;&gt;.jit&lt;/span&gt;将&lt;span class=&quot;code-snippet__selector-tag&quot;&gt;logit_regression&lt;/span&gt;翻译到&lt;span class=&quot;code-snippet__selector-tag&quot;&gt;GPU&lt;/span&gt;执行&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;‍&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;JAX 本质解决了两个问题&lt;/span&gt;&lt;/section&gt;&lt;ol class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;降低开发成本，在用户无感的情况下，利用GPU/TPU进行加速&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;降低学习成本，通过兼容numpy API 并提供自动求到来吸引开发者&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;section&gt;&lt;span&gt;沿着这个思路，对安全计算做个类比&lt;/span&gt;&lt;/section&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;JAX可以利用并行设备进行计算加速&lt;/strong&gt;，&lt;strong&gt;我们可否用安全设备进行安全加固？&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;JAX可以复用numpy API，我们是否可以复用其他AI框架API？&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;section&gt;&lt;span&gt;带着这两个问题&lt;/span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;，SPU的核心API就是这样一个函数，将AI模型翻译到安全设备上执行&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span/&gt;&lt;/section&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;css&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__selector-tag&quot;&gt;spu&lt;/span&gt;&lt;span class=&quot;code-snippet__selector-class&quot;&gt;.jit&lt;/span&gt;(&lt;span class=&quot;code-snippet__selector-tag&quot;&gt;logit_regression&lt;/span&gt;)(&lt;span class=&quot;code-snippet__selector-tag&quot;&gt;x&lt;/span&gt;, &lt;span class=&quot;code-snippet__selector-tag&quot;&gt;y&lt;/span&gt;)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;为了实现这个函数，我们需要两个子模块&lt;/span&gt;&lt;/strong&gt;&lt;span/&gt;&lt;/span&gt;&lt;/section&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;SPU (Jit) Compiler: 将原生的AI 程序翻译成 SPU字节码&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;SPU VM：一个带安全语义的虚拟机，解释和执行SPU字节码&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;实际中实现稍微复杂一些&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;将Tensorflow/PyTorch/JAX 翻译成SPU字节码本身是个复杂繁琐的工作&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;SPU字节码使用的是密文类型系统，譬如没有f32/f64等，类型系统需要重新设计&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;SPU后端是MPC，本质上是个分布式系统，需要处理分布式系统的通信和协作&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;上述程序中，变量&lt;/span&gt;&lt;code&gt;&lt;span&gt;x, y&lt;/span&gt;&lt;/code&gt;&lt;span&gt;可能由不同的参与方提供，所以IO模块有些特别&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;section&gt;&lt;span&gt;细节会在后续部分进行简单介绍，在此不再复述。&lt;/span&gt;&lt;/section&gt;&lt;h3&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;2.SPU的功能作用&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/h3&gt;&lt;section&gt;&lt;span&gt;介绍完SPU是什么，我们再来理一下为什么。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;市面上的隐私计算框架有很多，比如 TFE，CrypTen，MP-SPDZ 等，为什么我们要重新造一套轮子呢？&lt;/span&gt;&lt;/section&gt;&lt;h4&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;领域之间的距离&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h4&gt;&lt;section&gt;&lt;span&gt;安全机器学习是一个交叉领域，其实AI和安全之间有相当的距离。比如&lt;/span&gt;&lt;/section&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;安全开发者更关注基础算子，比如加减乘除的安全性&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;AI开发者更关注高阶算子，比如conv，tensordot&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;section&gt;&lt;span&gt;高阶算子和基础算子之间，有很大一段距离，譬如：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;机器学习编译器处理的 lowering/tiling/fusing等&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;运行时处理的的调度，并发等&lt;/span&gt;&lt;span/&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.7608966376089664&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/rczZsXZbI34bjA41awUUV8vpZTzKicVu510icR7OJBT97cSZiaicBzeeyx6RYXbvn3iaLdKNQichpW0iatWPDERNnt5yw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1606&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;无论是基于AI框架（TFE/CrypTen），还是从安全计算出发的框架（SPDZ），都有自己的问题。&lt;/span&gt;&lt;span&gt;前者往往难部署，难做安全领域特定的优化。&lt;/span&gt;&lt;span&gt;后者往往会需要写一些Toy AI框架，学习成本高。&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;SPU试图缝合这两个领域之间的间隙，使得：&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;向上，SPU原生对接AI框架（TF/JAX/PyTorch)，&lt;strong&gt;降低AI开发者的学习和开发成本&lt;/strong&gt;。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;向下，SPU提供纯粹安全语义接口，只需要实现很少的安全协议（比如加乘与或）就能跑起来复杂的模型，&lt;strong&gt;让目光更聚焦安全本身。&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;算力和需求的距离&lt;/span&gt;&lt;/strong&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;span&gt;近些年，密态计算（MPC/HE）在算力上都巨大的进步，但是&lt;strong&gt;密态算力和AI的算法需求还是难以匹配&lt;/strong&gt;。在算力无法匹配算法的时候，&lt;strong&gt;一个直观的想法就是“明密文混合”&lt;/strong&gt;，&lt;/span&gt;&lt;span&gt;&lt;strong&gt;用来做安全和性能的tradeoff&lt;/strong&gt;。&lt;/span&gt;&lt;span&gt;比如联邦学习，将算法的某一个子步骤使用安全计算实现，牺牲局部安全性以换取更高的性能。&lt;/span&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;隐语提供了非常自由的明密文混合编程范式，&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;我们不限制明文的引擎，也不限制密文引擎，开发者可以用他自己熟悉的框架开发，然后标记其中的某一部分用明文引擎跑，另一部分用SPU跑。比如：&lt;/span&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5613333333333334&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/rczZsXZbI36fYZDdjEibwGbxq2WPknjgicJq2d2t0IGh2AusicpiaoTUAib7NqSQOzTE9fwJiadJ7s28gwcjl02jRvPw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;750&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;em&gt;【注】图中MPC Device就是SPU实现的&lt;/em&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;作为对比，从安全和性能这种的角度，无论TFE/CrypTen/SPDZ等都很难进行这种tradeoff。&lt;/span&gt;&lt;/section&gt;&lt;h4&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;理论和落地的距离&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h4&gt;&lt;section&gt;&lt;span&gt;多方安全计算天然是一个分布式的系统，部署模式非常多样，比如：&lt;/span&gt;&lt;/section&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;论文中经常假设计算方和数据提供方分离（outsourcing）&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;真正进行业务落地时，数据提供方往往同时也是计算方（colocated）&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;在一个复杂的隐私计算网络里，计算方和数据方可以是任意组合的（hybrid）&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.2260061919504644&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/rczZsXZbI36fYZDdjEibwGbxq2WPknjgicm4aSQIBaB3g6TGM3Y6rr4ulQggib1ficEaWXYmRLapHrSyjGIWMZiblPw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;646&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;em&gt;如图，我们用三角形表示计算节点，圆形表示数据提供节点（不同颜色表示互不信任）&lt;/em&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;SPU被设计成部署模式透明的，不用修改任何一行代码，你的模型都可以在上述任何一种部署场景上被安全且正确的执行。并且（相对于基于AI平台的隐私计算框架）&lt;strong&gt;SPU运行时非常的轻量级，不需要Python runtime，可以方便的进行部署和集成&lt;/strong&gt;。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;所以，Why SPU？&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;作为AI开发者，你不需要任何安全背景，&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;就可以将你现有的模型安全的应用到多方数据上。&lt;/span&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;作为安全开发者，你不需要任何AI背景，&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;仅仅实现安全计算的基本算子，就可以支持多种前端框架。&lt;/span&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;并且，你可以方便的部署和运维，&lt;strong&gt;在安全和性能之间折中，找到最佳的落地方案。&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;h3&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;3.SPU的架构&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/h3&gt;&lt;section&gt;&lt;span&gt;介绍完是什么和为什么之后，我们简单介绍一下&lt;strong&gt;SPU的架构&lt;/strong&gt;。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;SPU上层对接了XLA-HLO，然后利用MLIR将HLO翻译成SPU IR，最后交给SPU VM进行解释执行，如图：&lt;/span&gt;&lt;/section&gt;&lt;h4&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;Workflow&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h4&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.7748538011695907&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/rczZsXZbI36fYZDdjEibwGbxq2WPknjgiclib3S9qAqlGFjrrIlhcm2aA7tIredI0Dg4ktW3G0GdnTibVIS8NkkTZQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1368&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;基本工作流程是：&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;ol class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;开发人员用自己熟悉的框架建模，然后用AI compiler将模型编译成 XLA IR。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;SPU compiler将XLA IR编译成SPU IR（SPU字节码）&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;参与方（Alice/Bob/Charlie) 将数据 infeed 给SPU VM&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;SPU VM执行字节码，接收输入，安全计算，并且产生输出&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;参与方协商将结果解密输出到某处&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h4&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;Why XLA？&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h4&gt;&lt;section&gt;&lt;span&gt;这里对于XLA不熟悉的同学进行一个简单介绍，&lt;strong&gt;XLA 是一种针对特定领域的线性代数编译器，&lt;/strong&gt;是tensorflow内部实现的一个子模块，使用编译器相关技术用来加速模型的执行。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1.370023419203747&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/rczZsXZbI36fYZDdjEibwGbxq2WPknjgicstc1neYPkImVogW1D38aKDtnf88ich2U5R9g1E92fASJS6Ks9zW5Ricw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;427&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;span&gt;我们可以将S&lt;/span&gt;&lt;span&gt;PU理解成一个带安全语义的Backend，对接XLA的理由&lt;/span&gt;&lt;span&gt;&lt;strong&gt;是Tensorflow/Jax/PyTorch计算图最终都可以翻译到XLA IR，只要SPU可以解释和执行XLA IR，理论上就可以原生支持多种AI前端&lt;/strong&gt;。所以理论上并不是选择了XLA编译器，而是选择了XLA IR 作为AI和MPC的桥梁。&lt;/span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;h4&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;Arch&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h4&gt;&lt;section&gt;&lt;span&gt;下面简单介绍一下SPU的编译和执行过程&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.9320882852292021&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/rczZsXZbI36fYZDdjEibwGbxq2WPknjgicoam4jurprX2ia9lLRcg14jbOQ7xSHhXwgQmCuaGBtElRhYcnciaBlDIg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;589&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;前端，我们依赖AI前端将python代码翻译成XLA IR&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;编译器，我们使用MLIR技术栈对HLO进行优化并翻译成PPHLO（SPU字节码）&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;运行时，我们逐渐将Tensor ops拆解，经过SPU HAL(硬件抽象层，处理fxp/int)，最终dispatch到协议层&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;协议层只需要实现Ring or Field上的基础运算即可&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;section&gt;&lt;span&gt;最终，通过编译时和运行时的层层翻译，&lt;strong&gt;SPU将AI前端和MPC后端解耦，使得在SPU中扩展的任何安全协议都可以无感的支持多种前端&lt;/strong&gt;。&lt;/span&gt;&lt;/section&gt;&lt;h4&gt;&lt;span&gt;Optimization&lt;/span&gt;&lt;/h4&gt;&lt;section&gt;&lt;span&gt;SPU完全自主研发，所以我们可以针对安全计算的特点进行优化，比如&lt;/span&gt;&lt;/section&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;针对MPC延时敏感的计算类型进行并发调度&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;针对特定协议设计特殊的VM指令集&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;基于C++语言，开发者可以得到Low-level access，更有效的榨取性能&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;section&gt;&lt;span&gt;具体细节在此不再复述。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;SPU依然在一个高速迭代过程中，隐语期待更多的AI专家、编译专家、安全专家参与共建。&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;&lt;span/&gt;&lt;strong/&gt;&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.5625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/rczZsXZbI34aV1PKibdSZMklqawRmmQKHv7NxlSRb70gNuicZicBeWE4Bb2ibqtotOVjJ13VpULmicYxPDC4VkfJUyg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1280&quot;/&gt;&lt;/section&gt;&lt;section class=&quot;mp_profile_iframe_wrp&quot;&gt;&lt;mpprofile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mpprofile&quot; data-id=&quot;MzA5NTQ0MTI4OA==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/rczZsXZbI36CJlTPowUY45OYvYBhibUlHEicJrdoroy7Qw82lIs8iaoutazt8hXR4mqDIBrLyI18Nq5vnHBicOxWxw/0?wx_fmt=png&quot; data-nickname=&quot;隐语的小剧场&quot; data-alias=&quot;secret-flow&quot; data-signature=&quot;隐语开源社区、隐私计算技术科普、隐私计算行业资讯&quot; data-from=&quot;0&quot;/&gt;&lt;/section&gt;&lt;/div&gt;

          
        &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>0fc8c8cee47c42dcdc409ae41a5706cb</guid>
<title>全新的 React 组件设计理念 Headless UI</title>
<link>https://toutiao.io/k/r3bxt2g</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot; data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;/h2&gt;&lt;section class=&quot;mp_profile_iframe_wrp&quot;&gt;&lt;mp-common-profile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mpprofile&quot; data-id=&quot;MzIwNDMyMTg4Ng==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/wIDSOebZK4NvWoUN1gSpNiaxwF4VLvroSV4fibB1a5iaLEaR23sVIW9ickg4StvsXlxnPpslKAltA6mvJUhkT2PsaA/0?wx_fmt=png&quot; data-nickname=&quot;JavaScript 每日一练&quot; data-alias=&quot;&quot; data-signature=&quot;每天一道JavaScript 实战题，让大家平时多多积累实用的知识，提高开发效率，才有更多的时间摸鱼。&quot; data-from=&quot;0&quot; data-is_biz_ban=&quot;0&quot;/&gt;&lt;/section&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;前言&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其实，最早接触 Headless UI 是在去年，碰巧看到了一个非常前沿且优秀的组件库 ---- Chakra UI，这个组件库本身就是 Headless UI 的实践者，同时也是 CSS-IN-JS 的集大成者。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我当时看过之后，就对该理念产生了很大的兴趣，同时工作中也正好有机会实践（着手公司开源组件库大版本重构），因此对该理念也有一定的实践经验。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那么今天，也是想和大家分享介绍下这项还算前沿的技术，另一方面是也算是个人的一份技术总结，这里也希望感兴趣的小伙伴可以在评论区探讨。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;契机：React Hooks 的诞生&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;React Hooks 可以说是 Headless UI 得以实现的基石，为什么这么说，这里我们首先聊聊 React Hooks。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;React Hooks 是什么&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们都知道，React Hooks 是在 V16.8 版本诞生了，是它让我们的函数组件真正拥有了状态。如下图，我们以数字累加这个功能举例，可以看到对于同样的功能，React Hooks 的写法相对于过去类组件的写法从代码上会减少一丢丢。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.296039603960396&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/e5Dzv8p9XdQB6ne45Ke8TLpEAHFia2dAespDTckkkiatvsIdFPx0axexb9TlpGibibKTa3177gibTU2lAj99Kick3xIQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2020&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但仅仅是因为如此才支持它吗？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们要知道，在 React v16.8 之前，一般情况下，普通的 UI 渲染直接使用函数组件就好，需要使用 state 或者其他副作用之类功能时，才会使用类组件。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;两者分工也算合理，那么 hooks 的诞生又是为何？仅仅是为函数组件赋能吗？从使用者的角度来说，这显然说不过去，徒增了学习成本不说，还多了一个纠结选项（函数组件 vs 类组件）。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;React Hooks 的意义&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以，事情并没有那么简单。我们可以推断，对于 hooks 它肯定解决一些“&lt;strong&gt;「类组件存在的不足或痛点”」&lt;/strong&gt; ，这里就不卖关子，罗列 2 点：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;状态逻辑在组件之间难以复用&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在过去，状态逻辑的复用往往会采用高阶组件来实现。但劣势也非常明显，需要&lt;strong&gt;「在原来的组件外再包裹一层父容器。」&lt;/strong&gt; 导致层级冗余，甚至嵌套地狱，引来了很多吐槽点：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;相信使用 Redux 的同学都知道，为了快速状态管理到组件的注入，会使用 &lt;code&gt;connect&lt;/code&gt; 对组件进行包裹，但是随着项目迭代，打开 DevTools 查看时发现 DOM 往往臃肿不堪。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5902992776057792&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/e5Dzv8p9XdQB6ne45Ke8TLpEAHFia2dAeP9p141vEP0EFHKlUY6gmM4WA7m4Hj1bB3LK2LBNs7QYEK9CgiacbkmA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1938&quot;/&gt;&lt;/figure&gt;&lt;ol start=&quot;2&quot; data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;复杂组件变得难以理解和维护&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;复杂组件本身就很复杂，但是类组件让其变得更贱难以理解和维护。比如：在一个生命周期函数中往往存在&lt;strong&gt;「不相干的逻辑混杂」&lt;/strong&gt;在一起，或者&lt;strong&gt;「一组相干的逻辑分散」&lt;/strong&gt;在不同的生命周期函数中，这里分别举个例子：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;在 &lt;code&gt;componentWillReceiveProps&lt;/code&gt; **中往往写入不相干 props 更新渲染的判断逻辑），对于一次更新，往往会有一些无效的执行，拉低执行效率&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;在 &lt;code&gt;componentDidMount&lt;/code&gt; 中注册事件，在 &lt;code&gt;componentWillUnmount&lt;/code&gt; 中卸载该事件），往往容易写出 bug 甚至忘记。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;长期以往我们的代码只会变得糟糕难懂。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5948453608247423&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/e5Dzv8p9XdQB6ne45Ke8TLpEAHFia2dAezwucPyx8snRhSfNuytNBfnTnCD0Dtibp1VMKIyXdggmiadE0u9uCeJyA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1940&quot;/&gt;&lt;/figure&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;React Hooks 对组件开发的影响&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;通过 React Hooks，我们可以把组件的状态逻辑抽离成自定义 hooks，相干的逻辑放在一个 Hook 里，不相干的拆分成不同的 hook，最终在组件需要时引入，实现状态逻辑在不同组件之间复用。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6345256609642301&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/e5Dzv8p9XdQB6ne45Ke8TLpEAHFia2dAeZJHjDyUMXWiaGb68jydPEwxaYNEUh1pnPexWU3G004649MPgWmPNY1w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1286&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;正是因为 React Hooks 的诞生，使 Headless UI 组件在技术上成为可能，这也是它为什么最近才开始流行的原因。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;什么是 HeadLess UI&lt;/span&gt;&lt;/h2&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;Headless UI 的定义&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Headless UI 目前社区还在探索实践阶段，这里我对它做了个简单定义：Headless UI &lt;strong&gt;「一套基于 React Hooks 的组件开发设计理念，强调只负责组件的状态及交互逻辑，而不管标签和样式。」&lt;/strong&gt; 其本质思想其实就是关注点分离：将组件的“状态及交互逻辑”和“UI 展示层”实现解耦。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;Headless UI 组件&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;从实体上看，Headless UI 组件就是一个 React Hook。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5587905935050392&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/e5Dzv8p9XdQB6ne45Ke8TLpEAHFia2dAeFjx1hZsRuKZOty3FV7icqGl7DiaYI9PetUNcTMnZVcOypuQO0Cicd5cWA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1786&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;从表象上来看，Headless UI 组件其实就是一个什么也不渲染的组件。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6077844311377245&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/e5Dzv8p9XdQB6ne45Ke8TLpEAHFia2dAeulMRIHBkHDNoUtib3giaxHclcLurluibUgOjs7geCUVWibRvicoePTic0f5A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;668&quot;/&gt;&lt;/figure&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;为什么会有 Headless UI&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那么我们为什么需要一个啥也不渲染的组件呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里我们还是以数字加减这个功能举例，先思考设计实现一个数字加减器 &lt;code&gt;Counter&lt;/code&gt; 组件。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;传统版组件的设计痛点&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;按照传统的模式，我们可能会直接去编写导出一个名字叫 &lt;code&gt;Counter&lt;/code&gt; 组件，然后使用上直接渲染它即可，对于组件的功能通过 props 设置，比如非受控初始数字值。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.3365921787709497&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/e5Dzv8p9XdQB6ne45Ke8TLpEAHFia2dAe9NBPOOQS46Rh7WUCh0icIicBxxWwAicEAlCWHWICrMaBva5OtJF6cDFRA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1432&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那么这么做有什么满足不了的痛点呢？我们这里随便举个场景，然后分别来从&lt;strong&gt;「组件的使用者、维护者以及服务的产品」&lt;/strong&gt;三个角度来分析下。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;使用者 - 高定制业务场景如何实现满足？&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;现在我们业务有这样的诉求：左右两个加减按钮要求支持长按后悬浮展示 Tooltip 提示。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.465625&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/e5Dzv8p9XdQB6ne45Ke8TLpEAHFia2dAeC6ELov4xWY9KAejLT68MQZhr7f9ub1PAB3Z7dhk23vLHWx3m2p6MVg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;640&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其实从产品角度这个需求很朴实，提升交互体验嘛。但是如果按照之前传统的组件设计，那就头疼了。它一整个都是组件库里面暴露出来的（假设哈），怎么去侵入到里面给加减按钮加 Tooltip 呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其实，对于组件这样定制业务场景的诉求，我们一般解决思路可能是这样：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.7481060606060606&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/e5Dzv8p9XdQB6ne45Ke8TLpEAHFia2dAeECibWOZmb0osPkic5REDuZxS6VoiaFl1Nb1Sp1QbMGO2352IVmKXOwicOQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1056&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;随着方案越往后选择，我们的代价是越来越高的，脸上的痛苦面具也越来越明显。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;维护者 - &lt;strong&gt;「组件」&lt;/strong&gt; &lt;strong&gt;「API」&lt;/strong&gt; &lt;strong&gt;「日趋复杂，功能扩展 &amp;amp; 向下兼容的苦恼？」&lt;/strong&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;对于维护者而言，如果要去满足这样的诉求，那么他可能会这么做。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;一开始，需求比较简单，我们可以通过新增 API 动态注入要实现的功能，对于上面的诉求，我们可能会新增 &lt;code&gt;xxxButtonTooltipText&lt;/code&gt; 之类的 API 来实现 Tooltip 文案的配置；&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;一周后，又需要加减按钮支持 Icon 自定义，我们可能会添加 &lt;code&gt;xxxButtonText&lt;/code&gt; 之类的 API 来满足；&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;又过了2周，我们又想支持 Tooltip 展示方位配置，避免遮挡核心内容展示，我们可能会添加 &lt;code&gt;xxxButtonTooltipPlacement&lt;/code&gt; 。。。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;日复一日，组件 API 数快速扩展，最后，维护者发现实在忍受不了了，决定尝试使用 &lt;code&gt;Render Props&lt;/code&gt; 设计，以此一劳永逸，于是新增了 &lt;code&gt;xxxButtonRender&lt;/code&gt; 支持加减按钮自定义函数渲染。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.42545871559633025&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/e5Dzv8p9XdQB6ne45Ke8TLpEAHFia2dAe1vqgONc8CnGbAk1IWLCcLklFL2l8Bdpb6sP1rlPuibbHedATJhFwQMQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1744&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们发现，通过这么做，一个简单的组件变得日趋复杂，不仅仅存在功能冗余实现，而且后面还要考虑功能扩展以及向下兼容，脸上的痛苦面具也逐渐明显。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;另外，对于使用者，当想使用一个组件发现有几页的 API 数量时，也会浅叹一声，功能难以检索到，而且大部分可能都不需要，面对性能优化也难以入手。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;strong&gt;「产品：如何快速打造好用定制的品牌」&lt;/strong&gt; &lt;strong&gt;「UI」&lt;/strong&gt; &lt;strong&gt;「？」&lt;/strong&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;对于一个产品，最重要的一点就是塑造产品本身的品牌形象和产品特色。对于用户最直接接触的 UI 交互，那更是至关重要。那么&lt;strong&gt;「如何快速打造好用定制的品牌 UI 呢？」&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;还是以数字加减器举例，那么，它的好用可能体现在它具备较为完善且好用的能力。&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;点击加减按钮：数字加减步长&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Accessibility 可访问性&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;数字值最大最小值控制&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;... ...&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;对于它的定制，可能体现在它 UI 视图层上的差异化。如下图，仅仅是 &lt;code&gt;Counter&lt;/code&gt; 这种小组件，就有五花八门的 UI 形态。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.35785288270377735&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/e5Dzv8p9XdQB6ne45Ke8TLpEAHFia2dAe38xic30tkhOvAEzFxYF9IJs3RFmVnKSz2pBpZsJl8n9IlW90Scs56cw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2012&quot;/&gt;&lt;/figure&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;Headless UI 的解法&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;从上面的分析我们可以看到，&lt;strong&gt;「UI」&lt;/strong&gt; &lt;strong&gt;「是一个自由度非常高的玩意，而构建 UI 是一种非常品牌化和定制化的体验。」&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那么，我们能不能&lt;strong&gt;「只需复用组件的交互逻辑，布局和样式完全自定义」&lt;/strong&gt;呢？显然，Headless UI 就是干这件事情的。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5757121439280359&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/e5Dzv8p9XdQB6ne45Ke8TLpEAHFia2dAeiaO13yXCH81UqmP7ApsK6lIYde9PeB3ibNhDRyFbbsC5fDJWOyGa2iaVg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1334&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;对于 Headless UI 组件，我们要做到第一件事，就是分析和抽离组件的状态以及交互逻辑。对于 &lt;code&gt;Counter&lt;/code&gt; 组件，它的状态逻辑大致如下：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5493492407809111&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/e5Dzv8p9XdQB6ne45Ke8TLpEAHFia2dAe1tOrvmicgTBIHTl9zRVVRPWNS8EoQ5AfDqibR2PkE07P8kAqto4CHUFQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;3688&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们把这些状态逻辑收敛到一个叫 &lt;code&gt;useCounter&lt;/code&gt; 的 React Hook 中。它接收用户传入的功能 API 设置，然后返回一套已处理过的全新 API。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;对于用户而言，我们只需把返回的 API 赋予到想赋予的标签上，那么就得到了一个&lt;strong&gt;「只带交互能力的无头组件。」&lt;/strong&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.47719298245614034&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/e5Dzv8p9XdQB6ne45Ke8TLpEAHFia2dAenD8ovssczgw55iaibDwAMj5lPt7bicsSiaQnta4L84TEUw8I5MUWjpD04w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1710&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;最后，我们结合设计稿进行 UI 还原，对编写自定义样式，最终就能实现一个全新数字加减器组件了；&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;另外，我们还可以将标签重新排版，然后样式改吧改吧，将按钮绝对定位一下，最终就能实现一个数字输入框组件；&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;除此之外，我们还可以基于它封装，比如原本的最大值表示总页数，插入到标签中间，样式再改吧改吧，就能实现了一个迷你版的分页器组件了。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6979591836734694&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/e5Dzv8p9XdQB6ne45Ke8TLpEAHFia2dAebeJTu1HB7awTH2sQyxYFbaD66P0C2rfdP1bibfiakFh67Q5hb7Qx4bDQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;490&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可以看到，通过 Headless UI 的设计思路，我们最终产出了一个叫 &lt;code&gt;useCounter&lt;/code&gt; 的 React Hook，&lt;strong&gt;「通过它，我们不用关心组件最为复杂且最通用的部分----交互逻辑，而是把它交给组件维护者管理；而对于经常变化需要定制的 UI 部分完全由我们自由发挥，从而实现最大化地满足业务高定制扩展的诉求，同时，也尽可能实现代码的充分复用。」&lt;/strong&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;Headless UI 的优与劣&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里我们简单梳理下 Headless UI 的优势和劣势，以及目前建议的适用场景，方便大家做技术选型和学习。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;优势&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;「有极强大的」&lt;/strong&gt; &lt;strong&gt;「UI」&lt;/strong&gt; &lt;strong&gt;「自定义发挥空间，支持高定制扩展」&lt;/strong&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可以看到 headless 的优势也非常明显，因为它更抽象，所以它拥有非常强大的&lt;strong&gt;「定制扩展能力：支持标签排版、元素组合，内容插入、样式定义等等都能满足。」&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;从上面可以看到，组件的状态逻辑可以尽可能达到最大化复用，帮助我们减小包体积，增强整体可维护性。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;因为基本都是逻辑，对于事件回调、React 运行管理等都可以快速模拟实现单测编写和回归；而 UI 部分，一般容易变化，且不容易出 bug，可以避免测试。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;劣势&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;「对开发者能力要求高，需要较强的组件抽象设计能力」&lt;/strong&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;抽象层次越高，编写难度越大。对于这样 headless 组件，我们关注的组件 API 设计和交互逻辑抽离，这非常考验开发者的组件设计能力。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;UI 层完全自定义，存在一定开发成本，因此需要评估好投入产出，对于没有特别高要求的 2b 业务的话，还是建议使用 Ant Design 这样自带 UI 规范的组件库进行开发。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;Headless UI 的生态与展望&lt;/span&gt;&lt;/h2&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;社区生态&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;关于组件，目前在国外已经有些探索和实践的案例，比如 React-Popper、React-Hook-Form、TanStack-Table，三个是组件库“三大难”，它们 stars （均上万）和活跃度都非常高，未来基于 headless UI 设计实践的组件只会越来越多。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.23820754716981132&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/e5Dzv8p9XdQB6ne45Ke8TLpEAHFia2dAeiccTTro87jxITEBk5seDtib2t5TWH8tcBeSA389kxgaQucM1C13iaI0cQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1696&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;关于组件库，我目前看到的比较不错的实践就是 Chakra-UI 组件库，整个组件库采用分层架构（这里以数字输入框组件为例）：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.3150684931506849&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/e5Dzv8p9XdQB6ne45Ke8TLpEAHFia2dAenMVhgbGpsicoBzmLwEt4UIlBgCOoeNC0j1oBQ7vuUg7JooyHn0IkEnQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;876&quot;/&gt;&lt;/figure&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;「底层」&lt;/strong&gt;使用 Headless UI 那一套模式，对外暴露相关的 React Hook，&lt;strong&gt;「保证整个组件的高定制扩展的诉求能得到最大化满足。」&lt;/strong&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.8153846153846154&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/e5Dzv8p9XdQB6ne45Ke8TLpEAHFia2dAebVnWHJPnxhqG4vqWhtJOhHo9zjFRZpJufiazic7x9zlyROWXQnk8DdSw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1300&quot;/&gt;&lt;/figure&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;而&lt;strong&gt;「上层」&lt;/strong&gt;则提供了类似于 Ant Design 这样的组件，自带默认的 UI，但不同的是每个组件都是由颗粒度更小且必要的原子组件构成，可以直接引入它们使用，这样又&lt;strong&gt;「保证大部分简单或普通的场景可以快速实现并满足。」&lt;/strong&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;注意：其实一个组件拆分成多个必要的原子组件构成，其实也算是 Headless UI 的一种实践形态，把交互逻辑生效的 API 直接绑定在必要的元素标签上，然后以原子组件暴露出来，标签的排版和样式修改也完全可以由用户自定义。&lt;/p&gt;&lt;/blockquote&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.4216417910447761&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/e5Dzv8p9XdQB6ne45Ke8TLpEAHFia2dAeZT65qq3U4S3VcO56tUI0WLzTDKdClcFPBfrZqzRicgUxHWTDGupXhag/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1608&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;另外，在 React Next 2022 大会上，也有嘉宾分享介绍 Headless UI 相关的理念，整个社区目前都处在持续发酵的阶段。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.16776909200240528&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/e5Dzv8p9XdQB6ne45Ke8TLpEAHFia2dAeYXQj34iaTCh5PjegCREdSRjDDbL1qIYupeaC8qjF1UlicOp9LE9ve2jg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;3326&quot;/&gt;&lt;/figure&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;未来展望&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;「个人认为 Headless」&lt;/strong&gt; &lt;strong&gt;「UI」&lt;/strong&gt; &lt;strong&gt;「是未来 React 组件库底层的最佳实践。」&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;对于组件库而言，可能大家都不需要读书借鉴了，而是都使用同一套组件的底层状态以及交互逻辑，在 UI 层以及细节上再进行品牌、场景定制化扩展。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5295508274231678&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/e5Dzv8p9XdQB6ne45Ke8TLpEAHFia2dAelkA193y3TeRQ7fKRFJBH8MF1ibrgUNllnwfnY6Sia1ptcTdtSicWiaaCOA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1692&quot;/&gt;&lt;/figure&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;总结&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那么，以上就是关于 headless 设计理念的全部内容。&lt;strong&gt;「通过 Headless」&lt;/strong&gt; &lt;strong&gt;「UI」&lt;/strong&gt; &lt;strong&gt;「，我们可以快速复用组件的状态以及交互逻辑，对于布局和样式实现完全自定义」&lt;/strong&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;另外，&lt;strong&gt;「Headless」&lt;/strong&gt; &lt;strong&gt;「UI」&lt;/strong&gt; &lt;strong&gt;「是一个组件库设计的新思路，也是未来组件库必然的趋势」&lt;/strong&gt;。对于前端同学而言，学习了解它也显得尤为重要。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;值得一提的是，在日常开发中，我们也可以尝试借鉴这样的思路，&lt;strong&gt;「将通用状态逻辑抽离出去，方便复用，帮助我们在日常开发提效」&lt;/strong&gt;。比如：常见的筛选过滤、分页请求列表数据的逻辑等；甚至，我们还可以将业务逻辑同 UI 交互进行抽离，比如：在&lt;strong&gt;「多端场景（Web」&lt;/strong&gt; &lt;strong&gt;「PC」&lt;/strong&gt; &lt;strong&gt;「端、小程序端、RN 端）复用同」&lt;/strong&gt;一套业务逻辑代码，实现业务逻辑复用和统一，以此大大提高我们的生产力。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;参考&lt;/span&gt;&lt;/h2&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;https://reactjs.org/docs/hooks-intro.html&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;https://medium.com/@nirbenyair/headless-components-in-react-and-why-i-stopped-using-ui-libraries-a8208197c268&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;完结。&lt;/p&gt;&lt;p&gt;作者：不败花丶&lt;/p&gt;&lt;p&gt;Github：https://github.com/Flcwl&lt;/p&gt;&lt;/blockquote&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>d8de8b0d39a7673fed713f7a1e48ca23</guid>
<title>什么时候你第一次读懂了「云技术」？</title>
<link>https://toutiao.io/k/ons4njx</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;span class=&quot;RichText ztext CopyrightRichText-richText css-4em6pe&quot; options=&quot;[object Object]&quot; itemprop=&quot;text&quot;&gt;&lt;p data-first-child=&quot;&quot; data-pid=&quot;zLJp_nf3&quot;&gt;「云技术」是一个相当广的概念，泛指基于云计算商业模式应用的网络技术、信息技术、整合技术、管理平台技术以及应用技术等的总称。&lt;/p&gt;&lt;p data-pid=&quot;HfjbgfAb&quot;&gt;我第一次接触云技术，大概是在 2011 年，中国举办了第一届云计算技术大会。&lt;/p&gt;&lt;p data-pid=&quot;pNmb3CC6&quot;&gt;彼时大家对「云计算」的认知还云里雾里。十年过去了，企业上云已经成为共识。甚至可以说，今天几乎所有企业都在某种程度上依赖着云计算。&lt;/p&gt;&lt;p data-pid=&quot;id_E9jmJ&quot;&gt;我们现在回过头来聊云计算，已经很清楚：&lt;b&gt;云计算 (Cloud Computing) 是一种计算资源交付模型。&lt;/b&gt;其中集成了各种服务器、应用程序、数据和其它资源，并通过 Internet 以服务的形式提供这些资源，且通常对资源进行了虚拟化。&lt;sup data-text=&quot;Cloud Computing&quot; data-url=&quot;https://en.wikipedia.org/wiki/Cloud_computing&quot; data-numero=&quot;1&quot; data-draft-node=&quot;inline&quot; data-draft-type=&quot;reference&quot; data-tooltip=&quot;Cloud Computing https://en.wikipedia.org/wiki/Cloud_computing&quot; data-tooltip-preset=&quot;white&quot; data-tooltip-classname=&quot;ztext-referene-tooltip&quot;&gt;&lt;a id=&quot;ref_1_0&quot; href=&quot;#ref_1&quot; data-reference-link=&quot;true&quot; aria-labelledby=&quot;ref_1&quot;&gt;[1]&lt;/a&gt;&lt;/sup&gt;&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/50/v2-5d09f7702acef20a23ac0ab01b00c6ec_720w.jpg?source=1940ef5c&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1059&quot; data-rawheight=&quot;959&quot; data-default-watermark-src=&quot;https://pic1.zhimg.com/50/v2-11217f36c5ffdf817b4ae2138fafd667_720w.jpg?source=1940ef5c&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://picd.zhimg.com/v2-5d09f7702acef20a23ac0ab01b00c6ec_r.jpg?source=1940ef5c&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1059&quot; data-rawheight=&quot;959&quot; data-default-watermark-src=&quot;https://pic1.zhimg.com/50/v2-11217f36c5ffdf817b4ae2138fafd667_720w.jpg?source=1940ef5c&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://picd.zhimg.com/v2-5d09f7702acef20a23ac0ab01b00c6ec_r.jpg?source=1940ef5c&quot; data-actualsrc=&quot;https://pic1.zhimg.com/50/v2-5d09f7702acef20a23ac0ab01b00c6ec_720w.jpg?source=1940ef5c&quot;/&gt;&lt;/figure&gt;&lt;h2 id=&quot;h_2762812178_0&quot; data-into-catalog-status=&quot;&quot;&gt;▎&lt;b&gt;从虚拟化到云原生&lt;/b&gt;&lt;/h2&gt;&lt;p data-pid=&quot;IJYh1krp&quot;&gt;&lt;b&gt;虚拟化作为云计算中最基础的关键技术，其本质是利用一种逻辑将另一种逻辑进行抽象出来。&lt;/b&gt;也就是用某种技术，将硬件的算力逻辑化，再具象成能多个独立且相互隔离的逻辑主机。&lt;/p&gt;&lt;p data-pid=&quot;DJu9LyIH&quot;&gt;怎么理解虚拟化呢？&lt;/p&gt;&lt;p data-pid=&quot;XQy1wvI_&quot;&gt;比方说最早的时候，大家把业务跑在服务器上面。但物理机就那么几个规格，有些业务可能只用到一半的资源，那能不能把空载的另一半也利用起来呢？&lt;/p&gt;&lt;p data-pid=&quot;JQBbLDhY&quot;&gt;虚拟化就让我们可以在一台物理机上跑很多虚机，虚机有不同的操作系统，它们之间互相隔离且彼此独立。使用上和物理机没有区别，称之为逻辑主机。可以理解为是云计算的 ver 1.0。&lt;/p&gt;&lt;p data-pid=&quot;HBb6MrRU&quot;&gt;&lt;b&gt;我们继续推广「虚拟」的思维&lt;/b&gt; —— 把更多的基础设施、甚至是平台服务进行池化打包，再统一提供 API 接口，IaaS 和 PasS 相继诞生。&lt;/p&gt;&lt;p data-pid=&quot;MmsiI6cQ&quot;&gt;再然后是容器，将容器作为一个载体来运行应用和服务。我们还可以将大型的复杂的单体应用分解成很多小的模块来运行，这是「微服务」。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/50/v2-8fa79f87eab8978a6f9d6409afd38c2b_720w.jpg?source=1940ef5c&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;2856&quot; data-rawheight=&quot;700&quot; data-default-watermark-src=&quot;https://pic1.zhimg.com/50/v2-9ddf06384c8eae29a7c3310c9b2fdb54_720w.jpg?source=1940ef5c&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic1.zhimg.com/v2-8fa79f87eab8978a6f9d6409afd38c2b_r.jpg?source=1940ef5c&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;2856&quot; data-rawheight=&quot;700&quot; data-default-watermark-src=&quot;https://pic1.zhimg.com/50/v2-9ddf06384c8eae29a7c3310c9b2fdb54_720w.jpg?source=1940ef5c&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic1.zhimg.com/v2-8fa79f87eab8978a6f9d6409afd38c2b_r.jpg?source=1940ef5c&quot; data-actualsrc=&quot;https://pic1.zhimg.com/50/v2-8fa79f87eab8978a6f9d6409afd38c2b_720w.jpg?source=1940ef5c&quot;/&gt;&lt;/figure&gt;&lt;p data-pid=&quot;Mf6PONiD&quot;&gt;&lt;b&gt;在这个发展过程中，不难看出云计算行业的两个趋势：&lt;/b&gt;&lt;/p&gt;&lt;p data-pid=&quot;brdZaW7j&quot;&gt;一是技术演进让开发人员可以更专注于应用程序，而非基础设施；&lt;/p&gt;&lt;p data-pid=&quot;7XQXrZ6_&quot;&gt;二是开发模式趋向于将大型复杂的单体应用程序分解为小模块执行单元。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://picd.zhimg.com/50/v2-ac49557d3c0a5dfb0e72408a1d7c9ce3_720w.jpg?source=1940ef5c&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1600&quot; data-rawheight=&quot;920&quot; data-default-watermark-src=&quot;https://pic1.zhimg.com/50/v2-3206a4db2b4b6046c57b1799e033d58a_720w.jpg?source=1940ef5c&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://picd.zhimg.com/v2-ac49557d3c0a5dfb0e72408a1d7c9ce3_r.jpg?source=1940ef5c&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1600&quot; data-rawheight=&quot;920&quot; data-default-watermark-src=&quot;https://pic1.zhimg.com/50/v2-3206a4db2b4b6046c57b1799e033d58a_720w.jpg?source=1940ef5c&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://picd.zhimg.com/v2-ac49557d3c0a5dfb0e72408a1d7c9ce3_r.jpg?source=1940ef5c&quot; data-actualsrc=&quot;https://picd.zhimg.com/50/v2-ac49557d3c0a5dfb0e72408a1d7c9ce3_720w.jpg?source=1940ef5c&quot;/&gt;&lt;/figure&gt;&lt;p data-pid=&quot;Rz9twuGq&quot;&gt;这个发展历程至当下，便是「云原生」了。&lt;b&gt;具体来讲，云原生包含了以下三个方面：&lt;/b&gt;&lt;/p&gt;&lt;ul&gt;&lt;li data-pid=&quot;OSOZytTT&quot;&gt;把应用程序切分为多个微服务；&lt;/li&gt;&lt;li data-pid=&quot;1Mf-YtCa&quot;&gt;再把每个部分打包成容器；&lt;/li&gt;&lt;li data-pid=&quot;G5-vF24f&quot;&gt;并且动态地编排这些容器以优化系统资源。&lt;/li&gt;&lt;/ul&gt;&lt;p data-pid=&quot;QPtnoHTr&quot;&gt;在 Gartner 2022 年顶级战略技术报告中提及：当前能够帮助企业完成数字化转型与信息流变现的技术趋势中，云原生平台 (Cloud Native Platforms) 首当其冲。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://picd.zhimg.com/50/v2-9220adefdc066f003e50b077c0bfef75_720w.jpg?source=1940ef5c&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;2007&quot; data-rawheight=&quot;968&quot; data-default-watermark-src=&quot;https://picd.zhimg.com/50/v2-6733b8be2bf2f428916e9f60d1869f7a_720w.jpg?source=1940ef5c&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://picd.zhimg.com/v2-9220adefdc066f003e50b077c0bfef75_r.jpg?source=1940ef5c&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;2007&quot; data-rawheight=&quot;968&quot; data-default-watermark-src=&quot;https://picd.zhimg.com/50/v2-6733b8be2bf2f428916e9f60d1869f7a_720w.jpg?source=1940ef5c&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://picd.zhimg.com/v2-9220adefdc066f003e50b077c0bfef75_r.jpg?source=1940ef5c&quot; data-actualsrc=&quot;https://picd.zhimg.com/50/v2-9220adefdc066f003e50b077c0bfef75_720w.jpg?source=1940ef5c&quot;/&gt;&lt;figcaption&gt;报告预测：至 2025 年，云原生平台将成为 95% 以上新数字计划的基础，而在 2021 年尚不足 40%，发展空间充分&lt;/figcaption&gt;&lt;/figure&gt;&lt;h2 id=&quot;h_2762812178_1&quot; data-into-catalog-status=&quot;&quot;&gt;▎&lt;b&gt;业务需求主导技术选型&lt;/b&gt;&lt;/h2&gt;&lt;p data-pid=&quot;w1P_c15-&quot;&gt;&lt;b&gt;从「知道」到「读懂」云技术，还有关键的一步 —— 理解业务需求。&lt;/b&gt;&lt;/p&gt;&lt;p data-pid=&quot;Xxg6f3MM&quot;&gt;技术的提出，可能是实验室里研究员的灵光乍现。而技术的应用，则需要用户的使用和企业的支持。换句话来说：上云可能我已经知道了，但是我为什么要用云原生呢？&lt;/p&gt;&lt;p data-pid=&quot;e1QoHVTG&quot;&gt;&lt;b&gt;重点在于「交付业务价值」，构建和整合基础架构所产生的工作量不能成为负累：&lt;/b&gt;&lt;/p&gt;&lt;h3 id=&quot;h_2762812178_2&quot; data-into-catalog-status=&quot;&quot;&gt;&lt;b&gt;一方面是成本：&lt;/b&gt;&lt;/h3&gt;&lt;p data-pid=&quot;IeuAlhAI&quot;&gt;云原生减少了操作系统虚拟化这层的资源损耗，也就变相降低了服务器的成本。在架构层面，云原生将应用程序切分成很多的微服务，并打包成容器，拆分粒度更细，切分的资源成本也就更小。&lt;/p&gt;&lt;h3 id=&quot;h_2762812178_3&quot; data-into-catalog-status=&quot;&quot;&gt;&lt;b&gt;另一方面是增效：&lt;/b&gt;&lt;/h3&gt;&lt;p data-pid=&quot;GPGaaRpW&quot;&gt;云原生可以实现分布式调度和链路追踪，更好地去观察业务的运行状态，相当于辅助企业的整个平台。另外，围绕云原生的一些 DevOps 工具链，也让效能提升得更好，不用时刻纠结于开发与测试之间不一致的环境等等。&lt;/p&gt;&lt;p data-pid=&quot;NUmbRhsU&quot;&gt;这两点是云原生的优势。鉴于数字化转型过程中代码重构的工作量，&lt;b&gt;一般建议企业在满足自身业务需求的情况下，尽可能选择标准接口、协议的方式，或者直接使用业界事实标准来进行云原生的改造。&lt;/b&gt;&lt;/p&gt;&lt;p data-pid=&quot;mQHe9DsO&quot;&gt;&lt;b&gt;近年来，企业级软件的市场环境发生了很大改变，公开透明的开源模式逐渐成为主流。&lt;/b&gt;&lt;/p&gt;&lt;p data-pid=&quot;8T3Xz2DW&quot;&gt;下图是 Intel 的开源云计算，其中虚线标志表示该项目由 Intel 发起，并且贡献到开源社区的。图里我们能看到包括 IaaS、SaaS、边缘计算和容器运行时等等的开源项目。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://picx.zhimg.com/50/v2-bbdb041741a0ea5f35cb35d8c1dd56f0_720w.jpg?source=1940ef5c&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;2146&quot; data-rawheight=&quot;1329&quot; data-default-watermark-src=&quot;https://pica.zhimg.com/50/v2-ab57f1d44a579ad8a07bfd9210b573ec_720w.jpg?source=1940ef5c&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic1.zhimg.com/v2-bbdb041741a0ea5f35cb35d8c1dd56f0_r.jpg?source=1940ef5c&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;2146&quot; data-rawheight=&quot;1329&quot; data-default-watermark-src=&quot;https://pica.zhimg.com/50/v2-ab57f1d44a579ad8a07bfd9210b573ec_720w.jpg?source=1940ef5c&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic1.zhimg.com/v2-bbdb041741a0ea5f35cb35d8c1dd56f0_r.jpg?source=1940ef5c&quot; data-actualsrc=&quot;https://picx.zhimg.com/50/v2-bbdb041741a0ea5f35cb35d8c1dd56f0_720w.jpg?source=1940ef5c&quot;/&gt;&lt;figcaption&gt;Intel 的开源云计算&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-pid=&quot;sh17Nta3&quot;&gt;其中，开源项目 Kubernetes, AKA K8s 是业界最受欢迎的底层调度平台，也是云原生的基石。在云原生落地实践的过程中，大部分企业会选择 K8s 作为其云原生的底层调度平台。&lt;/p&gt;&lt;p data-pid=&quot;5SWR4Jds&quot;&gt;尽管市面上云原生技术生态蓬勃发展，但这种开源自主的模式，对于技术底蕴较弱的用户而言，还是可能会面临无从下手的困境。&lt;/p&gt;&lt;p data-pid=&quot;yJ6mM_0b&quot;&gt;Intel 在帮助企业落地云原生时也看到了一些问题，比方说创建容器时间过长、容器扩展速度慢、资源利用率低等等。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/50/v2-c7283961d1b17efe2a5976cca2d3af00_720w.jpg?source=1940ef5c&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1565&quot; data-rawheight=&quot;841&quot; data-default-watermark-src=&quot;https://picd.zhimg.com/50/v2-c2d132e72b2ec3e62cb84ca11d8d252a_720w.jpg?source=1940ef5c&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic1.zhimg.com/v2-c7283961d1b17efe2a5976cca2d3af00_r.jpg?source=1940ef5c&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1565&quot; data-rawheight=&quot;841&quot; data-default-watermark-src=&quot;https://picd.zhimg.com/50/v2-c2d132e72b2ec3e62cb84ca11d8d252a_720w.jpg?source=1940ef5c&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic1.zhimg.com/v2-c7283961d1b17efe2a5976cca2d3af00_r.jpg?source=1940ef5c&quot; data-actualsrc=&quot;https://pic1.zhimg.com/50/v2-c7283961d1b17efe2a5976cca2d3af00_720w.jpg?source=1940ef5c&quot;/&gt;&lt;/figure&gt;&lt;p data-pid=&quot;rST_nfhP&quot;&gt;为此，Intel 在 K8s 社区里也做了很多相关工作：&lt;/p&gt;&lt;ul&gt;&lt;li data-pid=&quot;HQhUedke&quot;&gt;基于快照 + 热代码块来创建容器，以解决容器创建时间过长的问题；&lt;/li&gt;&lt;li data-pid=&quot;oFHpw2cZ&quot;&gt;利用分片式多调度器来面对低吞吐量 / RPS / 突发并发等；&lt;/li&gt;&lt;li data-pid=&quot;Hp1OXqj5&quot;&gt;通过弹性 POD 自动扩展来加快容器扩展速度；&lt;/li&gt;&lt;li data-pid=&quot;1UZAVDtV&quot;&gt;基于遥测的快速预测，用于实时扩展集群的决策；&lt;/li&gt;&lt;li data-pid=&quot;kl48cf8X&quot;&gt;动态插入/删除 POD 中的 Sidecar 容器解决 Sidecar 资源开销的问题&lt;/li&gt;&lt;li data-pid=&quot;Avxgr0KD&quot;&gt;……&lt;/li&gt;&lt;/ul&gt;&lt;p data-pid=&quot;wakqQn0F&quot;&gt;这些不同类型的技术方案，使其能够根据企业用户所处行业特性、数字初始化复杂程度进行灵活定制。&lt;/p&gt;&lt;p data-pid=&quot;xqqDIs7Z&quot;&gt;但是，仅靠软件层面的技术方案仍然差点意思，虽然云原生让开发者更专注于应用层面的研究，可云原生的性能调优对 IT 底层设施的要求可一点都不低。应用想获得最优的性能，需要在基础设施层就提供稳定可靠和极致的性能。&lt;/p&gt;&lt;p data-pid=&quot;kcvP6L7H&quot;&gt;我尝试自下而上，从架构的角度探索云原生的最佳实践。&lt;/p&gt;&lt;h2 id=&quot;h_2762812178_4&quot; data-into-catalog-status=&quot;&quot;&gt;▎&lt;b&gt;架构设计优化数字化转型&lt;/b&gt;&lt;/h2&gt;&lt;p data-pid=&quot;EDQQjlur&quot;&gt;随着越来越多的应用在云原生平台中产生或迁移，与这些现有应用整合的需求只会不断增加。&lt;b&gt;在此背景下，通过架构的设计和搭建选择适合企业自身业务的云原生项目变得尤为重要。&lt;/b&gt;&lt;/p&gt;&lt;p data-pid=&quot;mR-O57P_&quot;&gt;大部分企业在选择了 K8s 作为云原生的底层调度平台后，会随着业务需求的增加，发现无法依托单一的技术来融入云原生生态，继而持续地做「加法」：诸如使用 Prometheus 技术栈来掌握平台情况；而后，又要进行日志管理，开始做相应的微服务架构……&lt;/p&gt;&lt;p data-pid=&quot;jazF9vSQ&quot;&gt;这并没有错，但不是最优解。&lt;/p&gt;&lt;h3 id=&quot;h_2762812178_5&quot; data-into-catalog-status=&quot;&quot;&gt;&lt;b&gt;一个思想是：用架构思维为云原生做减法！&lt;/b&gt;&lt;/h3&gt;&lt;p data-pid=&quot;ziEtYYV3&quot;&gt;换言之，用户只需要面对一个产品，就能享受整个云原生团队的服务。这「一个」产品，是不是也可以包含底层硬件？&lt;/p&gt;&lt;p data-pid=&quot;LC3mX9sD&quot;&gt;我们知道 Intel 是芯片厂商。除此之外，Intel 也前瞻性地布局了包括计算、网络、存储、安全在内的全部产品线能够在 K8s 平台快速集成和稳定使用。使得以 K8s 为技术标准的用户，不仅能够在 Intel 平台上获得超预期体验，还能集成各种插件、管理技术，获得更多的功能加速与容器业务的优化。&lt;/p&gt;&lt;p data-pid=&quot;6V7QOJlj&quot;&gt;一直以来，企业级硬件测试与调优，都是耗费 IT 人员精力的大头。现在，以 K8s 为代表的开源软件为核心组件，基于 Intel 云原生技术的硬件，调整架构方式后的软硬全栈方案让云基础设施有更强的弹性伸缩能力支撑上层业务。&lt;/p&gt;&lt;p data-pid=&quot;YrEpDsfU&quot;&gt;&lt;b&gt;架构思维的精髓在于软硬结合，理解底层原理才能更好地实践上层应用。&lt;/b&gt;&lt;/p&gt;&lt;p data-pid=&quot;CIu2xulc&quot;&gt;在当前云原生生态环境下，不同于传统虚拟化平台与硬件之间的弱关联，云原生容器化的平台上，软件应用效率和硬件技术的关系更紧密。&lt;/p&gt;&lt;p data-pid=&quot;IJp2Ff18&quot;&gt;未来算力提升的趋势是异构计算，GPU /FPGA/ASIC 等硬件将发挥更多的能力。&lt;/p&gt;&lt;p data-pid=&quot;IzaShc8x&quot;&gt;在异构架构中，硬件会越来越多地通过云原生平台，给应用带来价值。软硬件协同一体调试才能让容器平台的运行达到更好的性能。&lt;/p&gt;&lt;p data-pid=&quot;xoD2gDix&quot;&gt;在基于 K8s 的架构上，Intel 通过优化的技术实践来完成对用户云原生应用场景的支持。而在整个云原生生态层面，Intel 基于长期的技术趋势探索与开源生态共建，来帮助企业用户完成不同技术现状的实践落地。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://picd.zhimg.com/50/v2-b71ff740e063d4f032e40bab2a60818b_720w.jpg?source=1940ef5c&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1080&quot; data-rawheight=&quot;589&quot; data-default-watermark-src=&quot;https://picx.zhimg.com/50/v2-c86c7fc9664de8c97d146dc86e88a14b_720w.jpg?source=1940ef5c&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://picd.zhimg.com/v2-b71ff740e063d4f032e40bab2a60818b_r.jpg?source=1940ef5c&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1080&quot; data-rawheight=&quot;589&quot; data-default-watermark-src=&quot;https://picx.zhimg.com/50/v2-c86c7fc9664de8c97d146dc86e88a14b_720w.jpg?source=1940ef5c&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://picd.zhimg.com/v2-b71ff740e063d4f032e40bab2a60818b_r.jpg?source=1940ef5c&quot; data-actualsrc=&quot;https://picd.zhimg.com/50/v2-b71ff740e063d4f032e40bab2a60818b_720w.jpg?source=1940ef5c&quot;/&gt;&lt;figcaption&gt;Intel 云原生战略&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-pid=&quot;tZ6_K7mW&quot;&gt;从知道「云技术」的名词，到接触业务，再到能用架构的思维去看待这项技术，我才能说读懂了。&lt;/p&gt;&lt;p data-pid=&quot;a6DsjhZs&quot;&gt;现在 Intel 携手国际学术期刊《科学》(Science／AAAS) 推出了一项公益学习课程《架构师成长计划》，涵盖了十个热门垂直领域的主体。旨在为数据科学家、架构师和 IT 开发者们提供学习资源与公益培训，帮助架构师群体进行系统学习、拓展与创新。&lt;/p&gt;&lt;p data-pid=&quot;ZA833Y1C&quot;&gt;感兴趣的各位可以自行观看需要的课程，链接我放这里了：&lt;/p&gt;&lt;a target=&quot;_blank&quot; href=&quot;https://link.zhihu.com/?target=https%3A//bizwebcast.intel.cn/planlist.aspx&quot; data-draft-node=&quot;block&quot; data-draft-type=&quot;link-card&quot; data-image=&quot;https://pic2.zhimg.com/v2-2380d188eb2cbcea227c8827ba38b859_120x160.jpg&quot; data-image-width=&quot;288&quot; data-image-height=&quot;408&quot; data-text=&quot;架构师成长计划（第二季）&quot; class=&quot;LinkCard new&quot;&gt;&lt;span class=&quot;LinkCard-contents&quot;&gt;&lt;span class=&quot;LinkCard-title loading&quot; data-text=&quot;true&quot;/&gt;&lt;span class=&quot;LinkCard-desc loading&quot;/&gt;&lt;/span&gt;&lt;span class=&quot;LinkCard-image LinkCard-image--default&quot;/&gt;&lt;/a&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/50/v2-c798c948a00488e50c497b8215c986a9_720w.jpg?source=1940ef5c&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1059&quot; data-rawheight=&quot;590&quot; data-default-watermark-src=&quot;https://pic1.zhimg.com/50/v2-665af96fc2bc2a953caee8029727b2e8_720w.jpg?source=1940ef5c&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pica.zhimg.com/v2-c798c948a00488e50c497b8215c986a9_r.jpg?source=1940ef5c&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1059&quot; data-rawheight=&quot;590&quot; data-default-watermark-src=&quot;https://pic1.zhimg.com/50/v2-665af96fc2bc2a953caee8029727b2e8_720w.jpg?source=1940ef5c&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pica.zhimg.com/v2-c798c948a00488e50c497b8215c986a9_r.jpg?source=1940ef5c&quot; data-actualsrc=&quot;https://pic1.zhimg.com/50/v2-c798c948a00488e50c497b8215c986a9_720w.jpg?source=1940ef5c&quot;/&gt;&lt;/figure&gt;&lt;p/&gt;&lt;h2&gt;参考&lt;/h2&gt;&lt;ol class=&quot;ReferenceList&quot;&gt;&lt;li id=&quot;ref_1&quot; tabindex=&quot;0&quot;&gt;&lt;a class=&quot;ReferenceList-backLink&quot; href=&quot;#ref_1_0&quot; aria-label=&quot;back&quot; data-reference-link=&quot;true&quot;&gt;^&lt;/a&gt;&lt;span&gt;Cloud Computing&lt;/span&gt; &lt;a href=&quot;https://en.wikipedia.org/wiki/Cloud_computing&quot; class=&quot;external&quot; target=&quot;_blank&quot; rel=&quot;noopener noreferrer&quot;&gt;https://en.wikipedia.org/wiki/Cloud_computing&lt;/a&gt;&lt;/li&gt;&lt;/ol&gt;&lt;/span&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>