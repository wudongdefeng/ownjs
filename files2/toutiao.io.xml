<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>25f3f75ea94dea8931f23672cca7d455</guid>
<title>聊聊Java中代码优化的30个小技巧</title>
<link>https://toutiao.io/k/jv8g1r6</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot; data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;/h2&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;大家好，我是苏三，又跟大家见面了。&lt;/span&gt;&lt;/h2&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;前言&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我之前写过两篇关于优化相关的问题：《&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzkwNjMwMTgzMQ==&amp;amp;mid=2247490473&amp;amp;idx=1&amp;amp;sn=ba07d64aa8c89054bd263efd660d3a3f&amp;amp;chksm=c0ebc341f79c4a579a6f41465df0459a696ab8ef0499a5f6fd76269af1064fde0286afdb027d&amp;amp;token=751314179&amp;amp;lang=zh_CN&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;聊聊sql优化的15个小技巧&lt;/a&gt;》和《&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzkwNjMwMTgzMQ==&amp;amp;mid=2247490731&amp;amp;idx=1&amp;amp;sn=29ed0295c7990157a3a56ba33cf7f8be&amp;amp;chksm=c0ebc443f79c4d55a2bac81744992c96f97737e5d0717ec99231f4d08f57a7f0220eafdac9c9&amp;amp;token=660773166&amp;amp;lang=zh_CN&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;聊聊接口性能优化的11个小技巧&lt;/a&gt;》，发表之后，在全网受到广大网友的好评。阅读量和点赞率都很高，说明了这类文章的价值。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;今天接着优化这个话题，我们一起聊聊Java中代码优化的30个小技巧，希望会对你有所帮助。&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.8313253012048193&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ibJZVicC7nz5gqHibQQHSJ4vj82XVnOgXBSsU9ic3SneiahUCRSjva6M3gbGFxut8tpXCGkemeH8ibE42v0xwM88BcWg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1660&quot;/&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;1.用String.format拼接字符串&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;不知道你有没有拼接过字符串，特别是那种有多个参数，字符串比较长的情况。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;比如现在有个需求：要用get请求调用第三方接口，url后需要拼接多个参数。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;以前我们的请求地址是这样拼接的：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;String url = &lt;span&gt;&quot;http://susan.sc.cn?userName=&quot;&lt;/span&gt;+userName+&lt;span&gt;&quot;&amp;amp;age=&quot;&lt;/span&gt;+age+&lt;span&gt;&quot;&amp;amp;address=&quot;&lt;/span&gt;+address+&lt;span&gt;&quot;&amp;amp;sex=&quot;&lt;/span&gt;+sex+&lt;span&gt;&quot;&amp;amp;roledId=&quot;&lt;/span&gt;+roleId;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;字符串使用&lt;code&gt;+&lt;/code&gt;号拼接，非常容易出错。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;后面优化了一下，改为使用&lt;code&gt;StringBuilder&lt;/code&gt;拼接字符串：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;StringBuilder urlBuilder = &lt;span&gt;new&lt;/span&gt; StringBuilder(&lt;span&gt;&quot;http://susan.sc.cn?&quot;&lt;/span&gt;);&lt;br/&gt;urlBuilder.append(&lt;span&gt;&quot;userName=&quot;&lt;/span&gt;)&lt;br/&gt;.append(userName)&lt;br/&gt;.append(&lt;span&gt;&quot;&amp;amp;age=&quot;&lt;/span&gt;)&lt;br/&gt;.append(age)&lt;br/&gt;.append(&lt;span&gt;&quot;&amp;amp;address=&quot;&lt;/span&gt;)&lt;br/&gt;.append(address)&lt;br/&gt;.append(&lt;span&gt;&quot;&amp;amp;sex=&quot;&lt;/span&gt;)&lt;br/&gt;.append(sex)&lt;br/&gt;.append(&lt;span&gt;&quot;&amp;amp;roledId=&quot;&lt;/span&gt;)&lt;br/&gt;.append(roledId);&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;代码优化之后，稍微直观点。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但还是看起来比较别扭。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这时可以使用&lt;code&gt;String.format&lt;/code&gt;方法优化：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;String requestUrl = &lt;span&gt;&quot;http://susan.sc.cn?userName=%s&amp;amp;age=%s&amp;amp;address=%s&amp;amp;sex=%s&amp;amp;roledId=%s&quot;&lt;/span&gt;;&lt;br/&gt;String url = String.format(requestUrl,userName,age,address,sex,roledId);&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;代码的可读性，一下子提升了很多。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们平常可以使用&lt;code&gt;String.format&lt;/code&gt;方法拼接url请求参数，日志打印等字符串。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;但不建议在for循环中用它拼接字符串，因为它的执行效率，比使用+号拼接字符串，或者使用StringBuilder拼接字符串都要慢一些。&lt;/p&gt;&lt;/blockquote&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;2.创建可缓冲的IO流&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;IO流&lt;/code&gt;想必大家都使用得比较多，我们经常需要把数据&lt;code&gt;写入&lt;/code&gt;某个文件，或者从某个文件中&lt;code&gt;读取&lt;/code&gt;数据到&lt;code&gt;内存&lt;/code&gt;中，甚至还有可能把文件a，从目录b，&lt;code&gt;复制&lt;/code&gt;到目录c下等。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;JDK给我们提供了非常丰富的API，可以去操作IO流。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;例如：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;IoTest1&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;(String[] args)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        FileInputStream fis = &lt;span&gt;null&lt;/span&gt;;&lt;br/&gt;        FileOutputStream fos = &lt;span&gt;null&lt;/span&gt;;&lt;br/&gt;        &lt;span&gt;try&lt;/span&gt; {&lt;br/&gt;            File srcFile = &lt;span&gt;new&lt;/span&gt; File(&lt;span&gt;&quot;/Users/dv_susan/Documents/workspace/jump/src/main/java/com/sue/jump/service/test1/1.txt&quot;&lt;/span&gt;);&lt;br/&gt;            File destFile = &lt;span&gt;new&lt;/span&gt; File(&lt;span&gt;&quot;/Users/dv_susan/Documents/workspace/jump/src/main/java/com/sue/jump/service/test1/2.txt&quot;&lt;/span&gt;);&lt;br/&gt;            fis = &lt;span&gt;new&lt;/span&gt; FileInputStream(srcFile);&lt;br/&gt;            fos = &lt;span&gt;new&lt;/span&gt; FileOutputStream(destFile);&lt;br/&gt;            &lt;span&gt;int&lt;/span&gt; len;&lt;br/&gt;            &lt;span&gt;while&lt;/span&gt; ((len = fis.read()) != -&lt;span&gt;1&lt;/span&gt;) {&lt;br/&gt;                fos.write(len);&lt;br/&gt;            }&lt;br/&gt;            fos.flush();&lt;br/&gt;        } &lt;span&gt;catch&lt;/span&gt; (IOException e) {&lt;br/&gt;            e.printStackTrace();&lt;br/&gt;        } &lt;span&gt;finally&lt;/span&gt; {&lt;br/&gt;            &lt;span&gt;try&lt;/span&gt; {&lt;br/&gt;                &lt;span&gt;if&lt;/span&gt; (fos != &lt;span&gt;null&lt;/span&gt;) {&lt;br/&gt;                    fos.close();&lt;br/&gt;                }&lt;br/&gt;            } &lt;span&gt;catch&lt;/span&gt; (IOException e) {&lt;br/&gt;                e.printStackTrace();&lt;br/&gt;            }&lt;br/&gt;            &lt;span&gt;try&lt;/span&gt; {&lt;br/&gt;                &lt;span&gt;if&lt;/span&gt; (fis != &lt;span&gt;null&lt;/span&gt;) {&lt;br/&gt;                    fis.close();&lt;br/&gt;                }&lt;br/&gt;            } &lt;span&gt;catch&lt;/span&gt; (IOException e) {&lt;br/&gt;                e.printStackTrace();&lt;br/&gt;            }&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个例子主要的功能，是将1.txt文件中的内容复制到2.txt文件中。这例子使用普通的IO流从功能的角度来说，也能满足需求，但性能却不太好。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;因为这个例子中，从1.txt文件中读一个字节的数据，就会马上写入2.txt文件中，需要非常频繁的读写文件。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;优化：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;IoTest&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;(String[] args)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        BufferedInputStream bis = &lt;span&gt;null&lt;/span&gt;;&lt;br/&gt;        BufferedOutputStream bos = &lt;span&gt;null&lt;/span&gt;;&lt;br/&gt;        FileInputStream fis = &lt;span&gt;null&lt;/span&gt;;&lt;br/&gt;        FileOutputStream fos = &lt;span&gt;null&lt;/span&gt;;&lt;br/&gt;        &lt;span&gt;try&lt;/span&gt; {&lt;br/&gt;            File srcFile = &lt;span&gt;new&lt;/span&gt; File(&lt;span&gt;&quot;/Users/dv_susan/Documents/workspace/jump/src/main/java/com/sue/jump/service/test1/1.txt&quot;&lt;/span&gt;);&lt;br/&gt;            File destFile = &lt;span&gt;new&lt;/span&gt; File(&lt;span&gt;&quot;/Users/dv_susan/Documents/workspace/jump/src/main/java/com/sue/jump/service/test1/2.txt&quot;&lt;/span&gt;);&lt;br/&gt;            fis = &lt;span&gt;new&lt;/span&gt; FileInputStream(srcFile);&lt;br/&gt;            fos = &lt;span&gt;new&lt;/span&gt; FileOutputStream(destFile);&lt;br/&gt;            bis = &lt;span&gt;new&lt;/span&gt; BufferedInputStream(fis);&lt;br/&gt;            bos = &lt;span&gt;new&lt;/span&gt; BufferedOutputStream(fos);&lt;br/&gt;            &lt;span&gt;byte&lt;/span&gt;[] buffer = &lt;span&gt;new&lt;/span&gt; &lt;span&gt;byte&lt;/span&gt;[&lt;span&gt;1024&lt;/span&gt;];&lt;br/&gt;            &lt;span&gt;int&lt;/span&gt; len;&lt;br/&gt;            &lt;span&gt;while&lt;/span&gt; ((len = bis.read(buffer)) != -&lt;span&gt;1&lt;/span&gt;) {&lt;br/&gt;                bos.write(buffer, &lt;span&gt;0&lt;/span&gt;, len);&lt;br/&gt;            }&lt;br/&gt;            bos.flush();&lt;br/&gt;        } &lt;span&gt;catch&lt;/span&gt; (IOException e) {&lt;br/&gt;            e.printStackTrace();&lt;br/&gt;        } &lt;span&gt;finally&lt;/span&gt; {&lt;br/&gt;            &lt;span&gt;try&lt;/span&gt; {&lt;br/&gt;                &lt;span&gt;if&lt;/span&gt; (bos != &lt;span&gt;null&lt;/span&gt;) {&lt;br/&gt;                    bos.close();&lt;br/&gt;                }&lt;br/&gt;                &lt;span&gt;if&lt;/span&gt; (fos != &lt;span&gt;null&lt;/span&gt;) {&lt;br/&gt;                    fos.close();&lt;br/&gt;                }&lt;br/&gt;            } &lt;span&gt;catch&lt;/span&gt; (IOException e) {&lt;br/&gt;                e.printStackTrace();&lt;br/&gt;            }&lt;br/&gt;            &lt;span&gt;try&lt;/span&gt; {&lt;br/&gt;                &lt;span&gt;if&lt;/span&gt; (bis != &lt;span&gt;null&lt;/span&gt;) {&lt;br/&gt;                    bis.close();&lt;br/&gt;                }&lt;br/&gt;                &lt;span&gt;if&lt;/span&gt; (fis != &lt;span&gt;null&lt;/span&gt;) {&lt;br/&gt;                    fis.close();&lt;br/&gt;                }&lt;br/&gt;            } &lt;span&gt;catch&lt;/span&gt; (IOException e) {&lt;br/&gt;                e.printStackTrace();&lt;br/&gt;            }&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个例子使用&lt;code&gt;BufferedInputStream&lt;/code&gt;和&lt;code&gt;BufferedOutputStream&lt;/code&gt;创建了&lt;code&gt;可缓冲&lt;/code&gt;的输入输出流。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;最关键的地方是定义了一个buffer字节数组，把从1.txt文件中读取的数据临时保存起来，后面再把该buffer字节数组的数据，一次性批量写入到2.txt中。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这样做的好处是，减少了读写文件的次数，而我们都知道读写文件是非常耗时的操作。也就是说使用可缓存的输入输出流，可以提升IO的性能，特别是遇到文件非常大时，效率会得到显著提升。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;3.减少循环次数&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在我们日常开发中，循环遍历集合是必不可少的操作。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但如果循环层级比较深，循环中套循环，可能会影响代码的执行效率。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;反例&lt;/code&gt;：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;for&lt;/span&gt;(User user: userList) {&lt;br/&gt;   &lt;span&gt;for&lt;/span&gt;(Role role: roleList) {&lt;br/&gt;      &lt;span&gt;if&lt;/span&gt;(user.getRoleId().equals(role.getId())) {&lt;br/&gt;         user.setRoleName(role.getName());&lt;br/&gt;      }&lt;br/&gt;   }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个例子中有两层循环，如果userList和roleList数据比较多的话，需要循环遍历很多次，才能获取我们所需要的数据，非常消耗cpu资源。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;正例&lt;/code&gt;：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;Map&amp;lt;Long, List&amp;lt;Role&amp;gt;&amp;gt; roleMap = roleList.stream().collect(Collectors.groupingBy(Role::getId));&lt;br/&gt;&lt;span&gt;for&lt;/span&gt; (User user : userList) {&lt;br/&gt;    List&amp;lt;Role&amp;gt; roles = roleMap.get(user.getRoleId());&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt;(CollectionUtils.isNotEmpty(roles)) {&lt;br/&gt;        user.setRoleName(roles.get(&lt;span&gt;0&lt;/span&gt;).getName());&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;减少循环次数，最简单的办法是，把第二层循环的集合变成&lt;code&gt;map&lt;/code&gt;，这样可以直接通过&lt;code&gt;key&lt;/code&gt;，获取想要的&lt;code&gt;value&lt;/code&gt;数据。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;虽说map的key存在&lt;code&gt;hash冲突&lt;/code&gt;的情况，但遍历存放数据的&lt;code&gt;链表&lt;/code&gt;或者&lt;code&gt;红黑树&lt;/code&gt;的&lt;code&gt;时间复杂度&lt;/code&gt;，比遍历整个list集合要小很多。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;4.用完资源记得及时关闭&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在我们日常开发中，可能经常访问&lt;code&gt;资源&lt;/code&gt;，比如：获取数据库连接，读取文件等。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们以获取数据库连接为例。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;反例&lt;/code&gt;：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;//1. 加载驱动类&lt;/span&gt;&lt;br/&gt;Class.forName(&lt;span&gt;&quot;com.mysql.jdbc.Driver&quot;&lt;/span&gt;);&lt;br/&gt;&lt;span&gt;//2. 创建连接&lt;/span&gt;&lt;br/&gt;Connection connection = DriverManager.getConnection(&lt;span&gt;&quot;jdbc:mysql//localhost:3306/db?allowMultiQueries=true&amp;amp;useUnicode=true&amp;amp;characterEncoding=UTF-8&quot;&lt;/span&gt;,&lt;span&gt;&quot;root&quot;&lt;/span&gt;,&lt;span&gt;&quot;123456&quot;&lt;/span&gt;);&lt;br/&gt;&lt;span&gt;//3.编写sql&lt;/span&gt;&lt;br/&gt;String sql =&lt;span&gt;&quot;select * from user&quot;&lt;/span&gt;;&lt;br/&gt;&lt;span&gt;//4.创建PreparedStatement&lt;/span&gt;&lt;br/&gt;PreparedStatement pstmt = conn.prepareStatement(sql);&lt;br/&gt;&lt;span&gt;//5.获取查询结果&lt;/span&gt;&lt;br/&gt;ResultSet rs = pstmt.execteQuery();&lt;br/&gt;&lt;span&gt;while&lt;/span&gt;(rs.next()){&lt;br/&gt;   &lt;span&gt;int&lt;/span&gt; id = rs.getInt(&lt;span&gt;&quot;id&quot;&lt;/span&gt;);&lt;br/&gt;   String name = rs.getString(&lt;span&gt;&quot;name&quot;&lt;/span&gt;);&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上面这段代码可以正常运行，但却犯了一个很大的错误，即：ResultSet、PreparedStatement和Connection对象的资源，使用完之后，没有关闭。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们都知道，数据库连接是非常宝贵的资源。我们不可能一直创建连接，并且用完之后，也不回收，白白浪费数据库资源。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;正例&lt;/code&gt;：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;//1. 加载驱动类&lt;/span&gt;&lt;br/&gt;Class.forName(&lt;span&gt;&quot;com.mysql.jdbc.Driver&quot;&lt;/span&gt;);&lt;br/&gt;&lt;br/&gt;Connection connection = &lt;span&gt;null&lt;/span&gt;;&lt;br/&gt;PreparedStatement pstmt = &lt;span&gt;null&lt;/span&gt;;&lt;br/&gt;ResultSet rs = &lt;span&gt;null&lt;/span&gt;;&lt;br/&gt;&lt;span&gt;try&lt;/span&gt; {&lt;br/&gt;    &lt;span&gt;//2. 创建连接&lt;/span&gt;&lt;br/&gt;    connection = DriverManager.getConnection(&lt;span&gt;&quot;jdbc:mysql//localhost:3306/db?allowMultiQueries=true&amp;amp;useUnicode=true&amp;amp;characterEncoding=UTF-8&quot;&lt;/span&gt;,&lt;span&gt;&quot;root&quot;&lt;/span&gt;,&lt;span&gt;&quot;123456&quot;&lt;/span&gt;);&lt;br/&gt;    &lt;span&gt;//3.编写sql&lt;/span&gt;&lt;br/&gt;    String sql =&lt;span&gt;&quot;select * from user&quot;&lt;/span&gt;;&lt;br/&gt;    &lt;span&gt;//4.创建PreparedStatement&lt;/span&gt;&lt;br/&gt;    pstmt = conn.prepareStatement(sql);&lt;br/&gt;    &lt;span&gt;//5.获取查询结果&lt;/span&gt;&lt;br/&gt;    rs = pstmt.execteQuery();&lt;br/&gt;    &lt;span&gt;while&lt;/span&gt;(rs.next()){&lt;br/&gt;       &lt;span&gt;int&lt;/span&gt; id = rs.getInt(&lt;span&gt;&quot;id&quot;&lt;/span&gt;);&lt;br/&gt;       String name = rs.getString(&lt;span&gt;&quot;name&quot;&lt;/span&gt;);&lt;br/&gt;    }&lt;br/&gt;} &lt;span&gt;catch&lt;/span&gt;(Exception e) {&lt;br/&gt;  log.error(e.getMessage(),e);&lt;br/&gt;} &lt;span&gt;finally&lt;/span&gt; {&lt;br/&gt;   &lt;span&gt;if&lt;/span&gt;(rs != &lt;span&gt;null&lt;/span&gt;) {&lt;br/&gt;      rs.close();&lt;br/&gt;   }&lt;br/&gt;   &lt;br/&gt;   &lt;span&gt;if&lt;/span&gt;(pstmt != &lt;span&gt;null&lt;/span&gt;) {&lt;br/&gt;      pstmt.close();&lt;br/&gt;   }&lt;br/&gt;   &lt;br/&gt;   &lt;span&gt;if&lt;/span&gt;(connection != &lt;span&gt;null&lt;/span&gt;) {&lt;br/&gt;      connection.close();&lt;br/&gt;   }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个例子中，无论是ResultSet，或者PreparedStatement，还是Connection对象，使用完之后，都会调用&lt;code&gt;close&lt;/code&gt;方法关闭资源。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;在这里温馨提醒一句：ResultSet，或者PreparedStatement，还是Connection对象，这三者关闭资源的顺序不能反了，不然可能会出现异常。&lt;/p&gt;&lt;/blockquote&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;5.使用池技术&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们都知道，从数据库查数据，首先要连接数据库，获取&lt;code&gt;Connection&lt;/code&gt;资源。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;想让程序多线程执行，需要使用&lt;code&gt;Thread&lt;/code&gt;类创建线程，线程也是一种资源。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;通常一次数据库操作的过程是这样的：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;创建连接&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;进行数据库操作&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;关闭连接&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;而创建连接和关闭连接，是非常耗时的操作，创建连接需要同时会创建一些资源，关闭连接时，需要回收那些资源。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果用户的每一次数据库请求，程序都都需要去创建连接和关闭连接的话，可能会浪费大量的时间。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;此外，可能会导致数据库连接过多。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们都知道数据库的&lt;code&gt;最大连接数&lt;/code&gt;是有限的，以mysql为例，最大连接数是：&lt;code&gt;100&lt;/code&gt;，不过可以通过参数调整这个数量。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果用户请求的连接数超过最大连接数，就会报：&lt;code&gt;too many connections&lt;/code&gt;异常。如果有新的请求过来，会发现数据库变得不可用。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这时可以通过命令：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;show&lt;/span&gt; &lt;span&gt;variables&lt;/span&gt; &lt;span&gt;like&lt;/span&gt; max_connections&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;查看最大连接数。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;然后通过命令：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;set GLOBAL max_connections=&lt;span&gt;1000&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;手动修改最大连接数。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这种做法只能暂时缓解问题，不是一个好的方案，无法从根本上解决问题。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;最大的问题是：数据库连接数可以无限增长，不受控制。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这时我们可以使用&lt;code&gt;数据库连接池&lt;/code&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;目前Java开源的数据库连接池有：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;DBCP：是一个依赖Jakarta commons-pool对象池机制的数据库连接池。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;C3P0：是一个开放源代码的JDBC连接池，它在lib目录中与Hibernate一起发布，包括了实现jdbc3和jdbc2扩展规范说明的Connection 和Statement 池的DataSources 对象。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Druid：阿里的Druid，不仅是一个数据库连接池，还包含一个ProxyDriver、一系列内置的JDBC组件库、一个SQL Parser。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Proxool：是一个Java SQL Driver驱动程序，它提供了对选择的其它类型的驱动程序的连接池封装，可以非常简单的移植到已有代码中。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;目前用的最多的数据库连接池是:&lt;code&gt;Druid&lt;/code&gt;。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;6.反射时加缓存&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们都知道通过&lt;code&gt;反射&lt;/code&gt;创建对象实例，比使用&lt;code&gt;new&lt;/code&gt;关键字要慢很多。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;由此，不太建议在用户请求过来时，每次都通过反射&lt;code&gt;实时&lt;/code&gt;创建实例。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;有时候，为了代码的灵活性，又不得不用反射创建实例，这时该怎么办呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;答：加&lt;code&gt;缓存&lt;/code&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其实spring中就使用了大量的反射，我们以支付方法为例。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;根据前端传入不同的支付code，动态找到对应的支付方法，发起支付。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们先定义一个注解。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;@Retention&lt;/span&gt;(RetentionPolicy.RUNTIME)  &lt;br/&gt;&lt;span&gt;@Target&lt;/span&gt;(ElementType.TYPE)  &lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;@interface&lt;/span&gt; PayCode {  &lt;br/&gt;     &lt;span&gt;String &lt;span&gt;value&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt;;    &lt;br/&gt;     &lt;span&gt;String &lt;span&gt;name&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt;;  &lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在所有的支付类上都加上该注解&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;@PayCode&lt;/span&gt;(value = &lt;span&gt;&quot;alia&quot;&lt;/span&gt;, name = &lt;span&gt;&quot;支付宝支付&quot;&lt;/span&gt;)  &lt;br/&gt;&lt;span&gt;@Service&lt;/span&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;AliaPay&lt;/span&gt; &lt;span&gt;implements&lt;/span&gt; &lt;span&gt;IPay&lt;/span&gt; &lt;/span&gt;{  &lt;br/&gt;&lt;br/&gt;     &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;     &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;pay&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{  &lt;br/&gt;         System.out.println(&lt;span&gt;&quot;===发起支付宝支付===&quot;&lt;/span&gt;);  &lt;br/&gt;     }  &lt;br/&gt;}  &lt;br/&gt;&lt;br/&gt;&lt;span&gt;@PayCode&lt;/span&gt;(value = &lt;span&gt;&quot;weixin&quot;&lt;/span&gt;, name = &lt;span&gt;&quot;微信支付&quot;&lt;/span&gt;)  &lt;br/&gt;&lt;span&gt;@Service&lt;/span&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;WeixinPay&lt;/span&gt; &lt;span&gt;implements&lt;/span&gt; &lt;span&gt;IPay&lt;/span&gt; &lt;/span&gt;{  &lt;br/&gt; &lt;br/&gt;     &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;     &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;pay&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{  &lt;br/&gt;         System.out.println(&lt;span&gt;&quot;===发起微信支付===&quot;&lt;/span&gt;);  &lt;br/&gt;     }  &lt;br/&gt;} &lt;br/&gt; &lt;br/&gt;&lt;span&gt;@PayCode&lt;/span&gt;(value = &lt;span&gt;&quot;jingdong&quot;&lt;/span&gt;, name = &lt;span&gt;&quot;京东支付&quot;&lt;/span&gt;)  &lt;br/&gt;&lt;span&gt;@Service&lt;/span&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;JingDongPay&lt;/span&gt; &lt;span&gt;implements&lt;/span&gt; &lt;span&gt;IPay&lt;/span&gt; &lt;/span&gt;{  &lt;br/&gt;     &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;     &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;pay&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{  &lt;br/&gt;        System.out.println(&lt;span&gt;&quot;===发起京东支付===&quot;&lt;/span&gt;);  &lt;br/&gt;     }  &lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;然后增加最关键的类：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;@Service&lt;/span&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;PayService2&lt;/span&gt; &lt;span&gt;implements&lt;/span&gt; &lt;span&gt;ApplicationListener&lt;/span&gt;&amp;lt;&lt;span&gt;ContextRefreshedEvent&lt;/span&gt;&amp;gt; &lt;/span&gt;{  &lt;br/&gt;     &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; Map&amp;lt;String, IPay&amp;gt; payMap = &lt;span&gt;null&lt;/span&gt;;  &lt;br/&gt;     &lt;br/&gt;     &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;     &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;onApplicationEvent&lt;/span&gt;&lt;span&gt;(ContextRefreshedEvent contextRefreshedEvent)&lt;/span&gt; &lt;/span&gt;{  &lt;br/&gt;         ApplicationContext applicationContext = contextRefreshedEvent.getApplicationContext();  &lt;br/&gt;         Map&amp;lt;String, Object&amp;gt; beansWithAnnotation = applicationContext.getBeansWithAnnotation(PayCode&lt;span&gt;.&lt;span&gt;class&lt;/span&gt;)&lt;/span&gt;;  &lt;br/&gt;        &lt;br/&gt;         &lt;span&gt;if&lt;/span&gt; (beansWithAnnotation != &lt;span&gt;null&lt;/span&gt;) {  &lt;br/&gt;             payMap = &lt;span&gt;new&lt;/span&gt; HashMap&amp;lt;&amp;gt;();  &lt;br/&gt;             beansWithAnnotation.forEach((key, value) -&amp;gt;{  &lt;br/&gt;                 String bizType = value.getClass().getAnnotation(PayCode&lt;span&gt;.&lt;span&gt;class&lt;/span&gt;).&lt;span&gt;value&lt;/span&gt;()&lt;/span&gt;;  &lt;br/&gt;                 payMap.put(bizType, (IPay) value);  &lt;br/&gt;             });  &lt;br/&gt;         }  &lt;br/&gt;     }  &lt;br/&gt;    &lt;br/&gt;     &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;pay&lt;/span&gt;&lt;span&gt;(String code)&lt;/span&gt; &lt;/span&gt;{  &lt;br/&gt;        payMap.get(code).pay();  &lt;br/&gt;     }  &lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;PayService2类实现了&lt;code&gt;ApplicationListener&lt;/code&gt;接口，这样在&lt;code&gt;onApplicationEvent方法&lt;/code&gt;中，就可以拿到&lt;code&gt;ApplicationContext&lt;/code&gt;的实例。这一步，其实是在spring容器启动的时候，spring通过反射我们处理好了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们再获取打了PayCode注解的类，放到一个&lt;code&gt;map&lt;/code&gt;中，map中的&lt;code&gt;key&lt;/code&gt;就是PayCode注解中定义的value，跟code参数一致，value是支付类的实例。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这样，每次就可以每次直接通过code获取支付类实例，而不用if...else判断了。如果要加新的支付方法，只需在支付类上面打上PayCode注解定义一个新的code即可。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;注意：这种方式的code可以没有业务含义，可以是纯数字，只要不重复就行。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;7.多线程处理&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;很多时候，我们需要在某个接口中，调用其他服务的接口。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;比如有这样的业务场景：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在用户信息查询接口中需要返回：用户名称、性别、等级、头像、积分、成长值等信息。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;而用户名称、性别、等级、头像在用户服务中，积分在积分服务中，成长值在成长值服务中。为了汇总这些数据统一返回，需要另外提供一个对外接口服务。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;于是，用户信息查询接口需要调用用户查询接口、积分查询接口 和 成长值查询接口，然后汇总数据统一返回。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;调用过程如下图所示：&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;2.184049079754601&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ibJZVicC7nz5gqHibQQHSJ4vj82XVnOgXBSegV4nBn6pQ0dYTz332ibOEmveuhTbiaDUAk72mHLVzpVz0MyvetPkGGg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;326&quot;/&gt;调用远程接口总耗时 530ms = 200ms + 150ms + 180ms&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;显然这种串行调用远程接口性能是非常不好的，调用远程接口总的耗时为所有的远程接口耗时之和。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那么如何优化远程接口性能呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上面说到，既然串行调用多个远程接口性能很差，为什么不改成并行呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如下图所示：&lt;img data-ratio=&quot;0.5012285012285013&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ibJZVicC7nz5gqHibQQHSJ4vj82XVnOgXBSSNAsEvIlgoiczQbO9k60Wz61Mp4q58OXgnEYm8aLTxgRL7wk2icFzvwg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;814&quot;/&gt;调用远程接口总耗时 200ms = 200ms（即耗时最长的那次远程接口调用）&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在java8之前可以通过实现&lt;code&gt;Callable&lt;/code&gt;接口，获取线程返回结果。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;java8以后通过&lt;code&gt;CompleteFuture&lt;/code&gt;类实现该功能。我们这里以CompleteFuture为例：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; UserInfo &lt;span&gt;getUserInfo&lt;/span&gt;&lt;span&gt;(Long id)&lt;/span&gt; &lt;span&gt;throws&lt;/span&gt; InterruptedException, ExecutionException &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;final&lt;/span&gt; UserInfo userInfo = &lt;span&gt;new&lt;/span&gt; UserInfo();&lt;br/&gt;    CompletableFuture userFuture = CompletableFuture.supplyAsync(() -&amp;gt; {&lt;br/&gt;        getRemoteUserAndFill(id, userInfo);&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; Boolean.TRUE;&lt;br/&gt;    }, executor);&lt;br/&gt;&lt;br/&gt;    CompletableFuture bonusFuture = CompletableFuture.supplyAsync(() -&amp;gt; {&lt;br/&gt;        getRemoteBonusAndFill(id, userInfo);&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; Boolean.TRUE;&lt;br/&gt;    }, executor);&lt;br/&gt;&lt;br/&gt;    CompletableFuture growthFuture = CompletableFuture.supplyAsync(() -&amp;gt; {&lt;br/&gt;        getRemoteGrowthAndFill(id, userInfo);&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; Boolean.TRUE;&lt;br/&gt;    }, executor);&lt;br/&gt;    CompletableFuture.allOf(userFuture, bonusFuture, growthFuture).join();&lt;br/&gt;&lt;br/&gt;    userFuture.get();&lt;br/&gt;    bonusFuture.get();&lt;br/&gt;    growthFuture.get();&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; userInfo;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;温馨提醒一下，这两种方式别忘了使用线程池。示例中我用到了executor，表示自定义的线程池，为了防止高并发场景下，出现线程过多的问题。&lt;/p&gt;&lt;/blockquote&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;8.懒加载&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;有时候，创建对象是一个非常耗时的操作，特别是在该对象的创建过程中，还需要创建很多其他的对象时。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们以单例模式为例。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在介绍单例模式的时候，必须要先介绍它的两种非常著名的实现方式：&lt;code&gt;饿汉模式&lt;/code&gt; 和 &lt;code&gt;懒汉模式&lt;/code&gt;。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;8.1 饿汉模式&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;实例在初始化的时候就已经建好了，不管你有没有用到，先建好了再说。具体代码如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;SimpleSingleton&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;//持有自己类的引用&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; SimpleSingleton INSTANCE = &lt;span&gt;new&lt;/span&gt; SimpleSingleton();&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;//私有的构造方法&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;SimpleSingleton&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    }&lt;br/&gt;    &lt;span&gt;//对外提供获取实例的静态方法&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; SimpleSingleton &lt;span&gt;getInstance&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; INSTANCE;&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;使用饿汉模式的好处是：&lt;code&gt;没有线程安全的问题&lt;/code&gt;，但带来的坏处也很明显。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; SimpleSingleton INSTANCE = &lt;span&gt;new&lt;/span&gt; SimpleSingleton();&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;一开始就实例化对象了，如果实例化过程非常耗时，并且最后这个对象没有被使用，不是白白造成资源浪费吗？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;还真是啊。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个时候你也许会想到，不用提前实例化对象，在真正使用的时候再实例化不就可以了？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这就是我接下来要介绍的：&lt;code&gt;懒汉模式&lt;/code&gt;。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;8.2 懒汉模式&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;顾名思义就是实例在用到的时候才去创建，“比较懒”，用的时候才去检查有没有实例，如果有则返回，没有则新建。具体代码如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;SimpleSingleton2&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; SimpleSingleton2 INSTANCE;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;SimpleSingleton2&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; SimpleSingleton2 &lt;span&gt;getInstance&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (INSTANCE == &lt;span&gt;null&lt;/span&gt;) {&lt;br/&gt;            INSTANCE = &lt;span&gt;new&lt;/span&gt; SimpleSingleton2();&lt;br/&gt;        }&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; INSTANCE;&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;示例中的INSTANCE对象一开始是空的，在调用getInstance方法才会真正实例化。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;懒汉模式相对于饿汉模式，没有提前实例化对象，在真正使用的时候再实例化，在实例化对象的阶段效率更高一些。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;除了单例模式之外，懒加载的思想，使用比较多的可能是：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;spring的@Lazy注解。在spring容器启动的时候，不会调用其getBean方法初始化实例。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;mybatis的懒加载。在mybatis做级联查询的时候，比如查用户的同时需要查角色信息。如果用了懒加载，先只查用户信息，真正使用到角色了，才取查角色信息。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;9.初始化集合时指定大小&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们在实际项目开发中，需要经常使用集合，比如：ArrayList、HashMap等。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但有个问题：你在初始化集合时指定了大小的吗？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;反例&lt;/code&gt;：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;Test2&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;(String[] args)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        List&amp;lt;Integer&amp;gt; list = &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;&amp;gt;();&lt;br/&gt;        &lt;span&gt;long&lt;/span&gt; time1 = System.currentTimeMillis();&lt;br/&gt;        &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; &lt;span&gt;100000&lt;/span&gt;; i++) {&lt;br/&gt;            list.add(i);&lt;br/&gt;        }&lt;br/&gt;        System.out.println(System.currentTimeMillis() - time1);&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;执行时间：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;12&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果在初始化集合时指定了大小。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;正例&lt;/code&gt;：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;Test2&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;(String[] args)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        List&amp;lt;Integer&amp;gt; list2 = &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;&amp;gt;(&lt;span&gt;100000&lt;/span&gt;);&lt;br/&gt;        &lt;span&gt;long&lt;/span&gt; time2 = System.currentTimeMillis();&lt;br/&gt;        &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; &lt;span&gt;100000&lt;/span&gt;; i++) {&lt;br/&gt;            list2.add(i);&lt;br/&gt;        }&lt;br/&gt;        System.out.println(System.currentTimeMillis() - time2);&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;执行时间：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;6&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们惊奇的发现，在创建集合时指定了大小，比没有指定大小，添加10万个元素的效率提升了一倍。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果你看过&lt;code&gt;ArrayList&lt;/code&gt;源码，你就会发现它的默认大小是&lt;code&gt;10&lt;/code&gt;，如果添加元素超过了一定的阀值，会按&lt;code&gt;1.5&lt;/code&gt;倍的大小扩容。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;你想想，如果装10万条数据，需要扩容多少次呀？而每次扩容都需要不停的复制元素，从老集合复制到新集合中，需要浪费多少时间呀。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;10.不要满屏try...catch异常&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;以前我们在开发接口时，如果出现&lt;code&gt;异常&lt;/code&gt;，为了给用户一个更友好的提示，例如：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;@RequestMapping&lt;/span&gt;(&lt;span&gt;&quot;/test&quot;&lt;/span&gt;)&lt;br/&gt;&lt;span&gt;@RestController&lt;/span&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;TestController&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@GetMapping&lt;/span&gt;(&lt;span&gt;&quot;/add&quot;&lt;/span&gt;)&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; String &lt;span&gt;add&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;int&lt;/span&gt; a = &lt;span&gt;10&lt;/span&gt; / &lt;span&gt;0&lt;/span&gt;;&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;&quot;成功&quot;&lt;/span&gt;;&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果不做任何处理，当我们请求add接口时，执行结果直接报错：&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.2833333333333333&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ibJZVicC7nz5gqHibQQHSJ4vj82XVnOgXBS6NAiaefsh2FScQC5sFLbnUPCiaJcNuZlHHUYWiaapdBwCvTsr3ZTsN0xA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;what？用户能直接看到错误信息？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这种交互方式给用户的体验非常差，为了解决这个问题，我们通常会在接口中捕获异常：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;@GetMapping&lt;/span&gt;(&lt;span&gt;&quot;/add&quot;&lt;/span&gt;)&lt;br/&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; String &lt;span&gt;add&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    String result = &lt;span&gt;&quot;成功&quot;&lt;/span&gt;;&lt;br/&gt;    &lt;span&gt;try&lt;/span&gt; {&lt;br/&gt;        &lt;span&gt;int&lt;/span&gt; a = &lt;span&gt;10&lt;/span&gt; / &lt;span&gt;0&lt;/span&gt;;&lt;br/&gt;    } &lt;span&gt;catch&lt;/span&gt; (Exception e) {&lt;br/&gt;        result = &lt;span&gt;&quot;数据异常&quot;&lt;/span&gt;;&lt;br/&gt;    }&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; result;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;接口改造后，出现异常时会提示：“数据异常”，对用户来说更友好。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;看起来挺不错的，但是有问题。。。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果只是一个接口还好，但是如果项目中有成百上千个接口，都要加上异常捕获代码吗？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;答案是否定的，这时全局异常处理就派上用场了：&lt;code&gt;RestControllerAdvice&lt;/code&gt;。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;@RestControllerAdvice&lt;/span&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;GlobalExceptionHandler&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@ExceptionHandler&lt;/span&gt;(Exception&lt;span&gt;.&lt;span&gt;class&lt;/span&gt;)&lt;br/&gt;    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;String&lt;/span&gt; &lt;span&gt;handleException&lt;/span&gt;(&lt;span&gt;Exception&lt;/span&gt; &lt;span&gt;e&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (e &lt;span&gt;instanceof&lt;/span&gt; ArithmeticException) {&lt;br/&gt;            &lt;span&gt;return&lt;/span&gt; &lt;span&gt;&quot;数据异常&quot;&lt;/span&gt;;&lt;br/&gt;        }&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (e &lt;span&gt;instanceof&lt;/span&gt; Exception) {&lt;br/&gt;            &lt;span&gt;return&lt;/span&gt; &lt;span&gt;&quot;服务器内部异常&quot;&lt;/span&gt;;&lt;br/&gt;        }&lt;br/&gt;        retur nnull;&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;只需在&lt;code&gt;handleException&lt;/code&gt;方法中处理异常情况，业务接口中可以放心使用，不再需要捕获异常（有人统一处理了）。真是爽歪歪。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;11.位运算效率更高&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果你读过JDK的源码，比如：&lt;code&gt;ThreadLocal&lt;/code&gt;、&lt;code&gt;HashMap&lt;/code&gt;等类，你就会发现，它们的底层都用了&lt;code&gt;位运算&lt;/code&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;为什么开发JDK的大神们，都喜欢用位运算？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;答：因为位运算的效率更高。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在ThreadLocal的get、set、remove方法中都有这样一行代码：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;int&lt;/span&gt; i = key.threadLocalHashCode &amp;amp; (len-&lt;span&gt;1&lt;/span&gt;);&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;通过key的hashCode值，&lt;code&gt;与&lt;/code&gt;数组的长度减1。其中key就是ThreadLocal对象，&lt;code&gt;与&lt;/code&gt;数组的长度减1，相当于除以数组的长度减1，然后&lt;code&gt;取模&lt;/code&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这是一种hash算法。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;接下来给大家举个例子：假设len=16，key.threadLocalHashCode=31，&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;于是：int i = 31 &amp;amp; 15 = 15&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;相当于：int i = 31 % 16 = 15&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;计算的结果是一样的，但是使用&lt;code&gt;与运算&lt;/code&gt;效率跟高一些。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;为什么与运算效率更高？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;答：因为ThreadLocal的初始大小是&lt;code&gt;16&lt;/code&gt;，每次都是按&lt;code&gt;2&lt;/code&gt;倍扩容，数组的大小其实一直都是2的n次方。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这种数据有个规律就是高位是0，低位都是1。在做与运算时，可以不用考虑高位，因为与运算的结果必定是0。只需考虑低位的与运算，所以效率更高。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;12.巧用第三方工具类&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在Java的庞大体系中，其实有很多不错的小工具，也就是我们平常说的：&lt;code&gt;轮子&lt;/code&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果在我们的日常工作当中，能够将这些轮子用户，再配合一下idea的快捷键，可以极大得提升我们的开发效率。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果你引入&lt;code&gt;com.google.guava&lt;/code&gt;的pom文件，会获得很多好用的小工具。这里推荐一款&lt;code&gt;com.google.common.collect&lt;/code&gt;包下的集合工具：&lt;code&gt;Lists&lt;/code&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;它是在太好用了，让我爱不释手。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果你想将一个&lt;code&gt;大集合&lt;/code&gt;分成若干个&lt;code&gt;小集合&lt;/code&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;之前我们是这样做的：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;List&amp;lt;Integer&amp;gt; list = Lists.newArrayList(&lt;span&gt;1&lt;/span&gt;, &lt;span&gt;2&lt;/span&gt;, &lt;span&gt;3&lt;/span&gt;, &lt;span&gt;4&lt;/span&gt;, &lt;span&gt;5&lt;/span&gt;);&lt;br/&gt;&lt;br/&gt;List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; partitionList = Lists.newArrayList();&lt;br/&gt;&lt;span&gt;int&lt;/span&gt; size = &lt;span&gt;0&lt;/span&gt;;&lt;br/&gt;List&amp;lt;Integer&amp;gt; dataList = Lists.newArrayList();&lt;br/&gt;&lt;span&gt;for&lt;/span&gt;(Integer data : list) {&lt;br/&gt;   &lt;span&gt;if&lt;/span&gt;(size &amp;gt;= &lt;span&gt;2&lt;/span&gt;) {&lt;br/&gt;      dataList = Lists.newArrayList();&lt;br/&gt;      size = &lt;span&gt;0&lt;/span&gt;;&lt;br/&gt;   } &lt;br/&gt;   size++;&lt;br/&gt;   dataList.add(data);&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;将list按size=2分成多个小集合，上面的代码看起来比较麻烦。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果使用&lt;code&gt;Lists&lt;/code&gt;的&lt;code&gt;partition&lt;/code&gt;方法，可以这样写代码：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;List&amp;lt;Integer&amp;gt; list = Lists.newArrayList(&lt;span&gt;1&lt;/span&gt;, &lt;span&gt;2&lt;/span&gt;, &lt;span&gt;3&lt;/span&gt;, &lt;span&gt;4&lt;/span&gt;, &lt;span&gt;5&lt;/span&gt;);&lt;br/&gt;List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; partitionList = Lists.partition(list, &lt;span&gt;2&lt;/span&gt;);&lt;br/&gt;System.out.println(partitionList);&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;执行结果：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;[[&lt;span&gt;1&lt;/span&gt;, &lt;span&gt;2&lt;/span&gt;], [&lt;span&gt;3&lt;/span&gt;, &lt;span&gt;4&lt;/span&gt;], [&lt;span&gt;5&lt;/span&gt;]]&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个例子中，list有5条数据，我将list集合按大小为2，分成了3页，即变成3个小集合。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个是我最喜欢的方法之一，经常在项目中使用。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;比如有个需求：现在有5000个id，需要调用批量用户查询接口，查出用户数据。但如果你直接查5000个用户，单次接口响应时间可能会非常慢。如果改成分页处理，每次只查500个用户，异步调用10次接口，就不会有单次接口响应慢的问题。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果你了解更多非常有用的第三方工具类的话，可以看看我的另一篇文章《&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzkwNjMwMTgzMQ==&amp;amp;mid=2247495296&amp;amp;idx=1&amp;amp;sn=6ff4affb2d00dce011c08d8eb5448d7a&amp;amp;chksm=c0e83668f79fbf7ead1410a998f4d4406badd65f943ca1b6833a7b1d663d5d5d0808e4c462e4&amp;amp;token=1690710950&amp;amp;lang=zh_CN&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;吐血推荐17个提升开发效率的“轮子”&lt;/a&gt;》。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;13.用同步代码块代替同步方法&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在某些业务场景中，为了防止多个线程并发修改某个共享数据，造成数据异常。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;为了解决并发场景下，多个线程同时修改数据，造成数据不一致的情况。通常情况下，我们会：&lt;code&gt;加锁&lt;/code&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但如果锁加得不好，导致&lt;code&gt;锁的粒度太粗&lt;/code&gt;，也会非常影响接口性能。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在java中提供了&lt;code&gt;synchronized&lt;/code&gt;关键字给我们的代码加锁。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;通常有两种写法：&lt;code&gt;在方法上加锁&lt;/code&gt; 和 &lt;code&gt;在代码块上加锁&lt;/code&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;先看看如何在方法上加锁：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;synchronized&lt;/span&gt; &lt;span&gt;doSave&lt;/span&gt;&lt;span&gt;(String fileUrl)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    mkdir();&lt;br/&gt;    uploadFile(fileUrl);&lt;br/&gt;    sendMessage(fileUrl);&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里加锁的目的是为了防止并发的情况下，创建了相同的目录，第二次会创建失败，影响业务功能。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但这种直接在方法上加锁，锁的粒度有点粗。因为doSave方法中的上传文件和发消息方法，是不需要加锁的。只有创建目录方法，才需要加锁。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们都知道文件上传操作是非常耗时的，如果将整个方法加锁，那么需要等到整个方法执行完之后才能释放锁。显然，这会导致该方法的性能很差，变得得不偿失。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这时，我们可以改成在代码块上加锁了，具体代码如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;doSave&lt;/span&gt;&lt;span&gt;(String path,String fileUrl)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;synchronized&lt;/span&gt;(&lt;span&gt;this&lt;/span&gt;) {&lt;br/&gt;      &lt;span&gt;if&lt;/span&gt;(!exists(path)) {&lt;br/&gt;          mkdir(path);&lt;br/&gt;       }&lt;br/&gt;    }&lt;br/&gt;    uploadFile(fileUrl);&lt;br/&gt;    sendMessage(fileUrl);&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这样改造之后，锁的粒度一下子变小了，只有并发创建目录功能才加了锁。而创建目录是一个非常快的操作，即使加锁对接口的性能影响也不大。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;最重要的是，其他的上传文件和发送消息功能，任然可以并发执行。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;14.不用的数据及时清理&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在Java中保证线程安全的技术有很多，可以使用&lt;code&gt;synchroized&lt;/code&gt;、&lt;code&gt;Lock&lt;/code&gt;等关键字给代码块&lt;code&gt;加锁&lt;/code&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但是它们有个共同的特点，就是加锁会对代码的性能有一定的损耗。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其实，在jdk中还提供了另外一种思想即：&lt;code&gt;用空间换时间&lt;/code&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;没错，使用&lt;code&gt;ThreadLocal&lt;/code&gt;类就是对这种思想的一种具体体现。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;ThreadLocal为每个使用变量的线程提供了一个独立的变量副本，这样每一个线程都能独立地改变自己的副本，而不会影响其它线程所对应的副本。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;ThreadLocal的用法大致是这样的：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;先创建一个CurrentUser类，其中包含了ThreadLocal的逻辑。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;CurrentUser&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; ThreadLocal&amp;lt;UserInfo&amp;gt; THREA_LOCAL = &lt;span&gt;new&lt;/span&gt; ThreadLocal();&lt;br/&gt;    &lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;(UserInfo userInfo)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        THREA_LOCAL.set(userInfo);&lt;br/&gt;    }&lt;br/&gt;    &lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; UserInfo &lt;span&gt;get&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;       THREA_LOCAL.get();&lt;br/&gt;    }&lt;br/&gt;    &lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;remove&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;       THREA_LOCAL.remove();&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;ol start=&quot;2&quot; data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;在业务代码中调用CurrentUser类。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;doSamething&lt;/span&gt;&lt;span&gt;(UserDto userDto)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;   UserInfo userInfo = convert(userDto);&lt;br/&gt;   CurrentUser.set(userInfo);&lt;br/&gt;   ...&lt;br/&gt;&lt;br/&gt;   &lt;span&gt;//业务代码&lt;/span&gt;&lt;br/&gt;   UserInfo userInfo = CurrentUser.get();&lt;br/&gt;   ...&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在业务代码的第一行，将userInfo对象设置到CurrentUser，这样在业务代码中，就能通过CurrentUser.get()获取到刚刚设置的userInfo对象。特别是对业务代码调用层级比较深的情况，这种用法非常有用，可以减少很多不必要传参。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但在高并发的场景下，这段代码有问题，只往ThreadLocal存数据，数据用完之后并没有及时清理。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;ThreadLocal即使使用了&lt;code&gt;WeakReference&lt;/code&gt;（弱引用）也可能会存在&lt;code&gt;内存泄露&lt;/code&gt;问题，因为 entry对象中只把key(即threadLocal对象)设置成了弱引用，但是value值没有。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那么，如何解决这个问题呢？&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;doSamething&lt;/span&gt;&lt;span&gt;(UserDto userDto)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;   UserInfo userInfo = convert(userDto);&lt;br/&gt;   &lt;br/&gt;   &lt;span&gt;try&lt;/span&gt;{&lt;br/&gt;     CurrentUser.set(userInfo);&lt;br/&gt;     ...&lt;br/&gt;     &lt;br/&gt;     &lt;span&gt;//业务代码&lt;/span&gt;&lt;br/&gt;     UserInfo userInfo = CurrentUser.get();&lt;br/&gt;     ...&lt;br/&gt;   } &lt;span&gt;finally&lt;/span&gt; {&lt;br/&gt;      CurrentUser.remove();&lt;br/&gt;   }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;需要在&lt;code&gt;finally&lt;/code&gt;代码块中，调用&lt;code&gt;remove&lt;/code&gt;方法清理没用的数据。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;15.用equals方法比较是否相等&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;不知道你在项目中有没有见过，有些同事对&lt;code&gt;Integer&lt;/code&gt;类型的两个参数使用&lt;code&gt;==&lt;/code&gt;号比较是否相等？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;反正我见过的，那么这种用法对吗？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我的回答是看具体场景，不能说一定对，或不对。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;有些状态字段，比如：orderStatus有：-1(未下单)，0（已下单），1（已支付），2（已完成），3（取消），5种状态。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这时如果用==判断是否相等：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;Integer orderStatus1 = &lt;span&gt;new&lt;/span&gt; Integer(&lt;span&gt;1&lt;/span&gt;);&lt;br/&gt;Integer orderStatus2 = &lt;span&gt;new&lt;/span&gt; Integer(&lt;span&gt;1&lt;/span&gt;);&lt;br/&gt;System.out.println(orderStatus1 == orderStatus2);&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;返回结果会是true吗？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;答案：是false。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;有些同学可能会反驳，Integer中不是有范围是：&lt;code&gt;-128-127&lt;/code&gt;的缓存吗？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;为什么是false？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;先看看Integer的构造方法：&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.2754237288135593&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/ibJZVicC7nz5gqHibQQHSJ4vj82XVnOgXBSGoDWXuoUVJoGiayMxPSkuKayLarclUJxotziaQOBf9FLygUF9G4GBKoA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;472&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;它其实并没有用到&lt;code&gt;缓存&lt;/code&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那么缓存是在哪里用的？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;答案在&lt;code&gt;valueOf&lt;/code&gt;方法中：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.226457399103139&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/ibJZVicC7nz5gqHibQQHSJ4vj82XVnOgXBSrichYZ6WD1k8jazQES87KDkhNu2wGhM526E9lqcEEbtPbticaIWXXXNg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;892&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果上面的判断改成这样：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;String orderStatus1 = &lt;span&gt;new&lt;/span&gt; String(&lt;span&gt;&quot;1&quot;&lt;/span&gt;);&lt;br/&gt;String orderStatus2 = &lt;span&gt;new&lt;/span&gt; String(&lt;span&gt;&quot;1&quot;&lt;/span&gt;);&lt;br/&gt;System.out.println(Integer.valueOf(orderStatus1) == Integer.valueOf(orderStatus2));&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;返回结果会是true吗？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;答案：还真是true。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们要养成良好编码习惯，尽量少用==判断两个Integer类型数据是否相等，只有在上述非常特殊的场景下才相等。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;而应该改成使用&lt;code&gt;equals&lt;/code&gt;方法判断：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;Integer orderStatus1 = &lt;span&gt;new&lt;/span&gt; Integer(&lt;span&gt;1&lt;/span&gt;);&lt;br/&gt;Integer orderStatus2 = &lt;span&gt;new&lt;/span&gt; Integer(&lt;span&gt;1&lt;/span&gt;);&lt;br/&gt;System.out.println(orderStatus1.equals(orderStatus2));&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;运行结果为true。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;16.避免创建大集合&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;很多时候，我们在日常开发中，需要创建集合。比如：为了性能考虑，从数据库查询某张表的所有数据，一次性加载到内存的某个集合中，然后做业务逻辑处理。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;例如：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;List&amp;lt;User&amp;gt; userList = userMapper.getAllUser();&lt;br/&gt;&lt;span&gt;for&lt;/span&gt;(User user:userList) {&lt;br/&gt;   doSamething();&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;从数据库一次性查询出所有用户，然后在循环中，对每个用户进行业务逻辑处理。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果&lt;code&gt;用户表&lt;/code&gt;的数据量非常多时，这样userList集合会很大，可能直接导致内存不足，而使整个应用挂掉。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;针对这种情况，必须做&lt;code&gt;分页处理&lt;/code&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;例如：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; PAGE_SIZE = &lt;span&gt;500&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;int&lt;/span&gt; currentPage = &lt;span&gt;1&lt;/span&gt;;&lt;br/&gt;RequestPage page = &lt;span&gt;new&lt;/span&gt; RequestPage();&lt;br/&gt;page.setPageNo(currentPage);&lt;br/&gt;page.setPageSize(PAGE_SIZE);&lt;br/&gt;&lt;br/&gt;Page&amp;lt;User&amp;gt; pageUser = userMapper.search(page);&lt;br/&gt;&lt;br/&gt;&lt;span&gt;while&lt;/span&gt;(pageUser.getPageCount() &amp;gt;= currentPage) {&lt;br/&gt;    &lt;span&gt;for&lt;/span&gt;(User user:pageUser.getData()) {&lt;br/&gt;       doSamething();&lt;br/&gt;    }&lt;br/&gt;   page.setPageNo(++currentPage);&lt;br/&gt;   pageUser = userMapper.search(page);&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;通过上面的分页改造之后，每次从数据库中只查询&lt;code&gt;500&lt;/code&gt;条记录，保存到userList集合中，这样userList不会占用太多的内存。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;这里特别说明一下，如果你查询的表中的数据量本来就很少，一次性保存到内存中，也不会占用太多内存，这种情况也可以不做分页处理。&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;此外，还有中特殊的情况，即表中的记录数并算不多，但每一条记录，都有很多字段，单条记录就占用很多内存空间，这时也需要做分页处理，不然也会有问题。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;整体的原则是要尽量避免创建大集合，导致内存不足的问题，但是具体多大才算大集合。目前没有一个唯一的衡量标准，需要结合实际的业务场景进行单独分析。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;17.状态用枚举&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在我们建的表中，有很多状态字段，比如：订单状态、禁用状态、删除状态等。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;每种状态都有多个值，代表不同的含义。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;比如订单状态有：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果没有使用枚举，一般是这样做的：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; ORDER_STATUS_CREATE = &lt;span&gt;1&lt;/span&gt;;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; ORDER_STATUS_PAY = &lt;span&gt;2&lt;/span&gt;;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; ORDER_STATUS_DONE = &lt;span&gt;3&lt;/span&gt;;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; ORDER_STATUS_CANCEL = &lt;span&gt;4&lt;/span&gt;;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; String ORDER_STATUS_CREATE_MESSAGE = &lt;span&gt;&quot;下单&quot;&lt;/span&gt;;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; String ORDER_STATUS_PAY = &lt;span&gt;&quot;下单&quot;&lt;/span&gt;;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; String ORDER_STATUS_DONE = &lt;span&gt;&quot;下单&quot;&lt;/span&gt;;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; String ORDER_STATUS_CANCEL = &lt;span&gt;&quot;下单&quot;&lt;/span&gt;;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;需要定义很多静态常量，包含不同的状态和状态的描述。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;使用&lt;code&gt;枚举&lt;/code&gt;定义之后，代码如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;enum&lt;/span&gt; OrderStatusEnum {  &lt;br/&gt;     CREATE(&lt;span&gt;1&lt;/span&gt;, &lt;span&gt;&quot;下单&quot;&lt;/span&gt;),  &lt;br/&gt;     PAY(&lt;span&gt;2&lt;/span&gt;, &lt;span&gt;&quot;支付&quot;&lt;/span&gt;),  &lt;br/&gt;     DONE(&lt;span&gt;3&lt;/span&gt;, &lt;span&gt;&quot;完成&quot;&lt;/span&gt;),  &lt;br/&gt;     CANCEL(&lt;span&gt;4&lt;/span&gt;, &lt;span&gt;&quot;撤销&quot;&lt;/span&gt;);  &lt;br/&gt;&lt;br/&gt;     &lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; code;  &lt;br/&gt;     &lt;span&gt;private&lt;/span&gt; String message;  &lt;br/&gt;&lt;br/&gt;     OrderStatusEnum(&lt;span&gt;int&lt;/span&gt; code, String message) {  &lt;br/&gt;         &lt;span&gt;this&lt;/span&gt;.code = code;  &lt;br/&gt;         &lt;span&gt;this&lt;/span&gt;.message = message;  &lt;br/&gt;     }  &lt;br/&gt;   &lt;br/&gt;     &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; &lt;span&gt;getCode&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{  &lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;.code;  &lt;br/&gt;     }  &lt;br/&gt;&lt;br/&gt;     &lt;span&gt;&lt;span&gt;public&lt;/span&gt; String &lt;span&gt;getMessage&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{  &lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;.message;  &lt;br/&gt;     }  &lt;br/&gt;  &lt;br/&gt;     &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; OrderStatusEnum &lt;span&gt;getOrderStatusEnum&lt;/span&gt;&lt;span&gt;(&lt;span&gt;int&lt;/span&gt; code)&lt;/span&gt; &lt;/span&gt;{  &lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; Arrays.stream(OrderStatusEnum.values()).filter(x -&amp;gt; x.code == code).findFirst().orElse(&lt;span&gt;null&lt;/span&gt;);  &lt;br/&gt;     }  &lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;使用枚举改造之后，职责更单一了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;而且使用枚举的好处是：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;代码的可读性变强了，不同的状态，有不同的枚举进行统一管理和维护。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;枚举是天然单例的，可以直接使用==号进行比较。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;code和message可以成对出现，比较容易相关转换。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;枚举可以消除if...else过多问题。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;18.把固定值定义成静态常量&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;不知道你在实际的项目开发中，有没有使用过固定值？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;例如：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;if&lt;/span&gt;(user.getId() &amp;lt; &lt;span&gt;1000L&lt;/span&gt;) {&lt;br/&gt;   doSamething();&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;或者：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;if&lt;/span&gt;(Objects.isNull(user)) {&lt;br/&gt;   &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; BusinessException(&lt;span&gt;&quot;该用户不存在&quot;&lt;/span&gt;);&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其中&lt;code&gt;1000L&lt;/code&gt;和&lt;code&gt;该用户不存在&lt;/code&gt;是固定值，每次都是一样的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;既然是固定值，我们为什么不把它们定义成静态常量呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这样语义上更直观，方便统一管理和维护，更方便代码复用。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;代码优化为：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; DEFAULT_USER_ID = &lt;span&gt;1000L&lt;/span&gt;;&lt;br/&gt;...&lt;br/&gt;&lt;span&gt;if&lt;/span&gt;(user.getId() &amp;lt; DEFAULT_USER_ID) {&lt;br/&gt;   doSamething();&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;或者：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; String NOT_FOUND_MESSAGE = &lt;span&gt;&quot;该用户不存在&quot;&lt;/span&gt;;&lt;br/&gt;...&lt;br/&gt;&lt;span&gt;if&lt;/span&gt;(Objects.isNull(user)) {&lt;br/&gt;   &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; BusinessException(NOT_FOUND_MESSAGE);&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;使用&lt;code&gt;static final&lt;/code&gt;关键字修饰静态常量，&lt;code&gt;static&lt;/code&gt;表示&lt;code&gt;静态&lt;/code&gt;的意思，即类变量，而&lt;code&gt;final&lt;/code&gt;表示&lt;code&gt;不允许修改&lt;/code&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;两个关键字加在一起，告诉Java虚拟机这种变量，在内存中只有一份，在全局上是唯一的，不能修改，也就是&lt;code&gt;静态常量&lt;/code&gt;。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;19.避免大事务&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;很多小伙伴在使用spring框架开发项目时，为了方便，喜欢使用&lt;code&gt;@Transactional&lt;/code&gt;注解提供事务功能。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;没错，使用@Transactional注解这种声明式事务的方式提供事务功能，确实能少写很多代码，提升开发效率。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但也容易造成大事务，引发其他的问题。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;下面用一张图看看大事务引发的问题。&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.2759259259259259&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ibJZVicC7nz5gqHibQQHSJ4vj82XVnOgXBSElRhibpG7ykB9z1QsOon7r2NqJmoShOScCwjcdd5LibPpF5iay5ZDyuvQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;从图中能够看出，大事务问题可能会造成接口超时，对接口的性能有直接的影响。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们该如何优化大事务呢？&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;少用@Transactional注解&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;将查询(select)方法放到事务外&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;事务中避免远程调用&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;事务中避免一次性处理太多数据&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;有些功能可以非事务执行&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;有些功能可以异步处理&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;关于大事务问题我的另一篇文章《&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzkwNjMwMTgzMQ==&amp;amp;mid=2247490259&amp;amp;idx=1&amp;amp;sn=1dd11c5f49103ca303a61fc82ce406e0&amp;amp;chksm=c0ebc23bf79c4b2db58b28ef752560bd91a1932ceb6713c9b19b821db0f29e1c58275d334076&amp;amp;token=2041133408&amp;amp;lang=zh_CN&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;让人头痛的大事务问题到底要如何解决？&lt;/a&gt;》，它里面做了非常详细的介绍，如果大家感兴趣可以看看。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;20.消除过长的if...else&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们在写代码的时候，if...else的判断条件是必不可少的。不同的判断条件，走的代码逻辑通常会不一样。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;废话不多说，先看看下面的代码。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;interface&lt;/span&gt; &lt;span&gt;IPay&lt;/span&gt; &lt;/span&gt;{  &lt;br/&gt;    &lt;span&gt;&lt;span&gt;void&lt;/span&gt; &lt;span&gt;pay&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt;;  &lt;br/&gt;}  &lt;br/&gt;&lt;br/&gt;&lt;span&gt;@Service&lt;/span&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;AliaPay&lt;/span&gt; &lt;span&gt;implements&lt;/span&gt; &lt;span&gt;IPay&lt;/span&gt; &lt;/span&gt;{  &lt;br/&gt;     &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;     &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;pay&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{  &lt;br/&gt;        System.out.println(&lt;span&gt;&quot;===发起支付宝支付===&quot;&lt;/span&gt;);  &lt;br/&gt;     }  &lt;br/&gt;}  &lt;br/&gt;&lt;br/&gt;&lt;span&gt;@Service&lt;/span&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;WeixinPay&lt;/span&gt; &lt;span&gt;implements&lt;/span&gt; &lt;span&gt;IPay&lt;/span&gt; &lt;/span&gt;{  &lt;br/&gt;     &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;     &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;pay&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{  &lt;br/&gt;         System.out.println(&lt;span&gt;&quot;===发起微信支付===&quot;&lt;/span&gt;);  &lt;br/&gt;     }  &lt;br/&gt;}  &lt;br/&gt;  &lt;br/&gt;&lt;span&gt;@Service&lt;/span&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;JingDongPay&lt;/span&gt; &lt;span&gt;implements&lt;/span&gt; &lt;span&gt;IPay&lt;/span&gt; &lt;/span&gt;{  &lt;br/&gt;     &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;     &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;pay&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{  &lt;br/&gt;        System.out.println(&lt;span&gt;&quot;===发起京东支付===&quot;&lt;/span&gt;); &lt;br/&gt;     }  &lt;br/&gt;}  &lt;br/&gt;&lt;br/&gt;&lt;span&gt;@Service&lt;/span&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;PayService&lt;/span&gt; &lt;/span&gt;{  &lt;br/&gt;     &lt;span&gt;@Autowired&lt;/span&gt;&lt;br/&gt;     &lt;span&gt;private&lt;/span&gt; AliaPay aliaPay;  &lt;br/&gt;     &lt;span&gt;@Autowired&lt;/span&gt;&lt;br/&gt;     &lt;span&gt;private&lt;/span&gt; WeixinPay weixinPay;  &lt;br/&gt;     &lt;span&gt;@Autowired&lt;/span&gt;&lt;br/&gt;     &lt;span&gt;private&lt;/span&gt; JingDongPay jingDongPay;  &lt;br/&gt;   &lt;br/&gt;     &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;toPay&lt;/span&gt;&lt;span&gt;(String code)&lt;/span&gt; &lt;/span&gt;{  &lt;br/&gt;         &lt;span&gt;if&lt;/span&gt; (&lt;span&gt;&quot;alia&quot;&lt;/span&gt;.equals(code)) {  &lt;br/&gt;             aliaPay.pay();  &lt;br/&gt;         } elseif (&lt;span&gt;&quot;weixin&quot;&lt;/span&gt;.equals(code)) {  &lt;br/&gt;              weixinPay.pay();  &lt;br/&gt;         } elseif (&lt;span&gt;&quot;jingdong&quot;&lt;/span&gt;.equals(code)) {  &lt;br/&gt;              jingDongPay.pay();  &lt;br/&gt;         } &lt;span&gt;else&lt;/span&gt; {  &lt;br/&gt;              System.out.println(&lt;span&gt;&quot;找不到支付方式&quot;&lt;/span&gt;);  &lt;br/&gt;         }  &lt;br/&gt;     }  &lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;PayService类的toPay方法主要是为了发起支付，根据不同的code，决定调用用不同的支付类（比如：aliaPay）的pay方法进行支付。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这段代码有什么问题呢？也许有些人就是这么干的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;试想一下，如果支付方式越来越多，比如：又加了百度支付、美团支付、银联支付等等，就需要改toPay方法的代码，增加新的else...if判断，判断多了就会导致逻辑越来越多？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;很明显，这里违法了设计模式六大原则的：开闭原则 和 单一职责原则。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;开闭原则：对扩展开放，对修改关闭。就是说增加新功能要尽量少改动已有代码。&lt;/p&gt;&lt;/blockquote&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;单一职责原则：顾名思义，要求逻辑尽量单一，不要太复杂，便于复用。&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那么，如何优化if...else判断呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;答：使用 &lt;code&gt;策略模式&lt;/code&gt;+&lt;code&gt;工厂模式&lt;/code&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;策略模式定义了一组算法，把它们一个个封装起来, 并且使它们可相互替换。工厂模式用于封装和管理对象的创建，是一种创建型模式。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;interface&lt;/span&gt; &lt;span&gt;IPay&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;&lt;span&gt;void&lt;/span&gt; &lt;span&gt;pay&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt;;&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;@Service&lt;/span&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;AliaPay&lt;/span&gt; &lt;span&gt;implements&lt;/span&gt; &lt;span&gt;IPay&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@PostConstruct&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;init&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        PayStrategyFactory.register(&lt;span&gt;&quot;aliaPay&quot;&lt;/span&gt;, &lt;span&gt;this&lt;/span&gt;);&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;pay&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        System.out.println(&lt;span&gt;&quot;===发起支付宝支付===&quot;&lt;/span&gt;);&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;@Service&lt;/span&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;WeixinPay&lt;/span&gt; &lt;span&gt;implements&lt;/span&gt; &lt;span&gt;IPay&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@PostConstruct&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;init&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        PayStrategyFactory.register(&lt;span&gt;&quot;weixinPay&quot;&lt;/span&gt;, &lt;span&gt;this&lt;/span&gt;);&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;pay&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        System.out.println(&lt;span&gt;&quot;===发起微信支付===&quot;&lt;/span&gt;);&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;@Service&lt;/span&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;JingDongPay&lt;/span&gt; &lt;span&gt;implements&lt;/span&gt; &lt;span&gt;IPay&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@PostConstruct&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;init&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        PayStrategyFactory.register(&lt;span&gt;&quot;jingDongPay&quot;&lt;/span&gt;, &lt;span&gt;this&lt;/span&gt;);&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;pay&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        System.out.println(&lt;span&gt;&quot;===发起京东支付===&quot;&lt;/span&gt;);&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;PayStrategyFactory&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; Map&amp;lt;String, IPay&amp;gt; PAY_REGISTERS = &lt;span&gt;new&lt;/span&gt; HashMap&amp;lt;&amp;gt;();&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;register&lt;/span&gt;&lt;span&gt;(String code, IPay iPay)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (&lt;span&gt;null&lt;/span&gt; != code &amp;amp;&amp;amp; !&lt;span&gt;&quot;&quot;&lt;/span&gt;.equals(code)) {&lt;br/&gt;            PAY_REGISTERS.put(code, iPay);&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; IPay &lt;span&gt;get&lt;/span&gt;&lt;span&gt;(String code)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; PAY_REGISTERS.get(code);&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;@Service&lt;/span&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;PayService3&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;toPay&lt;/span&gt;&lt;span&gt;(String code)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        PayStrategyFactory.get(code).pay();&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这段代码的关键是PayStrategyFactory类，它是一个策略工厂，里面定义了一个全局的map，在所有IPay的实现类中注册当前实例到map中，然后在调用的地方通过PayStrategyFactory类根据code从map获取支付类实例即可。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果加了一个新的支付方式，只需新加一个类实现IPay接口，定义init方法，并且重写pay方法即可，其他代码基本上可以不用动。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当然，消除又臭又长的if...else判断，还有很多方法，比如：使用注解、动态拼接类名称、模板方法、枚举等等。由于篇幅有限，在这里我就不过多介绍了，更详细的内容可以看看我的另一篇文章《&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzkwNjMwMTgzMQ==&amp;amp;mid=2247490272&amp;amp;idx=1&amp;amp;sn=c5db63c7b52e7518b7a42e48c70927fc&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;消除if...else是9条锦囊妙计&lt;/a&gt;》&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;21.防止死循环&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;有些小伙伴看到这个标题，可能会感到有点意外，代码中不是应该避免死循环吗？为啥还是会产生死循环？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;殊不知有些死循环是我们自己写的，例如下面这段代码：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;while&lt;/span&gt;(&lt;span&gt;true&lt;/span&gt;) {&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt;(condition) {&lt;br/&gt;        &lt;span&gt;break&lt;/span&gt;;&lt;br/&gt;    }&lt;br/&gt;    System.out.println(&lt;span&gt;&quot;do samething&quot;&lt;/span&gt;);&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里使用了while(true)的循环调用，这种写法在&lt;code&gt;CAS自旋锁&lt;/code&gt;中使用比较多。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当满足condition等于true的时候，则自动退出该循环。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果condition条件非常复杂，一旦出现判断不正确，或者少写了一些逻辑判断，就可能在某些场景下出现死循环的问题。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;出现死循环，大概率是开发人员人为的bug导致的，不过这种情况很容易被测出来。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;还有一种隐藏的比较深的死循环，是由于代码写的不太严谨导致的。如果用正常数据，可能测不出问题，但一旦出现异常数据，就会立即出现死循环。&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其实，还有另一种死循环：&lt;code&gt;无限递归&lt;/code&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果想要打印某个分类的所有父分类，可以用类似这样的递归方法实现：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;printCategory&lt;/span&gt;&lt;span&gt;(Category category)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;if&lt;/span&gt;(category == &lt;span&gt;null&lt;/span&gt; &lt;br/&gt;      || category.getParentId() == &lt;span&gt;null&lt;/span&gt;) {&lt;br/&gt;     &lt;span&gt;return&lt;/span&gt;;&lt;br/&gt;  } &lt;br/&gt;  System.out.println(&lt;span&gt;&quot;父分类名称：&quot;&lt;/span&gt;+ category.getName());&lt;br/&gt;  Category parent = categoryMapper.getCategoryById(category.getParentId());&lt;br/&gt;  printCategory(parent);&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;正常情况下，这段代码是没有问题的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但如果某次有人误操作，把某个分类的parentId指向了它自己，这样就会出现无限递归的情况。导致接口一直不能返回数据，最终会发生堆栈溢出。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;建议写递归方法时，设定一个递归的深度，比如：分类最大等级有4级，则深度可以设置为4。然后在递归方法中做判断，如果深度大于4时，则自动返回，这样就能避免无限循环的情况。&lt;/p&gt;&lt;/blockquote&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;22.注意BigDecimal的坑&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;通常我们会把一些小数类型的字段（比如：金额），定义成&lt;code&gt;BigDecimal&lt;/code&gt;，而不是&lt;code&gt;Double&lt;/code&gt;，避免丢失精度问题。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;使用Double时可能会有这种场景：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;double&lt;/span&gt; amount1 = &lt;span&gt;0.02&lt;/span&gt;;&lt;br/&gt;&lt;span&gt;double&lt;/span&gt; amount2 = &lt;span&gt;0.03&lt;/span&gt;;&lt;br/&gt;System.out.println(amount2 - amount1);&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;正常情况下预计amount2 - amount1应该等于0.01&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但是执行结果，却为：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;0.009999999999999998&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;实际结果小于预计结果。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Double类型的两个参数相减会转换成二进制，因为Double有效位数为16位这就会出现存储小数位数不够的情况，这种情况下就会出现误差。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;常识告诉我们使用&lt;code&gt;BigDecimal&lt;/code&gt;能避免丢失精度。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但是使用BigDecimal能避免丢失精度吗？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;答案是否定的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;为什么？&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;BigDecimal amount1 = &lt;span&gt;new&lt;/span&gt; BigDecimal(&lt;span&gt;0.02&lt;/span&gt;);&lt;br/&gt;BigDecimal amount2 = &lt;span&gt;new&lt;/span&gt; BigDecimal(&lt;span&gt;0.03&lt;/span&gt;);&lt;br/&gt;System.out.println(amount2.subtract(amount1));&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个例子中定义了两个BigDecimal类型参数，使用构造函数初始化数据，然后打印两个参数相减后的值。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;结果：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;0.0099999999999999984734433411404097569175064563751220703125&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;不科学呀，为啥还是丢失精度了？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;Jdk&lt;/code&gt;中&lt;code&gt;BigDecimal&lt;/code&gt;的&lt;code&gt;构造方法&lt;/code&gt;上有这样一段描述：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.2511013215859031&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/ibJZVicC7nz5gqHibQQHSJ4vj82XVnOgXBSH69HIOJwzLbx8F0uoMgeDicyDBUKjAyWDulF9OB9sx66Sds4Orre8vA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;908&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;大致的意思是此构造函数的结果可能不可预测，可能会出现创建时为0.1，但实际是0.1000000000000000055511151231257827021181583404541015625的情况。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;由此可见，使用BigDecimal构造函数初始化对象，也会丢失精度。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那么，如何才能不丢失精度呢？&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;BigDecimal amount1 = &lt;span&gt;new&lt;/span&gt; BigDecimal(Double.toString(&lt;span&gt;0.02&lt;/span&gt;));&lt;br/&gt;BigDecimal amount2 = &lt;span&gt;new&lt;/span&gt; BigDecimal(Double.toString(&lt;span&gt;0.03&lt;/span&gt;));&lt;br/&gt;System.out.println(amount2.subtract(amount1));&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们可以使用&lt;code&gt;Double.toString&lt;/code&gt;方法，对double类型的小数进行转换，这样能保证精度不丢失。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其实，还有更好的办法：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;BigDecimal amount1 = BigDecimal.valueOf(&lt;span&gt;0.02&lt;/span&gt;);&lt;br/&gt;BigDecimal amount2 = BigDecimal.valueOf(&lt;span&gt;0.03&lt;/span&gt;);&lt;br/&gt;System.out.println(amount2.subtract(amount1));&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;使用&lt;code&gt;BigDecimal.valueOf&lt;/code&gt;方法初始化BigDecimal类型参数，也能保证精度不丢失。在新版的阿里巴巴开发手册中，也推荐使用这种方式创建BigDecimal参数。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;23.尽可能复用代码&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;ctrl + c&lt;/code&gt; 和 &lt;code&gt;ctrl + v&lt;/code&gt;可能是程序员使用最多的快捷键了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;没错，我们是大自然的搬运工。哈哈哈。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在项目初期，我们使用这种工作模式，确实可以提高一些工作效率，可以少写（实际上是少敲）很多代码。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但它带来的问题是：会出现大量的代码重复。例如：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;@Service&lt;/span&gt;&lt;br/&gt;&lt;span&gt;@Slf&lt;/span&gt;4j&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;TestService1&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;test1&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;  &lt;/span&gt;{&lt;br/&gt;        addLog(&lt;span&gt;&quot;test1&quot;&lt;/span&gt;);&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;addLog&lt;/span&gt;&lt;span&gt;(String info)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (log.isInfoEnabled()) {&lt;br/&gt;            log.info(&lt;span&gt;&quot;info:{}&quot;&lt;/span&gt;, info);&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;@Service&lt;/span&gt;&lt;br/&gt;&lt;span&gt;@Slf&lt;/span&gt;4j&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;TestService2&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;test2&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;  &lt;/span&gt;{&lt;br/&gt;        addLog(&lt;span&gt;&quot;test2&quot;&lt;/span&gt;);&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;addLog&lt;/span&gt;&lt;span&gt;(String info)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (log.isInfoEnabled()) {&lt;br/&gt;            log.info(&lt;span&gt;&quot;info:{}&quot;&lt;/span&gt;, info);&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;@Service&lt;/span&gt;&lt;br/&gt;&lt;span&gt;@Slf&lt;/span&gt;4j&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;TestService3&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;test3&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;  &lt;/span&gt;{&lt;br/&gt;        addLog(&lt;span&gt;&quot;test3&quot;&lt;/span&gt;);&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;addLog&lt;/span&gt;&lt;span&gt;(String info)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (log.isInfoEnabled()) {&lt;br/&gt;            log.info(&lt;span&gt;&quot;info:{}&quot;&lt;/span&gt;, info);&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在TestService1、TestService2、TestService3类中，都有一个addLog方法用于添加日志。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;本来该功能用得好好的，直到有一天，线上出现了一个事故：服务器磁盘满了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;原因是打印的日志太多，记了很多没必要的日志，比如：查询接口的所有返回值，大对象的具体打印等。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;没办法，只能将addLog方法改成只记录&lt;code&gt;debug&lt;/code&gt;日志。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;于是乎，你需要全文搜索，addLog方法去修改，改成如下代码：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;addLog&lt;/span&gt;&lt;span&gt;(String info)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (log.isDebugEnabled()) {&lt;br/&gt;        log.debug(&lt;span&gt;&quot;debug:{}&quot;&lt;/span&gt;, info);&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里是有三个类中需要修改这段代码，但如果实际工作中有三十个、三百个类需要修改，会让你非常痛苦。改错了，或者改漏了，都会埋下隐患，把自己坑了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;为何不把这种功能的代码提取出来，放到某个工具类中呢？&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;@Slf&lt;/span&gt;4j&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;LogUtil&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;LogUtil&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; RuntimeException(&lt;span&gt;&quot;初始化失败&quot;&lt;/span&gt;);&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;addLog&lt;/span&gt;&lt;span&gt;(String info)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (log.isDebugEnabled()) {&lt;br/&gt;            log.debug(&lt;span&gt;&quot;debug:{}&quot;&lt;/span&gt;, info);&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;然后，在其他的地方，只需要调用。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;@Service&lt;/span&gt;&lt;br/&gt;&lt;span&gt;@Slf&lt;/span&gt;4j&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;TestService1&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;test1&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;  &lt;/span&gt;{&lt;br/&gt;        LogUtil.addLog(&lt;span&gt;&quot;test1&quot;&lt;/span&gt;);&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果哪天addLog的逻辑又要改了，只需要修改LogUtil类的addLog方法即可。你可以自信满满的修改，不需要再小心翼翼了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们写的代码，绝大多数是可维护性的代码，而非一次性的。所以，建议在写代码的过程中，如果出现重复的代码，尽量提取成公共方法。千万别因为项目初期一时的爽快，而给项目埋下隐患，后面的维护成本可能会非常高。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;24.foreach循环中不remove元素&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们知道在Java中，循环有很多种写法，比如：while、for、foreach等。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;Test2&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;(String[] args)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        List&amp;lt;String&amp;gt; list = Lists.newArrayList(&lt;span&gt;&quot;a&quot;&lt;/span&gt;,&lt;span&gt;&quot;b&quot;&lt;/span&gt;,&lt;span&gt;&quot;c&quot;&lt;/span&gt;);&lt;br/&gt;        &lt;span&gt;for&lt;/span&gt; (String temp : list) {&lt;br/&gt;            &lt;span&gt;if&lt;/span&gt; (&lt;span&gt;&quot;c&quot;&lt;/span&gt;.equals(temp)) {&lt;br/&gt;                list.remove(temp);&lt;br/&gt;            }&lt;br/&gt;        }&lt;br/&gt;        System.out.println(list);&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;执行结果：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;Exception in thread &lt;span&gt;&quot;main&quot;&lt;/span&gt; java.util.ConcurrentModificationException&lt;br/&gt; at java.util.ArrayList$Itr.checkForComodification(ArrayList.java:&lt;span&gt;901&lt;/span&gt;)&lt;br/&gt; at java.util.ArrayList$Itr.next(ArrayList.java:&lt;span&gt;851&lt;/span&gt;)&lt;br/&gt; at com.sue.jump.service.test1.Test2.main(Test2.java:&lt;span&gt;24&lt;/span&gt;)&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这种在&lt;code&gt;foreach&lt;/code&gt;循环中调用&lt;code&gt;remove&lt;/code&gt;方法删除元素，可能会报&lt;code&gt;ConcurrentModificationException&lt;/code&gt;异常。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果想在遍历集合时，删除其中的元素，可以用for循环，例如：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;Test2&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;(String[] args)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        List&amp;lt;String&amp;gt; list = Lists.newArrayList(&lt;span&gt;&quot;a&quot;&lt;/span&gt;,&lt;span&gt;&quot;b&quot;&lt;/span&gt;,&lt;span&gt;&quot;c&quot;&lt;/span&gt;);&lt;br/&gt;        &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; list.size(); i++) {&lt;br/&gt;            String temp = list.get(i);&lt;br/&gt;            &lt;span&gt;if&lt;/span&gt; (&lt;span&gt;&quot;c&quot;&lt;/span&gt;.equals(temp)) {&lt;br/&gt;                list.remove(temp);&lt;br/&gt;            }&lt;br/&gt;        }&lt;br/&gt;        System.out.println(list);&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;执行结果：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;[a, b]&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;25.避免随意打印日志&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在我们写代码的时候，打印日志是必不可少的工作之一。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;因为日志可以帮我们快速定位问题，判断代码当时真正的执行逻辑。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但打印日志的时候也需要注意，不是说任何时候都要打印日志，比如：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;@PostMapping&lt;/span&gt;(&lt;span&gt;&quot;/query&quot;&lt;/span&gt;)&lt;br/&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; List&amp;lt;User&amp;gt; &lt;span&gt;query&lt;/span&gt;&lt;span&gt;(@RequestBody List&amp;lt;Long&amp;gt; ids)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    log.info(&lt;span&gt;&quot;request params:{}&quot;&lt;/span&gt;, ids);&lt;br/&gt;    List&amp;lt;User&amp;gt; userList = userService.query(ids);&lt;br/&gt;    log.info(&lt;span&gt;&quot;response:{}&quot;&lt;/span&gt;, userList);&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; userList;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;对于有些查询接口，在日志中打印出了请求参数和接口返回值。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;咋一看没啥问题。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但如果ids中传入值非常多，比如有1000个。而该接口被调用的频次又很高，一下子就会打印大量的日志，用不了多久就可能把&lt;code&gt;磁盘空间&lt;/code&gt;打满。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果真的想打印这些日志该怎么办？&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;@PostMapping&lt;/span&gt;(&lt;span&gt;&quot;/query&quot;&lt;/span&gt;)&lt;br/&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; List&amp;lt;User&amp;gt; &lt;span&gt;query&lt;/span&gt;&lt;span&gt;(@RequestBody List&amp;lt;Long&amp;gt; ids)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (log.isDebugEnabled()) {&lt;br/&gt;        log.debug(&lt;span&gt;&quot;request params:{}&quot;&lt;/span&gt;, ids);&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    List&amp;lt;User&amp;gt; userList = userService.query(ids);&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (log.isDebugEnabled()) {&lt;br/&gt;        log.debug(&lt;span&gt;&quot;response:{}&quot;&lt;/span&gt;, userList);&lt;br/&gt;    }&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; userList;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;使用&lt;code&gt;isDebugEnabled&lt;/code&gt;判断一下，如果当前的日志级别是&lt;code&gt;debug&lt;/code&gt;才打印日志。生产环境默认日志级别是&lt;code&gt;info&lt;/code&gt;，在有些紧急情况下，把某个接口或者方法的日志级别改成debug，打印完我们需要的日志后，又调整回去。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;方便我们定位问题，又不会产生大量的垃圾日志，一举两得。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;26.比较时把常量写前面&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在比较两个参数值是否相等时，通常我们会使用&lt;code&gt;==&lt;/code&gt;号，或者&lt;code&gt;equals&lt;/code&gt;方法。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我在第15章节中说过，使用&lt;code&gt;==&lt;/code&gt;号比较两个值是否相等时，可能会存在问题，建议使用&lt;code&gt;equals&lt;/code&gt;方法做比较。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;反例&lt;/code&gt;：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;if&lt;/span&gt;(user.getName().equals(&lt;span&gt;&quot;苏三&quot;&lt;/span&gt;)) {&lt;br/&gt;   System.out.println(&lt;span&gt;&quot;找到：&quot;&lt;/span&gt;+user.getName());&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在上面这段代码中，如果user对象，或者user.getName()方法返回值为&lt;code&gt;null&lt;/code&gt;，则都报&lt;code&gt;NullPointerException&lt;/code&gt;异常。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那么，如何避免空指针异常呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;正例&lt;/code&gt;：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; String FOUND_NAME = &lt;span&gt;&quot;苏三&quot;&lt;/span&gt;;&lt;br/&gt;...&lt;br/&gt;&lt;br/&gt;&lt;span&gt;if&lt;/span&gt;(&lt;span&gt;null&lt;/span&gt; == user) {&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt;;&lt;br/&gt;}&lt;br/&gt;&lt;span&gt;if&lt;/span&gt;(FOUND_NAME.equals(user.getName())) {&lt;br/&gt;   System.out.println(&lt;span&gt;&quot;找到：&quot;&lt;/span&gt;+user.getName());&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在使用&lt;code&gt;equals&lt;/code&gt;做比较时，尽量将&lt;code&gt;常量&lt;/code&gt;写在前面，即equals方法的左边。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这样即使user.getName()返回的数据为null，equals方法会直接返回false，而不再是报空指针异常。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;27.名称要见名知意&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;java中没有强制规定参数、方法、类或者包名该怎么起名。但如果我们没有养成良好的起名习惯，随意起名的话，可能会出现很多奇怪的代码。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;27.1 有意义的参数名&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;有时候，我们写代码时为了省事（可以少敲几个字母），参数名起得越简单越好。假如同事A写的代码如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;int&lt;/span&gt; a = &lt;span&gt;1&lt;/span&gt;;&lt;br/&gt;&lt;span&gt;int&lt;/span&gt; b = &lt;span&gt;2&lt;/span&gt;;&lt;br/&gt;String c = &lt;span&gt;&quot;abc&quot;&lt;/span&gt;;&lt;br/&gt;&lt;span&gt;boolean&lt;/span&gt; b = &lt;span&gt;false&lt;/span&gt;;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;一段时间之后，同事A离职了，同事B接手了这段代码。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;他此时一脸懵逼，a是什么意思，b又是什么意思，还有c...然后心里一万个草泥马。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;给参数起一个有意义的名字，是非常重要的事情，避免给自己或者别人埋坑。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;正解：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;int&lt;/span&gt; supplierCount = &lt;span&gt;1&lt;/span&gt;;&lt;br/&gt;&lt;span&gt;int&lt;/span&gt; purchaserCount = &lt;span&gt;2&lt;/span&gt;;&lt;br/&gt;String userName = &lt;span&gt;&quot;abc&quot;&lt;/span&gt;;&lt;br/&gt;&lt;span&gt;boolean&lt;/span&gt; hasSuccess = &lt;span&gt;false&lt;/span&gt;;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;27.2 见名知意&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;光起有意义的参数名还不够，我们不能就这点追求。我们起的参数名称最好能够&lt;code&gt;见名知意&lt;/code&gt;，不然就会出现这样的情况：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;String yongHuMing = &lt;span&gt;&quot;苏三&quot;&lt;/span&gt;;&lt;br/&gt;String 用户Name = &lt;span&gt;&quot;苏三&quot;&lt;/span&gt;;&lt;br/&gt;String su3 = &lt;span&gt;&quot;苏三&quot;&lt;/span&gt;;&lt;br/&gt;String suThree = &lt;span&gt;&quot;苏三&quot;&lt;/span&gt;;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这几种参数名看起来是不是有点怪怪的？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;为啥不定义成国际上通用的（地球人都能看懂）英文单词呢？&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;String userName = &lt;span&gt;&quot;苏三&quot;&lt;/span&gt;;&lt;br/&gt;String susan = &lt;span&gt;&quot;苏三&quot;&lt;/span&gt;;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上面的这两个参数名，基本上大家都能看懂，减少了好多沟通成本。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以建议在定义不管是参数名、方法名、类名时，优先使用国际上通用的英文单词，更简单直观，减少沟通成本。少用汉子、拼音，或者数字定义名称。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;27.3 参数名风格一致&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;参数名其实有多种风格，列如：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;//字母全小写&lt;/span&gt;&lt;br/&gt;&lt;span&gt;int&lt;/span&gt; suppliercount = &lt;span&gt;1&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;//字母全大写&lt;/span&gt;&lt;br/&gt;&lt;span&gt;int&lt;/span&gt; SUPPLIERCOUNT = &lt;span&gt;1&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;//小写字母 + 下划线&lt;/span&gt;&lt;br/&gt;&lt;span&gt;int&lt;/span&gt; supplier_count = &lt;span&gt;1&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;//大写字母 + 下划线&lt;/span&gt;&lt;br/&gt;&lt;span&gt;int&lt;/span&gt; SUPPLIER_COUNT = &lt;span&gt;1&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;//驼峰标识&lt;/span&gt;&lt;br/&gt;&lt;span&gt;int&lt;/span&gt; supplierCount = &lt;span&gt;1&lt;/span&gt;;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果某个类中定义了多种风格的参数名称，看起来是不是有点杂乱无章？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以建议类的成员变量、局部变量和方法参数使用supplierCount，这种&lt;code&gt;驼峰风格&lt;/code&gt;，即：第一个字母小写，后面的每个单词首字母大写。例如：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;int&lt;/span&gt; supplierCount = &lt;span&gt;1&lt;/span&gt;;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;此外，为了好做区分，静态常量建议使用SUPPLIER_COUNT，即：&lt;code&gt;大写字母&lt;/code&gt; &lt;code&gt;+&lt;/code&gt; &lt;code&gt;下划线&lt;/code&gt;分隔的参数名。例如：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; SUPPLIER_COUNT = &lt;span&gt;1&lt;/span&gt;;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;28.SimpleDateFormat线程不安全&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在java8之前，我们对时间的格式化处理，一般都是用的&lt;code&gt;SimpleDateFormat&lt;/code&gt;类实现的。例如：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;@Service&lt;/span&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;SimpleDateFormatService&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; Date &lt;span&gt;time&lt;/span&gt;&lt;span&gt;(String time)&lt;/span&gt; &lt;span&gt;throws&lt;/span&gt; ParseException &lt;/span&gt;{&lt;br/&gt;        SimpleDateFormat dateFormat = &lt;span&gt;new&lt;/span&gt; SimpleDateFormat(&lt;span&gt;&quot;yyyy-MM-dd HH:mm:ss&quot;&lt;/span&gt;);&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; dateFormat.parse(time);&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果你真的这样写，是没问题的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;就怕哪天抽风，你觉得dateFormat是一段固定的代码，应该要把它抽取成常量。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;于是把代码改成下面的这样：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;@Service&lt;/span&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;SimpleDateFormatService&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;   &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; SimpleDateFormat dateFormat = &lt;span&gt;new&lt;/span&gt; SimpleDateFormat(&lt;span&gt;&quot;yyyy-MM-dd HH:mm:ss&quot;&lt;/span&gt;);&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; Date &lt;span&gt;time&lt;/span&gt;&lt;span&gt;(String time)&lt;/span&gt; &lt;span&gt;throws&lt;/span&gt; ParseException &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; dateFormat.parse(time);&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;dateFormat对象被定义成了静态常量，这样就能被所有对象共用。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果只有一个线程调用time方法，也不会出现问题。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但Serivce类的方法，往往是被Controller类调用的，而Controller类的接口方法，则会被&lt;code&gt;tomcat&lt;/code&gt;的&lt;code&gt;线程池&lt;/code&gt;调用。换句话说，可能会出现多个线程调用同一个Controller类的同一个方法，也就是会出现多个线程会同时调用time方法。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;而time方法会调用&lt;code&gt;SimpleDateFormat&lt;/code&gt;类的&lt;code&gt;parse&lt;/code&gt;方法：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; Date &lt;span&gt;parse&lt;/span&gt;&lt;span&gt;(String text, ParsePosition pos)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    ...&lt;br/&gt;    Date parsedDate;&lt;br/&gt;    &lt;span&gt;try&lt;/span&gt; {&lt;br/&gt;        parsedDate = calb.establish(calendar).getTime();&lt;br/&gt;        ...&lt;br/&gt;    } &lt;span&gt;catch&lt;/span&gt; (IllegalArgumentException e) {&lt;br/&gt;        pos.errorIndex = start;&lt;br/&gt;        pos.index = oldStart;&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;;&lt;br/&gt;    }&lt;br/&gt;   &lt;span&gt;return&lt;/span&gt; parsedDate;&lt;br/&gt;} &lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;该方法会调用&lt;code&gt;establish&lt;/code&gt;方法：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;Calendar &lt;span&gt;establish&lt;/span&gt;&lt;span&gt;(Calendar cal)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    ...&lt;br/&gt;    &lt;span&gt;//1.清空数据&lt;/span&gt;&lt;br/&gt;    cal.clear();&lt;br/&gt;    &lt;span&gt;//2.设置时间&lt;/span&gt;&lt;br/&gt;    cal.set(...);&lt;br/&gt;    &lt;span&gt;//3.返回&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; cal;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其中的步骤1、2、3是非原子操作。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但如果cal对象是局部变量还好，坏就坏在parse方法调用establish方法时，传入的calendar是&lt;code&gt;SimpleDateFormat&lt;/code&gt;类的父类&lt;code&gt;DateFormat&lt;/code&gt;的成员变量：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;abstract&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;DateFormat&lt;/span&gt; &lt;span&gt;extends&lt;/span&gt; &lt;span&gt;Forma&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    ....&lt;br/&gt;    &lt;span&gt;protected&lt;/span&gt; Calendar calendar;&lt;br/&gt;    ...&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这样就可能会出现多个线程，同时修改同一个对象即：dateFormat，它的同一个成员变量即：Calendar值的情况。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这样可能会出现，某个线程设置好了时间，又被其他的线程修改了，从而出现时间错误的情况。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那么，如何解决这个问题呢？&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;SimpleDateFormat类的对象不要定义成静态的，可以改成方法的局部变量。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;使用ThreadLocal保存SimpleDateFormat类的数据。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;使用java8的DateTimeFormatter类。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;29.少用Executors创建线程池&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们都知道&lt;code&gt;JDK5&lt;/code&gt;之后，提供了&lt;code&gt;ThreadPoolExecutor&lt;/code&gt;类，用它可以&lt;code&gt;自定义线程池&lt;/code&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;线程池的好处有很多，下面主要说说这3个方面。&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;降低资源消耗&lt;/code&gt;：避免了频繁的创建线程和销毁线程，可以直接复用已有线程。而我们都知道，创建线程是非常耗时的操作。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;提供速度&lt;/code&gt;：任务过来之后，因为线程已存在，可以拿来直接使用。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;提高线程的可管理性&lt;/code&gt;：线程是非常宝贵的资源，如果创建过多的线程，不仅会消耗系统资源，甚至会影响系统的稳定。使用线程池，可以非常方便的创建、管理和监控线程。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当然JDK为了我们使用更便捷，专门提供了：&lt;code&gt;Executors&lt;/code&gt;类，给我们快速创建&lt;code&gt;线程池&lt;/code&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;该类中包含了很多&lt;code&gt;静态方法&lt;/code&gt;：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;newCachedThreadPool&lt;/code&gt;：创建一个可缓冲的线程，如果线程池大小超过处理需要，可灵活回收空闲线程，若无可回收，则新建线程。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;newFixedThreadPool&lt;/code&gt;：创建一个固定大小的线程池，如果任务数量超过线程池大小，则将多余的任务放到队列中。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;newScheduledThreadPool&lt;/code&gt;：创建一个固定大小，并且能执行定时周期任务的线程池。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;newSingleThreadExecutor&lt;/code&gt;：创建只有一个线程的线程池，保证所有的任务安装顺序执行。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在高并发的场景下，如果大家使用这些静态方法创建线程池，会有一些问题。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那么，我们一起看看有哪些问题？&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;newFixedThreadPool&lt;/code&gt;：允许请求的队列长度是Integer.MAX_VALUE，可能会堆积大量的请求，从而导致OOM。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;newSingleThreadExecutor&lt;/code&gt;：允许请求的队列长度是Integer.MAX_VALUE，可能会堆积大量的请求，从而导致OOM。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;newCachedThreadPool&lt;/code&gt;：允许创建的线程数是Integer.MAX_VALUE，可能会创建大量的线程，从而导致OOM。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那我们该怎办呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;优先推荐使用&lt;code&gt;ThreadPoolExecutor&lt;/code&gt;类，我们自定义线程池。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;具体代码如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;ExecutorService threadPool = &lt;span&gt;new&lt;/span&gt; ThreadPoolExecutor(&lt;br/&gt;    &lt;span&gt;8&lt;/span&gt;, &lt;span&gt;//corePoolSize线程池中核心线程数&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;10&lt;/span&gt;, &lt;span&gt;//maximumPoolSize 线程池中最大线程数&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;60&lt;/span&gt;, &lt;span&gt;//线程池中线程的最大空闲时间，超过这个时间空闲线程将被回收&lt;/span&gt;&lt;br/&gt;    TimeUnit.SECONDS,&lt;span&gt;//时间单位&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;new&lt;/span&gt; ArrayBlockingQueue(&lt;span&gt;500&lt;/span&gt;), &lt;span&gt;//队列&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;new&lt;/span&gt; ThreadPoolExecutor.CallerRunsPolicy()); &lt;span&gt;//拒绝策略&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;顺便说一下，如果是一些低并发场景，使用&lt;code&gt;Executors&lt;/code&gt;类创建线程池也未尝不可，也不能完全一棍子打死。在这些低并发场景下，很难出现&lt;code&gt;OOM&lt;/code&gt;问题，所以我们需要根据实际业务场景选择。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;30.Arrays.asList转换的集合别修改&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在我们日常工作中，经常需要把&lt;code&gt;数组&lt;/code&gt;转换成&lt;code&gt;List&lt;/code&gt;集合。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;因为数组的长度是固定的，不太好扩容，而List的长度是可变的，它的长度会根据元素的数量动态扩容。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在JDK的&lt;code&gt;Arrays&lt;/code&gt;类中提供了&lt;code&gt;asList&lt;/code&gt;方法，可以把&lt;code&gt;数组&lt;/code&gt;转换成&lt;code&gt;List&lt;/code&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;正例&lt;/code&gt;：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;String [] array = &lt;span&gt;new&lt;/span&gt; String [] {&lt;span&gt;&quot;a&quot;&lt;/span&gt;,&lt;span&gt;&quot;b&quot;&lt;/span&gt;,&lt;span&gt;&quot;c&quot;&lt;/span&gt;};&lt;br/&gt;List&amp;lt;String&amp;gt; list = Arrays.asList(array);&lt;br/&gt;&lt;span&gt;for&lt;/span&gt; (String str : list) {&lt;br/&gt;    System.out.println(str);&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在这个例子中，使用Arrays.asList方法将array数组，直接转换成了list。然后在for循环中遍历list，打印出它里面的元素。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果转换后的list，只是使用，没新增或修改元素，不会有问题。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;反例&lt;/code&gt;：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;String[] array = &lt;span&gt;new&lt;/span&gt; String[]{&lt;span&gt;&quot;a&quot;&lt;/span&gt;, &lt;span&gt;&quot;b&quot;&lt;/span&gt;, &lt;span&gt;&quot;c&quot;&lt;/span&gt;};&lt;br/&gt;List&amp;lt;String&amp;gt; list = Arrays.asList(array);&lt;br/&gt;list.add(&lt;span&gt;&quot;d&quot;&lt;/span&gt;);&lt;br/&gt;&lt;span&gt;for&lt;/span&gt; (String str : list) {&lt;br/&gt;    System.out.println(str);&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;执行结果：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;Exception in thread &lt;span&gt;&quot;main&quot;&lt;/span&gt; java.lang.UnsupportedOperationException&lt;br/&gt;at java.util.AbstractList.add(AbstractList.java:&lt;span&gt;148&lt;/span&gt;)&lt;br/&gt;at java.util.AbstractList.add(AbstractList.java:&lt;span&gt;108&lt;/span&gt;)&lt;br/&gt;at com.sue.jump.service.test1.Test2.main(Test2.java:&lt;span&gt;24&lt;/span&gt;)&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;会直接报&lt;code&gt;UnsupportedOperationException&lt;/code&gt;异常。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;为什么呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;答：使用&lt;code&gt;Arrays.asList&lt;/code&gt;方法转换后的&lt;code&gt;ArrayList&lt;/code&gt;，是&lt;code&gt;Arrays&lt;/code&gt;类的内部类，并非&lt;code&gt;java.util&lt;/code&gt;包下我们常用的&lt;code&gt;ArrayList&lt;/code&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Arrays类的内部ArrayList类，它没有实现父类的add和remove方法,用的是父类AbstractList的默认实现。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们看看&lt;code&gt;AbstractList&lt;/code&gt;是如何实现的：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;add&lt;/span&gt;&lt;span&gt;(&lt;span&gt;int&lt;/span&gt; index, E element)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;   &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; UnsupportedOperationException();&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; E &lt;span&gt;remove&lt;/span&gt;&lt;span&gt;(&lt;span&gt;int&lt;/span&gt; index)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;   &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; UnsupportedOperationException();&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;该类的&lt;code&gt;add&lt;/code&gt;和&lt;code&gt;remove&lt;/code&gt;方法直接抛异常了，因此调用Arrays类的内部ArrayList类的add和remove方法，同样会抛异常。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;说实话，Java代码优化是一个比较大的话题，它里面可以优化的点非常多，我没办法一一列举完。在这里只能抛砖引玉，介绍一下比较常见的知识点，更全面的内容，需要小伙伴们自己去思考和探索。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这篇文章写了很久，花了很多时间和心思，如果你看了文章有些收获，记得给我点赞鼓励一下喔。&lt;/p&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>8b90be95ae4eb810cd8946e47553f9d9</guid>
<title>换掉Postman，事实证明它更牛逼！</title>
<link>https://toutiao.io/k/uncruss</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content                           autoTypeSetting24psection&amp;#10;                          &quot; id=&quot;js_content&quot;&gt;
            &lt;section data-tools=&quot;新媒体管家&quot; data-label=&quot;powered by xmt.cn&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;p data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;span/&gt;&lt;span&gt;最近国产API管理工具卷起来了，甚至发生了公开踩踏事件，但最后还是要回归产品，产品好才真的好。给大家推荐Eolink，低调又强大。Eolink是&lt;/span&gt;&lt;span&gt;&lt;strong&gt;结合了 API 设计、文档管理、自动化测试、监控、研发管理和团队协作的一站式 API 生产平台&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;，还集成  Gitlab、Jenkins、钉钉、企业微信、飞书等平台，简直就是一个六边形战士，没有短板！最重要的是，Eolink在商用方面已全面领先！&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.6666666666666666&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/LGh7bn8KbYDH7CosT0CQ8XJJW9w6aymWiaU8BZg4A5Rvc3Pf3RoiaDYGOWIobp4tVCR1MicbvhVruUcrDpenQ5Vyw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1538&quot;/&gt;&lt;/p&gt;&lt;section tn-link=&quot;compAttr.link || comp.link&quot;&gt;&lt;p&gt;&lt;span&gt;目前SaaS产品完全免费，你可使用web版，也可下载桌面端，Windows、Mac、Linux 平台均支持！&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;体验地址：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;https://www.eolink.com/?utm_source=w3003&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;给大家准备了介绍视频，如果你不想看图文，也可&lt;span&gt;&lt;span&gt;滑到文章底部看视频&lt;/span&gt;&lt;/span&gt;。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;/section&gt;&lt;section tn-link=&quot;compAttr.link || comp.link&quot;&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;01.&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;API研发测试天花板&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;目前市面上有众多API研发工具，但Eolink依然在&lt;span&gt;&lt;span&gt;功能深度、广度以及用户体验&lt;/span&gt;&lt;/span&gt;等方面都做到了更好，尤其是针对批量操作和重复工作开展了大量自动化和智能化提升。&lt;span&gt;&lt;span&gt;其实一个产品是不是用心打磨过，体验好不好，一上手就知道了。&lt;/span&gt;&lt;/span&gt;让我们看看Eolink到底有多强！&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;1. 支持所有类型的API文档管理&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;无论使用什么语言开发，无论是 &lt;span&gt;&lt;span&gt;&lt;span&gt;HTTPS、Websocket、TCP、UDP、gRPC、RPC&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;等什么协议，还是 Restful、SOAP、WebService 等什么规范，Eolink 都可以协助团队快速、统一、规范地管理起来。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;2. 一键发起API测试，打通 API 文档与测试&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Eolink可以一键发起测试，支持自动生成测试数据，能够通过 Javascript 代码对请求报文、返回结果等进行加解密、签名等处理，让繁琐的API测试变得简单顺滑。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;3. 0代码自动化测试，一键进行大范围回归测试&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;当 API 发生变化时，可以一键进行API回归测试，系统会自动根据规则判断返回结果并得出测试报告，方便团队快速了解 API 改动的影响范围，可减少超过 95% 的测试时间！&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;4. 强大的COOKIE管理&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在测试需要 Cookie 的 API 时，Eolink支持在 Cookie 管理里添加所需的 Cookie 信息，系统会自动存储 Cookie，下次测试其他相同域名的 API 时会自动传递 Cookie 请求参数。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;目前SaaS产品完全免费，你可使用web版，也可下载桌面端，Windows、Mac、Linux 平台均支持！&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;体验地址：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;https://www.eolink.com/?utm_source=w3003&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;02.&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;隐秘又好用的小亮点&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;还发现Eolink几个隐藏的亮点功能，用起来特别香！&lt;/span&gt;&lt;/p&gt;&lt;section tn-link=&quot;compAttr.link || comp.link&quot;&gt;&lt;ol class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;API变更智能通知&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;API历史版本比对&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;项目分析报表&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;超强Mock API&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;API文档评论功能&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;定时测试任务&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;支持数据驱动&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;直接上图，一看就懂。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;325&quot; data-backw=&quot;578&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.6666666666666666&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/LGh7bn8KbYDH7CosT0CQ8XJJW9w6aymWiaQVUPIKNVO8n39c1NXLvPz2S0Sibzh6hUqO6CtLn9Y144IUrccEIYUg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;/section&gt;&lt;section tn-link=&quot;compAttr.link || comp.link&quot;&gt;&lt;p&gt;&lt;span&gt;&lt;em&gt;当 API 发生变化时通过邮件和站内信自动通知相关成员，并且已与QQ和飞书打通&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.6666666666666666&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/LGh7bn8KbYDH7CosT0CQ8XJJW9w6aymWgn3FdXFVxqyxDaz2Aric6TNlJnGNwJenMGs6DYxBFhoZPolPTRuPEXw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1837&quot;/&gt;&lt;/p&gt;&lt;section tn-link=&quot;compAttr.link || comp.link&quot;&gt;&lt;p&gt;&lt;span&gt;&lt;em&gt;回滚查看API文档历史版本，智能查找不同版本文档差异&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.6666666666666666&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/LGh7bn8KbYDH7CosT0CQ8XJJW9w6aymWCl050EMNCELzia2nOBh494OrDVPYCFk4DxSrecFZWTn9m1U52tyic9Dg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1715&quot;/&gt;&lt;/p&gt;&lt;section tn-link=&quot;compAttr.link || comp.link&quot;&gt;&lt;p&gt;&lt;span&gt;&lt;em&gt;强大的项目数据统计分析功能和醒目的可视化呈现，团队开发工作一目了然&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;&lt;em&gt;&lt;br/&gt;&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;section tn-link=&quot;compAttr.link || comp.link&quot;&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.6666666666666666&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/cmN2YSn1WojBMOZCCnVx1a2zdgV1krqr2H6dGJZXQqJq0mt8JJ5ePWgiaOUTueIv0K34RiaV8yg4ffEFcrClJGaw/640?wx_fmt=gif&quot; data-type=&quot;gif&quot; data-w=&quot;2539&quot;/&gt;&lt;/p&gt;&lt;/section&gt;&lt;section tn-link=&quot;compAttr.link || comp.link&quot;&gt;&lt;p&gt;&lt;span&gt;&lt;em&gt;简易Mock功能，减轻Mock规则编写压力&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;em&gt;&lt;br/&gt;&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;section tn-link=&quot;compAttr.link || comp.link&quot;&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.6666666666666666&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/cmN2YSn1WojBMOZCCnVx1a2zdgV1krqrDYW2icVyANpPHsPuwfww8EiaqFmK0kJr6ZH4iaovbWKApMJjFibQkRas0A/640?wx_fmt=gif&quot; data-type=&quot;gif&quot; data-w=&quot;2551&quot;/&gt;&lt;/p&gt;&lt;/section&gt;&lt;section tn-link=&quot;compAttr.link || comp.link&quot;&gt;&lt;p&gt;&lt;span&gt;&lt;em&gt;智能Mock功能，实现Mock规则零配置&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;section tn-link=&quot;compAttr.link || comp.link&quot;&gt;&lt;p&gt;&lt;span&gt;当然，Eolink的功能还远不止如此，还有很多亮点可以探索。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;目前SaaS产品完全免费，你可使用web版，也可下载桌面端，Windows、Mac、Linux 平台均支持！&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;体验地址：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span/&gt;https://www.eolink.com/?utm_source=w3003&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;&lt;section/&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;03.&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;API全生命周期解决方案&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Eolink除了API管理、自动化测试服务以外，还是全球首个API全生命周期管理的SaaS平台，提供包括&lt;span&gt;&lt;span&gt;API网关、API监控、API自动生成&lt;/span&gt;&lt;/span&gt;等服务。API-First大势所趋，不掌握API全生命周期管理容易掉队！&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.6666666666666666&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/LGh7bn8KbYDH7CosT0CQ8XJJW9w6aymWx3BeuCDTME8UbicHzsw2Fwr1TeGS97gyErHbtricHiajrVLsYHciaWm7AQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1210&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;/section&gt;&lt;section tn-link=&quot;compAttr.link || comp.link&quot;&gt;&lt;p&gt;&lt;span&gt;截至目前，Eolink已经为包括奇安信、深信服、泰康集团、索尼、统一企业、博时基金、圆通速递等&lt;/span&gt;&lt;span&gt;&lt;span&gt;3万家各行业领先的企业&lt;/span&gt;&lt;/span&gt;&lt;span&gt;提供API管理服务，私有云续费率接近100%，实力非常硬，口碑非常好，值得信赖！&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;扫码加入官方微信群，领取&lt;span&gt;&lt;span&gt;API全生命周期管理资料，&lt;/span&gt;&lt;/span&gt;&lt;span&gt;与开发团队进行深入交流！&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;section tn-link=&quot;compAttr.link || comp.link&quot;&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;1&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/eZzl4LXykQwyIvRlq2cmUWziaV05u38at25Ud0uTPFnNnT3D2qaiakiaSfV9T6BXPXYsYNLxoSpl1WicEmafS3T1kA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;section tn-link=&quot;compAttr.link || comp.link&quot;&gt;&lt;p&gt;&lt;span&gt;目前SaaS产品完全免费，你可使用web版，也可下载桌面端，Windows、Mac、Linux 平台均支持！更加厉害的是，他们还有开源产品！&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;体验地址：&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;https://www.eolink.com/?utm_source=w3003&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;
          &lt;/div&gt;

          

          



           
                                
                    
        &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>ef37379867b108924d600d5a3b13a03b</guid>
<title>使用Go语言开发eBPF程序</title>
<link>https://toutiao.io/k/c8oeoo7</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot; data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在前面的&lt;span&gt;《&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzIyNzM0MDk0Mg==&amp;amp;mid=2247492847&amp;amp;idx=1&amp;amp;sn=7472210233cee735527f2cd880aab40d&amp;amp;chksm=e860030edf178a18700016e7898e88882b03d5dca033841731b7eaa5c35bf12027b6b76b6232&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;使用C语言从头开发一个Hello World级别的eBPF程序》&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;使用C语言从头开发一个Hello World级别的eBPF程序》&lt;/a&gt;&lt;/span&gt;&lt;sup&gt;[1]&lt;/sup&gt;一文中，我们详细说明了如何基于C语言和libbpf库从头开发一个eBPF程序(包括其用户态部分)。那篇文章是后续有关eBPF程序开发文章的基础，因为到目前为止，无论eBPF程序的用户态部分用什么语言开发，运行于内核态的eBPF程序内核态部分还是必须由C语言开发的。这样一来，其他编程语言只能拼一下如何让eBPF程序的用户态部分的开发更为简单了，Go语言也不例外。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在Go社区中，目前最为活跃的用于开发eBPF用户态部分的Go eBPF包莫过于cilium项目开源的&lt;span&gt;cilium/ebpf&lt;/span&gt;&lt;sup&gt;[2]&lt;/sup&gt;，cilium项目背后的&lt;span&gt;Isovalent公司&lt;/span&gt;&lt;sup&gt;[3]&lt;/sup&gt;也是eBPF技术在云原生领域应用的主要推手之一。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;本文我们就来说说&lt;strong&gt;基于cilium/ebpf开发eBPF程序的套路&lt;/strong&gt;！&lt;/p&gt;&lt;p&gt;&lt;mpcps class=&quot;js_editor_new_cps&quot; data-traceid=&quot;undefined&quot; data-goodssouce=&quot;1&quot; data-pid=&quot;101_13694000&quot; data-appuin=&quot;3227340942&quot; data-buffer=&quot;{&amp;quot;category_id&amp;quot;:0,&amp;quot;pid&amp;quot;:&amp;quot;101_13694000&amp;quot;,&amp;quot;biz_uin&amp;quot;:&amp;quot;3227340942&amp;quot;,&amp;quot;sku_id&amp;quot;:&amp;quot;101_13694000&amp;quot;,&amp;quot;source_id&amp;quot;:2,&amp;quot;source_name&amp;quot;:&amp;quot;京东&amp;quot;,&amp;quot;audit_state&amp;quot;:1,&amp;quot;main_img&amp;quot;:&amp;quot;https://img.zhls.qq.com/3/3c88eec690984b17b01468415f9b5d18.jpg&amp;quot;,&amp;quot;product_name&amp;quot;:&amp;quot;Go语言精进之路：从新手到高手的编程思想、方法和技巧 套装共2册&amp;quot;,&amp;quot;current_price&amp;quot;:10900,&amp;quot;first_category_id&amp;quot;:&amp;quot;0&amp;quot;,&amp;quot;appuin&amp;quot;:&amp;quot;3227340942&amp;quot;,&amp;quot;isNewCpsKOL&amp;quot;:1}&quot;/&gt;&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;一. 探索cilium/ebpf项目示例&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;cilium/ebpf项目借鉴了&lt;span&gt;libbpf-boostrap&lt;/span&gt;&lt;sup&gt;[4]&lt;/sup&gt;的思路，通过代码生成与bpf程序内嵌的方式构建eBPF程序用户态部分。为了搞清楚基于cilium/ebpf开发ebpf程序的套路，我们先来探索一下cilium/ebpf项目提供的示例代码。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们首先来下载和看看ebpf的示例的结构。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;$ git &lt;span&gt;clone&lt;/span&gt; https://github.com/cilium/ebpf.git&lt;br/&gt;Cloning into &lt;span&gt;&#x27;ebpf&#x27;&lt;/span&gt;...&lt;br/&gt;remote: Enumerating objects: 7054, &lt;span&gt;done&lt;/span&gt;.&lt;br/&gt;remote: Counting objects: 100% (183/183), &lt;span&gt;done&lt;/span&gt;.&lt;br/&gt;remote: Compressing objects: 100% (112/112), &lt;span&gt;done&lt;/span&gt;.&lt;br/&gt;remote: Total 7054 (delta 91), reused 124 (delta 69), pack-reused 6871&lt;br/&gt;Receiving objects: 100% (7054/7054), 10.91 MiB | 265.00 KiB/s, &lt;span&gt;done&lt;/span&gt;.&lt;br/&gt;Resolving deltas: 100% (4871/4871), &lt;span&gt;done&lt;/span&gt;.&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;ebpf示例在examples目录下，我们以tracepoint_in_c为例看看其组织形式：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;$tree&lt;/span&gt; tracepoint_in_c&lt;br/&gt;tracepoint_in_c&lt;br/&gt;├── bpf_bpfeb.go&lt;br/&gt;├── bpf_bpfeb.o&lt;br/&gt;├── bpf_bpfel.go&lt;br/&gt;├── bpf_bpfel.o&lt;br/&gt;├── main.go&lt;br/&gt;└── tracepoint.c&lt;br/&gt;&lt;br/&gt;0 directories, 6 files&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;根据经验判断，这里面的tracepoint.c对应的是ebpf程序内核态部分，而main.go和bpf_bpfel.go/bpf_bpfeb.go则是ebpf程序用户态部分，至于bpf_bpfeb.o/bpf_bpfel.o应该是某种中间目标文件。通过readelf -a bpf_bpfeb.o查看该中间文件：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;$readelf&lt;/span&gt; -a bpf_bpfeb.o&lt;br/&gt;ELF Header:&lt;br/&gt;  Magic:   7f 45 4c 46 02 02 01 00 00 00 00 00 00 00 00 00 &lt;br/&gt;  Class:                             ELF64&lt;br/&gt;  Data:                              2&lt;span&gt;&#x27;s complement, big endian&lt;br/&gt;  Version:                           1 (current)&lt;br/&gt;  OS/ABI:                            UNIX - System V&lt;br/&gt;  ABI Version:                       0&lt;br/&gt;  Type:                              REL (Relocatable file)&lt;br/&gt;  Machine:                           Linux BPF&lt;br/&gt;  Version:                           0x1&lt;br/&gt;  Entry point address:               0x0&lt;br/&gt;  Start of program headers:          0 (bytes into file)&lt;br/&gt;  Start of section headers:          1968 (bytes into file)&lt;br/&gt;  Flags:                             0x0&lt;br/&gt;  Size of this header:               64 (bytes)&lt;br/&gt;  Size of program headers:           0 (bytes)&lt;br/&gt;  Number of program headers:         0&lt;br/&gt;  Size of section headers:           64 (bytes)&lt;br/&gt;  Number of section headers:         13&lt;br/&gt;  Section header string table index: 1&lt;br/&gt;... ...&lt;br/&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们看到这是一个内含linux bpf字节码的elf文件(Machine: Linux BPF)。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;阅读了cilium/ebpf的相关文档，我搞明白了这几个文件的关系，用下面示意图呈现给大家：&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.33671875&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/cH6WzfQ94mYY6v7wXhOUtfXGUBHe1Bbb5rWZ8ibe64dbviag4GDCPZuQrekib4YvqtLnCbkncibKiaC3lsM4z8pqAcg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;ebpf程序的源码文件(比如图中tracepoint.c)经过bpf2go(cilium/ebpf提供的一个代码生成工具)被编译(bpf2go调用clang)为ebpf字节码文件bpf_bpfeb.o(大端)和bpf_bpfel.o(小端)，然后bpf2go会基于ebpf字节码文件生成bpf_bpfeb.go或bpf_bpfel.go，ebpf程序的字节码会以二进制数据的形式内嵌到这两个go源文件中，以bpf_bpfel.go为例，我们可以在其代码中找到下面内容(利用&lt;span&gt;go:embed特性&lt;/span&gt;&lt;sup&gt;[5]&lt;/sup&gt;)：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;//go:embed bpf_bpfel.o&lt;br/&gt;var _BpfBytes []byte&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;main.go则是ebpf程序用户态部分的主程序，将main.go与bpf_bpfeb.go或bpf_bpfel.go之一一起编译就形成了ebpf程序。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;有了对cilium/ebpf项目示例的初步探索后，我们来构建ebpf示例代码。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;二. 构建ebpf示例代码&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;cilium/ebpf提供了便利的构建脚本，我们只需在ebpf/examples下面执行&quot;make -C ..&quot;即可进行示例代码的构建。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;make构建过程会基于quay.io/cilium/ebpf-builder镜像启动构建容器，不过在国内的童鞋需要像下面一样对Makefile内容做一丁点修改，增加GOPROXY环境变量，否则wall外的go module无法拉取：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;$git&lt;/span&gt; diff ../Makefile&lt;br/&gt;diff --git a/Makefile b/Makefile&lt;br/&gt;index 3a1da88..d7b1712 100644&lt;br/&gt;--- a/Makefile&lt;br/&gt;+++ b/Makefile&lt;br/&gt;@@ -48,6 +48,7 @@ container-all:&lt;br/&gt;        &lt;span&gt;${CONTAINER_ENGINE}&lt;/span&gt; run --rm &lt;span&gt;${CONTAINER_RUN_ARGS}&lt;/span&gt; \&lt;br/&gt;                -v &lt;span&gt;&quot;&lt;span&gt;${REPODIR}&lt;/span&gt;&quot;&lt;/span&gt;:/ebpf -w /ebpf --env MAKEFLAGS \&lt;br/&gt;                --env CFLAGS=&lt;span&gt;&quot;-fdebug-prefix-map=/ebpf=.&quot;&lt;/span&gt; \&lt;br/&gt;+               --env GOPROXY=&lt;span&gt;&quot;https://goproxy.io&quot;&lt;/span&gt; \&lt;br/&gt;                --env HOME=&lt;span&gt;&quot;/tmp&quot;&lt;/span&gt; \&lt;br/&gt;                &lt;span&gt;&quot;&lt;span&gt;${IMAGE}&lt;/span&gt;:&lt;span&gt;${VERSION}&lt;/span&gt;&quot;&lt;/span&gt; \&lt;br/&gt;                $(MAKE) all&lt;br/&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这之后再执行构建就会顺利得到我们所要的结果：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;$ &lt;span&gt;cd&lt;/span&gt; examples&lt;br/&gt;$ make -C ..&lt;br/&gt;make: Entering directory &lt;span&gt;&#x27;/root/go/src/github.com/cilium/ebpf&#x27;&lt;/span&gt;&lt;br/&gt;docker run --rm  --user &lt;span&gt;&quot;0:0&quot;&lt;/span&gt; \&lt;br/&gt;    -v &lt;span&gt;&quot;/root/go/src/github.com/cilium/ebpf&quot;&lt;/span&gt;:/ebpf -w /ebpf --env MAKEFLAGS \&lt;br/&gt;    --env CFLAGS=&lt;span&gt;&quot;-fdebug-prefix-map=/ebpf=.&quot;&lt;/span&gt; \&lt;br/&gt;    --env GOPROXY=&lt;span&gt;&quot;https://goproxy.io&quot;&lt;/span&gt; \&lt;br/&gt;    --env HOME=&lt;span&gt;&quot;/tmp&quot;&lt;/span&gt; \&lt;br/&gt;    &lt;span&gt;&quot;quay.io/cilium/ebpf-builder:1648566014&quot;&lt;/span&gt; \&lt;br/&gt;    make all&lt;br/&gt;make: Entering directory &lt;span&gt;&#x27;/ebpf&#x27;&lt;/span&gt;&lt;br/&gt;find . -&lt;span&gt;type&lt;/span&gt; f -name &lt;span&gt;&quot;*.c&quot;&lt;/span&gt; | xargs clang-format -i&lt;br/&gt;go generate ./cmd/bpf2go/&lt;span&gt;test&lt;/span&gt;&lt;br/&gt;go: downloading golang.org/x/sys v0.0.0-20210906170528-6f6e22806c34&lt;br/&gt;Compiled /ebpf/cmd/bpf2go/&lt;span&gt;test&lt;/span&gt;/test_bpfel.o&lt;br/&gt;Stripped /ebpf/cmd/bpf2go/&lt;span&gt;test&lt;/span&gt;/test_bpfel.o&lt;br/&gt;Wrote /ebpf/cmd/bpf2go/&lt;span&gt;test&lt;/span&gt;/test_bpfel.go&lt;br/&gt;Compiled /ebpf/cmd/bpf2go/&lt;span&gt;test&lt;/span&gt;/test_bpfeb.o&lt;br/&gt;Stripped /ebpf/cmd/bpf2go/&lt;span&gt;test&lt;/span&gt;/test_bpfeb.o&lt;br/&gt;Wrote /ebpf/cmd/bpf2go/&lt;span&gt;test&lt;/span&gt;/test_bpfeb.go&lt;br/&gt;go generate ./internal/sys&lt;br/&gt;enum AdjRoomMode&lt;br/&gt;enum AttachType&lt;br/&gt;enum Cmd&lt;br/&gt;enum FunctionId&lt;br/&gt;enum HdrStartOff&lt;br/&gt;enum LinkType&lt;br/&gt;enum MapType&lt;br/&gt;enum ProgType&lt;br/&gt;enum RetCode&lt;br/&gt;enum SkAction&lt;br/&gt;enum StackBuildIdStatus&lt;br/&gt;enum StatsType&lt;br/&gt;enum XdpAction&lt;br/&gt;struct BtfInfo&lt;br/&gt;... ...&lt;br/&gt;attr ProgRun&lt;br/&gt;attr RawTracepointOpen&lt;br/&gt;&lt;span&gt;cd&lt;/span&gt; examples/ &amp;amp;&amp;amp; go generate ./...&lt;br/&gt;go: downloading github.com/cilium/ebpf v0.8.2-0.20220424153111-6da9518107a8&lt;br/&gt;go: downloading golang.org/x/sys v0.0.0-20211001092434-39dca1131b70&lt;br/&gt;Compiled /ebpf/examples/cgroup_skb/bpf_bpfel.o&lt;br/&gt;Stripped /ebpf/examples/cgroup_skb/bpf_bpfel.o&lt;br/&gt;Wrote /ebpf/examples/cgroup_skb/bpf_bpfel.go&lt;br/&gt;Compiled /ebpf/examples/cgroup_skb/bpf_bpfeb.o&lt;br/&gt;Stripped /ebpf/examples/cgroup_skb/bpf_bpfeb.o&lt;br/&gt;Wrote /ebpf/examples/cgroup_skb/bpf_bpfeb.go&lt;br/&gt;Compiled /ebpf/examples/fentry/bpf_bpfeb.o&lt;br/&gt;Stripped /ebpf/examples/fentry/bpf_bpfeb.o&lt;br/&gt;Wrote /ebpf/examples/fentry/bpf_bpfeb.go&lt;br/&gt;Compiled /ebpf/examples/fentry/bpf_bpfel.o&lt;br/&gt;Stripped /ebpf/examples/fentry/bpf_bpfel.o&lt;br/&gt;Wrote /ebpf/examples/fentry/bpf_bpfel.go&lt;br/&gt;Compiled /ebpf/examples/kprobe/bpf_bpfel.o&lt;br/&gt;Stripped /ebpf/examples/kprobe/bpf_bpfel.o&lt;br/&gt;Wrote /ebpf/examples/kprobe/bpf_bpfel.go&lt;br/&gt;Stripped /ebpf/examples/uretprobe/bpf_bpfel_x86.o&lt;br/&gt;... ...&lt;br/&gt;Wrote /ebpf/examples/uretprobe/bpf_bpfel_x86.go&lt;br/&gt;ln -srf testdata/loader-clang-14-el.elf testdata/loader-el.elf&lt;br/&gt;ln -srf testdata/loader-clang-14-eb.elf testdata/loader-eb.elf&lt;br/&gt;make: Leaving directory &lt;span&gt;&#x27;/ebpf&#x27;&lt;/span&gt;&lt;br/&gt;make: Leaving directory &lt;span&gt;&#x27;/root/go/src/github.com/cilium/ebpf&#x27;&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;以uretprobe下面的ebpf为例，我们运行一下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;$go&lt;/span&gt; run -&lt;span&gt;exec&lt;/span&gt; sudo uretprobe/*.go&lt;br/&gt;2022/06/05 18:23:23 Listening &lt;span&gt;for&lt;/span&gt; events..&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;打开一个新的terminal，然后在用户home目录下执行vi .bashrc。在上面的uretprobe程序的执行窗口我们能看到：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;2022/06/05 18:24:34 Listening &lt;span&gt;for&lt;/span&gt; events..&lt;br/&gt;2022/06/05 18:24:42 /bin/bash:readline &lt;span&gt;return&lt;/span&gt; value: vi .bashrc&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这就表明uretprobe下面的ebpf程序如预期地执行了。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;三. 使用cilium/ebpf为前文的Hello World eBPF程序开发用户态部分&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;有了对cilium/ebpf示例程序的初步了解，下面我们就来为前面的&lt;span&gt;《使用C语言从头开发一个Hello World级别的eBPF程序》&lt;/span&gt;&lt;sup&gt;[6]&lt;/sup&gt;一文中的那个helloworld ebpf程序开发用户态部分。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;回顾一下那个hello world ebpf程序的C源码：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;// github.com/bigwhite/experiments/tree/master/ebpf-examples/helloworld-go/helloworld.bpf.c&lt;br/&gt;&lt;span&gt;#include &amp;lt;linux/bpf.h&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;#include &amp;lt;bpf/bpf_helpers.h&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;SEC(&lt;span&gt;&quot;tracepoint/syscalls/sys_enter_execve&quot;&lt;/span&gt;)&lt;br/&gt;&lt;br/&gt;int bpf_prog(void *ctx) {&lt;br/&gt;  char msg[] = &lt;span&gt;&quot;Hello, World!&quot;&lt;/span&gt;;&lt;br/&gt;  bpf_printk(&lt;span&gt;&quot;invoke bpf_prog: %s\n&quot;&lt;/span&gt;, msg);&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; 0;&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;char LICENSE[] SEC(&lt;span&gt;&quot;license&quot;&lt;/span&gt;) = &lt;span&gt;&quot;Dual BSD/GPL&quot;&lt;/span&gt;;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当这个ebpf程序被加载到内核中后，每当execve这个系统调用被执行，该ebpf程序都会被调用一次，我们就会在/sys/kernel/debug/tracing/trace_pipe中看到对应的日志输出。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;1. 使用bpf2go将ebpf核心态程序转换为Go代码&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;根据我们在前面探索cilium/ebpf示例程序时所得到的“套路”，我们接下来第一个要做的就是将helloworld.bpf.c转换为Go代码文件，这一转换过程不可缺少的工具就是cilium/ebpf提供的bpf2go工具，我们先来安装一下该工具：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;$go&lt;/span&gt; install github.com/cilium/ebpf/cmd/bpf2go@latest&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;接下来，我们可以直接使用bpf2go工具将helloworld.ebpf.c转换为对应的go源文件：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;$GOPACKAGE&lt;/span&gt;=main bpf2go -cc clang-10 -cflags &lt;span&gt;&#x27;-O2 -g -Wall -Werror&#x27;&lt;/span&gt; -target bpfel,bpfeb bpf helloworld.bpf.c -- -I /home/tonybai/&lt;span&gt;test&lt;/span&gt;/ebpf/libbpf/include/uapi -I /usr/&lt;span&gt;local&lt;/span&gt;/bpf/include -idirafter /usr/&lt;span&gt;local&lt;/span&gt;/include -idirafter /usr/lib/llvm-10/lib/clang/10.0.0/include -idirafter /usr/include/x86_64-linux-gnu -idirafter /usr/include&lt;br/&gt;&lt;br/&gt;Compiled /home/tonybai/go/src/github.com/bigwhite/experiments/ebpf-examples/helloworld-go/bpf_bpfel.o&lt;br/&gt;Stripped /home/tonybai/go/src/github.com/bigwhite/experiments/ebpf-examples/helloworld-go/bpf_bpfel.o&lt;br/&gt;Wrote /home/tonybai/go/src/github.com/bigwhite/experiments/ebpf-examples/helloworld-go/bpf_bpfel.go&lt;br/&gt;Compiled /home/tonybai/go/src/github.com/bigwhite/experiments/ebpf-examples/helloworld-go/bpf_bpfeb.o&lt;br/&gt;Stripped /home/tonybai/go/src/github.com/bigwhite/experiments/ebpf-examples/helloworld-go/bpf_bpfeb.o&lt;br/&gt;Wrote /home/tonybai/go/src/github.com/bigwhite/experiments/ebpf-examples/helloworld-go/bpf_bpfeb.go&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;不过这里有一个问题，那就是bpf2go命令行后面的一系列提供给clang编译器的头文件引用路径参考了&lt;span&gt;《使用C语言从头开发一个Hello World级别的eBPF程序》&lt;/span&gt;&lt;sup&gt;[7]&lt;/sup&gt;一文中的Makefile。如果按照这些头文件路径来引用，虽然bpf2go转换可以成功，但是我们需要依赖并安装libbpf这个库，这显然不是我们想要的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;cilium/ebpf在examples中提供了一个headers目录，这个目录中包含了开发ebpf程序用户态部分所需的所有头文件，我们使用它作为我们的头文件引用路径。不过要想基于这个headers目录构建ebpf，我们需要将helloworld.bpf.c中的原头文件include语句由：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;#include &amp;lt;linux/bpf.h&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;#include &amp;lt;bpf/bpf_helpers.h&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;改为：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;#include &quot;common.h&quot;&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;接下来我们再来执行bpf2go工具进行转换：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;$GOPACKAGE&lt;/span&gt;=main bpf2go -cc clang-10 -cflags &lt;span&gt;&#x27;-O2 -g -Wall -Werror&#x27;&lt;/span&gt; -target bpfel,bpfeb bpf helloworld.bpf.c -- -I /home/tonybai/go/src/github.com/cilium/ebpf/examples/headers&lt;br/&gt;&lt;br/&gt;Compiled /home/tonybai/go/src/github.com/bigwhite/experiments/ebpf-examples/helloworld-go/bpf_bpfel.o&lt;br/&gt;Stripped /home/tonybai/go/src/github.com/bigwhite/experiments/ebpf-examples/helloworld-go/bpf_bpfel.o&lt;br/&gt;Wrote /home/tonybai/go/src/github.com/bigwhite/experiments/ebpf-examples/helloworld-go/bpf_bpfel.go&lt;br/&gt;Compiled /home/tonybai/go/src/github.com/bigwhite/experiments/ebpf-examples/helloworld-go/bpf_bpfeb.o&lt;br/&gt;Stripped /home/tonybai/go/src/github.com/bigwhite/experiments/ebpf-examples/helloworld-go/bpf_bpfeb.o&lt;br/&gt;Wrote /home/tonybai/go/src/github.com/bigwhite/experiments/ebpf-examples/helloworld-go/bpf_bpfeb.go&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们看到bpf2go顺利生成ebpf字节码与对应的Go源文件。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;2. 构建helloworld ebpf程序用户态部分&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;下面是参考cilium/ebpf示例而构建的helloword ebpf程序用户态部分的main.go源码：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;// github.com/bigwhite/experiments/ebpf-examples/helloworld-go/main.go&lt;br/&gt;package main&lt;br/&gt;&lt;br/&gt;import (&lt;br/&gt; &lt;span&gt;&quot;log&quot;&lt;/span&gt;&lt;br/&gt; &lt;span&gt;&quot;os&quot;&lt;/span&gt;&lt;br/&gt; &lt;span&gt;&quot;os/signal&quot;&lt;/span&gt;&lt;br/&gt; &lt;span&gt;&quot;syscall&quot;&lt;/span&gt;&lt;br/&gt;&lt;br/&gt; &lt;span&gt;&quot;github.com/cilium/ebpf/link&quot;&lt;/span&gt;&lt;br/&gt; &lt;span&gt;&quot;github.com/cilium/ebpf/rlimit&quot;&lt;/span&gt;&lt;br/&gt;)&lt;br/&gt;&lt;br/&gt;func &lt;span&gt;&lt;span&gt;main&lt;/span&gt;&lt;/span&gt;() {&lt;br/&gt; stopper := make(chan os.Signal, 1)&lt;br/&gt; signal.Notify(stopper, os.Interrupt, syscall.SIGTERM)&lt;br/&gt;&lt;br/&gt; // Allow the current process to lock memory &lt;span&gt;for&lt;/span&gt; eBPF resources.&lt;br/&gt; &lt;span&gt;if&lt;/span&gt; err := rlimit.RemoveMemlock(); err != nil {&lt;br/&gt;  log.Fatal(err)&lt;br/&gt; }&lt;br/&gt;&lt;br/&gt; // Load pre-compiled programs and maps into the kernel.&lt;br/&gt; objs := bpfObjects{}&lt;br/&gt; &lt;span&gt;if&lt;/span&gt; err := loadBpfObjects(&amp;amp;objs, nil); err != nil {&lt;br/&gt;  log.Fatalf(&lt;span&gt;&quot;loading objects: %s&quot;&lt;/span&gt;, err)&lt;br/&gt; }&lt;br/&gt; defer objs.Close()&lt;br/&gt;&lt;br/&gt; //SEC(&lt;span&gt;&quot;tracepoint/syscalls/sys_enter_execve&quot;&lt;/span&gt;)&lt;br/&gt; // attach to xxx&lt;br/&gt; kp, err := link.Tracepoint(&lt;span&gt;&quot;syscalls&quot;&lt;/span&gt;, &lt;span&gt;&quot;sys_enter_execve&quot;&lt;/span&gt;, objs.BpfProg, nil)&lt;br/&gt; &lt;span&gt;if&lt;/span&gt; err != nil {&lt;br/&gt;  log.Fatalf(&lt;span&gt;&quot;opening tracepoint: %s&quot;&lt;/span&gt;, err)&lt;br/&gt; }&lt;br/&gt; defer kp.Close()&lt;br/&gt;&lt;br/&gt; log.Printf(&lt;span&gt;&quot;Successfully started! Please run \&quot;sudo cat /sys/kernel/debug/tracing/trace_pipe\&quot; to see output of the BPF programs\n&quot;&lt;/span&gt;)&lt;br/&gt;&lt;br/&gt; // Wait &lt;span&gt;for&lt;/span&gt; a signal and close the perf reader,&lt;br/&gt; // &lt;span&gt;which&lt;/span&gt; will interrupt rd.Read() and make the program &lt;span&gt;exit&lt;/span&gt;.&lt;br/&gt; &amp;lt;-stopper&lt;br/&gt; log.Println(&lt;span&gt;&quot;Received signal, exiting program..&quot;&lt;/span&gt;)&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们知道一个ebpf程序有几个关键组成：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;ebpf程序数据&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;map：用于用户态与内核态的数据交互&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;挂接点(attach point)&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;根据&lt;span&gt;cilium/ebpf架构&lt;/span&gt;&lt;sup&gt;[8]&lt;/sup&gt;的说明，ebpf包将前两部分抽象为了一个数据结构bpfObjects：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;// github.com/bigwhite/experiments/ebpf-examples/helloworld-go/bpf_bpfel.go&lt;br/&gt;&lt;br/&gt;// bpfObjects contains all objects after they have been loaded into the kernel.&lt;br/&gt;//&lt;br/&gt;// It can be passed to loadBpfObjects or ebpf.CollectionSpec.LoadAndAssign.&lt;br/&gt;&lt;span&gt;type&lt;/span&gt; bpfObjects struct {&lt;br/&gt;    bpfPrograms&lt;br/&gt;    bpfMaps&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们看到，main函数通过生成的loadBpfObjects函数将ebpf程序加载到内核，并填充bpfObjects结构，一旦加载bpf程序成功，后续我们便可以使用bpfObjects结构中的字段来完成其余操作，比如通过link包的函数将bpf程序与目标挂节点对接在一起(如文中的link.Tracepoint函数），这样挂接后，bpf才能在对应的事件发生后被回调执行。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;下面编译执行一下该helloworld示例：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;$go&lt;/span&gt; run -&lt;span&gt;exec&lt;/span&gt; sudo main.go bpf_bpfel.go&lt;br/&gt;[sudo] password &lt;span&gt;for&lt;/span&gt; tonybai: &lt;br/&gt;2022/06/05 14:12:40 Successfully started! Please run &lt;span&gt;&quot;sudo cat /sys/kernel/debug/tracing/trace_pipe&quot;&lt;/span&gt; to see output of the BPF programs&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;之后新打开一个窗口，执行sudo cat /sys/kernel/debug/tracing/trace_pipe，当execve被调用时，我们就能看到类似下面的日志输出：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&amp;lt;...&amp;gt;-551077  [000] .... 6062226.208943: 0: invoke bpf_prog: Hello, World!&lt;br/&gt;&amp;lt;...&amp;gt;-551077  [000] .... 6062226.209098: 0: invoke bpf_prog: Hello, World!&lt;br/&gt;&amp;lt;...&amp;gt;-551079  [007] .... 6062226.215421: 0: invoke bpf_prog: Hello, World!&lt;br/&gt;&amp;lt;...&amp;gt;-551079  [007] .... 6062226.215578: 0: invoke bpf_prog: Hello, World!&lt;br/&gt;&amp;lt;...&amp;gt;-554756  [007] .... 6063476.785212: 0: invoke bpf_prog: Hello, World!&lt;br/&gt;&amp;lt;...&amp;gt;-554756  [007] .... 6063476.785378: 0: invoke bpf_prog: Hello, World!&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;3. 使用go generate来驱动bpf2go的转换&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在生成代码方面，Go工具链原生提供了go generate工具，cilium/ebpf的examples中也是利用go generate来驱动bpf2go将bpf程序转换为Go源文件的，这里我们也来做一下改造。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;首先我们在main.go的main函数上面增加一行go:generate指示语句：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;// github.com/bigwhite/experiments/ebpf-examples/helloworld-go/main.go&lt;br/&gt;&lt;br/&gt;// &lt;span&gt;$BPF_CLANG&lt;/span&gt;, &lt;span&gt;$BPF_CFLAGS&lt;/span&gt; and &lt;span&gt;$BPF_HEADERS&lt;/span&gt; are &lt;span&gt;set&lt;/span&gt; by the Makefile.&lt;br/&gt;//go:generate bpf2go -cc &lt;span&gt;$BPF_CLANG&lt;/span&gt; -cflags &lt;span&gt;$BPF_CFLAGS&lt;/span&gt; -target bpfel,bpfeb bpf helloworld.bpf.c -- -I &lt;span&gt;$BPF_HEADERS&lt;/span&gt;&lt;br/&gt;func &lt;span&gt;&lt;span&gt;main&lt;/span&gt;&lt;/span&gt;() {&lt;br/&gt;    stopper := make(chan os.Signal,  1)&lt;br/&gt;    ... ...&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这样当我们显式执行go generate语句时，go generate会扫描到该指示语句，并执行后面的命令。这里使用了几个变量，变量是定义在Makefile中的。当然如果你不想使用Makefile，也可以将变量替换为相应的值。这里我们使用Makefile，下面是Makefile的内容：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;// github.com/bigwhite/experiments/ebpf-examples/helloworld-go/Makefile&lt;br/&gt;&lt;br/&gt;CLANG ?= clang-10&lt;br/&gt;CFLAGS ?= -O2 -g -Wall -Werror&lt;br/&gt;&lt;br/&gt;LIBEBPF_TOP = /home/tonybai/go/src/github.com/cilium/ebpf&lt;br/&gt;EXAMPLES_HEADERS = $(LIBEBPF_TOP)/examples/headers&lt;br/&gt;&lt;br/&gt;all: generate&lt;br/&gt;&lt;br/&gt;generate: &lt;span&gt;export&lt;/span&gt; BPF_CLANG=$(CLANG)&lt;br/&gt;generate: &lt;span&gt;export&lt;/span&gt; BPF_CFLAGS=$(CFLAGS)&lt;br/&gt;generate: &lt;span&gt;export&lt;/span&gt; BPF_HEADERS=$(EXAMPLES_HEADERS)&lt;br/&gt;generate:&lt;br/&gt; go generate ./...&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;有了该Makefile后，我们执行make命令便可以执行bpf2go对bpf程序的转换：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;$make&lt;/span&gt;&lt;br/&gt;go generate ./...&lt;br/&gt;Compiled /home/tonybai/go/src/github.com/bigwhite/experiments/ebpf-examples/helloworld-go/bpf_bpfel.o&lt;br/&gt;Stripped /home/tonybai/go/src/github.com/bigwhite/experiments/ebpf-examples/helloworld-go/bpf_bpfel.o&lt;br/&gt;Wrote /home/tonybai/go/src/github.com/bigwhite/experiments/ebpf-examples/helloworld-go/bpf_bpfel.go&lt;br/&gt;Compiled /home/tonybai/go/src/github.com/bigwhite/experiments/ebpf-examples/helloworld-go/bpf_bpfeb.o&lt;br/&gt;Stripped /home/tonybai/go/src/github.com/bigwhite/experiments/ebpf-examples/helloworld-go/bpf_bpfeb.o&lt;br/&gt;Wrote /home/tonybai/go/src/github.com/bigwhite/experiments/ebpf-examples/helloworld-go/bpf_bpfeb.go&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;四. 小结&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;本文我们讲解了如何基于cilium/ebpf包来开发ebpf的用户态部分。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;ebpf借鉴了libbpf的思路，通过生成代码与数据内嵌的方式来构建ebpf的用户态部分。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;ebpf提供了bpf2go工具，可以将bpf的C源码转换为相应的go源码。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;ebpf将bpf程序抽象为bpfObjects，通过生成的loadBpfObjects完成bpf程序加载到内核的过程，然后利用ebpf库提供的诸如link之类的包实现ebpf与内核事件的关联。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;ebpf包的玩法还有很多，这一篇仅仅是为了打好基础，在后续文章中，我们还会针对各种类型的bpf程序做进一步学习和说明。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;本文代码可以在&lt;span&gt;这里&lt;/span&gt;&lt;sup&gt;[9]&lt;/sup&gt;下载。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;无. 参考资料&lt;/h3&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;使用Go语言管理和分发ebpf程序&lt;/span&gt;&lt;sup&gt;[10]&lt;/sup&gt; - https://www.ebpf.top/post/ebpf_go/&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;A Pure Go eBPF library&lt;/span&gt;&lt;sup&gt;[11]&lt;/sup&gt; - https://lpc.events/event/4/contributions/449/attachments/239/529/A_pure_Go_eBPF_library.pdf&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;cilium ebpf library architecture&lt;/span&gt;&lt;sup&gt;[12]&lt;/sup&gt; - https://github.com/cilium/ebpf/blob/master/ARCHITECTURE.md&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;hr data-tool=&quot;mdnice编辑器&quot;/&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;“Gopher部落”知识星球&lt;/span&gt;&lt;sup&gt;[13]&lt;/sup&gt;旨在打造一个精品Go学习和进阶社群！高品质首发Go技术文章，“三天”首发阅读权，每年两期Go语言发展现状分析，每天提前1小时阅读到新鲜的Gopher日报，网课、技术专栏、图书内容前瞻，六小时内必答保证等满足你关于Go语言生态的所有需求！2022年，Gopher部落全面改版，将持续分享Go语言与Go应用领域的知识、技巧与实践，并增加诸多互动形式。欢迎大家加入！&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1.247167868177137&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/cH6WzfQ94mb54jsFJZ3Knmz8obUsf3PBIMyZScLjHJSVL4jnaGBSFYZNhRQEwdUoGsAISHfVKfCHhWPic8yY0Ow/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;971&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6484620213433773&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/cH6WzfQ94mYKSeNd014VMtNhYulia0OHrHVoyrVYb2JvBa5ycFaeDfscQdubicnZkxB6je42bo3J4cZcx0FticLmQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1593&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.48884976525821594&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/cH6WzfQ94mb54jsFJZ3Knmz8obUsf3PBShthmdSw5E01TcYmUReGkj0BWpxHak1HlnlzHvLmKax53YSGr7aNlA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1704&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Gopher Daily(Gopher每日新闻)归档仓库 - https://github.com/bigwhite/gopherdaily&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我的联系方式：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;微博：https://weibo.com/bigwhite20xx&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;博客：tonybai.com&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;github: https://github.com/bigwhite&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.3436123348017621&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/cH6WzfQ94mb54jsFJZ3Knmz8obUsf3PBrSoqeMvoWCticN2cpU64fJ0FYQdXJhP7ia7WRh8628uOAsQYeE2NibRRw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1816&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;商务合作方式：撰稿、出书、培训、在线课程、合伙创业、咨询、广告合作。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;参考资料&lt;/span&gt;&lt;/h3&gt;&lt;section data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;span&gt;[1] &lt;/span&gt;&lt;p&gt;《使用C语言从头开发一个Hello World级别的eBPF程序》: &lt;em&gt;https://tonybai.com/2022/07/05/develop-hello-world-ebpf-program-in-c-from-scratch&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[2] &lt;/span&gt;&lt;p&gt;cilium/ebpf: &lt;em&gt;https://github.com/cilium/ebpf/&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[3] &lt;/span&gt;&lt;p&gt;Isovalent公司: &lt;em&gt;https://isovalent.com/&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[4] &lt;/span&gt;&lt;p&gt;libbpf-boostrap: &lt;em&gt;https://github.com/libbpf/libbpf-bootstrap&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[5] &lt;/span&gt;&lt;p&gt;go:embed特性: &lt;em&gt;https://tonybai.com/2021/02/25/some-changes-in-go-1-16&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[6] &lt;/span&gt;&lt;p&gt;《使用C语言从头开发一个Hello World级别的eBPF程序》: &lt;em&gt;https://tonybai.com/2022/07/05/develop-hello-world-ebpf-program-in-c-from-scratch&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[7] &lt;/span&gt;&lt;p&gt;《使用C语言从头开发一个Hello World级别的eBPF程序》: &lt;em&gt;https://tonybai.com/2022/07/05/develop-hello-world-ebpf-program-in-c-from-scratch&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[8] &lt;/span&gt;&lt;p&gt;cilium/ebpf架构: &lt;em&gt;https://github.com/cilium/ebpf/blob/master/ARCHITECTURE.md&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[9] &lt;/span&gt;&lt;p&gt;这里: &lt;em&gt;https://github.com/bigwhite/experiments/tree/master/ebpf-examples/helloworld-go&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[10] &lt;/span&gt;&lt;p&gt;使用Go语言管理和分发ebpf程序: &lt;em&gt;https://www.ebpf.top/post/ebpf_go/&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[11] &lt;/span&gt;&lt;p&gt;A Pure Go eBPF library: &lt;em&gt;https://lpc.events/event/4/contributions/449/attachments/239/529/A_pure_Go_eBPF_library.pdf&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[12] &lt;/span&gt;&lt;p&gt;cilium ebpf library architecture: &lt;em&gt;https://github.com/cilium/ebpf/blob/master/ARCHITECTURE.md&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[13] &lt;/span&gt;&lt;p&gt;“Gopher部落”知识星球: &lt;em&gt;https://wx.zsxq.com/dweb2/index/group/51284458844544&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>f1f0067e47a3fda428f219ee62311d89</guid>
<title>揭秘技术 Leader 必备的 7 大清奇脑回路</title>
<link>https://toutiao.io/k/btmeu2x</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-backh=&quot;254&quot; data-backw=&quot;558&quot; data-ratio=&quot;0.4546296296296296&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ufWcjcomw8ZTbQuMFY7zgaVql5ZjYOicbz1sJvOY0HjhKmf72FRNd0ibleicbX0uOZtYgz9GQT0ux5hRoXFodQYag/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;span&gt;技术常用思考方法&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;86122&quot; data-custom=&quot;#138bde&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;一、向前思考，向后倒推&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;这个思考方法的含义是：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在思考一个命题时可以采取未来视角，先对未来发展做个预判，然后基于你的判断倒推现在应该要做什么，最后制定出关键里程碑和节奏。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;这个思考模型经常用在技术规划这个场景上，但很遗憾很多团队的技术规划都只是基于当前问题，有多少资源，然后采取量力而行的方法在对事项优先级进行排序。这其实不是真正的规划，最多算是计划（如果做得不好，计划都算不上，只能算是列表整理）。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;这个思考模型有几个关键的误区：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;86152&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;span data-bgopacity=&quot;40%&quot;/&gt; &lt;span data-bgopacity=&quot;25%&quot;/&gt; &lt;span/&gt;&lt;/section&gt;&lt;section&gt;&lt;section data-brushtype=&quot;text&quot;&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;1、不敢向前思考，担心自己对未来的判断不对&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;span&gt;我相信很多 Leader 都有这样的恐惧，会不会因为自己思考力不够判断失误导致团队拿不到结果。有这样的担心可以理解但是对事项推动无意义，因为：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-role=&quot;list&quot;/&gt;&lt;section data-role=&quot;list&quot;/&gt;&lt;section data-role=&quot;list&quot;/&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;所以需要 Leader 信息充分交换分享，有信心地对未来做出合理的判断，并与相关角色达成共识。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;86152&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;span data-bgopacity=&quot;40%&quot;/&gt;&lt;span data-bgopacity=&quot;25%&quot;/&gt;&lt;span/&gt;&lt;/section&gt;&lt;section&gt;&lt;section data-brushtype=&quot;text&quot;&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;2、只有向前思考，没有向后倒推&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;span&gt;也见过只有向前思考但没有一点向后倒推的技术规划，这种就是典型的飘在天上，形而上的概念一堆。但实际上这个思考模型的精髓就是在向后推的结合：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-role=&quot;list&quot;/&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-role=&quot;list&quot;/&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-role=&quot;list&quot;/&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-role=&quot;list&quot;/&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;86122&quot; data-custom=&quot;#138bde&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;二、目标与路径&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;span&gt;这个思考方法的含义是：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在思考一个命题要关注什么是目标，什么是路径以及目标与路径的关系。离开路径的目标是空谈，离开目标的路径是瞎干，所以目标与路径是一体两面的，离开任何一个不谈其实都不成立。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;同样地在技术规划这个场合，大家可以仔细去看看，很多规划都是只有目标的（这点其实已经做得蛮好了，因为大家的意识已经觉醒，没有目标不往下谈，所以不管目标设立好与坏但至少都是有的），但很少有规划是把路径讲清楚。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;虽然这个思考模型见闻知义很好理解，但同样地这个思考模型也有一些误区：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;86152&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;span data-bgopacity=&quot;40%&quot;/&gt; &lt;span data-bgopacity=&quot;25%&quot;/&gt; &lt;span/&gt;&lt;/section&gt;&lt;section&gt;&lt;section data-brushtype=&quot;text&quot;&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;1、目标一定是要用来完成的&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;span&gt;Leader 都是要背负绩效压力的，所以天然就会有一个误区认为每一个目标都必须一丝不苟去完成。但一个低价值的 100%完成的目标 与 一个高价值的 90%完成的目标，未必一定是 100%完成就能拿高绩效，关键还是要看对组织的价值贡献。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;所以 Leader 还是要辩证看这个问题，在设定目标时目标要具备很强的牵引性才行，是让需要团队去跳一跳的才能够达成的，让团队有斗志；自己在完成目标时也要带着团队努力往前冲，朝着高目标去想一切办法拿结果，但也要随时观察团队状态，不能为了达成目标不择手段或者把团队干废了。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;86152&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;span data-bgopacity=&quot;40%&quot;/&gt; &lt;span data-bgopacity=&quot;25%&quot;/&gt; &lt;span/&gt;&lt;/section&gt;&lt;section&gt;&lt;section data-brushtype=&quot;text&quot;&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;2、路径执行时被惯性带着走&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;section&gt;&lt;span&gt;在细化目标的执行路径时，我们一般都会得到比较细致的 ACTION，甚至会有专人来管理和跟踪这些 ACTION。但比较容易出现的偏差就在于，我们做着做着就把初心忘了，把目标置于脑后了。典型的就是死命按照既定的路线走，没有重新基于当时的情况再回头看目标，去找是否还有更优的路径选择。所以时刻要反思什么是目的，什么是手段，不能把手段当成目的一味地执行。&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;86122&quot; data-custom=&quot;#138bde&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;三、端到端思考&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;span&gt;这个思考方法的含义是：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在思考一个命题要尽可能关注到全链路，而不是铁路警察各管一端。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;这个使用的场景是在于线上的问题治理和优化，尤其是客户体验问题或者是效能提升的课题上。这个思考模式也是非常简单，但是同样误区也蛮多：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;86152&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;span data-bgopacity=&quot;40%&quot;/&gt; &lt;span data-bgopacity=&quot;25%&quot;/&gt; &lt;span/&gt;&lt;/section&gt;&lt;section&gt;&lt;section data-brushtype=&quot;text&quot;&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;1、端到端从哪儿到哪儿没搞清楚&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;span&gt;想到端到端去思考和解决问题是非常好的，而且大家脑补就能理解大致想干什么事情。但这个思考模式最大的误区就在于它只是存在于大家的脑子里面，而不是白纸黑字写下来。最典型的场景就是 B 提出端到端思考解决了自己域的问题，但 A 未加仔细辨别，一听到端到端就想当然以为 B 也解决了 A 的问题。但实际上发现根本不是一码事，A 就开始吐槽 B 承诺没做到，B 就吐槽 A 瞎胡说。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;要破解这个误区其实也蛮简单，就是把全流程画出来，大家先基于客观事实把流程达成一致，然后再在这个流程上圈定端到端是具体哪一段到哪一段。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;86152&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;span data-bgopacity=&quot;40%&quot;/&gt; &lt;span data-bgopacity=&quot;25%&quot;/&gt; &lt;span/&gt;&lt;/section&gt;&lt;section&gt;&lt;section data-brushtype=&quot;text&quot;&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;2、效果没有说清楚假定条件&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;section&gt;&lt;span&gt;端到端一方面是把问题看全，另外一方面最重要的就是整体交付价值。这个端到端整体交付价值也有一个非常大的误区就是，对于假定条件没有说清楚。以端到端提效为例，那么提效就应该要讲清楚是基于什么业务范围做的端到端提效，以及能够达到什么提效效果。比较好的办法就是，以表格的形式把条件列清楚，然后对外给予端到端提效的明确效能结论。提效这个事其实没有尽头，只要做不到0投入那就一定要给予效能的确定性、相比较而言大家最怕的是效能不确定打乱原有的生产计划，而不是非要死扣几个人日的效能提升。&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;86122&quot; data-custom=&quot;#138bde&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;四、闭环思考&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;这个思考方法的含义是：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;这其实是一个很形象的逻辑思考方法，思考一个命题要从初心出发再回到初心，以免出现重大偏差。这个模式理解起来也不复杂，但也有一些误区：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;86152&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;span data-bgopacity=&quot;40%&quot;/&gt; &lt;span data-bgopacity=&quot;25%&quot;/&gt; &lt;span/&gt;&lt;/section&gt;&lt;section&gt;&lt;section data-brushtype=&quot;text&quot;&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;1、形而上的假闭环&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;span&gt;这其实是很多 Leader 非常容易走入的误区，没有实际展开命题的多个环节去做分析和探讨，把这种要求一味传递给团队要求做闭环的思考，即只有管理要求但缺乏技术领导力的洞察。一般来说，解题一个技术命题从开始孕育到落地有如下几步：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-role=&quot;list&quot;/&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-role=&quot;list&quot;/&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-role=&quot;list&quot;/&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-role=&quot;list&quot;/&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-role=&quot;list&quot;/&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-role=&quot;list&quot;/&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-role=&quot;list&quot;/&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-role=&quot;list&quot;/&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-role=&quot;list&quot;/&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-role=&quot;list&quot;/&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;很多时候我们并没有真正的在闭环思考和跟进问题，如漏掉某些节点，或某些节点退出过早：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-role=&quot;list&quot;/&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-role=&quot;list&quot;/&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;86152&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;span data-bgopacity=&quot;40%&quot;/&gt; &lt;span data-bgopacity=&quot;25%&quot;/&gt; &lt;span/&gt;&lt;/section&gt;&lt;section&gt;&lt;section data-brushtype=&quot;text&quot;&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;2、缺少进阶的下一环&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;span&gt;闭环思维某种意义上应该说环环相扣的螺旋式上升的过程，这样才是能够不断驱动开启下一轮的进化。但很多 Leader 并没有很好意识到这个问题。以上述的闭环 10 个步骤为例，Leader 应该是在小胜即庆时就开始思考下一个觉察，在抛物线的顶点之前开始下一轮的思考继续才能够确保下一个闭环能够及时开启，进入螺旋式的优化进程中。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;86122&quot; data-custom=&quot;#138bde&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;五、指标量化思考&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;这个思考方法的含义是：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;没有量化就谈不上优化，所以在定义和推动解决一个命题时，要尽可能地把遇到的问题用数据指标的方式进行量化思考。同样的这个思考模式也有一些误区：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;86152&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;span data-bgopacity=&quot;40%&quot;/&gt; &lt;span data-bgopacity=&quot;25%&quot;/&gt; &lt;span/&gt;&lt;/section&gt;&lt;section&gt;&lt;section data-brushtype=&quot;text&quot;&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;1、量化的维度缺失导致缺少客观性&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;span&gt;量化的本质其实是逼迫 Leader 更全面，更客观地理解问题。但要是更加客观地通过数据出现一个问题，也还是需要一些技巧，否则就会陷入心中已有答案，只是通过数据去做证明的困境。尤其是大团队越是要注意这个问题，通常来说组织这个群体是有自己的偏好，也是有动力和意愿去促成组织所偏好的事情。比如做技术的就倾向于偏好引导往架构优化上去，做业务的就会倾向于引导往完成 KPI 上去，但事实上更客观的应该是如何高效满足客户价值。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;如何突破这个误区，我得到的经验思考就是呈现的数据维度与客观世界的匹配度，越高的就越客观，越客观才越有利于解决问题。只有通过数据量化出来这个问题才有可能找到可能的解法，才有后续方案选择时的取舍，不能本末倒置为因为选定了方案然后通过数据去论证取舍的合理性。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;86152&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;span data-bgopacity=&quot;40%&quot;/&gt; &lt;span data-bgopacity=&quot;25%&quot;/&gt; &lt;span/&gt;&lt;/section&gt;&lt;section&gt;&lt;section data-brushtype=&quot;text&quot;&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;2、量化的数据断层解读后的欺骗性&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;span&gt;数据客观反映只是第一步，如何解读才是决定了数据的利用价值。不怕没看到真相，只怕看到真相的一部分，不恰当的解读方法就会让我们看到真相的部分从而得出错误的结论。比如把自己和首富的财富的平均下，给人的感觉就是全民收入都大涨。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;常见的数据解读方法如下：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-role=&quot;list&quot;/&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-role=&quot;list&quot;/&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-role=&quot;list&quot;/&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-role=&quot;list&quot;/&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;数据指标量化其实可以用在任何一个场景，但很多人的触发机制不是很敏感，常常忘记这个思考模型。导致很多事情实际上是在靠感觉，靠感觉的东西不长久，有时候对有时候错。越是比较抽象比较虚比较容易讲感觉的恰好就是练习的好时机，当你下次感觉到团队状态不对时，你可以尝试下如何用数据指标化的方法去做个思考，看能够量化出来哪些维度的数据。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;86122&quot; data-custom=&quot;#138bde&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;六、故事与形象思考&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;这个思考方法的含义是：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;技术 Leader 在给大家讲解自己的思考时，要注意通过故事的形象思考，尽可能将问题讲得透，让大家都能够懂。这一点是很多技术人都不是特别重视的地方，他们往往这样想：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;86152&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;span data-bgopacity=&quot;40%&quot;/&gt; &lt;span data-bgopacity=&quot;25%&quot;/&gt; &lt;span/&gt;&lt;/section&gt;&lt;section&gt;&lt;section data-brushtype=&quot;text&quot;&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;1、技术人踏实会干比能说会道重要得多，前者才是真正的硬核技能&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;span&gt;这反映了很多技术人的潜意识想法，尤其是做底层的同学。但我们是忘记人类协作的本质就是基于共同想象，如果我们都不能把自己要做的事讲清楚，如何激发大家一起干事情。作为技术 Leader 一定要摒弃这种想法，技术能力和良好的沟通能力两手都要硬。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;86152&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;span data-bgopacity=&quot;40%&quot;/&gt; &lt;span data-bgopacity=&quot;25%&quot;/&gt; &lt;span/&gt;&lt;/section&gt;&lt;section&gt;&lt;section data-brushtype=&quot;text&quot;&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;2、专业的本来就有门槛，为啥要浪费时间和精力去讲给不懂的人听&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;持有这样观点的人也不少，认为专业就应该有一定的神秘感，给人一种不明觉厉的感觉。但实际上真正的专业就是大道至简，用大白话去给别人解释清楚复杂的事情。那种不能够大白话讲清楚的多半自己还是半灌水，还不是真正的专业。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;而要克服这些问题最好的方法就是讲故事打比方这种形象化的思考模型，其实 PPT 就是用图片这种形象化去表达复杂的思考逻辑。至于如何讲好故事我觉得想想西游记就好了：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-role=&quot;list&quot;/&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-role=&quot;list&quot;/&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-role=&quot;list&quot;/&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;技术 Leader 在领导团队建设平台/系统时候，也可以用这样的故事讲法去激励大家。当然要讲好故事不只有这样一个结构，但本质初心是想技术 Leader 能够加入形象化思维，通过比方，通过故事让大家深刻理解你要做的事，这样才能够更好让大家朝着目标协同。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;86122&quot; data-custom=&quot;#138bde&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;七、乘数效应&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;这个思考方法的含义是：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;技术 Leader 在思考一个技术命题时，要充分考虑这件事的影响力，比如有些决定做下去可能是影响 10 个人，有些决定做下去可能是会间接影响 100 人，这种乘数效应必须是技术 Leader 要慎重考虑的，越大的 Leader 越要注意。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;乘数效应可以说是双刃剑，好的乘数效应能够让大团队享受到红利，但差的事件也会让所有人都受到波及。因此有如下实践：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;86152&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;span data-bgopacity=&quot;40%&quot;/&gt; &lt;span data-bgopacity=&quot;25%&quot;/&gt; &lt;span/&gt;&lt;/section&gt;&lt;section&gt;&lt;section data-brushtype=&quot;text&quot;&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;1、&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;自上而下的决策要慎审，充分考虑乘数效应&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;span&gt;作为团队 Leader 尤其是二线 TL，在做一些决策时务必要考虑乘数效应带来的威力（有时候二线 Leader 和一线 Leader 的差异就是在管理这个乘数效应），经常有如下两个误区：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-role=&quot;list&quot;/&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-role=&quot;list&quot;/&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;86152&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;span data-bgopacity=&quot;40%&quot;/&gt; &lt;span data-bgopacity=&quot;25%&quot;/&gt; &lt;span/&gt;&lt;/section&gt;&lt;section&gt;&lt;section data-brushtype=&quot;text&quot;&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;2、主动管理自下而上的乘数效应&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;span&gt;为了组织蓬勃发展，我们肯定是鼓励一线同学充分发挥乘数效应，以让大团队都能够享受到红利。但 Leader 一定要去主动识别和管理这些具有乘数效应的事项，要对可能出现的问题进行及时纠正和干预，典型的纠偏就是防止重复建设防止内卷。但对于确实对全局有利的，要做好及时的推广并主动帮忙解决推进过程中的障碍，让大团队尽可能享受到红利。但无论如何，对于这类具有乘数效应的都必须要有管理清单，鼓励好创新但也慎重做决策。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;86122&quot; data-custom=&quot;#138bde&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;小结&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;span&gt;技术 Leader 是集架构师，管理者，领导者一身的综合性岗位，多年实践下来也只是窥探到了部分。所以以上只沉淀的点滴思考技巧，当然也不可能解决所有的实际问题。期望这些思考对大家做好技术 Leader 有一些帮助。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-style-type=&quot;4&quot; data-tools=&quot;新媒体排版&quot; data-id=&quot;8351&quot;&gt;&lt;p&gt;&lt;span&gt;↓↓ 点击&quot;阅读原文&quot; 【加入云技术社区】&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;相关阅读：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzU0NDEyODkzMQ==&amp;amp;mid=2247528770&amp;amp;idx=2&amp;amp;sn=b43f376bf6a8518f0da7849fa6924e29&amp;amp;chksm=fb02db8ecc7552986e94d0643c4de98efe7df2ad45b96b1ade9d9ff3fdc67dca56b78bdb2fcf&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;“我只想做技术，走技术路线。”&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;“我只想做技术，走技术路线。”&lt;/a&gt;&lt;/span&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzU0NDEyODkzMQ==&amp;amp;mid=2247510818&amp;amp;idx=1&amp;amp;sn=9e4f156d0e4a3ed9e461af4e204a70f7&amp;amp;chksm=fb0201eecc7588f8f4071367fb8ae651a105fd17f3b800934f1a73fc324c088c00a828b69e69&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;一位老工程师在谷歌工作十年后的总结&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot; hasload=&quot;1&quot;&gt;一位老工程师在谷歌工作十年后的总结&lt;/a&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzU0NDEyODkzMQ==&amp;amp;mid=2247528540&amp;amp;idx=2&amp;amp;sn=5bb5a6f87f6d1bbf12dc6619b2d61dc5&amp;amp;chksm=fb02da90cc7553862803f6afd2011f7838c9f996b2ef9831648a7959072eae6649105b087bbd&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;一个成功的码农要经历哪四个阶段？华为技术专家这样说&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot; hasload=&quot;1&quot;&gt;一个成功的码农要经历哪四个阶段？华为技术专家这样说&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzU0NDEyODkzMQ==&amp;amp;mid=2247528354&amp;amp;idx=2&amp;amp;sn=066ef47bb5f922c990fa49996c5b1eee&amp;amp;chksm=fb02c56ecc754c7885c4195e7090b4ee4f4bb4fc1d79bbc2abf0b66f21d83e8eeaf372eedfb1&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;在华为做研发工程师，不仅下矿挖煤，通话居然还靠吼？&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot; hasload=&quot;1&quot;&gt;在华为做研发工程师，不仅下矿挖煤，通话居然还靠吼？&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzU0NDEyODkzMQ==&amp;amp;mid=2247527977&amp;amp;idx=1&amp;amp;sn=d43f9b18899676dfca03f28af32c44a4&amp;amp;chksm=fb02c4e5cc754df33043b0a1c16f015e35637b10ddb460650e3d7955f11d664b89e385deafc9&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;一位博士在华为的22年（干货满满）&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot; hasload=&quot;1&quot;&gt;一位博士在华为的22年（干货满满）&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzU0NDEyODkzMQ==&amp;amp;mid=2247500707&amp;amp;idx=1&amp;amp;sn=f7e5ebdeb79ce29c14d99393e2a65f3c&amp;amp;chksm=fb02696fcc75e079a240f51589fe8d07dac87fc1d4a9ebc154fa1a693e75e54c8fcea52a3088&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; data-linktype=&quot;2&quot; hasload=&quot;1&quot; wah-hotarea=&quot;click&quot;&gt;&lt;span&gt;最新最全 2020 云状态报告「69页PDF下载」&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzU0NDEyODkzMQ==&amp;amp;mid=2247496116&amp;amp;idx=1&amp;amp;sn=211c9acd714ffa181eb824593642b3a0&amp;amp;chksm=fb025b78cc75d26e889a302a0f9a0dc1efdc0bf8bd1dda42226590ef4385a5a836338e7e4996&amp;amp;scene=21#wechat_redirect&quot; target=&quot;_blank&quot; data-itemshowtype=&quot;0&quot; data-linktype=&quot;2&quot; hasload=&quot;1&quot; wah-hotarea=&quot;click&quot;&gt;&lt;span&gt;RightScale 2019年云状况调查报告：35% 的云支出被浪费「附50页PDF下载」&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;&lt;p&gt;更多文章请关注&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-copyright=&quot;0&quot; data-ratio=&quot;1&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/psR51B0KJzwH19fPW3Vk1Rd8ZrDkdpy1WtQCqnEG2w8jlwonr6MzJuFAR2icZDmOXSTzSMpmBeg553xfsjiazrrg/640?wx_fmt=jpeg&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; data-type=&quot;jpeg&quot; data-w=&quot;430&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;文章好看点这里[在看]&lt;strong&gt;👇&lt;/strong&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>683960c8c1846bbb6d4f9362c8ed6159</guid>
<title>彻底搞懂之C++智能指针</title>
<link>https://toutiao.io/k/yw510cs</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div id=&quot;cnblogs_post_body&quot; class=&quot;blogpost-body blogpost-body-html&quot;&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2022.cnblogs.com/blog/420532/202207/420532-20220720095122706-149653483.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p id=&quot;1658296992483&quot;/&gt;
&lt;p id=&quot;1658281911421&quot;/&gt;
&lt;p id=&quot;1658281899056&quot;/&gt;
&lt;p id=&quot;1658281884769&quot;/&gt;
&lt;h2&gt;&lt;span&gt;前言&lt;/span&gt;&lt;/h2&gt;
&lt;p id=&quot;smart-pointers-modern-c&quot;&gt;&lt;span&gt;在现代 c + + 编程中，标准库包含 &lt;/span&gt;&lt;em&gt;智能指针&lt;/em&gt;&lt;span&gt;，这些指针用于帮助确保程序不会出现内存和资源泄漏，并具有异常安全。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; &lt;/p&gt;
&lt;h2&gt;&lt;span&gt;标准库智能指针分类&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;auto_ptr, shared_ptr, weak_ptr, unique_ptr 其中后三个是c++11支持，并且第一个已经被c++11弃用。所以我只说后3个。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;shared_ptr&lt;/strong&gt;&lt;br/&gt;采用引用计数的智能指针。 如果你想要将一个原始指针分配给多个所有者（例如，从容器返回了指针副本又想保留原始指针时），请使用该指针。 直至所有 shared_ptr 所有者超出了范围或放弃所有权，才会删除原始指针。 大小为两个指针；一个用于对象，另一个用于包含引用计数的共享控制块。 头文件：&amp;lt;memory&amp;gt;。 有关详细信息，请参阅 如何：创建和使用 Shared_ptr 实例 和 shared_ptr 类。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;unique_ptr&lt;/strong&gt;&lt;br/&gt;只允许基础指针的一个所有者。 除非你确信需要 shared_ptr，否则请将该指针用作 POCO 的默认选项。 可以移到新所有者，但不会复制或共享。 替换已弃用的 auto_ptr。 与 boost::scoped_ptr 比较。 unique_ptr 很小且高效;大小是一个指针，它支持用于从 c + + 标准库集合快速插入和检索的右值引用。 头文件：&amp;lt;memory&amp;gt;。 有关详细信息，请参阅 如何：创建和使用 Unique_ptr 实例 和 unique_ptr 类。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;weak_ptr&lt;/strong&gt;&lt;br/&gt;结合 shared_ptr 使用的特例智能指针。 weak_ptr 提供对一个或多个 shared_ptr 实例拥有的对象的访问，但不参与引用计数。 如果你想要观察某个对象但不需要其保持活动状态，请使用该实例。 在某些情况下，需要断开 shared_ptr 实例间的循环引用。 头文件：&amp;lt;memory&amp;gt;。 有关详细信息，请参阅 如何：创建和使用 Weak_ptr 实例 和 weak_ptr 类。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt; &lt;/p&gt;
&lt;h2&gt;shared_ptr&lt;/h2&gt;
&lt;p&gt;shared_ptr 类型是 C++ 标准库中的一个智能指针，是为多个所有者可能必须管理对象在内存中的生命周期的方案设计的。 在您初始化一个 shared_ptr 之后，您可复制它，按值将其传入函数参数，然后将其分配给其他 shared_ptr 实例。 所有实例均指向同一个对象，并共享对一个“控制块”（每当新的 shared_ptr 添加、超出范围或重置时增加和减少引用计数）的访问权限。 当引用计数达到零时，控制块将删除内存资源和自身。&lt;/p&gt;
&lt;p&gt;下图显示了指向一个内存位置的几个 &lt;code&gt;shared_ptr&lt;/code&gt; 实例。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://docs.microsoft.com/zh-cn/cpp/cpp/media/shared_ptr.png?view=msvc-170&quot; alt=&quot;Shared pointer diagram.&quot; data-linktype=&quot;relative-path&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 原始用法：&lt;/p&gt;
&lt;pre class=&quot;language-cpp highlighter-hljs&quot;&gt;&lt;code&gt;Object * obj = new ChildObject(9);//从heap分配原始父对象，必须手动触发析构, 但子对象不会释放
testObject(*obj);
printf(&quot;release9 %p \n&quot;, obj);
delete obj;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;当testObject()出现异常时，delete将不被执行，因此将导致内存泄露。&lt;/p&gt;
&lt;p&gt;如何避免这种问题？有人会说，这还不简单，直接在&lt;code&gt;throw exception(); 在catch中&lt;/code&gt;加上&lt;code&gt;delete ps;&lt;/code&gt;不就行了。问题是很多人都会忘记在适当的地方加上delete语句，如果你要对一个庞大的工程进行review，看是否有这种潜在的内存泄露问题，那就是一场灾难！&lt;br/&gt;这时我们会想：&lt;strong&gt;如果指向heap的内存也能像stack变量一样用完时被自动释放，那该有多好啊。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;这正是 auto_ptr、unique_ptr和shared_ptr这几个智能指针背后的设计思想。我简单的总结下就是：&lt;strong&gt;将基本类型指针封装为类对象指针（这个类肯定是个模板，以适应不同基本类型的需求），并在析构函数里编写delete语句删除指针指向的内存空间。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt; &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;使用shared_ptr：&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;language-cpp highlighter-hljs&quot;&gt;&lt;code&gt;{
    std::shared_ptr&amp;lt;Object&amp;gt; sObj = std::make_shared&amp;lt;ChildObject&amp;gt;(1);
    testObject(*sObj); //调用父对象
    //自动回收 
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;很简单对吧~&lt;/p&gt;
&lt;p&gt; &lt;/p&gt;
&lt;h2&gt;&lt;strong&gt;unique_ptr&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;unique_ptr不共享指针。 它不能复制到另一个 unique_ptr函数，由值传递给函数，或在任何需要复制副本的 C++ 标准库算法中使用。 只能移动 unique_ptr。 这意味着，内存资源所有权将转移到另一 unique_ptr，并且原始 unique_ptr 不再拥有此资源。 我们建议你将对象限制为由一个所有者所有，因为多个所有权会使程序逻辑变得复杂。 因此，当需要纯 C++ 对象的智能指针时，请使用make_unique帮助程序函数。&lt;/p&gt;
&lt;p&gt;下图演示了两个 &lt;code&gt;unique_ptr&lt;/code&gt; 实例之间的所有权转换。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://docs.microsoft.com/zh-cn/cpp/cpp/media/unique_ptr.png?view=msvc-170&quot; alt=&quot;Diagram that shows moving the ownership of a unique pointer.&quot; data-linktype=&quot;relative-path&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;unique_ptr&lt;/code&gt; 在 C++ 标准库的标头中 &lt;code&gt;&amp;lt;memory&amp;gt;&lt;/code&gt; 定义。 它与原始指针一样高效，可在 C++ 标准库容器中使用。 将实例添加到 &lt;code&gt;unique_ptr&lt;/code&gt; C++ 标准库容器是有效的，因为移动构造函数 &lt;code&gt;unique_ptr&lt;/code&gt; 无需复制操作。&lt;/p&gt;
&lt;p&gt;unique_ptr 是一个独享所有权的智能指针，它提供了严格意义上的所有权，包括：&lt;/p&gt;
&lt;p&gt;1、拥有它指向的对象&lt;/p&gt;
&lt;p&gt;2、无法进行复制构造，无法进行复制赋值操作。即无法使两个unique_ptr指向同一个对象。但是可以进行移动构造和移动赋值操作&lt;/p&gt;
&lt;p&gt;3、保存指向某个对象的指针，当它本身被删除释放的时候，会使用给定的删除器释放它指向的对象&lt;/p&gt;
&lt;p&gt; &lt;/p&gt;
&lt;p&gt;用法：&lt;/p&gt;
&lt;pre class=&quot;language-cpp highlighter-hljs&quot;&gt;&lt;code&gt;std::unique_ptr&amp;lt;int&amp;gt;p1(new int(5));
std::unique_ptr&amp;lt;int&amp;gt;p2=p1;// 编译会出错
std::unique_ptr&amp;lt;int&amp;gt;p3=std::move(p1);// 转移所有权,那块内存归p3所有, p1成为无效的针.
p3.reset();//释放内存.
p1.reset();//无效&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt; &lt;/p&gt;
&lt;p&gt;share_ptr和unique_ptr的例子：&lt;/p&gt;
&lt;pre class=&quot;language-cpp highlighter-hljs&quot;&gt;&lt;code&gt;#include &amp;lt;iostream&amp;gt;
#include &amp;lt;string&amp;gt;
using namespace std;

namespace Test
{
    #define formatBool(b) ((b) ? &quot;true&quot; : &quot;false&quot;)
    class Object
    {
    protected:
        int id;

    public:
        using pointer = std::shared_ptr&amp;lt;Object&amp;gt;;
        virtual std::string version() const {
            return &quot;1.0.0&quot;;
        }; 
        Object(int _id):id(_id){
            cout &amp;lt;&amp;lt; &quot;\nnew parent Object id:&quot; &amp;lt;&amp;lt; id  &amp;lt;&amp;lt; endl;
        };
        virtual ~Object(){//释放时，首先是派生，然后是基类。必须将基类析构函数设为虚基类， 防止delete 子对象时不会调用父析构函数，导致内存泄露
            delete parent_str_ptr;
            cout &amp;lt;&amp;lt; &quot;delete parent Object id:&quot; &amp;lt;&amp;lt; id  &amp;lt;&amp;lt; endl;
        };
        virtual std::string debug() const
        {
            auto str = std::string( &quot;debug Object id:&quot; + std::to_string(id) );
            return str;
        }

    private:
        std::string *parent_str_ptr = new std::string(&quot;parent_str_ptr memory leak&quot;);                                          
    };
    class ChildObject : public Object
    {
    public:
        ChildObject(int _id):Object(_id)
        {
            std::cout &amp;lt;&amp;lt; &quot;new ChildObject id:&quot; &amp;lt;&amp;lt; (id) &amp;lt;&amp;lt; &quot;\n&quot;;
        }

        ~ChildObject()
        {
            delete str_ptr;
            std::cout &amp;lt;&amp;lt; &quot;delete ChildObject id:&quot; &amp;lt;&amp;lt; id &amp;lt;&amp;lt; &quot;\n&quot;;
        }
        virtual std::string version() const {
            return &quot;2.0.0&quot;;
        }; 
    private:
        std::string *str_ptr = new std::string(&quot;memory leak&quot;);  

    };

    void testObject(const Object &amp;amp;obj)
    {
        std::cout &amp;lt;&amp;lt; obj.debug() &amp;lt;&amp;lt; &quot; version:&quot;&amp;lt;&amp;lt; obj.version() &amp;lt;&amp;lt; &quot;\n&quot;;
    }

    void testCase()
    {
        {
            std::shared_ptr&amp;lt;Object&amp;gt; sObj = std::make_shared&amp;lt;ChildObject&amp;gt;(1);
            testObject(*sObj); //调用父对象
            //自动回收 
        }

        {
            std::unique_ptr&amp;lt;Object&amp;gt; obj = std::make_unique&amp;lt;ChildObject&amp;gt;(2);
            testObject(*obj);
            auto obj2 = std::move(obj);//转移所有权到obj2

            printf(&quot;obj:%s obj2:%s \n&quot;, formatBool(!!obj), formatBool(!!obj2));

            testObject(*obj2);//调用父对象

            obj2.release();//手动释放后， obj, obj2指向的对象已经被回收， 不会触发自动回收
            printf(&quot;obj2.release， obj:%s obj2:%s \n&quot;, formatBool(!!obj), formatBool(!!obj2));
        }

        {
            std::unique_ptr&amp;lt;ChildObject&amp;gt; obj = std::make_unique&amp;lt;ChildObject&amp;gt;(3);// 使用make_unique
            testObject(*obj);
            printf(&quot;release3 %s \n&quot;, formatBool(!!obj));
        }
        {
            std::unique_ptr&amp;lt;ChildObject&amp;gt; obj(new ChildObject(4));//使用new
            testObject(*obj);
            printf(&quot;release4 %s \n&quot;, formatBool(!!obj));
        }
        {
            // std::unique_ptr&amp;lt;ChildObject&amp;gt; obj(ChildObject(5));//使用stack对象，这是错误的用法， error: no matching constructor for initialization of &#x27;std::unique_ptr&amp;lt;Object&amp;gt;&#x27;
            // printf(&quot;release5 %d \n&quot;, !!obj);
        }
        {
            std::unique_ptr&amp;lt;Object&amp;gt; obj = std::make_unique&amp;lt;ChildObject&amp;gt;(6);//用父对象, 会触发析构
            testObject(*obj);
            printf(&quot;release6 %s \n&quot;, formatBool(!!obj));
        }
        {
            ChildObject obj = ChildObject(7);//从stack分配原始对象， 会触发析构
            testObject(obj);
            printf(&quot;release7 %p \n&quot;, &amp;amp;obj);
        }
        {
            ChildObject * obj = new ChildObject(8);//从heap分配原始对象， 必须手动触发析构
            testObject(*obj);
            printf(&quot;release8 %p \n&quot;, obj);
            delete obj;
        }
        {
            Object * obj = new ChildObject(9);//从heap分配原始父对象，必须手动触发析构
            testObject(*obj);
            printf(&quot;release9 %p \n&quot;, obj);
            delete obj;
        }
        {
            Object * obj = new Object(10);//从heap分配原始父对象，必须手动触发析构
            testObject(*obj);
            printf(&quot;release10 %p \n&quot;, obj);
            delete obj;
        }
        {
            std::shared_ptr&amp;lt;Object&amp;gt; obj = std::make_unique&amp;lt;ChildObject&amp;gt;(11);//指向父对象, 会释放子对象
            testObject(*obj);
            printf(&quot;release11 %s \n&quot;, formatBool(!!obj));
        }
        // {
        //     std::unique_ptr&amp;lt;Object&amp;gt; obj = std::make_shared&amp;lt;ChildObject&amp;gt;(11);//error: no viable conversion from &#x27;shared_ptr&amp;lt;Test::ChildObject&amp;gt;&#x27; to &#x27;std::unique_ptr&amp;lt;Object&amp;gt;&#x27;
        //     testObject(*obj);
        //     printf(&quot;release11 %s \n&quot;, formatBool(!!obj));
        // }
    }
}

int main(int argc, char **argv)
{
    Test::testCase();

    return EXIT_SUCCESS;
}&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&quot;language-cpp highlighter-hljs&quot;&gt;&lt;code&gt;#  c++ -std=c++14 -o a share_ptr.cpp; ./a
new parent Object id:1
new ChildObject id:1
debug Object id:1 version:2.0.0
delete ChildObject id:1
delete parent Object id:1

new parent Object id:2
new ChildObject id:2
debug Object id:2 version:2.0.0
obj:false obj2:true 
debug Object id:2 version:2.0.0
obj2.release， obj:false obj2:false 

new parent Object id:3
new ChildObject id:3
debug Object id:3 version:2.0.0
release3 true 
delete ChildObject id:3
delete parent Object id:3

new parent Object id:4
new ChildObject id:4
debug Object id:4 version:2.0.0
release4 true 
delete ChildObject id:4
delete parent Object id:4

new parent Object id:6
new ChildObject id:6
debug Object id:6 version:2.0.0
release6 true 
delete ChildObject id:6
delete parent Object id:6

new parent Object id:7
new ChildObject id:7
debug Object id:7 version:2.0.0
release7 0x7ff7bfcf3488 
delete ChildObject id:7
delete parent Object id:7

new parent Object id:8
new ChildObject id:8
debug Object id:8 version:2.0.0
release8 0x7fcaef705ba0 
delete ChildObject id:8
delete parent Object id:8

new parent Object id:9
new ChildObject id:9
debug Object id:9 version:2.0.0
release9 0x7fcaef705ba0 
delete ChildObject id:9
delete parent Object id:9

new parent Object id:10
debug Object id:10 version:1.0.0
release10 0x7fcaef705ba0 
delete parent Object id:10

new parent Object id:11
new ChildObject id:11
debug Object id:11 version:2.0.0
release11 true 
delete ChildObject id:11
delete parent Object id:11&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;&lt;strong&gt;weak_ptr&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;weak_ptr是用来&lt;strong&gt;解决shared_ptr相互引用时的死锁问题,&lt;/strong&gt;如果说两个shared_ptr相互引用,那么这两个指针的引用计数永远不可能下降为0,资源永远不会释放。它是对对象的一种弱引用，不会增加对象的引用计数，和shared_ptr之间可以相互转化，shared_ptr可以直接赋值给它，它可以通过调用lock函数来获得shared_ptr。&lt;/p&gt;
&lt;p&gt;最佳设计是避免在任何时候都能实现指针的共享所有权。 但是，如果您必须有实例的 &lt;code&gt;shared_ptr&lt;/code&gt; 共享所有权，请避免它们之间存在循环引用。 如果无法避免循环引用，或者出于某种原因更可取，则使用 &lt;a href=&quot;https://docs.microsoft.com/zh-cn/cpp/standard-library/weak-ptr-class?view=msvc-170&quot; data-linktype=&quot;relative-path&quot; rel=&quot;noopener&quot;&gt;weak_ptr&lt;/a&gt; 向一个或多个所有者提供对另 &lt;code&gt;shared_ptr&lt;/code&gt; 一个的弱引用。 通过使用 &lt;code&gt;weak_ptr&lt;/code&gt; ，可以创建一个 &lt;code&gt;shared_ptr&lt;/code&gt; 联接到一组现有相关实例的，但前提是基础内存资源仍有效。 &lt;code&gt;weak_ptr&lt;/code&gt;本身并不参与引用计数，因此它无法阻止引用计数转到零。 但是，你可以使用 &lt;code&gt;weak_ptr&lt;/code&gt; 来尝试获取用于初始化的的新副本 &lt;code&gt;shared_ptr&lt;/code&gt; 。 如果已删除内存，则的 bool 运算符将 &lt;code&gt;weak_ptr&lt;/code&gt; 返回 &lt;strong&gt;&lt;code&gt;false&lt;/code&gt;&lt;/strong&gt; 。 如果内存仍有效，新的共享指针会递增引用计数，并保证只要 &lt;code&gt;shared_ptr&lt;/code&gt; 变量保持在范围内，内存就有效。weak_ptr是弱智能指针对象，它不控制所指向对象生存期的智能指针，它指向由一个shared_ptr管理的智能指针。将一个weak_ptr绑定到一个shared_ptr对象，不会改变shared_ptr的引用计数。一旦最后一个所指向对象的shared_ptr被销毁，所指向的对象就会被释放，即使此时有weak_ptr指向该对象，所指向的对象依然被释放。&lt;br/&gt;&lt;/p&gt;
&lt;p&gt;例子：&lt;/p&gt;
&lt;pre class=&quot;language-cpp highlighter-hljs&quot;&gt;&lt;code&gt;#include &amp;lt;iostream&amp;gt;
#include &amp;lt;memory&amp;gt;

class A;

class B
{
public:
    ~B()
    {
        std::cout &amp;lt;&amp;lt; &quot;B destory, a_ptr use_count:&quot; &amp;lt;&amp;lt; a_ptr.use_count() &amp;lt;&amp;lt; &quot;\n&quot;;
    }

    //    std::shared_ptr&amp;lt;A&amp;gt; a_ptr; //它会造成循环引用
    std::weak_ptr&amp;lt;A&amp;gt; a_ptr;//它不会循环引用
};

class A
{
public:
    ~A()
    {
        std::cout &amp;lt;&amp;lt; &quot;A destory, b_ptr use_count:&quot; &amp;lt;&amp;lt; b_ptr.use_count() &amp;lt;&amp;lt; &quot;\n&quot;;
    }

    // std::shared_ptr&amp;lt;B&amp;gt; b_ptr;//它会造成循环引用
    std::weak_ptr&amp;lt;B&amp;gt; b_ptr;//它不会循环引用
};

int main()
{
    std::shared_ptr&amp;lt;A&amp;gt; a(new A());
    std::shared_ptr&amp;lt;B&amp;gt; b(new B());
    a-&amp;gt;b_ptr = b;
    b-&amp;gt;a_ptr = a;

    std::cout &amp;lt;&amp;lt; &quot;A:&quot; &amp;lt;&amp;lt; a.use_count() &amp;lt;&amp;lt; &quot;\n&quot;;
    std::cout &amp;lt;&amp;lt; &quot;B:&quot; &amp;lt;&amp;lt; b.use_count() &amp;lt;&amp;lt; &quot;\n&quot;;
}
// * 运行结果：
// A:2
// B:2&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt; &lt;/p&gt;
&lt;h2&gt;如何选择智能指针&lt;/h2&gt;
&lt;p&gt;（1）如果程序要使用多个指向同一个对象的指针，应选择shared_ptr。这样的情况包括：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;有一个指针数组，并使用一些辅助指针来标示特定的元素，如最大的元素和最小的元素；&lt;/li&gt;
&lt;li&gt;两个对象包含都指向第三个对象的指针；&lt;/li&gt;
&lt;li&gt;STL容器包含指针。很多STL算法都支持复制和赋值操作，这些操作可用于shared_ptr，但不能用于unique_ptr（编译器发出warning）和auto_ptr（行为不确定）。如果你的编译器没有提供shared_ptr，可使用Boost库提供的shared_ptr。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;（2）如果程序不需要多个指向同一个对象的指针，则可使用unique_ptr。如果函数使用new分配内存，并返还指向该内存的指针，将其返回类型声明为unique_ptr是不错的选择。这样，所有权转让给接受返回值的unique_ptr，而该智能指针将负责调用delete。可将unique_ptr存储到STL容器在那个，只要不调用将一个unique_ptr复制或赋给另一个算法（如sort()）。例如，可在程序中使用类似于下面的代码段。&lt;/p&gt;
&lt;h4&gt;  (3) 基于性能考虑：&lt;/h4&gt;
&lt;p data-pid=&quot;KBzKGqcF&quot;&gt;1、unique_ptr独占对象的所有权，由于没有引用计数，因此性能较好&lt;/p&gt;
&lt;p data-pid=&quot;ThoTZDbv&quot;&gt;2、shared_ptr共享对象的所有权，但性能略差&lt;/p&gt;
&lt;p data-pid=&quot;2XVph8ZH&quot;&gt;3、weak_ptr配合shared_ptr，解决循环引用的问题&lt;/p&gt;
&lt;p data-pid=&quot;_KQ0j_TC&quot;&gt;       由于性能问题，那么可以粗暴的理解：优先使用unique_ptr。但由于unique_ptr不能进行复制，因此部分场景下不能使用的。&lt;/p&gt;
&lt;p data-pid=&quot;_KQ0j_TC&quot;&gt; &lt;/p&gt;
&lt;h2&gt;智能指针的错误用法&lt;/h2&gt;
&lt;p data-pid=&quot;Tb2cu2q5&quot;&gt;1、使用智能指针托管的对象，尽量不要在再使用原生指针&lt;/p&gt;
&lt;p data-pid=&quot;tl1Iy6bw&quot;&gt;很多开发同学（包括我在内）在最开始使用智能指针的时候，对同一个对象会混用智能指针和原生指针，导致程序异常。&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;
&lt;pre class=&quot;language-cpp highlighter-hljs&quot;&gt;&lt;code&gt;void incorrect_smart_pointer1()
{
    A *a= new A();
    std::unique_ptr&amp;lt;A&amp;gt; unique_ptr_a(a);

    // 此处将导致对象的二次释放
    delete a;
}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p data-pid=&quot;zBa3ey9V&quot;&gt;2、不要把一个原生指针交给多个智能指针管理&lt;/p&gt;
&lt;p data-pid=&quot;VN4A8u8R&quot;&gt;如果将一个原生指针交个多个智能指针，这些智能指针释放对象时会产生对象的多次销毁&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;
&lt;pre class=&quot;language-cpp highlighter-hljs&quot;&gt;&lt;code&gt;void incorrect_smart_pointer2()
{
    A *a= new A();
    std::unique_ptr&amp;lt;A&amp;gt; unique_ptr_a1(a);
    std::unique_ptr&amp;lt;A&amp;gt; unique_ptr_a2(a);// 此处将导致对象的二次释放
}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p data-pid=&quot;QsomhVjP&quot;&gt;3、尽量不要使用 get()获取原生指针&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;
&lt;pre class=&quot;language-cpp highlighter-hljs&quot;&gt;&lt;code&gt;void incorrect_smart_pointer3()
{
    std::shared_ptr&amp;lt;A&amp;gt; shared_ptr_a1 = std::make_shared&amp;lt;A&amp;gt;();

    A *a= shared_ptr_a1.get();

    std::shared_ptr&amp;lt;A&amp;gt; shared_ptr_a2(a);// 此处将导致对象的二次释放

    delete a;// 此处也将导致对象的二次释放
}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p data-pid=&quot;Femj9eFt&quot;&gt;4、不要将 this 指针直接托管智能指针&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;
&lt;pre class=&quot;language-cpp highlighter-hljs&quot;&gt;&lt;code&gt;class E
{
    void use_this()
    {
        //错误方式，用this指针重新构造shared_ptr，将导致二次释放当前对象
        std::shared_ptr&amp;lt;E&amp;gt; this_shared_ptr1(this);
    }
};

std::shared_ptr&amp;lt;E&amp;gt; e = std::make_shared&amp;lt;E&amp;gt;();&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p data-pid=&quot;7kECTiJF&quot;&gt;5、智能指针只能管理堆对象，不能管理栈上对象&lt;/p&gt;
&lt;p data-pid=&quot;JETEOtA3&quot;&gt;栈上对象本身在出栈时就会被自动销毁，如果将其指针交给智能指针，会造成对象的二次销毁&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;
&lt;pre class=&quot;language-cpp highlighter-hljs&quot;&gt;&lt;code&gt;void incorrect_smart_pointer5()
{
    int int_num = 3;
    std::unique_ptr&amp;lt;int&amp;gt; int_unique_ptr(&amp;amp;int_num);
}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;h2&gt;如何优化&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;内存占用高&lt;/strong&gt;&lt;br/&gt;shared_ptr 的内存占用是裸指针的两倍。因为除了要管理一个裸指针外，还要维护一个引用计数。&lt;br/&gt;因此相比于 unique_ptr, shared_ptr 的内存占用更高&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;原子操作性能低&lt;/strong&gt;&lt;br/&gt;考虑到线程安全问题，引用计数的增减必须是原子操作。而原子操作一般情况下都比非原子操作慢。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;使用移动优化性能&lt;/strong&gt;&lt;br/&gt;shared_ptr 在性能上固然是低于 unique_ptr。而通常情况，我们也可以尽量避免 shared_ptr 复制。&lt;br/&gt;如果，一个 shared_ptr 需要将所有权共享给另外一个新的 shared_ptr，而我们确定在之后的代码中都不再使用这个 shared_ptr，那么这是一个非常鲜明的移动语义。&lt;br/&gt;对于此种场景，我们尽量使用 std::move，将 shared_ptr 转移给新的对象。因为移动不用增加引用计数，性能比复制更好。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2&gt;汇总 &lt;/h2&gt;
&lt;p&gt;智能指针能更安全的回收内存，它能防止：&lt;/p&gt;
&lt;p&gt;  1. 忘记delete造成的内存泄露&lt;/p&gt;
&lt;p&gt;  2. delete了，又被访问到了，比如并发时，导致“野指针”的危险情况&lt;/p&gt;
&lt;p&gt;  3. delete了，又被delete了，导致重复回收，导致报错中断程序&lt;/p&gt;
&lt;p&gt; &lt;/p&gt;
&lt;p&gt;总的来说，一般推荐用智能指针，性能要求很高性，可以用裸指针，但要十分小心。&lt;/p&gt;
&lt;p&gt; &lt;/p&gt;
&lt;h2&gt;参考&lt;/h2&gt;
&lt;p&gt;https://docs.microsoft.com/zh-cn/cpp/cpp/smart-pointers-modern-cpp?view=msvc-170&lt;/p&gt;
&lt;p&gt;https://www.zhihu.com/question/319277442/answer/2384378560&lt;/p&gt;
&lt;p&gt;https://www.cyhone.com/articles/right-way-to-use-cpp-smart-pointer/&lt;/p&gt;
&lt;p&gt;https://juejin.cn/post/6844904198962675719&lt;/p&gt;
&lt;p&gt; &lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>