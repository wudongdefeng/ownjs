<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>9dd94c2f5d73b74473f75d8c6db3d671</guid>
<title>2023 年该学点什么技术？「GitHub 热点速览 v.23.03」</title>
<link>https://toutiao.io/k/2hoku7p</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6220462543991956&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/xBgIbW1vdNOcnjuQcE6EiaTrZ88JJL6EB8enjr9LGXGe12YbsD2n93Gvz0ANXkU1e2XTkszFMzzOiaaeV0ejTJLA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;7956&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;作者：HelloGitHub-小鱼干&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;春节期间，小鱼干读了一篇万字回顾数据库行业的文章，在文字缝隙里我看见了两个词：AI+ 和数据两个词（当然数据是废话，毕竟是一个数据库的回顾文）。在 GitHub 上热点趋势上，可见到 AI+ 的身影，几乎百分之九十迅速蹿红的项目都同 AI 相关。所以在兔年的开头，本期收录一些入门 AI 的项目，希望兔年的你和那些 AI 项目一样突飞猛进。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;以下内容摘录自微博&lt;/span&gt;&lt;span&gt;@HelloGitHub&lt;/span&gt;&lt;span&gt; 的 GitHub Trending 及 Hacker News 热帖（简称 HN 热帖），选项标准：&lt;/span&gt;&lt;code&gt;&lt;span&gt;新发布&lt;/span&gt;&lt;/code&gt;&lt;span&gt; | &lt;/span&gt;&lt;code&gt;&lt;span&gt;实用&lt;/span&gt;&lt;/code&gt;&lt;span&gt; | &lt;/span&gt;&lt;code&gt;&lt;span&gt;有趣&lt;/span&gt;&lt;/code&gt;&lt;span&gt;，根据项目 release 时间分类，发布时间不超过 14 day 的项目会标注 &lt;/span&gt;&lt;code&gt;&lt;span&gt;New&lt;/span&gt;&lt;/code&gt;&lt;span&gt;，无该标志则说明项目 release 超过半月。由于本文篇幅有限，还有部分项目未能在本文展示，望周知 🌝&lt;/span&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5082547169811321&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/xBgIbW1vdNOcnjuQcE6EiaTrZ88JJL6EBsh29cEFFibFic6jicGicd0mDYRZmHfLlTR32nnqxsuXic5dVaIz4OkFicKYQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1696&quot;/&gt;&lt;/figure&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;1. 本周特推&lt;/span&gt;&lt;/h2&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;1.1 数据工程：data-engineering-zoomcamp&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;主语言：Jupyter Notebook、Python、Java&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;一个免费的数据工程教程，带你入门大数据。教程一共分为 9 周，前面三周了解基础知识、讲 Workflow Orchestration、数据湖，从第四周开始分析处理数据，教批处理和流处理等常见处理方式，最后 3 周为实操的 Project 部分。&lt;/span&gt;&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;GitHub 地址→https://github.com/DataTalksClub/data-engineering-zoomcamp&lt;/p&gt;&lt;/blockquote&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1.091451292246521&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/xBgIbW1vdNOcnjuQcE6EiaTrZ88JJL6EBvLPwF9ZY5FYGG1qL0QKRRTqD7EmK8YicWgc2G19GnW0YP5d5MWp7ALw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1006&quot;/&gt;&lt;/figure&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;1.2 微软 AI 教程：AI-For-Beginners&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;主语言：Jupyter Notebook&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;微软出品的 AI 新手教程，同它的其他 For Beginner 教程一样，它对新手十分友好，将复杂的 AI 知识进行分解，在 24 节课程中一一教授给你。除了课程之外，Microsoft Learn 还提供了一个方便启用的 GPU 环境让你更好地深入了解该课程。&lt;/span&gt;&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;GitHub 地址→https://github.com/microsoft/AI-For-Beginners&lt;/p&gt;&lt;/blockquote&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.7049576783555018&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/xBgIbW1vdNOcnjuQcE6EiaTrZ88JJL6EBt63y7jGxUqfibTCwN3CO1su5ZkHvfoThkwBHssicKaiclMtZTHWottrcQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2481&quot;/&gt;&lt;/figure&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;2. GitHub Trending 周榜&lt;/span&gt;&lt;/h2&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;2.1 AI 想象：imaginAIry&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;本周 star 增长数：3,500+&lt;strong&gt;，&lt;/strong&gt;主语言：Python&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;想知道 AI 的想象力到底如何么？ImaginAIry 便是一个根据你的描述生成对应图片的项目。也许你可以试试用它来生成你兔年兔飞猛进的那个时刻 :D 项目暂时可以在 macOS（M1）和 Linux 下运行，并未能在 Windows 下运行。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;下面的示例代码能生成相关的示例图（下图）&lt;/span&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;# on macOS, make sure rust is installed first&lt;/span&gt;&lt;br/&gt;&amp;gt;&amp;gt; pip install imaginairy&lt;br/&gt;&amp;gt;&amp;gt; imagine &lt;span&gt;&quot;a scenic landscape&quot;&lt;/span&gt; &lt;span&gt;&quot;a photo of a dog&quot;&lt;/span&gt; &lt;span&gt;&quot;photo of a fruit bowl&quot;&lt;/span&gt; &lt;span&gt;&quot;portrait photo of a freckled woman&quot;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;# Stable Diffusion 2.1&lt;/span&gt;&lt;br/&gt;&amp;gt;&amp;gt; imagine --model SD&lt;span&gt;-2.1&lt;/span&gt; &lt;span&gt;&quot;a forest&quot;&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;GitHub 地址→https://github.com/brycedrennan/imaginAIry&lt;/p&gt;&lt;/blockquote&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5067796610169492&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/xBgIbW1vdNOcnjuQcE6EiaTrZ88JJL6EBTYaCqZrb42wNoENeiaJwtLgAuz4EPVxScORhwfic5bicTrbicAky9Ngr3g/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;590&quot;/&gt;&lt;/figure&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;2.2 为懒人而生：LazyVim&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;本周 star 增长数：1,600+&lt;strong&gt;，&lt;/strong&gt;主语言：Lua&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;想用 Neovim 又懒得配置？LazyVim for lazy，它可轻松自定义、扩展你的配置。它可灵活调整配置，也有预先配置的便利，免你从头开始搞配置。特性：&lt;/span&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;将你的 Neovim 转为功能齐全的 IDE；&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;使用 &lt;/span&gt;&lt;span&gt;lazy.vim&lt;/span&gt;&lt;span&gt; 轻松定制配置；&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;快速；&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;选项、autocmd、 keymap 都有恰到好处的默认设置；&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;丰富的插件；&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;GitHub 地址→https://github.com/LazyVim/LazyVim&lt;/p&gt;&lt;/blockquote&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6919642857142857&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/xBgIbW1vdNOcnjuQcE6EiaTrZ88JJL6EB7ic1GQnMtlXnc3UtdLfusQCuf7gCQziahLWO3f8foaI0UdjEOfHtByFw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;896&quot;/&gt;&lt;/figure&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;2.3 深度学习的模型优化：tuning_playbook&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;本周 star 增长数：10,800+&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;New&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 想提升深度学习模型的性能么？Google 研究所开源了他们的模型优化方式，项目侧重点是高参数调整的过程，以此得到更好的模型性能。顺便提一嘴，这个刚开源没有一星期的项目，已经破 10k star 可见它的受欢迎程度。&lt;/span&gt;&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;GitHub 地址→https://github.com/google-research/tuning_playbook&lt;/p&gt;&lt;/blockquote&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;2.4 GitHub 档案：octosuite&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;本周 star 增长数：500+&lt;strong&gt;，&lt;/strong&gt;主语言：Python&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;一个收集 GitHub 用户、仓库、组织的开源情报的框架，简单来说你可以看到一个 ID（用户、仓库、组织）相关的信息，比如：粉丝、所在地、组织多少个仓库。&lt;/span&gt;&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;GitHub 地址→https://github.com/bellingcat/octosuite&lt;/p&gt;&lt;/blockquote&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5619791666666667&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/xBgIbW1vdNOcnjuQcE6EiaTrZ88JJL6EBfXpNzHxJQLIj0UXFTOXW3o6cmMsibpmjnCEK4OMNibT7NA4rUxu0Ficiaw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1920&quot;/&gt;&lt;/figure&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;2.5 可视化 git：git-sim&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;本周 star 增长数：1,550+&lt;strong&gt;，&lt;/strong&gt;主语言：Python&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;用命令在你终端模拟你的 git 操作，下图为 &lt;/span&gt;&lt;code&gt;&lt;span&gt;git-sim merge &amp;lt;branch&amp;gt;&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 的展示结果。&lt;/span&gt;&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;GitHub 地址→https://github.com/initialcommit-com/git-sim&lt;/p&gt;&lt;/blockquote&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5625&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/xBgIbW1vdNOcnjuQcE6EiaTrZ88JJL6EBrbCd9mrJ9Wn2Pz75zxmv4a5OxFNFuMMVw75kwiaqibfwyVyVhn8S8RjA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1920&quot;/&gt;&lt;/figure&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;3. 往期回顾&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;往期回顾：&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;以上为 2023 年第 3 个工作周的 GitHub Trending 🎉如果你 Pick 其他好玩、实用的 GitHub 项目，记得来 &lt;/span&gt;&lt;span&gt;HelloGitHub&lt;/span&gt;&lt;span&gt; issue 区和我们分享下哟 🌝&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;最后，记得你在本文留言区留下你想看的主题 Repo（限公众号），例如：AI 换头。👀 和之前的送书活动类似，留言点赞 Top3 的小伙伴(&lt;span&gt;棒&lt;/span&gt;），小鱼干会努力去找 Repo 的^^&lt;/span&gt;&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;HelloGitHub 交流群现已全面开放，添加微信号：HelloGitHub001 为好友入群，可同前端、Java、Go 等各界大佬谈笑风生、切磋技术~&lt;/p&gt;&lt;/blockquote&gt;&lt;span&gt;- END -&lt;/span&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>19a01f81a278e1a5aef0efc341c28949</guid>
<title>Python 的垃圾回收机制</title>
<link>https://toutiao.io/k/mkz3pjd</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content js_underline_content             autoTypeSetting24psection&amp;#10;            &quot; id=&quot;js_content&quot;&gt;&lt;blockquote class=&quot;js_blockquote_wrap&quot; data-type=&quot;2&quot; data-url=&quot;&quot; data-author-name=&quot;&quot; data-content-utf8-length=&quot;151&quot; data-source-title=&quot;&quot; data-text=&quot;几乎所有的高级编程语言都有自己的垃圾回收机制，开发者不需要关注内存的申请与释放，Python 也不例外。Python 官方团队的文章 https://devguide.python.org/internals/garbage-collector 详细介绍了 Python 中的垃圾回收算法，本文是这篇文章的译文。&quot; data-editid=&quot;6r1avmr7hpo0000000&quot;&gt;&lt;section class=&quot;js_blockquote_digest&quot;&gt;&lt;p&gt;几乎所有的高级编程语言都有自己的垃圾回收机制，开发者不需要关注内存的申请与释放，Python 也不例外。Python 官方团队的文章 https://devguide.python.org/internals/garbage-collector 详细介绍了 Python 中的垃圾回收算法，本文是这篇文章的译文。&lt;span/&gt;&lt;/p&gt;&lt;/section&gt;&lt;/blockquote&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;摘要&lt;/span&gt;&lt;/strong&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;CPython 中主要的垃圾回收算法是引用计数。引用计数顾名思义就是统计每个对象有多少个引用，每个引用可能来自另外一个对象，或者一个全局（或静态）C 变量，或者 C 语言函数中的局部变量。当一个变量的引用计数变成 0，那么这个对象就会被释放。如果被释放的对象包含对其他对象的引用，那么其他对象的引用计数就会相应地减 1。如果其他对象的引用计数在减 1 之后变成 0，这些对象也会级联地被释放掉。在 Python 代码中可以通过 &lt;span data-token-index=&quot;1&quot; spellcheck=&quot;false&quot;&gt;sys.getrefcount&lt;/span&gt; 函数获取一个对象的引用计数（函数的返回值会比实际的引用计数多 1，因为函数本身也包含一个对目标对象的引用）。&lt;/span&gt;&lt;/section&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span&gt;x&lt;/span&gt; &lt;span&gt;=&lt;/span&gt; &lt;span&gt;object&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span&gt;sys&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;getrefcount&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;x&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;br/&gt;&lt;span&gt;2&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span&gt;y&lt;/span&gt; &lt;span&gt;=&lt;/span&gt; &lt;span&gt;x&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span&gt;sys&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;getrefcount&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;x&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;br/&gt;&lt;span&gt;3&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span&gt;del&lt;/span&gt; &lt;span&gt;y&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span&gt;sys&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;getrefcount&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;x&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;br/&gt;&lt;span&gt;2&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;span&gt;引用计数最大的问题就是不能处理循环引用。&lt;/span&gt;&lt;span&gt;下面是一个循环引用的例子：&lt;/span&gt;&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span&gt;container&lt;/span&gt; &lt;span&gt;=&lt;/span&gt; &lt;span&gt;[]&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span&gt;container&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;append&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;container&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span&gt;sys&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;getrefcount&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;container&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;br/&gt;&lt;span&gt;3&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span&gt;del&lt;/span&gt; &lt;span&gt;container&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;section&gt;&lt;span&gt;在这个例子中，&lt;/span&gt;&lt;span data-token-index=&quot;1&quot; spellcheck=&quot;false&quot;&gt;container&lt;/span&gt;&lt;span&gt; 对象包含一个对自己的引用，所以即使我们移除了一个引用（变量 &lt;/span&gt;&lt;span data-token-index=&quot;3&quot; spellcheck=&quot;false&quot;&gt;container&lt;/span&gt;&lt;span&gt;）&lt;/span&gt;&lt;span data-token-index=&quot;5&quot; spellcheck=&quot;false&quot;&gt;container&lt;/span&gt;&lt;span&gt; 对象的引用计数也不会变成 0，因为 &lt;/span&gt;&lt;span data-token-index=&quot;7&quot; spellcheck=&quot;false&quot;&gt;container&lt;/span&gt;&lt;span&gt; 对象内部仍然有一个对自身的引用。&lt;/span&gt;&lt;span&gt;因此如果仅仅通过简单的引用计数，&lt;/span&gt;&lt;span data-token-index=&quot;9&quot; spellcheck=&quot;false&quot;&gt;container&lt;/span&gt;&lt;span&gt; 对象永远不会被释放。&lt;/span&gt;&lt;span&gt;鉴于此，当对象不可达的时候（译注：&lt;/span&gt;&lt;span&gt;当代码中没有对实际对象的引用时），我们需要额外的机制来清除这些不可达对象间的循环引用。&lt;/span&gt;&lt;span&gt;这个额外的机制就是循环垃圾收集器，通常简称为垃圾收集器（Garbage Collector，GC），虽然引用计数也是一种垃圾回收算法。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;内存布局和对象结构&lt;/span&gt;&lt;/strong&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;一般的 Python 对象在 C 语言中的结构体表示如下&lt;/span&gt;&lt;/section&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;ruby&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;object -----&amp;gt; +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+ \&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;              &lt;span class=&quot;code-snippet__params&quot;&gt;|                    ob_refcnt                  |&lt;/span&gt; &lt;span class=&quot;code-snippet__params&quot;&gt;|&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;              +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+ |&lt;/span&gt; PyObject_HEAD&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;              &lt;span class=&quot;code-snippet__params&quot;&gt;|                    *ob_type                   |&lt;/span&gt; &lt;span class=&quot;code-snippet__params&quot;&gt;|&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;              +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+ /&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;              &lt;span class=&quot;code-snippet__params&quot;&gt;|                      ...                      |&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;section&gt;&lt;span/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;为了支持垃圾回收，在一般 Python 对象的内存布局前面加了一些额外的信息&lt;/span&gt;&lt;/section&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;ruby&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;              +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+ \&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;              &lt;span class=&quot;code-snippet__params&quot;&gt;|                    *_gc_next                  |&lt;/span&gt; &lt;span class=&quot;code-snippet__params&quot;&gt;|&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;              +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+ |&lt;/span&gt; PyGC_Head&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;              &lt;span class=&quot;code-snippet__params&quot;&gt;|                    *_gc_prev                  |&lt;/span&gt; &lt;span class=&quot;code-snippet__params&quot;&gt;|&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;object -----&amp;gt; +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+ /&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;              |&lt;/span&gt;                    ob_refcnt                  &lt;span class=&quot;code-snippet__params&quot;&gt;| \&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;              +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+ |&lt;/span&gt; PyObject_HEAD&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;              &lt;span class=&quot;code-snippet__params&quot;&gt;|                    *ob_type                   |&lt;/span&gt; &lt;span class=&quot;code-snippet__params&quot;&gt;|&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;              +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+ /&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;              &lt;span class=&quot;code-snippet__params&quot;&gt;|                      ...                      |&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;通过这种方式，object 可以被看做一般的 Python 对象，当需要垃圾回收相关的信息时可以通过简单的类型转换来访问前面的字段：&lt;span data-token-index=&quot;1&quot; spellcheck=&quot;false&quot;&gt;((PyGC_Head *)(the_object)-1)&lt;/span&gt;。&lt;/span&gt;&lt;/section&gt;&lt;p&gt;在后面的章节 &lt;strong&gt;优化：通过复用字段来节省内存&lt;/strong&gt; 会介绍这两个字段通常用来串联起被垃圾收集器管理的对象构成的双向链表（ 每个链表对应垃圾回收中的一个分代，更多细节在 &lt;strong&gt;优化：分代回收&lt;/strong&gt; 中有介绍），但是在不需要链表结构的时候这两个字段会被用作其他功能来减少内存的使用。&lt;/p&gt;&lt;p&gt;使用双向链表是因为其能高效地支持垃圾回收对链表的一些高频操作。所有被垃圾收集器管理的对象被划分成一些不相交的集合，每个集合都在各自的双向链表中。不同的集合表示不同的分代，对象所处的分代反映了其在垃圾回收中存活了多久。每次垃圾回收的时候，每个分代中的对象会进一步划分成可达对象和不可达对象。双向链表的一些操作比如移动对象、添加对象、完全删除一个对象（垃圾收集器管理的对象一般情况下会在两次垃圾回收之间通过引用计数系统回收）、合并链表等，都会在常量时间复杂度完成。并且双向链表支持在遍历的时候添加和删除对象，垃圾收集器在运行的时候这也是一个非常频繁的操作。&lt;/p&gt;&lt;section&gt;&lt;span&gt;为了支持对象的垃圾回收，Python 的 C 接口提供了一些 API 来分配、释放、初始化、添加和移除被垃圾收集器维护的对象。这些 API 的详情参见 &lt;span&gt;https://docs.python.org/3/c-api/gcsupport.html&lt;/span&gt;。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;除了上面的对象结构之外，对于支持垃圾回收的对象的类型对象必须要在 &lt;span data-token-index=&quot;1&quot; spellcheck=&quot;false&quot;&gt;tp_flags&lt;/span&gt; 字段中设置 &lt;span data-token-index=&quot;3&quot; spellcheck=&quot;false&quot;&gt;Py_TPFLAGS_HAVE_GC&lt;/span&gt; 标记，并且实现 &lt;span data-token-index=&quot;5&quot; spellcheck=&quot;false&quot;&gt;tp_traverse&lt;/span&gt; 句柄。另外这些类型对象还要实现 &lt;span data-token-index=&quot;7&quot; spellcheck=&quot;false&quot;&gt;tp_clear&lt;/span&gt; 句柄，除非能够证明仅仅通过该类型的对象不会形成循环引用或者支持垃圾回收的对象是不可变类型。&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;循环引用的识别&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;CPython 中识别循环引用的算法在 &lt;code&gt;gc&lt;/code&gt; 模块中实现。垃圾收集器只关注清除容器类型的对象（也就是那些能够包含对其他对象的引用的对象）。比如数组、字典、列表、自定义类实例和扩展模块中的类等等。虽然循环引用并不常见， 但是 &lt;code&gt;CPython&lt;/code&gt; 解释器自身也会由于一些内部引用的存在形成循环引用。下面是一些典型场景&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;异常对象 exception 会包含栈跟踪对象 traceback，栈跟踪对象包含栈帧的列表，这些栈帧最终又会包含异常对象。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;模块级别的函数会引用模块的字典 dict（用于解析全局变量），模块字典反过来又会包含模块级别的函数。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;类的实例对象会引用其所属的类对象，类对象会引用其所在的模块，模块会包含模块内的所有对象（可能还会包含其他的模块）从而最终会引用到最初的类实例对象。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;当要表示图这类数据结构的时候，很容易产生对自身的引用。&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;如果想要正确释放不可达的对象，第一步就是要识别出不可达对象。在识别循环引用的函数中维护了两个双向链表：一个链表包含所有待扫描的对象，另一个链表包含暂时不可达的对象。&lt;/p&gt;&lt;section&gt;为了理解算法的原理，我们看一下下面的示例，其中 A 引用了一个循环链表，另外还有一个不可达的自我引用的对象：&lt;/section&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span&gt;import&lt;/span&gt; &lt;span&gt;gc&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; &lt;span&gt;Link&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;br/&gt;&lt;span&gt;...&lt;/span&gt;     &lt;span&gt;def&lt;/span&gt; &lt;span&gt;__init__&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;self&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;next_link&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt;None&lt;/span&gt;&lt;span&gt;):&lt;/span&gt;&lt;br/&gt;&lt;span&gt;...&lt;/span&gt;         &lt;span&gt;self&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;next_link&lt;/span&gt; &lt;span&gt;=&lt;/span&gt; &lt;span&gt;next_link&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span&gt;link_3&lt;/span&gt; &lt;span&gt;=&lt;/span&gt; &lt;span&gt;Link&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span&gt;link_2&lt;/span&gt; &lt;span&gt;=&lt;/span&gt; &lt;span&gt;Link&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;link_3&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span&gt;link_1&lt;/span&gt; &lt;span&gt;=&lt;/span&gt; &lt;span&gt;Link&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;link_2&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span&gt;link_3&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;next_link&lt;/span&gt; &lt;span&gt;=&lt;/span&gt; &lt;span&gt;link_1&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span&gt;A&lt;/span&gt; &lt;span&gt;=&lt;/span&gt; &lt;span&gt;link_1&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span&gt;del&lt;/span&gt; &lt;span&gt;link_1&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;link_2&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;link_3&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span&gt;link_4&lt;/span&gt; &lt;span&gt;=&lt;/span&gt; &lt;span&gt;Link&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span&gt;link_4&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;next_link&lt;/span&gt; &lt;span&gt;=&lt;/span&gt; &lt;span&gt;link_4&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span&gt;del&lt;/span&gt; &lt;span&gt;link_4&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;# 回收不可达的 Link 对象 (和它的字典 __dict__)。&lt;br/&gt;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span&gt;gc&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;collect&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;br/&gt;&lt;span&gt;2&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;section&gt;&lt;span&gt;当垃圾收集器开始工作的时候，会将所有要扫描的容器对象放在第一个链表中，这样做是为了将所有不可达对象移除。&lt;/span&gt;&lt;span&gt;因为正常情况下大多数对象都是可达的，所以移除不可达对象会涉及更少的指针操作，因此更高效。&lt;/span&gt;&lt;/section&gt;&lt;p&gt;算法开始的时候会为所有支持垃圾回收的对象另外初始化一个引用计数字段（下图中的 &lt;span data-token-index=&quot;1&quot; spellcheck=&quot;false&quot;&gt;gc_ref&lt;/span&gt;），初始值设置为对象实际的引用计数。因为算法在识别循环引用的计算中会修改引用计数，通过使用一个另外的字段 &lt;span data-token-index=&quot;3&quot; spellcheck=&quot;false&quot;&gt;gc_ref&lt;/span&gt; 解释器就不会修改对象真正的引用计数。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.2916666666666667&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;720&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/icAqJzf0cgMAuxicQMZDAUCMH6JCyWNEyUPGcA4CHBM6xqDj5q5ZK0zyA5vjpABiacLaW4NyyVWyOoK4DicC5kPPIw/640?wx_fmt=png&quot;/&gt;&lt;/p&gt;&lt;p&gt;垃圾收集器会遍历第一个列表中的所有容器对象，每遍历一个对象都会将其所引用的所有的其他对象的 &lt;span data-token-index=&quot;1&quot; spellcheck=&quot;false&quot;&gt;gc_ref&lt;/span&gt; 字段减 1。为了找到容器对象所引用的其他对象需要调用容器类的 &lt;span data-token-index=&quot;3&quot; spellcheck=&quot;false&quot;&gt;tp_traverse&lt;/span&gt; 方法（通过 C API 实现或者由超类继承）。在遍历完之后，只有那些被外部变量引用的对象的 &lt;span data-token-index=&quot;5&quot; spellcheck=&quot;false&quot;&gt;gc_ref&lt;/span&gt; 的值才会大于 0。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.2916666666666667&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;720&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/icAqJzf0cgMAuxicQMZDAUCMH6JCyWNEyU1GhqFNASiaQrpgHJRe9Pvss2x9eZpoDRliahgqhBZfvYXolCyuFHbjeQ/640?wx_fmt=png&quot;/&gt;&lt;/p&gt;&lt;p&gt;需要注意的是即使 &lt;span data-token-index=&quot;1&quot; spellcheck=&quot;false&quot;&gt;gc_ref == 0&lt;/span&gt; 也不能说明对象就是不可达的。因为被外部变量引用的对象（&lt;span data-token-index=&quot;3&quot; spellcheck=&quot;false&quot;&gt;gc_ref &amp;gt; 0&lt;/span&gt;）仍然可能引用它们。比如在我们的例子中，&lt;span data-token-index=&quot;5&quot; spellcheck=&quot;false&quot;&gt;link_2&lt;/span&gt; 对象在第一次遍历之后 &lt;span data-token-index=&quot;7&quot; spellcheck=&quot;false&quot;&gt;gc_ref == 0&lt;/span&gt;，但是 &lt;span data-token-index=&quot;9&quot; spellcheck=&quot;false&quot;&gt;link_1&lt;/span&gt; 对象仍然会引用 &lt;span data-token-index=&quot;11&quot; spellcheck=&quot;false&quot;&gt;link_2&lt;/span&gt;，而 &lt;span data-token-index=&quot;13&quot; spellcheck=&quot;false&quot;&gt;link_1&lt;/span&gt; 是从外部可达的。为了找到那些真正不可达的对象，垃圾收集器需要重新遍历容器对象，这次遍历的时候会将 &lt;span data-token-index=&quot;15&quot; spellcheck=&quot;false&quot;&gt;gc_ref == 0&lt;/span&gt; 的对象标记为暂时不可达并且移动到暂时不可达的链表中。下图描述了垃圾收集器在处理了 &lt;span data-token-index=&quot;17&quot; spellcheck=&quot;false&quot;&gt;link_3&lt;/span&gt; 和 &lt;span data-token-index=&quot;19&quot; spellcheck=&quot;false&quot;&gt;link_4&lt;/span&gt; 对象但是还没处理 &lt;span data-token-index=&quot;21&quot; spellcheck=&quot;false&quot;&gt;link_1&lt;/span&gt; 和 &lt;span data-token-index=&quot;23&quot; spellcheck=&quot;false&quot;&gt;link_2&lt;/span&gt; 对象时的状态。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.2916666666666667&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;720&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/icAqJzf0cgMAuxicQMZDAUCMH6JCyWNEyUT06tdtFmZYXQZrNptzclib0vf4YPSd47oPqMhM5fZVMaPSfhGibx56gA/640?wx_fmt=png&quot;/&gt;&lt;/p&gt;&lt;p&gt;垃圾收集器接下来会处理 &lt;span data-token-index=&quot;1&quot; spellcheck=&quot;false&quot;&gt;link_1&lt;/span&gt; 对象。由于 &lt;span data-token-index=&quot;3&quot; spellcheck=&quot;false&quot;&gt;gc_ref == 1&lt;/span&gt;，垃圾收集器不会对其做特殊处理因为知道其可达（并且已经在可达对象链表中）。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.2916666666666667&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;720&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/icAqJzf0cgMAuxicQMZDAUCMH6JCyWNEyU56o7h3x9GyWneDM7B1Z5tZu719ictxxxHuWSUXcWbg5RDVQz9zcfx6g/640?wx_fmt=png&quot;/&gt;&lt;/p&gt;&lt;p&gt;当垃圾收集器遇到可达对象时（&lt;span data-token-index=&quot;1&quot; spellcheck=&quot;false&quot;&gt;gc_ref &amp;gt; 0&lt;/span&gt;），会通过 &lt;span data-token-index=&quot;3&quot; spellcheck=&quot;false&quot;&gt;tp_traverse&lt;/span&gt; 找到其所引用的其他对象，并且将这些对象移动到可达对象链表（它们最初所在的链表）的末尾，同时设置 &lt;span data-token-index=&quot;5&quot; spellcheck=&quot;false&quot;&gt;gc_ref&lt;/span&gt; 字段为 1。&lt;span data-token-index=&quot;7&quot; spellcheck=&quot;false&quot;&gt;link_2&lt;/span&gt; 和 &lt;span data-token-index=&quot;9&quot; spellcheck=&quot;false&quot;&gt;link_3&lt;/span&gt; 对象就会被这样处理，因为它们都被 &lt;span data-token-index=&quot;11&quot; spellcheck=&quot;false&quot;&gt;link_1&lt;/span&gt; 引用。在上图所示状态之后，垃圾收集器会检查被 &lt;span data-token-index=&quot;13&quot; spellcheck=&quot;false&quot;&gt;link_1&lt;/span&gt; 引用的对象从而知道 &lt;span data-token-index=&quot;15&quot; spellcheck=&quot;false&quot;&gt;link_3&lt;/span&gt; 是可达的，所以将其移回到原来的链表中并且设置 &lt;span data-token-index=&quot;17&quot; spellcheck=&quot;false&quot;&gt;gc_ref&lt;/span&gt; 字段值为 1，那么垃圾收集器下次遇到 &lt;span data-token-index=&quot;19&quot; spellcheck=&quot;false&quot;&gt;link_3&lt;/span&gt; 的时候就知道它是可达的。为了避免重复处理同一个对象，垃圾收集器在处理被可达对象引用的对象的时候会标记它们已经被访问过（通过清除 &lt;span data-token-index=&quot;21&quot; spellcheck=&quot;false&quot;&gt;PREV_MASK_COLLECTING&lt;/span&gt; 标记）。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.2916666666666667&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;720&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/icAqJzf0cgMAuxicQMZDAUCMH6JCyWNEyUUVZgr5BvhgrylCHDTKEjQmDMnu5OCZcfXWtk2FenicwQm1COKudxxmg/640?wx_fmt=png&quot;/&gt;&lt;/p&gt;&lt;p&gt;需要注意的是那些开始被标记为暂时性不可达后来又被回到可达对象链表的对象，会再次被垃圾收集器访问到，因为按照算法逻辑现在被这些对象引用的其他对象也要被处理。第二次遍历实际上是对这些对象间引用关系构成的图的广度优先搜索。在第二遍遍历结束后，垃圾收集器就可以确定现在还留在暂时性不可达对象链表中的对象是真的不可达，因此可以被回收掉。&lt;/p&gt;&lt;p&gt;值得注意的是，整个算法中没有递归操作，也不需要相对于对象数量、指针数量或引用链长度的线性内存空间。除了临时的 C 变量占用 O(1) 的常量空间外，对象本身的字段都已经包含了算法需要的所有数据。&lt;/p&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;为什么选择移动不可达的对象&lt;/span&gt;&lt;/strong&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;因为大多数对象都是可达对象，因此移动不可达对象看起来很合理。但是真正的原因并非想象的那么简单。&lt;/span&gt;&lt;strong&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;假设我们依次创建了 A、B 和 C 三个对象，那么它们在第一代（译注：这里的第一代指的是分代回收）中的顺序就是创建顺序。如果 B 引用 A，C 引用 B，并且 C 有外部引用，那么在垃圾回收算法的第一轮遍历之后 A、B 和 C 的 &lt;span data-token-index=&quot;1&quot; spellcheck=&quot;false&quot;&gt;gc_ref&lt;/span&gt; 值分别为 0、0 和 1，因为只有 C 是外部可达对象。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在算法的第二轮遍历中，会先访问 A，因为 &lt;span data-token-index=&quot;1&quot; spellcheck=&quot;false&quot;&gt;gc_ref&lt;/span&gt; 为 0 会被移动到暂时性不可达对象链表中，B 也一样。当访问到 C 的时候会将 B 移回到可达对象链表中，当再次访问 B 的时候 A 也会被移回到可达对象链表中。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;本可以不用移动，A 和 B 却来回移动了两次，为什么要这么做呢？如果算法直接移动可达对象的话，那么只用将 A、B 和 C 分别移动一次即可。这么做的关键是在垃圾回收结束的时候这几个对象在链表中的顺序依次为 C、B 和 A，与它们最初的创建顺序相反。在后续的垃圾回收中，它们不再需要做任何移动。因为大多数对象之间都没有循环引用，这样做只会在第一次垃圾回收的时候开销比较大，在后续的垃圾回收中能节省很多移动的开销。&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;销毁不可达对象&lt;/span&gt;&lt;/strong&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;一旦垃圾收集器确定了最终的不可达对象列表，就开始销毁这些对象，销毁的大体过程如下&lt;/span&gt;&lt;strong&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;ol class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;处理并且清除弱引用（如果有的话）。如果要销毁的不可达对象有弱引用的回调，那么需要处理回调函数。这个处理过程需要特别小心，因为一个小小的错误就可能让状态不一致的对象被复活或者被回调函数所调用的 Python 函数引用。如果弱引用对象本身也是不可达的（弱引用和其引用的对象在不可达的循环引用中），那么这个弱引用对象需要马上被清理并且不用调用回调函数。如果不马上清理的话，那么在后来调用 &lt;span data-token-index=&quot;1&quot; spellcheck=&quot;false&quot;&gt;tp_clear&lt;/span&gt; 的时候会造成严重后果。当弱引用和其引用的对象都不可达的时候，那么两者都会被销毁，因此可以先销毁弱引用，这个时候其引用的对象还存在，所以可以忽略弱引用的回调。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;如果对象有老版本的终结器（&lt;span data-token-index=&quot;1&quot; spellcheck=&quot;false&quot;&gt;tp_del&lt;/span&gt;）需要将其移到 &lt;span data-token-index=&quot;3&quot; spellcheck=&quot;false&quot;&gt;gc.garbage&lt;/span&gt; 列表中。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;调用不可达对象的终结器（&lt;span data-token-index=&quot;1&quot; spellcheck=&quot;false&quot;&gt;tp_finalize&lt;/span&gt;函数）并且标记这些对象已终结，避免对象被复活后或者在其他对象的终结器已经移除该对象的情况下重复调用 &lt;span data-token-index=&quot;3&quot; spellcheck=&quot;false&quot;&gt;tp_finalize&lt;/span&gt;。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;处理被复活的对象。如果有些不可达对象在上一步被复活，垃圾收集器需要重新计算出最终的不可达对象。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;对于每个最终的不可达对象，调用 &lt;span data-token-index=&quot;1&quot; spellcheck=&quot;false&quot;&gt;tp_clear&lt;/span&gt; 来打破循环引用使每个对象的引用计数都变成 0，从而触发基于引用计数的销毁逻辑。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;优化：分代回收&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;为了避免每次垃圾回收的时候耗时太久，垃圾收集器使用了一个常用的优化：分代回收。分代回收有个前提假设，认为大多数对象的生命周期都很短，会在创建后很快就被回收。这个假设与现实中很多 Python 程序的情况一致，因为很多临时对象会被很快地创建和销毁。存活越久的对象越不容易因为不可达而被回收。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;为了充分利用这一点，所有容器对象都会被分成三代中的某一代。每个新建的容器对象都处于第一代（generation 0）。上面描述的垃圾回收算法只在某一个具体的分代中进行，那些没有被回收的对象会进入下一代（generation 1），这一代中的对象相对于上一代执行垃圾回收的次数会更少。如果对象在新一代中仍然没有被回收就会移动到最后一代（generation 2），在最后一代中执行垃圾回收的次数是最少的。&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;垃圾收集器会记录在上次垃圾回收之后新增对象与销毁对象数量之差，也就是净新增对象数量。如果超过了 &lt;span data-token-index=&quot;1&quot; spellcheck=&quot;false&quot;&gt;threshold_0&lt;/span&gt; 垃圾收集器就会执行。最初的时候垃圾回收只在 generation 0 中执行。如果 generation 1 在上次执行垃圾回收之后， generation 0 中执行垃圾回收的次数超过了 &lt;span data-token-index=&quot;3&quot; spellcheck=&quot;false&quot;&gt;threshold_1&lt;/span&gt; 那么就会再次在 generation 1 中执行垃圾回收。对于 generation 2 的处理稍微复杂点，在 &lt;strong&gt;第三代中的垃圾回收&lt;/strong&gt; 中单独介绍。前面说的阈值 &lt;span data-token-index=&quot;1&quot; spellcheck=&quot;false&quot;&gt;threshold_0&lt;/span&gt; 和 &lt;span data-token-index=&quot;3&quot; spellcheck=&quot;false&quot;&gt;threshold_1&lt;/span&gt; 可以通过函数 &lt;span data-token-index=&quot;5&quot; spellcheck=&quot;false&quot;&gt;gc.get_threshold&lt;/span&gt; 查看（译注：原文这里描述有误，我在 issue &lt;span&gt;https://github.com/python/devguide/issues/1027&lt;/span&gt; 中提出并被作者采纳）：&lt;/span&gt;&lt;/section&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span&gt;import&lt;/span&gt; &lt;span&gt;gc&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span&gt;gc&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;get_threshold&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;br/&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;700&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;10&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;10&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;section&gt;&lt;span&gt;每个分代中的对象可以通过函数 &lt;/span&gt;&lt;span data-token-index=&quot;1&quot; spellcheck=&quot;false&quot;&gt;gc.get_objects(generation=NUM)&lt;/span&gt;&lt;span&gt; 查看，另外可以通过调用函数 &lt;/span&gt;&lt;span data-token-index=&quot;3&quot; spellcheck=&quot;false&quot;&gt;gc.collect(generation=NUM)&lt;/span&gt;&lt;span&gt; 指定在哪个分代中执行垃圾回收。&lt;/span&gt;&lt;br/&gt;&lt;/section&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span&gt;import&lt;/span&gt; &lt;span&gt;gc&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; &lt;span&gt;MyObj&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;br/&gt;&lt;span&gt;...&lt;/span&gt;     &lt;span&gt;pass&lt;/span&gt;&lt;br/&gt;&lt;span&gt;...&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;# 为了更容易观察年轻代中的对象需要将第一代和第二代中的对象都移动到第三代&lt;br/&gt;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span&gt;gc&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;collect&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;br/&gt;&lt;span&gt;0&lt;/span&gt; &lt;span&gt;# 译注：不同版本执行的时候的结果不一样&lt;br/&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;# 创建循环引用&lt;br/&gt;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span&gt;x&lt;/span&gt; &lt;span&gt;=&lt;/span&gt; &lt;span&gt;MyObj&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span&gt;x&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;self&lt;/span&gt; &lt;span&gt;=&lt;/span&gt; &lt;span&gt;x&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;# x 最初在第一代中&lt;br/&gt;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span&gt;gc&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;get_objects&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;generation&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;br/&gt;&lt;span&gt;[...,&lt;/span&gt; &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;__main__&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;MyObj&lt;/span&gt; &lt;span&gt;object&lt;/span&gt; &lt;span&gt;at&lt;/span&gt; &lt;span&gt;0x7fbcc12a3400&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;...]&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;# 在第一代中执行垃圾回收之后，x 就移动到了第二代&lt;br/&gt;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span&gt;gc&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;collect&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;generation&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;br/&gt;&lt;span&gt;0&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span&gt;gc&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;get_objects&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;generation&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;br/&gt;&lt;span&gt;[]&lt;/span&gt; &lt;span&gt;# 译注：在交互模式下，每次键入的代码都会经过编译再执行，所以输出中还有编译过程生成的一些被垃圾收集器管理的对象&lt;br/&gt;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span&gt;gc&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;get_objects&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;generation&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;br/&gt;&lt;span&gt;[...,&lt;/span&gt; &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;__main__&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;MyObj&lt;/span&gt; &lt;span&gt;object&lt;/span&gt; &lt;span&gt;at&lt;/span&gt; &lt;span&gt;0x7fbcc12a3400&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;...]&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2&gt;&lt;span&gt;第三代中的垃圾回收&lt;/span&gt;&lt;br/&gt;&lt;/h2&gt;&lt;p&gt;&lt;span&gt;在上面提到的各种阈值的基础之上，只有当比率 &lt;span data-token-index=&quot;1&quot; spellcheck=&quot;false&quot;&gt;long_lived_pending / long_lived_total&lt;/span&gt; 的值高于一个给定值（硬编码为 25%）的时候，才会在第三代中进行一次全量回收。因为尽管对于非全量的回收（比如第一代和第二代中的回收）每次都会遍历差不多数量的对象（具体的大约数量由上面提到的阈值决定），但是对于一次全量回收的时间复杂度与长期存在的对象数量呈线性关系，而长期存在的对象数量是不可控的。实际上对于那些创建和保存很多长期存在的对象的程序，已经被证明如果每创建固定数量的对象就进行一次全量垃圾回收会导致性能的急剧下降（比如创建很多被垃圾收集器管理的对象并且都放进一个列表中，那么垃圾回收的时间复杂度不是线性的，而是 O(N²)。（译注：这里的时间复杂度不是上面说的一次垃圾回收的时间与分代中对象数量的关系，而是指在创建很多对象到列表中这种程序模式下，所有垃圾回收的总耗时与创建的对象数量的关系，详情见 &lt;span&gt;https://mail.python.org/pipermail/python-dev/2008-June/080579.html&lt;/span&gt;））。如果使用上面的比率，就会变成摊还之后的线性复杂度（这种做法可以总结为：尽管随着创建的对象越来越多全量垃圾回收会变得越来越慢，但是全量垃圾回收的次数也会变得越来越少）。&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;优化：通过复用字段来节省内存&lt;/span&gt;&lt;/strong&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;为了节省内存，支持垃圾回收的对象中的用于链表的两个指针也会被用作其他用途。这种常见的优化叫做胖指针或标记指针：在指针中存储额外的数据，能够这样做也是利用了内存寻址的特性。大多数架构会将数据的内存同数据的大小对齐，通常是一个字或多个字对齐。对齐之后就会使得指针的最低几位不会被使用，而这些低位就可以用作标记或存储其他信息 —— 通常作为位域（每一位都是一个独立的标记）—— 只要程序在使用指针寻址前屏蔽掉这些位域即可。例如在 32 位架构上，一个字大小是 32 位 4 字节，所以字对齐的地址都是 4 的倍数，也就是以 &lt;span data-token-index=&quot;1&quot; spellcheck=&quot;false&quot;&gt;00&lt;/span&gt; 结尾，因此最低 2 位可以用作他用；类似的在 64 位结构上，一个字大小是 64 位 8 字节，字对齐的地址以 &lt;span data-token-index=&quot;3&quot; spellcheck=&quot;false&quot;&gt;000&lt;/span&gt; 结尾，最低 3 位可以用来保存其他数据。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;CPython 的垃圾收集器的实现就使用了&lt;strong&gt; 内存布局和对象结构&lt;/strong&gt; 中描述的 &lt;span data-token-index=&quot;3&quot; spellcheck=&quot;false&quot;&gt;PyGC_Head&lt;/span&gt; 结构体中的两个胖指针：&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;注意事项&lt;/span&gt;&lt;/strong&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;因为胖指针或标记指针保存了其他数据，所以不能直接用来寻址，必须在清除这些其他数据之后才能得到真正的地址。尤其需要注意那些直接操作链表的函数，因为这些函数经常会假设链表中的指针状态一致。&lt;/span&gt;&lt;strong&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;优化：延迟管理容器对象&lt;/span&gt;&lt;/strong&gt;&lt;/section&gt;&lt;p&gt;有些容器对象不会产生循环引用，所以垃圾收集器没必要管理它们。解除对这些对象的管理会提高垃圾收集器的性能。但是判断一个对象是否可以解除管理也是有成本的，因此必须要权衡一下成本和由此给垃圾收集器带来的收益。有两个可能的时机可以解除对容器对象的管理：&lt;/p&gt;&lt;ol class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;容器对象创建的时候&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;垃圾回收的时候&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;section&gt;大的原则是原子类型不需要被垃圾收集器管理，非原子类型（容器、用户自定义对象等）需要。也有一些针对特定类型的优化避免垃圾收集器在垃圾回收时对一些简单对象做不必要的检查。下面是一些对内置类型延迟管理的例子：&lt;/section&gt;&lt;section&gt;垃圾回收模块提供了 Python 函数 &lt;span data-token-index=&quot;1&quot; spellcheck=&quot;false&quot;&gt;is_tracked(obj)&lt;/span&gt; 返回对象当前是否被垃圾收集器管理。当然后续垃圾回收的时候可能会改变管理状态。&lt;/section&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span&gt;gc&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;is_tracked&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;br/&gt;&lt;span&gt;False&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span&gt;gc&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;is_tracked&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;&quot;a&quot;&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;br/&gt;&lt;span&gt;False&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span&gt;gc&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;is_tracked&lt;/span&gt;&lt;span&gt;([])&lt;/span&gt;&lt;br/&gt;&lt;span&gt;True&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span&gt;gc&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;is_tracked&lt;/span&gt;&lt;span&gt;({})&lt;/span&gt;&lt;br/&gt;&lt;span&gt;False&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span&gt;gc&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;is_tracked&lt;/span&gt;&lt;span&gt;({&lt;/span&gt;&lt;span&gt;&quot;a&quot;&lt;/span&gt;&lt;span&gt;:&lt;/span&gt; &lt;span&gt;1&lt;/span&gt;&lt;span&gt;})&lt;/span&gt;&lt;br/&gt;&lt;span&gt;False&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span&gt;gc&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;is_tracked&lt;/span&gt;&lt;span&gt;({&lt;/span&gt;&lt;span&gt;&quot;a&quot;&lt;/span&gt;&lt;span&gt;:&lt;/span&gt; &lt;span&gt;[]})&lt;/span&gt;&lt;br/&gt;&lt;span&gt;True&lt;/span&gt;&lt;span/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;​&lt;/p&gt;&lt;p&gt;​&lt;/p&gt;&lt;p&gt;​&lt;/p&gt;&lt;p&gt;&lt;mp-style-type data-value=&quot;3&quot;/&gt;&lt;/p&gt;&lt;/div&gt;

          
        &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>d25c898784c52c840af47f15f5117b31</guid>
<title>谁再问我 docker，我就把这篇甩给他</title>
<link>https://toutiao.io/k/w4m85cs</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;目录&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;什么是Docker？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Docker的应用场景有哪些？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Docker的优点有哪些？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Docker与虚拟机的区别是什么？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Docker的三大核心是什么？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;如何快速安装Docker？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;如何修改Docker的存储位置？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Docker镜像常用管理有哪些？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;如何创建Docker容器？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Docker在后台的标准运行过程是什么？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Docker网络模式有哪些？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;什么是Docker的数据卷&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;如何搭建Docker私有仓库&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Docker如何迁移备份？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Docker如何部署MySQL？&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;前言&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;本文总结了Docker常见的问题和坑，采用问答的形式，分享给大家&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;1.什么是Docker？&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;Docker 是一个开源的应用容器引擎，基于go 语言开发并遵循了apache2.0 协议开源&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Docker 是在Linux 容器里运行应用的开源工具，是一种轻量级的“虚拟机”&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Docker 的容器技术可以在一台主机上轻松为任何应用创建一个轻量级的，可移植的，自给自足的容器&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;也可以这样形象的比喻：&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;Docker 的Logo设计为蓝色鲸鱼，拖着许多集装箱，鲸鱼可以看作为宿主机，集装箱可以理解为相互隔离的容器，每个集装箱中都包含自己的应用程序。&lt;/p&gt;&lt;/blockquote&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;2.Docker的应用场景有哪些？&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;Web 应用的自动化打包和发布。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;自动化测试和持续集成、发布。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;在服务型环境中部署和调整数据库或其他的后台应用。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;从头编译或者扩展现有的 OpenShift 或 Cloud Foundry 平台来搭建自己的 PaaS 环境。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在这里我重点介绍下Docker作为内部开发环境的场景&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在容器技术出现之前，公司往往是通过为每个开发人员提供一台或者多台虚拟机来充当开发测试环境。开发测试环境一般负载较低，大量的系统资源都被浪费在虚拟机本身的进程上了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Docker容器没有任何CPU和内存上的额外开销，很适合用来提供公司内部的开发测试环境。而且由于docker镜像可以很方便的在公司内部分享，这对开发环境的规范性也有极大的帮助。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果要把容器作为开发机使用，需要解决的是远程登录容器和容器内进程管理问题。虽然docker的初衷是为“微服务”架构设计的，但根据我们的实际使用经验，在docker内运行多个程序，甚至sshd或者upstart也是可行的。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;3.Docker的优点有哪些？&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;容器化越来越受欢迎，Docker的容器有点总结如下：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;灵活：即使是最复杂的应用也可以集装箱化。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;轻量级：容器利用并共享主机内核。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;可互换：可以即时部署更新和升级。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;便携式：可以在本地构建，部署到云，并在任何地方运行。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;可扩展：可以增加并白动分发容器副本。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;可堆叠：可以垂直和即时堆叠服务。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.7751004016064257&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/8KKrHK5ic6XBBkjg9F1QSQxP8nUib0JvB8oibHU8Xe0x29dY0gCibbrZSbiaaPoYhnsNrs5URy54GGtQmsmToUiaA7YA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;747&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Docker 是一个用于开发，交付和运行应用程序的开放平台。Docker 使您能够将应用程序与基础架构分开，从而可以快速交付软件。借助 Docker，您可以与管理应用程序相同的方式来管理基础架构。通过利用 Docker 的方法来快速交付，测试和部署代码，您可以大大减少编写代码和在生产环境中运行代码之间的延迟。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;4.Docker与虚拟机的区别是什么？&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;虚拟机通过添加Hypervisor层（虚拟化中间层），虚拟出网卡、内存、CPU等虚拟硬件，再在其上建立虚拟机，每个虚拟机都有自己的系统内核。而Docker容器则是通过隔离（namesapce）的方式，将文件系统、进程、设备、网络等资源进行隔离，再对权限、CPU资源等进行控制（cgroup），最终让容器之间互不影响，容器无法影响宿主机。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;与虚拟机相比，容器资源损耗要少。同样的宿主机下，能够建立容器的数量要比虚拟机多&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但是，虚拟机的安全性要比容器稍好，而docker容器与宿主机共享内核、文件系统等资源，更有可能对其他容器、宿主机产生影响。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.2596026490066225&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/8KKrHK5ic6XBBkjg9F1QSQxP8nUib0JvB83vDs1RFOicYyrDFQE1Xx0PEa4EqicH3f6rgEMNztbWWgBwPLPNn9YZaw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;755&quot;/&gt;&lt;/figure&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;5.Docker的三大核心是什么？&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;镜像&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Docker的镜像是创建容器的基础，类似虚拟机的快照，可以理解为一个面向Docker容器引擎的只读模板。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;通过镜像启动一个容器，一个镜像是一个可执行的包，其中包括运行应用程序所需要的所有内容包含代码，运行时间，库、环境变量、和配置文件。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Docker镜像也是一个压缩包，只是这个压缩包不只是可执行文件，环境部署脚本，它还包含了完整的操作系统。因为大部分的镜像都是基于某个操作系统来构建，所以很轻松的就可以构建本地和远端一样的环境，这也是Docker镜像的精髓。&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;容器&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Docker的容器是从镜像创建的运行实例，它可以被启动、停止和删除。所创建的每一个容器都是相互隔离、互不可见，以保证平台的安全性。可以把容器看做是一个简易版的linux环境（包括root用户权限、镜像空间、用户空间和网络空间等）和运行在其中的应用程序。&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;仓库&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;仓库注册服务器上往往存放着多个仓库，每个仓库中包含了多个镜像，每个镜像有不同标签（tag）。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;仓库分为公开仓库（Public）和私有仓库（Private）两种形式。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;最大的公开仓库是 Docker Hub:&lt;code&gt;https://hub.docker.com&lt;/code&gt;，存放了数量庞大的镜像供用户下载。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;国内的公开仓库包括阿里云 、网易云等。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;6.如何快速安装Docker？&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;执行以下安装命令去安装依赖包&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;yum install -y yum-utils device-mapper-persistent-data lvm2&lt;br/&gt;sudo yum-config-manager&lt;br/&gt;–add-repo&lt;br/&gt;https://download.docker.com/linux/centos/docker-ce.repo&lt;br/&gt;[root@centos7 ~] yum -y install docker-ce docker-ce-cli containerd.io&lt;br/&gt;[root@centos7 ~]&lt;span&gt;# docker ps --查看docker&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.9178433889602053&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/8KKrHK5ic6XBBkjg9F1QSQxP8nUib0JvB87HyDSUJeISnTnichXcZMeOpKQvwJJ2G8ZkCwYsibuCX4wicuKygbwfn4w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;779&quot;/&gt;&lt;/figure&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;[root@centos7 ~]&lt;span&gt;# systemctl enable docker&lt;/span&gt;&lt;br/&gt;[root@centos7 ~]&lt;span&gt;# systemctl start docker&lt;/span&gt;&lt;br/&gt;[root@centos7 ~]&lt;span&gt;# systemctl status docker&lt;/span&gt;&lt;br/&gt;[root@centos7 ~]&lt;span&gt;# docker ps --查看容器&lt;/span&gt;&lt;br/&gt;[root@centos7 ~]&lt;span&gt;# docker version --查看版本&lt;/span&gt;&lt;br/&gt;[root@centos7 ~]&lt;span&gt;# docker info --查看版本&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;7.如何修改Docker的存储位置？&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;默认情况下 Docker的存放位置为：&lt;code&gt;/var/lib/docker&lt;/code&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可以通过命令查看具体位置：&lt;code&gt;docker info | grep “Docker Root Dir”&lt;/code&gt;&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;修改到其它目录&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;首先停掉 Docker 服务：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;systemctl stop docker&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;然后移动整个/var/lib/docker 目录到目的路径&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;mkdir -p /root/data/docker&lt;br/&gt;mv /var/lib/docker /root/data/docker&lt;br/&gt;ln -s /root/data/docker /var/lib/docker --快捷方式&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;8.Docker镜像常用管理有哪些？&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;快速检索镜像&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;格式：&lt;code&gt;docker search&lt;/code&gt; 关键字&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;获取镜像&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;格式：&lt;code&gt;docker   pull&lt;/code&gt;   仓库名称[:标签]
如果下载镜像时不指定标签，则默认会下载仓库中最新版本的镜像，即选择标签为 latest 标签&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;查看镜像信息&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;镜像下载后默认存放在 &lt;code&gt;/var/lib/docker&lt;/code&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;REPOSITORY&lt;/code&gt;: 镜像所属仓库&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;TAG&lt;/code&gt;: 镜像的标签信息，标记同一个仓库中的不同镜像&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;IMAGE ID&lt;/code&gt; ：镜像的唯一ID号，唯一标识一个镜像&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;CREATED&lt;/code&gt;: 镜像创建时间&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;SIZE&lt;/code&gt;: 镜像大小&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.20512820512820512&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/8KKrHK5ic6XBBkjg9F1QSQxP8nUib0JvB85kgRFoA3k7NGlMG40qIEmUT8yEt5FwhybRLY8J3ambyESutLgfDO3A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;663&quot;/&gt;&lt;/figure&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;获取镜像的详细信息&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;格式：&lt;code&gt;docker   inspect&lt;/code&gt;   镜像ID号&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;镜像ID 号可以不用打全。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.4457034938621341&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/8KKrHK5ic6XBBkjg9F1QSQxP8nUib0JvB81MLYxrTLHeSIfiaAlwib6NtQHPBqiamS5GibCfMmUZ5L2RibeqiaQSibanELw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1059&quot;/&gt;&lt;/figure&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;为本地镜像添加新的标签&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;格式：&lt;code&gt;docker   tag  名称:[ 标签]&lt;/code&gt;&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;删除镜像&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;格式1：&lt;code&gt;docker   rmi   仓库名称:标签&lt;/code&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当一个镜像有多个标签时，只是删除其中指定的标签&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;格式2: &lt;code&gt;docker   rmi  镜像ID  [-f]&lt;/code&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果该镜像已经被容器使用，正确的做法是先删除依赖该镜像的所有容器，再去删除镜像&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;将镜像保存为本地文件&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;格式：&lt;code&gt;docker   save   -o  存储文件名   存储的镜像&lt;/code&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;[root@localhost ~]&lt;span&gt;# docker save -o /opt/nginx.tar nginx:latest&lt;/span&gt;&lt;br/&gt;&lt;span&gt;#将本地镜像传给另一台主机&lt;/span&gt;&lt;br/&gt;[root@localhost ~]&lt;span&gt;# scp /opt/nginx.tar 192.168.1.54:/opt&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;9.如何创建Docker容器？&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;#docker images   --镜像&lt;/span&gt;&lt;br/&gt;docker run -d --name centos7.8 -h centos7.8 \&lt;br/&gt;-p 220:22 -p 3387:3389 \&lt;br/&gt;--privileged=&lt;span&gt;true&lt;/span&gt; \&lt;br/&gt;centos:7.8.2003 /usr/sbin/init&lt;br/&gt;&lt;br/&gt;&lt;span&gt;#我想拥有一个 linux 8.2 的环境&lt;/span&gt;&lt;br/&gt;docker run -d --name centos8.2 -h centos8.2 \&lt;br/&gt;-p 230:22 -p 3386:3389 \&lt;br/&gt;--privileged=&lt;span&gt;true&lt;/span&gt; \&lt;br/&gt;daocloud.io/library/centos:8.2.2004 init&lt;br/&gt;&lt;br/&gt;&lt;span&gt;# 进入容器&lt;/span&gt;&lt;br/&gt;docker &lt;span&gt;exec&lt;/span&gt; -it centos7.8bash&lt;br/&gt;docker &lt;span&gt;exec&lt;/span&gt; -it centos8.2 bash&lt;br/&gt;cat /etc/redhat-release    --查看系统版本&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;10.Docker在后台的标准运行过程是什么？&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当利用 &lt;code&gt;docker run&lt;/code&gt; 来创建容器时， Docker 在后台的标准运行过程是：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;检查本地是否存在指定的镜像。当镜像不存在时，会从公有仓库下载；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;利用镜像创建并启动一个容器；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;分配一个文件系统给容器，在只读的镜像层外面挂载一层可读写层；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;从宿主主机配置的网桥接口中桥接一个虚拟机接口到容器中；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;分配一个地址池中的 IP 地址给容器；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;执行用户指定的应用程序，执行完毕后容器被终止运行。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;11.Docker网络模式有哪些？&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;host模式&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;host 模式 ：使用 &lt;code&gt;--net=host&lt;/code&gt; 指定&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;相当于VMware 中的桥接模式，与宿主机在同一个网络中，但是没有独立IP地址&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Docker 使用了Linux 的Namespace 技术来进行资源隔离，如&lt;code&gt;PID Namespace&lt;/code&gt;隔离进程，&lt;code&gt;Mount Namespace&lt;/code&gt;隔离文件系统，&lt;code&gt;Network Namespace&lt;/code&gt; 隔离网络等。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;一个&lt;code&gt;Network Namespace&lt;/code&gt; 提供了一份独立的网络环境，包括网卡，路由，iptable 规则等都与其他&lt;code&gt;Network Namespace&lt;/code&gt; 隔离。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;一个Docker 容器一般会分配一个独立的&lt;code&gt;Network Namespace&lt;/code&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但是如果启动容器的时候使用host 模式，那么这个容器将不会获得一个独立的&lt;code&gt;Network Namespace&lt;/code&gt; ，而是和宿主机共用一个&lt;code&gt;Network Namespace&lt;/code&gt; 。容器将不会虚拟出自己的网卡，配置自己的IP等，而是使用宿主机的IP和端口.此时容器不再拥有隔离的、独立的网络栈。不拥有所有端口资源&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.7944199706314243&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/8KKrHK5ic6XBBkjg9F1QSQxP8nUib0JvB80If17VF9yUiaxoXe8YjqWwEBEicFARkc0UylL8HYdWN3hvAfnyVBI2Xg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;681&quot;/&gt;&lt;/figure&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;container模式&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;container模式：使用&lt;code&gt;–net=contatiner:NAME_or_ID &lt;/code&gt;指定&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个模式指定新创建的容器和已经存在的一个容器共享一个&lt;code&gt;Network Namespace&lt;/code&gt;，而不是和宿主机共享。&lt;strong&gt;新创建的容器不会创建自己的网卡，配置自己的IP，而是和一个指定的容器共享IP，端口范围等。&lt;/strong&gt; 可以在一定程度上节省网络资源，容器内部依然不会拥有所有端口。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;同样，两个容器除了网络方面，其他的如文件系统，进程列表等还是隔离的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;两个容器的进程可以通过lo网卡设备通信&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.471875&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/8KKrHK5ic6XBBkjg9F1QSQxP8nUib0JvB8bNMcAdjian2X8BL5LpLPHibk2MRnGe9FFOzX7Zuib0KEe0liag7ia4qibuZw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;960&quot;/&gt;&lt;/figure&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;none 模式&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;none模式:使用 &lt;code&gt;--net=none&lt;/code&gt;指定&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;使用none 模式，docker 容器有自己的&lt;code&gt;network Namespace&lt;/code&gt; ，但是并不为Docker 容器进行任何网络配置。也就是说，这个Docker 容器没有网卡，ip， 路由等信息。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这种网络模式下，容器只有lo 回环网络，没有其他网卡。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这种类型没有办法联网，但是封闭的网络能很好的保证容器的安全性&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;该容器将完全独立于网络，用户可以根据需要为容器添加网卡。此模式拥有所有端口。（none网络模式配置网络）特殊情况下才会用到，一般不用&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;bridge 模式&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;相当于Vmware中的 nat 模式，容器使用独立&lt;code&gt;network Namespace&lt;/code&gt;，并连接到docker0虚拟网卡。通过docker0网桥以及&lt;code&gt;iptables nat&lt;/code&gt;表配置与宿主机通信，此模式会为每一个容器分配&lt;code&gt;Network Namespace&lt;/code&gt;、设置IP等，并将一个主机上的 Docker 容器连接到一个虚拟网桥上。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当Docker进程启动时，会在主机上创建一个名为docker0的虚拟网桥，此主机上启动的Docker容器会连接到这个虚拟网桥上。虚拟网桥的工作方式和物理交换机类似，这样主机上的所有容器就通过交换机连在了一个二层网络中。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;从docker0子网中分配一个IP给容器使用，并设置docker0的IP地址为容器的默认网关。在主机上创建一对虚拟网卡&lt;code&gt;veth pair&lt;/code&gt;设备。veth设备总是成对出现的，它们组成了一个数据的通道，数据从一个设备进入，就会从另一个设备出来。因此，veth设备常用来连接两个网络设备。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Docker将&lt;code&gt;veth pair&lt;/code&gt; 设备的一端放在新创建的容器中，并命名为eth0（容器的网卡），另一端放在主机中， 以&lt;code&gt;veth*&lt;/code&gt;这样类似的名字命名，并将这个网络设备加入到docker0网桥中。可以通过 &lt;code&gt;brctl show&lt;/code&gt; 命令查看。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;容器之间通过&lt;code&gt;veth pair&lt;/code&gt;进行访问&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;使用 &lt;code&gt;docker run -p&lt;/code&gt; 时，docker实际是在iptables做了DNAT规则，实现端口转发功能。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可以使用&lt;code&gt;iptables -t nat -vnL&lt;/code&gt; 查看。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.8253557567917206&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/8KKrHK5ic6XBBkjg9F1QSQxP8nUib0JvB8HuS4gqTTdXKzaSMcbRen5NbcfdFYtB2PwTe9k6icrHlRl2wR6wJpcww/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;773&quot;/&gt;&lt;/figure&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;12.什么是Docker的数据卷&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;数据卷是一个供容器使用的特殊目录，位于容器中。可将宿主机的目录挂载到数据卷上，对数据卷的修改操作立刻可见，并且更新数据不会影响镜像，从而实现数据在宿主机与容器之间的迁移。数据卷的使用类似于Linux下对目录进行的mount操作。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果需要在容器之间共享一些数据，最简单的方法就是使用数据卷容器。数据卷容器是一个普通的容器，专门提供数据卷给其他容器挂载使用。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;容器互联是通过容器的名称在容器间建立一条专门的网络通信隧道。简单点说，就是会在源容器和接收容器之间建立一条隧道，接收容器可以看到源容器指定的信息&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;13.如何搭建Docker私有仓库&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;1.拉取私有仓库镜像&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;[root@jeames ~]&lt;span&gt;# docker pull registry&lt;/span&gt;&lt;br/&gt;Using default tag: latest&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;2.启动私有仓库容器&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;docker run -di --name registry -p 5000:5000 registry&lt;br/&gt;docker update --restart=always registry   --开机自启动&lt;br/&gt;docker ps -a  --format &lt;span&gt;&quot;table {{.ID}}\t{{.Names}}\t{{.Status}}&quot;&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;访问网址：&lt;code&gt;http://192.168.1.54:5000/v2/_catalog&lt;/code&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;3.设置信任&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;[root@jeames ~]&lt;span&gt;# vi /etc/docker/daemon.json&lt;/span&gt;&lt;br/&gt;{&lt;br/&gt;&lt;span&gt;&quot;registry-mirrors&quot;&lt;/span&gt;:[&lt;span&gt;&quot;https://docker.mirrors.ustc.edu.cn&quot;&lt;/span&gt;],&lt;br/&gt;&lt;span&gt;&quot;insecure-registries&quot;&lt;/span&gt;:[&lt;span&gt;&quot;192.168.1.54:5000&quot;&lt;/span&gt;]&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;[root@jeames ~]&lt;span&gt;# systemctl restart docker   --重启docker&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;4.上传本地镜像&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;[root@jeames ~]&lt;span&gt;# docker images&lt;/span&gt;&lt;br/&gt;[root@jeames ~]&lt;span&gt;# docker tag postgres:11 192.168.1.54:5000/postgres&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;[root@jeames ~]&lt;span&gt;# docker push 192.168.1.54:5000/postgres&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;5.重新拉取镜像&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;[root@jeames ~]&lt;span&gt;# docker rmi 192.168.1.54:5000/postgres&lt;/span&gt;&lt;br/&gt;[root@jeames ~]&lt;span&gt;# docker images&lt;/span&gt;&lt;br/&gt;[root@jeames ~]&lt;span&gt;# docker pull 192.168.1.54:5000/postgres&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;14.Docker如何迁移备份？&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;1.容器保存为镜像&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;[root@jeames ~]&lt;span&gt;# docker images&lt;/span&gt;&lt;br/&gt;[root@jeames ~]&lt;span&gt;# docker ps -a&lt;/span&gt;&lt;br/&gt;docker ps -a --format &lt;span&gt;&quot;table {{.ID}}\t{{.Names}}\t{{.Status}}&quot;&lt;/span&gt;&lt;br/&gt;[root@jeames ~]&lt;span&gt;# docker commit redis myredis&lt;/span&gt;&lt;br/&gt;&lt;span&gt;##使用新的镜像创建容器&lt;/span&gt;&lt;br/&gt;docker run -di --name myredis myredis&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;2.镜像的备份&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;[root@jeames ~]&lt;span&gt;# docker save -o myredis.tar myredis&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;默认放到当前目录&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;[root@jeames ~]&lt;span&gt;# ll&lt;/span&gt;&lt;br/&gt;[root@jeames ~]&lt;span&gt;# pwd&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;3.恢复过程&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;##删除容器&lt;/span&gt;&lt;br/&gt;docker ps --format &lt;span&gt;&quot;table {{.ID}}\t{{.Names}}\t{{.Status}}&quot;&lt;/span&gt;&lt;br/&gt;docker stop myredis&lt;br/&gt;docker rm myredis&lt;br/&gt;&lt;span&gt;##删除镜像&lt;/span&gt;&lt;br/&gt;docker images&lt;br/&gt;docker rmi myredis&lt;br/&gt;[root@jeames ~]&lt;span&gt;# docker load -i myredis.tar&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;15. Docker如何部署MySQL？&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;1.下载镜像&lt;span/&gt;&lt;/h5&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;https://hub.docker.com/ 中搜索mysql&lt;br/&gt;[root@jeames ~]&lt;span&gt;# docker pull mysql:5.7.30&lt;/span&gt;&lt;br/&gt;[root@jeames ~]&lt;span&gt;# docker pull mysql:8.0.20&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;2.安装部署&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;2.1 创建容器&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;mkdir -p /usr/&lt;span&gt;local&lt;/span&gt;/mysql5730/&lt;br/&gt;mkdir -p /usr/&lt;span&gt;local&lt;/span&gt;/mysql8020/&lt;br/&gt;&lt;br/&gt;docker run -d --name mysql5730 -h mysql5730 \&lt;br/&gt;-p 3309:3306 \&lt;br/&gt;-v /usr/&lt;span&gt;local&lt;/span&gt;/mysql5730/conf:/etc/mysql/conf.d \&lt;br/&gt;-e MYSQL_ROOT_PASSWORD=root -e TZ=Asia/Shanghai \&lt;br/&gt;mysql:5.7.30&lt;br/&gt;&lt;br/&gt;docker run -d --name mysql8020 -h mysql8020 \&lt;br/&gt;-p 3310:3306 \&lt;br/&gt;-v /usr/&lt;span&gt;local&lt;/span&gt;/mysql8020/conf:/etc/mysql/conf.d \&lt;br/&gt;-e MYSQL_ROOT_PASSWORD=root -e TZ=Asia/Shanghai \&lt;br/&gt;mysql:8.0.20&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;2.2 访问Mysql&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;##登陆容器&lt;/span&gt;&lt;br/&gt;docker &lt;span&gt;exec&lt;/span&gt; -it mysql5730 bash&lt;br/&gt;mysql -uroot -proot&lt;br/&gt;mysql&amp;gt; select user,host from mysql.user&lt;br/&gt;&lt;br/&gt;&lt;span&gt;##远程访问&lt;/span&gt;&lt;br/&gt;mysql -uroot -proot -h192.168.59.220 -P3309&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>2b851ce7f17771c3b30df405b53d8379</guid>
<title>还能这样玩？Go 将会增强 Go1 向前兼容性</title>
<link>https://toutiao.io/k/nz2juqx</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content js_underline_content             autoTypeSetting24psection&amp;#10;            &quot; id=&quot;js_content&quot;&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot; data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;大家好，我是煎鱼。&lt;span&gt;新春快乐呀！&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;年前我们在《&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzUxMDI4MDc1NA==&amp;amp;mid=2247497929&amp;amp;idx=1&amp;amp;sn=1f730d9812918edac5a959d34e932152&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;醒醒吧，未来不会有 Go2 了！&lt;/a&gt;》文章中讨论了 Go2 的未来，明确了未来是以 Go1.x.y 为主的 Go1 时代。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;为了实现这个北极星目标，Go 团队采取的策略分别是：增强 Go1 向后兼容（在前文已分享）和 Go1 向前兼容（本文重点内容）。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;本次要提到的 “向前兼容”，指的是&lt;strong&gt;旧版本的 Go 编译新的 Go 代码&lt;/strong&gt;。这个方向比较少被谈论，甚至特意设计。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;让我有种，还能这样搞的感觉？&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;Go1 向前兼容&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Go 团队的大当家 Russ Cox，针对如下几个方面做了新设计和调整，输出了《&lt;span&gt;Proposal: Extended forwards compatibility in Go&lt;/span&gt;&lt;sup&gt;[1]&lt;/sup&gt;》，已经得到讨论，很大概率落地，把版本号停留在 Go1.x.y。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;将会涉及的部分重点如下：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;新增 GOTOOLCHAIN 环境变量的设置。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;改变在工作模块（work module）中解释 go 行的方式，增加了新的工具链（toolchain）行以此实现声明。此对应的是 go.mod 文件的 go 行和 &lt;span&gt;toolchain 行。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;对 go get 等命令进行联动修改，允许对 GOTOOLCHAIN 和工作模块的 go 版本进行修改。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;增强工作模块的 go.mod 和 toolchain&lt;span/&gt;&lt;/h3&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;声明 Go 版本号&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们会在 go module 生成时，在 Go 工程下生成一个 go.mod 文件。其中会包含一个 go 行，将会声明该模块应该应用的 go 版本语义是什么版本。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如下图，声明的是 go1.13：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.4857916102841678&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/KVl0giak5ib4h8ngBvgMWsicFibbwaibPia5jnVQ5ibHU5bdTPBqUKIpurlmxT3JQiccDGz9PxYwFQO9ELiaF7EicPUGbvoA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1478&quot;/&gt;&lt;figcaption&gt;go.mod 文件中的 go 版本声明&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在该提案落地后，本地安装的 Go 工具链如果比 go 行所声明的 go 版本新时，它将会直接提供所要求的旧语义，而不会重新下载和调用一个旧版本的 Go 工具链。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但如果 go 行声明了一个较新的 Go 工具链，那么本地安装的 Go 工具链就会下载并运行较新的工具链来满足其需求。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;以下是一个例子。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在例子中，我们正在运行的版本是 go1.30。但在模块中，有一个 go.mod 声明了 go 版本：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;go 1.30.1&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Go1.30 会下载并调用 go1.30.1 来完成命令，因为模块中要求的 go 版本比本地安装的更高。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但如果 go.mod 文件中声明的是：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;go 1.20rc1&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Go1.30 将自己提供 go1.20rc1 语义，而不是运行 go1.20 rc1 工具链。因为本地安装的版本更新，可以通过 GODEBUG 来满足旧语义的诉求。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;声明 Go 工具链版本号&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可能会有同学想要运行更新版本的 Go 工具链，但 Go 语义上还是使用旧版本。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;为了满足这点诉求，go.mod 文件也会支持 toolchain 行的设置，以此来支持新版本的工具链的使用。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果 go.mod 文件中设置了 toolchain 行，将指定使用的工具链版本，go 行只指定语言语义的 Go 版本。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;go.mod 文件如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;go 1.18&lt;br/&gt;toolchain go1.20rc1&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;作用是将为这个模块选择 go1.18 的语义，使用 go1.20rc1 的工具链来构建应用。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;增强 Go 工具链 GOTOOLCHAIN&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;将会在 Go 工具链新增 GOTOOLCHAIN 环境变量的设置和使用可以使用 &lt;code&gt;go env -w&lt;/code&gt; 设置。也可以在 go test 时做如下调整：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;GOTOOLCHAIN=go1.17.2 go &lt;span&gt;test&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;go build 编译时可以：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;GOTOOLCHAIN=go1.18rc1 go build -o myprog.exe&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可能会有同学疑惑 GOTOOLCHAIN 的默认值哪来，有哪些值？&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;设置 &lt;code&gt;GOTOOLCHAIN=local&lt;/code&gt;：使用本地安装的 Go 工具链，不会下载不同版本的工具链。这是现在的的默认行为。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;设置 &lt;code&gt;GOTOOLCHAIN=auto&lt;/code&gt;：使用工作模块的 go.mod 中声明的 go 版本（当它比本地安装的 Go 工具链要新时）。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;GOTOOLCHAIN 环境变量的默认值取决于 Go 工具链。标准 Go 发行版默认为 &lt;code&gt;GOTOOLCHAIN=auto&lt;/code&gt;，也就是将控制权交给 go.mod 文件。这是在实施这个提案后 99% 会看到的默认行为。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Go 工具链的一揽子东西里也比较多，例如：go get 命令，也会对 go.mod 文件中的 go 版本或 toolchain 行进行变更，以配合使用。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;总结&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在今天这篇文章中，我们介绍了 Go1 兼容性增强中的 “向前兼容” 部分，其中要点是：加大对 go.mod 文件中的 go 行和 toolchain 行和工具链 GOTOOLCHAIN 相关的应用。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;核心目的是为了将 go 语法语义和 go 工具链的版本声明公开出来，达到隔离使用。再配合 “向后兼容” 中的 GODEBUG 的使用，让 Go 语言做兼容性时有更多更大的使用空间来实现机制上的保障。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这么一来，Go 语言在这一块会变得异常复杂，理解成本也会变高。希望大家后续在这块也不要再踩坑了。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;推荐阅读&lt;span/&gt;&lt;/h4&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;参考资料&lt;/span&gt;&lt;/h3&gt;&lt;section data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;span&gt;[1]&lt;/span&gt;&lt;p&gt;Proposal: Extended forwards compatibility in Go: &lt;em&gt;https://go.googlesource.com/proposal/+/master/design/57001-gotoolchain.md&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;关注和加煎鱼微信，&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;一手消息和知识，拉你进技术交流群&lt;span&gt;&lt;span&gt;👇&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.9988738738738738&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/KVl0giak5ib4jVkzHVvaqjo3O0BIqDRJKkEyib7SJsryxHBFGsvek0FkdiczfJP6AdbWnK25DvlX3dY8wRObPbVJQg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;888&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.07106598984771574&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/486RHs1WbcgGib6o96dHbvGUGGwPicd8wusUGH1cXR29tM4bO0lNzialzkQhvU6m5ZUdaKibmcF2OQayjMe9Bia6iaXQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;394&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;你好，我是煎鱼，&lt;span&gt;出版过 Go 畅销书《Go 语言编程之旅》，再到获得 GOP（Go 领域最有观点专家）荣誉，&lt;/span&gt;&lt;strong&gt;&lt;span&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzUxMDI4MDc1NA==&amp;amp;mid=2247483854&amp;amp;idx=1&amp;amp;sn=ec422fbf4d846975f2930ddeb5e81373&amp;amp;chksm=f9041493ce739d85a4b987eece14da627206cdad798f645cc770868312e4a22b6df24804f186&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;点击蓝字查看我的出书之路&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;点击蓝字查看我的出书之路&lt;/a&gt;&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;日常分享高质量文章，输出 Go 面试、工作经验、架构设计，&lt;span&gt;加微信拉读者交流群，和大家交流！&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;p&gt;&lt;mp-style-type data-value=&quot;3&quot;/&gt;&lt;/p&gt;&lt;/div&gt;

          
        &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>963ff466ff08056d79f7760188f5b953</guid>
<title>Vue3 的响应式原理？一篇文章，八张图，三心为你解密</title>
<link>https://toutiao.io/k/2jra2qc</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content js_underline_content             autoTypeSetting24psection&amp;#10;            &quot; id=&quot;js_content&quot;&gt;&lt;blockquote data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;p&gt;关注公众号「前端之神」，每天分享有用的前端知识技巧，进学习群，定时举行模拟面试直播，简历指导~&lt;/p&gt;&lt;/blockquote&gt;&lt;h2&gt;&lt;span&gt;前言&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;大家好，我是林三心，大家也知道，本菜鸟平时写基础文章比较多，我始终坚信两句话&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;用最通俗易懂的话，讲最难的知识点&lt;/strong&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;基础是进阶的前提&lt;/strong&gt; 其实Vue3已经出来很久了，可能大部分公司都用上了，但是，Vue3究竟比Vue2好在哪里？其实很多人都不知道。今天我就先给大家讲一讲&lt;code&gt;Vue3的响应式原理&lt;/code&gt;吧，顺便说一说&lt;code&gt;Vue3的响应式到底比Vue2的响应式好在哪&lt;/code&gt;。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2&gt;&lt;span&gt;好在哪？&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;好的，咱们先来讲讲为什么&lt;code&gt;Vue3的响应式 优于 Vue2响应式&lt;/code&gt;。可能平时问大家：请问你知道Vue的响应式是怎么实现的吗？大家都能粗略回答出来&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;Vue2的响应式是基于&lt;code&gt;Object.defineProperty&lt;/code&gt;实现的&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Vue3的响应式是基于ES6的&lt;code&gt;Proxy&lt;/code&gt;来实现的&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;是的，虽然上面的回答抽象了点，但是确实是回答出了Vue的两个版本的响应式的核心原理，并且Vue的两个版本响应式的好坏，也确实就是体现在&lt;code&gt;Object.defineProperty&lt;/code&gt;和&lt;code&gt;Proxy&lt;/code&gt;的差异上。&lt;/p&gt;&lt;h3&gt;Vue2&lt;/h3&gt;&lt;p&gt;大家都知道Vue2的响应式是基于&lt;code&gt;Object.defineProperty&lt;/code&gt;的，那我就拿&lt;code&gt;Object.defineProperty&lt;/code&gt;来举个例子&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;// 响应式函数&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;function&lt;/span&gt; &lt;span&gt;reactive&lt;/span&gt;(&lt;span&gt;obj, key, value&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;Object&lt;/span&gt;.defineProperty(data, key, {&lt;br/&gt;    &lt;span&gt;get&lt;/span&gt;() {&lt;br/&gt;      &lt;span&gt;console&lt;/span&gt;.log(&lt;span&gt;`访问了&lt;span&gt;${key}&lt;/span&gt;属性`&lt;/span&gt;)&lt;br/&gt;      &lt;span&gt;return&lt;/span&gt; value&lt;br/&gt;    },&lt;br/&gt;    &lt;span&gt;set&lt;/span&gt;(val) {&lt;br/&gt;      &lt;span&gt;console&lt;/span&gt;.log(&lt;span&gt;`将&lt;span&gt;${key}&lt;/span&gt;由-&amp;gt;&lt;span&gt;${value}&lt;/span&gt;-&amp;gt;设置成-&amp;gt;&lt;span&gt;${val}&lt;/span&gt;`&lt;/span&gt;)&lt;br/&gt;      &lt;span&gt;if&lt;/span&gt; (value !== val) {&lt;br/&gt;        value = val&lt;br/&gt;      }&lt;br/&gt;    }&lt;br/&gt;  })&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; data = {&lt;br/&gt;  &lt;span&gt;name&lt;/span&gt;: &lt;span&gt;&#x27;林三心&#x27;&lt;/span&gt;,&lt;br/&gt;  &lt;span&gt;age&lt;/span&gt;: &lt;span&gt;22&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;span&gt;Object&lt;/span&gt;.keys(data).forEach(&lt;span&gt;&lt;span&gt;key&lt;/span&gt; =&amp;gt;&lt;/span&gt; reactive(data, key, data[key]))&lt;br/&gt;&lt;span&gt;console&lt;/span&gt;.log(data.name)&lt;br/&gt;&lt;span&gt;// 访问了name属性&lt;/span&gt;&lt;br/&gt;&lt;span&gt;// 林三心&lt;/span&gt;&lt;br/&gt;data.name = &lt;span&gt;&#x27;sunshine_lin&#x27;&lt;/span&gt; &lt;span&gt;// 将name由-&amp;gt;林三心-&amp;gt;设置成-&amp;gt;sunshine_lin&lt;/span&gt;&lt;br/&gt;&lt;span&gt;console&lt;/span&gt;.log(data.name)&lt;br/&gt;&lt;span&gt;// 访问了name属性&lt;/span&gt;&lt;br/&gt;&lt;span&gt;// sunshine_lin&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;通过上面的例子，我想大家都对&lt;code&gt;Object.defineProperty&lt;/code&gt;有了一个了解，那问题来了？它到底有什么弊端呢？使得尤大大在Vue3中抛弃了它，咱们接着看：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;// 接着上面代码&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;data.hobby = &lt;span&gt;&#x27;打篮球&#x27;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;console&lt;/span&gt;.log(data.hobby) &lt;span&gt;// 打篮球&lt;/span&gt;&lt;br/&gt;data.hobby = &lt;span&gt;&#x27;打游戏&#x27;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;console&lt;/span&gt;.log(data.hobby) &lt;span&gt;// 打游戏&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这下大家可以看出&lt;code&gt;Object.defineProperty&lt;/code&gt;有什么弊端了吧？咱们可以看到，data新增了&lt;code&gt;hobby&lt;/code&gt;属性，进行访问和设值，但是都不会触发&lt;code&gt;get和set&lt;/code&gt;，所以弊端就是：&lt;code&gt;Object.defineProperty&lt;/code&gt;只对初始对象里的属性有监听作用，而对新增的属性无效。这也是为什么Vue2中对象新增属性的修改需要使用&lt;code&gt;Vue.$set&lt;/code&gt;来设值的原因。&lt;/p&gt;&lt;h3&gt;Vue3&lt;/h3&gt;&lt;p&gt;从上面，咱们知道了&lt;code&gt;Object.defineProperty&lt;/code&gt;的弊端，咱们接着讲Vue3中响应式原理的核心&lt;code&gt;Proxy&lt;/code&gt;是怎么弥补这一缺陷的，老样子，咱们还是举例子(先粗略讲，具体参数下面会细讲)：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;const&lt;/span&gt; data = {&lt;br/&gt;  &lt;span&gt;name&lt;/span&gt;: &lt;span&gt;&#x27;林三心&#x27;&lt;/span&gt;,&lt;br/&gt;  &lt;span&gt;age&lt;/span&gt;: &lt;span&gt;22&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;function&lt;/span&gt; &lt;span&gt;reactive&lt;/span&gt;(&lt;span&gt;target&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;const&lt;/span&gt; handler = {&lt;br/&gt;    &lt;span&gt;get&lt;/span&gt;(target, key, receiver) {&lt;br/&gt;      &lt;span&gt;console&lt;/span&gt;.log(&lt;span&gt;`访问了&lt;span&gt;${key}&lt;/span&gt;属性`&lt;/span&gt;)&lt;br/&gt;      &lt;span&gt;return&lt;/span&gt; &lt;span&gt;Reflect&lt;/span&gt;.get(target, key, receiver)&lt;br/&gt;    },&lt;br/&gt;    &lt;span&gt;set&lt;/span&gt;(target, key, value, receiver) {&lt;br/&gt;      &lt;span&gt;console&lt;/span&gt;.log(&lt;span&gt;`将&lt;span&gt;${key}&lt;/span&gt;由-&amp;gt;&lt;span&gt;${target[key]}&lt;/span&gt;-&amp;gt;设置成-&amp;gt;&lt;span&gt;${value}&lt;/span&gt;`&lt;/span&gt;)&lt;br/&gt;      &lt;span&gt;Reflect&lt;/span&gt;.set(target, key, value, receiver)&lt;br/&gt;    }&lt;br/&gt;  }&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; &lt;span&gt;Proxy&lt;/span&gt;(target, handler)&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; proxyData = reactive(data)&lt;br/&gt;&lt;br/&gt;&lt;span&gt;console&lt;/span&gt;.log(proxyData.name)&lt;br/&gt;&lt;span&gt;// 访问了name属性&lt;/span&gt;&lt;br/&gt;&lt;span&gt;// 林三心&lt;/span&gt;&lt;br/&gt;proxyData.name = &lt;span&gt;&#x27;sunshine_lin&#x27;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;// 将name由-&amp;gt;林三心-&amp;gt;设置成-&amp;gt;sunshine_lin&lt;/span&gt;&lt;br/&gt;&lt;span&gt;console&lt;/span&gt;.log(proxyData.name)&lt;br/&gt;&lt;span&gt;// 访问了name属性&lt;/span&gt;&lt;br/&gt;&lt;span&gt;// sunshine_lin&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;可以看到，其实效果与上面的&lt;code&gt;Object.defineProperty&lt;/code&gt;没什么差别，那为什么尤大大要抛弃它，选择&lt;code&gt;Proxy&lt;/code&gt;呢？注意了，最最最关键的来了，那就是对象新增属性，来看看效果吧：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;proxyData.hobby = &lt;span&gt;&#x27;打篮球&#x27;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;console&lt;/span&gt;.log(proxyData.hobby)&lt;br/&gt;&lt;span&gt;// 访问了hobby属性&lt;/span&gt;&lt;br/&gt;&lt;span&gt;// 打篮球&lt;/span&gt;&lt;br/&gt;proxyData.hobby = &lt;span&gt;&#x27;打游戏&#x27;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;// 将hobby由-&amp;gt;打篮球-&amp;gt;设置成-&amp;gt;打游戏&lt;/span&gt;&lt;br/&gt;&lt;span&gt;console&lt;/span&gt;.log(proxyData.hobby)&lt;br/&gt;&lt;span&gt;// 访问了hobby属性&lt;/span&gt;&lt;br/&gt;&lt;span&gt;// 打游戏&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;所以现在大家知道Vue3的响应式比Vue2好在哪了吧？&lt;/p&gt;&lt;figure&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5526315789473685&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/TZL4BdZpLdiaJFdBTFwdnAH2tYZIFZYSJGjJSHfBcl6CGXrReEZbSTo8dXxXo8lIHaobOIf4yQt8f9bcuIiaJ1Bw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;760&quot;/&gt;&lt;figcaption&gt;截屏2021-08-26 下午8.48.43.png&lt;/figcaption&gt;&lt;/figure&gt;&lt;h2&gt;&lt;span&gt;Vue3响应式原理&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;说完&lt;code&gt;Proxy&lt;/code&gt;的好处，咱们正式来讲讲Vue3的响应式原理的核心部分吧。&lt;/p&gt;&lt;h3&gt;前言&lt;/h3&gt;&lt;p&gt;先看看下面这段代码&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;let&lt;/span&gt; name = &lt;span&gt;&#x27;林三心&#x27;&lt;/span&gt;, age = &lt;span&gt;22&lt;/span&gt;, money = &lt;span&gt;20&lt;/span&gt;&lt;br/&gt;&lt;span&gt;let&lt;/span&gt; myself = &lt;span&gt;`&lt;span&gt;${name}&lt;/span&gt;今年&lt;span&gt;${age}&lt;/span&gt;岁，存款&lt;span&gt;${money}&lt;/span&gt;元`&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;console&lt;/span&gt;.log(myself) &lt;span&gt;// 林三心今年22岁，存款20元&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;money = &lt;span&gt;300&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// 预期：林三心今年22岁，存款300元&lt;/span&gt;&lt;br/&gt;&lt;span&gt;console&lt;/span&gt;.log(myself) &lt;span&gt;// 实际：林三心今年22岁，存款20元&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;大家想一下，我想要让&lt;code&gt;myself&lt;/code&gt;跟着&lt;code&gt;money&lt;/code&gt;变，怎么办才行？嘿嘿，其实，只要让&lt;code&gt;myself = &#x27;${name}今年${age}岁，存款${money}元&#x27;&lt;/code&gt;再执行一次就行，如下&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;let&lt;/span&gt; name = &lt;span&gt;&#x27;林三心&#x27;&lt;/span&gt;, age = &lt;span&gt;22&lt;/span&gt;, money = &lt;span&gt;20&lt;/span&gt;&lt;br/&gt;&lt;span&gt;let&lt;/span&gt; myself = &lt;span&gt;`&lt;span&gt;${name}&lt;/span&gt;今年&lt;span&gt;${age}&lt;/span&gt;岁，存款&lt;span&gt;${money}&lt;/span&gt;元`&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;console&lt;/span&gt;.log(myself) &lt;span&gt;// 林三心今年22岁，存款20元&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;money = &lt;span&gt;300&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;myself = &lt;span&gt;`&lt;span&gt;${name}&lt;/span&gt;今年&lt;span&gt;${age}&lt;/span&gt;岁，存款&lt;span&gt;${money}&lt;/span&gt;元`&lt;/span&gt; &lt;span&gt;// 再执行一次&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// 预期：林三心今年22岁，存款300元&lt;/span&gt;&lt;br/&gt;&lt;span&gt;console&lt;/span&gt;.log(myself) &lt;span&gt;// 实际：林三心今年22岁，存款300元&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3&gt;effect&lt;/h3&gt;&lt;p&gt;上面说了，每一次&lt;code&gt;money&lt;/code&gt;改变就得再执行一次&lt;code&gt;myself = &#x27;${name}今年${age}岁，存款${money}元&#x27;&lt;/code&gt;，才能使&lt;code&gt;myself&lt;/code&gt;更新，其实这么写不优雅，咱们可以封装一个&lt;code&gt;effect函数&lt;/code&gt;&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;let&lt;/span&gt; name = &lt;span&gt;&#x27;林三心&#x27;&lt;/span&gt;, age = &lt;span&gt;22&lt;/span&gt;, money = &lt;span&gt;20&lt;/span&gt;&lt;br/&gt;&lt;span&gt;let&lt;/span&gt; myself = &lt;span&gt;&#x27;&#x27;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; effect = &lt;span&gt;&lt;span&gt;()&lt;/span&gt; =&amp;gt;&lt;/span&gt; myself = &lt;span&gt;`&lt;span&gt;${name}&lt;/span&gt;今年&lt;span&gt;${age}&lt;/span&gt;岁，存款&lt;span&gt;${money}&lt;/span&gt;元`&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;effect() &lt;span&gt;// 先执行一次&lt;/span&gt;&lt;br/&gt;&lt;span&gt;console&lt;/span&gt;.log(myself) &lt;span&gt;// 林三心今年22岁，存款20元&lt;/span&gt;&lt;br/&gt;money = &lt;span&gt;300&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;effect() &lt;span&gt;// 再执行一次&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;console&lt;/span&gt;.log(myself) &lt;span&gt;// 林三心今年22岁，存款300元&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;其实这样也是有坏处的，不信你可以看看下面这种情况&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;let&lt;/span&gt; name = &lt;span&gt;&#x27;林三心&#x27;&lt;/span&gt;, age = &lt;span&gt;22&lt;/span&gt;, money = &lt;span&gt;20&lt;/span&gt;&lt;br/&gt;&lt;span&gt;let&lt;/span&gt; myself = &lt;span&gt;&#x27;&#x27;&lt;/span&gt;, ohtherMyself = &lt;span&gt;&#x27;&#x27;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; effect1 = &lt;span&gt;&lt;span&gt;()&lt;/span&gt; =&amp;gt;&lt;/span&gt; myself = &lt;span&gt;`&lt;span&gt;${name}&lt;/span&gt;今年&lt;span&gt;${age}&lt;/span&gt;岁，存款&lt;span&gt;${money}&lt;/span&gt;元`&lt;/span&gt;&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; effect2 = &lt;span&gt;&lt;span&gt;()&lt;/span&gt; =&amp;gt;&lt;/span&gt; ohtherMyself = &lt;span&gt;`&lt;span&gt;${age}&lt;/span&gt;岁的&lt;span&gt;${name}&lt;/span&gt;居然有&lt;span&gt;${money}&lt;/span&gt;元`&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;effect1() &lt;span&gt;// 先执行一次&lt;/span&gt;&lt;br/&gt;effect2() &lt;span&gt;// 先执行一次&lt;/span&gt;&lt;br/&gt;&lt;span&gt;console&lt;/span&gt;.log(myself) &lt;span&gt;// 林三心今年22岁，存款20元&lt;/span&gt;&lt;br/&gt;&lt;span&gt;console&lt;/span&gt;.log(ohtherMyself) &lt;span&gt;// 22岁的林三心居然有20元&lt;/span&gt;&lt;br/&gt;money = &lt;span&gt;300&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;effect1() &lt;span&gt;// 再执行一次&lt;/span&gt;&lt;br/&gt;effect2() &lt;span&gt;// 再执行一次&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;console&lt;/span&gt;.log(myself) &lt;span&gt;// 林三心今年22岁，存款300元&lt;/span&gt;&lt;br/&gt;&lt;span&gt;console&lt;/span&gt;.log(ohtherMyself) &lt;span&gt;// 22岁的林三心居然有300元&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;增加了一个&lt;code&gt;ohtherMyself&lt;/code&gt;，就得再写一个&lt;code&gt;effect&lt;/code&gt;，然后每次更新都执行一次，那如果增加数量变多了，那岂不是每次都要写好多好多的&lt;code&gt;effect函数&lt;/code&gt;执行代码？&lt;/p&gt;&lt;h3&gt;track和trigger&lt;/h3&gt;&lt;p&gt;针对上面的问题，咱们可以这样解决：用&lt;code&gt;track函数&lt;/code&gt;把所有依赖于&lt;code&gt;money变量&lt;/code&gt;的&lt;code&gt;effect函数&lt;/code&gt;都收集起来，放在&lt;code&gt;dep&lt;/code&gt;里，&lt;code&gt;dep&lt;/code&gt;为什么用&lt;code&gt;Set&lt;/code&gt;呢？因为&lt;code&gt;Set&lt;/code&gt;可以自动去重。搜集起来之后，以后只要&lt;code&gt;money变量&lt;/code&gt;一改变，就执行&lt;code&gt;trigger函数&lt;/code&gt;通知&lt;code&gt;dep&lt;/code&gt;里所有依赖&lt;code&gt;money变量&lt;/code&gt;的&lt;code&gt;effect函数&lt;/code&gt;执行，实现依赖变量的更新。先来看看代码吧，然后我再通过一张图给大家展示一下，怕大家头晕哈哈。&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;let&lt;/span&gt; name = &lt;span&gt;&#x27;林三心&#x27;&lt;/span&gt;, age = &lt;span&gt;22&lt;/span&gt;, money = &lt;span&gt;20&lt;/span&gt;&lt;br/&gt;&lt;span&gt;let&lt;/span&gt; myself = &lt;span&gt;&#x27;&#x27;&lt;/span&gt;, ohtherMyself = &lt;span&gt;&#x27;&#x27;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; effect1 = &lt;span&gt;&lt;span&gt;()&lt;/span&gt; =&amp;gt;&lt;/span&gt; myself = &lt;span&gt;`&lt;span&gt;${name}&lt;/span&gt;今年&lt;span&gt;${age}&lt;/span&gt;岁，存款&lt;span&gt;${money}&lt;/span&gt;元`&lt;/span&gt;&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; effect2 = &lt;span&gt;&lt;span&gt;()&lt;/span&gt; =&amp;gt;&lt;/span&gt; ohtherMyself = &lt;span&gt;`&lt;span&gt;${age}&lt;/span&gt;岁的&lt;span&gt;${name}&lt;/span&gt;居然有&lt;span&gt;${money}&lt;/span&gt;元`&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; dep = &lt;span&gt;new&lt;/span&gt; &lt;span&gt;Set&lt;/span&gt;()&lt;br/&gt;&lt;span&gt;&lt;span&gt;function&lt;/span&gt; &lt;span&gt;track&lt;/span&gt; (&lt;span/&gt;) &lt;/span&gt;{&lt;br/&gt;    dep.add(effect1)&lt;br/&gt;    dep.add(effect2)&lt;br/&gt;}&lt;br/&gt;&lt;span&gt;&lt;span&gt;function&lt;/span&gt; &lt;span&gt;trigger&lt;/span&gt;(&lt;span/&gt;) &lt;/span&gt;{&lt;br/&gt;    dep.forEach(&lt;span&gt;&lt;span&gt;effect&lt;/span&gt; =&amp;gt;&lt;/span&gt; effect())&lt;br/&gt;}&lt;br/&gt;track() &lt;span&gt;//收集依赖&lt;/span&gt;&lt;br/&gt;effect1() &lt;span&gt;// 先执行一次&lt;/span&gt;&lt;br/&gt;effect2() &lt;span&gt;// 先执行一次&lt;/span&gt;&lt;br/&gt;&lt;span&gt;console&lt;/span&gt;.log(myself) &lt;span&gt;// 林三心今年22岁，存款20元&lt;/span&gt;&lt;br/&gt;&lt;span&gt;console&lt;/span&gt;.log(ohtherMyself) &lt;span&gt;// 22岁的林三心居然有20元&lt;/span&gt;&lt;br/&gt;money = &lt;span&gt;300&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;trigger() &lt;span&gt;// 通知变量myself和otherMyself进行更新&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;console&lt;/span&gt;.log(myself) &lt;span&gt;// 林三心今年22岁，存款300元&lt;/span&gt;&lt;br/&gt;&lt;span&gt;console&lt;/span&gt;.log(ohtherMyself) &lt;span&gt;// 22岁的林三心居然有300元&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;figure&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6429433051869723&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/TZL4BdZpLdiaJFdBTFwdnAH2tYZIFZYSJhN2dvekfUtVs1OUz85ysIFCsib9TeB780ekaNxM6Dj8Ev6hINQtYepg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;829&quot;/&gt;&lt;figcaption&gt;截屏2021-08-26 下午10.43.12.png&lt;/figcaption&gt;&lt;/figure&gt;&lt;h3&gt;对象呢？&lt;/h3&gt;&lt;p&gt;上面都是讲基础数据类型的，那咱们来讲讲&lt;code&gt;对象&lt;/code&gt;吧，我先举个例子，用最原始的方式去实现他的响应&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;const&lt;/span&gt; person = { &lt;span&gt;name&lt;/span&gt;: &lt;span&gt;&#x27;林三心&#x27;&lt;/span&gt;, &lt;span&gt;age&lt;/span&gt;: &lt;span&gt;22&lt;/span&gt; }&lt;br/&gt;&lt;span&gt;let&lt;/span&gt; nameStr1 = &lt;span&gt;&#x27;&#x27;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;let&lt;/span&gt; nameStr2 = &lt;span&gt;&#x27;&#x27;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;let&lt;/span&gt; ageStr1 = &lt;span&gt;&#x27;&#x27;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;let&lt;/span&gt; ageStr2 = &lt;span&gt;&#x27;&#x27;&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; effectNameStr1 = &lt;span&gt;&lt;span&gt;()&lt;/span&gt; =&amp;gt;&lt;/span&gt; { nameStr1 = &lt;span&gt;`&lt;span&gt;${person.name}&lt;/span&gt;是个大菜鸟`&lt;/span&gt; }&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; effectNameStr2 = &lt;span&gt;&lt;span&gt;()&lt;/span&gt; =&amp;gt;&lt;/span&gt; { nameStr2 = &lt;span&gt;`&lt;span&gt;${person.name}&lt;/span&gt;是个小天才`&lt;/span&gt; }&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; effectAgeStr1 = &lt;span&gt;&lt;span&gt;()&lt;/span&gt; =&amp;gt;&lt;/span&gt; { ageStr1 = &lt;span&gt;`&lt;span&gt;${person.age}&lt;/span&gt;岁已经算很老了`&lt;/span&gt; }&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; effectAgeStr2 = &lt;span&gt;&lt;span&gt;()&lt;/span&gt; =&amp;gt;&lt;/span&gt; { ageStr2 = &lt;span&gt;`&lt;span&gt;${person.age}&lt;/span&gt;岁还算很年轻啊`&lt;/span&gt; }&lt;br/&gt;&lt;br/&gt;effectNameStr1()&lt;br/&gt;effectNameStr2()&lt;br/&gt;effectAgeStr1()&lt;br/&gt;effectAgeStr2()&lt;br/&gt;&lt;span&gt;console&lt;/span&gt;.log(nameStr1, nameStr2, ageStr1, ageStr2)&lt;br/&gt;&lt;span&gt;// 林三心是个大菜鸟 林三心是个小天才 22岁已经算很老了 22岁还算很年轻啊&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;person.name = &lt;span&gt;&#x27;sunshine_lin&#x27;&lt;/span&gt;&lt;br/&gt;person.age = &lt;span&gt;18&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;effectNameStr1()&lt;br/&gt;effectNameStr2()&lt;br/&gt;effectAgeStr1()&lt;br/&gt;effectAgeStr2()&lt;br/&gt;&lt;br/&gt;&lt;span&gt;console&lt;/span&gt;.log(nameStr1, nameStr2, ageStr1, ageStr2)&lt;br/&gt;&lt;span&gt;// sunshine_lin是个大菜鸟 sunshine_lin是个小天才 18岁已经算很老了 18岁还算很年轻啊&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;上面的代码，咱们也看出来了，感觉写的很无脑。。还记得前面讲的&lt;code&gt;dep&lt;/code&gt;收集&lt;code&gt;effect&lt;/code&gt;吗？咱们暂且把person对象里的name和age看成两个变量，他们都有各自的&lt;code&gt;依赖变量&lt;/code&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;name：nameStr1和nameStr2&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;age：ageStr1和ageStr2 所以&lt;code&gt;name和age&lt;/code&gt;应该拥有自己的&lt;code&gt;dep&lt;/code&gt;，并收集各自依赖变量所对应的&lt;code&gt;effect&lt;/code&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;figure&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.4677871148459384&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/TZL4BdZpLdiaJFdBTFwdnAH2tYZIFZYSJu5p7YaFPwbibsZUBDUyFAUZNGmOj92eAibKDibkKNhgZGzqDPu6thBSug/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;714&quot;/&gt;&lt;figcaption&gt;截屏2021-08-26 下午11.11.04.png&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;前面说了&lt;code&gt;dep&lt;/code&gt;是使用&lt;code&gt;Set&lt;/code&gt;，由于person拥有&lt;code&gt;age和name&lt;/code&gt;两个属性，所以拥有&lt;code&gt;两个dep&lt;/code&gt;，那用什么来储存这两个dep呢？咱们可以用ES6的另一个数据结构&lt;code&gt;Map&lt;/code&gt;来储存&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;const&lt;/span&gt; person = { &lt;span&gt;name&lt;/span&gt;: &lt;span&gt;&#x27;林三心&#x27;&lt;/span&gt;, &lt;span&gt;age&lt;/span&gt;: &lt;span&gt;22&lt;/span&gt; }&lt;br/&gt;&lt;span&gt;let&lt;/span&gt; nameStr1 = &lt;span&gt;&#x27;&#x27;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;let&lt;/span&gt; nameStr2 = &lt;span&gt;&#x27;&#x27;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;let&lt;/span&gt; ageStr1 = &lt;span&gt;&#x27;&#x27;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;let&lt;/span&gt; ageStr2 = &lt;span&gt;&#x27;&#x27;&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; effectNameStr1 = &lt;span&gt;&lt;span&gt;()&lt;/span&gt; =&amp;gt;&lt;/span&gt; { nameStr1 = &lt;span&gt;`&lt;span&gt;${person.name}&lt;/span&gt;是个大菜鸟`&lt;/span&gt; }&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; effectNameStr2 = &lt;span&gt;&lt;span&gt;()&lt;/span&gt; =&amp;gt;&lt;/span&gt; { nameStr2 = &lt;span&gt;`&lt;span&gt;${person.name}&lt;/span&gt;是个小天才`&lt;/span&gt; }&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; effectAgeStr1 = &lt;span&gt;&lt;span&gt;()&lt;/span&gt; =&amp;gt;&lt;/span&gt; { ageStr1 = &lt;span&gt;`&lt;span&gt;${person.age}&lt;/span&gt;岁已经算很老了`&lt;/span&gt; }&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; effectAgeStr2 = &lt;span&gt;&lt;span&gt;()&lt;/span&gt; =&amp;gt;&lt;/span&gt; { ageStr2 = &lt;span&gt;`&lt;span&gt;${person.age}&lt;/span&gt;岁还算很年轻啊`&lt;/span&gt; }&lt;br/&gt;&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; depsMap = &lt;span&gt;new&lt;/span&gt; &lt;span&gt;Map&lt;/span&gt;()&lt;br/&gt;&lt;span&gt;&lt;span&gt;function&lt;/span&gt; &lt;span&gt;track&lt;/span&gt;(&lt;span&gt;key&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;let&lt;/span&gt; dep = depsMap.get(key)&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (!dep) {&lt;br/&gt;        depsMap.set(key, dep = &lt;span&gt;new&lt;/span&gt; &lt;span&gt;Set&lt;/span&gt;())&lt;br/&gt;    }&lt;br/&gt;    &lt;span&gt;// 这里先暂且写死&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (key === &lt;span&gt;&#x27;name&#x27;&lt;/span&gt;) {&lt;br/&gt;        dep.add(effectNameStr1)&lt;br/&gt;        dep.add(effectNameStr2)&lt;br/&gt;    } &lt;span&gt;else&lt;/span&gt; {&lt;br/&gt;        dep.add(effectAgeStr1)&lt;br/&gt;        dep.add(effectAgeStr2)&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;span&gt;&lt;span&gt;function&lt;/span&gt; &lt;span&gt;trigger&lt;/span&gt; (&lt;span&gt;key&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;const&lt;/span&gt; dep = depsMap.get(key)&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (dep) {&lt;br/&gt;        dep.forEach(&lt;span&gt;&lt;span&gt;effect&lt;/span&gt; =&amp;gt;&lt;/span&gt; effect())&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;track(&lt;span&gt;&#x27;name&#x27;&lt;/span&gt;) &lt;span&gt;// 收集person.name的依赖&lt;/span&gt;&lt;br/&gt;track(&lt;span&gt;&#x27;age&#x27;&lt;/span&gt;) &lt;span&gt;// 收集person.age的依赖&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;br/&gt;&lt;br/&gt;effectNameStr1()&lt;br/&gt;effectNameStr2()&lt;br/&gt;effectAgeStr1()&lt;br/&gt;effectAgeStr2()&lt;br/&gt;&lt;span&gt;console&lt;/span&gt;.log(nameStr1, nameStr2, ageStr1, ageStr2)&lt;br/&gt;&lt;span&gt;// 林三心是个大菜鸟 林三心是个小天才 22岁已经算很老了 22岁还算很年轻啊&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;person.name = &lt;span&gt;&#x27;sunshine_lin&#x27;&lt;/span&gt;&lt;br/&gt;person.age = &lt;span&gt;18&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;trigger(&lt;span&gt;&#x27;name&#x27;&lt;/span&gt;) &lt;span&gt;// 通知person.name的依赖变量更新&lt;/span&gt;&lt;br/&gt;trigger(&lt;span&gt;&#x27;age&#x27;&lt;/span&gt;) &lt;span&gt;// 通知person.age的依赖变量更新&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;console&lt;/span&gt;.log(nameStr1, nameStr2, ageStr1, ageStr2)&lt;br/&gt;&lt;span&gt;// sunshine_lin是个大菜鸟 sunshine_lin是个小天才 18岁已经算很老了 18岁还算很年轻啊&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;上面咱们是只有一个person对象，那如果有多个对象呢？怎么办？我们都知道，每个对象会建立一个&lt;code&gt;Map&lt;/code&gt;来存储此对象里属性的&lt;code&gt;dep(使用Set来存储)&lt;/code&gt;，那如果有多个对象，该用什么来存储每个对象对应的&lt;code&gt;Map&lt;/code&gt;呢？请看下图&lt;/p&gt;&lt;figure&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.7035460992907802&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/TZL4BdZpLdiaJFdBTFwdnAH2tYZIFZYSJ4AFyCPWJayrDSSt7SxSC6JHQU83dm1qD1d4ngxicxMvSlibHAib5dsTnw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;705&quot;/&gt;&lt;figcaption&gt;截屏2021-08-27 下午8.01.20.png&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;其实ES6还有一个新的数据结构，叫做&lt;code&gt;WeakMap&lt;/code&gt;的，咱们就用它来存储这些对象的&lt;code&gt;Map&lt;/code&gt;吧。所以咱们得对&lt;code&gt;track函数&lt;/code&gt;和&lt;code&gt;trigger函数&lt;/code&gt;进行改造，先看看之前他们长啥样&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;const&lt;/span&gt; depsMap = &lt;span&gt;new&lt;/span&gt; &lt;span&gt;Map&lt;/span&gt;()&lt;br/&gt;&lt;span&gt;&lt;span&gt;function&lt;/span&gt; &lt;span&gt;track&lt;/span&gt;(&lt;span&gt;key&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;let&lt;/span&gt; dep = depsMap.get(key)&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (!dep) {&lt;br/&gt;        depsMap.set(key, dep = &lt;span&gt;new&lt;/span&gt; &lt;span&gt;Set&lt;/span&gt;())&lt;br/&gt;    }&lt;br/&gt;    &lt;span&gt;// 这里先暂且写死&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (key === &lt;span&gt;&#x27;name&#x27;&lt;/span&gt;) {&lt;br/&gt;        dep.add(effectNameStr1)&lt;br/&gt;        dep.add(effectNameStr2)&lt;br/&gt;    } &lt;span&gt;else&lt;/span&gt; {&lt;br/&gt;        dep.add(effectAgeStr1)&lt;br/&gt;        dep.add(effectAgeStr2)&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;span&gt;&lt;span&gt;function&lt;/span&gt; &lt;span&gt;trigger&lt;/span&gt; (&lt;span&gt;key&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;const&lt;/span&gt; dep = depsMap.get(key)&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (dep) {&lt;br/&gt;        dep.forEach(&lt;span&gt;&lt;span&gt;effect&lt;/span&gt; =&amp;gt;&lt;/span&gt; effect())&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;之前的代码只做了单个对象的处理方案，但是现在如果要多个对象，那就得使用&lt;code&gt;WeakMap&lt;/code&gt;进行改造了(接下来代码可能有点啰嗦，但都会为了照顾基础薄弱的同学)&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;const&lt;/span&gt; person = { &lt;span&gt;name&lt;/span&gt;: &lt;span&gt;&#x27;林三心&#x27;&lt;/span&gt;, &lt;span&gt;age&lt;/span&gt;: &lt;span&gt;22&lt;/span&gt; }&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; animal = { &lt;span&gt;type&lt;/span&gt;: &lt;span&gt;&#x27;dog&#x27;&lt;/span&gt;, &lt;span&gt;height&lt;/span&gt;: &lt;span&gt;50&lt;/span&gt; }&lt;br/&gt;&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; targetMap = &lt;span&gt;new&lt;/span&gt; &lt;span&gt;WeakMap&lt;/span&gt;()&lt;br/&gt;&lt;span&gt;&lt;span&gt;function&lt;/span&gt; &lt;span&gt;track&lt;/span&gt;(&lt;span&gt;target, key&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;let&lt;/span&gt; depsMap = targetMap.get(target)&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (!depsMap) {&lt;br/&gt;        targetMap.set(target, depsMap = &lt;span&gt;new&lt;/span&gt; &lt;span&gt;Map&lt;/span&gt;())&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;let&lt;/span&gt; dep = depsMap.get(key)&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (!dep) {&lt;br/&gt;        depsMap.set(key, dep = &lt;span&gt;new&lt;/span&gt; &lt;span&gt;Set&lt;/span&gt;())&lt;br/&gt;    }&lt;br/&gt;    &lt;span&gt;// 这里先暂且写死&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (target === person) {&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (key === &lt;span&gt;&#x27;name&#x27;&lt;/span&gt;) {&lt;br/&gt;            dep.add(effectNameStr1)&lt;br/&gt;            dep.add(effectNameStr2)&lt;br/&gt;        } &lt;span&gt;else&lt;/span&gt; {&lt;br/&gt;            dep.add(effectAgeStr1)&lt;br/&gt;            dep.add(effectAgeStr2)&lt;br/&gt;        }&lt;br/&gt;    } &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (target === animal) {&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (key === &lt;span&gt;&#x27;type&#x27;&lt;/span&gt;) {&lt;br/&gt;            dep.add(effectTypeStr1)&lt;br/&gt;            dep.add(effectTypeStr2)&lt;br/&gt;        } &lt;span&gt;else&lt;/span&gt; {&lt;br/&gt;            dep.add(effectHeightStr1)&lt;br/&gt;            dep.add(effectHeightStr2)&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;function&lt;/span&gt; &lt;span&gt;trigger&lt;/span&gt;(&lt;span&gt;target, key&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;let&lt;/span&gt; depsMap = targetMap.get(target)&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (depsMap) {&lt;br/&gt;        &lt;span&gt;const&lt;/span&gt; dep = depsMap.get(key)&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (dep) {&lt;br/&gt;            dep.forEach(&lt;span&gt;&lt;span&gt;effect&lt;/span&gt; =&amp;gt;&lt;/span&gt; effect())&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;经过了上面的改造，咱们终于实现了多对象的依赖收集，咱们来试一试吧&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;const&lt;/span&gt; person = { &lt;span&gt;name&lt;/span&gt;: &lt;span&gt;&#x27;林三心&#x27;&lt;/span&gt;, &lt;span&gt;age&lt;/span&gt;: &lt;span&gt;22&lt;/span&gt; }&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; animal = { &lt;span&gt;type&lt;/span&gt;: &lt;span&gt;&#x27;dog&#x27;&lt;/span&gt;, &lt;span&gt;height&lt;/span&gt;: &lt;span&gt;50&lt;/span&gt; }&lt;br/&gt;&lt;span&gt;let&lt;/span&gt; nameStr1 = &lt;span&gt;&#x27;&#x27;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;let&lt;/span&gt; nameStr2 = &lt;span&gt;&#x27;&#x27;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;let&lt;/span&gt; ageStr1 = &lt;span&gt;&#x27;&#x27;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;let&lt;/span&gt; ageStr2 = &lt;span&gt;&#x27;&#x27;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;let&lt;/span&gt; typeStr1 = &lt;span&gt;&#x27;&#x27;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;let&lt;/span&gt; typeStr2 = &lt;span&gt;&#x27;&#x27;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;let&lt;/span&gt; heightStr1 = &lt;span&gt;&#x27;&#x27;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;let&lt;/span&gt; heightStr2 = &lt;span&gt;&#x27;&#x27;&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; effectNameStr1 = &lt;span&gt;&lt;span&gt;()&lt;/span&gt; =&amp;gt;&lt;/span&gt; { nameStr1 = &lt;span&gt;`&lt;span&gt;${person.name}&lt;/span&gt;是个大菜鸟`&lt;/span&gt; }&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; effectNameStr2 = &lt;span&gt;&lt;span&gt;()&lt;/span&gt; =&amp;gt;&lt;/span&gt; { nameStr2 = &lt;span&gt;`&lt;span&gt;${person.name}&lt;/span&gt;是个小天才`&lt;/span&gt; }&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; effectAgeStr1 = &lt;span&gt;&lt;span&gt;()&lt;/span&gt; =&amp;gt;&lt;/span&gt; { ageStr1 = &lt;span&gt;`&lt;span&gt;${person.age}&lt;/span&gt;岁已经算很老了`&lt;/span&gt; }&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; effectAgeStr2 = &lt;span&gt;&lt;span&gt;()&lt;/span&gt; =&amp;gt;&lt;/span&gt; { ageStr2 = &lt;span&gt;`&lt;span&gt;${person.age}&lt;/span&gt;岁还算很年轻啊`&lt;/span&gt; }&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; effectTypeStr1 = &lt;span&gt;&lt;span&gt;()&lt;/span&gt; =&amp;gt;&lt;/span&gt; { typeStr1 = &lt;span&gt;`&lt;span&gt;${animal.type}&lt;/span&gt;是个大菜鸟`&lt;/span&gt; }&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; effectTypeStr2 = &lt;span&gt;&lt;span&gt;()&lt;/span&gt; =&amp;gt;&lt;/span&gt; { typeStr2 = &lt;span&gt;`&lt;span&gt;${animal.type}&lt;/span&gt;是个小天才`&lt;/span&gt; }&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; effectHeightStr1 = &lt;span&gt;&lt;span&gt;()&lt;/span&gt; =&amp;gt;&lt;/span&gt; { heightStr1 = &lt;span&gt;`&lt;span&gt;${animal.height}&lt;/span&gt;已经算很高了`&lt;/span&gt; }&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; effectHeightStr2 = &lt;span&gt;&lt;span&gt;()&lt;/span&gt; =&amp;gt;&lt;/span&gt; { heightStr2 = &lt;span&gt;`&lt;span&gt;${animal.height}&lt;/span&gt;还算很矮啊`&lt;/span&gt; }&lt;br/&gt;&lt;br/&gt;track(person, &lt;span&gt;&#x27;name&#x27;&lt;/span&gt;) &lt;span&gt;// 收集person.name的依赖&lt;/span&gt;&lt;br/&gt;track(person, &lt;span&gt;&#x27;age&#x27;&lt;/span&gt;) &lt;span&gt;// 收集person.age的依赖&lt;/span&gt;&lt;br/&gt;track(animal, &lt;span&gt;&#x27;type&#x27;&lt;/span&gt;) &lt;span&gt;// animal.type的依赖&lt;/span&gt;&lt;br/&gt;track(animal, &lt;span&gt;&#x27;height&#x27;&lt;/span&gt;) &lt;span&gt;// 收集animal.height的依赖&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;br/&gt;&lt;br/&gt;effectNameStr1()&lt;br/&gt;effectNameStr2()&lt;br/&gt;effectAgeStr1()&lt;br/&gt;effectAgeStr2()&lt;br/&gt;effectTypeStr1()&lt;br/&gt;effectTypeStr2()&lt;br/&gt;effectHeightStr1()&lt;br/&gt;effectHeightStr2()&lt;br/&gt;&lt;br/&gt;&lt;span&gt;console&lt;/span&gt;.log(nameStr1, nameStr2, ageStr1, ageStr2)&lt;br/&gt;&lt;span&gt;// 林三心是个大菜鸟 林三心是个小天才 22岁已经算很老了 22岁还算很年轻啊&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;console&lt;/span&gt;.log(typeStr1, typeStr2, heightStr1, heightStr2)&lt;br/&gt;&lt;span&gt;// dog是个大菜鸟 dog是个小天才 50已经算很高了 50还算很矮啊&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;person.name = &lt;span&gt;&#x27;sunshine_lin&#x27;&lt;/span&gt;&lt;br/&gt;person.age = &lt;span&gt;18&lt;/span&gt;&lt;br/&gt;animal.type = &lt;span&gt;&#x27;猫&#x27;&lt;/span&gt;&lt;br/&gt;animal.height = &lt;span&gt;20&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;trigger(person, &lt;span&gt;&#x27;name&#x27;&lt;/span&gt;)&lt;br/&gt;trigger(person, &lt;span&gt;&#x27;age&#x27;&lt;/span&gt;)&lt;br/&gt;trigger(animal, &lt;span&gt;&#x27;type&#x27;&lt;/span&gt;)&lt;br/&gt;trigger(animal, &lt;span&gt;&#x27;height&#x27;&lt;/span&gt;)&lt;br/&gt;&lt;br/&gt;&lt;span&gt;console&lt;/span&gt;.log(nameStr1, nameStr2, ageStr1, ageStr2)&lt;br/&gt;&lt;span&gt;// sunshine_lin是个大菜鸟 sunshine_lin是个小天才 18岁已经算很老了 18岁还算很年轻啊&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;console&lt;/span&gt;.log(typeStr1, typeStr2, heightStr1, heightStr2)&lt;br/&gt;&lt;span&gt;// 猫是个大菜鸟 猫是个小天才 20已经算很高了 20还算很矮啊&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3&gt;Proxy&lt;/h3&gt;&lt;p&gt;通过上面的学习，我们已经可以实现当数据更新时，他的依赖变量也跟着改变，但是还是有缺点的，大家可以发现，每次我们总是得自己手动去执行&lt;code&gt;track函数&lt;/code&gt;进行依赖收集，并且当数据改变时，我么又得手动执行&lt;code&gt;trigger函数&lt;/code&gt;去进行通知更新&lt;/p&gt;&lt;p&gt;那么，到底有没有办法可以实现，自动收集依赖，以及自动通知更新呢？答案是有的，&lt;code&gt;Proxy&lt;/code&gt;可以为我们解决这个难题。咱们先写一个&lt;code&gt;reactive函数&lt;/code&gt;，大家先照敲，理解好&lt;code&gt;Proxy-track-trigger&lt;/code&gt;这三者的关系，后面我会讲为什么这里&lt;code&gt;Proxy&lt;/code&gt;需要搭配&lt;code&gt;Reflect&lt;/code&gt;&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;function&lt;/span&gt; &lt;span&gt;reactive&lt;/span&gt;(&lt;span&gt;target&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;const&lt;/span&gt; handler = {&lt;br/&gt;        &lt;span&gt;get&lt;/span&gt;(target, key, receiver) {&lt;br/&gt;            track(receiver, key) &lt;span&gt;// 访问时收集依赖&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;return&lt;/span&gt; &lt;span&gt;Reflect&lt;/span&gt;.get(target, key, receiver)&lt;br/&gt;        },&lt;br/&gt;        &lt;span&gt;set&lt;/span&gt;(target, key, value, receiver) {&lt;br/&gt;            &lt;span&gt;Reflect&lt;/span&gt;.set(target, key, value, receiver)&lt;br/&gt;            trigger(receiver, key) &lt;span&gt;// 设值时自动通知更新&lt;/span&gt;&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; &lt;span&gt;Proxy&lt;/span&gt;(target, handler)&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;然后改一改之前的代码，把&lt;code&gt;手动track&lt;/code&gt;和&lt;code&gt;手动trigger&lt;/code&gt;去掉，发现也能实现之前的效果&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;const&lt;/span&gt; person = reactive({ &lt;span&gt;name&lt;/span&gt;: &lt;span&gt;&#x27;林三心&#x27;&lt;/span&gt;, &lt;span&gt;age&lt;/span&gt;: &lt;span&gt;22&lt;/span&gt; }) &lt;span&gt;// 传入reactive&lt;/span&gt;&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; animal = reactive({ &lt;span&gt;type&lt;/span&gt;: &lt;span&gt;&#x27;dog&#x27;&lt;/span&gt;, &lt;span&gt;height&lt;/span&gt;: &lt;span&gt;50&lt;/span&gt; }) &lt;span&gt;// 传入reactive&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;effectNameStr1()&lt;br/&gt;effectNameStr2()&lt;br/&gt;effectAgeStr1()&lt;br/&gt;effectAgeStr2()&lt;br/&gt;effectTypeStr1()&lt;br/&gt;effectTypeStr2()&lt;br/&gt;effectHeightStr1()&lt;br/&gt;effectHeightStr2()&lt;br/&gt;&lt;br/&gt;&lt;span&gt;console&lt;/span&gt;.log(nameStr1, nameStr2, ageStr1, ageStr2)&lt;br/&gt;&lt;span&gt;// 林三心是个大菜鸟 林三心是个小天才 22岁已经算很老了 22岁还算很年轻啊&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;console&lt;/span&gt;.log(typeStr1, typeStr2, heightStr1, heightStr2)&lt;br/&gt;&lt;span&gt;// dog是个大菜鸟 dog是个小天才 50已经算很高了 50还算很矮啊&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;person.name = &lt;span&gt;&#x27;sunshine_lin&#x27;&lt;/span&gt;&lt;br/&gt;person.age = &lt;span&gt;18&lt;/span&gt;&lt;br/&gt;animal.type = &lt;span&gt;&#x27;猫&#x27;&lt;/span&gt;&lt;br/&gt;animal.height = &lt;span&gt;20&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;console&lt;/span&gt;.log(nameStr1, nameStr2, ageStr1, ageStr2)&lt;br/&gt;&lt;span&gt;// sunshine_lin是个大菜鸟 sunshine_lin是个小天才 18岁已经算很老了 18岁还算很年轻啊&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;console&lt;/span&gt;.log(typeStr1, typeStr2, heightStr1, heightStr2)&lt;br/&gt;&lt;span&gt;// 猫是个大菜鸟 猫是个小天才 20已经算很高了 20还算很矮啊&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;可能有的同学会有点懵逼，对上面的代码有点疑惑，也可能有点绕，我还以为通过一张图给大家讲解一下流程，图可能会被压缩，建议点开看看&lt;/p&gt;&lt;figure&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6236203090507726&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/TZL4BdZpLdiaJFdBTFwdnAH2tYZIFZYSJxFf2wN7hlAx60wAOx2YaDWkvdLSO6VibNLQf7y91s6ZaAyPlmVbJfiaw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;906&quot;/&gt;&lt;figcaption&gt;截屏2021-08-27 下午9.13.55.png&lt;/figcaption&gt;&lt;/figure&gt;&lt;h3&gt;解决写死问题&lt;/h3&gt;&lt;p&gt;在上面有一处地方，咱们是写死的，大家都还记得吗，就是在&lt;code&gt;track函数&lt;/code&gt;中&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;function&lt;/span&gt; &lt;span&gt;track&lt;/span&gt;(&lt;span&gt;target, key&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;let&lt;/span&gt; depsMap = targetMap.get(target)&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (!depsMap) {&lt;br/&gt;        targetMap.set(target, depsMap = &lt;span&gt;new&lt;/span&gt; &lt;span&gt;Map&lt;/span&gt;())&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;let&lt;/span&gt; dep = depsMap.get(key)&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (!dep) {&lt;br/&gt;        depsMap.set(key, dep = &lt;span&gt;new&lt;/span&gt; &lt;span&gt;Set&lt;/span&gt;())&lt;br/&gt;    }&lt;br/&gt;    &lt;span&gt;// 这里先暂且写死&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (target === person) {&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (key === &lt;span&gt;&#x27;name&#x27;&lt;/span&gt;) {&lt;br/&gt;            dep.add(effectNameStr1)&lt;br/&gt;            dep.add(effectNameStr2)&lt;br/&gt;        } &lt;span&gt;else&lt;/span&gt; {&lt;br/&gt;            dep.add(effectAgeStr1)&lt;br/&gt;            dep.add(effectAgeStr2)&lt;br/&gt;        }&lt;br/&gt;    } &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (target === animal) {&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (key === &lt;span&gt;&#x27;type&#x27;&lt;/span&gt;) {&lt;br/&gt;            dep.add(effectTypeStr1)&lt;br/&gt;            dep.add(effectTypeStr2)&lt;br/&gt;        } &lt;span&gt;else&lt;/span&gt; {&lt;br/&gt;            dep.add(effectHeightStr1)&lt;br/&gt;            dep.add(effectHeightStr2)&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;实际开发中，肯定是不止两个对象的，如果每多加一个对象，就得多加一个&lt;code&gt;else if&lt;/code&gt;判断，那是万万不行的。那我们要怎么解决这个问题呢？其实说难也不难，Vue3的作者们想出了一个非常巧妙的办法，使用一个全局变量&lt;code&gt;activeEffect&lt;/code&gt;来巧妙解决这个问题，具体是怎么解决呢？其实很简单，就是每一个&lt;code&gt;effect函数&lt;/code&gt;一执行，就把自身放到对应的&lt;code&gt;dep&lt;/code&gt;里，这就可以不需要写死了。&lt;/p&gt;&lt;figure&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6722054380664653&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/TZL4BdZpLdiaJFdBTFwdnAH2tYZIFZYSJxosGAia0Snrl0BxcwQgQA060jmw2xm8iaLKn70QJbQd4plHbamfZnFlA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;662&quot;/&gt;&lt;figcaption&gt;截屏2021-08-27 下午9.31.37.png&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;我们怎么才能实现这个功能呢？我们需要改装一下&lt;code&gt;effect函数&lt;/code&gt;才行，并且要修改&lt;code&gt;track函数&lt;/code&gt;&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;let&lt;/span&gt; activeEffect = &lt;span&gt;null&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;function&lt;/span&gt; &lt;span&gt;effect&lt;/span&gt;(&lt;span&gt;fn&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;    activeEffect = fn&lt;br/&gt;    activeEffect()&lt;br/&gt;    activeEffect = &lt;span&gt;null&lt;/span&gt; &lt;span&gt;// 执行后立马变成null&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;span&gt;&lt;span&gt;function&lt;/span&gt; &lt;span&gt;track&lt;/span&gt;(&lt;span&gt;target, key&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;// 如果此时activeEffect为null则不执行下面&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;// 这里判断是为了避免例如console.log(person.name)而触发track&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (!activeEffect) &lt;span&gt;return&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;let&lt;/span&gt; depsMap = targetMap.get(target)&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (!depsMap) {&lt;br/&gt;        targetMap.set(target, depsMap = &lt;span&gt;new&lt;/span&gt; &lt;span&gt;Map&lt;/span&gt;())&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;let&lt;/span&gt; dep = depsMap.get(key)&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (!dep) {&lt;br/&gt;        depsMap.set(key, dep = &lt;span&gt;new&lt;/span&gt; &lt;span&gt;Set&lt;/span&gt;())&lt;br/&gt;    }&lt;br/&gt;    dep.add(activeEffect) &lt;span&gt;// 把此时的activeEffect添加进去&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// 每个effect函数改成这么执行&lt;/span&gt;&lt;br/&gt;effect(effectNameStr1)&lt;br/&gt;effect(effectNameStr2)&lt;br/&gt;effect(effectAgeStr1)&lt;br/&gt;effect(effectAgeStr2)&lt;br/&gt;effect(effectTypeStr1)&lt;br/&gt;effect(effectTypeStr2)&lt;br/&gt;effect(effectHeightStr1)&lt;br/&gt;effect(effectHeightStr2)&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;figure&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6589506172839507&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/TZL4BdZpLdiaJFdBTFwdnAH2tYZIFZYSJ05qacLVBEPqnYsC2B8cRsHicYPceWVZ4CdxbcLpPmzQC9UFQ41YXqIA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;648&quot;/&gt;&lt;figcaption&gt;截屏2021-08-27 下午9.49.44.png&lt;/figcaption&gt;&lt;/figure&gt;&lt;h3&gt;实现ref&lt;/h3&gt;&lt;p&gt;咱们在Vue3中是这么使用&lt;code&gt;ref&lt;/code&gt;的&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;let&lt;/span&gt; num = ref(&lt;span&gt;5&lt;/span&gt;)&lt;br/&gt;&lt;br/&gt;&lt;span&gt;console&lt;/span&gt;.log(num.value) &lt;span&gt;// 5&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;然后&lt;code&gt;num&lt;/code&gt;就会成为一个响应式的数据，而且使用&lt;code&gt;num&lt;/code&gt;时需要这么写&lt;code&gt;num.value&lt;/code&gt;才能使用&lt;/p&gt;&lt;p&gt;实现ref其实很简单，咱们上面已经实现了&lt;code&gt;reactive&lt;/code&gt;，只需要这么做就可以实现&lt;code&gt;ref&lt;/code&gt;&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;function&lt;/span&gt; &lt;span&gt;ref&lt;/span&gt; (&lt;span&gt;initValue&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; reactive({&lt;br/&gt;        &lt;span&gt;value&lt;/span&gt;: initValue&lt;br/&gt;    })&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;咱们可以来试试效果如何&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;let&lt;/span&gt; num = ref(&lt;span&gt;5&lt;/span&gt;)&lt;br/&gt;&lt;br/&gt;effect(&lt;span&gt;&lt;span&gt;()&lt;/span&gt; =&amp;gt;&lt;/span&gt; sum = num.value * &lt;span&gt;100&lt;/span&gt;)&lt;br/&gt;&lt;br/&gt;&lt;span&gt;console&lt;/span&gt;.log(sum) &lt;span&gt;// 500&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;num.value = &lt;span&gt;10&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;console&lt;/span&gt;.log(sum) &lt;span&gt;// 1000&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3&gt;实现computed&lt;/h3&gt;&lt;p&gt;咱们顺便简单实现一下&lt;code&gt;computed&lt;/code&gt;吧，其实也很简单&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;function&lt;/span&gt; &lt;span&gt;computed&lt;/span&gt;(&lt;span&gt;fn&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;const&lt;/span&gt; result = ref()&lt;br/&gt;    effect(&lt;span&gt;&lt;span&gt;()&lt;/span&gt; =&amp;gt;&lt;/span&gt; result.value = fn()) &lt;span&gt;// 执行computed传入函数&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; result&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;咱们来看看结果&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;let&lt;/span&gt; num1 = ref(&lt;span&gt;5&lt;/span&gt;)&lt;br/&gt;&lt;span&gt;let&lt;/span&gt; num2 = ref(&lt;span&gt;8&lt;/span&gt;)&lt;br/&gt;&lt;span&gt;let&lt;/span&gt; sum1 = computed(&lt;span&gt;&lt;span&gt;()&lt;/span&gt; =&amp;gt;&lt;/span&gt; num1.value * num2.value)&lt;br/&gt;&lt;span&gt;let&lt;/span&gt; sum2 = computed(&lt;span&gt;&lt;span&gt;()&lt;/span&gt; =&amp;gt;&lt;/span&gt; sum1.value * &lt;span&gt;10&lt;/span&gt;)&lt;br/&gt;&lt;br/&gt;&lt;span&gt;console&lt;/span&gt;.log(sum1.value) &lt;span&gt;// 40&lt;/span&gt;&lt;br/&gt;&lt;span&gt;console&lt;/span&gt;.log(sum2.value) &lt;span&gt;// 400&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;num1.value = &lt;span&gt;10&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;console&lt;/span&gt;.log(sum1.value) &lt;span&gt;// 80&lt;/span&gt;&lt;br/&gt;&lt;span&gt;console&lt;/span&gt;.log(sum2.value) &lt;span&gt;// 800&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;num2.value = &lt;span&gt;16&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;console&lt;/span&gt;.log(sum1.value) &lt;span&gt;// 160&lt;/span&gt;&lt;br/&gt;&lt;span&gt;console&lt;/span&gt;.log(sum2.value) &lt;span&gt;// 1600&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;自此咱们就实现了本文章所有功能&lt;/p&gt;&lt;h3&gt;最终代码&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;const&lt;/span&gt; targetMap = &lt;span&gt;new&lt;/span&gt; &lt;span&gt;WeakMap&lt;/span&gt;()&lt;br/&gt;&lt;span&gt;&lt;span&gt;function&lt;/span&gt; &lt;span&gt;track&lt;/span&gt;(&lt;span&gt;target, key&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;// 如果此时activeEffect为null则不执行下面&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;// 这里判断是为了避免例如console.log(person.name)而触发track&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (!activeEffect) &lt;span&gt;return&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;let&lt;/span&gt; depsMap = targetMap.get(target)&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (!depsMap) {&lt;br/&gt;        targetMap.set(target, depsMap = &lt;span&gt;new&lt;/span&gt; &lt;span&gt;Map&lt;/span&gt;())&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;let&lt;/span&gt; dep = depsMap.get(key)&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (!dep) {&lt;br/&gt;        depsMap.set(key, dep = &lt;span&gt;new&lt;/span&gt; &lt;span&gt;Set&lt;/span&gt;())&lt;br/&gt;    }&lt;br/&gt;    dep.add(activeEffect) &lt;span&gt;// 把此时的activeEffect添加进去&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;span&gt;&lt;span&gt;function&lt;/span&gt; &lt;span&gt;trigger&lt;/span&gt;(&lt;span&gt;target, key&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;let&lt;/span&gt; depsMap = targetMap.get(target)&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (depsMap) {&lt;br/&gt;        &lt;span&gt;const&lt;/span&gt; dep = depsMap.get(key)&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (dep) {&lt;br/&gt;            dep.forEach(&lt;span&gt;&lt;span&gt;effect&lt;/span&gt; =&amp;gt;&lt;/span&gt; effect())&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;span&gt;&lt;span&gt;function&lt;/span&gt; &lt;span&gt;reactive&lt;/span&gt;(&lt;span&gt;target&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;const&lt;/span&gt; handler = {&lt;br/&gt;        &lt;span&gt;get&lt;/span&gt;(target, key, receiver) {&lt;br/&gt;            track(receiver, key) &lt;span&gt;// 访问时收集依赖&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;return&lt;/span&gt; &lt;span&gt;Reflect&lt;/span&gt;.get(target, key, receiver)&lt;br/&gt;        },&lt;br/&gt;        &lt;span&gt;set&lt;/span&gt;(target, key, value, receiver) {&lt;br/&gt;            &lt;span&gt;Reflect&lt;/span&gt;.set(target, key, value, receiver)&lt;br/&gt;            trigger(receiver, key) &lt;span&gt;// 设值时自动通知更新&lt;/span&gt;&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; &lt;span&gt;Proxy&lt;/span&gt;(target, handler)&lt;br/&gt;}&lt;br/&gt;&lt;span&gt;let&lt;/span&gt; activeEffect = &lt;span&gt;null&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;function&lt;/span&gt; &lt;span&gt;effect&lt;/span&gt;(&lt;span&gt;fn&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;    activeEffect = fn&lt;br/&gt;    activeEffect()&lt;br/&gt;    activeEffect = &lt;span&gt;null&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;span&gt;&lt;span&gt;function&lt;/span&gt; &lt;span&gt;ref&lt;/span&gt;(&lt;span&gt;initValue&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; reactive({&lt;br/&gt;        &lt;span&gt;value&lt;/span&gt;: initValue&lt;br/&gt;    })&lt;br/&gt;}&lt;br/&gt;&lt;span&gt;&lt;span&gt;function&lt;/span&gt; &lt;span&gt;computed&lt;/span&gt;(&lt;span&gt;fn&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;const&lt;/span&gt; result = ref()&lt;br/&gt;    effect(&lt;span&gt;&lt;span&gt;()&lt;/span&gt; =&amp;gt;&lt;/span&gt; result.value = fn())&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; result&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2&gt;&lt;span&gt;Proxy和Reflect&lt;/span&gt;&lt;/h2&gt;&lt;h3&gt;Proxy&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;const&lt;/span&gt; person = { &lt;span&gt;name&lt;/span&gt;: &lt;span&gt;&#x27;林三心&#x27;&lt;/span&gt;, &lt;span&gt;age&lt;/span&gt;: &lt;span&gt;22&lt;/span&gt; }&lt;br/&gt;&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; proxyPerson = &lt;span&gt;new&lt;/span&gt; &lt;span&gt;Proxy&lt;/span&gt;(person, {&lt;br/&gt;    &lt;span&gt;get&lt;/span&gt;(target, key, receiver) {&lt;br/&gt;        &lt;span&gt;console&lt;/span&gt;.log(target) &lt;span&gt;// 原来的person&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;console&lt;/span&gt;.log(key) &lt;span&gt;// 属性名&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;console&lt;/span&gt;.log(receiver) &lt;span&gt;// 代理后的proxyPerson&lt;/span&gt;&lt;br/&gt;    },&lt;br/&gt;    &lt;span&gt;set&lt;/span&gt;(target, key, value, receiver) {&lt;br/&gt;        &lt;span&gt;console&lt;/span&gt;.log(target) &lt;span&gt;// 原来的person&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;console&lt;/span&gt;.log(key) &lt;span&gt;// 属性名&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;console&lt;/span&gt;.log(value) &lt;span&gt;// 设置的值&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;console&lt;/span&gt;.log(receiver) &lt;span&gt;// 代理后的proxyPerson&lt;/span&gt;&lt;br/&gt;    }&lt;br/&gt;})&lt;br/&gt;&lt;br/&gt;proxyPerson.name &lt;span&gt;// 访问属性触发get方法&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;proxyPerson.name = &lt;span&gt;&#x27;sunshine_lin&#x27;&lt;/span&gt; &lt;span&gt;// 设置属性值触发set方法&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3&gt;Reflect&lt;/h3&gt;&lt;p&gt;在这列举&lt;code&gt;Reflect&lt;/code&gt;的两个方法&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;get(target, key, receiver)&lt;/code&gt;：个人理解就是，访问&lt;code&gt;target&lt;/code&gt;的&lt;code&gt;key&lt;/code&gt;属性，但是&lt;code&gt;this&lt;/code&gt;是指向&lt;code&gt;receiver&lt;/code&gt;，所以实际是访问的值是&lt;code&gt;receiver的key&lt;/code&gt;的值，但是这可不是直接访问&lt;code&gt;receiver[key]&lt;/code&gt;属性，大家要区分一下&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;set(target, key, value, receiver)&lt;/code&gt;：个人理解就是，设置&lt;code&gt;target&lt;/code&gt;的&lt;code&gt;key&lt;/code&gt;属性为&lt;code&gt;value&lt;/code&gt;，但是&lt;code&gt;this&lt;/code&gt;是指向&lt;code&gt;receiver&lt;/code&gt;，所以实际是是设置&lt;code&gt;receiver的key&lt;/code&gt;的值为&lt;code&gt;value&lt;/code&gt;，但这可不是直接&lt;code&gt;receiver[key] = value&lt;/code&gt;，大家要区分一下&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;上面咱们强调了，不能直接&lt;code&gt;receiver[key]&lt;/code&gt;或者&lt;code&gt;receiver[key] = value&lt;/code&gt;，而是要通过&lt;code&gt;Reflect.get和Reflect.set&lt;/code&gt;，绕个弯去访问属性或者设置属性，这是为啥呢？下面咱们举个反例&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;const&lt;/span&gt; person = { &lt;span&gt;name&lt;/span&gt;: &lt;span&gt;&#x27;林三心&#x27;&lt;/span&gt;, &lt;span&gt;age&lt;/span&gt;: &lt;span&gt;22&lt;/span&gt; }&lt;br/&gt;&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; proxyPerson = &lt;span&gt;new&lt;/span&gt; &lt;span&gt;Proxy&lt;/span&gt;(person, {&lt;br/&gt;    &lt;span&gt;get&lt;/span&gt;(target, key, receiver) {&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;Reflect&lt;/span&gt;.get(receiver, key) &lt;span&gt;// 相当于 receiver[key]&lt;/span&gt;&lt;br/&gt;    },&lt;br/&gt;    &lt;span&gt;set&lt;/span&gt;(target, key, value, receiver) {&lt;br/&gt;        &lt;span&gt;Reflect&lt;/span&gt;.set(receiver, key, value) &lt;span&gt;// 相当于 receiver[key] = value&lt;/span&gt;&lt;br/&gt;    }&lt;br/&gt;})&lt;br/&gt;&lt;br/&gt;&lt;span&gt;console&lt;/span&gt;.log(proxyPerson.name)&lt;br/&gt;&lt;br/&gt;proxyPerson.name = &lt;span&gt;&#x27;sunshine_lin&#x27;&lt;/span&gt; &lt;br/&gt;&lt;span&gt;// 会直接报错，栈内存溢出 Maximum call stack size exceeded&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;为什么会这样呢？看看下图解答&lt;/p&gt;&lt;figure&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.48933143669985774&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/TZL4BdZpLdiaJFdBTFwdnAH2tYZIFZYSJnV9BhGE1UBIjOiaHKibIouHOzsrgWBGYaMf1cp65lHbLwlST6d3pVY1w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;703&quot;/&gt;&lt;figcaption&gt;截屏2021-08-27 下午10.55.49.png&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;现在知道为什么不能直接&lt;code&gt;receiver[key]&lt;/code&gt;或者&lt;code&gt;receiver[key] = value&lt;/code&gt;了吧，因为直接这么操作会导致无限循环，最终报错。所以正确做法是&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;const&lt;/span&gt; person = { &lt;span&gt;name&lt;/span&gt;: &lt;span&gt;&#x27;林三心&#x27;&lt;/span&gt;, &lt;span&gt;age&lt;/span&gt;: &lt;span&gt;22&lt;/span&gt; }&lt;br/&gt;&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; proxyPerson = &lt;span&gt;new&lt;/span&gt; &lt;span&gt;Proxy&lt;/span&gt;(person, {&lt;br/&gt;    &lt;span&gt;get&lt;/span&gt;(target, key, receiver) {&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;Reflect&lt;/span&gt;.get(target, key, receiver)&lt;br/&gt;    },&lt;br/&gt;    &lt;span&gt;set&lt;/span&gt;(target, key, value, receiver) {&lt;br/&gt;        &lt;span&gt;Reflect&lt;/span&gt;.set(target, key, value, receiver)&lt;br/&gt;    }&lt;br/&gt;})&lt;br/&gt;&lt;br/&gt;&lt;span&gt;console&lt;/span&gt;.log(proxyPerson.name) &lt;span&gt;// 林三心&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;proxyPerson.name = &lt;span&gt;&#x27;sunshine_lin&#x27;&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;console&lt;/span&gt;.log(proxyPerson.name) &lt;span&gt;// sunshine_lin&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;肯定有的同学就要问了，下面这么写也可以，为什么也不建议呢？我放到下面一起说&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;const&lt;/span&gt; proxyPerson = &lt;span&gt;new&lt;/span&gt; &lt;span&gt;Proxy&lt;/span&gt;(person, {&lt;br/&gt;    &lt;span&gt;get&lt;/span&gt;(target, key, receiver) {&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;Reflect&lt;/span&gt;.get(target, key)&lt;br/&gt;    },&lt;br/&gt;    &lt;span&gt;set&lt;/span&gt;(target, key, value, receiver) {&lt;br/&gt;        &lt;span&gt;Reflect&lt;/span&gt;.get(target, key, value)&lt;br/&gt;    }&lt;br/&gt;})&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3&gt;为什么要一起用&lt;/h3&gt;&lt;p&gt;其实Proxy不搭配Reflect也是可以的。咱们可以这么写，也照样能实现想要的效果&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;const&lt;/span&gt; person = { &lt;span&gt;name&lt;/span&gt;: &lt;span&gt;&#x27;林三心&#x27;&lt;/span&gt;, &lt;span&gt;age&lt;/span&gt;: &lt;span&gt;22&lt;/span&gt; }&lt;br/&gt;&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; proxyPerson = &lt;span&gt;new&lt;/span&gt; &lt;span&gt;Proxy&lt;/span&gt;(person, {&lt;br/&gt;    &lt;span&gt;get&lt;/span&gt;(target, key, receiver) {&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; target[key]&lt;br/&gt;    },&lt;br/&gt;    &lt;span&gt;set&lt;/span&gt;(target, key, value, receiver) {&lt;br/&gt;        target[key] = value&lt;br/&gt;    }&lt;br/&gt;})&lt;br/&gt;&lt;br/&gt;&lt;span&gt;console&lt;/span&gt;.log(proxyPerson.name) &lt;span&gt;// 林三心&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;proxyPerson.name = &lt;span&gt;&#x27;sunshine_lin&#x27;&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;console&lt;/span&gt;.log(proxyPerson.name) &lt;span&gt;// sunshine_lin&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;那为什么建议&lt;code&gt;Proxy和Reflect&lt;/code&gt;一起使用呢？因为&lt;code&gt;Proxy和Reflect&lt;/code&gt;的方法都是一一对应的，在&lt;code&gt;Proxy&lt;/code&gt;里使用&lt;code&gt;Reflect&lt;/code&gt;会提高语义化&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;Proxy的get&lt;/code&gt;对应&lt;code&gt;Reflect.get&lt;/code&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;Proxy的set&lt;/code&gt;对应&lt;code&gt;Reflect.set&lt;/code&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;还有很多其他方法我就不一一列举，都是一一对应的&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;还有一个原因就是，尽量把this放在&lt;code&gt;receiver&lt;/code&gt;上，而不放在&lt;code&gt;target&lt;/code&gt;上&lt;/p&gt;&lt;p&gt;为什么要尽量把this放在代理对象&lt;code&gt;receiver&lt;/code&gt;上，而不建议放原对象&lt;code&gt;target&lt;/code&gt;上呢？因为原对象&lt;code&gt;target&lt;/code&gt;有可能本来也是是另一个代理的代理对象，所以如果this一直放&lt;code&gt;target&lt;/code&gt;上的话，出bug的概率会大大提高，所以之前的代码为什么不建议，大家应该知道了吧？&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;const&lt;/span&gt; proxyPerson = &lt;span&gt;new&lt;/span&gt; &lt;span&gt;Proxy&lt;/span&gt;(person, {&lt;br/&gt;    &lt;span&gt;get&lt;/span&gt;(target, key, receiver) {&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;Reflect&lt;/span&gt;.get(target, key)&lt;br/&gt;    },&lt;br/&gt;    &lt;span&gt;set&lt;/span&gt;(target, key, value, receiver) {&lt;br/&gt;        &lt;span&gt;Reflect&lt;/span&gt;.set(target, key, value)&lt;br/&gt;    }&lt;br/&gt;})&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2&gt;&lt;span&gt;结语&lt;/span&gt;&lt;/h2&gt;&lt;blockquote&gt;&lt;p&gt;关注公众号「前端之神」，每天分享有用的前端知识技巧，进学习群，定时举行模拟面试直播，简历指导~&lt;/p&gt;&lt;/blockquote&gt;&lt;section&gt;&lt;mp-common-profile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mpprofile&quot; data-weui-theme=&quot;light&quot; data-id=&quot;Mzg2NjY2NTcyNg==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/TZL4BdZpLdjaCTEjQdxnaIlEWiaGcw9zNV7AHZGgp5q9U0zPf3cmcIgBRYG1n2ydEBHJGgl8nEA1bKiaj1fibK2EA/0?wx_fmt=png&quot; data-nickname=&quot;前端之神&quot; data-alias=&quot;Sunshine_Lin_God&quot; data-signature=&quot;一位前端小菜鸡，写过100多篇原创文章，全网有5w+个前端朋友，梦想是成为”前端之神“~&quot; data-from=&quot;0&quot; data-is_biz_ban=&quot;0&quot;/&gt;&lt;/section&gt;&lt;p&gt;如果你觉得此文对你有一丁点帮助，点个赞，鼓励一下林三心哈哈。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;mp-style-type data-value=&quot;3&quot;/&gt;&lt;/p&gt;&lt;/div&gt;

          
        &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>