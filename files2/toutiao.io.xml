<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>924c067248a96e16b4a192c7f7092663</guid>
<title>大厂Kafka的深度实践</title>
<link>https://toutiao.io/k/7jz8lsl</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;profile_inner&quot;&gt;
                  &lt;strong class=&quot;profile_nickname&quot;&gt;华仔聊技术&lt;/strong&gt;
                  &lt;img class=&quot;profile_avatar&quot; id=&quot;js_profile_qrcode_img&quot; src=&quot;&quot; alt=&quot;&quot;/&gt;

                  &lt;p class=&quot;profile_meta&quot;&gt;
                  &lt;label class=&quot;profile_meta_label&quot;&gt;Weixin ID&lt;/label&gt;
                  &lt;span class=&quot;profile_meta_value&quot;&gt;gh_97b8de4b5b34&lt;/span&gt;
                  &lt;/p&gt;

                  &lt;p class=&quot;profile_meta&quot;&gt;
                  &lt;label class=&quot;profile_meta_label&quot;&gt;About Feature&lt;/label&gt;
                  &lt;span class=&quot;profile_meta_value&quot;&gt;聊聊后端技术架构以及中间件源码&lt;/span&gt;
                  &lt;/p&gt;
                &lt;/div&gt;
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>0961e9471a5c99adbaf0aeb973e4884b</guid>
<title>HttpClient 在vivo内销浏览器的高并发实践优化</title>
<link>https://toutiao.io/k/whq0h15</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content                                       &quot; id=&quot;js_content&quot;&gt;&lt;section class=&quot;mp_profile_iframe_wrp&quot;&gt;&lt;mp-common-profile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mpprofile&quot; data-id=&quot;MzI4NjY4MTU5Nw==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/4g5IMGibSxt45QXJZicZ9gaNU2mRSlvqhQd94MJ7oQh4QFj1ibPV66xnUiaKoicSatwaGXepL5sBDSDLEckicX1ttibHg/0?wx_fmt=png&quot; data-nickname=&quot;vivo互联网技术&quot; data-alias=&quot;vivoVMIC&quot; data-signature=&quot;分享 vivo 互联网技术干货与沙龙活动，推荐最新行业动态与热门会议。&quot; data-from=&quot;0&quot; data-is_biz_ban=&quot;0&quot;/&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;span&gt;作者：vivo 互联网服务器团队- Zhi Guangquan&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;HttpClient作为Java程序员最常用的Http工具，其对Http连接的管理能简化开发，并且提升连接重用效率；在正常情况下，HttpClient能帮助我们高效管理连接，但在一些并发高，报文体较大的情况下，如果再遇到网络波动，如何保证连接被高效利用，有哪些优化空间。&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;一、问题现象&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;北京时间X月X日，浏览器信息流服务监控出现异常，主要表现在以下三个方面：&lt;/p&gt;&lt;/section&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;ol class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;从某个时间点开始，云监控显示部分Http接口的熔断器被打开，而且从明细列表可以发现问题机器：&lt;/p&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-croporisrc=&quot;https://mmbiz.qpic.cn/mmbiz_png/4g5IMGibSxt6ANHib9N7picyuomWhjsuEur15EYAlfFXS2v6ibSZBGh5ttNolxdgnVx9RvXX3y9M2UW3ibI12XKKQIA/0?wx_fmt=png&quot; data-cropx1=&quot;11.347750865051903&quot; data-cropx2=&quot;925.6522491349482&quot; data-cropy1=&quot;8.105536332179932&quot; data-cropy2=&quot;520.3754325259516&quot; data-ratio=&quot;0.5612691466083151&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/4g5IMGibSxt6ANHib9N7picyuomWhjsuEur5AIibyxz3ELszDfH8WD2D7jiaRh8OMR4X1V0kedsKSjQw2evOZtfSbjQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;914&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;2.06651376146789&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/4g5IMGibSxt6ANHib9N7picyuomWhjsuEur6s0RcbP2Bg3qbgIUHuVyCQYVOzZ6PLZhgF88phEfauktUeMxqhL5rA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;436&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;2. 从PAAS平台Hystrix熔断管理界面中可以进一步确认问题机器的所有Http接口调用均出现了熔断：&lt;/p&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;3. 日志中心有大量从Http连接池获取连接的异常：&lt;/p&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;org.apache.http.impl.execchain.RequestAbortedException: Request aborted。&lt;/p&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;二、问题定位&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;综合以上三个现象，大概可以推测出问题机器的TCP连接管理出了问题，可能是虚拟机问题，也可能是物理机问题；与运维与系统侧沟通后，发现虚拟机与物理机均无明显异常，第一时间联系运维重启了问题机器，线上问题得到解决。&lt;/p&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;span&gt;2.1 临时解决方案&lt;/span&gt;&lt;/p&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;几天以后，线上部分其他机器也陆续出现了上述现象，此时基本可以确认是服务本身有问题；既然问题与TCP连接相关，于是联系运维在问题机器上建立了一个作业查看TCP连接的状态分布：&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;nginx&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__attribute&quot;&gt;netstat&lt;/span&gt; -ant|awk &lt;span class=&quot;code-snippet__string&quot;&gt;&#x27;/^tcp/ {++S[&lt;span class=&quot;code-snippet__variable&quot;&gt;$NF&lt;/span&gt;]} END {for(a in S) print (a,S[a])}&#x27;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;结果如下：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;1.5706806282722514&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/4g5IMGibSxt6ANHib9N7picyuomWhjsuEurWrF38mPTicd7HZxGabxC9BwhXb9iaVhCj3kXLW4o7fHoR7SDJauWlmBw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;191&quot;/&gt;&lt;/p&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;如上图，问题机器的CLOSE_WAIT状态的连接数已经接近200左右（该服务Http连接池最大连接数设置的250），那问题直接原因基本可以确认是CLOSE_WAIT状态的连接过多导致的；本着第一时间先解决线上问题的原则，先把连接池调整到500，然后让运维重启了机器，线上问题暂时得到解决。&lt;/p&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;span&gt;2.2 原因分析&lt;/span&gt;&lt;/p&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;调整连接池大小只是暂时解决了线上问题，但是具体原因还不确定，按照以往经验，出现连接无法正常释放基本都是开发者使用不当，在使用完成后没有及时关闭连接；但很快这个想法就被否定了，原因显而易见：当前的服务已经在线上运行了一周左右，中间没有经历过发版，以浏览器的业务量，如果是连接使用完没有及时关。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;闭，250的连接数连一分钟都撑不到就会被打爆。那么问题就只能是一些异常场景导致的连接没有释放；于是，重点排查了下近期上线的业务接口，尤其是那种数据包体较大，响应时间较长的接口，最终把目标锁定在了某个详情页优化接口上；先查看处于CLOSE_WAIT状态的IP与端口连接对，确认对方服务器IP地址。&lt;/p&gt;&lt;/section&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;objectivec&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;netstat-tulnap|grep &lt;span class=&quot;code-snippet__built_in&quot;&gt;CLOSE_WAIT&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.47398843930635837&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/4g5IMGibSxt6ANHib9N7picyuomWhjsuEur01UhbE9Xr6OEsLkwBcuU1VdibUj5vzibsZYM0OOl87f5kFz8fe5ib53zw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;865&quot;/&gt;&lt;/p&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;经过与合作方确认，目标IP均来自该合作方，与我们的推测是相符的。&lt;/p&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;span&gt;2.3 TCP抓包&lt;/span&gt;&lt;/p&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;在定位问题的同时，也让运维同事帮忙抓取了TCP的数据包，结果表明确实是客户端（浏览器服务端）没返回ACK结束握手，导致挥手失败，客户端处于了CLOSE_WAIT状态，数据包的大小也与怀疑的问题接口相符。&lt;/p&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.2254335260115607&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/4g5IMGibSxt6ANHib9N7picyuomWhjsuEur7JVPyB85KruzYNfwmjaCYttFj0NGsd2Xdux5LCTxW0D9vLrXa3tDibA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;865&quot;/&gt;&lt;/p&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;为了方便大家理解，我从网上找了一张图，大家可以作为参考：&lt;/p&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.9421965317919075&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/4g5IMGibSxt6ANHib9N7picyuomWhjsuEurmN7AzjyiaUFtoE8XkxicztqTrrHHcwzNYJF6ar5QOXp34pCaIO9hP9zQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;865&quot;/&gt;&lt;/p&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;CLOSE_WAIT是一种被动关闭状态，如果是SERVER主动断开的连接，那么就会在CLIENT出现CLOSE_WAIT的状态，反之同理；&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;通常情况下，如果客户端在一次http请求完成后没有及时关闭流（tcp中的流套接字），那么超时后服务端就会主动发送关闭连接的FIN，客户端没有主动关闭，所以就停留在了CLOSE_WAIT状态，如果是这种情况，很快连接池中的连接就会被耗尽。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;所以，我们今天遇到的情况（处于CLOSE_WAIT状态的连接数每天都在缓慢增长），更像是某一种异常场景导致的连接没有关闭。&lt;/p&gt;&lt;/section&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;span&gt;2.4 独立连接池&lt;/span&gt;&lt;/p&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;为了不影响其他业务场景，防止出现系统性风险，我们先把问题接口连接池进行了独立管理。&lt;/p&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;span&gt;2.5 深入分析&lt;/span&gt;&lt;/p&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;带着2.3的疑问我们仔细查看一下业务调用代码：&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;cs&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;try&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        httpResponse = HttpsClientUtil.getHttpClient().execute(request);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        HttpEntity httpEntity = httpResponse.getEntity();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__keyword&quot;&gt;is&lt;/span&gt; = httpEntity.getContent();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;     }&lt;span class=&quot;code-snippet__keyword&quot;&gt;catch&lt;/span&gt; (Exception e){&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        log.error(&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;&quot;&lt;/span&gt;);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;     }&lt;span class=&quot;code-snippet__keyword&quot;&gt;finally&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        IOUtils.closeQuietly(&lt;span class=&quot;code-snippet__keyword&quot;&gt;is&lt;/span&gt;);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        IOUtils.closeQuietly(httpResponse);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;     }&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;这段代码存在一个明显的问题：既关闭了数据传输流（ &lt;strong&gt;IOUtils.closeQuietly(is)&lt;/strong&gt;），也关闭了整个连接（&lt;strong&gt;IOUtils.closeQuietly(httpResponse)&lt;/strong&gt;），这样我们就没办法进行连接的复用了；但是却更让人疑惑了：既然每次都手动关闭了连接，为什么还会有大量CLOSE_WAIT状态的连接存在呢？&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;如果问题不在业务调用代码上，那么只能是这个业务接口具有的某种特殊性导致了问题的发生；通过抓包分析发现该接口有一个明显特征：&lt;strong&gt;接口返回报文较大，平均在500KB左右&lt;/strong&gt;。那么问题就极有可能是报文过大导致了某种异常，造成了连接不能被复用也不能被释放。&lt;/p&gt;&lt;/section&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;span&gt;2.6 源码分析&lt;/span&gt;&lt;/p&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;开始分析之前，我们需要了解一个基础知识：&lt;strong&gt;Http的长连接和短连接&lt;/strong&gt;。所谓长连接就是建立起连接之后，可以复用连接多次进行数据传输；而短连接则是每次都需要重新建立连接再进行数据传输。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;而通过对接口的抓包我们发现，响应头里有Connection:keep-live字样，那我们就可以重点从HttpClient对长连接的管理入手来进行代码分析。&lt;/p&gt;&lt;/section&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;strong&gt;2.6.1 连接池初始化 &lt;/strong&gt;&lt;/p&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;初始化方法：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.34858188472095153&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/4g5IMGibSxt6ANHib9N7picyuomWhjsuEurgicYc34WE717UibUPV4yVCHNAhacFg6wYTp3yYZjvqc9icoiazoK5GJMBg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1093&quot;/&gt;&lt;/p&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;进入PoolingHttpClientConnectionManager这个类，有一个重载构造方法里包含连接存活时间参数：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.3196060877350045&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/4g5IMGibSxt6ANHib9N7picyuomWhjsuEurC6OqfsAVkL5D9fGHo9rHWSG4BUSQrKc8xVYF3CjLyy1e9WWK5oQgvg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1117&quot;/&gt;&lt;/p&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;顺着继续向下查看：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.46895787139689576&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/4g5IMGibSxt6ANHib9N7picyuomWhjsuEurm7jCw5QEbfKRbuZTJGTK5fcBiblMmoS1wpCNicj1MLgHDnMqz8DWicEyQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;902&quot;/&gt;&lt;/p&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;manager的构造方法到此结束，我们不难发现validityDeadline会被赋值给expiry变量，那我们接下来就要看下HttpClient是在哪里使用expiry这个参数的；&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;通常情况下，实例对象被构建出来的时候会初始化一些策略参数，此时我们需要查看构建HttpClient实例的方法来寻找答案：&lt;/p&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.11466666666666667&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/4g5IMGibSxt6ANHib9N7picyuomWhjsuEurguib85JMT1FoQJrzVVEFQCzmlqUibrs0m8icCG4OwLeCWjicaXmFkMa0CA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;750&quot;/&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;此方法包含一系列的初始化操作，包括构建连接池，给连接池设置最大连接数，指定重用策略和长连接策略等，这里我们还注意到，HttpClient创建了一个异步线程，去监听清理空闲连接。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;当然，前提是你打开了自动清理空闲连接的配置，默认是关闭的。&lt;/p&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.2563667232597623&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/4g5IMGibSxt6ANHib9N7picyuomWhjsuEuriaEuLwJ3Q1WibQ00m2J7AibBicMkL8rHwBmAVG6bOvtyB1YBapZWIC5GeA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1178&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.5612612612612613&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/4g5IMGibSxt6ANHib9N7picyuomWhjsuEure8ICZ1KxwqgdWsKlkEn3F1OS4zQOPlXQiaTAOIA2wfP1nqWQSPcXF2w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1110&quot;/&gt;&lt;/p&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;接着我们就看到了HttpClient关闭空闲连接的具体实现，里面有我们想要看到的内容：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.4912485414235706&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/4g5IMGibSxt6ANHib9N7picyuomWhjsuEurwuhoSNyTCggvjvw5G0CEttazzoMg2nZpqmOazn3uVBl7icuM1Jk1L3w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;857&quot;/&gt;&lt;/p&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.4619750283768445&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/4g5IMGibSxt6ANHib9N7picyuomWhjsuEurdFeW0kXNnWScCMdb53wEMZ7Y3dprGMtb04icCeYgPWvYkJnI1soLmQQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;881&quot;/&gt;&lt;/p&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;此时，我们可以得出第一个结论：可以在初始化连接池的时候，通过实现带参的PoolingHttpClientConnectionManager构造方法，修改validityDeadline的值，从而影响HttpClient对长连接的管理策略。&lt;/p&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;strong&gt;2.6.2 执行方法入口&lt;/strong&gt;&lt;/p&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;先找到执行入口方法：&lt;/p&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;org.apache.http.impl.execchain.MainClientExec.execute,看到了keepalive相关代码实现：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.4505154639175258&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/4g5IMGibSxt6ANHib9N7picyuomWhjsuEurzZJSgpM42fIsILUE61hkWpFU1Jfpplk5FkLSsib5c9R9Fic0zIp5EfFA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;970&quot;/&gt;&lt;/p&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;我们来看下默认的策略：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.42618110236220474&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/4g5IMGibSxt6ANHib9N7picyuomWhjsuEurYTTxCxpb6XRBvylo2UiaxFLwWqHQXtyD5RKewQDSC4XVEkgU5B6aXWg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1016&quot;/&gt;&lt;/p&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.3185437997724687&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/4g5IMGibSxt6ANHib9N7picyuomWhjsuEurfdsPe1VoiaWTNDB6C8reVGibnz6N1DS2ojVoOjxFDsmmJV6Cfg7mbwibw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;879&quot;/&gt;&lt;/p&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;由于中间的调用逻辑比较简单，就不在这里一一把调用的链路贴出来了，这边直接给结论：HttpClient对没有指定连接有效时间的长连接，有效期设置为永久（Long.MAX_VALUE）。&lt;/p&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;综合以上分析,我们可以得出最终结论：&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;HttpClient通过控制newExpiry和validityDeadline来实现对长连接的有效期的管理，而且对没有指定连接有效时间的长连接，有效期设置为永久。&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;至此我们可以大胆给出一个猜测：长连接的有效期是永久，而因为某种异常导致长连接没有被及时关闭，而永久存活了下来，不能被复用也不能被释放。（只是根据现象的猜测，虽然最后被证实并不完全正确，但确实提高了我们解决问题的效率）。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;基于此，我们也可以通过改变这两个参数来实现对长连接的管理：&lt;/p&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.31328125&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/4g5IMGibSxt6ANHib9N7picyuomWhjsuEurL0uJGdtayaWSCLh0v04xMqK4cqXhZX4jDC8uwh6ZV2W5d7ftt8S85g/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;这样简单修改上线后，处于close_wait状态的连接数没有再持续增长，这个线上问题也算是得到了彻底的解决。&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;但此时相信大家也都存在一个疑问：作为被广泛使用的开源框架，HttpClient难道对长连接的管理这么粗糙吗？一个简单的异常调用就能导致整个调度机制彻底崩溃，而且不会自行恢复；&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;于是带着疑问，再一次详细查看了HttpClient的源码。&lt;/p&gt;&lt;/section&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;三、关于HttpClient&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;span&gt;3.1 前言&lt;/span&gt;&lt;/p&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;开始分析之前，先简单介绍下几个核心类：&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;ul class=&quot;list-paddingleft-1&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;【PoolingHttpClientConnectionManager】&lt;/strong&gt;：连接池管理器类，主要作用是管理连接和连接池，封装连接的创建、状态流转以及连接池的相关操作，是操作连接和连接池的入口方法；&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;【CPool】&lt;/strong&gt;：连接池的具体实现类，连接和连接池的具体实现均在CPool以及抽象类AbstractConnPool中实现，也是分析的重点；&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;【CPoolEntry】&lt;/strong&gt;：具体的连接封装类，包含连接的一些基础属性和基础操作，比如连接id，创建时间，有效期等；&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;【HttpClientBuilder】&lt;/strong&gt;：HttpClient的构造器，重点关注build方法；&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;【MainClientExec】&lt;/strong&gt;：客户端请求的执行类，是执行的入口，重点关注execute方法；&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;【ConnectionHolder】&lt;/strong&gt;：主要封装释放连接的方法，是在PoolingHttpClientConnectionManager的基础上进行了封装。&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;/p&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;span&gt;3.2 两个连接&lt;/span&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;ul class=&quot;list-paddingleft-1&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;li&gt;&lt;p&gt;最大连接数（maxTotal）&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;最大单路由连接数(maxPerRoute)&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/section&gt;&lt;/section&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;span&gt;3.3 三个超时&lt;/span&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;connectionRequestTimout&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;connetionTimeout&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;socketTimeout&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;【connectionRequestTimout】：&lt;/strong&gt;指从连接池获取连接的超时时间；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;【connetionTimeout】&lt;/strong&gt;：指客户端和服务器建立连接的超时时间，超时后会报&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;ConnectionTimeOutException异常；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;【socketTimeout】&lt;/strong&gt;：指客户端和服务器建立连接后，数据传输过程中数据包之间间隔的最大时间，超出后会抛出SocketTimeOutException。&lt;/span&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;一定要注意：这里的超时不是数据传输完成，而只是接收到两个数据包的间隔时间，这也是很多线上诡异问题发生的根本原因。&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;span&gt;3.4 四个容器&lt;/span&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;ul class=&quot;list-paddingleft-1&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;li&gt;&lt;p&gt;free&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;leased&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;pending&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;available&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/section&gt;&lt;/section&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;strong&gt;【free】：&lt;/strong&gt;空闲连接的容器，连接还没有建立，理论上freeSize=maxTotal -leasedSize&lt;/p&gt;&lt;p&gt;- availableSize（其实HttpClient中并没有该容器，只是为了描述方便，特意引入的一个容器）。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;【leased】&lt;/strong&gt;：租赁连接的容器，连接创建后，会从free容器转移到leased容器；也可以直接从available容器租赁连接，租赁成功后连接被放在leased容器中，此种场景主要是连接的复用，也是连接池的一个很重要的能力。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;【pending】&lt;/strong&gt;：等待连接的容器，其实该容器只是在等待连接释放的时候用作阻塞线程，下文也不会再提到，感兴趣的可以参考具体实现代码，其与connectionRequestTimout相关。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;【available】&lt;/strong&gt;：可复用连接的容器，通常直接从leased容器转移过来，长连接的情况下完成通信后，会把连接放到available列表，一些对连接的管理和释放通常都是围绕该容器进行的。&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;注：由于存在maxTotal和maxPerRoute两个连接数限制，下文在提到这四种容器时，如果没有带前缀，都代表是总连接数，如果是r.xxxx则代表是路由连接里的某个容器大小。&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;1.0042105263157894&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/4g5IMGibSxt6ANHib9N7picyuomWhjsuEurC3HeZcR5MsEUpEyWsOpUSsd9D1LENvJxs6mbcC3VmoeAe879d0d2lA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;475&quot;/&gt;&lt;/p&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;span&gt;maxTotal的组成&lt;/span&gt;&lt;/p&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;span&gt;3.5 连接的产生与管理&lt;/span&gt;&lt;/p&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;ol class=&quot;list-paddingleft-1&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;li&gt;&lt;p&gt;循环从available容器中获取连接，如果该连接未失效（根据上文提到的expiry字段判断），则把该连接从available容器中删除，并添加到leased容器，并返回该连接；&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;如果在第一步中没有获取到可用连接，则判断r.available + r.leased是否大于maxPerRoute，其实就是判断是否还有free连接；如果不存在，则需要把多余分配的连接释放掉（r. available + r.leased - maxPerRoute），来保证真实的连接数受maxPerRoute控制（至于为什么会出现r.leased+r.available&amp;gt;maxPerRoute的情况其实也很好理解，虽然在整个状态流转过程都加了锁，但是状态的流转并不是原子操作，存在一些异常的场景都会导致状态短时间不正确）；所以我们可以得出结论，maxPerRoute只是一个理论上的最大数值，其实真实产生的连接数在短时间内是可能大于这个值的；&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;在真实的连接数（r .leased+ r .available）小于maxPerRoute且maxTotal&amp;gt;leased的情况下：如果free&amp;gt;0，则重新创建一个连接；如果free=0，则把available容器里的最早创建的一个连接关闭掉，然后再重新创建一个连接；看起来有点绕，其实就是优先使用free容器里的连接，获取不到再释放available容器里的连接；&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;如果经过上述过程仍然没有获取到可用连接，那就只能等待一个connectionRequestTimout时间，或者有其他线程的信号通知来结束整个获取连接的过程。&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;1.5846599131693198&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/4g5IMGibSxt6ANHib9N7picyuomWhjsuEurcZYcQJNpQsQiaCFleT0d1ByYqpdaZDZ2060fJ7vAe98xfeXa5h2FickQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;691&quot;/&gt;&lt;/p&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;span&gt;3.6 连接的释放&lt;/span&gt;&lt;/p&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;ol class=&quot;list-paddingleft-1&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;li&gt;&lt;p&gt;如果是长连接（reusable），则把该连接从leased容器中删除，然后添加到available容器的头部，设置有效期为expiry；&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;如果是短连接（non-reusable），则直接关闭该连接，并且从released容器中删除，此时的连接被释放，处于free容器中；&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;最后，唤醒“连接的产生与管理“第四部中的等待线程。&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;整个过程分析完，了解了httpclient如何管理连接，再回头来看我们遇到的那个问题就比较清晰了：&lt;/p&gt;&lt;p&gt;正常情况下，虽然建立了长连接，但是我们会在finally代码块里去手动关闭，此场景其实是触发了“&lt;strong&gt;连接的释放&lt;/strong&gt;”中的步骤2，连接直接被关闭；所以正常情况下是没有问题的，长连接其实并没有发挥真正的作用；&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;那问题自然就只能出现在一些异常场景，导致了长连接没有被及时关闭，结合最初的分析，是服务端主动断开了连接，那大概率出现在一些超时导致连接断开的异常场景，我们再回到&lt;/p&gt;&lt;p&gt;org.apache.http.impl.execchain.MainClientExec这个类，发现这样几行代码：&lt;/p&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.20460358056265984&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/4g5IMGibSxt6ANHib9N7picyuomWhjsuEurZNq2RrNovs9aJIUMxNf36LsSBr2Yw4n0R5eibYZIjsvGZX4brliaZXMg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;782&quot;/&gt;&lt;/p&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;strong&gt;connHolder.releaseConnection()&lt;/strong&gt;对应“&lt;strong&gt;连接的释放&lt;/strong&gt;”中提到的步骤1，此时连接只是被放入了available容器，并且有效期是永久；&lt;/p&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;strong&gt;return new HttpResponseProxy(response, null)&lt;/strong&gt;返回的ConnectionHolder是null，结合IOUtils.closeQuietly(httpResponse)的具体实现，连接并没有及时关闭，而是永久的放在了available容器里，并且状态为CLOSE_WAIT，无法被复用；&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.3257261410788382&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/4g5IMGibSxt6ANHib9N7picyuomWhjsuEury97ZSUqBu8yZIdicKIA686T3XH6UT9hxMbCCP88XKMCDLEclbrYXgDQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;482&quot;/&gt;&lt;/p&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;根据 “&lt;strong&gt;连接的产生与管理&lt;/strong&gt;”的步骤3的描述，在free容器为空的时候httpclient是能够主动释放available里的连接的，即使连接永久的放在了available容器里，理论上也不会造成连接永远无法释放；&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;然而再结合“&lt;strong&gt;连接的产生与管理&lt;/strong&gt;”的步骤4，当free容器为空了以后，从连接池获取连接时需要等待available容器里的连接被释放掉，整个过程是单线程的，效率极低，势必会造成拥堵，最终导致大量等待获取连接超时报错，这也与我们线上看到的场景相吻合。&lt;/p&gt;&lt;/section&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;四、总结&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;ol class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;连接池的主要功能有两个：连接的管理和连接的复用，在使用连接池的时候一定要注意只需关闭当前数据流，而不要每次都关闭连接，除非你的目标访问地址是完全随机的；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;maxTotal和maxPerRoute的设置一定要谨慎，合理的分配参数可以做到业务隔离，但如果无法准确做出评估，可以暂时设置成一样，或者用两个独立的httpclient实例；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;一定记得要设置长连接的有效期，用&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;PoolingHttpClientConnectionManager(60, TimeUnit.SECONDS)构造函数，尤其是调用量较大的情况，防止发生不可预知的问题；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;可以通过设置evictIdleConnections(5, TimeUnit.SECONDS)定时清理空闲连接，尤其是http接口响应时间短，并发量大的情况下，及时清理空闲连接，避免从连接池获取连接的时候发现连接过期再去关闭连接，能在一定程度上提高接口性能。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;五、写在最后&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;HttpClient作为当前使用最广泛的基于Java语言的Http调用框架，在笔者看来其存在两点明显不足：&lt;/p&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;ol class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;没有提供监控连接状态的入口，也没有提供能外部介入动态影响连接生命周期的扩展点，一旦线上出现问题可能就是致命的；&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;此外，其获取连接的方式是采用同步锁的方式，在并发较高的情况下存在一定的性能瓶颈，而且其对长连接的管理方式存在问题，稍不注意就会导致建立大量异常长连接而无法及时释放，造成系统性灾难。&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;END&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;span title=&quot;&quot; opera-tn-ra-cell=&quot;_$.pages:0.layers:0.comps:154.title1&quot;&gt;&lt;p&gt;猜你喜欢&lt;/p&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/div&gt;

          

          



           
                                
                    
        &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>ac51b5e622769376249ccebaaf1c6243</guid>
<title>Python爬虫之xpath语法及案例使用</title>
<link>https://toutiao.io/k/vx7c0aa</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;preview&quot;&gt;&lt;p&gt;---- 钢铁侠的知识库 2022.08.15&lt;/p&gt;

&lt;p&gt;我们在写Python爬虫时，经常需要对网页提取信息，如果用传统正则表达去写会增加很多工作量，此时需要一种对数据解析的方法，也就是本章要介绍的Xpath表达式。&lt;/p&gt;

&lt;h2&gt;Xpath是什么&lt;/h2&gt;

&lt;p&gt;XPath，全称 &lt;strong&gt;XML Path Language&lt;/strong&gt;，即 XML 路径语言，它是一门在 XML 文档中查找信息的语言。最初是用来搜寻 XML 文档的，但同样适用于 HTML 文档的搜索。所以在做爬虫时完全可以使用 XPath 做相应的信息抽取。&lt;/p&gt;

&lt;p&gt;XPath 的选择功能十分强大，它提供了非常简洁明了的路径选择表达式。另外，它还提供超过 100 个内置函数，用于字符串、数值、时间的匹配以及节点、序列的处理等，几乎所有想要定位的节点都可以用 XPath 来选取。&lt;/p&gt;

&lt;p&gt;下面介绍实战中常用的几个知识点，详细也可以看W3C介绍：&lt;a href=&quot;https://www.w3school.com.cn/xpath/index.asp&quot;&gt;https://www.w3school.com.cn/xpath/index.asp&lt;/a&gt;&lt;/p&gt;

&lt;h2&gt;Xpath语法介绍&lt;/h2&gt;

&lt;h3&gt;路径常用规则&lt;/h3&gt;

&lt;table&gt;&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;表达式&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;th&gt;实例&lt;/th&gt;
&lt;th/&gt;
&lt;/tr&gt;
&lt;/thead&gt;&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;nodename&lt;/td&gt;
&lt;td&gt;选取此节点的所有子节点&lt;/td&gt;
&lt;td&gt;xpath(&#x27;//div&#x27;)&lt;/td&gt;
&lt;td&gt;选取了div节点的所有子节点&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;/&lt;/td&gt;
&lt;td&gt;从根节点选取&lt;/td&gt;
&lt;td&gt;xpath(&#x27;/div&#x27;)&lt;/td&gt;
&lt;td&gt;从根节点上选取div节点&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;//&lt;/td&gt;
&lt;td&gt;选取所有当前节点，不考虑位置&lt;/td&gt;
&lt;td&gt;xpath(&#x27;//div&#x27;)&lt;/td&gt;
&lt;td&gt;选取所有的div节点&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;.&lt;/td&gt;
&lt;td&gt;选取当前节点&lt;/td&gt;
&lt;td&gt;xpath(&#x27;./div&#x27;)&lt;/td&gt;
&lt;td&gt;选取当前节点下的div节点&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;..&lt;/td&gt;
&lt;td&gt;选取当前节点的父节点&lt;/td&gt;
&lt;td&gt;xpath(&#x27;..&#x27;)&lt;/td&gt;
&lt;td&gt;回到上一个节点&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;@&lt;/td&gt;
&lt;td&gt;选取属性&lt;/td&gt;
&lt;td&gt;xpath（&#x27;//@calss&#x27;）&lt;/td&gt;
&lt;td&gt;选取所有的class属性&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;

&lt;h3&gt;谓语规则&lt;/h3&gt;

&lt;p&gt;谓语被嵌在方括号内，用来查找某个特定的节点或包含某个制定的值的节点&lt;/p&gt;

&lt;table&gt;&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;表达式&lt;/th&gt;
&lt;th&gt;结果&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;xpath(&#x27;/body/div[1]&#x27;)&lt;/td&gt;
&lt;td&gt;选取body下的第一个div节点&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;xpath(&#x27;/body/div[last()]&#x27;)&lt;/td&gt;
&lt;td&gt;选取body下最后一个div节点&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;xpath(&#x27;/body/div[last()-1]&#x27;)&lt;/td&gt;
&lt;td&gt;选取body下倒数第二个div节点&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;xpath(&#x27;/body/div[positon()&amp;lt;3]&#x27;)&lt;/td&gt;
&lt;td&gt;选取body下前两个div节点&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;xpath(&#x27;/body/div[@class]&#x27;)&lt;/td&gt;
&lt;td&gt;选取body下带有class属性的div节点&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;xpath(&#x27;/body/div[@class=&quot;main&quot;]&#x27;)&lt;/td&gt;
&lt;td&gt;选取body下class属性为main的div节点&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;xpath(&#x27;/body/div[price&amp;gt;35.00]&#x27;)&lt;/td&gt;
&lt;td&gt;选取body下price元素值大于35的div节点&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;

&lt;h3&gt;通配符&lt;/h3&gt;

&lt;p&gt;通配符来选取未知的XML元素&lt;/p&gt;

&lt;table&gt;&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;表达式&lt;/th&gt;
&lt;th&gt;结果&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;xpath（&#x27;/div/*&#x27;）&lt;/td&gt;
&lt;td&gt;选取div下的所有子节点&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;xpath(&#x27;/div[@*]&#x27;)&lt;/td&gt;
&lt;td&gt;选取所有带属性的div节点&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;

&lt;h3&gt;取多个路径&lt;/h3&gt;

&lt;p&gt;使用“|”运算符可以选取多个路径 &lt;/p&gt;

&lt;table&gt;&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;表达式&lt;/th&gt;
&lt;th&gt;结果&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;xpath(&#x27;//div|//table&#x27;)&lt;/td&gt;
&lt;td&gt;选取所有的div和table节点&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;

&lt;h3&gt;功能函数&lt;/h3&gt;

&lt;p&gt;使用功能函数能够更好的进行模糊搜索&lt;/p&gt;

&lt;table&gt;&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;函数&lt;/th&gt;
&lt;th&gt;用法&lt;/th&gt;
&lt;th&gt;解释&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;starts-with&lt;/td&gt;
&lt;td&gt;xpath(&#x27;//div[starts-with(@id,&quot;ma&quot;)]&#x27;)&lt;/td&gt;
&lt;td&gt;选取id值以ma开头的div节点&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;contains&lt;/td&gt;
&lt;td&gt;xpath(&#x27;//div[contains(@id,&quot;ma&quot;)]&#x27;)&lt;/td&gt;
&lt;td&gt;选取id值包含ma的div节点&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;and&lt;/td&gt;
&lt;td&gt;xpath(&#x27;//div[contains(@id,&quot;ma&quot;) and contains(@id,&quot;in&quot;)]&#x27;)&lt;/td&gt;
&lt;td&gt;选取id值包含ma和in的div节点&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;text()&lt;/td&gt;
&lt;td&gt;xpath(&#x27;//div[contains(text(),&quot;ma&quot;)]&#x27;)&lt;/td&gt;
&lt;td&gt;选取节点文本包含ma的div节点&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;

&lt;h3&gt;语法熟悉&lt;/h3&gt;

&lt;p&gt;下面举一段HTML文本进行语法热身，代码如下&lt;/p&gt;

&lt;pre lang=&quot;python&quot;&gt;&lt;code&gt;#!/usr/bin/env python
# -*- coding: utf-8 -*-
# time: 2022/8/8 0:05
# author: gangtie
# email: 648403020@qq.com
from lxml import etree

text = &#x27;&#x27;&#x27;
&amp;lt;div&amp;gt;
            &amp;lt;ul id=&#x27;ultest&#x27;&amp;gt;
                 &amp;lt;li class=&quot;item-0&quot;&amp;gt;&amp;lt;a href=&quot;link1.html&quot;&amp;gt;first item&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt;
                 &amp;lt;li class=&quot;item-1&quot;&amp;gt;&amp;lt;a href=&quot;link2.html&quot;&amp;gt;second item&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt;
                 &amp;lt;li class=&quot;item-inactive&quot;&amp;gt;&amp;lt;a href=&quot;link3.html&quot;&amp;gt;third item&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt;
                 &amp;lt;li class=&quot;item-1&quot;&amp;gt;&amp;lt;a href=&quot;link4.html&quot;&amp;gt;&amp;lt;span&amp;gt;fourth item&amp;lt;/span&amp;gt;&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt;
                 &amp;lt;li class=&quot;item-0&quot;&amp;gt;&amp;lt;a href=&quot;link5.html&quot;&amp;gt;fifth item&amp;lt;/a&amp;gt;
             &amp;lt;/ul&amp;gt;
         &amp;lt;/div&amp;gt;
&#x27;&#x27;&#x27;
# 调用HTML类进行初始化，这样就成功构造了一个XPath解析对象。
# 利用etree.HTML解析字符串
page = etree.HTML(text)   
print(type(page))

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以看到打印结果已经变成XML元素：&lt;/p&gt;

&lt;pre lang=&quot;python&quot;&gt;&lt;code&gt;&amp;lt;class &#x27;lxml.etree._Element&#x27;&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h4&gt;字符串转换HTML&lt;/h4&gt;

&lt;p&gt;字符串利用etree.HTML解析成html格式：&lt;/p&gt;

&lt;pre lang=&quot;python&quot;&gt;&lt;code&gt;print(etree.tostring(page,encoding=&#x27;utf-8&#x27;).decode(&#x27;utf-8&#x27;))

&lt;/code&gt;&lt;/pre&gt;

&lt;p/&gt;


&lt;p&gt;Process finished with exit code 0&lt;/p&gt;

&lt;pre&gt;&lt;code/&gt;&lt;/pre&gt;
&lt;p&gt;经过处理可以看到缺失的&lt;code&gt;&amp;lt;/li&amp;gt;&lt;/code&gt;也自动补全了，还自动添加html、body节点。&lt;/p&gt;

&lt;h4&gt;查找绝对路径&lt;/h4&gt;

&lt;p&gt;通过绝对路径获取a标签的所有内容&lt;/p&gt;

&lt;pre lang=&quot;python&quot;&gt;&lt;code&gt;a = page.xpath(&quot;/html/body/div/ul/li/a&quot;)
for i in a:
    print(i.text)

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;first item
second item
third item
None
fifth item&lt;/p&gt;

&lt;pre&gt;&lt;code/&gt;&lt;/pre&gt;
&lt;h4&gt;查找相对路径(常用)&lt;/h4&gt;

&lt;p&gt;查找所有li标签下的a标签内容&lt;/p&gt;

&lt;pre lang=&quot;python&quot;&gt;&lt;code&gt;html = etree.HTML(text)
a = html.xpath(&quot;//a/text()&quot;)
print(a)

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;[&#x27;first item&#x27;, &#x27;second item&#x27;, &#x27;third item&#x27;, &#x27;fifth item&#x27;]&lt;/p&gt;

&lt;pre&gt;&lt;code/&gt;&lt;/pre&gt;
&lt;h4&gt;当前标签节点&lt;/h4&gt;

&lt;p&gt;&lt;code&gt;.&lt;/code&gt; 表示选取当前标签的节点。&lt;/p&gt;

&lt;p&gt;我们先定位 ul 元素节点得到一个列表，打印当前节点列表得到第一个 ul，
接着打印 ul 节点的子节点 li，text()输出。&lt;/p&gt;

&lt;pre lang=&quot;python&quot;&gt;&lt;code&gt;page = etree.HTML(text)
ul = page.xpath(&quot;//ul&quot;)
print(ul)
print(ul[0].xpath(&quot;.&quot;))
print(ul[0].xpath(&quot;./li&quot;))
print(ul[0].xpath(&quot;./li/a/text()&quot;))

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;[&lt;element ul=&quot;&quot; at=&quot;&quot;&gt;]
[&lt;element ul=&quot;&quot; at=&quot;&quot;&gt;]
[&lt;element li=&quot;&quot; at=&quot;&quot;&gt;, &lt;element li=&quot;&quot; at=&quot;&quot;&gt;, &lt;element li=&quot;&quot; at=&quot;&quot;&gt;, &lt;element li=&quot;&quot; at=&quot;&quot;&gt;, &lt;element li=&quot;&quot; at=&quot;&quot;&gt;]
[&#x27;first item&#x27;, &#x27;second item&#x27;, &#x27;third item&#x27;, &#x27;fifth item&#x27;]&lt;/element&gt;&lt;/element&gt;&lt;/element&gt;&lt;/element&gt;&lt;/element&gt;&lt;/element&gt;&lt;/element&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code/&gt;&lt;/pre&gt;
&lt;h4&gt;父节点&lt;/h4&gt;

&lt;p&gt;&lt;code&gt;..&lt;/code&gt; 表示选取当前标签的父节点。&lt;/p&gt;

&lt;p&gt;可以看到得到ul的上一级div&lt;/p&gt;

&lt;pre lang=&quot;python&quot;&gt;&lt;code&gt;page = etree.HTML(text)
ul = page.xpath(&quot;//ul&quot;)
print(ul[0].xpath(&quot;.&quot;))
print(ul[0].xpath(&quot;..&quot;))

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;[&lt;element ul=&quot;&quot; at=&quot;&quot;&gt;]
[&lt;element div=&quot;&quot; at=&quot;&quot;&gt;]&lt;/element&gt;&lt;/element&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code/&gt;&lt;/pre&gt;
&lt;h4&gt;属性匹配&lt;/h4&gt;

&lt;p&gt;匹配时可以用@符号进行属性过滤
查找a标签下属性href值为link2.html的内容&lt;/p&gt;

&lt;pre lang=&quot;python&quot;&gt;&lt;code&gt;html = etree.HTML(text)
a = html.xpath(&quot;//a[@href=&#x27;link2.html&#x27;]/text()&quot;)
print(a)

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;[&#x27;second item&#x27;]&lt;/p&gt;

&lt;pre&gt;&lt;code/&gt;&lt;/pre&gt;
&lt;h4&gt;函数&lt;/h4&gt;

&lt;p&gt;last()：查找最后一个li标签里的a标签的href属性&lt;/p&gt;

&lt;pre lang=&quot;python&quot;&gt;&lt;code&gt;html = etree.HTML(text)
a = html.xpath(&quot;//li[last()]/a/text()&quot;)
print(a)

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;[&#x27;fifth item&#x27;]&lt;/p&gt;

&lt;pre&gt;&lt;code/&gt;&lt;/pre&gt;
&lt;p&gt;contains：查找a标签中属性href包含link的节点，并文本输出&lt;/p&gt;

&lt;pre lang=&quot;python&quot;&gt;&lt;code&gt;html = etree.HTML(text)
a = html.xpath(&quot;//a[contains(@href, &#x27;link&#x27;)]/text()&quot;)
print(a)

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;[&#x27;first item&#x27;, &#x27;second item&#x27;, &#x27;third item&#x27;, &#x27;fifth item&#x27;]&lt;/p&gt;

&lt;pre&gt;&lt;code/&gt;&lt;/pre&gt;
&lt;h2&gt;实战案例&lt;/h2&gt;

&lt;p&gt;上面说完基本用法，接下来做几个实战案例练练手。&lt;/p&gt;

&lt;h3&gt;案例一：豆瓣读书&lt;/h3&gt;

&lt;pre lang=&quot;python&quot;&gt;&lt;code&gt;#  -*-coding:utf8 -*-
# 1.请求并提取需要的字段
# 2.保存需要的数据
import requests
from lxml import etree

class DoubanBook():

    def __init__(self):
        self.base_url = &#x27;https://book.douban.com/chart?subcat=all&amp;amp;icn=index-topchart-popular&#x27;
        self.headers = {
            &#x27;User-Agent&#x27;: &#x27;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) &#x27;
                          &#x27;Chrome/104.0.0.0 Safari/537.36&#x27;
        }

    # 请求并提取需要的字段
    def crawl(self):
        res = requests.get(self.base_url, headers=self.headers)
        lis = etree.HTML(res.text).xpath(&#x27;//*[@id=&quot;content&quot;]/div/div[1]/ul/li&#x27;)
        # print(type(lis))
        books = []
        for li in lis:
            # print(etree.tostring(li,encoding=&#x27;utf-8&#x27;).decode(&#x27;utf-8&#x27;))
            # print(&quot;==================================================&quot;)
            title = &quot;&quot;.join(li.xpath(&quot;.//a[@class=&#x27;fleft&#x27;]/text()&quot;))
            score = &quot;&quot;.join(li.xpath(&quot;.//p[@class=&#x27;clearfix w250&#x27;]/span[2]/text()&quot;))
            # list输出带有[&#x27;\n                    刘瑜 / 2022-4 / 广西师范大学出版社 / 82.00元 / 精装\n                &#x27;]
            publishing = &quot;&quot;.join(li.xpath(&quot;.//p[@class=&#x27;subject-abstract color-gray&#x27;]/text()&quot;)).strip()
            book = {
                &#x27;title&#x27;: title,
                &#x27;score&#x27;: score,
                &#x27;publishing&#x27;: publishing,
            }
            books.append(book)
        self.save_data(books)

    def save_data(self, datas):
            with open(&#x27;books.txt&#x27;, &#x27;w&#x27;, encoding=&#x27;utf-8&#x27;) as f:
                f.write(str(datas))

    def run(self):
        self.crawl()

if __name__ == &#x27;__main__&#x27;:
    DoubanBook().run()
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;案例二：彼岸图片下载&lt;/h3&gt;

&lt;pre lang=&quot;python&quot;&gt;&lt;code&gt;#!/usr/bin/env python
# -*- coding: utf-8 -*-
# author: 钢铁知识库
# email: 648403020@qq.com

import os
import requests
from lxml import etree

# 彼岸图片下载
class BiAn():

    def __init__(self):
        self.url = &#x27;https://pic.netbian.com&#x27;
        self.headers = {
            &#x27;User-Agent&#x27;: &#x27;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) &#x27;
                          &#x27;Chrome/104.0.0.0 Safari/537.36&#x27;,
            &#x27;cookie&#x27;: &#x27;__yjs_duid=1_cb922eedbda97280755010e53b2caca41659183144320; Hm_lvt_c59f2e992a863c2744e1ba985abaea6c=1649863747,1660203266; zkhanecookieclassrecord=%2C23%2C54%2C55%2C66%2C60%2C; Hm_lpvt_c59f2e992a863c2744e1ba985abaea6c=1660207771; yjs_js_security_passport=1225f36e8501b4d95592e5e7d5202f4081149e51_1630209607_js&#x27;
        }
        # 如果目录不存在会报错
        if not os.path.exists(&#x27;BianPicture&#x27;):
            os.mkdir(&#x27;BianPicture&#x27;)

    # 请求拿到ul列表
    def crawl(self):
        res = requests.get(self.url, headers=self.headers)
        res.encoding = &#x27;gbk&#x27;
        uls = etree.HTML(res.text).xpath(&#x27;//div[@class=&quot;slist&quot;]/ul[@class=&quot;clearfix&quot;]/li&#x27;)
        # print(etree.tostring(uls,encoding=&#x27;gbk&#x27;).decode(&#x27;gbk&#x27;))

        # 循环拿到图片名、图片地址，拼接请求再次下载到图片
        for ul in uls:
            img_name = ul.xpath(&#x27;.//a/b/text()&#x27;)[0]
            img_src = ul.xpath(&#x27;.//a/span/img/@src&#x27;)[0]
            # print(img_name + img_src)
            img_url = self.url + img_src
            # 拼接后下载图片，转义Bytes
            img_res = requests.get(img_url, headers=self.headers).content
            img_path = &quot;BianPicture/&quot; + img_name + &quot;.jpg&quot;
            data = {
                &#x27;img_res&#x27;: img_res,
                &#x27;img_path&#x27;: img_path
            }
            self.save_data(data)

    # 数据保存逻辑
    def save_data(self, data):
        with open(data[&#x27;img_path&#x27;], &#x27;wb&#x27;) as f:
            f.write(data[&#x27;img_res&#x27;])
        # print(data)

    def run(self):
        self.crawl()

if __name__ == &#x27;__main__&#x27;:
    BiAn().run()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/img_convert/393bf933c5ce91b60536ffa81c991cb4.png&quot; alt=&quot;image-20220812165403134&quot;/&gt;&lt;/p&gt;

&lt;h3&gt;案例三：全国城市名称爬取&lt;/h3&gt;

&lt;pre lang=&quot;python&quot;&gt;&lt;code&gt;#!/usr/bin/env python
# -*- coding: utf-8 -*-
# author: 钢铁知识库
# email: 648403020@qq.com
import os

import requests
from lxml import etree

class CityName():
    def __init__(self):
        self.url = &#x27;https://www.aqistudy.cn/historydata/&#x27;
        self.headers = {
            &#x27;User-Agent&#x27;: &#x27;Mozilla/5.0 (Windows NT 6.1; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/104.0.0.0 Safari/537.36&#x27;
        }
        # 判断目录是否存在
        if not os.path.exists(&#x27;city_project&#x27;):
            os.mkdir(&#x27;city_project&#x27;)

    def crawl(self):
        res = requests.get(url=self.url, headers=self.headers).text
        uls = etree.HTML(res).xpath(&#x27;//div[@class=&quot;all&quot;]/div[2]/ul/div[2]/li&#x27;)

        all_city_name = list()
        for ul in uls:
            city_name = ul.xpath(&#x27;.//a/text()&#x27;)[0]
            # print(type(city_name))
            all_city_name.append(city_name)
            self.save_data(all_city_name)

    def save_data(self, data):
        with open(&#x27;./city_project/city.txt&#x27;, &#x27;w&#x27;) as f:
            f.write(str(data))

    def run(self):
        self.crawl()

if __name__ == &#x27;__main__&#x27;:
    CityName().run()
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;xpath使用工具&lt;/h2&gt;

&lt;h3&gt;chrome生成XPath表达式&lt;/h3&gt;

&lt;p&gt;经常使用chome的朋友都应该知道这功能，在 &lt;code&gt;审查&lt;/code&gt; 状态下(快捷键ctrl+shift+i，F12)，定位到元素(快捷键ctrl+shift+c) ，在Elements选项卡中，右键元素 Copy-&amp;gt;Copy xpath，就能得到该元素的xpath了&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/img_convert/2a6d8f8b9ab4dd09ffc0ef74bcd95316.png&quot; alt=&quot;image-20220808172320534&quot;/&gt;&lt;/p&gt;

&lt;h3&gt;Xpath Helper插件&lt;/h3&gt;

&lt;p&gt;为chome装上XPath Helper就可以很轻松的检验自己的xpath是否正确了。安装插件需要科学上网，安装好插件后，在chrome右上角点插件的图标，调出插件的黑色界面，编辑好xpath表达式，表达式选中的元素被标记为黄色&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/img_convert/082fcb74e383529f489803f511c98fd0.png&quot; alt=&quot;image-20220808172538959&quot;/&gt;&lt;/p&gt;

&lt;p&gt;---- 钢铁侠的知识库 2022.08.15&lt;/p&gt;

&lt;h2&gt;结语：&lt;/h2&gt;

&lt;p&gt;以上就是利用XPath的所有用法，从常用语法，到案例练习都走了一遍。下一章 钢铁知识库 会继续介绍另一种好用的解析框架，Beautiful Soup，觉得有用点赞加关注，就当你送了红包666&lt;/p&gt;
&lt;/div&gt;
  &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>ea4f4e4a06073f669cd7ee9a4e55c9e4</guid>
<title>求求你别在用SpringMVC了，太Low了！Spring又官宣了一个更牛逼的替代框架！</title>
<link>https://toutiao.io/k/5gti4d9</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;spring-webflux&lt;/code&gt;是spring在5.0版本后提供的一套响应式编程风格的web开发框架。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个框架包含了&lt;code&gt;spring-framework&lt;/code&gt;和spring mvc，它可以运行在Netty、Undertow以及3.1版本以上的Serlvet容器上。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;你可以在项目中同时使用&lt;code&gt;spring-webmvc&lt;/code&gt;和&lt;code&gt;spring-webflux&lt;/code&gt;，或者只用其中一个来开发web应用。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;什么是“响应式”&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所谓响应式，举个例子，当调用一个api获取数据时，无需阻塞等待数据返回，而是当有数据返回时会进行告知。可见响应式是非阻塞的，意味着调用方法后，CPU可以去做别的事情，当接收到数据响应时CPU再回来处理，这种方式提高了系统的吞吐量。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;而响应式编程，其实是为这种异步非阻塞的流式编程制定的一套标准。流式编程已不陌生了，Java8提供的stream api就是这种风格。这套标准包括对运行环境（JVM、JavaScript）以及网络协议相关的规范。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;Spring-webflux的响应式API&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;Spring-webflux&lt;/code&gt;框架是基于Reactor这个开源项目开发的。Reactor框架是跟Spring紧密配合的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;它提供了两种API类型，分别是Mono和Flux；&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;// Mono一般作用于单个对象&lt;/span&gt;&lt;br/&gt;Mono&amp;lt;Person&amp;gt; person = personDao.getPerson(personId);&lt;br/&gt;&lt;span&gt;// Flux一般作用于多个对象&lt;/span&gt;&lt;br/&gt;Flux&amp;lt;Person&amp;gt; people = personDao.listAllPeople();&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;尽管webflux框架基于Reactor，它也能与其他的响应式框架同时使用，比如RxJava。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;选择Spring-webmvc还是Spring-webflux呢&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这两个web框架分别代表着两种不同类型的编程流派，官方给出了一个图作为对比如下&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5748792270531401&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/JfTPiahTHJhqIINVW9vuiaQD3u3u3Vo1t9ffrbJz8mfzVF0ItW7maqibNn85abyLzoIHRPr04bRNlOCy6tbJ1Ba8g/640?wx_fmt=png&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; data-type=&quot;png&quot; data-w=&quot;1656&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;根据官方的建议有以下几点可以作为参考：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;如果你已经使用了&lt;/span&gt;&lt;code&gt;&lt;span&gt;Spring-webmvc&lt;/span&gt;&lt;/code&gt;&lt;span&gt;进行开发，并且项目运行良好，就无需更改了；何况现在大多数的三方库都是阻塞的，并不能发挥出非阻塞的优势。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;code&gt;&lt;span&gt;webflux&lt;/span&gt;&lt;/code&gt;&lt;span&gt;提供了相当多的选择；在服务层，可以使用(Netty, Tomcat, Jetty, Undertow, 和3.1版本以上的Servlet容器)作为web服务；在应用层，可以选择用&lt;/span&gt;&lt;code&gt;&lt;span&gt;@Controller&lt;/span&gt;&lt;/code&gt;&lt;span&gt;定义还是使用函数编程定义；在编程风格上，可以选择用Reactor、RxJava或其他。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;如果你钟爱Java8提供的lambda表达式这种轻量级、函数式的编程风格，那么建议选择用webflux；同时对于一些轻量级应用，或者复杂度比较低的微服务，建议使用webflux以便更好的进行控制。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;在微服务架构中，可以将webmvc和webflux项目混合使用。两个框架都可以使用&lt;/span&gt;&lt;code&gt;&lt;span&gt;@Controller&lt;/span&gt;&lt;/code&gt;&lt;span&gt;这种注解的方式，使得项目的重用更加容易。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;评估一个项目是否应该选择webflux的最简单的方式是，依据项目中是否会使用很多的阻塞API，比如JDBC或者一些阻塞式的API就不适用与webflux项目。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;如果一个webmvc项目中有很多的外部系统调用，可以试试响应式的&lt;/span&gt;&lt;code&gt;&lt;span&gt;WebClient&lt;/span&gt;&lt;/code&gt;&lt;span&gt;，它能直接从&lt;/span&gt;&lt;code&gt;&lt;span&gt;Controller&lt;/span&gt;&lt;/code&gt;&lt;span&gt;的方法中返回响应式结果。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;响应式编程的学习路线是比较陡峭的，所以如果你身在一个大型的团队中，要考虑投入的成本；不过可以用用&lt;/span&gt;&lt;code&gt;&lt;span&gt;WebClient&lt;/span&gt;&lt;/code&gt;&lt;span&gt;来体验下响应式编程。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;Spring-webflux&lt;/code&gt;不仅可以支持在Tomcat、Jetty以及3.1版本以上的Servlet容器上，还能够运行在非Servlet的服务器之上，比如Netty、Undertow等。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;使用Springboot构建一个webflux应用，默认就是使用Netty，因为Netty本身就是非阻塞式的实现。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;并发模型&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;尽管webmvc和webflux都支持使用注解来定义一个Controller，但是其实现方式完全不同。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;webmvc是一个Servlet应用，实现是阻塞式IO，其维护一个线程池来处理每一个用户请求，也就是当Servlet容器启动时，就会创建比如10个线程出来，因此系统吞吐量的瓶颈在于有限的连接数和阻塞的请求处理过程。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;webflux可以基于netty这样的NIO网络框架，它只需要很少的几个工作线程（Event loop worker）就能够处理并响应请求。由于无需阻塞等待方法返回，CPU资源就得到了更好的利用。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;webflux并不能让程序运行地更快；而是提高了并发处理请求的能力，即提高了系统吞吐量。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;webflux代码示例&lt;/span&gt;&lt;/h3&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;Talk is cheap, show me the code&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;下面让我们来看一下webflux的示例，总的来说使用上是非常便捷的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们用Springboot构建一个webflux应用非常简单，仅仅需要加入这么一个依赖&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;&amp;lt;&lt;span&gt;dependency&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt; &lt;span&gt;&amp;lt;&lt;span&gt;groupId&lt;/span&gt;&amp;gt;&lt;/span&gt;org.springframework.boot&lt;span&gt;&amp;lt;/&lt;span&gt;groupId&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt; &lt;span&gt;&amp;lt;&lt;span&gt;artifactId&lt;/span&gt;&amp;gt;&lt;/span&gt;spring-boot-starter-webflux&lt;span&gt;&amp;lt;/&lt;span&gt;artifactId&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&amp;lt;/&lt;span&gt;dependency&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;首先定义一个对象&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;Person&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; Integer id;&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; Integer age;&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; String name;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;然后定义“&lt;code&gt;PersonController&lt;/code&gt;”，响应式风格中不再使用&lt;code&gt;@RequestMapping&lt;/code&gt;声明地址映射了，而是通过&lt;code&gt;RouterFunctions.route().GET()&lt;/code&gt;方法&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;@Configuration&lt;/span&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;PersonRouter&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;@Resource&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; PersonHandler personHandler;&lt;br/&gt;    &lt;span&gt;@Bean&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; RouterFunction&amp;lt;ServerResponse&amp;gt; &lt;span&gt;personRoutes&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; RouterFunctions.route()&lt;br/&gt;                .GET(&lt;span&gt;&quot;/person/{id}&quot;&lt;/span&gt;, RequestPredicates.accept(MediaType.APPLICATION_JSON), personHandler::getPerson)&lt;br/&gt;                .GET(&lt;span&gt;&quot;/person&quot;&lt;/span&gt;, RequestPredicates.accept(MediaType.APPLICATION_JSON), personHandler::listPeople)&lt;br/&gt;                .POST(&lt;span&gt;&quot;/person&quot;&lt;/span&gt;, personHandler::createPerson)&lt;br/&gt;                .build();&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在&lt;code&gt;PersonHandler&lt;/code&gt;中处理对应的HTTP请求，等同于MVC架构中的Service层&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;@Component&lt;/span&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;PersonHandler&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@Resource&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; PersonRepository personDao;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; Mono&amp;lt;ServerResponse&amp;gt; &lt;span&gt;listPeople&lt;/span&gt;&lt;span&gt;(ServerRequest request)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        Flux&amp;lt;Person&amp;gt; people = personDao.listAllPeople();&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; ServerResponse.ok()&lt;br/&gt;                .contentType(MediaType.APPLICATION_JSON)&lt;br/&gt;                .body(people, Person&lt;span&gt;.&lt;span&gt;class&lt;/span&gt;)&lt;/span&gt;;&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; Mono&amp;lt;ServerResponse&amp;gt; &lt;span&gt;createPerson&lt;/span&gt;&lt;span&gt;(ServerRequest request)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        Mono&amp;lt;Person&amp;gt; person = request.bodyToMono(Person&lt;span&gt;.&lt;span&gt;class&lt;/span&gt;)&lt;/span&gt;;&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; ServerResponse.ok()&lt;br/&gt;                .build(personDao.savePerson(person));&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; Mono&amp;lt;ServerResponse&amp;gt; &lt;span&gt;getPerson&lt;/span&gt;&lt;span&gt;(ServerRequest request)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;int&lt;/span&gt; personId = Integer.parseInt(request.pathVariable(&lt;span&gt;&quot;id&quot;&lt;/span&gt;));&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; personDao.getPerson(personId)&lt;br/&gt;                .flatMap(person -&amp;gt; ServerResponse.ok().contentType(MediaType.APPLICATION_JSON).bodyValue(person))&lt;br/&gt;                .switchIfEmpty(ServerResponse.notFound().build());&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;通过启动日志可以证实&lt;code&gt;Spring-webflux&lt;/code&gt;是默认使用Netty提供HTTP服务&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.055741360089186176&quot; data-type=&quot;png&quot; data-w=&quot;1794&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/JfTPiahTHJhqIINVW9vuiaQD3u3u3Vo1t9JxwrQB8YibHJkS2ZuIRmAQbEML4zUmJIuTTWKOtCAsYFMY0J7T3Xb6Q/640?wx_fmt=png&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;项目启动之后浏览器访问&lt;code&gt;http://localhost:8080/person/1&lt;/code&gt;就能发现，你的Spring-webflux项目已经正常工作了。&lt;/p&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>4313c6c0e5c9edd9568123ea8f7fd873</guid>
<title>从Golang调度器的作者视角探究其设计之道！</title>
<link>https://toutiao.io/k/5vxv78h</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content                                       &quot; id=&quot;js_content&quot;&gt;&lt;p&gt;&lt;span&gt;导语 |&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;&lt;span&gt;G&lt;/span&gt;&lt;/span&gt;&lt;span&gt;olang核心开发人员、goroutine调度的设计者Dmitry Vyukov，在2019年的一个talk里深入浅出地阐述了goroutine调度的设计思想以及一些优化的细节。本文是笔者结合自身经验和认知的一点观后感，采用从零开始层层递进的方法，总结剖析了其背后的软件设计思想，希望对读者更好地理解goroutine调度GMP模型会有所帮助。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section mpa-from-tpl=&quot;t&quot; data-mpa-template=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;span&gt;&lt;strong mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;前言&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p data-lines=&quot;2&quot; data-type=&quot;p&quot; data-sign=&quot;966abf0788d42166032df9b8208943b7&quot;&gt;&lt;strong&gt;视频地址：&lt;/strong&gt;&lt;/p&gt;&lt;p data-lines=&quot;2&quot; data-type=&quot;p&quot; data-sign=&quot;966abf0788d42166032df9b8208943b7&quot;&gt;&lt;span&gt;https://2019.hydraconf.com/2019/talks/7336ginp0kke7n4yxxjvld/&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;这个视频我以前看过，近几天刷到便又看了一遍，真是有听君一席话受益匪浅之感。毫不夸张地说，本视频在笔者看过的所有资料中，对于GMP为什么要有Processor这点，讲得最为清楚。视频中对goroutine调度模型的讲解，真可谓深入浅出！下面笔者将自己的一些观感整理分享给大家，还没看过视频的同学，建议先看完本文再去看，收获会更大。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;为了表达方便，本文会沿用golang里面的GMP缩写：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;G —— goroutine&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;M —— 机器线程&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;P —— 对处理器的抽象&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section mpa-from-tpl=&quot;t&quot; data-mpa-template=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;span&gt;&lt;strong mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;一、设计并发编程模型&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;goroutine调度的设计目标，其实就是设计一种高效的并发编程模型：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;我们可以近似将goroutine看待为协程（一些代码逻辑+一个栈上下文），如果读者用C/C++造过协程框架的轮子，会很容易理解这点。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;注&lt;/strong&gt;&lt;span&gt;：除了高效之外，还有其他几个目标，如无大小限制的goroutine栈，公平的调度策略等。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section mpa-from-tpl=&quot;t&quot; data-mpa-template=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;span&gt;&lt;strong mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;二、从零开始：从多线程说起&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;想要实现并发的执行流，最直截了当的，自然就是多线程。由此便得出初始思路：&lt;/span&gt;&lt;strong&gt;每个goroutine对应一个线程&lt;/strong&gt;&lt;span&gt;。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;从并发的功能角度来讲，该方案固然可以实现并发，但性能方面却很不堪，尤其是在并发很重的时候，成千上万个线程的资源占用、创建销毁、调度带来的开销会很巨大。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section mpa-from-tpl=&quot;t&quot; data-mpa-template=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;span&gt;&lt;strong mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;三、更进一步：线程池的方案&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;既然线程太多不好，那我们可以很轻易地做出一点改善，控制一下线程数量，如此便得到更进一步的方案：线程池，限定只启动N个线程。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;由于该方案下，可能是M个goroutine，N个线程，因而显然需要考虑一个问题：对于一个goroutine，它到底该由哪个线程去执行？我们可以简单地采用一个全局的Global Run Queue，然后让所有线程主动去获取goroutine来执行，示意如下：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.5293072824156305&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/VY8SELNGe97qkBuNjF5nzeQLW7G2OfjGwRrfb85Khl4yPUwTQVkT200TQXib3EWDp5UASib8oBJibQVR5uIhdhOsA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1126&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;这样做在线程少的时候，如果调度行为不是很频繁，可能问题不大。但当线程较多时，就会有scalable的问题，mutex的互斥竞争会非常激烈（考虑到基于时间片的抢占行为，实际上调度必然是很频繁的）。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section mpa-from-tpl=&quot;t&quot; data-mpa-template=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;span&gt;&lt;strong mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;四、初具雏形：线程分治&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在多线程编程领域中，互斥处理可以称得上是“名声在外”，需极其小心地去应对。最常见的解决方案，并不是如何精妙地去lock free，而是直接通过 “数据分治”和“逻辑分治”来避免做复杂的加锁互斥，将各个线程按横向（载荷分组）或纵向（逻辑划分）进行切分来处理工作。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;通过数据分治的思想，我们就可以得到改进的方案：每个线程分别处理一批G，进行线程分治。将所有G分开放到各线程自己的存储中，即所谓的Local Run Queue中。示意如下：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.8433566433566434&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/VY8SELNGe97qkBuNjF5nzeQLW7G2OfjGxJ4ku0gAyfBdqZJJ0lVxpnCibkxYE4rgezknDfFTvVe9euhPXFmY0Qw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;715&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;注&lt;/strong&gt;&lt;span&gt;：Global Run Queue也还继续存在的，有关它存在的细节非本文重点，这里不做展开。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;至此，调度模型已具雏形。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;让我们继续分析确认一下，该模型是否真的解决了scalable的问题。上述模型下，为了充分利用CPU，每个线程要按一定的策略去Steal其他线程Local Run Queue里面的G来执行，以免线程之间存在load balance问题（有些太闲，有些又太忙）&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;因此在线程很多的时候，存在大量的无意义加锁Steal操作，因为其他线程的Local Run Queue可能也常常都是空的。还有另一个问题，由于现在的一些内存资源是绑定在线程上面的，会导致线程数量和资源占用规模紧耦合。当线程数量多的时候，资源消耗也会比较大。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;注：在N核的机器环境下，假如我们设定线程池大小为N，由于系统调用的存在（关于系统调用的处理见后文），实际的线程数量会超过N。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section mpa-from-tpl=&quot;t&quot; data-mpa-template=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;span&gt;&lt;strong mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;五、趋于完善：将资源和线程解耦&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;既然每个线程一份资源也不合适，那么我们可以仿照线程池的思路，单独做一个资源池，做计算存储分离：把Local Run Queue及相关存储资源都挪出去，并依然限定全局一共N份，即可实现资源规模与系统中的真实线程数量的解耦。线程每次从对应的数据结构（Processor）中获取goroutine去执行，Local Run Queue及其他一些相关存储资源都挂在Processor下。这样加一层Processor的抽象之后，便得到众所周知的GMP模型：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.6363636363636364&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/VY8SELNGe97qkBuNjF5nzeQLW7G2OfjGWu6LuNMv5twyHIWN855hYibZHdusJukJfbpKGQsdYVq3ibABHVYWjpZA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;924&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;现在的调度模型已趋于完善，不过前面我们主要侧重讲的是如何高效，还未讨论到调度的另一个关键问题：&lt;/span&gt;&lt;strong&gt;公平性与抢占&lt;/strong&gt;&lt;span&gt;，接下来我们看看如何实现抢占。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section mpa-from-tpl=&quot;t&quot; data-mpa-template=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;span&gt;&lt;strong mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;六、还要公平：调度抢占&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;参考操作系统CPU的调度策略，通常各进程会分时间片，时间片用完了就轮到其他进程。在golang里也可以如此，不能让一些goroutine长期霸占着运行资源不退出，必须实现基于时间片的“抢占”。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;那怎么抢占呢，需要监测goroutine执行时间片是否用完了。如果要检查系统中的各种状态变化、事件发生情况，通常会有中断与轮询两种思路，中断是由一个中控方来做检查与控制，而轮询则是各个参与方按一定的策略主动check询问。因此对于goroutine抢占而言，有以下两种解决方案：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;二者的&lt;/span&gt;&lt;strong&gt;优劣对比&lt;/strong&gt;&lt;span&gt;如下：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.39820359281437123&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/VY8SELNGe97qkBuNjF5nzeQLW7G2OfjGS1X8Qd9Nea1hfkMfLUjJljhmic1UwCicr1jX1qLQ810uHzDBsE2PwFfQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1002&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;因为golang其实是有runtime的，而且代码编译生成也都是golang编译器控制的，综合优劣分析，选择后者会比较合理。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;对于Cooperative checks的方案，从代码编译生成的角度看，很容易做check指令的埋点。且因为golang本来就要做动态增长栈，在函数入口处会插入检查是否该扩栈的指令，正好利用这一点来做相关的检查实现（这里有一些优化细节，可以使得基于时间片的抢占开销也较小）&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;插入check指令的做法，会导致该方案存在一个理论缺陷：若有一个死循环，里面的所有代码都不包含check指令，那依然会无法抢占，不过现实中基本不存在这种情况，总会做函数调用、访问channel等类似操作，因此不足为虑。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;除此以外还有一个系统调用的问题，当线程一旦进入系统调用后，也会脱离runtime的控制。试想万一系统调用阻塞了呢，基于Cooperative checks的方案，此时又无法进行抢占，是不是整个线程也就罢工了。所以为了维持整个调度体系的高效运转，必然要在进入系统调用之前要做点什么以防患未然。Dmitry这里采用的办法也很直接，对于即将进入系统调用的线程，不做抢占，而是由它主动让出执行权。线程A在系统调用之前handoff让出Processor的执行权，唤醒一个idle线程B来做交接。当线程A从系统调用返回时，不会继续执行，而是将G放到run queue，然后进入idle状态等待唤醒，这样一来便能确保活跃线程数依然与Processor数量相同。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section mpa-from-tpl=&quot;t&quot; data-mpa-template=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;span&gt;&lt;strong mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;七、设计思想的小结&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;这里recap一下，把前文涉及到的一些软件设计思想罗列如下：&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;加一层，这个是万能大法，不赘述。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section mpa-from-tpl=&quot;t&quot; data-mpa-template=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;span&gt;&lt;strong mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;八、视频的其他内容&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;本文的重点在GMP模型，因此视频里还有一些其他的内容，文中并未详细展开：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;以上这些内容，大家可以去视频学习。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;注&lt;/strong&gt;&lt;span&gt;：本文基于2019的talk，不知最新版本的调度机制是否有进一步的调整，不过无论调整与否，这并不妨碍我们对GMP设计思想的学习。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section mpa-from-tpl=&quot;t&quot; data-mpa-template=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;span&gt;&lt;strong mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;九、进一步的改进&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;有&lt;/span&gt;&lt;span&gt;同学在与笔者讨论时提了&lt;/span&gt;&lt;span&gt;一个问题：&lt;/span&gt;&lt;strong&gt;还可以怎么继续优化&lt;/strong&gt;&lt;span&gt;，这真的是一个非常好的问题，这里将该问题的回答也放入文章。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;不单纯针对GMP，话题稍微放大一点，下面简单聊聊goroutine调度机制的一些优化可能。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Dmitry自己在视频最后说的future work方向：&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;以下纯属个人探讨：&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;目前就先想到这些，欢迎讨论。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section mpa-from-tpl=&quot;t&quot; data-mpa-template=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;span&gt;&lt;strong mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;十、欢乐游戏的协程框架&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;基于上面那个问题的回答，这里也补充介绍一下欢乐游戏协程框架（&lt;/span&gt;&lt;strong&gt;基于C++&lt;/strong&gt;&lt;span&gt;）中采用的处理机制，因为是纯业务自用，所以从设计要求上就低很多，不少点直接都可以不去考虑（这也说明了，有些时候再好的既有流行方案，从性能上讲可能也比不过自家的破轮子，当然自家的轮子泛化不足，肯定普适性就会差很多）&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;协程调度完全不考虑公平性，全部采用主动handoff策略&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;对于某个协程，如果它要持续运行，就任它运行，直到要进行阻塞类操作（典型如RPC调用），才会交出执行权。&lt;/span&gt;&lt;span&gt;实际上对于业务来讲，微观层面几十毫秒内哪个协程多占了一点执行权真的无所谓，不用太讲究公平性。&lt;/span&gt;&lt;span&gt;假如真的有些协程饿死了，那说明业务都已经过载了（就是时时刻刻都在跑其他协程，cpu&lt;/span&gt;&lt;span&gt;100），此时讨论公平也没什么意义了。&lt;/span&gt;&lt;span&gt;假如我们真的要做，因为做不到指令插入，只能采用&lt;/span&gt;&lt;span&gt;Signals&lt;/span&gt;&lt;span&gt;信号中断的方式，在注册的信号处理函数中直接按需切栈。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.4885114885114885&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/VY8SELNGe97qkBuNjF5nzeQLW7G2OfjGGRtV2IxnfU5ABLm9X4eCVBkyVRx0icaHrI7mmF67FmKmmcqa9nyD33Q/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1001&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;协程切换示意图，图注：1、2、5在主协程，3、4在业务协程，主协程和业务协程都在主线程内。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;总之，这种基于&lt;/span&gt;&lt;span&gt;逻辑分治&lt;/span&gt;&lt;span&gt;做线程拆分的改造都是很简单的，也并不会影响到核心协程调度的机制。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section mpa-from-tpl=&quot;t&quot; data-mpa-template=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;span&gt;&lt;strong mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt; 作者简介&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;105&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;105&quot; data-fileid=&quot;100044396&quot; data-ratio=&quot;1&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/VY8SELNGe97qkBuNjF5nzeQLW7G2OfjG4Gekw2DY7ydHIweaYxdBy0hV1dibpicGSZxxmj4kblNqshxVrCwHqiafA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;500&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;strong&gt;吴连火&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;span&gt;&lt;span/&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;腾讯游戏专家开发工程师&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span/&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot; viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;span&gt;腾讯游戏专家开发工程师，负责欢乐游戏大规模分布式服务器架构。有十余年微服务架构经验，擅长分布式系统领域，有丰富的高性能高可用实践经验，目前正带领团队完成云原生技术栈的全面转型。&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;hr/&gt;&lt;p&gt;&lt;strong&gt;推荐阅读&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-darkmode-bgcolor-15906318746582=&quot;rgb(36, 36, 36)&quot; data-darkmode-original-bgcolor-15906318746582=&quot;rgb(255, 255, 255)&quot; data-style=&quot;width: 30px; height: 30px; background-color: rgb(255, 255, 255); box-shadow: rgb(87, 187, 255) -7px -7px 0px; margin-left: 7px;&quot;&gt;&lt;span&gt;&lt;strong&gt;福利&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section data-darkmode-bgcolor-15906318746582=&quot;rgb(36, 36, 36)&quot; data-darkmode-original-bgcolor-15906318746582=&quot;rgb(255, 255, 255)&quot; data-style=&quot;width: 30px; height: 30px; background-color: rgb(255, 255, 255); box-shadow: rgb(87, 187, 255) -7px -7px 0px; margin-left: 7px;&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;section data-darkmode-bgcolor-15906318746582=&quot;rgb(36, 36, 36)&quot; data-darkmode-original-bgcolor-15906318746582=&quot;rgb(255, 255, 255)&quot; data-style=&quot;width: 30px; height: 30px; background-color: rgb(255, 255, 255); box-shadow: rgb(87, 187, 255) -7px -7px 0px; margin-left: 7px;&quot;&gt;&lt;span/&gt;&lt;span&gt;我为大家整理了一份&lt;/span&gt;&lt;span&gt;从入门到进阶的Go学习资料礼包&lt;/span&gt;&lt;span&gt;，包含学习建议：入门看什么，进阶看什么。&lt;/span&gt;&lt;span&gt;关注公众号 「polarisxu」，回复 &lt;/span&gt;&lt;strong&gt;&lt;span&gt;ebook&lt;/span&gt;&lt;/strong&gt;&lt;span&gt; 获取；还可以回复「&lt;strong&gt;进群&lt;/strong&gt;」，和数万 Gopher 交流学习。&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;1&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/UWba2ryLMqm8cgtrMXjG1BLGg46vQNmUompBL02uYYwic9RicPbCnlKdZiacBF5Wv6RLgmGIqnBnwuWyP82ibYusiag/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;258&quot;/&gt;&lt;/p&gt;&lt;/div&gt;

          

          



           
                                
                    
        &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>