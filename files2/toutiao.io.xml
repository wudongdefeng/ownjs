<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>bd8054297b851583950c22de1a42553d</guid>
<title>你可能也会掉进这个简单的 String 的坑</title>
<link>https://toutiao.io/k/sx3bbfh</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    

                    
                    
                    &lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot; data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-role=&quot;paragraph&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-width=&quot;100%&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;img data-ratio=&quot;0.8767123287671232&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/EeJSurrFuXN8k74xtBpeicuXWMy9AjmTs6CzLGRfp5KFzJ49EVSXDTYj2ntuToBNtenTjCEEZBueuthDIgO9yLA/640?wx_fmt=gif&quot; data-w=&quot;219&quot; data-width=&quot;100%&quot; data-type=&quot;gif&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;p data-brushtype=&quot;text&quot;&gt;&lt;span&gt;&lt;span&gt;点击上方&lt;/span&gt;&lt;span&gt;蓝色字体&lt;/span&gt;&lt;span&gt;，关注我 ——&lt;/span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-brushtype=&quot;text&quot;&gt;&lt;span&gt;一个在&lt;strong&gt;阿里云&lt;/strong&gt;打工的&lt;strong mpa-from-tpl=&quot;t&quot;&gt;清华&lt;/strong&gt;&lt;strong mpa-from-tpl=&quot;t&quot;&gt;学渣&lt;/strong&gt;!&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;578&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;434&quot; data-ratio=&quot;0.75&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/ZMXDhhGnYibsaPMW6maIBpAOTaKjfK9Eqnga3WVfozLGNK2qVBNoQOY9RpewOKzZLQFLgO8zULvr7ibHI5azcrjg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;图 by：石头@阿里巴巴飞天园区&lt;/span&gt;&lt;/p&gt;&lt;blockquote class=&quot;js_blockquote_wrap&quot; data-type=&quot;2&quot; data-url=&quot;&quot; data-author-name=&quot;&quot; data-content-utf8-length=&quot;79&quot; data-source-title=&quot;&quot;&gt;&lt;section class=&quot;js_blockquote_digest&quot;&gt;&lt;section&gt;&lt;span&gt;关于作者：程序猿石头(ID: tangleithu)，现任阿里巴巴技术专家，清华学渣，前大疆后端 Leader。欢迎关注，交流和指导！回复 &lt;/span&gt;&lt;span&gt;“0”&lt;/span&gt;&lt;span&gt; 送阿里技术大礼包。&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;/blockquote&gt;&lt;/section&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;背景&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;石头同学是某大公司高级开发工程师，某日收到不少错误告警信息，于是便去开始排查。&lt;/p&gt;&lt;p&gt;跟踪日志发现是某个服务抛出的异常信息，奇怪的是这个服务上线也有一段时间了。之前很少看到类似的错误信息，最近偶尔多了起来。&lt;/p&gt;&lt;p&gt;后来才定位到是因为服务调用了某外部接口，发现对方对参数长度做了限制，如果输入参数超过 1000 bytes，就直接抛异常，代码类似如下：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;/**&lt;br/&gt; * &lt;span&gt;@param&lt;/span&gt; status&lt;br/&gt; * &lt;span&gt;@param&lt;/span&gt; result, the size should less than 1000 bytes&lt;br/&gt; * &lt;span&gt;@throws&lt;/span&gt; Exception&lt;br/&gt; */&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;XXResult&lt;/span&gt;&lt;span&gt;(&lt;span&gt;boolean&lt;/span&gt; status, String result)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (result != &lt;span&gt;null&lt;/span&gt; &amp;amp;&amp;amp; result.getBytes().length &amp;gt; &lt;span&gt;1000&lt;/span&gt;) {&lt;br/&gt;        &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; RuntimeException(&lt;span&gt;&quot;result size more than 1000 bytes!&quot;&lt;/span&gt;);&lt;br/&gt;    }&lt;br/&gt;  ......&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;心想，这还不简单，咱们的 &lt;code&gt;result&lt;/code&gt; 也不是什么关键性的东西，你有限制，我直接 trim 一下不就行了？&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;1&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ZMXDhhGnYibsaPMW6maIBpAOTaKjfK9EqN1dSpOd6GkVbznYyIeAIiadoYUTOgLpdR7JRPrpbpYCAyEEDxvRKTwA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;255&quot;/&gt;&lt;/p&gt;&lt;h2&gt;&lt;span&gt;解决方案&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;于是三下五除二，给搞了个 &lt;code&gt;trim&lt;/code&gt; 方法，支持传不同参数按需 trim，代码如下：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;/**&lt;br/&gt; * 将给定的字符串 trim 到指定大小&lt;br/&gt; * &lt;span&gt;@param&lt;/span&gt; input&lt;br/&gt; * &lt;span&gt;@param&lt;/span&gt; trimTo 需要 trim 的字节长度&lt;br/&gt; * &lt;span&gt;@return&lt;/span&gt; trim 后的 String&lt;br/&gt; */&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; String &lt;span&gt;trimAsByte&lt;/span&gt;&lt;span&gt;(String input, &lt;span&gt;int&lt;/span&gt; trimTo)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (Objects.isNull(input)) {&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;;&lt;br/&gt;    }&lt;br/&gt;    &lt;span&gt;byte&lt;/span&gt;[] bytes = input.getBytes();&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (bytes.length &amp;gt; trimTo) {&lt;br/&gt;        &lt;span&gt;byte&lt;/span&gt; [] subArray = Arrays.copyOfRange(bytes, &lt;span&gt;0&lt;/span&gt;, trimTo);&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; String(subArray);&lt;br/&gt;    }&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; input;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;再在需要调用外部服务的地方，先调用这个 &lt;code&gt;trimAsByte&lt;/code&gt; 方法，一顿操作连忙上线，一切完美~&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;1&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/ZMXDhhGnYibsaPMW6maIBpAOTaKjfK9EqAzicf99qCGuOLzwbw4DiaibhH8SZsFcSYfqjnjjS0icRpbmuYMV09C2FMQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;400&quot;/&gt;&lt;/p&gt;&lt;h2&gt;&lt;span&gt;灾难现场&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;一切完美，石头哥也是这样认为的。然后幸福总是短暂的。&lt;/p&gt;&lt;p&gt;经过一段时间后（前面也提到，业务场景确实是偶发的），相同的错误仍然发生了。&lt;span/&gt;&lt;/p&gt;&lt;p&gt;简直不敢相信，都 trim 了为啥还会超出？&lt;span&gt;你也帮忙想想，是哪里的问题？&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;1&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/ZMXDhhGnYibsaPMW6maIBpAOTaKjfK9EqwevSDx2Oia5icghpciaLykibgGylZU1bcASI26syXVuMibEZdOZTvqBhvFA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;300&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.3003337041156841&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ZMXDhhGnYibsaPMW6maIBpAOTaKjfK9Eq46yoWLzwibo73n6alrRmtXM6ChTAUMs4MnH127z2ah4THxWwXNviar5A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1798&quot;/&gt;&lt;/p&gt;&lt;p&gt;看看上面的例子（为了方便展示，简单修改文首代码了下），&lt;/p&gt;&lt;pre&gt;&lt;code&gt;trimAsByte(&lt;span&gt;&quot;WeChat:tangleithu&quot;&lt;/span&gt;, &lt;span&gt;8&lt;/span&gt;)&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;输入字符串 &lt;code&gt;WeChat:tangleithu&lt;/code&gt; 太长了，只 trim 到剩下 8 个字节，对应的字节数组是从 &lt;code&gt;[87,101,67,104,97,116,58,116,97,110,103,108,101,105,116,104,117]&lt;/code&gt; 变为了 &lt;code&gt;[87,101,67,104,97,116,58,116]&lt;/code&gt;，字符串变成了 &lt;code&gt;WeChat:t&lt;/code&gt; ，结果正确。&lt;/p&gt;&lt;p&gt;其实在写这个方法的时候还是太草率了，本应该很容易想到中文的情况的，我们来试试：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;trimAsByte(&lt;span&gt;&quot;程序猿石头&quot;&lt;/span&gt;, &lt;span&gt;8&lt;/span&gt;)&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.300768386388584&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ZMXDhhGnYibsaPMW6maIBpAOTaKjfK9EqOKWFelSpbTJdtelrzIJQZnbIBFKHRiaREIxOIibWibLcxBVd0VC8vnHug/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1822&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;看上述截图，悲剧了，输入&lt;code&gt;程序猿石头&lt;/code&gt;，3 个字节一个汉字，一共 15 个字节 &lt;code&gt;[-25,-88,-117,-27,-70,-113,-25,-116,-65,-25,-97,-77,-27,-92,-76]&lt;/code&gt;，trim 到 8 位，剩下前 8 位 &lt;code&gt;[-25,-88,-117,-27,-70,-113,-25,-116]&lt;/code&gt; 也正确。再 &lt;code&gt;new String&lt;/code&gt;，&lt;/span&gt;又&lt;span&gt;变成3 个 “中文” 了，虽然第 3 个“中文”，咱也不认识，咱也不敢问到底读啥，总之再转换成字节数组，长度多了 1 个，变成 9 了。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.5179372197309418&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ZMXDhhGnYibsaPMW6maIBpAOTaKjfK9EqgibpKicSmTicwSjAKyiaYLdWH7Appxfv68ZQxMJEictibs82oDU2Ve02aJWg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;892&quot;/&gt;&lt;/p&gt;&lt;p&gt;问题算是定位到了。&lt;/p&gt;&lt;h2&gt;&lt;span&gt;不禁要问，为什么？&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;来看看这个 String 的构造函数，看看上面注释才发现，其实我们忽略了一个很重要的概念，就是编码方式。&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;/**&lt;br/&gt; * Constructs a new {&lt;span&gt;@code&lt;/span&gt; String} by decoding the specified array of bytes&lt;br/&gt; * using the platform&#x27;s default charset.  The length of the new {&lt;span&gt;@code&lt;/span&gt;&lt;br/&gt; * String} is a function of the charset, and hence may not be equal to the&lt;br/&gt; * length of the byte array.&lt;br/&gt; *&lt;br/&gt; * &amp;lt;p&amp;gt; The behavior of this constructor when the given bytes are not valid&lt;br/&gt; * in the default charset is unspecified.  The {&lt;span&gt;@link&lt;/span&gt;&lt;br/&gt; * java.nio.charset.CharsetDecoder} class should be used when more control&lt;br/&gt; * over the decoding process is required.&lt;br/&gt; *&lt;br/&gt; * &lt;span&gt;@param&lt;/span&gt;  bytes&lt;br/&gt; *         The bytes to be decoded into characters&lt;br/&gt; *&lt;br/&gt; * &lt;span&gt;@since&lt;/span&gt;  JDK1.1&lt;br/&gt; */&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;String&lt;/span&gt;&lt;span&gt;(&lt;span&gt;byte&lt;/span&gt; bytes[])&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;//this(bytes, 0, bytes.length);&lt;/span&gt;&lt;br/&gt;    checkBounds(bytes, offset, length);&lt;br/&gt;    &lt;span&gt;this&lt;/span&gt;.value = StringCoding.decode(bytes, offset, length);&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;当我们用默认的构造函数 new String 的时候，只是用了系统默认的编码（本文是“UTF-8”）去尝试解码，构造出字符串。&lt;/p&gt;&lt;p&gt;所以，当我们在用字节数组（字节流）来表达具体的语义的时候，一定要约定好以什么方式进行编码，本文不具体阐述编码问题了。下面用一个例子来解释上文的现象：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;1.0159045725646123&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ZMXDhhGnYibsaPMW6maIBpAOTaKjfK9EqiahPs6wm3RV887WUWQZURrklGHqEK8N7u3myyBBAqyic4BV4fErNm27w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1006&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;code&gt;[-25,-88,-117,-27,-70,-113,-25,-116,-65,-25,-97,-77,-27,-92,-76]&lt;/code&gt; 仍然用这串字节数组来实验，这串字节数组，如果用 “UTF-8” 编码去解释，那么其想表达的语义就是中文“程序猿石头”，从上文标注的 1，2，3 中可以看出来，没有写即用了系统中的默认编码“UTF-8”。&lt;/p&gt;&lt;p&gt;假设按照 “GBK” 来解释（标注 4），就是表达的 “绋嬪簭鐚跨煶澶�”，注意看下其中的 &lt;code&gt;�&lt;/code&gt; 是不是似曾相识；&lt;/p&gt;&lt;p&gt;注意标注 5，通过 GBK 解释构造字符串后，再通过默认的 “UTF-8” 获取字节数组，长度就变成 24 了，然后还通过 “GBK” 编码得到的字节数组长度为 15（标注 6），再试图构造字符串（标注 7），其中“程序猿石头”的“头”字，已经没了。说明这个转换过程中，其实信息已经被丢了。&lt;/p&gt;&lt;p&gt;上面的 &lt;code&gt;�&lt;/code&gt; 其实是 UNICODE 编码方式中的一个特殊的字符，也就是 0xFFFD(65535)，其实是一个占位符(REPLACEMENT CHARACTER)，用来表达未知的、没办法表达的东东。上文中在进行编码转换过程中，出现了这个玩意，其实也就是没办法准确表达含义，会被替换成这个东西，因此信息也就丢失了。你可以试试前面的例子，比如把前 8 个字节中的最后一两个字节随便改改，都是一样的。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.7334710743801653&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ZMXDhhGnYibsaPMW6maIBpAOTaKjfK9EqGzZA2L7rLwGIuqmYhDwYAicI1vNJbD6oZGcsPnMsOHk9lhGh1nB6QCw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;968&quot;/&gt;&lt;/p&gt;&lt;figure&gt;&lt;figcaption&gt;程序猿石头：65533 示例&lt;/figcaption&gt;&lt;/figure&gt;&lt;h2&gt;&lt;span&gt;总结&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;总结一下，其实本来是一个很简单的问题，却经过几次修改才最终解决，说明对 “基础” 掌握得还是不够，一个重要的点是，在处理二进制数据的时候，一定要联想到 “编码” 方式。&lt;/p&gt;&lt;p&gt;另外，提醒我们，看似简单的问题，我们往往容易忽略。比如如果单纯看到文中提到的这个&lt;code&gt;trim&lt;/code&gt; 方法，其实很容易写个&lt;span&gt;&lt;strong&gt;单元测试&lt;/strong&gt;&lt;/span&gt;就能尽早发现有问题；&lt;/p&gt;&lt;p&gt;越是基础的方法，我们越应该考虑其代码的健壮性，在之前的 &lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzI3OTUzMzcwNw==&amp;amp;mid=2247484698&amp;amp;idx=1&amp;amp;sn=03cc4636e7ee7364a85788a98809cc03&amp;amp;chksm=eb4704fedc308de8efd48ab9aed4fd1ddee5665d8e76d0d3767c1f704eac8b15a83e450a08f1&amp;amp;token=1702436273&amp;amp;lang=zh_CN&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;从一道面试题谈谈一线大厂码农应该具备的基本能力&lt;/a&gt; 中，我也谈到了写单元测试、测试用例的重要性。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;后记&lt;/span&gt;&lt;span/&gt;&lt;br/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;觉得本号分享的文章有价值，记得添加星标哦。周更很累，不要白 piao，需要来点正反馈，安排个 “&lt;/span&gt;&lt;span&gt;一键三连&lt;/span&gt;&lt;span&gt;”（点赞、在看、分享）如何？😝 这将是我持续输出优质文章的最强动力。&lt;/span&gt;&lt;/p&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;img data-ratio=&quot;0.5763888888888888&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/ZMXDhhGnYibus0M9Ca9kxyicUG4QMG51vSh2LCtOpicfJwrribu5Zc8d9OKFIP2E5UhcJ9ctTEeG9Xv0ElRFJqv65A/640?wx_fmt=gif&quot; data-type=&quot;gif&quot; data-w=&quot;288&quot;/&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;strong mpa-from-tpl=&quot;t&quot;&gt;推 荐 阅 读&lt;/strong&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;span/&gt;&lt;span&gt;&lt;strong mpa-from-tpl=&quot;t&quot;&gt;&lt;img class=&quot;rich_pages __bg_gif&quot; data-before-oversubscription-url=&quot;https://mmbiz.qlogo.cn/mmbiz_gif/uwFfSFSf91seQScIvEVNUmicz8EaY909ichXz5pHkVN8AwtsHOVg6mYnOlib8icUjfWZJkX6IibVlx9vJhtQrYaIUjg/0?wx_fmt=gif&quot; data-ratio=&quot;0.8428571428571429&quot; data-s=&quot;300,640&quot; data-type=&quot;gif&quot; data-w=&quot;140&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/uwFfSFSf91seQScIvEVNUmicz8EaY909ichXz5pHkVN8AwtsHOVg6mYnOlib8icUjfWZJkX6IibVlx9vJhtQrYaIUjg/640?wx_fmt=gif&quot;/&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-tools-id=&quot;74666&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;程序猿石头 &lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;p&gt;&lt;span&gt;程序猿石头(ID: tangleithu)，现任阿里巴巴技术专家，清华学渣，前大疆后端 Leader。用不同的视角分享高质量技术文章，以每篇文章都让人有收获为目的，欢迎关注，交流和指导！扫码回复关键字 “&lt;/span&gt;&lt;span&gt;1024&lt;/span&gt;&lt;span&gt;” 获取&lt;/span&gt;&lt;span&gt;程序员大厂面试指南&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img data-backh=&quot;53&quot; data-backw=&quot;53&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;269&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;269&quot; data-ratio=&quot;1&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/ZMXDhhGnYibsGrjJaF5hvicrswVeQicFujwTxcfbYhd7y5cjEkf2nwDCFdiauYuqmHY3VDWyCbImg92mvoicoQ6Uk3g/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;258&quot;/&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>916ac2fc901cdd5ab5dc4728b692ce3d</guid>
<title>分布式数据网格 Data Mesh</title>
<link>https://toutiao.io/k/p6zp7x5</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;article__content&quot; itemprop=&quot;articleBody&quot;&gt;&lt;p&gt;ThoughtWorks最近一期的&lt;a href=&quot;https://www.thoughtworks.com/cn/radar/techniques/data-mesh&quot;&gt;技术雷达&lt;/a&gt;，把Data Mesh从“评估”调升到了“试验”。ThoughtWorks眼中的“试验”意味着这项技术“值得追求。重要的是理解如何建立这种能力。企业应该在风险可控的项目中尝试此技术。”&lt;/p&gt;

&lt;p&gt;文章内容大部分来自 Zhamak Dehghani 的&lt;a href=&quot;https://martinfowler.com/articles/data-monolith-to-mesh.html&quot;&gt;《How to Move Beyond a Monolithic Data Lake to a Distributed Data Mesh》&lt;/a&gt; 讲了如何将单体的数据湖，变为分布式的数据网格（Data Mesh）。&lt;/p&gt;

&lt;p&gt;那么，未来的企业数据中心，可能企业将告别建造单体的数据湖，转而成为分布式的数据水系么？&lt;/p&gt;



&lt;h1 id=&quot;如何从单体数据湖演进到分布式数据网格&quot;&gt;如何从单体数据湖演进到分布式数据网格&lt;/h1&gt;

&lt;p&gt;许多企业都在投资建设自己的下一代数据湖，希望通过数据洞察业务并做出智能决策。基于数据湖的数据平台架构，这样的单体架构存在共通的失败特征，不能达到建设时承诺过的服务标准。为了解决这些问题，我们需要转变这种集中式的数据湖或者数仓。我们需要一种现代的分布式架构：将“领域”作为首要考虑的因素，运用平台化的思维创建自助服务型的数据基础设施，并且将数据也视作一种产品。&lt;/p&gt;

&lt;p&gt;建设数据驱动的组织，是当前许多公司的首要目标。他们深知数据智为企业带来的好处：基于数据与个性化技术，提升的客户体验；数据驱动的运营成本优化；通过趋势分析和BI工具为员工赋能。他们也一直在大力投资构建数据和智能平台。然而构建数据平台虽然投入不菲，但是最后结果却一般般。&lt;/p&gt;

&lt;p&gt;我承认组织在转型数据驱动时，会面临诸多复杂问题：比如需要迁移十几年前的历史遗留系统，企业之前的内部文化并不欢迎数据加入，以及难以权衡的业务优先级。我所分享的架构理念，正是基于这诸多失败的数据平台建造过程，借鉴过去十年间在建造分布式架构，引入“数据领域”，这项新的企业数据架构，我称之为——数据网格（Data Mesh）。&lt;/p&gt;

&lt;p&gt;在继续阅读之前，请各位读者放下对传统数据平台架构建设理念的固有思维，尽可能地以开放的心态拥抱分布式数据网格架构。你需要面对这样一个事实：数据是永远存在的、是无处不在的、而且是分布式存在的。&lt;/p&gt;

&lt;h2 id=&quot;当前企业数据平台架构及其弊端&quot;&gt;当前企业数据平台架构及其弊端&lt;/h2&gt;

&lt;p&gt;当前企业的数据平台是：中心化、整体化、领域无关的，亦称数据湖。&lt;/p&gt;

&lt;p&gt;我接触过的所有客户，都正在构建或者计划构建他们的第三代数据智能平台，同时也认识到之前两代数据平台的不足：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;第一代： 专有的企业数据仓库和BI平台；虽然这是一个价格不菲的解决方案，但同样留下了不小的技术债务；技术债务存在于数千个难以维护的ETL作业，诸多表格和报告中，这些东西仅有少数专业人员能够理解他们。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;第二代： 大数据生态构建的数据湖，看起来似乎是银弹。复杂的大数据生态系统，长时间执行的批处理作业，必须由高度专业化的工程小组构建和维护，他们创造的是一个数据湖怪兽，但是充其量也只能完成一些研发分析；对比建设初期许下的承诺，显然有些差距。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;第三代数据平台和当前的架构或多或少有些类似，面向流的实时数据处理架构，比如Kappa； 批流一体的数据转换框架，比如Apache Beam；以及完全基于云的托管服务来存储、处理数据的流水线和机器学习平台。显而易见，第三代数据平台正在解决之前遇到的问题，比如实时数据处理，以及降低基础设施的管理成本。但是，这种架构依然面临着和之前两代一样的潜在弊端。&lt;/p&gt;

&lt;h3 id=&quot;架构弊端&quot;&gt;架构弊端&lt;/h3&gt;

&lt;p&gt;为了解释这些数据平台面临的潜在问题，我们看一下这些架构的特征。在本文中，以互联网流媒体业务为例（像Spotify，SoundCloud，Apple iTunes等）来阐明一些概念。&lt;/p&gt;

&lt;h4 id=&quot;集中式和单体式&quot;&gt;集中式和单体式&lt;/h4&gt;

&lt;p&gt;从三万英尺的高度看数据平台架构，就像下面图1所示。集中式的目标是：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;从企业的各个角落获取数据，包括运营系统、交易系统等等，也包括外部数据供应商。例如在流媒体业务中，数据平台会负责获取各种数据：“媒体播放器的性能”、“用户和播放器的交互”、“播放列表”、“关注的歌手”、“唱片公司和歌手”、和歌手之间的“金融结算”，以及外部市场调研数据（比如客户人口统计信息）等等。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;清洗，扩表，转换源数据到高质量数据，以满足数据消费端的需求。在我们的示例中，用户交互行为的点击流信息，扩充上用户的详细信息，这种转换将重建用户的行为到一个聚合视图中。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;向不同的数据需求方提供数据，需要提供不同种类的数据。从数据中分析消费，通过机器学习制定决策，通过BI报表展示业务表现，这些需求所需要的数据各不相同。在我们的流媒体示例中，平台可以近实时的从Kafka等分布式日志系统接口中取得全球范围内播放器的错误和播放质量信息，或者提供某个歌手的播放记录的聚合视图，以推动财务结算应付账款给歌手和唱片公司。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;/illustration/data-mesh-fig1.png&quot; alt=&quot;figure-1&quot;/&gt;
图1：三万英尺俯瞰单体数据平台&lt;/p&gt;

&lt;p&gt;单体架构平台上的集中托管的数据，在逻辑上其实并不属于相同的领域，比如：“播放事件”、“销售的KPI”、“歌手”、“唱片”、“唱片公司”、“音频”、“播客”、“音乐活动”等等；这些数据来自大量不同领域。&lt;/p&gt;

&lt;p&gt;过去十年间，尽管我们成功地将领域驱动设计（Domain Driven Design,DDD）和边界上下文（Bounded Context）应用于各类系统，但是我们在数据平台中却忽略了领域的概念。我们已经不知不觉地从“面向领域的数据所有权”转向了“集中式领域不明确的数据所有权”。我们以创造最大的单体大数据平台而骄傲。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/illustration/data-mesh-fig2.png&quot; alt=&quot;figure-2&quot;/&gt;
图2： 集中数据平台，没有明确的数据领域边界和面向领域数据的所有权。&lt;/p&gt;

&lt;p&gt;集中式的模型适用于较为简单的领域，数据消费端数量较少的情况；对于领域丰富，数据生产来源众多，数据消费者多样的企业并不适用。&lt;/p&gt;

&lt;p&gt;集中式的数据平台架构通常有两个压力点，经常导致数据平台是建设失败：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;分散的数据和源的不断增加：随着数据变得分散，单一平台的控制协调能力将会下降。想象一下，“客户信息”，在组织内外有各种各样的数据来源，提供现存和潜在客户的信息。随着数据源的不断增加，我们需要从各个数据源接入并存储到一个单一的位置。对于数据用途，数据科学家和分析师希望低成本的处理各个数据集，以运营为目的使用数据，和以分析目的使用数据的方式也并不相同。我的看法是，现有的集中式的解决方案，不是应对多领域，数据源持续新增的大企业的最佳解决方案。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;业务创新需求和数据消费多元化：业务方通常需要通过数据快速验证一些想法，这样的需求引入了大量的数据使用的案例。这意味着不同的数据处理任务数量也不断增长：聚合、投影、切片，以满足创新的测试和学习。长期以来，如何快速满足数据使用者的需求，一直是企业面临的问题，并且在现代数据平台架构中依然如此。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;但是需要澄清的是，我并不是要鼓吹之前那种隐藏在各个系统中的、分散、孤立、烟筒似的领域数据，这样的数据是难以被发现、理解和使用的。也不是鼓吹那些由于多年攒下的技术债务导致的分散成的多个数据孤岛。我的观点是，为了解决这些无法访问的数据孤岛问题，不应该是建立一个集中的数据平台，再搭上一个中心化的团队。这样就会面临我们前面提到的那些扩展性的问题。&lt;/p&gt;

&lt;h4 id=&quot;耦合数据流水线的拆分方式&quot;&gt;耦合数据流水线的拆分方式&lt;/h4&gt;

&lt;p&gt;传统数据平台架构的第二弊端是我们如何拆分体系结构。在一万英尺看集中式大数据平台的时候，我们会发现数据架构依据获取、清洗、聚合、服务等功能进行拆分。架构师会根据平台的增长进一步分解体系架构。架构师需要找到一个扩展系统，将其分解到架构单元（architectural quantum）。在《演进式构建》的描述中，一个“架构单元”是一个具备完整功能、高内聚、可独立部署的组件。将系统分解为单一结构单元的初衷，是方便划分独立的团队，每个人都可以构建和维护这个结构单元。团队之间并行工作以便增加系统的可扩展性和建设速度。&lt;/p&gt;

&lt;p&gt;考虑到前几代数据平台架构的影响，架构师通常将数据平台划分为一系列的数据处理阶段。围绕数据处理的技术实现，通过一条流水线实现一组功能。包括了数据获取、预处理、聚合、服务等功能。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/illustration/data-mesh-fig3.png&quot; alt=&quot;figure-3&quot;/&gt;
图3：数据平台的架构拆分方式&lt;/p&gt;

&lt;p&gt;尽管此模型可以提供一定程度的扩展，但是将团队分配到数据流水线上的不同阶段，具有一个固有的局限性，将功能交付速度拖慢。整条数据流水线在各个阶段都具有很高的耦合性，而这种拆分方式，流水线的拆分方向和流水线本身的变化方向，刚好是正交的。&lt;/p&gt;

&lt;p&gt;让我们看一下流媒体实例。互联网流媒体平台围绕他们的媒体类型，具有强大的面向领域建造能力。这些服务通常以“歌曲”和“专辑”开始，然后再扩展到“音乐活动”、“播客”、“电台SHOW”、“电影”等等。每一个数据统计的新需求，例如“播客播放率”，需要修改整个数据流水线上的所有部分。团队必须引入新的获取数据的代码、新的清理数据和预处理数据的代码、新的聚合数据的代码，直到最后才是展示“播客播放率”的视图。这要求在不同的组件之间要同步实现功能，并在团队之间管理发布节奏。许多数据平台现在已经提供了通用的和基于配置的数据获取服务，以应对扩展的需求，降低实现新功能的成本。但是这并没有从根本上消除新数据集需要端到端的依赖性管理。流水线架构从表面上看，各个处理阶段已经是一个独立的架构单元，但是从整个单体平台角度看，这整条数据流水线才是最小的架构单元，新的数据集从获取到展示，必须要改变整条流水线。这就限制了我们快速应对新的数据源或者新的数据使用需求。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/illustration/data-mesh-fig4.png&quot; alt=&quot;figure-4&quot;/&gt;
图4：新增或改进功能时，架构的分解和对应的变化是正交的，从而导致耦合并且拖慢了交付。&lt;/p&gt;

&lt;h4 id=&quot;专业且独立的技术团队&quot;&gt;专业且独立的技术团队&lt;/h4&gt;

&lt;p&gt;当前数据平台的第三个弊端，与我们如何建立平台团队有关系。当我们更近距离观察这些构建和维护数据平台的工程师们，会发现他们是一群超专业的工程师，和那些生产数据或者使用数据的部门是隔离开的。数据平台工程师通常不仅组织结构上的独立，而且通常他们具备大数据工具的专业经验，且缺乏业务相关领域的知识，因而被组成一个独立的团队。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/illustration/data-mesh-fig5.png&quot; alt=&quot;figure-5&quot;/&gt;
图5：专业且独立的数据平台团队&lt;/p&gt;

&lt;p&gt;我个人并不羡慕平台工程师的工作。一方面，他们需要从其他团队消费数据，但是其他团队并没有动力提供那么真实、准确、有意义的数据。而另一方面，他们对生产数据的领域又知之甚少，缺乏专业知识。他们需要为各需求方提供数据，却不了解数据需求方的领域知识。&lt;/p&gt;

&lt;p&gt;在流媒体平台这个例子中，在数据源一侧，我们有跨职能的“播放器”团队，可以提供用户如何使用播放器功能的有效信息，比如“播放乐曲事件”、“购买事件”、“播放的音频质量”等等；在数据的另一端，是跨职能的数据消费团队，例如“歌曲推荐团队”推荐歌曲，“销售团队”报告销售KPI，“结算团队”通过计算播放事件数量支付给歌手费用等等。不幸的是，加载中间的数据平台团队，需要付诸全力才能为生产端和消费端提供合适的数据。&lt;/p&gt;

&lt;p&gt;但实际上，我们发现数据平台团队，很难获得数据生产端的支持，又很容易被数据消费端争抢任务排期，这导致数据平台团队一直被撕扯。&lt;/p&gt;

&lt;p&gt;我们当前创建的技术架构和组织结构都无法进行扩展，自然不能实现在创建数据驱动型组织时设立的目标。&lt;/p&gt;

&lt;h2 id=&quot;下一代企业数据平台架构&quot;&gt;下一代企业数据平台架构&lt;/h2&gt;

&lt;p&gt;使用分布式数据网格（Data Mesh）拥抱无处不在的数据。&lt;/p&gt;

&lt;p&gt;针对上面讨论的集中式架构的弊端，我们的应对是什么？我认为是进行必要的范式转换（paradigm shift）。在构建大规模分布式体系架构中已经有所应用，并且在业界已经取得了不错的成果。&lt;/p&gt;

&lt;p&gt;我建议下一代企业数据平台架构，包括：分布式领域驱动架构（Distributed Domain Driven Architecture），自助服务平台设计（Self-serve Platform Design），以及数据产品思想（Product Thinking with Data）&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/illustration/data-mesh-fig6.png&quot; alt=&quot;figure-6&quot;/&gt;
图6：转变范式，构建下一代数据平台&lt;/p&gt;

&lt;p&gt;尽管听起来有很多时髦的词，但这些技术在特定领域已经产生了重大的积极影响。让我们深入研究如何将这些技术应用于数据领域，以摆脱多年来陈旧的数仓体系结构。&lt;/p&gt;

&lt;h3 id=&quot;数据-与-分布式领域驱动架构相结合&quot;&gt;数据 与 分布式领域驱动架构相结合&lt;/h3&gt;

&lt;h4 id=&quot;面向领域的数据的拆分&quot;&gt;面向领域的数据的拆分&lt;/h4&gt;

&lt;p&gt;埃里克·埃文斯（Eric Evans）的著作《域驱动设计》（Domain-Driven Design）深刻地影响了现代体系架构思想，也影响了组织架构模型。它通过将系统分解为：围绕业务域构建分布式服务的微服务体系结构。从根本上改变了团队的组成方式，从而使团队可以独立自主地拥有特定领域的能力。&lt;/p&gt;

&lt;p&gt;尽管在许多时候，我们都采用了面向领域的拆分方式，但奇怪的是，在涉及数据时，我们却忽略了业务领域的概念。在数据平台体系结构中最接近DDD概念的地方，是数据源端的系统生产的业务领域的事件，然后由数据平台来接收它们。但是，在此之后，数据就失去了领域的概念，该领域团队也失去了对数据的掌控。&lt;/p&gt;

&lt;p&gt;领域边界上下文是划分数据集归属的有力工具。Ben Stopford的《Data Dichotomy》一文介绍了通过流共享领域数据集的概念。&lt;/p&gt;

&lt;p&gt;为了数据平台的去中心化，我们需要反思我们的数据，反思数据所处的位置和责任归属。不应将数据从特定领域全部归集到数据湖或平台，而是应该由数据所归属的“领域”以方便消费的方式保存他们的数据并提供数据服务。&lt;/p&gt;

&lt;p&gt;在我们的例子中，与其让数据里从媒体播放器流入中心数据平台，不如思考让“播放器域”自己掌握所有数据并提供服务，其他下游团队进行访问。数据集存储在哪里，如何流动，这是“播放器域”自己的技术实现。物理存储可以是Amazon S3这样的基础架构，但是数据的内容和归属依然属于生产它的团队。类似的，“推荐域”通过创建适合他们自己业务的数据格式，比如通过消费“播放器域”的数据，经过处理和计算，保存到图数据库存储。如果其他领域，例如“发现新歌手域”发现“推荐域”中图数据有意义，他们就可以选择拉取这些数据。&lt;/p&gt;

&lt;p&gt;这意味着，我们可能需要复制数据，然后做一些计算变成新的领域数据。例如，将时间序列的播放事件，转换为歌手相关的图。&lt;/p&gt;

&lt;p&gt;我们需要转变思维方式，从推送和获取（传统的通过ETL和事件流处理数据的方式），转换到跨领域的服务和拉取模型。&lt;/p&gt;

&lt;p&gt;在面向领域数据平台中基本的架构单元是“领域”，而不是数据流水线上的不同处理阶段。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/illustration/data-mesh-fig7.png&quot; alt=&quot;figure-7&quot;/&gt;
图7：根据领域划分数据架构和团队。&lt;/p&gt;

&lt;h4 id=&quot;面向源的域数据&quot;&gt;面向源的域数据&lt;/h4&gt;

&lt;p&gt;一些领域和源数据的组成是天然一致的。源领域数据集，展示的是业务上的事实。源领域的数据集对应的是原始业务系统中的数据，代表着真实系统产生的数据。在我们的流媒体例子中，“用户如何使用服务”，这样的业务创建的数据，例如“用户点击流”、“音频播放质量流”。这些是数据就是由原始业务系统生成的。“播放器域”最了解“用户点击流”数据。&lt;/p&gt;

&lt;p&gt;在理想情况下，一个业务系统的团队，除了负责提供业务功能，也应该负责提供他们所处领域的源数据集。在企业中，没有一对一的领域和系统的对应关系。通常是许多系统，各自提供一部分数据，同时属于一个领域，有些是旧系统，有些易变动。因此这里有许多源数据集需要对齐（事实数据集），最终需要汇聚成为一个内聚的领域对齐的数据集。&lt;/p&gt;

&lt;p&gt;业务事实，最佳表现形式是”业务领域事件“，以“带时间戳的事件的分布式日志”的形式存储并提供服务，获得授权的消费者可访问这些数据。&lt;/p&gt;

&lt;p&gt;除了时序事件外，源数据域还应该提供便于消费的历史数据快照，这些快照以特定间隔汇总数据，以反映域数据的变化。例如，在“唱片公司”源域中，应该同时提供每月汇总唱片公司上架音乐的数据。&lt;/p&gt;

&lt;p&gt;需要注意的是，对齐后的源域数据集必须与内部原始系统的数据集分开存放。领域数据集的性质与原始系统用来提供服务的系统内部数据完全不同。与原始系统数据相比，领域数据集具有更大的体积，代表不变历史事实，并且更改频率较低。因此，领域数据的存储必须适合大数据，并且必须与现有的业务数据库分开。在后续的数据和自助服务平台的设计部分，会介绍如何创建大数据存储和服务基础设施。&lt;/p&gt;

&lt;p&gt;源域数据集是最基础的数据集，更改频率较低，因为业务事实并不经常变更。预计这些源域数据集将被永久保存，随着组织数据驱动的演进，他们可以始终追溯到业务事实，并创建新的汇总或者预测。&lt;/p&gt;

&lt;p&gt;注意，源域数据集在创建时几乎代表原始数据，并且不针对特定数据使用者进行数据拟合或建模。&lt;/p&gt;

&lt;h4 id=&quot;面向消费的共享域数据&quot;&gt;面向消费的共享域数据&lt;/h4&gt;

&lt;p&gt;另一些领域数据与他们的使用者密切相关。在数据消费端的领域数据集，是为了满足特定的数据使用场景。例如，“社交推荐域”侧重于根据用户之间的关系，提供推荐服务，因此需要创建适合此特定需求的域数据集；也许是“用户社交网络图”的形式。显然此图数据集对于推荐场景很适用，除此之外，对于“听众通知域”也可能有意义，推送给听众的通知，包括其社交网络中的“朋友正在听”的消息。因此，“用户社交网络”有可能成为共享的新领域数据集，供多个数据消费者使用。 “用户社交网络”域的团队有责任提供“用户社交网络域”的精确数据视图并及时更新。&lt;/p&gt;

&lt;p&gt;消费者对齐的域数据集与源域数据集相比具有不同的性质。数据结构上发生了更多的变更，并且源域事件被转换聚合为适合特定访问模型的视图和结构，例如我们上面看到的图数据的示例。面向领域的数据平台应该能够轻松地从源域数据集重新生成这些消费域数据集。&lt;/p&gt;

&lt;h4 id=&quot;将分布式数据流水线作为领域内部实现&quot;&gt;将分布式数据流水线作为领域内部实现&lt;/h4&gt;

&lt;p&gt;尽管数据集的归属从中心平台委派给各个域，但数据仍然需要经过清理、预处理、聚合和服务几个阶段。在新体系结构中，数据流水线只是数据域内部的实现，并在该域内部执行。这样，我们将看到数据流水线的阶段分散到每个域中。&lt;/p&gt;

&lt;p&gt;例如，源域需要包括对其域事件的清理，去重，扩展，以便其他域可以使用它们。而无需使用者再次重复这些工作。因此每个域数据集的提供者都必须为其所提供的数据设定“服务质量目标”（Service Level Objectives）：数据实效性，数据错误率等。例如，提供音频“播放点击流”的“播放器域”应当在其域数据流水线中清理和标准化数据，从而提供去重后近实时的“音频单击播放事件”，并且符合企业设定的编码标准。&lt;/p&gt;

&lt;p&gt;类似的，集中式流水线的聚合阶段功能，成为了消费域内部的实现细节。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/illustration/data-mesh-fig8.png&quot; alt=&quot;figure-8&quot;/&gt;
图8：将数据流水线放到各个域中，作为领域的内部实现。&lt;/p&gt;

&lt;p&gt;有人会对此提出异议：该模型会导致每个领域需要各自实现自己的数据处理流水线，在技术栈和工具方面带来重复的工作量。对于这个问题，我将在后续介绍自助服务共享数据基础架构平台时，回答这个问题 。&lt;/p&gt;

&lt;h3 id=&quot;数据和产品思维融合&quot;&gt;数据和产品思维融合&lt;/h3&gt;

&lt;p&gt;采用分布式数据集，将数据和流水线的实现放到各个业务领域之内，就需要关注数据集的可访问性、可用性、协调性。在这里需要借鉴产品化和数据资产所有权的思想。&lt;/p&gt;

&lt;h4 id=&quot;域数据作为产品&quot;&gt;域数据作为产品&lt;/h4&gt;

&lt;p&gt;在过去的十年中，业务领域已将产品化思维融入到他们提供的业务功能中了。业务领域团队将这些功能作为API提供给其他开发人员，用于构建上层的功能。这些团队致力于为他们的API创建最佳的开发人员体验；包括可发现且易理解的API文档，API测试沙箱，以及和质量密切相关的KPI指标。&lt;/p&gt;

&lt;p&gt;为了使分布式数据平台取得同样的成功，领域数据团队必须以严谨的产品化思维，审视他们提供的数据集。将数据资产视为产品，将使用数据的数据科学家、机器学习工程师、数据工程师等视为自己的客户。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/illustration/data-mesh-fig9.png&quot; alt=&quot;figure-9&quot;/&gt;
图9：产品化领域数据的特征&lt;/p&gt;

&lt;p&gt;在互联网媒体流业务这个例子中，它的关键领域之一是“播放事件”，即：谁，在何时，在何地，播放了哪些歌曲。这个关键领域在组织中有不同的使用者。例如，对用户体验以及服务质量感兴趣的支持团队，需要近实时的播放事件数据，以便在客户体验下降或接到投诉电话的情况下可以快速响应。也有一些数据使用者更需要按日或按月汇总的歌曲播放事件的历史快照。&lt;/p&gt;

&lt;p&gt;在这种情况下，我们的“播放的歌曲域”需要为其他数据用户提供了两个不同的数据集作为产品。在流式存储上的实时播放事件，以及在对象存储中的聚合播放事件的统计。&lt;/p&gt;

&lt;p&gt;任何技术产品（在这种情况下是领域数据集产品）的一项衡量标准，就是使它们的顾客满意度。数据产品的顾客包括：数据工程师、机器学习工程师、数据科学家。为了向顾客提供最佳的用户体验，领域数据产品需要具有以下基本素质：&lt;/p&gt;

&lt;h5 id=&quot;可发现&quot;&gt;可发现&lt;/h5&gt;

&lt;p&gt;数据产品必须易于发现。常见的实现方式是对所有可用数据产品及其元信息（例如其所有者，来源来源，血统，样本数据集等）进行注册，编制数据目录。集中式可发现性服务，允许数据消费者，工程师和科学家组织，能够轻松找到他们感兴趣的数据集。每个域数据产品都必须在此集中式数据目录中注册以方便他人发现。&lt;/p&gt;

&lt;p&gt;请注意，这里的观点转变：从单个平台提取并拥有全部数据，到各个数据域以可发现的方式提供产品。&lt;/p&gt;

&lt;h5 id=&quot;可寻址&quot;&gt;可寻址&lt;/h5&gt;

&lt;p&gt;数据产品一旦发现，应遵循全局约定，允许用户以编程方式访问数据的唯一地址。根据数据的基础存储和格式，可以为数据设计不同的命名约定。考虑到易用性，在一个分布式体系结构中，有必要制定通用的约定。不同的域可以使用不同形式的存储和提供数据，事件可能提供诸如Kafka之类的流式存储和访问，列式数据可能使用CSV文件或Parquet文件存储在AWS S3上。标准的数据集寻址方式，有助于消除了查找和访问时的信息壁垒。&lt;/p&gt;

&lt;h5 id=&quot;诚实守信&quot;&gt;诚实守信&lt;/h5&gt;

&lt;p&gt;没有人会使用他们不信任的产品。在传统的数据平台中，ETL 可能有错误，不能反映业务真相，数据根本不可信。因此，这也是集中式数据流水线的大部分工作，在获取数据后，进行数据清洗。&lt;/p&gt;

&lt;p&gt;根本性的转变，是要求数据产品的提供者，围绕数据的真实性设定可接受的服务水平目标（Service Level Objective）。因此，在创建数据产品时，需要数据清理，并且执行自动数据完整性测试，来保证数据产品的质量水平。提供数据来源和数据血缘，帮助消费者增强对数据产品的信任，以及确定数据适合相应的需求。&lt;/p&gt;

&lt;p&gt;数据完整性（质量）指标的目标值，在不同的领域数据产品之间可以有所不同。例如，“播放事件”域可以提供两种不同的数据产品，一种近实时，准确性较低，可能包括丢失或重复的事件；而另一种则具有较长的延迟，但事件准确性较高。每个数据产品定义一组完整性和可靠性等指标，作为服务水平目标（SLOs）。&lt;/p&gt;

&lt;h5 id=&quot;自描述的语义和语法&quot;&gt;自描述的语义和语法&lt;/h5&gt;

&lt;p&gt;优质的产品不需要消费者深究即可使用：可以独立地发现、理解和消费它们。将数据集构建为便于使用的产品，以供数据工程师和数据科学家使用，这需要对数据的语义和语法进行充分描述，理想情况下还应提供数据集的示例。数据的模式（schema），是提供自助数据资产的起点。&lt;/p&gt;

&lt;h5 id=&quot;可互操作且符合全局标准&quot;&gt;可互操作且符合全局标准&lt;/h5&gt;

&lt;p&gt;分布式域数据体系结构的主要关注问题是跨域关联数据的能力：连接，过滤，聚合等。跨域关联数据的关键是：遵循标准和统一规则。此类标准化应属于全局治理范畴的，以实现多域数据集之间的互操作性。此类标准化关注：字段类型格式化，跨域识别多义词，约定数据集地址，元数据公共字段，事件格式（例如CloudEvents等）。&lt;/p&gt;

&lt;p&gt;例如，在媒体流业务中，“歌手”可能出现在不同的数据域中，并且在每个域中具有不同的属性和标识符。 “播放事件流”域对歌手的标识，可能与负责发票和付款的“歌手结算域”的不同。但是，为了能够在不同域数据产品之间关联歌手数据，我们需要就如何标识歌手达成一致。一种方法是考虑“歌手”的唯一全局实体标识符，这与管理个人身份的方式类似。&lt;/p&gt;

&lt;p&gt;全局的通信的互操作和标准化，是构建分布式系统的基础支柱之一。&lt;/p&gt;

&lt;h5 id=&quot;安全并受全局访问控制&quot;&gt;安全并受全局访问控制&lt;/h5&gt;

&lt;p&gt;无论体系结构是否集中化，都必须能够安全地访问数据集。在分散的面向域的数据产品的世界中，对每个域数据产品，都以更精细的粒度进行访问控制。与业务领域类似，访问控制策略可以集中定义，但在访问每个单独的数据集产品时应用。使用企业身份管理系统（SSO） 和基于角色的访问控制策略定义是实现产品数据集访问控制的较为便捷方法。&lt;/p&gt;

&lt;p&gt;数据和自助服务平台的设计部分，描述了一个各数据产品可以轻松拥有这些能力的，共享基础架构。&lt;/p&gt;

&lt;h4 id=&quot;域数据跨职能团队&quot;&gt;域数据跨职能团队&lt;/h4&gt;

&lt;p&gt;将领域数据集作为产品，需要增加新的：（a）数据产品负责人（b）数据工程师。&lt;/p&gt;

&lt;p&gt;数据产品负责人围绕数据产品的愿景和路线图做出决策，关注数据消费者的满意度，并不断量化和提高其拥有和生产的数据的质量和丰富性。负责领域数据集的生命周期管理，以及何时更改，修订和淘汰数据和模式。还需要权衡数据使用者的需求之间的优先级。&lt;/p&gt;

&lt;p&gt;数据产品负责人必须为其数据产品定义成功标准和与业务相关的KPI指标。例如，数据产品的消费者从发现数据和使用数据的时间周期，是可衡量的指标。&lt;/p&gt;

&lt;p&gt;为了构建和运行领域内部数据流水线，团队中必须包括数据工程师。这种跨职能团队的一个奇妙副作用是不同技能的交叉互补。我目前的行业观察是，一些数据工程师虽然能够使用数据工具，但在构建数据资产时缺乏软件工程标准实践，例如缺少连续交付和自动化测试。同样，构建业务系统的软件工程师通常也没有使用数据工具的经验。如果能消除这种技能孤岛，将创建出更强大精深的数据工程技能库。我们已经观察到与DevOps相类似的跨技能交叉，并诞生了新型工程师的岗位，例如 SRE。&lt;/p&gt;

&lt;p&gt;数据必须被视为任何软件生态系统的基础，因此软件工程师必须将数据产品开发的经验和知识添加到他们的工具箱中。同样，基础设施工程师也需要增加管理数据基础设施的知识和经验。组织必须提供职业发展途径。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/illustration/data-mesh-fig10.png&quot; alt=&quot;figure-10&quot;/&gt;
图10：具有明确数据产品责任的跨职能的领域域数据团队&lt;/p&gt;

&lt;h3 id=&quot;数据和自助平台设计融合-data-and-self-serve-platform-design-convergence&quot;&gt;数据和自助平台设计融合 Data and self-serve platform design convergence&lt;/h3&gt;

&lt;p&gt;将数据的责任划分给各个域的主要问题之一，是在每个域中重复建设数据流水线的技术栈和基础架构。幸运的是，将通用基础结构构建为平台，是一个众所周知并且已经有解决方案的问题。尽管工具和技术在数据生态系统中还不成熟。&lt;/p&gt;

&lt;p&gt;将领域无关的基础架构功能放到基础架构平台中，解决了重复设置数据管道引擎，存储和流基础架构的工作。数据基础架构团队掌握并提供技术，各个领域获取、处理、存储和服务其数据产品。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/illustration/data-mesh-fig11.png&quot; alt=&quot;figure-11&quot;/&gt;
图11：抽取域无关的数据流水线基础架构，并将工具构建到独立的数据基础平台架构中&lt;/p&gt;

&lt;p&gt;将数据基础架构构建为平台的关键是（a）不包含任何特定于域的概念或业务逻辑，使其保持领域无关性；以及（b）确保平台隐藏了所有潜在的系统复杂性，提供自助服务型的数据基础组件。自助数据基础架构平台可以向用户（领域数据工程师）提供诸多功能。例如：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;可扩展的多语言大数据存储&lt;/li&gt;
  &lt;li&gt;静态和动态数据加密&lt;/li&gt;
  &lt;li&gt;数据产品版本控制&lt;/li&gt;
  &lt;li&gt;数据产品schema&lt;/li&gt;
  &lt;li&gt;数据产品逆向标识&lt;/li&gt;
  &lt;li&gt;统一的数据访问控制和记录&lt;/li&gt;
  &lt;li&gt;数据管道实现和编排&lt;/li&gt;
  &lt;li&gt;数据产品发现，catalog注册和发布&lt;/li&gt;
  &lt;li&gt;数据治理与标准化&lt;/li&gt;
  &lt;li&gt;数据产品血缘&lt;/li&gt;
  &lt;li&gt;数据产品监控/报警/日志&lt;/li&gt;
  &lt;li&gt;数据产品质量指标（收集和共享）&lt;/li&gt;
  &lt;li&gt;内存数据缓存&lt;/li&gt;
  &lt;li&gt;统一身份标识管理&lt;/li&gt;
  &lt;li&gt;计算和数据本地化&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;衡量自助数据基础架构的成功与否的标准，是能否减少“创建新数据产品的时间”。这需要实现“数据产品”所需的自动化能力。例如，通过配置和脚本自动执行数据提取，创建数据产品的脚手架工具，在catalog中自动注册数据产品等。&lt;/p&gt;

&lt;p&gt;使用云作为基础设施，可以减少提供按需访问的运营成本和工作量，但是并不能完全消除需要在业务环境中进行部署的工作。无论云服务商如何，数据基础架构团队都应该有一组丰富且不断增长的数据基础架构服务。&lt;/p&gt;

&lt;h2 id=&quot;范式向数据网格转移&quot;&gt;范式向数据网格转移&lt;/h2&gt;

&lt;p&gt;现在，让我们一起来回顾本文。我们研究了当前数据平台的一些基本特征： 集中式，单体式，高度耦合的管道架构，由独立且专业化的数据工程师进行维护。我们还介绍了数据网格作为数据平台的构建 ； 面向领域的分布式数据产品，由独立的跨职能团队负责，这些团队具有数据工程师和数据产品负责人，使用通用数据基础结构作为平台来托管、准备数据资产，并对其他客户提供服务。&lt;/p&gt;

&lt;p&gt;数据网格平台是经过精心设计的分布式数据体系结构，通过集中治理和标准化实现领域之间互操作性，并通过共享和统一的自助式数据基础架构实现。很明显，这与之前无法访问的数据孤岛的情况相去甚远。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/illustration/data-mesh-fig12.png&quot; alt=&quot;figure-12&quot;/&gt;
图12：30,000英尺视角的数据网格架构&lt;/p&gt;

&lt;p&gt;您可能会问，数据湖或数据仓库在此体系结构中位于什么位置？它们只是网格上的节点。我们很有可能不需要数据湖，因为保存原始数据的分布式日志和存储，是一个产品化的数据产品，是可以寻址的。但是，如果确实需要更改数据的原始格式以进行进一步的数据发掘（例如打标记），则对此有需求的域，也可能会创建自己的数据湖或数据中心。&lt;/p&gt;

&lt;p&gt;因此，数据湖不再是整个体系结构的核心。我们将继续利用数据湖的某些原理，例如使不可变数据可用于发掘和分析用途 。我们也将继续使用数据湖工具，但是会将其用于数据产品的内部实现或作为共享数据基础架构的一部分。&lt;/p&gt;

&lt;p&gt;实际上，这使我们回到了一切的起点： 2010年，詹姆斯·迪克森（James Dixon）打算将一个数据湖用于单个域，而多个数据域将形成一个“水系”。&lt;/p&gt;

&lt;p&gt;主要转变是将领域数据产品视为主要关注点，而将数据湖工具和管道视为次要的关注点——实现细节。这将当前的思维模型从集中式数据湖转变为可以很好地协同工作的数据产品生态系统，即数据网格。&lt;/p&gt;

&lt;p&gt;相同的原则适用于用于业务报表和可视化的数据仓库。它们也只是网格上的一个节点，可能位于面向数据消费者的网格边缘上。&lt;/p&gt;

&lt;p&gt;必须承认，尽管看到数据网格实践已在有些应用，但是企业如果大规模的采用仍然有很长的路要走。但我不认为这是技术限制，我们今天使用的所有工具都可以容纳多个团队。特别是批流一体化工具，诸如Apache Beam或 Google Cloud Dataflow之类，可以轻松地处理可寻址的各类数据集。&lt;/p&gt;

&lt;p&gt;诸如Google Cloud Data Catalog之类的数据目录平台 提供了集中的可发现性，访问控制和分布式域数据集的治理。云端数据存储也有多种选择。&lt;/p&gt;

&lt;p&gt;需求是真实的，工具也已经准备就绪。由组织的工程师和领导者需要认识到，如果仅使用新的基于云的工具，但以原有的方式建设大数据平台或数据湖，只会重蹈覆辙。&lt;/p&gt;

&lt;p&gt;这种范式转换需要一套新的治理理念：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;数据服务，胜过数据获取；&lt;/li&gt;
  &lt;li&gt;数据的发现和使用，胜过提取和加载；&lt;/li&gt;
  &lt;li&gt;发布流式事件，胜过流水线数据流动；&lt;/li&gt;
  &lt;li&gt;数据产品生态，胜过集中数据平台。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;将单体大数据体系，分解为协同、协作、分布式生态系统——数据网格。&lt;/p&gt;

&lt;hr/&gt;
&lt;h2 id=&quot;参考资料&quot;&gt;参考资料&lt;/h2&gt;
&lt;ol&gt;
  &lt;li&gt;https://www.thoughtworks.com/cn/radar/techniques/data-mesh&lt;/li&gt;
  &lt;li&gt;https://martinfowler.com/articles/data-monolith-to-mesh.html&lt;/li&gt;
  &lt;li&gt;http://www.tuzei8.com/distributed-data-mesh/&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>debd42c5f8a0ed15135e30fae3abcbe5</guid>
<title>工具 | 蚂蚁集团开源的，支付宝开放平台服务端 SDK</title>
<link>https://toutiao.io/k/g3q6fk5</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    

                    
                    
                    &lt;p&gt;&lt;span&gt;大家好，我是周刊菌。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;「码农周刊 VIP 会员」推出 30 周啦！感谢亲们的大力支持！第 030 期「码农周刊 VIP 会员专属邮件周报」已发送完毕，请注意查收。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;告诉大家一个好消息&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;：已有数位上市公司 CTO 低调订阅了我们的「码农周刊 VIP 会员专属邮件周报」，感谢肯定！&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;img class=&quot;rich_pages&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;255&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;255&quot; data-ratio=&quot;1&quot; data-s=&quot;300,640&quot; data-type=&quot;jpeg&quot; data-w=&quot;300&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/t8lpVibticjQ7PeUupLzwuuAibicnrRNxKcfCY7fIva78efKsUzANlCCAeuSQEGkGm34rKkzNRpzy6IiaiaHmBNA6DcA/640?wx_fmt=jpeg&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;以下内容选自「码农周刊 VIP 会员」圈子，每日更新，精彩不断&lt;span&gt;。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;578&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;1047&quot; data-ratio=&quot;1.9253333333333333&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/AjN1jquNav9j7ucJicuhf8MpuHfZ7pHXrlZfibuAWoicAaTTfsOW5203y1wjfvpmCllCycYQv1v9mZX1ia4PoKfaEw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;750&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;「码农周刊 VIP 会员」是什么？&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;简介版&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;码农周刊 VIP 会员 = 全年 52 期「VIP 会员专属邮件周报」 + 只限 VIP 会员加入的交流圈子 + 大厂「内推机会」 + N 多福利&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;详细版&lt;/span&gt;&lt;br/&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;点击「阅读原文」即可查看详细介绍&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;加入「码农周刊 VIP 会员」，与上市公司 CTO 一起成长！&lt;br/&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;全年 52 期「VIP 会员专属邮件周报」 + 只限 VIP 会员加入的交流圈子 + 大厂「内推机会」 + N 多福利，你值得拥有！&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;原价 365 元/年&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;&lt;strong&gt;，现价仅需 108 元！&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;260&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;260&quot; data-ratio=&quot;1.3478260869565217&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/AjN1jquNavibNJDoLvVWUq6RKn5LwtlzRHSMFBED29234hRwibmOzJF4XxKOv5lzRVCelQJIEIOaXh3vYRHOMRzQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;690&quot;/&gt;&lt;/p&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>901094a17bdbae9409e5ea1bcfb83168</guid>
<title>postMessage 还能这样玩</title>
<link>https://toutiao.io/k/286vf6i</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot; data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在日常工作中，消息通信是一个很常见的场景。比如大家熟悉 B/S 结构，在该结构下，浏览器与服务器之间是基于 HTTP 协议进行消息通信：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/jQmwTIFl1V0vDjWMgCItw8O5GakD3toUaugBT5iapibTwLcuQtZAEF9mEAPr4q8reiciaT4IVG7btkZtqlcPG10vNA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-ratio=&quot;0.298&quot; data-w=&quot;1000&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;然而除了 HTTP 协议之外，在一些对数据实时性要求较高的场景下，我们会使用 WebSocket 协议来完成消息通信：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/jQmwTIFl1V0vDjWMgCItw8O5GakD3toUA6Rr39UNaXQrTAZpb78Y8AFdry6oKk8Xsywcnx0iawzggnuM438ZIwA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-ratio=&quot;0.47314814814814815&quot; data-w=&quot;1080&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;对于这两种场景，相信大家都不会陌生。接下来，阿宝哥将介绍消息通信的另外一种场景，即父页面与 iframe 加载的子页面之间，如何进行消息通信。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;为什么会突然写这个话题呢？其实是因为在近期项目中，阿宝哥需要实现父页面与 iframe 加载的子页面之间的消息通信。另外，刚好近期阿宝哥在写 &lt;strong&gt;源码分析&lt;/strong&gt; 专题，所以就到 Github 上搜索 🔍 了一番，然后找到了一个不错的项目 ——  Postmate。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在阅读完 Postmate 源码之后，阿宝哥觉得该项目的一些设计思想挺值得借鉴的，所以就写了这篇文章来跟大家分享一下。阅读&lt;span&gt;完本文之后，你将学到以下&lt;/span&gt;&lt;span&gt;知识：&lt;/span&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;消息系统中握手的作用及如何实现握手；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;消息模型的设计及如何实现消息验证来保证通信安全；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;postMessage 的使用及如何利用它实现父子页面的消息通信；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;消息通信 API 的设计与实现。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;好的，废话不多说，我们先来简单介绍一下 Postmate。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;一、Postmate 简介&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/jQmwTIFl1V0vDjWMgCItw8O5GakD3toUynQgcHrS54ndSDicwAHV9rF17URJrwvlAyc6sAiaS14BXg29v7pqubQg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-ratio=&quot;0.21666666666666667&quot; data-w=&quot;1080&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Postmate 是一个强大，简单，基于 Promise 的 postMessage 库。它允许父页面以最小的成本与跨域的子 &lt;code&gt;iframe&lt;/code&gt; 进行通信。该库拥有以下特性：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;基于 Promise 的 API，可实现优雅而简单的通信；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;使用 &lt;strong&gt;消息验证&lt;/strong&gt; 来保护双向 父 &amp;lt;-&amp;gt; 子 消息通信的安全；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;子对象公开父对象可以访问的可检索的模型对象；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;子对象可派发父对象已监听的事件；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;父对象可以调用子对象中的函数；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;零依赖。如果需要可以为 Promise API 提供自定义 polyfill 或抽象；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;轻量，大小约 1.6 KB（minified &amp;amp; gzipped）。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;接下来阿宝哥将从如何进行握手、如何实现双向消息通信和如何断开连接，这三个方面来分析一下 Postmate 这个库。另外，在此期间还会穿插介绍 Postmate 项目中一些好的设计思路。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;二、如何进行握手&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;TCP 建立连接的时候，需要进行三次握手。同样，当父页面与子页面通信的时候，Postmate 也是通过 “握手” 来确保双方能正常通信。因为 Postmate 通信的基础是基于 postMessage，所以在介绍如何握手之前，我们先来简单了解一下 &lt;code&gt;postMessage&lt;/code&gt; API。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;2.1 postMessage 简介&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;对于两个不同页面的脚本，只有当执行它们的页面位于具有相同的协议、端口号以及主机时，这两个脚本才能相互通信。&lt;code&gt;window.postMessage()&lt;/code&gt; 方法提供了一种受控机制来规避此限制，只要正确的使用，这种方法就很安全。&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;2.1.1 postMessage() 语法&lt;span/&gt;&lt;/h5&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;pre&gt;&lt;span/&gt;&lt;code&gt;otherWindow.postMessage(message, targetOrigin, [transfer]);&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/blockquote&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;otherWindow：其他窗口的一个引用，比如 iframe 的 contentWindow 属性、执行 window.open 返回的窗口对象等。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;message：将要发送到其他 window 的数据，它将会被结构化克隆算法序列化。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;targetOrigin：通过窗口的 origin 属性来指定哪些窗口能接收到消息事件，其值可以是字符串 &quot;*&quot;（表示无限制）或者一个 URI。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;transfer（可选）：是一串和 message 同时传递的 Transferable 对象。这些对象的所有权将被转移给消息的接收方，而发送一方将不再保有所有权。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;发送方通过 postMessage API 来发送消息，而接收方可以通过监听 &lt;code&gt;message&lt;/code&gt; 事件，来添加消息处理回调函数，具体使用方式如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;window&lt;/span&gt;.addEventListener(&lt;span&gt;&quot;message&quot;&lt;/span&gt;, receiveMessage, &lt;span&gt;false&lt;/span&gt;);&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;function&lt;/span&gt; &lt;span&gt;receiveMessage&lt;/span&gt;(&lt;span&gt;event&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;let&lt;/span&gt; origin = event.origin || event.originalEvent.origin; &lt;br/&gt;  &lt;span&gt;if&lt;/span&gt; (origin !== &lt;span&gt;&quot;http://semlinker.com&quot;&lt;/span&gt;) &lt;span&gt;return&lt;/span&gt;;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;2.2 Postmate 握手的实现&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在电信和微处理器系统中，术语握手（Handshake，亦称为交握）具有以下含义：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;在数据通信中，由硬件或软件管理的事件序列，在进行信息交换之前，需要对操作模式的状态互相达成协定。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;在接收站和发送站之间建立通信参数的过程。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;对于通信系统来说，握手是在通信电路建立之后，信息传输开始之前。&lt;strong&gt;握手用于达成参数，如信息传输率，字母表，奇偶校验， 中断过程，和其他协议特性&lt;/strong&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;而对于 Postmate 这个库来说，握手是为了确保父页面与 iframe 子页面之间可以正常的通信，对应的握手流程如下所示：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-cropselx1=&quot;0&quot; data-cropselx2=&quot;558&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;328&quot; data-ratio=&quot;0.6&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/jQmwTIFl1V0vDjWMgCItw8O5GakD3toU4ia3SZhBEl2Br7jBnfOnJL6uIfbfGicSF3NRtMcCC6UYEppIEQpfVcfg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;900&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在 Postmate 中，握手消息是由父页面发起的，在父页面中要发起握手信息，首先需要创建 &lt;code&gt;Postmate&lt;/code&gt; 对象：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;const&lt;/span&gt; postmate = &lt;span&gt;new&lt;/span&gt; Postmate({&lt;br/&gt;  &lt;span&gt;container&lt;/span&gt;: &lt;span&gt;document&lt;/span&gt;.getElementById(&lt;span&gt;&#x27;some-div&#x27;&lt;/span&gt;), &lt;span&gt;// iframe的容器&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;url&lt;/span&gt;: &lt;span&gt;&#x27;http://child.com/page.html&#x27;&lt;/span&gt;, &lt;span&gt;// 包含postmate.js的iframe子页面地址&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;name&lt;/span&gt;: &lt;span&gt;&#x27;my-iframe-name&#x27;&lt;/span&gt; &lt;span&gt;// 用于设置iframe元素的name属性&lt;/span&gt;&lt;br/&gt;});&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在以上代码中，我们通过调用 Postmate 构造函数来创建 postmate 对象，在 Postmate 构造函数内部含有两个主要步骤：设置 Postmate 对象的内部属性和发送握手消息：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/jQmwTIFl1V0vDjWMgCItw8O5GakD3toU2bL0cNUQTlm8p3LuHs0gpKP8QBn23KZicnmeibbRQTHhwS5u1zpia5Rxw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-ratio=&quot;0.5944444444444444&quot; data-w=&quot;1080&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;以上流程图对应的代码相对比较简单，这里阿宝哥就不贴详细的代码了。感兴趣的小伙伴可以阅读 &lt;code&gt;src/postmate.js&lt;/code&gt; 文件中的相关内容。为了能够响应父页面的握手信息，我们需要在子页面中创建一个 Model 对象：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;const&lt;/span&gt; model = &lt;span&gt;new&lt;/span&gt; Postmate.Model({&lt;br/&gt;  &lt;span&gt;// Expose your model to the Parent. Property values may be functions, promises, or regular values&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;height&lt;/span&gt;: &lt;span&gt;&lt;span&gt;()&lt;/span&gt; =&amp;gt;&lt;/span&gt; &lt;span&gt;document&lt;/span&gt;.height || &lt;span&gt;document&lt;/span&gt;.body.offsetHeight&lt;br/&gt;});&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其中 Postmate.Model 构造函数的定义如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;// src/postmate.js&lt;/span&gt;&lt;br/&gt;Postmate.Model = &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;Model&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;constructor&lt;/span&gt;(model) {&lt;br/&gt;    &lt;span&gt;this&lt;/span&gt;.child = &lt;span&gt;window&lt;/span&gt;;&lt;br/&gt;    &lt;span&gt;this&lt;/span&gt;.model = model;&lt;br/&gt;    &lt;span&gt;this&lt;/span&gt;.parent = &lt;span&gt;this&lt;/span&gt;.child.parent;&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;.sendHandshakeReply();&lt;br/&gt;  }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在 Model 构造函数中，我们可以很清楚地看到调用 &lt;code&gt;sendHandshakeReply&lt;/code&gt; 这个方法，这里我们只看核心的代码：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/jQmwTIFl1V0vDjWMgCItw8O5GakD3toUjwo7SP4ZfUEj6R8DxlOEwHicqvZLrYnuLiadMShwgoDJhbpylcV14T4g/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-ratio=&quot;0.36203703703703705&quot; data-w=&quot;1080&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;现在我们来总结一下父页面和子页面之间的握手流程：当子页面加载完成后，父页面会通过 &lt;code&gt;postMessage&lt;/code&gt; API 向子页面发送 &lt;code&gt;handshake&lt;/code&gt; 握手消息。在子页面接收到 &lt;code&gt;handshake&lt;/code&gt; 握手消息之后，同样也会使用 &lt;code&gt;postMessage&lt;/code&gt; API 往父页面回复 &lt;code&gt;handshake-reply&lt;/code&gt; 消息。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;另外，需要注意的是，为了保证子页面能收到 &lt;code&gt;handshake&lt;/code&gt; 握手消息，在 &lt;code&gt;sendHandshake&lt;/code&gt; 方法内部会启动一个定时器来执行发送操作：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;// src/postmate.js&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;Postmate&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;  sendHandshake(url) {&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; Postmate.Promise(&lt;span&gt;(&lt;span&gt;resolve, reject&lt;/span&gt;) =&amp;gt;&lt;/span&gt; {&lt;br/&gt;      &lt;span&gt;const&lt;/span&gt; loaded = &lt;span&gt;&lt;span&gt;()&lt;/span&gt; =&amp;gt;&lt;/span&gt; {&lt;br/&gt;        doSend();&lt;br/&gt;        responseInterval = setInterval(doSend, &lt;span&gt;500&lt;/span&gt;);&lt;br/&gt;      };&lt;br/&gt;&lt;br/&gt;      &lt;span&gt;if&lt;/span&gt; (&lt;span&gt;this&lt;/span&gt;.frame.attachEvent) {&lt;br/&gt;        &lt;span&gt;this&lt;/span&gt;.frame.attachEvent(&lt;span&gt;&quot;onload&quot;&lt;/span&gt;, loaded);&lt;br/&gt;      } &lt;span&gt;else&lt;/span&gt; {&lt;br/&gt;        &lt;span&gt;this&lt;/span&gt;.frame.addEventListener(&lt;span&gt;&quot;load&quot;&lt;/span&gt;, loaded);&lt;br/&gt;      }&lt;br/&gt;      &lt;br/&gt;      &lt;span&gt;this&lt;/span&gt;.frame.src = url;&lt;br/&gt;    });&lt;br/&gt;  }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当然为了避免发送过多无效的握手信息，在 &lt;code&gt;doSend&lt;/code&gt; 方法内部会限制最大的握手次数：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;const&lt;/span&gt; doSend = &lt;span&gt;&lt;span&gt;()&lt;/span&gt; =&amp;gt;&lt;/span&gt; {&lt;br/&gt;  attempt++;&lt;br/&gt;  &lt;span&gt;this&lt;/span&gt;.child.postMessage(&lt;br/&gt;    {&lt;br/&gt;      &lt;span&gt;postmate&lt;/span&gt;: &lt;span&gt;&quot;handshake&quot;&lt;/span&gt;,&lt;br/&gt;      &lt;span&gt;type&lt;/span&gt;: messageType,&lt;br/&gt;      &lt;span&gt;model&lt;/span&gt;: &lt;span&gt;this&lt;/span&gt;.model,&lt;br/&gt;    },&lt;br/&gt;    childOrigin&lt;br/&gt;  );&lt;br/&gt;  &lt;span&gt;// const maxHandshakeRequests = 5;&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;if&lt;/span&gt; (attempt === maxHandshakeRequests) {&lt;br/&gt;     clearInterval(responseInterval);&lt;br/&gt;  }&lt;br/&gt;};&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在主应用和子应用双方完成握手之后，就可以进行双向消息通信了，下面我们来了解一下如何实现双向消息通信。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;三、如何实现双向消息通信&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在调用 &lt;code&gt;Postmate&lt;/code&gt; 和 &lt;code&gt;Postmate.Model&lt;/code&gt; 构造函数之后，会返回一个 Promise 对象。而当 Promise 对象的状态从 &lt;code&gt;pending&lt;/code&gt; 变为 &lt;code&gt;resolved&lt;/code&gt; 之后，就会分别返回 &lt;code&gt;ParentAPI&lt;/code&gt; 和 &lt;code&gt;ChildAPI&lt;/code&gt; 对象：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;Postmate&lt;/strong&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;// src/postmate.js&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;Postmate&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;constructor&lt;/span&gt;({&lt;br/&gt;    container = &lt;span&gt;typeof&lt;/span&gt; container !== &lt;span&gt;&quot;undefined&quot;&lt;/span&gt; ? container : &lt;span&gt;document&lt;/span&gt;.body,&lt;br/&gt;    model, url, name, classListArray = [],&lt;br/&gt;  }) {&lt;br/&gt;    &lt;span&gt;// 省略设置 Postmate 对象的内部属性&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;.sendHandshake(url);&lt;br/&gt;  }&lt;br/&gt;  &lt;br/&gt;  sendHandshake(url) {&lt;br/&gt;    &lt;span&gt;// 省略部分代码&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; Postmate.Promise(&lt;span&gt;(&lt;span&gt;resolve, reject&lt;/span&gt;) =&amp;gt;&lt;/span&gt; {&lt;br/&gt;      &lt;span&gt;const&lt;/span&gt; reply = &lt;span&gt;(&lt;span&gt;e&lt;/span&gt;) =&amp;gt;&lt;/span&gt; {&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (!sanitize(e, childOrigin)) &lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;;&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (e.data.postmate === &lt;span&gt;&quot;handshake-reply&quot;&lt;/span&gt;) {&lt;br/&gt;          &lt;span&gt;return&lt;/span&gt; resolve(&lt;span&gt;new&lt;/span&gt; ParentAPI(&lt;span&gt;this&lt;/span&gt;));&lt;br/&gt;        }&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; reject(&lt;span&gt;&quot;Failed handshake&quot;&lt;/span&gt;);&lt;br/&gt;      };&lt;br/&gt;    });&lt;br/&gt;  }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;ParentAPI&lt;/strong&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;ParentAPI&lt;/span&gt;&lt;/span&gt;{&lt;br/&gt;  +&lt;span&gt;get&lt;/span&gt;(property: any) // 获取子页面中Model对象上的property属性上的值&lt;br/&gt;  +call(property: any, data: any) // 调用子页面中Model对象上的方法&lt;br/&gt;  +on(eventName: any, callback: any) // 监听子页面派发的事件&lt;br/&gt;  +destroy() // 移除事件监听并删除iframe&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;Postmate.Model&lt;/strong&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;// src/postmate.js&lt;/span&gt;&lt;br/&gt;Postmate.Model = &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;Model&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;constructor&lt;/span&gt;(model) {&lt;br/&gt;    &lt;span&gt;this&lt;/span&gt;.child = &lt;span&gt;window&lt;/span&gt;;&lt;br/&gt;    &lt;span&gt;this&lt;/span&gt;.model = model;&lt;br/&gt;    &lt;span&gt;this&lt;/span&gt;.parent = &lt;span&gt;this&lt;/span&gt;.child.parent;&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;.sendHandshakeReply();&lt;br/&gt;  }&lt;br/&gt;&lt;br/&gt;  sendHandshakeReply() {&lt;br/&gt;    &lt;span&gt;// 省略部分代码&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; Postmate.Promise(&lt;span&gt;(&lt;span&gt;resolve, reject&lt;/span&gt;) =&amp;gt;&lt;/span&gt; {&lt;br/&gt;      &lt;span&gt;const&lt;/span&gt; shake = &lt;span&gt;(&lt;span&gt;e&lt;/span&gt;) =&amp;gt;&lt;/span&gt; {&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (e.data.postmate === &lt;span&gt;&quot;handshake&quot;&lt;/span&gt;) {&lt;br/&gt;          &lt;span&gt;this&lt;/span&gt;.child.removeEventListener(&lt;span&gt;&quot;message&quot;&lt;/span&gt;, shake, &lt;span&gt;false&lt;/span&gt;);&lt;br/&gt;          &lt;span&gt;return&lt;/span&gt; resolve(&lt;span&gt;new&lt;/span&gt; ChildAPI(&lt;span&gt;this&lt;/span&gt;));&lt;br/&gt;        }&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; reject(&lt;span&gt;&quot;Handshake Reply Failed&quot;&lt;/span&gt;);&lt;br/&gt;      };&lt;br/&gt;      &lt;span&gt;this&lt;/span&gt;.child.addEventListener(&lt;span&gt;&quot;message&quot;&lt;/span&gt;, shake, &lt;span&gt;false&lt;/span&gt;);&lt;br/&gt;    });&lt;br/&gt;  }&lt;br/&gt;};&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;ChildAPI&lt;/strong&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;ChildAPI&lt;/span&gt;&lt;/span&gt;{&lt;br/&gt;  +emit(name: any, &lt;span&gt;data&lt;/span&gt;: any)&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;3.1 子页面 -&amp;gt; 父页面&lt;span/&gt;&lt;/h4&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;3.1.1 子页面发送消息&lt;span/&gt;&lt;/h5&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;const&lt;/span&gt; model = &lt;span&gt;new&lt;/span&gt; Postmate.Model({&lt;br/&gt;  &lt;span&gt;// Expose your model to the Parent. Property values may be functions, promises, or regular values&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;height&lt;/span&gt;: &lt;span&gt;&lt;span&gt;()&lt;/span&gt; =&amp;gt;&lt;/span&gt; &lt;span&gt;document&lt;/span&gt;.height || &lt;span&gt;document&lt;/span&gt;.body.offsetHeight&lt;br/&gt;});&lt;br/&gt;&lt;br/&gt;model.then(&lt;span&gt;&lt;span&gt;childAPI&lt;/span&gt; =&amp;gt;&lt;/span&gt; {&lt;br/&gt;  childAPI.emit(&lt;span&gt;&#x27;some-event&#x27;&lt;/span&gt;, &lt;span&gt;&#x27;Hello, World!&#x27;&lt;/span&gt;);&lt;br/&gt;});&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在以上代码中，子页面可以通过 &lt;code&gt;ChildAPI&lt;/code&gt; 对象提供的 &lt;code&gt;emit&lt;/code&gt; 方法来发送消息，该方法的定义如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;export&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;ChildAPI&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;  emit(name, data) {&lt;br/&gt;    &lt;span&gt;this&lt;/span&gt;.parent.postMessage(&lt;br/&gt;      {&lt;br/&gt;        &lt;span&gt;postmate&lt;/span&gt;: &lt;span&gt;&quot;emit&quot;&lt;/span&gt;,&lt;br/&gt;        &lt;span&gt;type&lt;/span&gt;: messageType,&lt;br/&gt;        &lt;span&gt;value&lt;/span&gt;: {&lt;br/&gt;          name,&lt;br/&gt;          data,&lt;br/&gt;        },&lt;br/&gt;      },&lt;br/&gt;      &lt;span&gt;this&lt;/span&gt;.parentOrigin&lt;br/&gt;    );&lt;br/&gt;  }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;3.1.2 父页面监听消息&lt;span/&gt;&lt;/h5&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;const&lt;/span&gt; postmate = &lt;span&gt;new&lt;/span&gt; Postmate({&lt;br/&gt;  &lt;span&gt;container&lt;/span&gt;: &lt;span&gt;document&lt;/span&gt;.getElementById(&lt;span&gt;&#x27;some-div&#x27;&lt;/span&gt;), &lt;span&gt;// iframe的容器&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;url&lt;/span&gt;: &lt;span&gt;&#x27;http://child.com/page.html&#x27;&lt;/span&gt;, &lt;span&gt;// 包含postmate.js的iframe子页面地址&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;name&lt;/span&gt;: &lt;span&gt;&#x27;my-iframe-name&#x27;&lt;/span&gt; &lt;span&gt;// 用于设置iframe元素的name属性&lt;/span&gt;&lt;br/&gt;});&lt;br/&gt;&lt;br/&gt;postmate.then(&lt;span&gt;&lt;span&gt;parentAPI&lt;/span&gt; =&amp;gt;&lt;/span&gt; {&lt;br/&gt;  parentAPI.on(&lt;span&gt;&#x27;some-event&#x27;&lt;/span&gt;, data =&amp;gt; &lt;span&gt;console&lt;/span&gt;.log(data)); &lt;span&gt;// Logs &quot;Hello, World!&quot;&lt;/span&gt;&lt;br/&gt;});&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在以上代码中，父页面可以通过 &lt;code&gt;ParentAPI&lt;/code&gt; 对象提供的 &lt;code&gt;on&lt;/code&gt; 方法来注册事件处理器，该方法的定义如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;export&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;ParentAPI&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;constructor&lt;/span&gt;(info) {&lt;br/&gt;    &lt;span&gt;this&lt;/span&gt;.parent = info.parent;&lt;br/&gt;    &lt;span&gt;this&lt;/span&gt;.frame = info.frame;&lt;br/&gt;    &lt;span&gt;this&lt;/span&gt;.child = info.child;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;this&lt;/span&gt;.events = {};&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;this&lt;/span&gt;.listener = &lt;span&gt;(&lt;span&gt;e&lt;/span&gt;) =&amp;gt;&lt;/span&gt; {&lt;br/&gt;      &lt;span&gt;if&lt;/span&gt; (!sanitize(e, &lt;span&gt;this&lt;/span&gt;.childOrigin)) &lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;;&lt;br/&gt;   &lt;span&gt;// 省略部分代码&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;if&lt;/span&gt; (e.data.postmate === &lt;span&gt;&quot;emit&quot;&lt;/span&gt;) {&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (name &lt;span&gt;in&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;.events) {&lt;br/&gt;          &lt;span&gt;this&lt;/span&gt;.events[name].forEach(&lt;span&gt;(&lt;span&gt;callback&lt;/span&gt;) =&amp;gt;&lt;/span&gt; {&lt;br/&gt;            callback.call(&lt;span&gt;this&lt;/span&gt;, data);&lt;br/&gt;          });&lt;br/&gt;        }&lt;br/&gt;      }&lt;br/&gt;    };&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;this&lt;/span&gt;.parent.addEventListener(&lt;span&gt;&quot;message&quot;&lt;/span&gt;, &lt;span&gt;this&lt;/span&gt;.listener, &lt;span&gt;false&lt;/span&gt;);&lt;br/&gt;  }&lt;br/&gt;&lt;br/&gt;  on(eventName, callback) {&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;this&lt;/span&gt;.events[eventName]) {&lt;br/&gt;      &lt;span&gt;this&lt;/span&gt;.events[eventName] = [];&lt;br/&gt;    }&lt;br/&gt;    &lt;span&gt;this&lt;/span&gt;.events[eventName].push(callback);&lt;br/&gt;  }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;3.2 消息验证&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;为了保证通信的安全，在消息处理时，Postmate 会对消息进行验证，对应的验证逻辑被封装到 &lt;code&gt;sanitize&lt;/code&gt; 方法中：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;const&lt;/span&gt; sanitize = &lt;span&gt;(&lt;span&gt;message, allowedOrigin&lt;/span&gt;) =&amp;gt;&lt;/span&gt; {&lt;br/&gt;  &lt;span&gt;if&lt;/span&gt; (&lt;span&gt;typeof&lt;/span&gt; allowedOrigin === &lt;span&gt;&quot;string&quot;&lt;/span&gt; &amp;amp;&amp;amp; message.origin !== allowedOrigin)&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;;&lt;br/&gt;  &lt;span&gt;if&lt;/span&gt; (!message.data) &lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;;&lt;br/&gt;  &lt;span&gt;if&lt;/span&gt; (&lt;span&gt;typeof&lt;/span&gt; message.data === &lt;span&gt;&quot;object&quot;&lt;/span&gt; &amp;amp;&amp;amp; !(&lt;span&gt;&quot;postmate&quot;&lt;/span&gt; &lt;span&gt;in&lt;/span&gt; message.data))&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;;&lt;br/&gt;  &lt;span&gt;if&lt;/span&gt; (message.data.type !== messageType) &lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;;&lt;br/&gt;  &lt;span&gt;if&lt;/span&gt; (!messageTypes[message.data.postmate]) &lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;;&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;;&lt;br/&gt;};&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;对应的验证规则如下：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;验证消息的来源是否合法；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;验证是否含有消息体；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;验证消息体中是否含有 &lt;code&gt;postmate&lt;/code&gt; 属性；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;验证消息的类型是否为 &lt;code&gt;&quot;application/x-postmate-v1+json&quot;&lt;/code&gt;；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;验证消息体中的 &lt;code&gt;postmate&lt;/code&gt; 对应的消息类型是否合法；&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;以下是 Postmate 支持的消息类型：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;const&lt;/span&gt; messageTypes = {&lt;br/&gt;  &lt;span&gt;handshake&lt;/span&gt;: &lt;span&gt;1&lt;/span&gt;, &lt;br/&gt;  &lt;span&gt;&quot;handshake-reply&quot;&lt;/span&gt;: &lt;span&gt;1&lt;/span&gt;, &lt;br/&gt;  &lt;span&gt;call&lt;/span&gt;: &lt;span&gt;1&lt;/span&gt;,&lt;br/&gt;  &lt;span&gt;emit&lt;/span&gt;: &lt;span&gt;1&lt;/span&gt;, &lt;br/&gt;  &lt;span&gt;reply&lt;/span&gt;: &lt;span&gt;1&lt;/span&gt;, &lt;br/&gt;  &lt;span&gt;request&lt;/span&gt;: &lt;span&gt;1&lt;/span&gt;,&lt;br/&gt;};&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其实要实现消息验证的提前，我们还需要定义标准的消息体模型：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;{&lt;br/&gt;   postmate: &lt;span&gt;&quot;emit&quot;&lt;/span&gt;, &lt;span&gt;// 必填：&quot;request&quot; | &quot;call&quot; 等等&lt;/span&gt;&lt;br/&gt;   type: messageType, &lt;span&gt;// 必填：&quot;application/x-postmate-v1+json&quot;&lt;/span&gt;&lt;br/&gt;   &lt;span&gt;// 自定义属性&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;了解完子页面如何与父页面进行通信及如何进行消息验证之后，下面我们来看一下父页面如何与子页面进行消息通信。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;3.3 父页面 -&amp;gt; 子页面&lt;span/&gt;&lt;/h4&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;3.3.1 调用子页面模型对象上的方法&lt;span/&gt;&lt;/h5&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-cropselx1=&quot;0&quot; data-cropselx2=&quot;558&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;273&quot; data-ratio=&quot;0.48997772828507796&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/jQmwTIFl1V0vDjWMgCItw8O5GakD3toUU8B5A7GnHX9YewYwQFXhPQLv7iaDSSgOcMG6HgibOqsCU5ndFMblm8Cg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;898&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在页面中，通过 &lt;code&gt;ParentAPI&lt;/code&gt; 对象提供的 &lt;code&gt;call&lt;/code&gt; 方法，我们就可以调用子页面模型对象上的方法：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;export&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;ParentAPI&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt; call(property, data) {&lt;br/&gt;    &lt;span&gt;this&lt;/span&gt;.child.postMessage(&lt;br/&gt;      {&lt;br/&gt;        &lt;span&gt;postmate&lt;/span&gt;: &lt;span&gt;&quot;call&quot;&lt;/span&gt;,&lt;br/&gt;        &lt;span&gt;type&lt;/span&gt;: messageType,&lt;br/&gt;        property,&lt;br/&gt;        data,&lt;br/&gt;      },&lt;br/&gt;      &lt;span&gt;this&lt;/span&gt;.childOrigin&lt;br/&gt;    );&lt;br/&gt;  }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在 &lt;code&gt;ChildAPI&lt;/code&gt; 对象中，会对 &lt;code&gt;call&lt;/code&gt; 消息类型进行对应的处理，相应的处理逻辑如下所示：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;export&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;ChildAPI&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;constructor&lt;/span&gt;(info) {&lt;br/&gt;  &lt;span&gt;// 省略部分代码&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;this&lt;/span&gt;.child.addEventListener(&lt;span&gt;&quot;message&quot;&lt;/span&gt;, (e) =&amp;gt; {&lt;br/&gt;      &lt;span&gt;if&lt;/span&gt; (!sanitize(e, &lt;span&gt;this&lt;/span&gt;.parentOrigin)) &lt;span&gt;return&lt;/span&gt;;&lt;br/&gt;      &lt;span&gt;const&lt;/span&gt; { property, uid, data } = e.data;&lt;br/&gt;      &lt;br/&gt;      &lt;span&gt;// 响应父页面发送的call消息类型，用于调用Model对象上的对应方法&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;if&lt;/span&gt; (e.data.postmate === &lt;span&gt;&quot;call&quot;&lt;/span&gt;) {&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (&lt;br/&gt;          property &lt;span&gt;in&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;.model &amp;amp;&amp;amp;&lt;br/&gt;          &lt;span&gt;typeof&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;.model[property] === &lt;span&gt;&quot;function&quot;&lt;/span&gt;&lt;br/&gt;        ) {&lt;br/&gt;          &lt;span&gt;this&lt;/span&gt;.model[property](data);&lt;br/&gt;        }&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt;;&lt;br/&gt;      }&lt;br/&gt;    });&lt;br/&gt;  }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;通过以上代码我们可知，call 消息只能用来调用子页面 Model 对象上的方法并不能获取方法调用的返回值。然而在一些场景下，我们是需要获取方法调用的返回值，接下来我们来看一下 &lt;code&gt;ParentAPI&lt;/code&gt; 是如何实现这个功能。&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;3.3.2 调用子页面模型对象上的方法并获取返回值&lt;span/&gt;&lt;/h5&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-cropselx1=&quot;0&quot; data-cropselx2=&quot;558&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;332&quot; data-ratio=&quot;0.5991091314031181&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/jQmwTIFl1V0vDjWMgCItw8O5GakD3toUnVmRjn5X5XMKsWxwOTiayiaDKdPlrcNr8MgMLRcN1thAsicNxBQVYvaxQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;898&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;若需要获取调用后的返回值，我们需要调用 &lt;code&gt;ParentAPI&lt;/code&gt; 对象上提供的 &lt;code&gt;get&lt;/code&gt; 方法：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;export&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;ParentAPI&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt; &lt;span&gt;get&lt;/span&gt;(property) {&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; Postmate.Promise(&lt;span&gt;(&lt;span&gt;resolve&lt;/span&gt;) =&amp;gt;&lt;/span&gt; {&lt;br/&gt;      &lt;span&gt;// 从响应中获取数据并移除监听&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;const&lt;/span&gt; uid = generateNewMessageId();&lt;br/&gt;      &lt;span&gt;const&lt;/span&gt; transact = &lt;span&gt;(&lt;span&gt;e&lt;/span&gt;) =&amp;gt;&lt;/span&gt; {&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (e.data.uid === uid &amp;amp;&amp;amp; e.data.postmate === &lt;span&gt;&quot;reply&quot;&lt;/span&gt;) {&lt;br/&gt;          &lt;span&gt;this&lt;/span&gt;.parent.removeEventListener(&lt;span&gt;&quot;message&quot;&lt;/span&gt;, transact, &lt;span&gt;false&lt;/span&gt;);&lt;br/&gt;          resolve(e.data.value);&lt;br/&gt;        }&lt;br/&gt;      };&lt;br/&gt;      &lt;br/&gt;      &lt;span&gt;// 监听来自子页面的响应消息&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;this&lt;/span&gt;.parent.addEventListener(&lt;span&gt;&quot;message&quot;&lt;/span&gt;, transact, &lt;span&gt;false&lt;/span&gt;);&lt;br/&gt;&lt;br/&gt;      &lt;span&gt;// 向子页面发送请求&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;this&lt;/span&gt;.child.postMessage(&lt;br/&gt;        {&lt;br/&gt;          &lt;span&gt;postmate&lt;/span&gt;: &lt;span&gt;&quot;request&quot;&lt;/span&gt;,&lt;br/&gt;          &lt;span&gt;type&lt;/span&gt;: messageType,&lt;br/&gt;          property,&lt;br/&gt;          uid,&lt;br/&gt;        },&lt;br/&gt;        &lt;span&gt;this&lt;/span&gt;.childOrigin&lt;br/&gt;      );&lt;br/&gt;    });&lt;br/&gt;  }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;对于父页面发送的 &lt;code&gt;request&lt;/code&gt; 消息，在子页面中会通过 &lt;code&gt;resolveValue&lt;/code&gt; 方法来获取返回结果，然后通过 &lt;code&gt;postMessage&lt;/code&gt; 来返回结果：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;// src/postmate.js&lt;/span&gt;&lt;br/&gt;&lt;span&gt;export&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;ChildAPI&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;constructor&lt;/span&gt;(info) {&lt;br/&gt;    &lt;span&gt;this&lt;/span&gt;.child.addEventListener(&lt;span&gt;&quot;message&quot;&lt;/span&gt;, (e) =&amp;gt; {&lt;br/&gt;      &lt;span&gt;if&lt;/span&gt; (!sanitize(e, &lt;span&gt;this&lt;/span&gt;.parentOrigin)) &lt;span&gt;return&lt;/span&gt;;&lt;br/&gt;      &lt;span&gt;const&lt;/span&gt; { property, uid, data } = e.data;&lt;br/&gt;      &lt;br/&gt;      &lt;span&gt;// 响应父页面发送的request消息&lt;/span&gt;&lt;br/&gt;      resolveValue(&lt;span&gt;this&lt;/span&gt;.model, property).then(&lt;span&gt;(&lt;span&gt;value&lt;/span&gt;) =&amp;gt;&lt;/span&gt;&lt;br/&gt;        e.source.postMessage(&lt;br/&gt;          {&lt;br/&gt;            property,&lt;br/&gt;            &lt;span&gt;postmate&lt;/span&gt;: &lt;span&gt;&quot;reply&quot;&lt;/span&gt;,&lt;br/&gt;            &lt;span&gt;type&lt;/span&gt;: messageType,&lt;br/&gt;            uid,&lt;br/&gt;            value,&lt;br/&gt;          },&lt;br/&gt;          e.origin&lt;br/&gt;        )&lt;br/&gt;      );&lt;br/&gt;    });&lt;br/&gt;  }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;以上代码中的 &lt;code&gt;resolveValue&lt;/code&gt; 方法实现也很简单：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;const&lt;/span&gt; resolveValue = &lt;span&gt;(&lt;span&gt;model, property&lt;/span&gt;) =&amp;gt;&lt;/span&gt; {&lt;br/&gt;  &lt;span&gt;const&lt;/span&gt; unwrappedContext =&lt;br/&gt;    &lt;span&gt;typeof&lt;/span&gt; model[property] === &lt;span&gt;&quot;function&quot;&lt;/span&gt; ? model[property]() : model[property];&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; Postmate.Promise.resolve(unwrappedContext);&lt;br/&gt;};&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;此时，我们已经介绍了 Postmate 如何进行握手及如何实现双向消息通信，最后我们来介绍一下如何断开连接。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;四、如何断开连接&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当父页面与子页面完成消息通信之后，我们需要断开连接。这时我们可以调用 &lt;code&gt;ParentAPI&lt;/code&gt; 对象上的 &lt;code&gt;destroy&lt;/code&gt; 方法来断开连接。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;// src/postmate.js&lt;/span&gt;&lt;br/&gt;&lt;span&gt;export&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;ParentAPI&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt; destroy() {&lt;br/&gt;    &lt;span&gt;window&lt;/span&gt;.removeEventListener(&lt;span&gt;&quot;message&quot;&lt;/span&gt;, &lt;span&gt;this&lt;/span&gt;.listener, &lt;span&gt;false&lt;/span&gt;);&lt;br/&gt;    &lt;span&gt;this&lt;/span&gt;.frame.parentNode.removeChild(&lt;span&gt;this&lt;/span&gt;.frame);&lt;br/&gt;  }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;本文阿宝哥以 Postmate 这个库为例，介绍了如何基于 postMessage 来实现父页面和 iframe 子页面之间优雅的消息通信。如果你还意犹未尽的话，可以阅读阿宝哥之前写的与通信相关的文章：&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzI2MjcxNTQ0Nw==&amp;amp;mid=2247486033&amp;amp;idx=1&amp;amp;sn=a31978e4e4ebba6ba753cd32399b10a2&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;如何优雅的实现消息通信？&lt;/a&gt; 和 &lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzI2MjcxNTQ0Nw==&amp;amp;mid=2247485740&amp;amp;idx=1&amp;amp;sn=a9243b90b709d0e138f7f5e5beaea9c0&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;你不知道的 WebSocket&lt;/a&gt;。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;五、参考资源&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;MDN - postMessage&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Github - postmate&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>a17b90d52f24ea0c22afbe65591587fa</guid>
<title>从无到有，支付路由系统升级打怪之路</title>
<link>https://toutiao.io/k/3dz260i</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Hello，大家好，我是楼下小黑哥~&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;今天继续分享支付系统相关的内容，这次分享一下如何支付路由系统实现方式。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其实这个话题去年也写过，不过当时没啥阅读量，这次就再次翻出来加工一下，炒下冷饭。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;支付路由系统&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;提到路由，不免会想到网络通信过程中起到数据包转发的路由器。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.47401685393258425&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/LEFcpfxrbq6VnicjejzlqM6wQ02jqtNTZoc0rxSeGmVqpmb13s7YzHYHHiakL9H56H9oGnp4ia60V6SKiafz9moUiaQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1424&quot; title=&quot;&quot;/&gt;&lt;figcaption&gt;图片来自网络&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;而我们今天讲到支付路由系统，也是起到类似的作用。路由系统本身并不处理具体业务，它的作用就是将支付请求转发底层支付通道。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.48878923766816146&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/LEFcpfxrbq6VnicjejzlqM6wQ02jqtNTZAXswKicl5BygicDs3Q8ickvCwtmUKLFeLUzcHYqGAueCoGuYPlsXayhBg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;892&quot;/&gt;&lt;figcaption&gt;支付路由系统&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如上图所示，支付系统接入层，接收到支付请求之后，经过内部运算，最后将会通过路由系统转发给具体底层的支付通道。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;另外，除了路由转发功能以外，路由器一般还会有一些额外的功能，比如防火墙等。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那我们其实也可以在支付路由系统加入额外功能，比如实时计算底层支付渠道的成功率，若低于一定的阈值，进行报警并且将该渠道下线。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里需要说明一点，这里的路由系统可以是一个应用中子模块，也可以是一个单独子系统。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;为什么需要路由系统&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;看到这里，可能会有一些小伙伴会思考，一定需要这个路由系统吗？直接将请求发给支付通道不好吗？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;答案当然是可以的，如果当前只对接&lt;strong&gt;「一两个支付渠道」&lt;/strong&gt;，这么做没问题，并且也推荐这么做。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个阶段由于业务量不大，支付系统可能只是一个单体应用，或者也可能是其他应用内一个子模块而已。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.2178932178932179&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/LEFcpfxrbq6VnicjejzlqM6wQ02jqtNTZDrAWy2NHJp6yFsN99NPyk09TQYa3ANNiae8IicTbtubTDCArVpvvpzNg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;693&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那这个时候，业务很简单，系统也很简单，那我们不需要额外的路由系统，增加系统复杂度。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;不过这样的系统弊端也很明显，如果后期再新增一个支付通道，我们需要再开发对接。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;另外由于所有实现都在一个系统，假设系统应用发生问题，那么就是大家一起「死」，这其实也是单体系统最大弊端。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以如果底层对接支付通道很多，像一般第三支付公司的支付系统，同一家银行的可能会对接很多支付通道，比对银联无跳转支付，网联支付，也有可能是 XX 行自己提供的接口。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那么这种情况就非常需要单独维护一个路由系统。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;PS：630 政策之前，支付公司对接支付通道那真是一个多，同一家银行，可能会对接四五个通道。&lt;/p&gt;&lt;p&gt;但是 630政策之后， 不允许支付机构直接对接银行。&lt;/p&gt;&lt;p&gt;所以现在支付机构对接通道可能会比之前少很多。&lt;/p&gt;&lt;/blockquote&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;实现方式&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;路由系统实现方式有很多，下面主要分享一下我所经历过实现方案。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们的路由系统经历过三个阶段的迭代，才有了现在的实现方案。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;第一个阶段-混沌初开&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个阶段就跟上面讲的场景一样，业务需求较简单，仅仅只需要对接一两个支付通道。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;为了快速上线，设计方案就简单粗暴，所有业务都处于一个应用。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;支付子模块对内暴露暴露支付服务接口，由业务系统发起直接调用。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;系统设计图如下:&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.8621359223300971&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/LEFcpfxrbq6VnicjejzlqM6wQ02jqtNTZWeTZ3peNMIGNdCkF14x0DWUCG6wGR0Fw9oSs7xzMSw6uXmIVDdLjFQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;515&quot; title=&quot;&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个阶段由于只有一个支付渠道，所以也不需要有路由系统，直接由业务系统调用支付服务接口发起支付。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;不过随着业务量增大之后，这个设计方案就暴露很多问题：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;业务系统与支付系统位于同一个系统，系统任何一次变更都会影响整个系统。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;扩展性问题。每接入一个新的支付通道如微信，就需要增加一个新的实现类。另外，业务系统的代码同时也需要改动，需要调用新的实现类。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;针对以上问题，我们进行第一版的改造。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;首先我们将整个支付模块从原来应用中拆分出来，成为一个独立的子系统，专门运行支付业务。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个系统对外提供一组支付接口，业务系统只需要调用这个接口，传入必要的参数，无需关心支付系统到底是如何实现的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果业务系统想指定某个支付通道，比如支付宝，那么可以在接口传入这个渠道标识，支付系统将会根据这个渠道标识调用相应的支付通道。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.7863105175292153&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/LEFcpfxrbq6VnicjejzlqM6wQ02jqtNTZyb08luYQr9ZCCuKNjfRB6qvwp3Ycmdcn7Itgib3ibs05x63XJPnQqltQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;599&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其次梳理渠道接口文档，抽象出共性接口，每个支付通道实现都需要继承这个接口。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.6150341685649203&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/LEFcpfxrbq6VnicjejzlqM6wQ02jqtNTZn3UYLPRaNMxgf7JxQ6psTJr2M7YUHobicunDDnOGoZyaMBeyonSfsyw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1756&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这组通用渠道接口，其中 &lt;strong&gt;「channelName」&lt;/strong&gt; 方法，代表这个实现类具体代表哪个通道。比如说这个方法返回 &lt;strong&gt;「aliPay」&lt;/strong&gt;，那么就代表这个实现类将会调用支付宝通道。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;支付系统子应用中将会维护一个类似路由表，这里简单使用 &lt;code&gt;Map&lt;/code&gt; 存储映射关系，&lt;strong&gt;「key」&lt;/strong&gt; 为上文提到的渠道唯一应用标识，而 &lt;strong&gt;「value」&lt;/strong&gt; 为具体的实现类。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;应用初始化之后，将会调用 &lt;strong&gt;「Spring ApplicationContext getBeansOfType」&lt;/strong&gt; 方法，获取同一个接口的所有实现类 ，最后将其放入 Map 缓存中。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;每次支付调用都会根据渠道唯一标识从路由表获取具体实现类，然后由具体的子类实现支付逻辑。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;学过设计模式的同学，这里应该不会陌生，这其实是使用设计模式中的策略模式。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.8212927756653993&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/LEFcpfxrbq6VnicjejzlqM6wQ02jqtNTZfb6n7tpmiaReyEOtL1w7KHqkLbevN9ibXayYZ3icpttSSNMY9bbN0Fo5A/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1315&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个阶段，由于业务还不是很复杂，系统还是挺简单，路由系统还只是系统中的一个子模块。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;第二个阶段-神功初成&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;经历过一段时间，公司的业务量变的越来越大，这个阶段我们开始追求系统的稳定性。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但是在第一阶段设计方案中，支付系统所有模块位于同一工程。有些模块可能需要频繁发布，这样一旦发布就会影响所有系统功能。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;第二点，系统功能全都耦合在一起，团队开发也变的困难，分支冲突，代码丢失也是经常的事。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;第三点，一旦某些改动发布发生问题，整个系统都受到影响，真的是「&lt;span&gt;要死一起死&lt;/span&gt;」。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以这个阶段针对以上的问题，我们进行了相应改造，开始将支付系统进行拆分。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;首先按照功能，将支付系统拆分几个独立的子系统，路由系统，渠道系统，成为独立系统，独立部署维护。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;每个支付通道单独维护部署，成为一个单独的子应用。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.5908141962421712&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/LEFcpfxrbq6VnicjejzlqM6wQ02jqtNTZtzNy1auLdZtogzKnkmtib2PScZViaKnpsa1aian4mZ7dfjibONnr3dRAyg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;479&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;系统之间的调用关系，就从同一进程内调用，变成使用 &lt;strong&gt;「RPC」&lt;/strong&gt; 进行跨进程调用。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.4883720930232558&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/LEFcpfxrbq6VnicjejzlqM6wQ02jqtNTZaHEVyVlaCt9hbza1eWTpEBcp6NwiahKgIATaiciazCoxkvwqNs2ARZRicA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;903&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个时候就会有个问题，渠道系统可能会因为发布而下线/上线，这时路由系统必须动态维护这种关系，在渠道系统某一节点下线时，自动删除调用关系，而当应用上线时，新增调用关系。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;「说白了，路由系统需要实现渠道服务动态发现。」&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;看到这里不要怕，其实 Dubbo 框架已经自带这个功能，我们没必要自己再去实现了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Dubbo 配置中有一个属性-&lt;strong&gt;「group」&lt;/strong&gt;，这个属性可以用于服务分组。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当同一个接口有多个实现，我们就可以根据这个来区分不同渠道系统的实现。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.07936507936507936&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/LEFcpfxrbq6VnicjejzlqM6wQ02jqtNTZqOAzhHATu3iaYdaDggGRDAmh5ghXic5tS1uamZaj3l8nr1BMrVJKLyvQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;2016&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;因为渠道系统实现同一组接口之后，提供出 Dubbo 服务需要加上相应的 group 属性，值为相应的渠道唯一标识。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如下所示：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.22787878787878788&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/LEFcpfxrbq6VnicjejzlqM6wQ02jqtNTZZkTyqfVg2HGTO8yZbEzNT7IIqb3OSqkdAicCbbMAUwwEWdKtXzaeakQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;3300&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;路由系统只要引入这个 Dubbo 服务，设置相应的 &lt;strong&gt;「group」&lt;/strong&gt; 属性 ，路由系统引用渠道系统的服务：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.19009100101112233&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/LEFcpfxrbq6VnicjejzlqM6wQ02jqtNTZRNHaztlcj4yH9gHJH3iceJF9Q19Zb2rEPib23mg2iaFCPm4q6yuMgmnIg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;3956&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;此时路由系统就跟第一阶段一样，内部维护一个路由表就好了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里采用了 XML 配置存储渠道标识与 Dubbo 引用服务的映射关系，如下所示：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.24967824967824967&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/LEFcpfxrbq6VnicjejzlqM6wQ02jqtNTZccaicgqTJicOxaIQG0csUaY6C9JhY10uYz19lIePWZbl57XPCRFJVeTA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1554&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;服务启动之后解析这个 XML 文件，然后将其维护在 Map 中。每次支付调用都会根据渠道唯一标识从路由表获取服务名，然后借助 &lt;strong&gt;「Spring ApplicationContext#getBean」&lt;/strong&gt; 获取具体的 Dubbo 引用服务。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.587915078933043&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/LEFcpfxrbq6VnicjejzlqM6wQ02jqtNTZib5B6cb21WpdGD1xkjnAJpIGmNZalLnXR8nyHtibiaularUkYvO2VJQPg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1837&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;后续如果再新增渠道系统，路由系统不需要再修改任何代码，只要在配置文件中新增 Dubbo 服务引用以及增加路由表引用关系即可。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;第三阶段-登峰造极&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;第二个阶段路由系统基本上已经满足现有阶段业务实用，不过还是存在个问题，渠道应用新增时，还需要新增配置&lt;strong&gt;「重启应用」&lt;/strong&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;之前有一次新增渠道，忘记了在路由系统新增配置，从而导致新的渠道应用无法被调用，找了很久的问题，才发现是这个问题。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以第三阶段，主要是优化路由系统，去掉上述配置文件，到达新增渠道应用，而不用重启路由系统。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个阶段的改造，我们不再使用 XML 配置引用服务，而是借助 &lt;strong&gt;「Dubbo API」&lt;/strong&gt; ，动态引用 Dubbo 服务。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;查看  Dubbo 文档 ，可以直接使用 ReferenceConfig 直接查找服务提供者。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.6319485078993563&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/LEFcpfxrbq6VnicjejzlqM6wQ02jqtNTZ9K4VFnm33Aj2JKU27rcSYWhphsNibzPEON205nd0a33bbewoDIPqR5w/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1709&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;官方文档建议：&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;ReferenceConfig 实例很重，封装了与注册中心的连接以及与提供者的连接，需要缓存。否则重复生成 ReferenceConfig 可能造成性能问题并且会有内存和连接泄漏。在 API 方式编程时，容易忽略此问题。&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里使用ReferenceConfigCache，用于缓存 &lt;strong&gt;「ReferenceConfig」&lt;/strong&gt; 实例。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;改造之后，去除之前所有引用服务配置文件以及缓存注册代码，不用再使用 &lt;code&gt;Map&lt;/code&gt; 存储路由的映射关系。改造如下：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.9498680738786279&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/LEFcpfxrbq6VnicjejzlqM6wQ02jqtNTZ5JlSfvmiaxLyUk4FRqfZRbxaiacYke4icFo2V6XZQpVq1keUTZxdl9E2A/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1137&quot;/&gt;&lt;/figure&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;总结&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;回顾上文，可以看到初期没有路由系统，整个系统可以运行下去。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但是随着业务量不断变大变复杂，最开始的系统架构已经不能适应当前的环境，所以我们才开始系统拆分，进行微服务改造，一步步改进系统。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;改进的过程中，不断发现方案不足处，然后一步步迭代演进。这个过程中，要善于利用现有框架的功能，加速功能的开发。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;最后，本文给出了几种不同阶段路由系统实现方式，适合不同阶段、不同类型的系统。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果各位同学刚好也有类似需要，可以根据自己系统的情况借鉴参考。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;好了，下周见~&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;/&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>