<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>f8028b4fcba6fdffdceecadd411cf538</guid>
<title>欢迎加入读者圈子，一起交流！</title>
<link>https://toutiao.io/k/mtrqmru</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content                                       &quot; id=&quot;js_content&quot;&gt;
            &lt;p&gt;&lt;span&gt;&lt;strong&gt;欢迎加入读者圈子，一起交流！&lt;br/&gt;↓↓↓&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;558&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;307&quot; data-ratio=&quot;0.5493333333333333&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/AjN1jquNavich3VaNkKeiaAwUhz7TQbQmic4fFsr58X9PAYleYzxqc1K1vZjeBoZDMUsmia0xH67EQYINGRvNOtLmA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;750&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;圈子剧透&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;1、600+圈子成员，以中高级程序员为主，更有架构师、CTO坐镇交流；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;2、1000+优质主题，数十G独家资料，每日分享，精挑细选；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;3、全年52期专属邮件周报，让你轻松掌握业界资讯、技术干货，提升认知水平；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;4、全年52本好书共读，让你花最少的时间，获取更好的知识；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;……&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;心动不如行动，赶快加入吧！&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
          &lt;/div&gt;

          

          



           
                                
                    
        &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>80c3b8e0004a3c0e48fa4bd4f406729d</guid>
<title>Java线上CPU内存冲高问题排查步骤</title>
<link>https://toutiao.io/k/t9sj17s</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section&gt;&lt;blockquote&gt;&lt;p&gt;作者：茂茂的小破号&lt;br/&gt;链接：https://www.jianshu.com/p/801ecfb44113&lt;/p&gt;&lt;/blockquote&gt;&lt;h3&gt;&lt;span&gt;1 引言&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;作为一名从事Java开发快一年的程序员，在线上经常碰到某个模块的Pod发出CPU与内存告警的问题，而这些问题会导致系统响应缓慢甚至是服务不可用。一般情况下可以通过重启或者调高Pod的资源量或者增加Pod数量暂时解决问题，但这是治标不治本的，只有找到问题发生的原因才能从根本上解决问题。那么在该如何快速定位到导致告警的原因呢？下面将汇总一下大致的处理思路。&lt;/p&gt;&lt;p&gt;一般来说导致Java程序CPU与内存冲高的原因有两种：&lt;/p&gt;&lt;ol class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;代码中某个位置读取数据量较大，导致系统内存耗尽，从而导致Full GC次数过多，系统缓慢。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;代码中有比较耗CPU的操作，导致CPU过高，系统运行缓慢。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;代码某个位置有阻塞性的操作，导致该功能调用整体比较耗时，但出现是比较随机的；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;某个线程由于某种原因而进入WAITING状态，此时该功能整体不可用，但是无法复现；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;由于锁使用不当，导致多个线程进入死锁状态，从而导致系统整体比较缓慢。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;前两种情况出现的频率较高，可能会导致系统不可用，后三种会导致某个功能运行缓慢，但是不至于导致系统不可用。&lt;/p&gt;&lt;p&gt;对于第一种情况，本人曾经遇到过某个查全量数据的接口在某段时间被频繁调用导致内存耗尽、疯狂GC的情况：记一次GC导致的CPU与内存冲高的问题解决。&lt;/p&gt;&lt;p&gt;下面将总结一些具体的排查步骤。&lt;/p&gt;&lt;h3&gt;&lt;span&gt;2 分析工具&lt;/span&gt;&lt;/h3&gt;&lt;h4&gt;&lt;span&gt;2.1 top命令查看CPU占用情况&lt;/span&gt;&lt;/h4&gt;&lt;p&gt;PID为进程编号，COMMAND为其中执行命令，java即为要找的应用&lt;/p&gt;&lt;pre&gt;&lt;code&gt;root@8d36124607a0:/&lt;span&gt;### top&lt;/span&gt;&lt;br/&gt;top - 14:01:23 up 1 day, 17:54,  1 user,  &lt;span&gt;load&lt;/span&gt; average: &lt;span&gt;0.00&lt;/span&gt;, &lt;span&gt;0.01&lt;/span&gt;, &lt;span&gt;0.05&lt;/span&gt;&lt;br/&gt;Tasks: &lt;span&gt;101&lt;/span&gt; total,   &lt;span&gt;1&lt;/span&gt; running, &lt;span&gt;100&lt;/span&gt; sleeping,   &lt;span&gt;0&lt;/span&gt; stopped,   &lt;span&gt;0&lt;/span&gt; zombie&lt;br/&gt;%Cpu(s):  &lt;span&gt;0.8&lt;/span&gt; us,  &lt;span&gt;1.2&lt;/span&gt; sy,  &lt;span&gt;0.0&lt;/span&gt; ni, &lt;span&gt;98.0&lt;/span&gt; &lt;span&gt;id&lt;/span&gt;,  &lt;span&gt;0.0&lt;/span&gt; wa,  &lt;span&gt;0.0&lt;/span&gt; hi,  &lt;span&gt;0.0&lt;/span&gt; si,  &lt;span&gt;0.0&lt;/span&gt; st&lt;br/&gt;KiB Mem :  &lt;span&gt;3782864&lt;/span&gt; total,  &lt;span&gt;1477524&lt;/span&gt; free,   &lt;span&gt;329656&lt;/span&gt; used,  &lt;span&gt;1975684&lt;/span&gt; buff/&lt;span&gt;cache&lt;/span&gt;&lt;br/&gt;KiB Swap:        &lt;span&gt;0&lt;/span&gt; total,        &lt;span&gt;0&lt;/span&gt; free,        &lt;span&gt;0&lt;/span&gt; used.  &lt;span&gt;3181392&lt;/span&gt; avail Mem&lt;br/&gt;&lt;br/&gt;  PID &lt;span&gt;USER&lt;/span&gt;      PR  NI    VIRT    RES    SHR S  %CPU %MEM     &lt;span&gt;TIME&lt;/span&gt;+ COMMAND&lt;br/&gt;  &lt;span&gt;9&lt;/span&gt;   root      &lt;span&gt;20&lt;/span&gt;   &lt;span&gt;0&lt;/span&gt; &lt;span&gt;1031064&lt;/span&gt;  &lt;span&gt;52580&lt;/span&gt;  &lt;span&gt;19248&lt;/span&gt; S  &lt;span&gt;90.3&lt;/span&gt; &lt;span&gt;10.4&lt;/span&gt;  &lt;span&gt;26&lt;/span&gt;:&lt;span&gt;30.37&lt;/span&gt; javacatalina.sh&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;pre&gt;&lt;code&gt;root@8d36124607a0:/&lt;span&gt;### top -Hp 9&lt;/span&gt;&lt;br/&gt;top - 08:31:16 up 30 min,  0 users,  &lt;span&gt;load&lt;/span&gt; average: &lt;span&gt;0.75&lt;/span&gt;, &lt;span&gt;0.59&lt;/span&gt;, &lt;span&gt;0.35&lt;/span&gt;&lt;br/&gt;Threads:  &lt;span&gt;11&lt;/span&gt; total,   &lt;span&gt;1&lt;/span&gt; running,  &lt;span&gt;10&lt;/span&gt; sleeping,   &lt;span&gt;0&lt;/span&gt; stopped,   &lt;span&gt;0&lt;/span&gt; zombie&lt;br/&gt;%Cpu(s):  &lt;span&gt;3.5&lt;/span&gt; us,  &lt;span&gt;0.6&lt;/span&gt; sy,  &lt;span&gt;0.0&lt;/span&gt; ni, &lt;span&gt;95.9&lt;/span&gt; &lt;span&gt;id&lt;/span&gt;,  &lt;span&gt;0.0&lt;/span&gt; wa,  &lt;span&gt;0.0&lt;/span&gt; hi,  &lt;span&gt;0.0&lt;/span&gt; si,  &lt;span&gt;0.0&lt;/span&gt; st&lt;br/&gt;KiB Mem:   &lt;span&gt;2046460&lt;/span&gt; total,  &lt;span&gt;1924856&lt;/span&gt; used,   &lt;span&gt;121604&lt;/span&gt; free,    &lt;span&gt;14396&lt;/span&gt; buffers&lt;br/&gt;KiB Swap:  &lt;span&gt;1048572&lt;/span&gt; total,        &lt;span&gt;0&lt;/span&gt; used,  &lt;span&gt;1048572&lt;/span&gt; free.  &lt;span&gt;1192532&lt;/span&gt; cached Mem&lt;br/&gt;&lt;br/&gt;  PID &lt;span&gt;USER&lt;/span&gt;      PR  NI    VIRT    RES    SHR S %CPU %MEM     &lt;span&gt;TIME&lt;/span&gt;+ COMMAND&lt;br/&gt;   &lt;span&gt;10&lt;/span&gt; root      &lt;span&gt;20&lt;/span&gt;   &lt;span&gt;0&lt;/span&gt; &lt;span&gt;2557160&lt;/span&gt; &lt;span&gt;289824&lt;/span&gt;  &lt;span&gt;15872&lt;/span&gt; R &lt;span&gt;79.3&lt;/span&gt; &lt;span&gt;14.2&lt;/span&gt;   &lt;span&gt;0&lt;/span&gt;:&lt;span&gt;41.49&lt;/span&gt; &lt;span&gt;java&lt;/span&gt;&lt;br/&gt;   &lt;span&gt;11&lt;/span&gt; root      &lt;span&gt;20&lt;/span&gt;   &lt;span&gt;0&lt;/span&gt; &lt;span&gt;2557160&lt;/span&gt; &lt;span&gt;289824&lt;/span&gt;  &lt;span&gt;15872&lt;/span&gt; S &lt;span&gt;1.2&lt;/span&gt;  &lt;span&gt;14.2&lt;/span&gt;   &lt;span&gt;0&lt;/span&gt;:&lt;span&gt;06.78&lt;/span&gt; &lt;span&gt;java&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;可以看到占用CPU消耗最高的PID为10，该ID即为线程ID，使用如下命令将其转化为16进制格式：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;root@8d36124607a0&lt;span&gt;:/&lt;/span&gt;&lt;span&gt;### printf &quot;%x\n&quot; 10 &lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;得到输出a线程即为0xa。&lt;/p&gt;&lt;h4&gt;&lt;span&gt;2.2 使用jstack查看Java线程信息&lt;/span&gt;&lt;/h4&gt;&lt;pre&gt;&lt;code&gt;root@8d36124607a0&lt;span&gt;:/&lt;/span&gt;&lt;span&gt;### jstack 9 | grep 0xa&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&quot;VM Thread&quot;&lt;/span&gt; os_prio=&lt;span&gt;0&lt;/span&gt; tid=&lt;span&gt;0x00007f871806e000&lt;/span&gt; nid=&lt;span&gt;0xa&lt;/span&gt; runnable”&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;第一个双引号圈起来的就是线程名，如果是“VM Thread”这就是虚拟机GC回收线程，如果是&quot;main&quot;则是其他线程，后面的runnable是线程状态。&lt;/p&gt;&lt;h4&gt;&lt;span&gt;2.3 使用jstat查看GC信息&lt;/span&gt;&lt;/h4&gt;&lt;pre&gt;&lt;code&gt;root@8d36124607a0&lt;span&gt;:/&lt;/span&gt;&lt;span&gt;### jstat -gcutil 9 1000 10&lt;/span&gt;&lt;br/&gt;  S&lt;span&gt;0&lt;/span&gt;     S1     E      O      M     CCS    YGC     YGCT    FGC    FGCT     GCT&lt;br/&gt;  &lt;span&gt;0&lt;/span&gt;.&lt;span&gt;00&lt;/span&gt;   &lt;span&gt;0&lt;/span&gt;.&lt;span&gt;00&lt;/span&gt;   &lt;span&gt;0&lt;/span&gt;.&lt;span&gt;00&lt;/span&gt;  &lt;span&gt;75.07&lt;/span&gt;  &lt;span&gt;59.09&lt;/span&gt;  &lt;span&gt;59.60&lt;/span&gt;   &lt;span&gt;3259&lt;/span&gt;    &lt;span&gt;0&lt;/span&gt;.&lt;span&gt;919&lt;/span&gt;  &lt;span&gt;6517&lt;/span&gt;    &lt;span&gt;7.715&lt;/span&gt;    &lt;span&gt;8.635&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;0&lt;/span&gt;.&lt;span&gt;00&lt;/span&gt;   &lt;span&gt;0&lt;/span&gt;.&lt;span&gt;00&lt;/span&gt;   &lt;span&gt;0&lt;/span&gt;.&lt;span&gt;00&lt;/span&gt;   &lt;span&gt;0&lt;/span&gt;.08  &lt;span&gt;59.09&lt;/span&gt;  &lt;span&gt;59.60&lt;/span&gt;   &lt;span&gt;3306&lt;/span&gt;    &lt;span&gt;0&lt;/span&gt;.&lt;span&gt;930&lt;/span&gt;  &lt;span&gt;6611&lt;/span&gt;    &lt;span&gt;7.822&lt;/span&gt;    &lt;span&gt;8.752&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;0&lt;/span&gt;.&lt;span&gt;00&lt;/span&gt;   &lt;span&gt;0&lt;/span&gt;.&lt;span&gt;00&lt;/span&gt;   &lt;span&gt;0&lt;/span&gt;.&lt;span&gt;00&lt;/span&gt;   &lt;span&gt;0&lt;/span&gt;.08  &lt;span&gt;59.09&lt;/span&gt;  &lt;span&gt;59.60&lt;/span&gt;   &lt;span&gt;3351&lt;/span&gt;    &lt;span&gt;0&lt;/span&gt;.&lt;span&gt;943&lt;/span&gt;  &lt;span&gt;6701&lt;/span&gt;    &lt;span&gt;7.924&lt;/span&gt;    &lt;span&gt;8.867&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;0&lt;/span&gt;.&lt;span&gt;00&lt;/span&gt;   &lt;span&gt;0&lt;/span&gt;.&lt;span&gt;00&lt;/span&gt;   &lt;span&gt;0&lt;/span&gt;.&lt;span&gt;00&lt;/span&gt;   &lt;span&gt;0&lt;/span&gt;.08  &lt;span&gt;59.09&lt;/span&gt;  &lt;span&gt;59.60&lt;/span&gt;   &lt;span&gt;3397&lt;/span&gt;    &lt;span&gt;0&lt;/span&gt;.&lt;span&gt;955&lt;/span&gt;  &lt;span&gt;6793&lt;/span&gt;    &lt;span&gt;8.029&lt;/span&gt;    &lt;span&gt;8.984&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;查看某进程GC持续变化情况，如果发现返回中FGC很大且一直增大，确认为Full GC! 也可以使用“jmap -heap 进程ID”查看一下进程的堆内从是不是要溢出了，特别是老年代内从使用情况一般是达到阈值(具体看垃圾回收器和启动时配置的阈值)就会进程Full GC。&lt;/p&gt;&lt;h4&gt;&lt;span&gt;2.4 使用Jmap分析内存&lt;/span&gt;&lt;/h4&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;code&gt;jmap -dump:format=b,file=文件名称 进程ID&lt;/code&gt; ：生成内存dump文件，进行离线分析。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;dump文件界面分析工具：IBM HeapAnalyzer，点击进入找到ha457.jar的下载链接进行下载&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;code&gt;java -Xmx4G -jar ha457.jar&lt;/code&gt;：运行jar文件，如果dump文件过大可以使用&lt;code&gt;-Xmx&lt;/code&gt;设置最大堆内存大小，防止内存溢出。&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;通过ha457.jar的GUI界面可以很清晰的看到各种类型的数据内存占用情况、对象之间的引用关系以及可能存在内存泄漏的对象。&lt;/p&gt;&lt;figure&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.9741666666666666&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz/OKUeiaP72uRxUgVJjiaqFmNaG4nVMf6TLGe4Jocn295UNx4tEcgMIM0MJFIsWxKQY7YLLyKGKTCxuCPBHBC3ibwkg/640?wx_fmt=other&quot; data-type=&quot;other&quot; data-w=&quot;1200&quot; title=&quot;&quot;/&gt;&lt;/figure&gt;&lt;h3&gt;&lt;span&gt;3 原因分析&lt;/span&gt;&lt;/h3&gt;&lt;h4&gt;&lt;span&gt;3.1 Full GC次数过多&lt;/span&gt;&lt;/h4&gt;&lt;p&gt;相对来说，这种情况是最容易出现的，尤其是新功能上线时。对于Full GC较多的情况，其主要有如下两个特征：&lt;/p&gt;&lt;p&gt;初步排查：使用&lt;code&gt;top&lt;/code&gt;与&lt;code&gt;top -Hp&lt;/code&gt;命令找到CPU占用最高的Java线程，将其转为16进制后，使用&lt;code&gt;jstack&lt;/code&gt;命令抓取该线程信息，发现线程名称是&quot;VM Thread&quot;垃圾回收线程。&lt;br/&gt;进一步确认：使用&lt;code&gt;jstat -gcutil&lt;/code&gt;命令查看gc次数与增长情况。&lt;br/&gt;进一步分析：使用&lt;code&gt;jmap -dump&lt;/code&gt;命令dump内存，然后使用使用&lt;code&gt;ha457.jar&lt;/code&gt;离线分析。&lt;/p&gt;&lt;h4&gt;&lt;span&gt;3.2 某个业务逻辑执行时间过长&lt;/span&gt;&lt;/h4&gt;&lt;p&gt;如果是Full GC次数过多，那么通过 &lt;code&gt;jstack&lt;/code&gt;得到的线程信息会是类似于VM Thread之类的线程，而如果是代码中有比较耗时的计算，那么我们得到的就是一个线程的具体堆栈信息。&lt;/p&gt;&lt;p&gt;如下是一个代码中有比较耗时的计算，导致CPU过高的线程信息：&lt;/p&gt;&lt;figure&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5814814814814815&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz/OKUeiaP72uRxUgVJjiaqFmNaG4nVMf6TLGHYicpA8OPqIBR6VWN0CVpHcEXZvv6vDcCXxvYnb2HcZMcp4ECiaE3iamg/640?wx_fmt=other&quot; data-type=&quot;other&quot; data-w=&quot;1080&quot; title=&quot;&quot;/&gt;&lt;/figure&gt;&lt;p&gt;这里可以看到，在请求UserController的时候，由于该Controller进行了一个比较耗时的调用，导致该线程的CPU一直处于100%。&lt;/p&gt;&lt;p&gt;我们可以根据堆栈信息，直接定位到UserController的34行，查看代码中具体是什么原因导致计算量如此之高。&lt;/p&gt;&lt;h4&gt;&lt;span&gt;3.3 死锁&lt;/span&gt;&lt;/h4&gt;&lt;p&gt;如果有死锁，会直接提示。关键字：deadlock。使用&lt;code&gt;jstack&lt;/code&gt;打印线程信息会打印出业务死锁的位置。&lt;/p&gt;&lt;figure&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6407407407407407&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz/OKUeiaP72uRxUgVJjiaqFmNaG4nVMf6TLGNop8ahlnjcTkszUNn30l84v6iaAzRQibIicGLfJRrSdCEdpKVxJd7putQ/640?wx_fmt=other&quot; data-type=&quot;other&quot; data-w=&quot;1080&quot; title=&quot;&quot;/&gt;&lt;/figure&gt;&lt;h4&gt;&lt;span&gt;3.4 线程一直处于WAITTING状态&lt;/span&gt;&lt;/h4&gt;&lt;p&gt;对于这种情况，这是比较罕见的一种情况，但是也是有可能出现的，而且由于其具有一定的 “不可复现性”，因在排查的时候是非常难以发现的。&lt;/p&gt;&lt;p&gt;某个线程由于某种原因而进入WAITING状态，此时该功能整体不可用，但是无法复现。&lt;code&gt;jstack&lt;/code&gt;多查询几次，每次间隔30秒，对比一直停留在parking 导致的WAITING状态的线程。&lt;/p&gt;&lt;p&gt;可以通过给线程命名快速定位到是哪个业务代码。&lt;/p&gt;&lt;h4&gt;&lt;span&gt;3.5 随机出现大量线程访问接口缓慢&lt;/span&gt;&lt;/h4&gt;&lt;p&gt;对于这种情况，比较典型的例子就是，我们某个接口访问经常需要2~3s才能返回。&lt;/p&gt;&lt;p&gt;这是比较麻烦的一种情况，因为一般来说，其消耗的CPU不多，而且占用的内存也不高，也就是说，我们通过上述两种方式进行排查是无法解决这种问题的。&lt;/p&gt;&lt;p&gt;而且由于这样的接口耗时比较大的问题是不定时出现的，这就导致了我们在通过 jstack命令即使得到了线程访问的堆栈信息，我们也没法判断具体哪个线程是正在执行比较耗时操作的线程。&lt;/p&gt;&lt;p&gt;对于不定时出现的接口耗时比较严重的问题，我们的定位思路基本如下：&lt;/p&gt;&lt;p&gt;首先找到该接口，通过压测工具不断加大访问力度，如果说该接口中有某个位置是比较耗时的，由于我们的访问的频率非常高，那么大多数的线程最终都将阻塞于该阻塞点&lt;/p&gt;&lt;p&gt;这样通过多个线程具有相同的堆栈日志，我们基本上就可以定位到该接口中比较耗时的代码的位置。&lt;/p&gt;&lt;p&gt;如下是一个代码中有比较耗时的阻塞操作通过压测工具得到的线程堆栈日志：&lt;/p&gt;&lt;figure&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1.125&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz/OKUeiaP72uRxUgVJjiaqFmNaG4nVMf6TLGBzbmzopLgWyBSKkdqPvKvZxjT8sbewCmaR2ibLRS8rt6OnLKfVNTU1w/640?wx_fmt=other&quot; data-type=&quot;other&quot; data-w=&quot;1200&quot; title=&quot;&quot;/&gt;&lt;/figure&gt;&lt;p&gt;从上面的日志可以看你出，这里有多个线程都阻塞在了UserController的第18行，说明这是一个阻塞点，也就是导致该接口比较缓慢的原因。&lt;/p&gt;&lt;h3&gt;&lt;span&gt;4 总结&lt;/span&gt;&lt;/h3&gt;&lt;h4&gt;&lt;span&gt;4.1 排查命令总结&lt;/span&gt;&lt;/h4&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;code&gt;top&lt;/code&gt;：查看系统进程CPU与内存占用情况，找到占用最多的进程ID&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;code&gt;top -Hp 进程号&lt;/code&gt;：查看该进程号的所有线程CPU与内存占用情况，找到占用最多的线程ID（显示的PID即为10进制线程编号，printf &quot;%x\n&quot; 进程号转为16进制线程号）&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;code&gt;jstack 进程号 &amp;amp;gt;&amp;amp;gt; stack.txt&lt;/code&gt;：将进程号所属进程的堆栈信息输出到stack.txt中&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;code&gt;jstack 进程号 | grep 16进制线程号&lt;/code&gt;：查看进程号先所属线程的堆栈信息，可查看线程名，区分出普通线程与GC线程（&quot;VM Thread&quot;）。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;code&gt;jstat -gcutil 进程号 统计间隔毫秒 统计次数（缺省代表一直统计）&lt;/code&gt;：如果是因为GC问题，进一步观察GC情况&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;code&gt;jmap -heap 进程ID&lt;/code&gt;：查看详细进程内存使用信息&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;code&gt;jmap -dump:format=b,file=文件名称 进程ID&lt;/code&gt;：将进程内存信息dump到磁盘上供进一步分析。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;code&gt;java -Xmx4G -jar ha457.jar&lt;/code&gt;：使用ha457.jar来分析内存泄漏情况。&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h4&gt;&lt;span&gt;4.2 异常情况解决总结&lt;/span&gt;&lt;/h4&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;GC问题：top+top -Hp + jstack排查是&quot;VM Thread&quot;消耗过多资源，可以进一步使用jmap工具进行内存溢出排查。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;业务执行过慢问题：top+top -Hp + jstack排查发现是普通业务线程，可看到具体是哪个接口。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;死锁：&lt;code&gt;jstack + Java进程&lt;/code&gt;打印堆栈信息中包含死锁信息deadlock&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;线程处于waiting状态：多打印几次jstack信息，对比一直停留在waiting状态的线程。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3&gt;&lt;span&gt;5 参考：&lt;/span&gt;&lt;/h3&gt;&lt;ol class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;线上CPU飙升100%问题排查，一篇足矣 - 只会一点java - 博客园 (cnblogs.com)&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;面试官：如果你们的系统 CPU 突然飙升且 GC 频繁，如何排查？(qq.com)&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;系统运行缓慢，CPU 100%，以及Full GC次数过多问题的排查思路 - charming丶的个人空间 - OSCHINA - 中文开源技术交流社区&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>8a2ebef2c4b4e79024db7f2e74a260ce</guid>
<title>40 张最全计算机网络基础思维导图</title>
<link>https://toutiao.io/k/rogs5j4</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;profile_inner&quot;&gt;
                  &lt;strong class=&quot;profile_nickname&quot;&gt;PHP开发者&lt;/strong&gt;
                  &lt;img class=&quot;profile_avatar&quot; id=&quot;js_profile_qrcode_img&quot; src=&quot;&quot; alt=&quot;&quot;/&gt;

                  &lt;p class=&quot;profile_meta&quot;&gt;
                  &lt;label class=&quot;profile_meta_label&quot;&gt;Weixin ID&lt;/label&gt;
                  &lt;span class=&quot;profile_meta_value&quot;&gt;phpDevs&lt;/span&gt;
                  &lt;/p&gt;

                  &lt;p class=&quot;profile_meta&quot;&gt;
                  &lt;label class=&quot;profile_meta_label&quot;&gt;About Feature&lt;/label&gt;
                  &lt;span class=&quot;profile_meta_value&quot;&gt;「PHP开发者」专注分享 PHP 开发相关的技术文章和工具资源。&lt;/span&gt;
                  &lt;/p&gt;
                &lt;/div&gt;
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>f9e7c45fc240fdfdb0aed37cb15885c8</guid>
<title>Api 接口优化的几个技巧</title>
<link>https://toutiao.io/k/nrwggst</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content                                       &quot; id=&quot;js_content&quot;&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot; data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;section data-style-type=&quot;5&quot; data-tools=&quot;新媒体排版&quot; data-id=&quot;965972&quot;&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;因公众号更改推送规则，请点“在看”并加“星标”&lt;span&gt;第一时间获取精彩技术分享&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;点击关注#互联网架构师公众号，领取&lt;/span&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzI2MTIzMzY3Mw==&amp;amp;mid=2247487508&amp;amp;idx=1&amp;amp;sn=78cf235aa9ba5f988c6922ca98f8bfd6&amp;amp;chksm=ea5cdd72dd2b54647cf55b4a73dcafa69fc7228205ad39ecc98fe57b39cdecb21c238c6d6cb6&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;架构师全套资料&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;架构师全套资料&lt;/span&gt;&lt;/a&gt;&lt;span&gt; 都在这里&lt;/span&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-fileid=&quot;100029587&quot; data-ratio=&quot;1&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/b96CibCt70iaajvl7fD4ZCicMcjhXMp1v6UibM134tIsO1j5yqHyNhh9arj090oAL7zGhRJRq6cFqFOlDZMleLl4pw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;64&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;a target=&quot;_blank&quot; href=&quot;https://mp.weixin.qq.com/s?__biz=MzI2MTIzMzY3Mw==&amp;amp;mid=2247487508&amp;amp;idx=1&amp;amp;sn=78cf235aa9ba5f988c6922ca98f8bfd6&amp;amp;chksm=ea5cdd72dd2b54647cf55b4a73dcafa69fc7228205ad39ecc98fe57b39cdecb21c238c6d6cb6&amp;amp;scene=21&amp;amp;token=171858062&amp;amp;lang=zh_CN#wechat_redirect&quot; textvalue=&quot;0、2T架构师学习资料干货分享&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;0、&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;&lt;strong&gt;2T架构师学习资料干货分&lt;/strong&gt;&lt;/span&gt;&lt;/a&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;上一篇：&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzI2MTIzMzY3Mw==&amp;amp;mid=2247529763&amp;amp;idx=1&amp;amp;sn=0b7b1d671871e0d68eb6f9dd59cdfb68&amp;amp;chksm=ea5fb845dd28315384c8ae5dee1ca5dcff849934134dc2a116469d22b781c1eadca2de3df891&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;分布式系统设计模式，你用过哪些？&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;分布式系统设计模式，你用过哪些？&lt;/a&gt;&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;span&gt;当越来越多对性能的吐槽反馈到我们这里的时候，我们意识到，接口性能的问题的优先级必须提高了。然后我们就跟踪了1周的接口性能监控，这个时候我们的心情是这样的：&lt;/span&gt;&lt;span/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.9876543209876543&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz/YrLz7nDONjFUhGlIwUrUuicVZN5tT3fLsJvP5o7tYAE9DqoRuoTuHbBGW57uMOkT1nJcvVH7TFTFSmjqpzL24kw/640?wx_fmt=jpeg&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; data-type=&quot;jpeg&quot; data-w=&quot;243&quot;/&gt;&lt;/figure&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;有20多个慢接口，5个接口响应时间超过5s，1个超过10s，其余的都在2s以上，稳定性不足99.8%。作为一个优秀的后端程序员，这个数据肯定是不能忍的，我们马上就进入了漫长的接口优化之路。本文就是对我们漫长工作历程的一个总结。&lt;/span&gt;&lt;/section&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;哪些问题会引起接口性能问题？&lt;/span&gt;&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;这个问题的答案非常多，需要根据自己的业务场景具体分析。这里做一个不完全的总结：&lt;/span&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;数据库慢查询&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;深度分页问题&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;未加索引&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;索引失效&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;join过多&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;子查询过多&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;in中的值太多&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;单纯的数据量过大&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;业务逻辑复杂&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;线程池设计不合理&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;锁设计不合理&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;机器问题（fullGC，机器重启，线程打满）&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;1、慢查询（基于mysql）&lt;br/&gt;&lt;/span&gt;&lt;/h1&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;1.1 深度分页&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;所谓的深度分页问题，涉及到mysql分页的原理。通常情况下，mysql的分页是这样写的：&lt;/span&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;select name,code from student &lt;span&gt;limit&lt;/span&gt; 100,20&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;含义当然就是从student表里查100到120这20条数据，mysql会把前120条数据都查出来，抛弃前100条，返回20条。当分页所以深度不大的时候当然没问题，随着分页的深入，sql可能会变成这样：&lt;/span&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;select name,code from student &lt;span&gt;limit&lt;/span&gt; 1000000,20&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;这个时候，mysql会查出来1000020条数据，抛弃1000000条，如此大的数据量，速度一定快不起来。那如何解决呢？一般情况下，最好的方式是增加一个条件：&lt;/span&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;select name,code from student &lt;span&gt;where&lt;/span&gt; id&amp;gt;1000000  &lt;span&gt;limit&lt;/span&gt; 20&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;这样，mysql会走主键索引，直接连接到1000000处，然后查出来20条数据。但是这个方式需要接口的调用方配合改造，把上次查询出来的最大id以参数的方式传给接口提供方，会有沟通成本（调用方：老子不改！）。&lt;/span&gt;&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;1.2 未加索引&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;这个是最容易解决的问题，我们可以通过&lt;/span&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;show create table xxxx（表名）&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;查看某张表的索引。具体加索引的语句网上太多了，不再赘述。不过顺便提一嘴，加索引之前，需要考虑一下这个索引是不是有必要加，如果加索引的字段区分度非常低，那即使加了索引也不会生效。另外，加索引的alter操作，可能引起锁表，执行sql的时候一定要在低峰期（血泪史！！！！）&lt;/span&gt;&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;1.3 索引失效&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;这个是慢查询最不好分析的情况，虽然mysql提供了explain来评估某个sql的查询性能，其中就有使用的索引。但是为啥索引会失效呢？mysql却不会告诉咱，需要咱自己分析。大体上，可能引起索引失效的原因有这几个（可能不完全）：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.36807511737089205&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz/YrLz7nDONjFUhGlIwUrUuicVZN5tT3fLsiaOOiciawmr7LfVEWic3JnrBjZfYRjTCibTtZdeQv1Y2j8D2kWqrHLbBOlg/640?wx_fmt=jpeg&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; data-type=&quot;jpeg&quot; data-w=&quot;1065&quot;/&gt;&lt;/figure&gt;&lt;p&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;需要特别提出的是，关于字段区分性很差的情况，在加索引的时候就应该进行评估。如果区分性很差，这个索引根本就没必要加。区分性很差是什么意思呢，举几个例子，比如：&lt;/span&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;某个字段只可能有3个值，那这个字段的索引区分度就很低。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;再比如，某个字段大量为空，只有少量有值；&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;再比如，某个字段值非常集中，90%都是1，剩下10%可能是2,3,4....&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;进一步的，那如果不符合上面所有的索引失效的情况，但是mysql还是不使用对应的索引，是为啥呢？这个跟mysql的sql优化有关，mysql会在sql优化的时候自己选择合适的索引，很可能是mysql自己的选择算法算出来使用这个索引不会提升性能，所以就放弃了。这种情况，可以使用force index 关键字强制使用索引（建议修改前先实验一下，是不是真的会提升查询效率）：&lt;/span&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;select name,code from student force index(XXXXXX) &lt;span&gt;where&lt;/span&gt; name = &lt;span&gt;&#x27;天才&#x27;&lt;/span&gt; &lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;其中xxxx是索引名。&lt;/span&gt;&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;1.4 join过多 or 子查询过多&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;我把join过多 和子查询过多放在一起说了。一般来说，不建议使用子查询，可以把子查询改成join来优化。同时，join关联的表也不宜过多，一般来说2-3张表还是合适的。具体关联几张表比较安全是需要具体问题具体分析的，如果各个表的数据量都很少，几百条几千条，那么关联的表的可以适当多一些，反之则需要少一些。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;另外需要提到的是，在大多数情况下join是在内存里做的，如果匹配的量比较小，或者join_buffer设置的比较大，速度也不会很慢。但是，当join的数据量比较大的时候，mysql会采用在硬盘上创建临时表的方式进行多张表的关联匹配，这种显然效率就极低，本来磁盘的IO就不快，还要关联。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;一般遇到这种情况的时候就建议从代码层面进行拆分，在业务层先查询一张表的数据，然后以关联字段作为条件查询关联表形成map，然后在业务层进行数据的拼装。一般来说，索引建立正确的话，会比join快很多，毕竟内存里拼接数据要比网络传输和硬盘IO快得多。&lt;/span&gt;&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;1.5 in的元素过多&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;这种问题，如果只看代码的话不太容易排查，最好结合监控和数据库日志一起分析。如果一个查询有in，in的条件加了合适的索引，这个时候的sql还是比较慢就可以高度怀疑是in的元素过多。一旦排查出来是这个问题，解决起来也比较容易，不过是把元素分个组，每组查一次。想再快的话，可以再引入多线程。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;进一步的，如果in的元素量大到一定程度还是快不起来，这种最好还是有个限制&lt;/span&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;select id from student &lt;span&gt;where&lt;/span&gt; id &lt;span&gt;in&lt;/span&gt; (1,2,3 ...... 1000) &lt;span&gt;limit&lt;/span&gt; 200&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;当然了，最好是在代码层面做个限制&lt;/span&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;if&lt;/span&gt; (ids.size() &amp;gt; 200) {&lt;br/&gt;    throw new Exception(&lt;span&gt;&quot;单次查询数据量不能超过200&quot;&lt;/span&gt;);&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;1.6 单纯的数据量过大&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;这种问题，单纯代码的修修补补一般就解决不了了，需要变动整个的数据存储架构。或者是对底层mysql分表或分库+分表；或者就是直接变更底层数据库，把mysql转换成专门为处理大数据设计的数据库。这种工作是个系统工程，需要严密的调研、方案设计、方案评审、性能评估、开发、测试、联调，同时需要设计严密的数据迁移方案、回滚方案、降级措施、故障处理预案。除了以上团队内部的工作，还可能有跨系统沟通的工作，毕竟做了重大变更，下游系统的调用接口的方式有可能会需要变化。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;出于篇幅的考虑，这个不再展开了，笔者有幸完整参与了一次亿级别数据量的数据库分表工作，对整个过程的复杂性深有体会，后续有机会也会分享出来。&lt;/span&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;2、业务逻辑复杂&lt;/span&gt;&lt;/h2&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;2.1 循环调用&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;这种情况，一般都循环调用同一段代码，每次循环的逻辑一致，前后不关联。比如说，我们要初始化一个列表，预置12个月的数据给前端：&lt;/span&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;List&amp;lt;Model&amp;gt; list = &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;&amp;gt;();&lt;br/&gt;&lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt; ; i &amp;lt; &lt;span&gt;12&lt;/span&gt; ; i ++) {&lt;br/&gt;    Model model = calOneMonthData(i); &lt;span&gt;// 计算某个月的数据，逻辑比较复杂，难以批量计算，效率也无法很高&lt;/span&gt;&lt;br/&gt;    list.add(model);&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;这种显然每个月的数据计算相互都是独立的，我们完全可以采用多线程方式进行：&lt;/span&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;// 建立一个线程池，注意要放在外面，不要每次执行代码就建立一个，具体线程池的使用就不展开了&lt;/span&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; ExecutorService commonThreadPool = &lt;span&gt;new&lt;/span&gt; ThreadPoolExecutor(&lt;span&gt;5&lt;/span&gt;, &lt;span&gt;5&lt;/span&gt;, &lt;span&gt;300L&lt;/span&gt;,&lt;br/&gt;        TimeUnit.SECONDS, &lt;span&gt;new&lt;/span&gt; LinkedBlockingQueue&amp;lt;&amp;gt;(&lt;span&gt;10&lt;/span&gt;), commonThreadFactory, &lt;span&gt;new&lt;/span&gt; ThreadPoolExecutor.DiscardPolicy());&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// 开始多线程调用&lt;/span&gt;&lt;br/&gt;List&amp;lt;Future&amp;lt;Model&amp;gt;&amp;gt; futures = &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;&amp;gt;();&lt;br/&gt;&lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt; ; i &amp;lt; &lt;span&gt;12&lt;/span&gt; ; i ++) {&lt;br/&gt;    Future&amp;lt;Model&amp;gt; future = commonThreadPool.submit(() -&amp;gt; calOneMonthData(i););&lt;br/&gt;    futures.add(future);&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// 获取结果&lt;/span&gt;&lt;br/&gt;List&amp;lt;Model&amp;gt; list = &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;&amp;gt;();&lt;br/&gt;&lt;span&gt;try&lt;/span&gt; {&lt;br/&gt;   &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt; ; i &amp;lt; futures.size() ; i ++) {&lt;br/&gt;      list.add(futures.get(i).get());&lt;br/&gt;   }&lt;br/&gt;} &lt;span&gt;catch&lt;/span&gt; (Exception e) {&lt;br/&gt;   LOGGER.error(&lt;span&gt;&quot;出现错误：&quot;&lt;/span&gt;, e);&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;2.2 顺序调用&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;如果不是类似上面循环调用，而是一次次的顺序调用，而且调用之间没有结果上的依赖，那么也可以用多线程的方式进行，例如：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.24031620553359684&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz/YrLz7nDONjFUhGlIwUrUuicVZN5tT3fLsRjM3e4RQ1OS90QM72xoibJa1uUIQnJGbvsorRvPLbvGEhgLYDuRh2tw/640?wx_fmt=jpeg&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; data-type=&quot;jpeg&quot; data-w=&quot;1265&quot;/&gt;&lt;/figure&gt;&lt;p&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;代码上看：&lt;/span&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;A a = doA();&lt;br/&gt;B b = doB();&lt;br/&gt;&lt;br/&gt;C c = doC(a, b);&lt;br/&gt;&lt;br/&gt;D d = doD(c);&lt;br/&gt;E e = doE(c);&lt;br/&gt;&lt;br/&gt;&lt;span&gt;return&lt;/span&gt; doResult(d, e);&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;那么可用CompletableFuture解决&lt;/span&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;CompletableFuture&amp;lt;A&amp;gt; futureA = CompletableFuture.supplyAsync(() -&amp;gt; doA());&lt;br/&gt;CompletableFuture&amp;lt;B&amp;gt; futureB = CompletableFuture.supplyAsync(() -&amp;gt; doB());&lt;br/&gt;CompletableFuture.allOf(futureA,futureB) // 等a b 两个任务都执行完成&lt;br/&gt;&lt;br/&gt;C c = doC(futureA.join(), futureB.join());&lt;br/&gt;&lt;br/&gt;CompletableFuture&amp;lt;D&amp;gt; futureD = CompletableFuture.supplyAsync(() -&amp;gt; doD(c));&lt;br/&gt;CompletableFuture&amp;lt;E&amp;gt; futureE = CompletableFuture.supplyAsync(() -&amp;gt; doE(c));&lt;br/&gt;CompletableFuture.allOf(futureD,futureE) // 等d e两个任务都执行完成&lt;br/&gt;&lt;br/&gt;&lt;span&gt;return&lt;/span&gt; doResult(futureD.join(),futureE.join());&lt;br/&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;这样A B 两个逻辑可以并行执行，D E两个逻辑可以并行执行，最大执行时间取决于哪个逻辑更慢。&lt;/span&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;3、线程池设计不合理&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;有的时候，即使我们使用了线程池让任务并行处理，接口的执行效率仍然不够快，这种情况可能是怎么回事呢？&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;这种情况首先应该怀疑是不是线程池设计的不合理。我觉得这里有必要回顾一下线程池的三个重要参数：核心线程数、最大线程数、等待队列。这三个参数是怎么打配合的呢？当线程池创建的时候，如果不预热线程池，则线程池中线程为0。当有任务提交到线程池，则开始创建核心线程。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;244&quot; data-backw=&quot;578&quot; data-ratio=&quot;0.4216133942161339&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz/YrLz7nDONjFUhGlIwUrUuicVZN5tT3fLsIIiawKn14zsNkkDZM6WNfvTTMsTNejWGfyYQwYt212dU119fXoByQNw/640?wx_fmt=jpeg&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; data-type=&quot;jpeg&quot; data-w=&quot;657&quot;/&gt;&lt;span&gt;当核心线程全部被占满，如果再有任务到达，则让任务进入等待队列开始等待。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.4216133942161339&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz/YrLz7nDONjFUhGlIwUrUuicVZN5tT3fLsFYLBdTWyVRs1iaDDKeztGLgNa1iawh0lghZibbFVMeLeXeIEkwtlibUxDA/640?wx_fmt=jpeg&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; data-type=&quot;jpeg&quot; data-w=&quot;657&quot;/&gt;&lt;span&gt;如果队列也被占满，则开始创建非核心线程运行。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.4216133942161339&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz/YrLz7nDONjFUhGlIwUrUuicVZN5tT3fLss0XvO9Zcf6gicB9n2Kt2EHRkDGO1RSeBdw4iag1y7JvOjunFLC3m85pg/640?wx_fmt=jpeg&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; data-type=&quot;jpeg&quot; data-w=&quot;657&quot;/&gt;&lt;span&gt;如果线程总数达到最大线程数，还是有任务到达，则开始根据线程池抛弃规则开始抛弃。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.3449564134495641&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz/YrLz7nDONjFUhGlIwUrUuicVZN5tT3fLsGrDowplkIOwgdbpYnJ4dJTic2FTQ4icEOApSN1rVicQjBUib18MslHIRPA/640?wx_fmt=jpeg&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; data-type=&quot;jpeg&quot; data-w=&quot;803&quot;/&gt;&lt;/figure&gt;&lt;p&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;那么这个运行原理与接口运行时间有什么关系呢？&lt;/span&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;核心线程设置过小：核心线程设置过小则没有达到并行的效果&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;线程池公用，别的业务的任务执行时间太长，占用了核心线程，另一个业务的任务到达就直接进入了等待队列&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;任务太多，以至于占满了线程池，大量任务在队列中等待&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;在排查的时候，只要找到了问题出现的原因，那么解决方式也就清楚了，无非就是调整线程池参数，按照业务拆分线程池等等。&lt;/span&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;4、锁设计不合理&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;锁设计不合理一般有两种：锁类型使用不合理 or 锁过粗。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;锁类型使用不合理的典型场景就是读写锁。也就是说，读是可以共享的，但是读的时候不能对共享变量写；而在写的时候，读写都不能进行。在可以加读写锁的时候，如果我们加成了互斥锁，那么在读远远多于写的场景下，效率会极大降低。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;锁过粗则是另一种常见的锁设计不合理的情况，如果我们把锁包裹的范围过大，则加锁时间会过长，例如：&lt;/span&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;synchronized&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;doSome&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    File f = calData();&lt;br/&gt;    uploadToS3(f);&lt;br/&gt;    sendSuccessMessage();&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;这块逻辑一共处理了三部分，计算、上传结果、发送消息。显然上传结果和发送消息是完全可以不加锁的，因为这个跟共享变量根本不沾边。因此完全可以改成：&lt;/span&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;doSome&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    File f = &lt;span&gt;null&lt;/span&gt;;&lt;br/&gt;    &lt;span&gt;synchronized&lt;/span&gt;(&lt;span&gt;this&lt;/span&gt;) {&lt;br/&gt;        f = calData();&lt;br/&gt;    }&lt;br/&gt;    uploadToS3(f);&lt;br/&gt;    sendSuccessMessage();&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;5、机器问题（fullGC，机器重启，线程打满）&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;造成这个问题的原因非常多，笔者就遇到了定时任务过大引起fullGC，代码存在线程泄露引起RSS内存占用过高进而引起机器重启等待诸多原因。需要结合各种监控和具体场景具体分析，进而进行大事务拆分、重新规划线程池等等工作&lt;/span&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;6、万金油解决方式&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;万金油这个形容词是从我们单位某位老师那里学来的，但是笔者觉得非常贴切。这些万金油解决方式往往能解决大部分的接口缓慢的问题，而且也往往是我们解决接口效率问题的最终解决方案。当我们实在是没有办法排查出问题，或者实在是没有优化空间的时候，可以尝试这种万金油的方式。&lt;/span&gt;&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;6.1 缓存&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;缓存是一种空间换取时间的解决方案，是在高性能存储介质上（例如：内存、SSD硬盘等）存储一份数据备份。当有请求打到服务器的时候，优先从缓存中读取数据。如果读取不到，则再从硬盘或通过网络获取数据。由于内存或SSD相比硬盘或网络IO的效率高很多，则接口响应速度会变快非常多。缓存适合于应用在数据读远远大于数据写，且数据变化不频繁的场景中。从技术选型上看，有这些：&lt;/span&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;简单的&lt;/span&gt;&lt;code&gt;&lt;span&gt;map&lt;/span&gt;&lt;/code&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;&lt;span&gt;guava&lt;/span&gt;&lt;/code&gt;&lt;span&gt;等本地缓存工具包&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;缓存中间件：&lt;/span&gt;&lt;code&gt;&lt;span&gt;redis&lt;/span&gt;&lt;/code&gt;&lt;span&gt;、&lt;/span&gt;&lt;code&gt;&lt;span&gt;tair&lt;/span&gt;&lt;/code&gt;&lt;span&gt;或&lt;/span&gt;&lt;code&gt;&lt;span&gt;memcached&lt;/span&gt;&lt;/code&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;当然，&lt;/span&gt;&lt;code&gt;&lt;span&gt;memcached&lt;/span&gt;&lt;/code&gt;&lt;span&gt;现在用的很少了，因为相比于&lt;/span&gt;&lt;code&gt;&lt;span&gt;redis&lt;/span&gt;&lt;/code&gt;&lt;span&gt;他不占优势。&lt;/span&gt;&lt;code&gt;&lt;span&gt;tair&lt;/span&gt;&lt;/code&gt;&lt;span&gt;则是阿里开发的一个分布式缓存中间件，他的优势是理论上可以在不停服的情况下，动态扩展存储容量，适用于大数据量缓存存储。相比于单机&lt;/span&gt;&lt;code&gt;&lt;span&gt;redis&lt;/span&gt;&lt;/code&gt;&lt;span&gt;缓存当然有优势，而他与可扩展&lt;/span&gt;&lt;code&gt;&lt;span&gt;Redis&lt;/span&gt;&lt;/code&gt;&lt;span&gt;集群的对比则需要进一步调研。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;进一步的，当前缓存的模型一般都是key-value模型。如何设计key以提高缓存的命中率是个大学问，好的key设计和坏的key设计所提升的性能差别非常大。而且，key设计是没有一定之规的，需要结合具体的业务场景去分析。各个大公司分享出来的相关文章，缓存设计基本上是最大篇幅。&lt;/span&gt;&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;6.2 回调 or 反查&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;这种方式往往是业务上的解决方式，在订单或者付款系统中应用的比较多。举个例子：当我们付款的时候，需要调用一个专门的付款系统接口，该系统经过一系列验证、存储工作后还要调用银行接口以执行付款。由于付款这个动作要求十分严谨，银行侧接口执行可能比较缓慢，进而拖累整个付款接口性能。这个时候我们就可以采用fast success的方式：当必要的校验和存储完成后，立即返回success，同时告诉调用方一个中间态“付款中”。而后调用银行接口，当获得支付结果后再调用上游系统的回调接口返回付款的最终结果“成果”or“失败”。这样就可以异步执行付款过程，提升付款接口效率。当然，为了防止多业务方接入的时候回调接口不统一，可以把结果抛进kafka，让调用方监听自己的结果。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.8003629764065335&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz/YrLz7nDONjFUhGlIwUrUuicVZN5tT3fLsDAI73qeRyXmdnLfHicibPodKsBwPUhf5S0Qw2aOauLPB140XrdBS7N7w/640?wx_fmt=jpeg&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; data-type=&quot;jpeg&quot; data-w=&quot;551&quot;/&gt;&lt;/figure&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;p&gt;&lt;span&gt;来源：juejin.cn/post/7043423820543164453&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;相关阅读：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;1、&lt;/span&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzI2MTIzMzY3Mw==&amp;amp;mid=2247523205&amp;amp;idx=1&amp;amp;sn=89b261f829ce6c3487ce8b2ccf3ed06b&amp;amp;chksm=ea5f56e3dd28dff5238989d3e07d775d34c04a4e80a166059e92e84379274819203d72d1dc1d&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;Alibaba开源内网高并发编程手册.pdf&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;Alibaba开源内网高并发编程手册.pdf&lt;/span&gt;&lt;/a&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;2、&lt;/span&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzI2MTIzMzY3Mw==&amp;amp;mid=2247487508&amp;amp;idx=1&amp;amp;sn=78cf235aa9ba5f988c6922ca98f8bfd6&amp;amp;chksm=ea5cdd72dd2b54647cf55b4a73dcafa69fc7228205ad39ecc98fe57b39cdecb21c238c6d6cb6&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;2T架构师学习资料干货分享&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;2T架构师学习资料干货分享&lt;/span&gt;&lt;/a&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;3、&lt;/span&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzI2MTIzMzY3Mw==&amp;amp;mid=2247523100&amp;amp;idx=1&amp;amp;sn=82a70350577bde0bca6dd2dde811ca17&amp;amp;chksm=ea5f567add28df6cb6a780ff744c3ffdc79e498d2c2536ffb1853d8082ebfa986e1e5c43d532&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;10000+TB 资源，阿里云盘，牛逼！！&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;10000+TB 资源，阿里云盘，牛逼！！&lt;/span&gt;&lt;/a&gt;&lt;/section&gt;&lt;p&gt;4、&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzI2MTIzMzY3Mw==&amp;amp;mid=2247523863&amp;amp;idx=1&amp;amp;sn=4d2a2b5da60f14f3e8947e174d485c03&amp;amp;chksm=ea5f5371dd28da6791af6cb3a164c8052f1e77d7392cbbc87c5a73ccc6916b76eab29dbc9991&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;基本涵盖了Spring所有核心知识点总结&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;基本涵盖了Spring所有核心知识点总结&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;  · END ·&lt;/span&gt;&lt;br/&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;最后，关注公众号互联网架构师，在后台回复：2T，可以获取我整理的 Java 系列面试题和答案，非常齐全&lt;span&gt;。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.3640625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/9mQQWOf4KRL358RWHQSLbUws79uyGm5RJ6WZibYJMAKUQibz8aYNA5LPSmbo1boibnD3IhggQ2F7kS37xgk3WXQ8Q/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果这篇文章对您有所帮助，或者有所启发的话，帮忙扫描下发二维码关注一下，您的支持是我坚持写作最大的动力。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;求一键三连：点赞、转发、在看。&lt;/p&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/div&gt;

          

          



                    
          &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>41c4dd229189d217432ab50b8e44ce0c</guid>
<title>安全架构设计的方法论</title>
<link>https://toutiao.io/k/ig2i9fh</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;a class=&quot;weui-flex original_primary_card appmsg_card_context wx_tap_card js_wx_tap_highlight&quot; href=&quot;#&quot; id=&quot;copyright_info&quot;&gt;
                  
                  &lt;div class=&quot;weui-flex__item&quot; role=&quot;option&quot;&gt;
                    &lt;strong class=&quot;original_primary_nickname&quot;&gt;阿里开发者&lt;/strong&gt;
                                          &lt;span class=&quot;weui-hidden_abs&quot;&gt;.&lt;/span&gt;
                      &lt;p class=&quot;original_primary_desc&quot;&gt;阿里巴巴官方技术号，关于阿里的技术创新均呈现于此。&lt;/p&gt;
                                      &lt;/div&gt;
                  &lt;p class=&quot;weui-flex__ft&quot;/&gt;
                &lt;/a&gt;
              &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>