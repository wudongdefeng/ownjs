<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>c9abe7f9aa74a1ce47d20b1a2285e80a</guid>
<title>创意！原来阮大佬博客的阅读进度功能这么简单</title>
<link>https://toutiao.io/k/e9q9qy6</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot; data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;section class=&quot;mp_profile_iframe_wrp&quot;&gt;&lt;mp-common-profile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mpprofile&quot; data-id=&quot;MzUxNzk1MjQ0Ng==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/YBFV3Da0Nwvv72YkFO0qPibDKicOCsfltiaE9070DOu4iahXnicYwRIHcxe9VBicAy45MkPqy8nZzLTVibugOtV0ORFcg/0?wx_fmt=png&quot; data-nickname=&quot;程序员成长指北&quot; data-alias=&quot;coder_growth&quot; data-signature=&quot;专注 Node.js 技术栈分享，从 前端 到 Node.js 再到 后端数据库，祝您成为优秀的高级 Node.js 全栈工程师。一个有趣的且乐于分享的人。座右铭：今天未完成的，明天更不会完成。&quot; data-from=&quot;0&quot; data-is_biz_ban=&quot;0&quot;/&gt;&lt;/section&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;大厂技术&lt;/span&gt;&lt;span&gt;  &lt;/span&gt;&lt;span&gt;高级前端&lt;/span&gt;&lt;span&gt;  &lt;/span&gt;&lt;span&gt;Node进阶&lt;/span&gt;&lt;br/&gt;&lt;/h1&gt;&lt;p&gt;&lt;span data-darkmode-bgcolor-16021670869911=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16021670869911=&quot;rgb(255, 255, 255)&quot; data-darkmode-color-16021670869911=&quot;rgb(136, 136, 136)&quot; data-darkmode-original-color-16021670869911=&quot;rgb(136, 136, 136)&quot; data-darkmode-bgcolor-16030289161394=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16030289161394=&quot;rgb(255, 255, 255)&quot; data-darkmode-color-16030289161394=&quot;rgb(136, 136, 136)&quot; data-darkmode-original-color-16030289161394=&quot;rgb(136, 136, 136)&quot; data-darkmode-bgcolor-16030315732716=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16030315732716=&quot;rgb(255, 255, 255)&quot; data-darkmode-color-16030315732716=&quot;rgb(136, 136, 136)&quot; data-darkmode-original-color-16030315732716=&quot;rgb(136, 136, 136)&quot;&gt;点击上方 &lt;/span&gt;&lt;span data-darkmode-bgcolor-16021670869911=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16021670869911=&quot;rgb(255, 255, 255)&quot; data-darkmode-color-16021670869911=&quot;rgb(0, 128, 255)&quot; data-darkmode-original-color-16021670869911=&quot;rgb(0, 128, 255)&quot; data-darkmode-bgcolor-16030289161394=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16030289161394=&quot;rgb(255, 255, 255)&quot; data-darkmode-color-16030289161394=&quot;rgb(0, 128, 255)&quot; data-darkmode-original-color-16030289161394=&quot;rgb(0, 128, 255)&quot; data-darkmode-bgcolor-16030315732716=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16030315732716=&quot;rgb(255, 255, 255)&quot; data-darkmode-color-16030315732716=&quot;rgb(0, 128, 255)&quot; data-darkmode-original-color-16030315732716=&quot;rgb(0, 128, 255)&quot;&gt;程序员成长指北&lt;/span&gt;&lt;span data-darkmode-bgcolor-16021670869911=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16021670869911=&quot;rgb(255, 255, 255)&quot; data-darkmode-color-16021670869911=&quot;rgb(136, 136, 136)&quot; data-darkmode-original-color-16021670869911=&quot;rgb(136, 136, 136)&quot; data-darkmode-bgcolor-16030289161394=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16030289161394=&quot;rgb(255, 255, 255)&quot; data-darkmode-color-16030289161394=&quot;rgb(136, 136, 136)&quot; data-darkmode-original-color-16030289161394=&quot;rgb(136, 136, 136)&quot; data-darkmode-bgcolor-16030315732716=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16030315732716=&quot;rgb(255, 255, 255)&quot; data-darkmode-color-16030315732716=&quot;rgb(136, 136, 136)&quot; data-darkmode-original-color-16030315732716=&quot;rgb(136, 136, 136)&quot;&gt;，关注公众号&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;回复&lt;/span&gt;&lt;span&gt;&lt;span&gt;1&lt;/span&gt;&lt;/span&gt;&lt;span&gt;，加入高级Node交流群&lt;/span&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;🎄 前言&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;小包在学习阮一峰大佬的《ES6入门教程》时，对文章顶部的&lt;strong&gt;阅读进度&lt;/strong&gt;功能产生了浓厚的兴趣。小包当时猜想应该是使用 &lt;code&gt;JavaScript&lt;/code&gt; 实现的，但最近爱上了浩如烟海的 &lt;code&gt;CSS&lt;/code&gt; ，于是小包有个大胆的想法，单纯的 &lt;code&gt;CSS&lt;/code&gt; 能实现阅读进度功能吗？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;能，不止能，还非常巧妙！&lt;code&gt;CSS⭐CSS⭐CSS&lt;/code&gt; 真的太强了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;虽然通过 &lt;code&gt;CSS&lt;/code&gt; 可以实现阅读进度问题，但 &lt;code&gt;JavaScript&lt;/code&gt; 作为老本行，一样得精通。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;因此学习本文，你可以学会:&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;使用 &lt;code&gt;JavaScript&lt;/code&gt; 实现阅读进度功能&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;使用 &lt;code&gt;CSS&lt;/code&gt; 实现阅读进度功能&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;🔥 利用JavaScript实现阅读进度&lt;/span&gt;&lt;/h2&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;📃 HTML与CSS&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;html css&lt;/code&gt; 部分非常简单，通过嵌套的两个 &lt;code&gt;div&lt;/code&gt; 实现，外部的 &lt;code&gt;div&lt;/code&gt; 提供底色背景，内部 &lt;code&gt;div&lt;/code&gt; 显示阅读进度&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;&amp;lt;&lt;span&gt;div&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;=&lt;span&gt;&quot;read_pro&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&amp;lt;&lt;span&gt;div&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;=&lt;span&gt;&quot;read_pro_inner&quot;&lt;/span&gt;&amp;gt;&amp;lt;/&lt;span&gt;div&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&amp;lt;/&lt;span&gt;div&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;复制代码&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;.read_pro&lt;/span&gt; {&lt;br/&gt;    &lt;span&gt;position&lt;/span&gt;: fixed;&lt;br/&gt;    &lt;span&gt;top&lt;/span&gt;: &lt;span&gt;0&lt;/span&gt;;&lt;br/&gt;    &lt;span&gt;left&lt;/span&gt;: &lt;span&gt;0&lt;/span&gt;;&lt;br/&gt;    &lt;span&gt;width&lt;/span&gt;: &lt;span&gt;100%&lt;/span&gt;;&lt;br/&gt;    &lt;span&gt;height&lt;/span&gt;: &lt;span&gt;3px&lt;/span&gt;;&lt;br/&gt;    &lt;span&gt;background-color&lt;/span&gt;: &lt;span&gt;#DDD&lt;/span&gt;;&lt;br/&gt;}&lt;br/&gt;&lt;span&gt;.read_pro_inner&lt;/span&gt; {&lt;br/&gt;    &lt;span&gt;content&lt;/span&gt;: &lt;span&gt;&#x27;&#x27;&lt;/span&gt;;&lt;br/&gt;    &lt;span&gt;position&lt;/span&gt;: absolute;&lt;br/&gt;    &lt;span&gt;left&lt;/span&gt;: &lt;span&gt;0&lt;/span&gt;;&lt;br/&gt;    &lt;span&gt;height&lt;/span&gt;: &lt;span&gt;100%&lt;/span&gt;;&lt;br/&gt;    &lt;span&gt;background-color&lt;/span&gt;: &lt;span&gt;#0089f2&lt;/span&gt;;&lt;br/&gt;}&lt;br/&gt;复制代码&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当我们设置 &lt;code&gt;.read_pro_inner&lt;/code&gt; 的宽度为 &lt;code&gt;20%&lt;/code&gt; 时，得到的效果图如下:&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.06694560669456066&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz/H8M5QJDxMHrrOcWZv0kibCibqOT4dpARh4LuvqhGp3jM0hbuwFNtfeErDpNPIzbJJWxwopMSBj7urib7uQfOrX2LA/640?wx_fmt=other&quot; data-type=&quot;other&quot; data-w=&quot;478&quot;/&gt;&lt;figcaption&gt;read_pro_js.png&lt;/figcaption&gt;&lt;/figure&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;只截取部分图，并放大了浏览器，要不灰色部分会非常长&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;台子搭好了，下面就是通过 &lt;code&gt;js&lt;/code&gt; 来动态计算 &lt;code&gt;read_pro_inner&lt;/code&gt; 的 &lt;code&gt;width&lt;/code&gt; 即可。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;🎬 JS实现&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果我们利用 &lt;code&gt;JavaScript&lt;/code&gt; 来实现阅读进度，我们要获取到文档的总高度、文档滚动距离、浏览器窗口的可视高度。&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;文档总高度: &lt;code&gt;document.documentElement.scrollHeight&lt;/code&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;窗口可视高度: &lt;code&gt;document.documentElment.cliengHeight&lt;/code&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;滚动距离: &lt;code&gt;document.documentElement.scrollTop || document.body.scrollTop&lt;/code&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;光看上面三个属性的名字有几分难以理解，来看一张示意图&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.8082191780821918&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz/H8M5QJDxMHrrOcWZv0kibCibqOT4dpARh4g0U5z5iapz3Pf52WricThImagJR62W2yRz8PeU50ULUsTSB8hVM8Iicbg/640?wx_fmt=other&quot; data-type=&quot;other&quot; data-w=&quot;511&quot;/&gt;&lt;figcaption&gt;scroll.jpg&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;从上图可以看到 &lt;code&gt;scrollTop&lt;/code&gt; 就是已经读过被卷起来的文档部分，&lt;code&gt;scrollHeight&lt;/code&gt; 是文档的总长度，&lt;code&gt;clientHeight&lt;/code&gt; 是浏览器显示区域的高度&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;图源: &lt;span&gt;慕课手记&lt;/span&gt;&lt;sup&gt;[2]&lt;/sup&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;获取上面几个属性值后，阅读进度就可以通过下面的公式计算出来&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;readProInner.style.width = +(scrollTop / (scrollHeight- clientHeight)).toFixed(&lt;span&gt;2&lt;/span&gt;)*&lt;span&gt;100&lt;/span&gt; + &lt;span&gt;&#x27;%&#x27;&lt;/span&gt;&lt;br/&gt;复制代码&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;大家可能会有疑惑，为什么分母是 &lt;code&gt;scrollHeight- clientHeight&lt;/code&gt; 而不是 &lt;code&gt;scrollHeight&lt;/code&gt;?&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当滚动条滚动到底部时，浏览器此时仍显示一屏内容，此时滚动条无法再滚动，&lt;code&gt;scrollTop&lt;/code&gt; 无法再增加，因此 &lt;code&gt;scrollTop&lt;/code&gt; 的最大值是 &lt;code&gt;scrollHeight- clientHeight&lt;/code&gt; ，如果使用 &lt;code&gt;scrollHeight&lt;/code&gt; 做分母，阅读进度最终无法达到 &lt;code&gt;100%&lt;/code&gt;。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;document&lt;/span&gt;.addEventListener(&lt;span&gt;&#x27;scroll&#x27;&lt;/span&gt;, &lt;span&gt;&lt;span&gt;function&lt;/span&gt;(&lt;span&gt;e&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;const&lt;/span&gt; scrollTop = &lt;span&gt;document&lt;/span&gt;.documentElement.scrollTop || &lt;span&gt;document&lt;/span&gt;.body.scrollTop;&lt;br/&gt;    readProInner.style.width = +(scrollTop/(scrollHeight-clientHeight)).toFixed(&lt;span&gt;2&lt;/span&gt;)*&lt;span&gt;100&lt;/span&gt; + &lt;span&gt;&#x27;%&#x27;&lt;/span&gt;&lt;br/&gt;})&lt;br/&gt;复制代码&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;使用 &lt;code&gt;js&lt;/code&gt; 实现需要监听 &lt;code&gt;scroll&lt;/code&gt; 事件，而且滚动时有可能是频繁的 &lt;code&gt;scroll&lt;/code&gt; 事件触发，有可能会造成一定的性能浪费，所以我们来一起学习 &lt;code&gt;css&lt;/code&gt; 实现方案&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;🌟 使用CSS实现阅读进度&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;使用 &lt;code&gt;CSS&lt;/code&gt; 实现阅读进度的方法很有意思，而且非常巧妙，不多说了，一起来看看。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;📕预备知识&lt;/span&gt;&lt;/h3&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;code&gt;linear-gradient&lt;/code&gt;: 线性渐变，第一个参数为渐变方向，后面是颜色比例变化。&lt;/p&gt;&lt;p&gt;比如设置 &lt;code&gt;linear-gradient(to right top, #0089f2 50%, #DDD 50%)&lt;/code&gt;&lt;/p&gt;&lt;p&gt;就可以实现下面效果，一个蓝色的三角形:&lt;/p&gt;&lt;figure&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5714285714285714&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz/H8M5QJDxMHrrOcWZv0kibCibqOT4dpARh4p6PehicqcE6EjM4T5gic9bhVraGxHnXkYpuPZgIlOkTJqM9VtG7WrEhQ/640?wx_fmt=other&quot; data-type=&quot;other&quot; data-w=&quot;980&quot;/&gt;&lt;figcaption&gt;body-linear.png&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;看到这种蓝色的三角形，你有没有感觉离阅读进度已经很近了？&lt;/p&gt;&lt;p&gt;如果我们用一块白块遮住蓝块，只留一条缝在顶部，那当前显示出来蓝色块的底边不就是阅读进度吗？&lt;/p&gt;&lt;figure&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6889168765743073&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz/H8M5QJDxMHrrOcWZv0kibCibqOT4dpARh4fStelicuKnugfkKeaQ2iaC22UKKXxYVIubCLicgOJ4wWzh5CibkWhE9OTA/640?wx_fmt=other&quot; data-type=&quot;other&quot; data-w=&quot;794&quot;/&gt;&lt;figcaption&gt;scrollPro.gif&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;最后处理最后一屏的问题，保证滚动条滚动至底部时，阅读进度到达 &lt;code&gt;100%&lt;/code&gt;&lt;/p&gt;&lt;figure&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.7034739454094293&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz/H8M5QJDxMHrrOcWZv0kibCibqOT4dpARh4bKCZyD7UkoEpZWgh25XmhvcnTz1sZrEenotIvticDRgumlGEAiaMcrjw/640?wx_fmt=other&quot; data-type=&quot;other&quot; data-w=&quot;806&quot;/&gt;&lt;figcaption&gt;scrollBottom.png&lt;/figcaption&gt;&lt;/figure&gt;&lt;blockquote&gt;&lt;p&gt;这里如果没能理解原理，不用急，后面我会更详细的演示&lt;/p&gt;&lt;/blockquote&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;code&gt;@supports&lt;/code&gt;&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;类似于 &lt;code&gt;js&lt;/code&gt; 的功能检查，可以检查 &lt;code&gt;CSS&lt;/code&gt; 中某一属性或功能当前浏览器是否支持。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;💡 实现原理&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上面讲解 &lt;code&gt;linear-height&lt;/code&gt; 时，我们提出了一种实现方案: 使用一块白块遮住蓝块，只留一条缝在顶部，显示的蓝条长度就是阅读进度&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;光说不难假把式，为了方便大家理解原理，我们使用一个案例来模拟一下，蓝块仍保持原来大小，使用一块 &lt;code&gt;0.8&lt;/code&gt; 透明度的黑块盖在上面，黑块给蓝块在顶部空出 &lt;code&gt;10px&lt;/code&gt; 空间。具体看下面演示&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.7424441524310118&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/udZl15qqib0NGIZrkCnFNDMWZ0gChVrhia0fA8oWC26SlTZD7zsksiaicXDTvJictyWnYTeFNm93PtjvYMxLRlCdy0w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;761&quot;/&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;figcaption&gt;scrollShow.gif&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;现在是不是感觉瞬间茅塞顿开&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;💻 CSS实现&lt;/span&gt;&lt;/h3&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;pre&gt;&lt;code&gt;首先使用 `linear-gradient` 实现蓝色背景块，并且要空出最后一屏&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;body&lt;/span&gt;{ &lt;br/&gt;    &lt;span&gt;background&lt;/span&gt;: &lt;span&gt;linear-gradient&lt;/span&gt;(to right top, #&lt;span&gt;0089&lt;/span&gt;f2 &lt;span&gt;50%&lt;/span&gt;, #DDD &lt;span&gt;50%&lt;/span&gt;);&lt;br/&gt;    &lt;span&gt;/* 通过 calc 函数配合 100vh 就可以从总长中删除一屏的高度 */&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;/* 100vh 浏览器视口的高度 */&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;background-size&lt;/span&gt;: &lt;span&gt;100%&lt;/span&gt; &lt;span&gt;calc&lt;/span&gt;(&lt;span&gt;100%&lt;/span&gt; - &lt;span&gt;100vh&lt;/span&gt; + &lt;span&gt;4px&lt;/span&gt;);&lt;br/&gt;    &lt;span&gt;background-repeat&lt;/span&gt;: no-repeat;&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;复制代码&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;ol start=&quot;2&quot; data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;设置盖住蓝块的白块&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;阅读进度条的高度为 &lt;code&gt;3px&lt;/code&gt; ，因此设置白块的高度为 &lt;code&gt;100% \- 3px&lt;/code&gt;，可以另外加一个 &lt;code&gt;div&lt;/code&gt; 元素来设置白块，但小包推荐使用为元素 &lt;code&gt;:before/:after&lt;/code&gt; ，伪元素不在文档流之中，方便渲染和控制&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;body&lt;/span&gt;&lt;span&gt;:before&lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;content&lt;/span&gt;:&lt;span&gt;&#x27;&#x27;&lt;/span&gt;;&lt;br/&gt;    &lt;span&gt;/* fixed定位 */&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;position&lt;/span&gt;: fixed;&lt;br/&gt;    &lt;span&gt;/* 同时设置 top 和 bottom 可以拉伸 height */&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;/* 设置高度为 100% - 3px */&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;top&lt;/span&gt;: &lt;span&gt;3px&lt;/span&gt;;&lt;br/&gt;    &lt;span&gt;bottom&lt;/span&gt;: &lt;span&gt;0&lt;/span&gt;;&lt;br/&gt;    &lt;span&gt;width&lt;/span&gt;: &lt;span&gt;100%&lt;/span&gt;;&lt;br/&gt;    &lt;span&gt;/* 降低层级，白块显示在文字之下 */&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;z-index&lt;/span&gt;: -&lt;span&gt;1&lt;/span&gt;;&lt;br/&gt;    &lt;span&gt;background&lt;/span&gt;: white;&lt;br/&gt;}&lt;br/&gt;复制代码&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;通过上面简单的代码，就可以实现封面阅读进度效果了，撒花~~~~&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;🛕 源码仓库&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;传送门: &lt;span&gt;阅读进度功能&lt;/span&gt;&lt;sup&gt;[3]&lt;/sup&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果感觉有帮助的话，别忘了给小包点个 ⭐ 。&lt;/p&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>a054a99a29b668e9d38dc187ab08d4d6</guid>
<title>基于 Doris 的知乎 DMP 系统架构与实践</title>
<link>https://toutiao.io/k/902qs8s</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;profile_inner&quot;&gt;
                  &lt;strong class=&quot;profile_nickname&quot;&gt;DataFunTalk&lt;/strong&gt;
                  &lt;img class=&quot;profile_avatar&quot; id=&quot;js_profile_qrcode_img&quot; src=&quot;&quot; alt=&quot;&quot;/&gt;

                  &lt;p class=&quot;profile_meta&quot;&gt;
                  &lt;label class=&quot;profile_meta_label&quot;&gt;Weixin ID&lt;/label&gt;
                  &lt;span class=&quot;profile_meta_value&quot;&gt;datafuntalk&lt;/span&gt;
                  &lt;/p&gt;

                  &lt;p class=&quot;profile_meta&quot;&gt;
                  &lt;label class=&quot;profile_meta_label&quot;&gt;About Feature&lt;/label&gt;
                  &lt;span class=&quot;profile_meta_value&quot;&gt;专注于大数据、人工智能技术应用的分享与交流。致力于成就百万数据科学家。定期组织技术分享直播，并整理大数据、推荐/搜索算法、广告算法、NLP 自然语言处理算法、智能风控、自动驾驶、机器学习/深度学习等技术应用文章。&lt;/span&gt;
                  &lt;/p&gt;
                &lt;/div&gt;
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>69c9d98928b722d928436a014bbbc6fd</guid>
<title>Dubbo 泛化调用引发的“血案”</title>
<link>https://toutiao.io/k/goxfkdv</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;上个月公司 ZooKeeper 集群发生了一次故障，要求所有项目组自检有无使用 Dubbo 编程式或者泛化调用，强制使用 @Reference 生成 Consumer。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;平台部给出的故障原因：&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;泛化调用时候，provider 没启动，导致每次请求都在 ZooKeeper 创建消费节点，导致在短时间大量访问 &lt;span&gt;ZooKeeper &lt;/span&gt;并创建了240万+ 的节点，导致 ZooKeeper 所有节点陆续崩溃导致，多个应用因无法连接到 ZooKeeper 报错。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;原因是听说泛化调用时候，provider 没启动，导致每次请求都在 &lt;span&gt;ZooKeeper&lt;/span&gt;&lt;span&gt; &lt;/span&gt;创建消费节点。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;由于并不是自己负责的项目，为了弄清楚背后的原因，通过进行实验来探究该故障的深层次原因。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;span&gt;2、求证&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;span&gt;2.1 泛化不使用缓存&lt;/span&gt;&lt;/strong&gt;&lt;/h4&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;测试代码如下：&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;javascript&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;public Result&amp;lt;&lt;span class=&quot;code-snippet__built_in&quot;&gt;Map&lt;/span&gt;&amp;gt; getProductGenericCache(ProductDTO dto) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    ReferenceConfig&amp;lt;GenericService&amp;gt; reference = &lt;span class=&quot;code-snippet__keyword&quot;&gt;new&lt;/span&gt; ReferenceConfig&amp;lt;GenericService&amp;gt;();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    ApplicationConfig application = &lt;span class=&quot;code-snippet__keyword&quot;&gt;new&lt;/span&gt; ApplicationConfig();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    application.setName(&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;dubbo-demo-client-consumer-generic&quot;&lt;/span&gt;);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    RegistryConfig registry = &lt;span class=&quot;code-snippet__keyword&quot;&gt;new&lt;/span&gt; RegistryConfig();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    registry.setAddress(&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;zookeeper://127.0.0.1:2181&quot;&lt;/span&gt;);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    ConsumerConfig consumer = &lt;span class=&quot;code-snippet__keyword&quot;&gt;new&lt;/span&gt; ConsumerConfig();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    consumer.setTimeout(&lt;span class=&quot;code-snippet__number&quot;&gt;5000&lt;/span&gt;);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    consumer.setRetries(&lt;span class=&quot;code-snippet__number&quot;&gt;0&lt;/span&gt;);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    reference.setApplication(application);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    reference.setRegistry(registry);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    reference.setConsumer(consumer);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    reference.setInterface(com.demo.dubbo.api.ProductService.class); &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    reference.setGeneric(&lt;span class=&quot;code-snippet__literal&quot;&gt;true&lt;/span&gt;); &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    GenericService svc = reference.get();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__built_in&quot;&gt;Object&lt;/span&gt; target = svc.$invoke(&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;findProduct&quot;&lt;/span&gt;, &lt;span class=&quot;code-snippet__keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;code-snippet__built_in&quot;&gt;String&lt;/span&gt;[]{ProductDTO.class.getName()}, &lt;span class=&quot;code-snippet__keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;code-snippet__built_in&quot;&gt;Object&lt;/span&gt;[]{dto});&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;return&lt;/span&gt; Result.success((&lt;span class=&quot;code-snippet__built_in&quot;&gt;Map&lt;/span&gt;)target);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;由于没有缓存 reference，因此每次请求这个方法，就会在 &lt;span&gt;ZooKeeper&lt;/span&gt;&lt;span&gt; &lt;/span&gt;创建个消费节点（无论 provider 是否启动）。请求量大的时候，就会导致 &lt;span&gt;ZooKeeper&lt;/span&gt;&lt;span&gt; &lt;/span&gt;所有节点陆续崩溃。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;如果泛化不使用缓存，请求量大时会创建大量 &lt;span&gt;ZooKeeper&lt;/span&gt;&lt;span&gt; &lt;/span&gt;节点。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;span&gt;2.2 泛化使用缓存&lt;/span&gt;&lt;/strong&gt;&lt;/h4&gt;&lt;p&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;测试代码如下：&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;javascript&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;@Override&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;public Result&amp;lt;&lt;span class=&quot;code-snippet__built_in&quot;&gt;Map&lt;/span&gt;&amp;gt; getProductGenericCache(ProductDTO dto) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    ReferenceConfigCache referenceCache = ReferenceConfigCache.getCache();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    ReferenceConfig&amp;lt;GenericService&amp;gt; reference = &lt;span class=&quot;code-snippet__keyword&quot;&gt;new&lt;/span&gt; ReferenceConfig&amp;lt;GenericService&amp;gt;();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    ApplicationConfig application = &lt;span class=&quot;code-snippet__keyword&quot;&gt;new&lt;/span&gt; ApplicationConfig();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    application.setName(&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;pangu-client-consumer-generic&quot;&lt;/span&gt;);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    RegistryConfig registry = &lt;span class=&quot;code-snippet__keyword&quot;&gt;new&lt;/span&gt; RegistryConfig();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    registry.setAddress(&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;zookeeper://127.0.0.1:2181&quot;&lt;/span&gt;);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    ConsumerConfig consumer = &lt;span class=&quot;code-snippet__keyword&quot;&gt;new&lt;/span&gt; ConsumerConfig();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    consumer.setTimeout(&lt;span class=&quot;code-snippet__number&quot;&gt;5000&lt;/span&gt;);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    consumer.setRetries(&lt;span class=&quot;code-snippet__number&quot;&gt;0&lt;/span&gt;);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    reference.setApplication(application);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    reference.setRegistry(registry);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    reference.setConsumer(consumer);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    reference.setInterface(com.demo.dubbo.api.ProductService.class); &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    reference.setGeneric(&lt;span class=&quot;code-snippet__literal&quot;&gt;true&lt;/span&gt;); &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    GenericService svc = referenceCache.get(reference);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__built_in&quot;&gt;Object&lt;/span&gt; target = svc.$invoke(&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;findProduct&quot;&lt;/span&gt;, &lt;span class=&quot;code-snippet__keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;code-snippet__built_in&quot;&gt;String&lt;/span&gt;[]{ProductDTO.class.getName()}, &lt;span class=&quot;code-snippet__keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;code-snippet__built_in&quot;&gt;Object&lt;/span&gt;[]{dto});&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;return&lt;/span&gt; Result.success((&lt;span class=&quot;code-snippet__built_in&quot;&gt;Map&lt;/span&gt;)target);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;经过测试，如果使用缓存，无论 provider 端无论是否启动，都只会在 &lt;span&gt;ZooKeeper&lt;/span&gt;&lt;span&gt; &lt;/span&gt;创建一个消费节点。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;span&gt;2.3 设置服务检查为 true&lt;/span&gt;&lt;/strong&gt;&lt;/h4&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;设置 check=true，测试代码如下：&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;javascript&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;@Override&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;public Result&amp;lt;&lt;span class=&quot;code-snippet__built_in&quot;&gt;Map&lt;/span&gt;&amp;gt; getProductGenericCache(ProductDTO dto) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    ReferenceConfigCache referenceCache = ReferenceConfigCache.getCache();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    ReferenceConfig&amp;lt;GenericService&amp;gt; reference = &lt;span class=&quot;code-snippet__keyword&quot;&gt;new&lt;/span&gt; ReferenceConfig&amp;lt;GenericService&amp;gt;();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    ApplicationConfig application = &lt;span class=&quot;code-snippet__keyword&quot;&gt;new&lt;/span&gt; ApplicationConfig();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    application.setName(&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;pangu-client-consumer-generic&quot;&lt;/span&gt;);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    RegistryConfig registry = &lt;span class=&quot;code-snippet__keyword&quot;&gt;new&lt;/span&gt; RegistryConfig();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    registry.setAddress(&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;zookeeper://127.0.0.1:2181&quot;&lt;/span&gt;);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    ConsumerConfig consumer = &lt;span class=&quot;code-snippet__keyword&quot;&gt;new&lt;/span&gt; ConsumerConfig();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    consumer.setTimeout(&lt;span class=&quot;code-snippet__number&quot;&gt;5000&lt;/span&gt;);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    consumer.setRetries(&lt;span class=&quot;code-snippet__number&quot;&gt;0&lt;/span&gt;);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    reference.setApplication(application);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    reference.setRegistry(registry);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    reference.setConsumer(consumer);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    reference.setCheck(&lt;span class=&quot;code-snippet__literal&quot;&gt;true&lt;/span&gt;);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    reference.setInterface(org.pangu.api.ProductService.class); &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    reference.setGeneric(&lt;span class=&quot;code-snippet__literal&quot;&gt;true&lt;/span&gt;); &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    GenericService svc = referenceCache.get(reference);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__built_in&quot;&gt;Object&lt;/span&gt; target = svc.$invoke(&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;findProduct&quot;&lt;/span&gt;, &lt;span class=&quot;code-snippet__keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;code-snippet__built_in&quot;&gt;String&lt;/span&gt;[]{ProductDTO.class.getName()}, &lt;span class=&quot;code-snippet__keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;code-snippet__built_in&quot;&gt;Object&lt;/span&gt;[]{dto});&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;return&lt;/span&gt; Result.success((&lt;span class=&quot;code-snippet__built_in&quot;&gt;Map&lt;/span&gt;)target);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;span&gt;情况一&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;启动 provider 服务，然后启动消费端泛化，请求此泛化方法时，在 &lt;span&gt;ZooKeeper&lt;/span&gt;&lt;span&gt; &lt;/span&gt;只注册了一个 consumer 节点；停止 provider，再请求此泛化方法，发现 &lt;span&gt;ZooKeeper&lt;/span&gt;&lt;span&gt; &lt;/span&gt;上此节点数量不变化。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;这是为什么呢？&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;provider 停止后，请求不再创建 &lt;span&gt;ZooKeeper&lt;/span&gt;&lt;span&gt; &lt;/span&gt;节点的原因是 RegistryConfig 的 ref 已经在启动时候生成了代理（由于启动时候 provider 服务存在，check=true 校验过通过），因此不再创建。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;span&gt;情况二&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;不启动 provider 服务，直接启动消费端泛化，请求此泛化方法，发现每请求一次，在 &lt;span&gt;ZooKeeper&lt;/span&gt;&lt;span&gt; &lt;/span&gt;就会创建一个消费节点。至此验证到故障。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-croporisrc=&quot;https://mmbiz.qpic.cn/mmbiz_png/Wkp2azia4QFvNYc4kKDXSEfLWHjuib7JWzT1StY5ia2ajba4v9Xh7me7icvpIibyMh705877DwTSIpwwLVvDYicVrSUQ/640?wx_fmt=png&quot; data-cropx1=&quot;0&quot; data-cropx2=&quot;614.076124567474&quot; data-cropy1=&quot;0&quot; data-cropy2=&quot;381.5726643598616&quot; data-ratio=&quot;0.6205211726384365&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/eZzl4LXykQxOnt2dib2u2fr0r3ccEicVQYkY8lLmRymCJ1484e5XhdtXLhKebECUbkjbDYzdiaUGQqNE68s8v8gHw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;614&quot;/&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/figure&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;那么这种情况，为什么会每次请求都在 &lt;span&gt;ZooKeeper&lt;/span&gt;&lt;span&gt; &lt;/span&gt;创建消费节点呢？根本原因是什么？&lt;/span&gt;&lt;/figure&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/figure&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;/&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;cs&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;private&lt;/span&gt; T &lt;span class=&quot;code-snippet__title&quot;&gt;createProxy&lt;/span&gt;(&lt;span class=&quot;code-snippet__params&quot;&gt;Map&amp;lt;String, String&amp;gt; map&lt;/span&gt;)&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;if&lt;/span&gt; (isJvmRefer) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    } &lt;span class=&quot;code-snippet__keyword&quot;&gt;else&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__keyword&quot;&gt;if&lt;/span&gt; (url != &lt;span class=&quot;code-snippet__literal&quot;&gt;null&lt;/span&gt; &amp;amp;&amp;amp; url.length() &amp;gt; &lt;span class=&quot;code-snippet__number&quot;&gt;0&lt;/span&gt;) { &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        } &lt;span class=&quot;code-snippet__keyword&quot;&gt;else&lt;/span&gt; { &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            List&amp;lt;URL&amp;gt; us = loadRegistries(&lt;span class=&quot;code-snippet__literal&quot;&gt;false&lt;/span&gt;); &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            &lt;span class=&quot;code-snippet__keyword&quot;&gt;if&lt;/span&gt; (us != &lt;span class=&quot;code-snippet__literal&quot;&gt;null&lt;/span&gt; &amp;amp;&amp;amp; !us.isEmpty()) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                &lt;span class=&quot;code-snippet__keyword&quot;&gt;for&lt;/span&gt; (URL u : us) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                    URL monitorUrl = loadMonitor(u);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                    &lt;span class=&quot;code-snippet__keyword&quot;&gt;if&lt;/span&gt; (monitorUrl != &lt;span class=&quot;code-snippet__literal&quot;&gt;null&lt;/span&gt;) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                        map.put(Constants.MONITOR_KEY, URL.encode(monitorUrl.toFullString()));&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                    }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                    urls.&lt;span class=&quot;code-snippet__keyword&quot;&gt;add&lt;/span&gt;(u.addParameterAndEncoded(Constants.REFER_KEY, StringUtils.toQueryString(map)));&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            &lt;span class=&quot;code-snippet__keyword&quot;&gt;if&lt;/span&gt; (urls.isEmpty()) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                &lt;span class=&quot;code-snippet__keyword&quot;&gt;throw&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;new&lt;/span&gt; IllegalStateException(&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;No such any registry to reference &quot;&lt;/span&gt; + interfaceName + &lt;span class=&quot;code-snippet__string&quot;&gt;&quot; on the consumer &quot;&lt;/span&gt; + NetUtils.getLocalHost() + &lt;span class=&quot;code-snippet__string&quot;&gt;&quot; use dubbo version &quot;&lt;/span&gt; + Version.getVersion() + &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;, please config &amp;lt;dubbo:registry address=\&quot;...\&quot; /&amp;gt; to your spring config.&quot;&lt;/span&gt;);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__keyword&quot;&gt;if&lt;/span&gt; (urls.size() == &lt;span class=&quot;code-snippet__number&quot;&gt;1&lt;/span&gt;) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            invoker = refprotocol.refer(interfaceClass, urls.&lt;span class=&quot;code-snippet__keyword&quot;&gt;get&lt;/span&gt;(&lt;span class=&quot;code-snippet__number&quot;&gt;0&lt;/span&gt;));&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        } &lt;span class=&quot;code-snippet__keyword&quot;&gt;else&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            List&amp;lt;Invoker&amp;lt;?&amp;gt;&amp;gt; invokers = &lt;span class=&quot;code-snippet__keyword&quot;&gt;new&lt;/span&gt; ArrayList&amp;lt;Invoker&amp;lt;?&amp;gt;&amp;gt;();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            URL registryURL = &lt;span class=&quot;code-snippet__literal&quot;&gt;null&lt;/span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            &lt;span class=&quot;code-snippet__keyword&quot;&gt;for&lt;/span&gt; (URL url : urls) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                invokers.&lt;span class=&quot;code-snippet__keyword&quot;&gt;add&lt;/span&gt;(refprotocol.refer(interfaceClass, url));&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                &lt;span class=&quot;code-snippet__keyword&quot;&gt;if&lt;/span&gt; (Constants.REGISTRY_PROTOCOL.&lt;span class=&quot;code-snippet__keyword&quot;&gt;equals&lt;/span&gt;(url.getProtocol())) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                    registryURL = url; &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            &lt;span class=&quot;code-snippet__keyword&quot;&gt;if&lt;/span&gt; (registryURL != &lt;span class=&quot;code-snippet__literal&quot;&gt;null&lt;/span&gt;) { &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                URL u = registryURL.addParameterIfAbsent(Constants.CLUSTER_KEY, AvailableCluster.NAME);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                invoker = cluster.&lt;span class=&quot;code-snippet__keyword&quot;&gt;join&lt;/span&gt;(&lt;span class=&quot;code-snippet__keyword&quot;&gt;new&lt;/span&gt; StaticDirectory(u, invokers));&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            } &lt;span class=&quot;code-snippet__keyword&quot;&gt;else&lt;/span&gt; { &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                invoker = cluster.&lt;span class=&quot;code-snippet__keyword&quot;&gt;join&lt;/span&gt;(&lt;span class=&quot;code-snippet__keyword&quot;&gt;new&lt;/span&gt; StaticDirectory(invokers));&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    Boolean c = check;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;if&lt;/span&gt; (c == &lt;span class=&quot;code-snippet__literal&quot;&gt;null&lt;/span&gt; &amp;amp;&amp;amp; consumer != &lt;span class=&quot;code-snippet__literal&quot;&gt;null&lt;/span&gt;) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        c = consumer.isCheck();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;if&lt;/span&gt; (c == &lt;span class=&quot;code-snippet__literal&quot;&gt;null&lt;/span&gt;) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        c = &lt;span class=&quot;code-snippet__literal&quot;&gt;true&lt;/span&gt;; &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;if&lt;/span&gt; (c &amp;amp;&amp;amp; !invoker.isAvailable()) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        initialized = &lt;span class=&quot;code-snippet__literal&quot;&gt;false&lt;/span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__keyword&quot;&gt;throw&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;new&lt;/span&gt; IllegalStateException(&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;Failed to check the status of the service &quot;&lt;/span&gt; + interfaceName + &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;. No provider available for the service &quot;&lt;/span&gt; + (&lt;span class=&quot;code-snippet__keyword&quot;&gt;group&lt;/span&gt; == &lt;span class=&quot;code-snippet__literal&quot;&gt;null&lt;/span&gt; ? &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;&quot;&lt;/span&gt; : &lt;span class=&quot;code-snippet__keyword&quot;&gt;group&lt;/span&gt; + &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;/&quot;&lt;/span&gt;) + interfaceName + (version == &lt;span class=&quot;code-snippet__literal&quot;&gt;null&lt;/span&gt; ? &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;&quot;&lt;/span&gt; : &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;:&quot;&lt;/span&gt; + version) + &lt;span class=&quot;code-snippet__string&quot;&gt;&quot; from the url &quot;&lt;/span&gt; + invoker.getUrl() + &lt;span class=&quot;code-snippet__string&quot;&gt;&quot; to the consumer &quot;&lt;/span&gt; + NetUtils.getLocalHost() + &lt;span class=&quot;code-snippet__string&quot;&gt;&quot; use dubbo version &quot;&lt;/span&gt; + Version.getVersion());&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;if&lt;/span&gt; (logger.isInfoEnabled()) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        logger.info(&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;Refer dubbo service &quot;&lt;/span&gt; + interfaceClass.getName() + &lt;span class=&quot;code-snippet__string&quot;&gt;&quot; from url &quot;&lt;/span&gt; + invoker.getUrl());&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;return&lt;/span&gt; (T) proxyFactory.getProxy(invoker);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;首次请求泛化方法，由于 ReferenceConfig 的 ref 为 null，因此执行 createProxy，执行代码 @1、@2、@3，在 &lt;span&gt;ZooKeeper&lt;/span&gt;&lt;span&gt; &lt;/span&gt;创建消费节点，但是由于 check=true，因此抛出 IllegalStateException 异常，最终 ReferenceConfig 的 ref 依然为 null。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;第二次请求泛化方法，由于 ReferenceConfig 已经被缓存，这次的 ReferenceConfig 对象就是首次的 ReferenceConfig 对象，获取 ReferenceConfig 的代理对象 ref，由于 ReferenceConfig 的 ref 为 null，因此执行 createProxy，执行代码 @1、@2、@4，在 &lt;span&gt;ZooKeeper&lt;/span&gt;&lt;span&gt; &lt;/span&gt;创建消费节点，但是由于 check=true，因此抛出 IllegalStateException 异常，最终 ReferenceConfig 的 ref 依然为 null。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;第三次以及后续的请求，都和第二次请求是一样效果。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;为什么每次在 &lt;span&gt;ZooKeeper&lt;/span&gt;&lt;span&gt; &lt;/span&gt;都创建消费节点，只能说明订阅 URL 不同导致的。如果 &lt;span&gt;UR&lt;/span&gt;&lt;span&gt;L &lt;/span&gt;相同，在 &lt;span&gt;ZooKeeper&lt;/span&gt;&lt;span&gt; &lt;/span&gt;是不会创建的。那么订阅 &lt;span&gt;UR&lt;/span&gt;&lt;span&gt;L &lt;/span&gt;的组成对一个服务来说有哪些不同呢？&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;查看 ReferenceConfig.init()，发现订阅 &lt;span&gt;UR&lt;/span&gt;&lt;span&gt;L &lt;/span&gt;上有 timestamp，是当前时间戳，这也说明了为什么每次都去注册，因为订阅 &lt;span&gt;UR&lt;/span&gt;&lt;span&gt;L &lt;/span&gt;不同，如下图：&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.46882217090069284&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Wkp2azia4QFvNYc4kKDXSEfLWHjuib7JWzicYCCBBf3iahqpxJNsNmBFRLIqeqCoqdFNoGbxHnB2t369kLu9IGNVLQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;433&quot;/&gt;&lt;/figure&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.47344110854503463&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Wkp2azia4QFvNYc4kKDXSEfLWHjuib7JWzfG1DF7REiaFjT2pwCvLSM43Nyk5VThMtGzkib3zXibf8zRiakQf0zzs9HQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;433&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;订阅 &lt;span&gt;UR&lt;/span&gt;&lt;span&gt;L &lt;/span&gt;上加上这个 timestamp 是否有些不合理呢？&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;查看官方文档，在 2.7.5 版本中已经将订阅的 URL 中的 timestamp 去掉了，只会对一个 URL 订阅一次。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;由于使用了泛化调用，但启动者没有启动，而且使用了 check 等于 true，每次调用都会尝试去注册。但在 Dubbo 2.7.5 之前，注册的 URL 带了时间戳，导致每请求一次就在 &lt;span&gt;ZooKeeper&lt;/span&gt;&lt;span&gt; &lt;/span&gt;上创建一个节点，导致产生大量节点，最终导致 &lt;span&gt;ZooKeeper&lt;/span&gt;&lt;span&gt; &lt;/span&gt;崩掉。&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>66e2fa40c0c63e00ef9aac1a216eddac</guid>
<title>云原生大数据平台未来的发展趋势是什么？ - 知乎</title>
<link>https://toutiao.io/k/ask4hy4</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;span class=&quot;RichText ztext CopyrightRichText-richText css-yvdm7v&quot; options=&quot;[object Object]&quot; itemprop=&quot;text&quot;&gt;&lt;p data-first-child=&quot;&quot; data-pid=&quot;MMJixSE8&quot;&gt;今天我们谈企业的数字化转型、精细化运营，我们实际上谈的核心是：&lt;b&gt;数据。&lt;/b&gt;&lt;/p&gt;&lt;p data-pid=&quot;GeFtbAsP&quot;&gt;「大数据」是近几年一个较为火热的技术词汇，国际数据公司 (IDC) 认为大数据有四个特征：海量 (Volume)、高速 (Velocity)、异构 (Variety) 和价值密度低 (Value)&lt;sup data-text=&quot;2019 年中国大数据行业研究报告&quot; data-url=&quot;https://pdf.dfcfw.com/pdf/H3_AP201911251371103072_1.pdf&quot; data-numero=&quot;1&quot; data-draft-node=&quot;inline&quot; data-draft-type=&quot;reference&quot; data-tooltip=&quot;2019 年中国大数据行业研究报告 https://pdf.dfcfw.com/pdf/H3_AP201911251371103072_1.pdf&quot; data-tooltip-preset=&quot;white&quot; data-tooltip-classname=&quot;ztext-referene-tooltip&quot;&gt;&lt;a id=&quot;ref_1_0&quot; href=&quot;#ref_1&quot; data-reference-link=&quot;true&quot; aria-labelledby=&quot;ref_1&quot;&gt;[1]&lt;/a&gt;&lt;/sup&gt;。这也就意味着：&lt;b&gt;面对这种复杂度高的数据，企业难以用常规的手段进行处理，让数据得以发挥价值。&lt;/b&gt;&lt;/p&gt;&lt;p data-pid=&quot;YGtFcxIF&quot;&gt;大数据已经有了十余年的发展，从 2009 年流行的离线计算、2012 年的实时计算，再到 2015 年火热的机器学习，以及目前的主流方式：隐私计算、云原生。一个新的技术思想渐渐荷尖探头：数智融合。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://picx.zhimg.com/50/v2-4e5dc136a93cf0b2fc0d20e1867c2399_720w.jpg?source=1940ef5c&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1918&quot; data-rawheight=&quot;939&quot; data-default-watermark-src=&quot;https://pic4.zhimg.com/50/v2-5af035c4b092f54813b7298a83bdd547_720w.jpg?source=1940ef5c&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic1.zhimg.com/v2-4e5dc136a93cf0b2fc0d20e1867c2399_r.jpg?source=1940ef5c&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1918&quot; data-rawheight=&quot;939&quot; data-default-watermark-src=&quot;https://pic4.zhimg.com/50/v2-5af035c4b092f54813b7298a83bdd547_720w.jpg?source=1940ef5c&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic1.zhimg.com/v2-4e5dc136a93cf0b2fc0d20e1867c2399_r.jpg?source=1940ef5c&quot; data-actualsrc=&quot;https://picx.zhimg.com/50/v2-4e5dc136a93cf0b2fc0d20e1867c2399_720w.jpg?source=1940ef5c&quot;/&gt;&lt;figcaption&gt;△ 大数据技术发展的历程&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-pid=&quot;aOzR88mR&quot;&gt;&lt;b&gt;那么，在数智化时代，云原生到底意味着什么呢？&lt;/b&gt;&lt;/p&gt;&lt;p data-pid=&quot;ABi77yjn&quot;&gt;云原生首先是由 Matt Stine 提出并延用至今，基于 DCMC 技术体系（D: DevOps, C: Container, M: Microservices, C: CI/CD）去发挥云计算基础设施的优势&lt;sup data-text=&quot;Cloud Native Architectures - a Conversation with Matt Stine&quot; data-url=&quot;https://www.infoq.com/articles/cloud-native-architectures-matt-stine/&quot; data-numero=&quot;2&quot; data-draft-node=&quot;inline&quot; data-draft-type=&quot;reference&quot; data-tooltip=&quot;Cloud Native Architectures - a Conversation with Matt Stine https://www.infoq.com/articles/cloud-native-architectures-matt-stine/&quot; data-tooltip-preset=&quot;white&quot; data-tooltip-classname=&quot;ztext-referene-tooltip&quot;&gt;&lt;a id=&quot;ref_2_0&quot; href=&quot;#ref_2&quot; data-reference-link=&quot;true&quot; aria-labelledby=&quot;ref_2&quot;&gt;[2]&lt;/a&gt;&lt;/sup&gt;。&lt;/p&gt;&lt;p data-pid=&quot;JGSTE4eY&quot;&gt;云原生灵活的资源供给特性，给数据处理的架构带来了新鲜血液。大数据并不一定需要在云原生的环境下才能发展，但是云原生能让大数据释放出更大的能量。&lt;/p&gt;&lt;p data-pid=&quot;9y3r9wxI&quot;&gt;在这个背景下，&lt;b&gt;「云原生大数据平台」顺势诞生：它可以充分利用云基础设施来解决超大规模数据的获取、管理、存储和分析，并在整个数据治理的过程中降本增效，实现数据驱动商业。&lt;/b&gt;&lt;/p&gt;&lt;h2&gt;▎&lt;b&gt;如何实现大数据云原生&lt;/b&gt;&lt;/h2&gt;&lt;p data-pid=&quot;924-Qwx2&quot;&gt;对企业而言，数据是最重要的资产，而云原生大数据平台的价值就在于：如何让平台更易用，让企业能更聚焦数据之间的关系，进而更好地利用数据。&lt;/p&gt;&lt;p data-pid=&quot;ipCAkIhk&quot;&gt;当然，处理数据的系统或技术只是手段。我们在解决数据治理的问题时，关键点在于：&lt;b&gt;面向数据。&lt;/b&gt;&lt;/p&gt;&lt;p data-pid=&quot;aUnKyHgz&quot;&gt;基于这个原则，我们再结合市面上落地的技术，来分析数据价值化的最佳实践。&lt;/p&gt;&lt;p data-pid=&quot;kGyCIAUj&quot;&gt;一般而言，一个完善的大数据产品矩阵，至少应该包含以下三个层级：&lt;/p&gt;&lt;ul&gt;&lt;li data-pid=&quot;z0ohyyC6&quot;&gt;&lt;b&gt;数据基础设施：&lt;/b&gt;典型产品如数据湖计算 DLC、云数据仓库 CDW&lt;/li&gt;&lt;li data-pid=&quot;bUJbu286&quot;&gt;&lt;b&gt;数据中台服务：&lt;/b&gt;例如数据开发治理平台 WeData&lt;/li&gt;&lt;li data-pid=&quot;_tdSpRiC&quot;&gt;&lt;b&gt;数据应用服务：&lt;/b&gt;企业画像、可视交互系统等&lt;/li&gt;&lt;/ul&gt;&lt;p data-pid=&quot;ZZJq06_d&quot;&gt;首届腾讯云大数据峰会 ，腾讯云大数据发布了从基础引擎、数据治理到应用分析的完整产品矩阵，各位想详细了解的话也可以看一下。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pica.zhimg.com/50/v2-72043fb106592d2ee7407aa8f1c6cb3f_720w.jpg?source=1940ef5c&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1920&quot; data-rawheight=&quot;1080&quot; data-default-watermark-src=&quot;https://pic2.zhimg.com/50/v2-8c9a9bb50f5e3b24816196aa5c381b5d_720w.jpg?source=1940ef5c&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic3.zhimg.com/v2-72043fb106592d2ee7407aa8f1c6cb3f_r.jpg?source=1940ef5c&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1920&quot; data-rawheight=&quot;1080&quot; data-default-watermark-src=&quot;https://pic2.zhimg.com/50/v2-8c9a9bb50f5e3b24816196aa5c381b5d_720w.jpg?source=1940ef5c&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic3.zhimg.com/v2-72043fb106592d2ee7407aa8f1c6cb3f_r.jpg?source=1940ef5c&quot; data-actualsrc=&quot;https://pica.zhimg.com/50/v2-72043fb106592d2ee7407aa8f1c6cb3f_720w.jpg?source=1940ef5c&quot;/&gt;&lt;/figure&gt;&lt;p data-pid=&quot;2sSOaH76&quot;&gt;&lt;b&gt;其中，底层的大数据基础设施为挖掘数据价值夯实基础，帮助构建数据资产一体化：&lt;/b&gt;&lt;/p&gt;&lt;p data-pid=&quot;iM4jkEuR&quot;&gt;云数据仓库 CDW 是腾讯云实时云数仓品牌，旗下涵盖 CDW ClickHouse、CDWPostgreSQL、CDW Doris 等多款实时数仓引擎，覆盖 MySQL、PostgreSQL 生态，可以对海量数据进行即时的多维分析透视和业务探索，帮助客户快速构建企业云上数据仓库。&lt;/p&gt;&lt;p data-pid=&quot;M-UffZWv&quot;&gt;数据湖计算 DLC 提供了敏捷高效的数据湖分析服务。基于存算分离的产品架构体系实现数据资产统一建设，用户可以敏捷、低成本地管理和分析海量数据，打通数据孤岛，最大化释放数据价值。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pica.zhimg.com/50/v2-c02470bbdd390291224621b3e2c2cf36_720w.jpg?source=1940ef5c&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1920&quot; data-rawheight=&quot;1080&quot; data-default-watermark-src=&quot;https://picx.zhimg.com/50/v2-278ecf4734fd4efe9baffb598ee5f958_720w.jpg?source=1940ef5c&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pica.zhimg.com/v2-c02470bbdd390291224621b3e2c2cf36_r.jpg?source=1940ef5c&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1920&quot; data-rawheight=&quot;1080&quot; data-default-watermark-src=&quot;https://picx.zhimg.com/50/v2-278ecf4734fd4efe9baffb598ee5f958_720w.jpg?source=1940ef5c&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pica.zhimg.com/v2-c02470bbdd390291224621b3e2c2cf36_r.jpg?source=1940ef5c&quot; data-actualsrc=&quot;https://pica.zhimg.com/50/v2-c02470bbdd390291224621b3e2c2cf36_720w.jpg?source=1940ef5c&quot;/&gt;&lt;figcaption&gt;△ 腾讯云大数据基础产品&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-pid=&quot;RW5H5Q9p&quot;&gt;&lt;b&gt;在提升数据价值密度的中间阶段，依靠的是大数据平台工具：如数据开发治理平台 WeData 等。&lt;/b&gt;&lt;/p&gt;&lt;p data-pid=&quot;chqGtryp&quot;&gt;WeData 是位于云端的一站式数据开发治理平台，融合了包含数据集成、数据开发、任务运维的全链路 DataOps 数据开发能力，以及数据地图、数据质量、数据安全等一系列数据治理和运营能力。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pica.zhimg.com/50/v2-9bfea9f24c4e11c4dea1b25382a45aac_720w.jpg?source=1940ef5c&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1920&quot; data-rawheight=&quot;1080&quot; data-default-watermark-src=&quot;https://pica.zhimg.com/50/v2-42641df44abf320d5b9ab5b71a1cb566_720w.jpg?source=1940ef5c&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pica.zhimg.com/v2-9bfea9f24c4e11c4dea1b25382a45aac_r.jpg?source=1940ef5c&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1920&quot; data-rawheight=&quot;1080&quot; data-default-watermark-src=&quot;https://pica.zhimg.com/50/v2-42641df44abf320d5b9ab5b71a1cb566_720w.jpg?source=1940ef5c&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pica.zhimg.com/v2-9bfea9f24c4e11c4dea1b25382a45aac_r.jpg?source=1940ef5c&quot; data-actualsrc=&quot;https://pica.zhimg.com/50/v2-9bfea9f24c4e11c4dea1b25382a45aac_720w.jpg?source=1940ef5c&quot;/&gt;&lt;figcaption&gt;△ WeData 数据开发治理平台&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-pid=&quot;UgtUcVlA&quot;&gt;&lt;b&gt;通过底层基础设施和中台服务的构建，才形成了上层如企业画像、智能数据分析、大数据可视交互系统等大家能轻松上手的数据应用工具。&lt;/b&gt;&lt;/p&gt;&lt;p data-pid=&quot;_zVAzWq9&quot;&gt;三层由底到高，层层递进。&lt;/p&gt;&lt;h2&gt;▎&lt;b&gt;数据治理方法论&lt;/b&gt;&lt;/h2&gt;&lt;p data-pid=&quot;rO7PgdG3&quot;&gt;企业在进行「大数据」技术选型的时候，&lt;b&gt;除了要关注数据的「大」，更要关心数据的「治」，也就是「数据治理」。&lt;/b&gt;&lt;/p&gt;&lt;p data-pid=&quot;u_4-Zwox&quot;&gt;说起来看似轻巧，实际情况有「亿点点」复杂。&lt;/p&gt;&lt;p data-pid=&quot;VMndEgjh&quot;&gt;技术落地，需求先行。在数字化不同阶段，数据治理需要关注的核心需求是不一样的。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pica.zhimg.com/50/v2-7929e92ff6f14071c5dc89b81b72dc7d_720w.jpg?source=1940ef5c&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1349&quot; data-rawheight=&quot;561&quot; data-default-watermark-src=&quot;https://pica.zhimg.com/50/v2-842b363b9a780928189c4afd6d99ef13_720w.jpg?source=1940ef5c&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic1.zhimg.com/v2-7929e92ff6f14071c5dc89b81b72dc7d_r.jpg?source=1940ef5c&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1349&quot; data-rawheight=&quot;561&quot; data-default-watermark-src=&quot;https://pica.zhimg.com/50/v2-842b363b9a780928189c4afd6d99ef13_720w.jpg?source=1940ef5c&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic1.zhimg.com/v2-7929e92ff6f14071c5dc89b81b72dc7d_r.jpg?source=1940ef5c&quot; data-actualsrc=&quot;https://pica.zhimg.com/50/v2-7929e92ff6f14071c5dc89b81b72dc7d_720w.jpg?source=1940ef5c&quot;/&gt;&lt;figcaption&gt;△ 数据治理之「马斯洛需求层次」&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-pid=&quot;gNe86hov&quot;&gt;在腾讯内部，数据治理不仅有来自管理的挑战，还有来自技术和业务的挑战。&lt;/p&gt;&lt;p data-pid=&quot;RD_joMC0&quot;&gt;在数百条产品线、数万业务场景、总存储达到 EB 级的情况下，首要的一点是&lt;b&gt;「组织支撑」：即基于 Oteam 协同构建全集团大数据统一体系。&lt;/b&gt;&lt;/p&gt;&lt;p data-pid=&quot;lx8juyrz&quot;&gt;在腾讯统一的数据平台体系中，数据资产化成为了可能，并在其上进一步赋予业务属性，建立数据服务生态。最后加持以新的技术能力，如机器学习、数智融合等，来挖掘数据价值，真正地通过数据驱动新的业务模式孵化和创新。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/50/v2-8a4a0e74fd4b3f9149c8f529258ad288_720w.jpg?source=1940ef5c&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1920&quot; data-rawheight=&quot;1080&quot; data-default-watermark-src=&quot;https://picx.zhimg.com/50/v2-a5690ea26feb8f28d7f2c6d7364a28e0_720w.jpg?source=1940ef5c&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pica.zhimg.com/v2-8a4a0e74fd4b3f9149c8f529258ad288_r.jpg?source=1940ef5c&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1920&quot; data-rawheight=&quot;1080&quot; data-default-watermark-src=&quot;https://picx.zhimg.com/50/v2-a5690ea26feb8f28d7f2c6d7364a28e0_720w.jpg?source=1940ef5c&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pica.zhimg.com/v2-8a4a0e74fd4b3f9149c8f529258ad288_r.jpg?source=1940ef5c&quot; data-actualsrc=&quot;https://pic1.zhimg.com/50/v2-8a4a0e74fd4b3f9149c8f529258ad288_720w.jpg?source=1940ef5c&quot;/&gt;&lt;figcaption&gt;△ 腾讯内部实践方法论&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-pid=&quot;QU0x3H9c&quot;&gt;以 QQ 音乐为例，QQ 音乐每天承载着万亿级新增数据，PB 级的数据分析服务，大数据在其发展中占据了重要作用。尤其在包括业务数据分析、推荐系统、经营分析等重点项目上，起到关键的数据支撑。&lt;/p&gt;&lt;p data-pid=&quot;fkNxURAj&quot;&gt;在面对业务快速迭代的挑战下，QQ 音乐通过基于 CDW ClickHouse 实现了 OLAP 平台架构演进优化，实时数据日接入能力达到数百万亿以上，实时链路平均延时缩短在秒级以内，大幅提升了数据分析的时效性。&lt;/p&gt;&lt;p data-pid=&quot;OWJPN_A4&quot;&gt;下图是 QQ 音乐敏捷数据平台架构：&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/50/v2-e2915faa1145e78836aece4c2de0e05d_720w.jpg?source=1940ef5c&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1920&quot; data-rawheight=&quot;1080&quot; data-default-watermark-src=&quot;https://pic3.zhimg.com/50/v2-d72e2ef27f1c6c5a59e362c24492611c_720w.jpg?source=1940ef5c&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pica.zhimg.com/v2-e2915faa1145e78836aece4c2de0e05d_r.jpg?source=1940ef5c&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1920&quot; data-rawheight=&quot;1080&quot; data-default-watermark-src=&quot;https://pic3.zhimg.com/50/v2-d72e2ef27f1c6c5a59e362c24492611c_720w.jpg?source=1940ef5c&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pica.zhimg.com/v2-e2915faa1145e78836aece4c2de0e05d_r.jpg?source=1940ef5c&quot; data-actualsrc=&quot;https://pic1.zhimg.com/50/v2-e2915faa1145e78836aece4c2de0e05d_720w.jpg?source=1940ef5c&quot;/&gt;&lt;figcaption&gt;△ TME - 敏捷数据平台架构&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-pid=&quot;b4VMpABR&quot;&gt;数据中心主要承担了数据生命周期链路过程中平台化的建设，提升从数据采集 - 数据加工 - 数据存储 - 计算 - 应用管理各环节的数据使用效率，协同互补业务数据团队，为效果分析、个性化推荐、增长决策、内容评估等场景下提供数据服务平台。&lt;/p&gt;&lt;h2&gt;▎&lt;b&gt;数据未来，路在何方？&lt;/b&gt;&lt;/h2&gt;&lt;p data-pid=&quot;81si7RF9&quot;&gt;从技术到产业的深刻变革，业界逐渐形成一个共识：&lt;b&gt;算力是硬武器，数据治理是软实力。&lt;/b&gt;&lt;/p&gt;&lt;p data-pid=&quot;X1vNfH9s&quot;&gt;数十年间，大数据产品的发展经历了从商业化软件购买、开源技术组件构建，到现在的开箱即用云原生大数据产品。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://picx.zhimg.com/50/v2-a15b4b55360f418eb5cf17aef2efa5d2_720w.jpg?source=1940ef5c&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1920&quot; data-rawheight=&quot;1080&quot; data-default-watermark-src=&quot;https://pica.zhimg.com/50/v2-34dd0cae5093b7a71f95f692d0e15ca3_720w.jpg?source=1940ef5c&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://picx.zhimg.com/v2-a15b4b55360f418eb5cf17aef2efa5d2_r.jpg?source=1940ef5c&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1920&quot; data-rawheight=&quot;1080&quot; data-default-watermark-src=&quot;https://pica.zhimg.com/50/v2-34dd0cae5093b7a71f95f692d0e15ca3_720w.jpg?source=1940ef5c&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://picx.zhimg.com/v2-a15b4b55360f418eb5cf17aef2efa5d2_r.jpg?source=1940ef5c&quot; data-actualsrc=&quot;https://picx.zhimg.com/50/v2-a15b4b55360f418eb5cf17aef2efa5d2_720w.jpg?source=1940ef5c&quot;/&gt;&lt;figcaption&gt;△ 大数据技术的演进趋势&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-pid=&quot;xrWoUbs2&quot;&gt;尽管云原生大数据有着巨大的价值收益，但二者技术的结合依然充满挑战。很高兴能看到腾讯云、NVIDIA、Alluxio、SelectDB 等多家大数据企业和开源社区，共同成立了云原生大数据技术生态联盟。&lt;/p&gt;&lt;p data-pid=&quot;MM5G6o4V&quot;&gt;从用户和客户的角度而言，数字化浪潮是不可避免的趋势。对数据上云非常看重的一点还有「安全可信」。因此，隐私计算、多方加密是非常重要的能力。这也是数据未来的一个重中之重。&lt;/p&gt;&lt;p data-pid=&quot;xMn0Lrmy&quot;&gt;而在包括我在内的技术工作者看来，从开源到开放，做好服务和生态则是当下的重要任务。&lt;/p&gt;&lt;a target=&quot;_blank&quot; href=&quot;https://xg.zhihu.com/plugin/00f78d8154c5b3bbd15e4f6c4c700c9f?BIZ=ECOMMERCE&quot; data-draft-node=&quot;block&quot; data-draft-type=&quot;link-card&quot; data-is-ecommerce=&quot;1&quot; class=&quot;LinkCard internal old&quot;&gt;&lt;span class=&quot;LinkCard-content LinkCard-ecommerceLoadingCard&quot;&gt;&lt;p class=&quot;LinkCard-ecommerceLoadingCardLoadingbar&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;/p&gt;&lt;/span&gt;&lt;/a&gt;&lt;p/&gt;&lt;h2&gt;参考&lt;/h2&gt;&lt;ol class=&quot;ReferenceList&quot;&gt;&lt;li id=&quot;ref_1&quot; tabindex=&quot;0&quot;&gt;&lt;a class=&quot;ReferenceList-backLink&quot; href=&quot;#ref_1_0&quot; aria-label=&quot;back&quot; data-reference-link=&quot;true&quot;&gt;^&lt;/a&gt;&lt;span&gt;2019 年中国大数据行业研究报告&lt;/span&gt; &lt;a href=&quot;https://pdf.dfcfw.com/pdf/H3_AP201911251371103072_1.pdf&quot; class=&quot;external&quot; target=&quot;_blank&quot; rel=&quot;noopener noreferrer&quot;&gt;https://pdf.dfcfw.com/pdf/H3_AP201911251371103072_1.pdf&lt;/a&gt;&lt;/li&gt;&lt;li id=&quot;ref_2&quot; tabindex=&quot;0&quot;&gt;&lt;a class=&quot;ReferenceList-backLink&quot; href=&quot;#ref_2_0&quot; aria-label=&quot;back&quot; data-reference-link=&quot;true&quot;&gt;^&lt;/a&gt;&lt;span&gt;Cloud Native Architectures - a Conversation with Matt Stine&lt;/span&gt; &lt;a href=&quot;https://www.infoq.com/articles/cloud-native-architectures-matt-stine/&quot; class=&quot;external&quot; target=&quot;_blank&quot; rel=&quot;noopener noreferrer&quot;&gt;https://www.infoq.com/articles/cloud-native-architectures-matt-stine/&lt;/a&gt;&lt;/li&gt;&lt;/ol&gt;&lt;/span&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>23b80f0acdddb39cd08e1af2097287ca</guid>
<title>7000字+24张图带你彻底弄懂线程池</title>
<link>https://toutiao.io/k/wy9f3j0</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot; data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;大家好，我是苏三~~&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;今天跟大家聊一聊无论是在工作中常用还是在面试中常问的线程池，通过画图的方式来彻底弄懂线程池的工作原理，以及在实际项目中该如何自定义适合业务的线程池。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.7203703703703703&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/B279WL06QYx1otOsqTzCrXnesWzhE81KiaAtXn4qlrHpniaygT6eSzmXbyDLH618nCsALDrrDTgygrLDSbjQbX7A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/figure&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;一、什么是线程池&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;线程池其实是一种池化的技术的实现，池化技术的核心思想其实就是实现资源的一个复用，避免资源的重复创建和销毁带来的性能开销。在线程池中，线程池可以管理一堆线程，让线程执行完任务之后不会进行销毁，而是继续去处理其它线程已经提交的任务。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;线程池的好处:&lt;/strong&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;降低资源消耗。通过重复利用已创建的线程降低线程创建和销毁造成的消耗。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;提高响应速度。当任务到达时，任务可以不需要等到线程创建就能立即执行。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;提高线程的可管理性。线程是稀缺资源，如果无限制的创建，不仅会消耗系统资源，还会降低系统 的稳定性，使用线程池可以进行统一的分配，调优和监控。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;二、线程池的构造&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Java中主要是通过构建ThreadPoolExecutor来创建线程池的，接下来我们看一下线程池是如何构造出来的。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.8444444444444444&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/B279WL06QYx1otOsqTzCrXnesWzhE81K3onOh1g6FAymrIxPmic6CBAvIpvO55lmkS22pVib2ZpwXLeqOcrxQqjQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;figcaption&gt;线程池构造参数&lt;/figcaption&gt;&lt;/figure&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;corePoolSize：线程池中用来工作的核心的线程数量。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;maximumPoolSize：最大线程数，线程池允许创建的最大线程数。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;keepAliveTime：超出 corePoolSize 后创建的线程存活时间或者是所有线程最大存活时间，取决于配置。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;unit：keepAliveTime 的时间单位。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;workQueue：任务队列，是一个阻塞队列，当线程数已达到核心线程数，会将任务存储在阻塞队列中。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;threadFactory ：线程池内部创建线程所用的工厂。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;handler：拒绝策略；当队列已满并且线程数量达到最大线程数量时，会调用该方法处理该任务。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;线程池的构造其实很简单，就是传入一堆参数，然后进行简单的赋值操作。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;三、线程池的运行原理&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;说完线程池的核心构造参数的意思，接下来就来画图讲解这些参数在线程池中是如何工作的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;线程池刚创建出来是什么样子呢，如下图&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.8425925925925926&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/B279WL06QYx1otOsqTzCrXnesWzhE81Kb9vibvUDicXicWcrp2bHSSf2ABL9icP5RwXOo1ZEHvOrQiaRmxviaoY2gmaA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;不错，刚创建出来的线程池中只有一个构造时传入的阻塞队列而已，此时里面并没有的任何线程，但是如果你想要在执行之前已经创建好核心线程数，可以调用prestartAllCoreThreads方法来实现，默认是没有线程的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当有线程通过execute方法提交了一个任务，会发生什么呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;提交任务的时候，其实会去进行任务的处理&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;首先会去判断当前线程池的线程数是否小于核心线程数，也就是线程池构造时传入的参数corePoolSize。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果小于，那么就直接通过ThreadFactory创建一个线程来执行这个任务，如图&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6064814814814815&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/B279WL06QYx1otOsqTzCrXnesWzhE81KHrALayTL6iaRic5VDzQqR49MiajicxyObRRlUNaQrSibicEodOLz71y38xEw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当任务执行完之后，线程不会退出，而是会去从阻塞队列中获取任务，如下图&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6092592592592593&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/B279WL06QYx1otOsqTzCrXnesWzhE81KRPQfiaggkqd0kdK03lSicSORDZGicucSHTia6C2ERicpjs1ZMc44sk6Ria5g/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;接下来如果又提交了一个任务，也会按照上述的步骤，去判断是否小于核心线程数，如果小于，还是会创建线程来执行任务，执行完之后也会从阻塞队列中获取任务。这里有个细节，就是提交任务的时候，就算有线程池里的线程从阻塞队列中获取不到任务，如果线程池里的线程数还是小于核心线程数，那么依然会继续创建线程，而不是复用已有的线程。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果线程池里的线程数不再小于核心线程数呢？那么此时就会尝试将任务放入阻塞队列中，入队成功之后，如图&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6111111111111112&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/B279WL06QYx1otOsqTzCrXnesWzhE81K2VHgKPbCle00a5Rtd1YQO0F91zfMObqDlwtEichdMke0h5vcypfibt7g/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这样在阻塞的线程就可以获取到任务了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但是，随着任务越来越多，队列已经满了，任务放入失败了，那怎么办呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;此时就会判断当前线程池里的线程数是否小于最大线程数，也就是入参时的maximumPoolSize参数&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果小于最大线程数，那么也会创建非核心线程来执行提交的任务，如图&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6166666666666667&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/B279WL06QYx1otOsqTzCrXnesWzhE81KXzMC4icCxL1el2BACmZjaczviblw14e8nqst7bNgwWHrBmj8iaIvibmwzw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以，从这里可以发现，就算队列中有任务，新创建的线程还是优先处理这个提交的任务，而不是从队列中获取已有的任务执行，从这可以看出，先提交的任务不一定先执行。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但是不幸的事发生了，线程数已经达到了最大线程数量，那么此时会怎么办呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;此时就会执行拒绝策略，也就是构造线程池的时候，传入的RejectedExecutionHandler对象，来处理这个任务。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.6064814814814815&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/B279WL06QYx1otOsqTzCrXnesWzhE81KYGsUbGUZAgddrd1tIJBuqVk5R01Hj9me9DicRiczvIZATdg6eSL00Kng/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;RejectedExecutionHandler的实现JDK自带的默认有4种&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;AbortPolicy：丢弃任务，抛出运行时异常&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;CallerRunsPolicy：由提交任务的线程来执行任务&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;DiscardPolicy：丢弃这个任务，但是不抛异常&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;DiscardOldestPolicy：从队列中剔除最先进入队列的任务，然后再次提交任务&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;线程池创建的时候，如果不指定拒绝策略就默认是AbortPolicy策略。当然，你也可以自己实现RejectedExecutionHandler接口，比如将任务存在数据库或者缓存中，这样就数据库或者缓存中获取到被拒绝掉的任务了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;到这里，我们发现，线程池构造的几个参数corePoolSize、maximumPoolSize、workQueue、threadFactory、handler我们都在上述的执行过程中讲到了，那么还差两个参数keepAliveTime和unit(unit是keepAliveTime的时间单位)没讲到，所以keepAliveTime是如何起到作用的呢，这个问题留到后面分析。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;说完整个执行的流程，接下来看看execute方法代码是如何实现的。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6929637526652452&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/B279WL06QYx1otOsqTzCrXnesWzhE81K4evIFBoAWppW6IWCzicaXyWoHqIK1FzFJrj0omxAeqoDeOocC9BMcBA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;938&quot;/&gt;&lt;figcaption&gt;execute方法&lt;/figcaption&gt;&lt;/figure&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;workerCountOf(c)&amp;lt;corePoolSize:这行代码就是判断是否小于核心线程数，是的话就通过addWorker方法，addWorker就是添加线程来执行任务。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;workQueue.offer(command)：这行代码就表示尝试往阻塞队列中添加任务&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;添加失败之后就会再次调用addWorker方法尝试添加非核心线程来执行任务&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;如果还是添加非核心线程失败了，那么就会调用reject(command)来拒绝这个任务。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;最后再来另画一张图总结execute执行流程&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.44260599793174765&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/B279WL06QYx1otOsqTzCrXnesWzhE81KCk0zdyVzdeP0pJjbpfibx3SA62GGvKia9nENGK6hvemYicxE85ia23bESw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1934&quot;/&gt;&lt;/figure&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;四、线程池中线程实现复用的原理&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;线程池的核心功能就是实现了线程的重复利用，那么线程池是如何实现线程的复用呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;线程在线程池内部其实是被封装成一个Worker对象&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.3087431693989071&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/B279WL06QYx1otOsqTzCrXnesWzhE81KdmccmWh5wSdVEkbA88GH17YLpwdGkh7FOibxicTSib3Q4A34tuZsTbNEQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;732&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Worker继承了AQS，也就是有一定锁的特性。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;创建线程来执行任务的方法上面提到是通过addWorker方法创建的。在创建Worker对象的时候，会把线程和任务一起封装到Worker内部，然后调用runWorker方法来让线程执行任务，接下来我们就来看一下runWorker方法。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1.6444444444444444&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/B279WL06QYx1otOsqTzCrXnesWzhE81KiapoGLicgicX4QQJA0eoEkS9S0ibFL72HvvVx6koZruGYRoT5TwlVNErWg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;figcaption&gt;启动线程处理任务&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;从这张图可以看出线程执行完任务不会退出的原因，runWorker内部使用了while死循环，当第一个任务执行完之后，会不断地通过getTask方法获取任务，只要能获取到任务，就会调用run方法，继续执行任务，这就是线程能够复用的主要原因。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但是如果从getTask获取不到方法的时候，最后就会调用finally中的processWorkerExit方法，来将线程退出。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里有个一个细节就是，因为Worker继承了AQS，每次在执行任务之前都会调用Worker的lock方法，执行完任务之后，会调用unlock方法，这样做的目的就可以通过Woker的加锁状态就能判断出当前线程是否正在运行任务。如果想知道线程是否正在运行任务，只需要调用Woker的tryLock方法，根据是否加锁成功就能判断，加锁成功说明当前线程没有加锁，也就没有执行任务了，在调用shutdown方法关闭线程池的时候，就用这种方式来判断线程有没有在执行任务，如果没有的话，来尝试打断没有执行任务的线程。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;五、线程是如何获取任务的以及如何实现超时的&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上一节我们说到，线程在执行完任务之后，会继续从getTask方法中获取任务，获取不到就会退出。接下来我们就来看一看getTask方法的实现。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1.3657407407407407&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/B279WL06QYx1otOsqTzCrXnesWzhE81KTrAJwcbAkdFbibMJhC8yvxFkib7HSnF9QYsGXH1fjevhMHDY7SnbhBHw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;figcaption&gt;getTask方法&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;getTask方法，前面就是线程池的一些状态的判断，这里有一行代码&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;boolean&lt;/span&gt; timed = allowCoreThreadTimeOut || wc &amp;gt; corePoolSize;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这行代码是判断，当前过来获取任务的线程是否可以超时退出。如果allowCoreThreadTimeOut设置为true或者线程池当前的线程数大于核心线程数，也就是corePoolSize，那么该获取任务的线程就可以超时退出。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那是怎么做到超时退出呢，就是这行核心代码&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;Runnable r = timed ?&lt;br/&gt;                    workQueue.poll(keepAliveTime, TimeUnit.NANOSECONDS) :&lt;br/&gt;                    workQueue.take();&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;会根据是否允许超时来选择调用阻塞队列workQueue的poll方法或者take方法。如果允许超时，则会调用poll方法，传入keepAliveTime，也就是构造线程池时传入的空闲时间，这个方法的意思就是从队列中阻塞keepAliveTime时间来获取任务，获取不到就会返回null；如果不允许超时，就会调用take方法，这个方法会一直阻塞获取任务，直到从队列中获取到任务位置。从这里可以看到keepAliveTime是如何使用的了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以到这里应该就知道线程池中的线程为什么可以做到空闲一定时间就退出了吧。其实最主要的是利用了阻塞队列的poll方法的实现，这个方法可以指定超时时间，一旦线程达到了keepAliveTime还没有获取到任务，那么就会返回null，上一小节提到，getTask方法返回null，线程就会退出。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里也有一个细节，就是判断当前获取任务的线程是否可以超时退出的时候，如果将allowCoreThreadTimeOut设置为true，那么所有线程走到这个timed都是true，那么所有的线程，包括核心线程都可以做到超时退出。如果你的线程池需要将核心线程超时退出，那么可以通过allowCoreThreadTimeOut方法将allowCoreThreadTimeOut变量设置为true。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;整个getTask方法以及线程超时退出的机制如图所示&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.35648148148148145&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/B279WL06QYx1otOsqTzCrXnesWzhE81KIblH3TF7bj9zMNUAFY5jGqFAsicicqywJWoLv3IcwghnXEBKyRW26pibw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/figure&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;六、线程池的5种状态&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;线程池内部有5个常量来代表线程池的五种状态&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.3170731707317073&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/B279WL06QYx1otOsqTzCrXnesWzhE81KW510Iw1rnDHl1jYqPDSMpgHEoLNJC7d5hSTn9WVJo7nibHuFSGqCvFQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;984&quot;/&gt;&lt;/figure&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;RUNNING：线程池创建时就是这个状态，能够接收新任务，以及对已添加的任务进行处理。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;SHUTDOWN：调用shutdown方法线程池就会转换成SHUTDOWN状态，此时线程池不再接收新任务，但能继续处理已添加的任务到队列中任务。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;STOP：调用shutdownNow方法线程池就会转换成STOP状态，不接收新任务，也不能继续处理已添加的任务到队列中任务，并且会尝试中断正在处理的任务的线程。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;TIDYING：SHUTDOWN 状态下，任务数为 0， 其他所有任务已终止，线程池会变为 TIDYING 状态。线程池在 SHUTDOWN 状态，任务队列为空且执行中任务为空，线程池会变为 TIDYING 状态。线程池在 STOP 状态，线程池中执行中任务为空时，线程池会变为 TIDYING 状态。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;TERMINATED：线程池彻底终止。线程池在 TIDYING 状态执行完 terminated() 方法就会转变为 TERMINATED 状态。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;线程池状态具体是存在ctl成员变量中，ctl中不仅存储了线程池的状态还存储了当前线程池中线程数的大小&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; AtomicInteger ctl = &lt;span&gt;new&lt;/span&gt; AtomicInteger(ctlOf(RUNNING, &lt;span&gt;0&lt;/span&gt;));&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;最后画个图来总结一下这5种状态的流转&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.2722222222222222&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/B279WL06QYx1otOsqTzCrXnesWzhE81KgibgzrJZtkLialiafKje4N0dOtgmp1AtLsnicE90uH7ic7UfLDiawrhYcy8w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其实，在线程池运行过程中，绝大多数操作执行前都得判断当前线程池处于哪种状态，再来决定是否继续执行该操作。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;七、线程池的关闭&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;线程池提供了shutdown和shutdownNow两个方法来关闭线程池。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6571428571428571&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/B279WL06QYx1otOsqTzCrXnesWzhE81KqCo9wXsHWt0CIDvNIpXzBwUzHQrohec7ADVrGpKbgBq7lXnh0k4JGg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;910&quot;/&gt;&lt;figcaption&gt;shutdown方法&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;就是将线程池的状态修改为SHUTDOWN，然后尝试打断空闲的线程（如何判断空闲，上面在说Worker继承AQS的时候说过），也就是在阻塞等待任务的线程。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.7700892857142857&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/B279WL06QYx1otOsqTzCrXnesWzhE81KBCDvL1HiaLoQ1ZE8jM8HicTMxlSo8noCXSulOt0QEQMXFMzDneDOmtfA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;896&quot;/&gt;&lt;figcaption&gt;shutdownNow方法&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;就是将线程池的状态修改为STOP，然后尝试打断所有的线程，从阻塞队列中移除剩余的任务，这也是为什么shutdownNow不能执行剩余任务的原因。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以也可以看出shutdown方法和shutdownNow方法的主要区别就是，shutdown之后还能处理在队列中的任务，shutdownNow直接就将任务从队列中移除，线程池里的线程就不再处理了。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;八、线程池的监控&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在项目中使用线程池的时候，一般需要对线程池进行监控，方便出问题的时候进行查看。线程池本身提供了一些方法来获取线程池的运行状态。&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;getCompletedTaskCount：已经执行完成的任务数量&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;getLargestPoolSize：线程池里曾经创建过的最大的线程数量。这个主要是用来判断线程是否满过。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;getActiveCount：获取正在执行任务的线程数据&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;getPoolSize：获取当前线程池中线程数量的大小&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;除了线程池提供的上述已经实现的方法，同时线程池也预留了很多扩展方法。比如在runWorker方法里面，在执行任务之前会回调beforeExecute方法，执行任务之后会回调afterExecute方法，而这些方法默认都是空实现，你可以自己继承ThreadPoolExecutor来扩展重写这些方法，来实现自己想要的功能。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;九、Executors构建线程池以及问题分析&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;JDK内部提供了Executors这个工具类，来快速的创建线程池。&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;固定线程数量的线程池：核心线程数与最大线程数相等&lt;span/&gt;&lt;/h5&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.18425925925925926&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/B279WL06QYx1otOsqTzCrXnesWzhE81KdCSrsBY12gD3eyZhJ0g8OAoAkhSMNLJT4RicxqQGUADmUXDhEYCMgGg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/figure&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;单个线程数量的线程池&lt;span/&gt;&lt;/h5&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.24259259259259258&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/B279WL06QYx1otOsqTzCrXnesWzhE81KXa0d9f7aLOCUOeGvzvl4ZpBxpMyVPC4jcGic6U7hcoKnzhQTgfyLN8w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/figure&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;接近无限大线程数量的线程池&lt;span/&gt;&lt;/h5&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.22685185185185186&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/B279WL06QYx1otOsqTzCrXnesWzhE81KqicV1fPTzz7sjCczxe6yOCaxx2yg5k0Jsw5c3zaIFIZMj6mmXA3moBA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/figure&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;带定时调度功能的线程池&lt;span/&gt;&lt;/h5&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.14351851851851852&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/B279WL06QYx1otOsqTzCrXnesWzhE81KFRVMcibq0n9OqlGBYp5CqKxEibeynbZIG1lFLe6QNyQE882NtNOibYbIw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;虽然JDK提供了快速创建线程池的方法，但是其实不推荐使用Executors来创建线程池，因为从上面构造线程池可以看出，newFixedThreadPool线程池，由于使用了LinkedBlockingQueue，队列的容量默认是无限大，实际使用中出现任务过多时会导致内存溢出；newCachedThreadPool线程池由于核心线程数无限大，当任务过多的时候，会导致创建大量的线程，可能机器负载过高，可能会导致服务宕机。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;十、线程池的使用场景&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在java程序中，其实经常需要用到多线程来处理一些业务，但是不建议单纯使用继承Thread或者实现Runnable接口的方式来创建线程，那样就会导致频繁创建及销毁线程，同时创建过多的线程也可能引发资源耗尽的风险。所以在这种情况下，使用线程池是一种更合理的选择，方便管理任务，实现了线程的重复利用。所以线程池一般适合那种需要异步或者多线程处理任务的场景。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;十一、实际项目中如何合理的自定义线程池&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;通过上面分析提到，通过Executors这个工具类来创建的线程池其实都无法满足实际的使用场景，那么在实际的项目中，到底该如何构造线程池呢，该如何合理的设置参数？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;1）线程数&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;线程数的设置主要取决于业务是IO密集型还是CPU密集型。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;CPU密集型指的是任务主要使用来进行大量的计算，没有什么导致线程阻塞。一般这种场景的线程数设置为CPU核心数+1。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;IO密集型：当执行任务需要大量的io，比如磁盘io，网络io，可能会存在大量的阻塞，所以在IO密集型任务中使用多线程可以大大地加速任务的处理。一般线程数设置为 2*CPU核心数&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;java中用来获取CPU核心数的方法是：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;Runtime.getRuntime().availableProcessors();&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;2）线程工厂&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;一般建议自定义线程工厂，构建线程的时候设置线程的名称，这样就在查日志的时候就方便知道是哪个线程执行的代码。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;3）有界队列&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;一般需要设置有界队列的大小，比如LinkedBlockingQueue在构造的时候就可以传入参数，来限制队列中任务数据的大小，这样就不会因为无限往队列中扔任务导致系统的oom。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;- END -&lt;/span&gt;&lt;/p&gt;&lt;section class=&quot;mp_profile_iframe_wrp&quot;&gt;&lt;mp-common-profile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mpprofile&quot; data-id=&quot;Mzg4NjYyODc4OA==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/J4jTHmo8Xh6qM32ASOtVbXNoiaegrI26qLRw6r6FTI7dZw6TMT7vecvnjd1O8xSsM5MiajIuQZicxSC6KFK8TMpbg/0?wx_fmt=png&quot; data-nickname=&quot;java突击队&quot; data-alias=&quot;&quot; data-signature=&quot;技术经验分享&quot; data-from=&quot;0&quot; data-is_biz_ban=&quot;0&quot;/&gt;&lt;/section&gt;&lt;p&gt;此外，我最近打算把新建的技术交流群，打造成一个活跃的高质量技术群。群里不定期有&lt;strong&gt;送书&lt;/strong&gt;，&lt;strong&gt;发红包&lt;/strong&gt;活动，工作中遇到的技术问题，都可以在里面咨询大家，还有工作&lt;strong&gt;内推&lt;/strong&gt;的机会。有兴趣的小伙伴，欢迎加群。&lt;/p&gt;&lt;p&gt;扫描下方二维码，备注：加群，即可进群。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;1.0048309178743962&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/uL371281oDE9vvfu1eb0KdQmjCiceE3xr7JF0cvK0z4UwCNyKO4UsMg5Urfro5qzoU2NWfgthCjwENmLxK6Nxyw/640?wx_fmt=png&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; data-type=&quot;png&quot; data-w=&quot;414&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>