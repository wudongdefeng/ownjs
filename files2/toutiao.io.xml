<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>e3f9152d94963169872d509e91fd57ee</guid>
<title>分布式系统下的认证与授权</title>
<link>https://toutiao.io/k/gq6zhrc</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;entry-content&quot; itemprop=&quot;articleBody&quot;&gt;&amp;#13;
&lt;p&gt;在软件系统设计中，如何让应用能够在各种环境中安全高效的访问是个复杂的问题，这个问题的背后是一系列软件设计时需要考虑的架构安全问题：&lt;a href=&quot;https://icyfenix.cn/architect-perspective/general-architecture/system-security/&quot;&gt;架构安全性 | 凤凰架构&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;认证：系统如何识别合法用户，也就是解决 &lt;strong&gt;你是谁&lt;/strong&gt; 的问题；&lt;/li&gt;
&lt;li&gt;授权：系统在识别合法用户后，还需要解决 &lt;strong&gt;你能做什么&lt;/strong&gt; 的问题；&lt;/li&gt;
&lt;li&gt;凭证：系统如何保证它与用户之间的承诺是双方真实意图的体现，是准确、完整且不可抵赖的；&lt;/li&gt;
&lt;li&gt;保密：如何安全的持久化用户的账户信息，确保不会被任何人窃取与滥用；&lt;/li&gt;
&lt;li&gt;传输：在复杂的用户环境中，如何安全的传递用户信息，保证不被第三方窃听、篡改和冒充。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在漫长的架构演进历史中，业界对这些问题已经有很成熟的解决方案。在架构安全这块，最好的是遵循技术标准与最佳实践，尽可能&lt;strong&gt;不重复造轮子或“创新”&lt;/strong&gt;。下面这个思维导图就是针对这些问题的常见的技术标准及方案：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://insights.thoughtworks.cn/wp-content/uploads/2022/12/authentication-and-authorization-in-distributed-systems-1.png&quot;&gt;&lt;img src=&quot;https://insights.thoughtworks.cn/wp-content/uploads/2022/12/authentication-and-authorization-in-distributed-systems-1-1024x808.png&quot; alt=&quot;架构安全思维导图&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;在研究分布式系统的认证和授权问题前，让我们回到单体架构的时代，看看在单体架构上这些问题是如何被解决的。&lt;/p&gt;
&lt;h2&gt;&lt;strong&gt;单体系统&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://insights.thoughtworks.cn/wp-content/uploads/2022/12/authentication-and-authorization-in-distributed-systems-2.png&quot;&gt;&lt;img src=&quot;https://insights.thoughtworks.cn/wp-content/uploads/2022/12/authentication-and-authorization-in-distributed-systems-2-1024x408.png&quot; alt=&quot;单体系统&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;&lt;strong&gt;认证&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;认证主要解决 &lt;strong&gt;你是谁&lt;/strong&gt; 的问题，从方式上来看有以下三种：&lt;a href=&quot;https://icyfenix.cn/architect-perspective/general-architecture/system-security/authentication.html&quot;&gt;认证 | 凤凰架构&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;基于通信信道：建立通信信道之前需要证明 &lt;strong&gt;你是谁&lt;/strong&gt;。在网络传输（Network）场景中的典型是基于 SSL/TLS 传输安全层的认证。&lt;/li&gt;
&lt;li&gt;基于通信协议：在获取资源之前需要证明 &lt;strong&gt;你是谁&lt;/strong&gt;。在互联网（Internet）场景中的典型是基于 HTTP 协议的认证。&lt;/li&gt;
&lt;li&gt;基于通信内容：在提供服务之前需要证明 &lt;strong&gt;你是谁&lt;/strong&gt;。在万维网（World Wide Web）场景中的典型是基于 Web 内容的认证。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在单体系统时代，认证方式一般是在通信信道上开启 HTTPS，在通信协议上利用 &lt;a href=&quot;https://datatracker.ietf.org/doc/html/rfc7235#section-4.2&quot;&gt;HTTP Basic&lt;/a&gt;/&lt;a href=&quot;https://datatracker.ietf.org/doc/html/rfc7616&quot;&gt;Digest&lt;/a&gt;/&lt;a href=&quot;https://datatracker.ietf.org/doc/html/rfc6750&quot;&gt;Bearer&lt;/a&gt;/&lt;a href=&quot;https://datatracker.ietf.org/doc/html/rfc7486&quot;&gt;HOBA&lt;/a&gt;/&lt;a href=&quot;https://datatracker.ietf.org/doc/html/rfc6287&quot;&gt;OCRA&lt;/a&gt; 等方式并在通信内容上结合表单或 &lt;a href=&quot;https://datatracker.ietf.org/doc/html/rfc6238&quot;&gt;TOTP&lt;/a&gt; 等的认证组合方式。这样可以从通信的不同阶段获得相应的安全保证。&lt;/p&gt;
&lt;p&gt;如果想对基于 HTTP 协议的认证方式做进一步的了解，可以参考这两篇文章：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;https://icyfenix.cn/architect-perspective/general-architecture/system-security/authentication.html&quot;&gt;认证 | 凤凰架构&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://insights.thoughtworks.cn/api-2/&quot;&gt;细说API - 认证、授权和凭证 - Thoughtworks洞见&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;认证的一个常见应用场景是单点登录。单点登录主要解决了一个一次登录访问多个独立应用的问题。在单点登录方案出现之前，每个应用都需要独立登录维持各自的会话。相关的技术方案已经很成熟，主要有以下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://datatracker.ietf.org/doc/html/rfc4120&quot;&gt;Kerberos-based&lt;/a&gt;：MIT 设计的 SSO 协议，基于对称密码学，并需要一个值得信赖的第三方。其广泛用于操作系统认证，如被 Windows 2000 和后续的操作系统作为默认的认证方法。&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.apereo.org/projects/cas&quot;&gt;CAS&lt;/a&gt;：Yale 设计的 SSO 协议，基于浏览器的 SSO 方案，部署简单，适用于简单的应用场景。&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Security_Assertion_Markup_Language&quot;&gt;SAML&lt;/a&gt;：基于 XML 标记语言的认证断言方案，适用的场景众多，但技术较复杂。&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://openid.net/connect/&quot;&gt;OIDC&lt;/a&gt;：在 OAuth2 的基础上额外加一个 JWT 来传递用户信息。功能全面强大，是目前很流行的 SSO 方案。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;&lt;strong&gt;授权&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;授权主要解决 &lt;strong&gt;你能做什么&lt;/strong&gt; 的问题，从方案上来说有以下几种：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Access-control_list&quot;&gt;ACL&lt;/a&gt;：访问控制列表（Access-control list）广泛用于操作系统内部的文件系统、网络及进程权限控制方面。如在 Linux 中，可通过 &lt;code&gt;getfacl&lt;/code&gt; 获取目录的默认 ACL 设置。&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Role-based_access_control&quot;&gt;RBAC&lt;/a&gt;：RBAC 通过将权限属性从 ACL 方案中的单个用户抽取成更为抽象的角色（Role），通过给角色一组权限属性，再将多个角色赋予某个用户，实现了比 ACL 更为灵活强大的权限控制方案。实际上大部分系统的授权方案采用 RBAC 就足够了。但 RBAC 在面临复杂的权限控制需求时可能面临角色爆炸的问题，这时可以考虑采用更细粒度的 ABAC 方案。&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Attribute-based_access_control&quot;&gt;ABAC&lt;/a&gt;：ABAC 是比 RBAC 更细粒度的权限控制方案。通过引入一组称为“属性”的特征，包括用户属性、环境属性和资源属性。例如，ABAC 可以对用户的访问做进一步的控制，如只允许在特定的时间或与相关员工相关的某些分支机构进行访问员工信息的操作，而不是让某部门的人员总是能够访问员工信息。但 ABAC 的问题在于初始设置需要定义大量的属性，工作量比 RBAC 要大。&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://datatracker.ietf.org/doc/html/rfc6749&quot;&gt;OAuth2&lt;/a&gt;：OAuth2 是为了解决应用系统给第三方系统授权的问题而设计的授权框架。传统的客户端服务器交互模式中，客户端持有资源访问凭证（如用户名密码），服务端验证成功后放行。而在给第三方系统提供资源时，如果给第三方系统资源凭证，可能会带来未知的安全问题，比如凭证泄漏，凭证回收等问题。当应用系统面向第三方系统提供服务时，需要使用此方案。同时因为 OAuth2 做授权的时候一般需要用户登录，也能实现单点登录的功能。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;如果想对授权做进一步的了解，可以参考这篇文章：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;https://icyfenix.cn/architect-perspective/general-architecture/system-security/authorization.html&quot;&gt;授权 | 凤凰架构&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h3&gt;&lt;strong&gt;凭证&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;凭证是为了解决在认证授权后如何承载认证授权信息的问题。在单体应用时代，主流的解决方案是基于 HTTP 协议的 Cookie-Session 机制为代表的服务端状态存储技术。&lt;/p&gt;
&lt;p&gt;由于 HTTP 协议本身是无状态的，要维持一个会话（Session），而不是每次访问都重新认证授权，需要客户端也就是浏览器通过 Cookie 来存储服务器端返回的一个凭证信息，这个凭证信息一般是一串随机的字符串，用来代表用户此次的会话标识。每次请求浏览器都会在 HTTP Header 中携带这个 Cookie 信息，应用拿到这个会话标识后从内存或缓存（Cache）中查询出用户的信息，这样就定位到了具体的用户，实现了会话的维持。&lt;/p&gt;
&lt;p&gt;这套古老的方案存在以下先天优势：&lt;a href=&quot;https://icyfenix.cn/architect-perspective/general-architecture/system-security/credentials.html&quot;&gt;凭证 | 凤凰架构&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;状态信息都存储于服务器，只要依靠客户端的 &lt;a href=&quot;https://developer.mozilla.org/zh-CN/docs/Web/Security/Same-origin_policy&quot;&gt;同源策略&lt;/a&gt; 和 HTTPS 的传输层安全，保证 Cookie 中的键值不被窃取而出现被冒认身份的情况，就能完全规避掉上下文信息在传输过程中被泄漏和篡改的风险（但 Cookie 方案容易受到 &lt;a href=&quot;https://owasp.org/www-community/attacks/csrf&quot;&gt;CSRF&lt;/a&gt; 攻击，这种可通过 &lt;a href=&quot;https://cheatsheetseries.owasp.org/cheatsheets/Cross-Site_Request_Forgery_Prevention_Cheat_Sheet.html#token-based-mitigation&quot;&gt;CSRF Token&lt;/a&gt; 技术防御）；&lt;/li&gt;
&lt;li&gt;另一大优点是服务端有主动的状态管理能力，可根据自己的意愿随时修改、清除任意上下文信息，譬如很轻易就能实现强制某用户下线的这样功能；&lt;/li&gt;
&lt;li&gt;服务端也很容易实现如统计用户在线这类功能；&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;一切都很美好，直到我们来到了分布式系统时代。&lt;/p&gt;
&lt;h2&gt;&lt;strong&gt;分布式系统&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;分布式系统与单体系统的一大区别就是状态管理。分布式系统通过把单体系统中有状态的部分转移到中间件中去管理，从而很容易做到水平扩容，提高系统峰值处理能力。在架构认证和授权部分，分布式和单体并没有什么不同，唯独有变化的在持有状态的凭证部分。&lt;/p&gt;
&lt;p&gt;我们知道单体应用在服务端管理用户会话信息，客户端只持有会话标识。如果服务端要将此用户会话状态转移出去有两种处理思路：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;将用户会话信息继续托管至服务端。此时有几种服务端方案可以选择：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;中心化存储：转移到中间件如 Redis 中去。利用 Redis &lt;a href=&quot;https://redis.io/topics/benchmarks&quot;&gt;极高的并发处理能力&lt;/a&gt;，也可以做到弹性横行扩容。不过可能会带来中间件高可用性维护难的问题，通过租赁云服务商的托管中间件是降低中间件 &lt;a href=&quot;https://en.wikipedia.org/wiki/Single_point_of_failure&quot;&gt;单点故障（SPOF）&lt;/a&gt; 的一种方式；&lt;/li&gt;
&lt;li&gt;会话复制（Session replication）：让各个节点之间采用复制式的 Session，每一个节点中的 Session 变动都会发送到组播地址的其他服务器上，这样某个节点崩溃了，不会中断该节点用户的服务。但 Session 之间组播复制的同步代价高昂，节点越多时，同步成本越高。&lt;/li&gt;
&lt;li&gt;会话粘滞（Sticky session）：通过负载均衡算法如 Nginx 的 &lt;a href=&quot;https://docs.nginx.com/nginx/admin-guide/load-balancer/http-load-balancer/&quot;&gt;IP Hash&lt;/a&gt; 算法将来自同一 IP 的请求转发至同一服务。每个服务节点都不重复地保存着一部分用户的状态，如果这个服务崩溃了，里面的用户状态便完全丢失。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;为什么在分布式系统中共享状态就这么困难？这是因为分布式系统中有一个不可能三角的理论：&lt;a href=&quot;https://en.wikipedia.org/wiki/CAP_theorem&quot;&gt;CAP&lt;/a&gt;。这个理论简单地理解就是因为在分布式系统中，因为网络无法做到绝对的可靠（分区容错性：&lt;strong&gt;P&lt;/strong&gt;artition Tolerance），只能在一致性（&lt;strong&gt;C&lt;/strong&gt;onsistency）和可用性（&lt;strong&gt;A&lt;/strong&gt;vailability）间选择一个。 比如上述的三种服务端方案其实都是牺牲了 CAP 的某个方面。比如第一种中心化存储方案我们放弃了中心化存储的分区容错性，一旦其网络分区，整个集群都会不可用。第二种会话复制方案我们牺牲了可用性，当节点在同步会话数据时，整个服务会短暂的不可用。第三种会话粘滞方案我们牺牲了一致性，一旦某个节点宕机，整个集群的数据会因该节点的数据丢失而达到不一致的状态。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;将状态从服务端转移到客户端。Cookie-Session 是一种引用令牌（Reference tokens），也就是客户端持有的是服务端存储的会话引用标识。还有一种自包含令牌（Self-contained tokens），如 &lt;a href=&quot;https://datatracker.ietf.org/doc/html/rfc7519.html&quot;&gt;JWT&lt;/a&gt; 就是这种客户端保存会话信息的技术，服务端只是去校验会话信息是否合法。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;&lt;strong&gt;JWT&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;如果你对 JWT 不了解，可以先看这两篇：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;https://icyfenix.cn/architect-perspective/general-architecture/system-security/credentials.html#jwt&quot;&gt;JWT | 凤凰架构&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.pingidentity.com/en/company/blog/posts/2019/jwt-security-nobody-talks-about.html&quot;&gt;The Hard Parts of JWT Security Nobody Talks About&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;由于 JWT 的 Payload 并未做过多限制，所以很容易产生滥用的问题，并且带来很多误解。比如下面的一些问题：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;误把 JWT 当作 Cookie-Session 使用（把 JWT 当作引用令牌使用），会带来未知的隐患。遵循不重复造轮子和“创新”的指导原则，尽可能不要这么做；&lt;/li&gt;
&lt;li&gt;认为 JWT 更安全。虽然 JWT 采用了一定的加密算法签名，使其具备了抗篡改的能力。但其 Payload 大部分都只是采用 &lt;code&gt;base64UrlEncode&lt;/code&gt; 编码，数据并不是加密的。攻击者可以通过 &lt;a href=&quot;https://owasp.org/www-community/attacks/Session_hijacking_attack&quot;&gt;会话劫持（Session hijacking）&lt;/a&gt; 技术拿到 JWT 会话信息，之后通过 &lt;a href=&quot;https://campus.barracuda.com/product/webapplicationfirewall/doc/49058327/session-replay-attack/&quot;&gt;会话重放攻击（Session Replay Attack）&lt;/a&gt; 获取用户资源，所以最佳实践是通过启用 TLS/SSL 来加密通信信道。&lt;/li&gt;
&lt;li&gt;把 JWT 存储到浏览器的 Local Storage 中。此方式很容易受到 &lt;a href=&quot;https://owasp.org/www-community/attacks/xss/&quot;&gt;XSS&lt;/a&gt; 攻击导致 JWT 泄漏。可通过服务端启用 &lt;a href=&quot;https://developers.google.com/web/fundamentals/security/csp/&quot;&gt;内容安全策略（CSP）&lt;/a&gt; 来防御这种攻击。&lt;/li&gt;
&lt;li&gt;采用对称加密方式签名（Signature）。对称加密密钥一旦泄漏，会让整个服务的基础设施遭受安全威胁。JWT 支持非对称加密算法，只有签名的服务需要私钥，其他验证 JWT 信息的服务只需要使用公钥即可。&lt;/li&gt;
&lt;li&gt;不校验 JWT 的签名算法。这篇 &lt;a href=&quot;https://auth0.com/blog/critical-vulnerabilities-in-json-web-token-libraries/&quot;&gt;Critical vulnerabilities in JSON Web Token libraries&lt;/a&gt; 文章提到 JWT 的一种漏洞，通过 &lt;code&gt;none&lt;/code&gt; 算法规避令牌验证。所以最好每次都验证 JWT header 中的签名算法是否是期望的。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;相信看了上述的一些问题，你对 JWT 的“简单、安全”有了新的理解。这还没完，JWT 还有以下一些 Cookie-Session 没有的问题：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;令牌难以主动失效：JWT 中虽然有 &lt;code&gt;exp&lt;/code&gt;、&lt;code&gt;nbf&lt;/code&gt; 与 &lt;code&gt;iat&lt;/code&gt; 这些和时间相关的属性，但很难在令牌到期之前让令牌失效，比如很难在用户退出登录时立刻让签发的令牌全部失效。虽然可能通过一些“黑名单”的技术解决这个问题，不过相比 Cookie-Session 来说，引入了一定的复杂性；&lt;/li&gt;
&lt;li&gt;令牌数据老旧：很难把签发的令牌全部更新成最新的数据。比如把用户的权限信息（Role）放在 JWT Payload 中，当用户的角色发生变化时，很难把之前签发的令牌信息更新成最新的数据；&lt;/li&gt;
&lt;li&gt;令牌存储：存储在客户端意味着有多种选择：Cookie？Local Storage？如果放在 Cookie 中，为了安全，一般会给 Cookie 设置 &lt;code&gt;http-only&lt;/code&gt; 和 &lt;code&gt;secure&lt;/code&gt; 的属性。但这也会带来一定的不便性，比如客户端要读取 JWT Payload 的内容只能借助服务端 API 接口。如果将 JWT 存储至浏览器 Local Storage，虽然方便了客户端读取，但可能会带来 XSS 攻击的威胁，又需要去设置 CSP 来防御这种威胁；&lt;/li&gt;
&lt;li&gt;令牌大小：JWT 相比 Cookie-Session 还是大不少，尤其是要在 Payload 中存储一些额外的权限信息。一般服务端都有对 HTTP Header 的大小限制；&lt;/li&gt;
&lt;li&gt;网络开销：更大的文本意味着更高的网络开销，进一步会需要更复杂的基础设施，也会产生复杂的运维问题等；&lt;/li&gt;
&lt;li&gt;难以统计：服务端无状态意味着很难做诸如统计用户在线数量的功能；&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;JWT 解决了 Cookie-Session 方案在分布式系统中因 CAP 的限制而带来的问题，但同时也带来了一些新的问题。所以并不能说 JWT 就是 Cookie-Session 在分布式系统中的完美替代。&lt;/p&gt;
&lt;p&gt;那么 JWT 的最佳使用场景到底是什么？这篇 &lt;a href=&quot;http://cryto.net/~joepie91/blog/2016/06/13/stop-using-jwt-for-sessions/&quot;&gt;Stop using JWT for sessions&lt;/a&gt; 给出了以下的结论：&lt;strong&gt;JWT 更适合作分布式系统中的一次性令牌使用&lt;/strong&gt;。分布式系统继续使用 Cookie-Session 做会话管理，但可以在认证鉴权后生成 JWT 做分布式系统内部服务调用间的一次性令牌。&lt;/p&gt;
&lt;p&gt;让我们通过一个例子来理解下在分布式系统下的认证授权场景。&lt;/p&gt;
&lt;h3&gt;&lt;strong&gt;一个例子&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;https://insights.thoughtworks.cn/wp-content/uploads/2022/12/authentication-and-authorization-in-distributed-systems-3.png&quot;&gt;&lt;img src=&quot;https://insights.thoughtworks.cn/wp-content/uploads/2022/12/authentication-and-authorization-in-distributed-systems-3-1024x713.png&quot; alt=&quot;分布式系统下的认证授权场景&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;此处Auth服务承担的是授权（Authorization）的职责，而不是认证（Authentication）的职责；&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;OAuth2在协议中是做授权框架的，但是其一般需要登录授权，也能实现SSO的功能。&lt;/strong&gt;
&lt;ol&gt;
&lt;li&gt;用户通过 HTTPS 访问我们的应用。当请求发送至微服务网关层（Gateway），网关检测 HTTP Header 中的 Cookie 发现没有 &lt;code&gt;SESSIONID&lt;/code&gt; 这个键值对，重定向至 SSO 登录页面。&lt;/li&gt;
&lt;li&gt;用户通过 SSO 登录我们的应用。&lt;/li&gt;
&lt;li&gt;用户信息存放至 AD/LDAP 等系统中。管理员提前给用户配置好角色权限。&lt;/li&gt;
&lt;li&gt;SSO 集成方案我们选择 OIDC。OIDC 集成了 AD/LDAP，当用户提供正确的用户名和密码后，SSO 重定向至网关。&lt;/li&gt;
&lt;li&gt;网关生成了 &lt;code&gt;SESSIONID&lt;/code&gt; 键值对并通过 HTTP &lt;code&gt;Set-Cookie&lt;/code&gt; 响应给用户浏览器设置了此 Cookie。&lt;/li&gt;
&lt;li&gt;浏览器重新发起带 &lt;code&gt;SESSIONID&lt;/code&gt; Cookie 的请求。网关经过查询其缓存或中间件（如将会话信息存放至 Redis）中的 Session 信息确认了用户的身份信息。之后网关请求 Auth 服务利用其私钥签名生成 JWT 凭证，JWT Payload 中可以存放一部分用户信息和角色信息，这些信息可以从中间件中或 AD/LDAP 中查询出。&lt;/li&gt;
&lt;li&gt;网关之后将此 JWT 凭证通过反向代理转发至内部的 BFF 服务，之后请求到达内部的领域微服务。&lt;/li&gt;
&lt;li&gt;各领域微服务接受到请求后，先从 HTTP Header 中拿出 JWT 凭证。&lt;/li&gt;
&lt;li&gt;在执行真正的业务逻辑前，先利用之前定时从 Auth 服务中同步获取的公钥。
&lt;ol&gt;
&lt;li&gt;Auth 服务通过一个类似 &lt;code&gt;https://&amp;lt;your_domain&amp;gt;/.well-known/jwks.json&lt;/code&gt; 的 API 提供 JWT 公钥的分发。关于 &lt;code&gt;.well-known&lt;/code&gt; 前缀，可阅读 &lt;a href=&quot;https://datatracker.ietf.org/doc/html/rfc5785&quot;&gt;RFC 5785&lt;/a&gt; 做进一步了解。在 &lt;code&gt;jwks.json&lt;/code&gt; 文件中，我们可以找到 &lt;a href=&quot;https://datatracker.ietf.org/doc/html/rfc7517&quot;&gt;JWK&lt;/a&gt; 或 JSON Web Key，这是我们用来验证签名的公钥。&lt;/li&gt;
&lt;li&gt;校验 JWT 这块逻辑属于微服务共有的部分，一般可以开发一个 SDK 包来做这个通用的工作。为了提高性能，可使用缓存技术，定时从 Auth 中同步公钥。&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;获取到公钥后验证成功后拿出 JWT Payload 即可获取到用户信息和角色权限。&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;全部流程就是这样，我们得到了以下的一些好处：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;这个流程里我们并没有将 JWT 返回给用户，只是在认证授权过后生成一个一次性的 JWT 令牌凭证用于微服务内部服务间的调用。因为用户的权限信息存放至 JWT Payload 中，内部的服务并不需要从 AD/LDAP 中获取用户权限信息。可能有人觉得内部服务直接从中间件中获取用户会话信息也可以，但这又让我们的应用进一步耦合了中间件，同时也让一个请求链路中产生更多的子请求，不如直接在请求头中存放用户信息的方式高效。&lt;/li&gt;
&lt;li&gt;在微服务内部间传递的是经过非对称加密算法签名的 JWT 凭证，并不是一个 JWT Payload 信息。就算我们的微服务内部被入侵，攻击者也并不能通过篡改凭证中用户的权限信息来搞破坏。这也满足了分布式系统中 &lt;a href=&quot;https://icyfenix.cn/distribution/secure/zero-trust.html&quot;&gt;零信任网络（Zero Trust）&lt;/a&gt; 的部分要求。&lt;/li&gt;
&lt;li&gt;与外部第三方应用的通讯（M2M），可以采用 OAuth2 的方式或 Personal Access Token 这种方式来集成。&lt;/li&gt;
&lt;li&gt;通过引入 SDK 与定时同步公钥的机制，我们引入了一定的复杂度。比如 SDK 在异构编程语言的项目中开发复杂的问题。不过这个问题在云原生系统时代有了不同的解法，让我们之后讨论这个问题。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;架构总是在演进，也许分布式系统中很多问题我们还没完全解决，就来到了云原生时代。&lt;/p&gt;
&lt;h2&gt;&lt;strong&gt;云原生系统&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;如果你对云原生应用开发还不了解的话，可以先看看我这篇 &lt;a href=&quot;https://www.bmpi.dev/dev/guide-to-k8s-cloud-native/&quot;&gt;K8S 云原生应用开发小记&lt;/a&gt;。云原生系统其实并不是什么后分布式系统时代。它们两者都是为了解决不同场景的问题而出现的解决方案。&lt;/p&gt;
&lt;p&gt;在认证授权这块，云原生系统的优势在于可以通过 &lt;a href=&quot;https://icyfenix.cn/immutable-infrastructure/mesh/&quot;&gt;服务网格(Service Mesh)&lt;/a&gt; 做一些业务系统中通用的切面工作，比如我们在分布式系统中遇到的校验 JWT 的 SDK 其实就可以放入服务网格中的边车（&lt;a href=&quot;https://www.thoughtworks.com/radar/techniques/sidecars-for-endpoint-security&quot;&gt;Sidecar&lt;/a&gt;）去实现，让业务应用更专注特定领域的业务。&lt;/p&gt;
&lt;p&gt;由于这篇文章并不主要讨论云原生，对这部分感兴趣的可以参考以下两篇文章做进一步了解：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;https://insights.thoughtworks.cn/service-mesh-authentication-authorization/&quot;&gt;Service Mesh架构下的认证与授权&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://insights.thoughtworks.cn/microservices-authentication-token-management/&quot;&gt;微服务下的身份认证和令牌管理&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h2&gt;&lt;strong&gt;总结&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;由于篇幅及能力限制，这篇文章我只能从高层次梳理在不同架构演进中认证、授权及凭证这些和架构安全相关的技术的发展过程。由于这些技术涉及了大量的技术标准及实践，很难在一篇文章中对这些技术做详尽的分享，更无法去分享如何实现。但有了这些理论支持和最佳实践，希望能让你在实现的过程中多了一个指引。如果你想进一步了解，可参考文章中的参考文章链接。&lt;/p&gt;
&lt;p&gt;最后，技术总是在不断的发展，但并不是新技术总比老技术“先进”。正如文章中对 Cookie-Session 与 JWT 的分析对比，技术方案总是充满了各种 &lt;code&gt;Trade-off&lt;/code&gt;。而作为一个工程师，我们能做的就是认清这些技术的历史背景及局限性，选择最适合项目需求的技术方案。&lt;/p&gt;
&amp;#13;
&lt;/div&gt;&amp;#13;
&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>e84d945000cdc9ec42b97ef1d06e74e6</guid>
<title>海量请求下的接口并发解决方案</title>
<link>https://toutiao.io/k/vjyeghm</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;思考并整理分布式业务的解决方案，有问题请帮忙指出，谢谢！&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;设定一个场景，假如一个商品接口在某段时间突然上升，会怎么办？&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;生活中的例子来说，假设冰墩墩在当天晚上上热搜之后，迅速有十几万人去淘宝下单购买，此时并没有做好对该商品的缓存预热以及准备，如何操作？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;对于这个问题，在电商高并发系统中，对接口的保护一般采用：&lt;span&gt;缓存、限流、降级 来操作。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;假设该接口已经接受过风控的处理，过滤掉一半的机器人脚本请求，剩下都是人为的下单请求。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;服务限流&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;限流 主要的目的是通过对并发访问/请求进行限速，或者对一个时间窗口内的请求进行限速，一旦达到限制速率则可以拒绝服务、排队或等待、降级等处理。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;限流算法&lt;/span&gt;&lt;/h2&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;漏斗算法 漏桶算法&lt;/strong&gt;&lt;/section&gt;&lt;section&gt;是当请求到达时直接放入漏桶，如果当前容量已达到上限（限流值），则进行丢弃或其他策略（触发限流策略）。漏桶以固定的速率（根据服务吞吐量）进行释放访问请求（即请求通过），直到漏桶为空。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;漏斗算法的思想就是，不管你来多少请求，我的接口消费速度一定是小于等于流出速率的阈值的。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.8289124668435013&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sXiaukvjR0RDAdzFJk6cpqJGuE7kbRkHwnA9OsWnd6ZHPQ12fWq3ekJJib7FD3L0GUcDsakkElKDR8ZQc655Lzag/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;754&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可以基于消息队列来实现&lt;/p&gt;&lt;/blockquote&gt;&lt;ol start=&quot;2&quot; data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;令牌桶算法 令牌桶算法&lt;/strong&gt;&lt;/section&gt;&lt;section&gt;是程序以v（v = 时间周期 / 限流值）的速度向令牌桶中增加令牌，直到令牌桶满，请求到达时向令牌桶请求令牌，如果获取成功则通过请求，如果获取失败触发限流策略。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;令牌桶算法和漏斗算法的思想差别在于，前者可以允许突发请求的发生。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.7530120481927711&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sXiaukvjR0RDAdzFJk6cpqJGuE7kbRkHwMhvJoYWNRT0XjFT6Q2rHrbwey9SttHNT6kSDWm3TK7uKibdZeKwa4Hw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;830&quot;/&gt;&lt;/p&gt;&lt;ol start=&quot;3&quot; data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;滑窗算法 滑窗算法&lt;/strong&gt;&lt;/section&gt;&lt;section&gt;是将一个时间周期分为N个小周期，分别记录每个小周期内访问次数，并且根据时间滑动删除过期的小周期。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如下图所示，假设时间周期为1分钟，将1分钟再分为2个小周期，统计每个小周期的访问数量，则可以看到，第一个时间周期内，访问数量为75，第二个时间周期内，访问数量为100，如果一个时间周期内所有的小周期总和超过100的话，则会触发限流策略。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.28912213740458015&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sXiaukvjR0RDAdzFJk6cpqJGuE7kbRkHwJUBF2ic5vGZx5RiabXZJZE7WUgxWQibtG5mk6nFY4pNT8C8iawRxjXYxlA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1048&quot;/&gt;&lt;/p&gt;&lt;blockquote&gt;&lt;span/&gt;Sentinel的实现 和 TCP滑窗。&lt;/blockquote&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;接入层限流&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;Nginx限流&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Nginx 限流采用的是漏桶算法。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;它可以根据客户端特征，限制其访问频率，客户端特征主要指 IP、UserAgent等。使用 IP 比 UserAgent 更可靠，因为 IP 无法造假，UserAgent 可随意伪造。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;limit_req模块基于IP：Module ngx_http_limit_req_module (nginx.org)&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;tgngine：ngx_http_limit_req_module - The Tengine Web Server (taobao.org)&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;本地接口限流&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;Semaphore&lt;/strong&gt;Java 并发库 的 Semaphore 可以很轻松完成信号量控制，Semaphore 可以控制某个资源可被同时访问的个数，通过 acquire() 获取一个许可，如果没有就等待，而 release() 释放一个许可。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;假如我们对外提供一个服务接口，允许最大并发数为40，我们可以这样：&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;java&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;final&lt;/span&gt; Semaphore permit = &lt;span class=&quot;code-snippet__keyword&quot;&gt;new&lt;/span&gt; Semaphore(&lt;span class=&quot;code-snippet__number&quot;&gt;40&lt;/span&gt;, &lt;span class=&quot;code-snippet__keyword&quot;&gt;true&lt;/span&gt;);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;process&lt;/span&gt;&lt;span class=&quot;code-snippet__params&quot;&gt;()&lt;/span&gt;&lt;/span&gt;{&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;try&lt;/span&gt;{&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    permit.acquire();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;} &lt;span class=&quot;code-snippet__keyword&quot;&gt;catch&lt;/span&gt; (InterruptedException e) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    e.printStackTrace();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;} &lt;span class=&quot;code-snippet__keyword&quot;&gt;finally&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    permit.release();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;blockquote class=&quot;&quot; data-type=&quot;2&quot; data-url=&quot;&quot; data-author-name=&quot;&quot; data-content-utf8-length=&quot;21&quot; data-source-title=&quot;&quot;&gt;&lt;section class=&quot;&quot;&gt;&lt;section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;具体的 Semaphore 实现参考源码。&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;分布式接口限流&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;使用消息队列&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;不管是用MQ中间件，或是Redis的List实现的消息队列，都可以作为一个 缓冲队列 来使用。思想就是基于漏斗算法。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当对于一个接口请求达到一定阈值时，就可以启用消息队列来进行接口数据的缓冲，并根据服务的吞吐量来消费数据。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.4116222760290557&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sXiaukvjR0RDAdzFJk6cpqJGuE7kbRkHwnfuUeeZwFMAweSc5W1WHgVOqicsvTcW8jxKkoABKqNnvUM4ibqj7XWHQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;826&quot;/&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;服务降级&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在接口做好风控的前提下，发现了接口请求的并发量迅速上升，我们可以启用兜底方案，进行服务降级。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;一般服务降级应该用来对一些 不重要 或 不紧急 的服务或任务进行服务的&lt;span class=&quot;Apple-converted-space&quot;&gt; &lt;/span&gt;&lt;/strong&gt;&lt;span&gt;&lt;strong&gt;延迟使用&lt;/strong&gt;&lt;/span&gt;&lt;strong&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt; &lt;/span&gt;或&lt;span class=&quot;Apple-converted-space&quot;&gt; &lt;/span&gt;&lt;/strong&gt;&lt;span&gt;&lt;strong&gt;暂停使用&lt;/strong&gt;&lt;/span&gt;&lt;strong&gt;。&lt;/strong&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;降级方案&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;停止边缘业务&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;比如淘宝双11前，就不可以查询三个月前的订单，对边缘业务进行降级，保证核心业务的高可用。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;拒绝请求&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在接口请求并发量大于阈值，或是接口出现大量失败请求等等突发情况，可以拒绝一些访问请求。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;拒绝策略&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;随机拒绝：随机拒绝超过阈值的请求 。拒绝旧请求：按照请求的时间，优先拒绝更早收到的请求。拒绝非核心请求：根据系统业务设置核心请求清单，将非核心清单内的请求拒绝掉。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;恢复方案&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在实现服务降级之后，对于突增流量我们可以继续注册多个消费者服务来应对并发量，之后我们再对一些服务器进行慢加载。&lt;/p&gt;&lt;blockquote class=&quot;&quot; data-type=&quot;2&quot; data-url=&quot;&quot; data-author-name=&quot;&quot; data-content-utf8-length=&quot;13&quot; data-source-title=&quot;&quot;&gt;&lt;section class=&quot;&quot;&gt;&lt;section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;降级具体实现参考其他文章。&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;数据缓存&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在接口做好风控的前提下，发现了接口请求的并发量迅速上升，我们可以分以下几个操作执行：&lt;span/&gt;&lt;/p&gt;&lt;ol class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;对访问请求使用分布式锁进行阻塞。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;在这个短时间中，我们可以将对应操作行的热点数据，缓存在缓存中间件中。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;放行请求后，让所有请求优先操作缓存数据。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;再将操作的结果通过消息队列发送给消费接口慢慢消费。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.9607577807848444&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sXiaukvjR0RDAdzFJk6cpqJGuE7kbRkHwUjjJU17pVBEwxehBv7w7PpoCSiclclDibpd2CbroW3jvOORoHA3yvPrw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;739&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;缓存问题&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;假设我们操作的是一个库存接口，此时数据库中只有100个库存。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那假如此时我们将一条数据放入缓存中，如果所有的请求都来访问这个缓存，那它还是被打挂，我们该怎么操作？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;读写分离&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;第一种想法，读写分离。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;使用Redis的哨兵集群模式来进行主从复制的读写分离操作。读的操作肯定大于写操作，等库存被消费到0时，读操作直接快速失败。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.7843822843822844&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sXiaukvjR0RDAdzFJk6cpqJGuE7kbRkHwJVWhgNAs9s9NjxuV9iavichW7r1H4DXZdlJXjKUQiacz26ebrX5jpuJQA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;858&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;负载均衡&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;第二种想法，负载均衡。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在缓存数据后，如果所有请求都来缓存中操作这个库存，不管是加悲观锁还是乐观锁，并发率都很低，此时我们可以对这个库存进行拆分。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们可以参照 ConcurrentHashMap 中的 counterCells 变量的设计思想，将100个库存拆分到10个缓存服务中，每个缓存服务有10个缓存，然后我们再对请求进行负载均衡到各个缓存服务上。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但是这种方式会有问题，如果大部分用户被hash到同一个缓存上，导致其他缓存没有被消费，却返回没有库存，这是不合理的。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.8071593533487298&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sXiaukvjR0RDAdzFJk6cpqJGuE7kbRkHwZOnojHTiczcOvpiaAmpibmcY6Yrt82x7rOkllxKYKm6RFse2fu8wrG4ibQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;866&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;page cache&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;第三种想法，page cache。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;大部分软件架构其实都用到了这种方法，比如linux内核的硬盘写入、mysql的刷盘等等，即将短时间内的写操作聚合结果写入，所有的写操作在缓存内完成。&lt;/p&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>e958aa3693d38e60afd57cd3f1a8c73f</guid>
<title>说透 IO 多路复用模型</title>
<link>https://toutiao.io/k/lcr4y93</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;preview&quot;&gt;&lt;h3&gt;作者：京东零售 石朝阳&lt;/h3&gt;

&lt;p&gt;在说IO多路复用模型之前，我们先来大致了解下Linux文件系统。在Linux系统中，不论是你的鼠标，键盘，还是打印机，甚至于连接到本机的socket client端，都是以文件描述符的形式存在于系统中，诸如此类，等等等等，所以可以这么说，一切皆文件。来看一下系统定义的文件描述符说明：&lt;/p&gt;

&lt;p&gt;﻿&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a53184abd9f34ecfa1d5f7120fe05fb4%7Etplv-k3u1fbpfcp-zoom-1.image&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;﻿﻿  &lt;/p&gt;

&lt;p&gt;从上面的列表可以看到，文件描述符0,1,2都已经被系统占用了，当系统启动的时候，这三个描述符就存在了。其中0代表标准输入，1代表标准输出，2代表错误输出。当我们创建新的文件描述符的时候，就会在2的基础上进行递增。可以这么说，文件描述符是为了管理被打开的文件而创建的系统索引，他代表了文件的身份ID。对标windows的话，你可以认为和句柄类似，这样就更容易理解一些。&lt;/p&gt;

&lt;p&gt;由于网上对linux文件这块的原理描述的文章已经非常多了，所以这里我不再做过多的赘述，感兴趣的同学可以从&lt;a href=&quot;https://en.wikipedia.org/wiki/File_descriptor&quot;&gt;Wikipedia&lt;/a&gt;翻阅一下。由于这块内容比较复杂，不属于本文普及的内容，建议读者另行自研，这里我非常推荐马士兵老师将linux文件系统这块，讲解的真的非常好。&lt;/p&gt;

&lt;h3&gt;&lt;strong&gt;select模型&lt;/strong&gt;&lt;/h3&gt;

&lt;p&gt;此模型是IO多路复用的最早期使用的模型之一，距今已经几十年了，但是现在依旧有不少应用还在采用此种方式，可见其长生不老。首先来看下其&lt;a href=&quot;https://linux.die.net/man/2/select&quot;&gt;具体的定义&lt;/a&gt;（来源于man二类文档）：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;int select(int nfds, fd_set *readfds, fd_set *writefds, fd_set *errorfds, struct timeval *timeout);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这里解释下其具体参数：&lt;/p&gt;

&lt;p&gt;参数一：nfds，也即maxfd，最大的文件描述符递增一。这里之所以传最大描述符，为的就是在遍历fd_set的时候，限定遍历范围。&lt;/p&gt;

&lt;p&gt;参数二：readfds，可读文件描述符集合。&lt;/p&gt;

&lt;p&gt;参数三：writefds，可写文件描述符集合。&lt;/p&gt;

&lt;p&gt;参数四：errorfds，异常文件描述符集合。&lt;/p&gt;

&lt;p&gt;参数五：timeout，超时时间。在这段时间内没有检测到描述符被触发，则返回。&lt;/p&gt;

&lt;p&gt;下面的宏处理，可以对fd_set集合（准确的说是bitmap，一个描述符有变更，则会在描述符对应的索引处置1）进行操作：&lt;/p&gt;

&lt;p&gt;FD_CLR(inr fd,fd_set* set) 用来清除描述词组set中相关fd 的位，即bitmap结构中索引值为fd的值置为0。&lt;/p&gt;

&lt;p&gt;FD_ISSET(int fd,fd_set *set) 用来测试描述词组set中相关fd 的位是否为真，即bitmap结构中某一位是否为1。&lt;/p&gt;

&lt;p&gt;FD_SET（int fd,fd_set*set） 用来设置描述词组set中相关fd的位，即将bitmap结构中某一位设置为1，索引值为fd。&lt;/p&gt;

&lt;p&gt;FD_ZERO（fd_set *set） 用来清除描述词组set的全部位，即将bitmap结构全部清零。&lt;/p&gt;

&lt;p&gt;首先来看一段服务端采用了select模型的示例代码：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;//创建server端套接字，获取文件描述符
    int listenfd = socket(PF_INET,SOCK_STREAM,0);
    if(listenfd &amp;lt; 0) return -1;
    //绑定服务器
    bind(listenfd,(struct sockaddr*)&amp;amp;address,sizeof(address));
    //监听服务器
    listen(listenfd,5); 
    struct sockaddr_in client;
    socklen_t addr_len = sizeof(client);
    //接收客户端连接
    int connfd = accept(listenfd,(struct sockaddr*)&amp;amp;client,&amp;amp;addr_len);
    //读缓冲区
    char buff[1024]; 
    //读文件操作符
    fd_set read_fds;  
    while(1)
    {
        memset(buff,0,sizeof(buff));
        //注意：每次调用select之前都要重新设置文件描述符connfd，因为文件描述符表会在内核中被修改
        FD_ZERO(&amp;amp;read_fds);
        FD_SET(connfd,&amp;amp;read_fds);
        //注意：select会将用户态中的文件描述符表放到内核中进行修改，内核修改完毕后再返回给用户态，开销较大
        ret = select(connfd+1,&amp;amp;read_fds,NULL,NULL,NULL);
        if(ret &amp;lt; 0)
        {
            printf(&quot;Fail to select!\n&quot;);
            return -1;
        }
        //检测文件描述符表中相关请求是否可读
        if(FD_ISSET(connfd, &amp;amp;read_fds))
        {
            ret = recv(connfd,buff,sizeof(buff)-1,0);
            printf(&quot;receive %d bytes from client: %s \n&quot;,ret,buff);
        }
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面的代码我加了比较详细的注释了，大家应该很容易看明白，说白了大概流程其实如下：&lt;/p&gt;

&lt;p&gt;首先，创建socket套接字，创建完毕后，会获取到此套接字的文件描述符。&lt;/p&gt;

&lt;p&gt;然后，bind到指定的地址进行监听listen。这样，服务端就在特定的端口启动起来并进行监听了。&lt;/p&gt;

&lt;p&gt;之后，利用开启accept方法来监听客户端的连接请求。一旦有客户端连接，则将获取到当前客户端连接的connection文件描述符。&lt;/p&gt;

&lt;p&gt;双方建立连接之后，就可以进行数据互传了。需要注意的是，在循环开始的时候，务必每次都要重新设置当前connection的文件描述符，是因为文件描描述符表在内核中被修改过，如果不重置，将会导致异常的情况。&lt;/p&gt;

&lt;p&gt;重新设置文件描述符后，就可以利用select函数从文件描述符表中，来轮询哪些文件描述符就绪了。此时系统会将用户态的文件描述符表发送到内核态进行调整，即将准备就绪的文件描述符进行置位，然后再发送给用户态的应用中来。&lt;/p&gt;

&lt;p&gt;用户通过FD_ISSET方法来轮询文件描述符，如果数据可读，则读取数据即可。&lt;/p&gt;

&lt;p&gt;举个例子，假设此时连接上来了3个客户端，connection的文件描述符分别为 4,8,12，那么其read_fds文件描述符表（bitmap结构）的大致结构为 00010001000100000....0，由于read_fds文件描述符的长度为1024位，所以最多允许1024个连接。&lt;/p&gt;

&lt;p&gt;﻿&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2e531ddb917144af8e30fc7bcba4faae%7Etplv-k3u1fbpfcp-zoom-1.image&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;﻿﻿  &lt;/p&gt;

&lt;p&gt;而在select的时候，涉及到用户态和内核态的转换，所以整体转换方式如下：&lt;/p&gt;

&lt;p&gt;﻿&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2d2189eee3c446b2b8a95a983462f96f%7Etplv-k3u1fbpfcp-zoom-1.image&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;﻿﻿  &lt;/p&gt;

&lt;p&gt;所以，综合起来，select整体还是比较高效和稳定的，但是呈现出来的问题也不少，这些问题进一步限制了其性能发挥：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;文件描述符表为bitmap结构，且有长度为1024的限制。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;fdset无法做到重用，每次循环必须重新创建。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;频繁的用户态和内核态拷贝，性能开销较大。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;需要对文件描述符表进行遍历，O(n)的轮询时间复杂度。&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h3&gt;&lt;strong&gt;poll模型&lt;/strong&gt;&lt;/h3&gt;

&lt;p&gt;考虑到select模型的几个限制，后来进行了改进，这也就是poll模型，既然是select模型的改进版，那么肯定有其亮眼的地方，一起来看看吧。当然，这次我们依旧是先翻阅&lt;a href=&quot;https://linux.die.net/man/2/poll&quot;&gt;linux man二类文档&lt;/a&gt;，因为这是官方的文档，对其有着最为精准的定义。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;int poll(struct pollfd *fds, nfds_t nfds, int timeout);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;其实，从运行机制上说来，poll所做的功能和select是基本上一样的，都是等待并检测一组文件描述符就绪，然后在进行后续的IO处理工作。只不过不同的是，select中，采用的是bitmap结构，长度限定在1024位的文件描述符表，而poll模型则采用的是pollfd结构的数组fds，也正是由于poll模型采用了数组结构，则不会有1024长度限制，使其能够承受更高的并发。&lt;/p&gt;

&lt;p&gt;pollfd结构内容如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;struct pollfd {
    int   fd;         /* 文件描述符 */
    short events;     /* 关心的事件 */
    short revents;    /* 实际返回的事件 */
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;从上面的结构可以看出，fd很明显就是指文件描述符，也就是当客户端连接上来后，fd会将生成的文件描述符保存到这里；而events则是指用户想关注的事件；revents则是指实际返回的事件，是由系统内核填充并返回，如果当前的fd文件描述符有状态变化，则revents的值就会有相应的变化。&lt;/p&gt;

&lt;p&gt;events事件列表如下：&lt;/p&gt;

&lt;p&gt;﻿&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1cd4e5aa3f624a5ca09c8ed18264cfa5%7Etplv-k3u1fbpfcp-zoom-1.image&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;﻿﻿  &lt;/p&gt;

&lt;p&gt;revents事件列表如下：&lt;/p&gt;

&lt;p&gt;﻿&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/bc5b9c27730942649c3f31672d7c7926%7Etplv-k3u1fbpfcp-zoom-1.image&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;﻿﻿  &lt;/p&gt;

&lt;p&gt;从列表中可以看出，revents是包含events的。接下来结合示例来看一下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;//创建server端套接字，获取文件描述符
    int listenfd = socket(PF_INET,SOCK_STREAM,0);
    if(listenfd &amp;lt; 0) return -1;
    //绑定服务器
    bind(listenfd,(struct sockaddr*)&amp;amp;address,sizeof(address));
    //监听服务器
    listen(listenfd,5); 
    struct pollfd pollfds[1];
    socklen_t addr_len = sizeof(client);
    //接收客户端连接
    int connfd = accept(listenfd,(struct sockaddr*)&amp;amp;client,&amp;amp;addr_len);
    //放入fd数组
    pollfds[0].fd = connfd;
    pollfds[0].events = POLLIN;
    //读缓冲区
    char buff[1024]; 
    //读文件操作符
    fd_set read_fds;  
    while(1)
    {
        memset(buff,0,sizeof(buff));
        /**
         ** SELECT模型专用
         ** 注意：每次调用select之前都要重新设置文件描述符connfd，因为文件描述符表会在内核中被修改
         ** FD_ZERO(&amp;amp;read_fds);
         ** FD_SET(connfd,&amp;amp;read_fds);
        ** 注意：select会将用户态中的文件描述符表放到内核中进行修改，内核修改完毕后再返回给用户态，开销较大
        ** ret = select(connfd+1,&amp;amp;read_fds,NULL,NULL,NULL);
        **/
        ret = poll(pollfds, 1, 1000);
        if(ret &amp;lt; 0)
        {
            printf(&quot;Fail to poll!\n&quot;);
            return -1;
        }
        /**
         ** SELECT模型专用
         ** 检测文件描述符表中相关请求是否可读
         ** if(FD_ISSET(connfd, &amp;amp;read_fds))
         ** {
         **   ret = recv(connfd,buff,sizeof(buff)-1,0);
         **   printf(&quot;receive %d bytes from client: %s \n&quot;,ret,buff);
         ** }
         **/
        //检测文件描述符数组中相关请求
        if(pollfds[0].revents &amp;amp; POLLIN){
            pollfds[0].revents = 0;
            ret = recv(connfd,buff,sizeof(buff)-1,0);
            printf(&quot;receive %d bytes from client: %s \n&quot;,ret,buff);
        }
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;由于源码中，我做了比较详细的注释，同时将和select模型不一样的地方都列了出来，这里就不再详细解释了。总体说来，poll模型比select模型要好用一些，去掉了一些限制，但是仍然避免不了如下的问题：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;用户态和内核态仍需要频繁切换，因为revents的赋值是在内核态进行的，然后再推送到用户态，和select类似，整体开销较大。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;仍需要遍历数组，时间复杂度为O（N）。&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h3&gt;&lt;strong&gt;epoll模型&lt;/strong&gt;&lt;/h3&gt;

&lt;p&gt;如果说select模型和poll模型是早期的产物，在性能上有诸多不尽人意之处，那么自linux 2.6之后新增的epoll模型，则彻底解决了性能问题，一举使得单机承受百万并发的课题变得极为容易。现在可以这么说，只需要一些简单的设置更改，然后配合上epoll的性能，实现单机百万并发轻而易举。同时，由于epoll整体的优化，使得之前的几个比较耗费性能的问题不再成为羁绊，所以也成为了linux平台上进行网络通讯的首选模型。&lt;/p&gt;

&lt;p&gt;讲解之前，还是linux man文档镇楼：&lt;a href=&quot;https://linux.die.net/man/4/epoll&quot;&gt;linux man epoll 4类文档&lt;/a&gt; &lt;a href=&quot;https://linux.die.net/man/7/epoll&quot;&gt;linux man epoll 7类文档&lt;/a&gt;，俩文档结合着读，会对epoll有个大概的了解。和之前提到的select和poll不同的是，此二者皆属于系统调用函数，但是epoll则不然，他是存在于内核中的数据结构，可以通过epoll_create，epoll_ctl及epoll_wait三个函数结合来对此数据结构进行操控。&lt;/p&gt;

&lt;p&gt;说道epoll_create函数，其作用是在内核中创建一个epoll数据结构实例，然后将返回此实例在系统中的文件描述符。此epoll数据结构的组成其实是一个链表结构，我们称之为interest list，里面会注册连接上来的client的文件描述符。&lt;/p&gt;

&lt;p&gt;其简化工作机制如下：&lt;/p&gt;

&lt;p&gt;﻿&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9098325d1e78440d873dc6e80f4337e5%7Etplv-k3u1fbpfcp-zoom-1.image&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;﻿﻿  &lt;/p&gt;

&lt;p&gt;说道epoll_ctl函数，其作用则是对epoll实例进行增删改查操作。有些类似我们常用的CRUD操作。这个函数操作的对象其实就是epoll数据结构，当有新的client连接上来的时候，他会将此client注册到epoll中的interest list中，此操作通过附加EPOLL_CTL_ADD标记来实现；当已有的client掉线或者主动下线的时候，他会将下线的client从epoll的interest list中移除，此操作通过附加EPOLL_CTL_DEL标记来实现；当有client的文件描述符有变更的时候，他会将events中的对应的文件描述符进行更新，此操作通过附加EPOLL_CTL_MOD来实现；当interest list中有client已经准备好了，可以进行IO操作的时候，他会将这些clients拿出来，然后放到一个新的ready list里面。&lt;/p&gt;

&lt;p&gt;其简化工作机制如下：&lt;/p&gt;

&lt;p&gt;﻿&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a62a1115a06e4120aa2ac8041a3fcae9%7Etplv-k3u1fbpfcp-zoom-1.image&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;﻿﻿  &lt;/p&gt;

&lt;p&gt;说道epoll_wait函数，其作用就是扫描ready list，处理准备就绪的client IO，其返回结果即为准备好进行IO的client的个数。通过遍历这些准备好的client，就可以轻松进行IO处理了。&lt;/p&gt;

&lt;p&gt;上面这三个函数是epoll操作的基本函数，但是，想要彻底理解epoll，则需要先了解这三块内容，即：inode，链表，红黑树。&lt;/p&gt;

&lt;p&gt;在linux内核中，针对当前打开的文件，有一个open file table，里面记录的是所有打开的文件描述符信息；同时也有一个inode table，里面则记录的是底层的文件描述符信息。这里假如文件描述符B fork了文件描述符A，虽然在open file table中，我们看新增了一个文件描述符B，但是实际上，在inode table中，A和B的底层是一模一样的。这里，将inode table中的内容理解为windows中的文件属性，会更加贴切和易懂。这样存储的好处就是，无论上层文件描述符怎么变化，由于epoll监控的数据永远是inode table的底层数据，那么我就可以一直能够监控到文件的各种变化信息，这也是epoll高效的基础。更多详细信息，请参阅这两篇文章：&lt;a href=&quot;https://copyconstruct.medium.com/nonblocking-i-o-99948ad7c957&quot;&gt;Nonblocking IO &lt;/a&gt;&amp;amp; &lt;a href=&quot;https://copyconstruct.medium.com/the-method-to-epolls-madness-d9d2d6378642&quot;&gt;The method to epoll&#x27;s madness&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;简化流程如下：&lt;/p&gt;

&lt;p&gt;﻿&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/41126d9704cd44f8ba024b7bdde4d924%7Etplv-k3u1fbpfcp-zoom-1.image&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;﻿﻿  &lt;/p&gt;

&lt;p&gt;数据存储这块解决了，那么针对连接上来的客户端socket，该用什么数据结构保存进来呢？这里用到了红黑树，由于客户端socket会有频繁的新增和删除操作，而红黑树这块时间复杂度仅仅为O(logN)，还是挺高效的。有人会问为啥不用哈希表呢？当大量的连接频繁的进行接入或者断开的时候，扩容或者其他行为将会产生不少的rehash操作，而且还要考虑哈希冲突的情况。虽然查询速度的确可以达到o(1)，但是rehash或者哈希冲突是不可控的，所以基于这些考量，我认为红黑树占优一些。&lt;/p&gt;

&lt;p&gt;客户端socket怎么管理这块解决了，接下来，当有socket有数据需要进行读写事件处理的时候，系统会将已经就绪的socket添加到双向链表中，然后通过epoll_wait方法检测的时候，其实检查的就是这个双向链表，由于链表中都是就绪的数据，所以避免了针对整个客户端socket列表进行遍历的情况，使得整体效率大大提升。 整体的操作流程为：&lt;/p&gt;

&lt;p&gt;首先，利用epoll_create在内核中创建一个epoll对象。其实这个epoll对象，就是一个可以存储客户端连接的数据结构。&lt;/p&gt;

&lt;p&gt;然后，客户端socket连接上来，会通过epoll_ctl操作将结果添加到epoll对象的红黑树数据结构中。&lt;/p&gt;

&lt;p&gt;然后，一旦有socket有事件发生，则会通过回调函数将其添加到ready list双向链表中。&lt;/p&gt;

&lt;p&gt;最后，epoll_wait会遍历链表来处理已经准备好的socket，然后通过预先设置的水平触发或者边缘触发来进行数据的感知操作。&lt;/p&gt;

&lt;p&gt;从上面的细节可以看出，由于epoll内部监控的是底层的文件描述符信息，可以将变更的描述符直接加入到ready list，无需用户将所有的描述符再进行传入。同时由于epoll_wait扫描的是已经就绪的文件描述符，避免了很多无效的遍历查询，使得epoll的整体性能大大提升，可以说现在只要谈论linux平台的IO多路复用，epoll已经成为了不二之选。&lt;/p&gt;

&lt;h4&gt;&lt;strong&gt;水平触发和边缘触发&lt;/strong&gt;&lt;/h4&gt;

&lt;p&gt;上面说到了epoll，主要讲解了client端怎么连进来，但是并未详细的讲解epoll_wait怎么被唤醒的，这里我将来详细的讲解一下。&lt;/p&gt;

&lt;p&gt;水平触发，意即Level Trigger，边缘触发，意即Edge Trigger，如果单从字面意思上理解，则不太容易，但是如果将硬件设计中的水平沿，上升沿，下降沿的概念引进来，则理解起来就容易多了。比如我们可以这样认为：&lt;/p&gt;

&lt;p&gt;﻿&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2203a03db2464f7b8fdf088c5cf0b081%7Etplv-k3u1fbpfcp-zoom-1.image&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;﻿﻿  &lt;/p&gt;

&lt;p&gt;如果将上图中的方块看做是buffer的话，那么理解起来则就更加容易了，比如针对水平触发，buffer只要是一直有数据，则一直通知；而边缘触发，则buffer容量发生变化的时候，才会通知。虽然可以这样简单的理解，但是实际上，其细节处理部分，比图示中展现的更加精细，这里来详细的说一下。&lt;/p&gt;

&lt;h5&gt;&lt;strong&gt;边缘触发&lt;/strong&gt;&lt;/h5&gt;

&lt;p&gt;针对读操作，也就是当前fd处于EPOLLIN模式下，即可读。此时意味着有新的数据到来，接收缓冲区可读，以下buffer都指接收缓冲区：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;buffer由空变为非空，意即有数据进来的时候，此过程会触发通知。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;﻿&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/609a9db48f1240f1af873eb12632bdc7%7Etplv-k3u1fbpfcp-zoom-1.image&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;﻿﻿  &lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;buffer原本有些数据，这时候又有新数据进来的时候，数据变多，此过程会触发通知。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;﻿&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b7f92ffc6bf64219803e5994418635d3%7Etplv-k3u1fbpfcp-zoom-1.image&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;﻿﻿  &lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;buffer中有数据，此时用户对操作的fd注册EPOLL_CTL_MOD事件的时候，会触发通知。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;﻿&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a4452a8540ab4cde8b5af7be1d92e141%7Etplv-k3u1fbpfcp-zoom-1.image&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;﻿﻿  &lt;/p&gt;

&lt;p&gt;针对写操作，也就是当前fd处于EPOLLOUT模式下，即可写。此时意味着缓冲区可以写了，以下buffer都指发送缓冲区：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;buffer满了，这时候发送出去一些数据，数据变少，此过程会触发通知。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;﻿&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5dfd379f33884bf8a18f85e2216b8a0b%7Etplv-k3u1fbpfcp-zoom-1.image&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;﻿﻿  &lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;buffer原本有些数据，这时候又发送出去一些数据，数据变少，此过程会触发通知。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;﻿&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/48720fa50a1e4137886b594a01ed73c2%7Etplv-k3u1fbpfcp-zoom-1.image&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;﻿﻿  &lt;/p&gt;

&lt;p&gt;这里就是ET这种模式触发的几种情形，可以看出，基本上都是围绕着接收缓冲区或者发送缓冲区的状态变化来进行的。&lt;/p&gt;

&lt;p&gt;晦涩难懂？不存在的，举个栗子：&lt;/p&gt;

&lt;p&gt;在服务端，我们开启边缘触发模式，然后将buffer size设为10个字节，来看看具体的表现形式。&lt;/p&gt;

&lt;p&gt;服务端开启，客户端连接，发送单字符A到服务端，输出结果如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;--&amp;gt;ET Mode: it was triggered once
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;get 1 bytes of content: A
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;--&amp;gt;wait to read!
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以看到，由于buffer从空到非空，边缘触发通知产生，之后在epoll_wait处阻塞，继续等待后续事件。&lt;/p&gt;

&lt;p&gt;这里我们变一下，输入ABCDEFGHIJKLMNOPQ，可以看到，客户端发送的字符长度超过了服务端buffer size，那么输出结果将是怎么样的呢？&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;--&amp;gt;ET Mode: it was triggered once
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;get 9 bytes of content: ABCDEFGHI
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;get 8 bytes of content: JKLMNOPQ
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;--&amp;gt;wait to read!
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以看到，这次发送，由于发送的长度大于buffer size，所以内容被折成两段进行接收，由于用了边缘触发方式，buffer的情况是从空到非空，所以只会产生一次通知。&lt;/p&gt;

&lt;h5&gt;&lt;strong&gt;水平触发&lt;/strong&gt;&lt;/h5&gt;

&lt;p&gt;水平触发则简单多了，他包含了边缘触发的所有场景，简而言之如下：&lt;/p&gt;

&lt;p&gt;当接收缓冲区不为空的时候，有数据可读，则读事件会一直触发。&lt;/p&gt;

&lt;p&gt;﻿&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8330414a6dc04641abdf0507e7fb2f86%7Etplv-k3u1fbpfcp-zoom-1.image&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;﻿﻿  &lt;/p&gt;

&lt;p&gt;当发送缓冲区未满的时候，可以继续写入数据，则写事件一直会触发。&lt;/p&gt;

&lt;p&gt;﻿&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2ef751ed9f0f4012871baa67399a78fd%7Etplv-k3u1fbpfcp-zoom-1.image&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;﻿﻿  &lt;/p&gt;

&lt;p&gt;同样的，为了使表达更清晰，我们也来举个栗子，按照上述入输入方式来进行。&lt;/p&gt;

&lt;p&gt;服务端开启，客户端连接并发送单字符A，可以看到服务端输出情况如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;--&amp;gt;LT Mode: it was triggered once!
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;get 1 bytes of content: A
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这个输出结果，毋庸置疑，由于buffer中有数据，所以水平模式触发，输出了结果。&lt;/p&gt;

&lt;p&gt;服务端开启，客户端连接并发送ABCDEFGHIJKLMNOPQ，可以看到服务端输出情况如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;--&amp;gt;LT Mode: it was triggered once!
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;get 9 bytes of content: ABCDEFGHI
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;--&amp;gt;LT Mode: it was triggered once!
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;get 8 bytes of content: JKLMNOPQ
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;从结果中，可以看出，由于buffer中数据读取完毕后，还有未读完的数据，所以水平模式会一直触发，这也是为啥这里水平模式被触发了两次的原因。&lt;/p&gt;

&lt;p&gt;有了这两个栗子的比对，不知道聪明的你，get到二者的区别了吗？&lt;/p&gt;

&lt;p&gt;在实际开发过程中，实际上LT更易用一些，毕竟系统帮助我们做了大部分校验通知工作，之前提到的SELECT和POLL，默认采用的也都是这个。但是需要注意的是，当有成千上万个客户端连接上来开始进行数据发送，由于LT的特性，内核会频繁的处理通知操作，导致其相对于ET来说，比较的耗费系统资源，所以，随着客户端的增多，其性能也就越差。&lt;/p&gt;

&lt;p&gt;而边缘触发，由于监控的是FD的状态变化，所以整体的系统通知并没有那么频繁，高并发下整体的性能表现也要好很多。但是由于此模式下，用户需要积极的处理好每一笔数据，带来的维护代价也是相当大的，稍微不注意就有可能出错。所以使用起来须要非常小心才行。&lt;/p&gt;

&lt;p&gt;至于二者如何抉择，诸位就仁者见仁智者见智吧。&lt;/p&gt;

&lt;p&gt;行文到这里，关于epoll的讲解基本上完毕了，大家从中是不是学到了很多干货呢？ 由于从netty研究到linux epoll底层，其难度非常大，可以用曲高和寡来形容，所以在这块探索的文章是比较少的，很多东西需要自己照着man文档和源码一点一点的琢磨（linux源码详见eventpoll.c等）。这里我来纠正一下搜索引擎上，说epoll高性能是因为利用mmap技术实现了用户态和内核态的内存共享，所以性能好，我前期被这个观点误导了好久，后来下来了linux源码，翻了一下，并没有在epoll中翻到mmap的技术点，所以这个观点是错误的。这些错误观点的文章，国内不少，国外也不少，希望大家能审慎抉择，避免被错误带偏。&lt;/p&gt;

&lt;p&gt;所以，epoll高性能的根本就是，其高效的文件描述符处理方式加上颇具特性边的缘触发处理模式，以极少的内核态和用户态的切换，实现了真正意义上的高并发。&lt;/p&gt;
&lt;/div&gt;
  &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>bd4cf2d1fc4dc2a71985e651afe5c0fb</guid>
<title>Android开机全解析</title>
<link>https://toutiao.io/k/usk1um1</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content js_underline_content             autoTypeSetting24psection&amp;#10;            &quot; id=&quot;js_content&quot;&gt;&lt;p&gt;对于任何操作系统来讲，开机时间的优化都是一个很关键的工作。如果用户每次启动设备都需要等待很长的时间，那么其用户体验是很差的。本文从Android12出发，分以下三部分阐述Android系统的开机优化：&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;Android开机过程&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;分析开机时间&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;开机速度优化实践&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;em&gt;备注&lt;/em&gt;&lt;br/&gt;&lt;em&gt;1. 文中所有的代码都省略了无关部分，并且省略了省略号；&lt;/em&gt;&lt;br/&gt;&lt;em&gt;2. 由于作者能力有限，难免会有不正确或者不完善的地方。欢迎大家指正。&lt;/em&gt;&lt;/p&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;1. Android开机过程&lt;/span&gt;&lt;span/&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;/section&gt;&lt;p&gt;要想进行开机速度的优化，首先需要了解开机的详细流程。开机过程从CPU上电开始，到锁屏界面显示出来结束。下图为比较简洁的开机流程图。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.969551282051282&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz/yyLvy204xWibt5Ih0icthSOQgz1XcmYqIw8HK32icu8NX2gO3J211wNIBXkjm4a51W8ghDOn2EEkBypEggKehsYfw/640?wx_fmt=other&quot; data-type=&quot;other&quot; data-w=&quot;624&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;再来看一张比较详细的开机流程图&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.7559153175591532&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz/yyLvy204xWibt5Ih0icthSOQgz1XcmYqIwjbSEmibtUKianXoTA8YAVbuxdV1pBTSuicg887R3vsgOYSIF8icr0Fn2Cw/640?wx_fmt=other&quot; data-type=&quot;other&quot; data-w=&quot;803&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;总的来说，开机过程分为以下六主要子过程&lt;/p&gt;&lt;h2&gt;&lt;span&gt;&lt;strong&gt;1.1 Boot ROM&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;Boot ROM是硬编码在CPU内部固定地址的一段ROM(在一些较老的系统上也可能使用外挂Boot ROM（相对CPU来说）)，这块代码是由CPU制造商提供。当用户按下电源键或者系统重启之后，触发CPU上电动作，此时其它硬件还未初始化，然而这块ROM就已经可读了。CPU首先执行PBL(Primary Boot Loader，主引导加载程序，固化在ROM上)代码。在必要的硬件初始化之后，Boot ROM开始加载Bootloader到RAM中，然后PC指针跳过去执行bootloader。在加载 Bootloader之前，PBL也可以进行验证。如果验证无法通过，则不会加载运行Bootloader，从而开机失败。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6907378335949764&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz/yyLvy204xWibt5Ih0icthSOQgz1XcmYqIwIJ5cLmpiaVXbpkDXlXal89Y5W0p0JlYF6Y96V1tUMG0t9IsurANQDBQ/640?wx_fmt=other&quot; data-type=&quot;other&quot; data-w=&quot;637&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;A.&lt;/strong&gt;  CPU刚上电时，CPU 处于未初始化状态，还没有设定内部时钟，此时只有内部 RAM 可用。当电源稳定后会开始执行 Boot ROM 代码。Boot ROM通过系统寄存器映射到 ASIC (Application Specific Integrated Circuit, 即专用集成电路，是指应特定用户要求和特定电子系统的需要而设计、制造的集成电路)中的物理区域来找到boot media，进而可以找到Bootloader&lt;br/&gt;&lt;strong&gt;B.&lt;/strong&gt;  boot  media序列确定之后，Boot ROM 加载 Bootloader到内部 RAM 中，之后Boot ROM代码会跳到Bootloader&lt;/p&gt;&lt;h2&gt;&lt;span&gt;&lt;strong&gt;1.2Bootloader&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;Bootloader是一个特殊的独立于内核的程序，是CPU复位后进入操作系统之前执行的一段代码。Bootloader完成由硬件启动到操作系统启动的过渡，从而为操作系统提供基本的运行环境，如初始化CPU、时钟、堆栈、存储器系统等。Bootloader功能类似于PC机的BIOS程序,其代码与CPU芯片的内核结构、具体型号、应用系统的配置及使用的操作系统等因素有关，因此不可能有通用的bootloader,开发时需要用户根据具体情况进行移植。嵌入式Linux系统中常用的Bootloader有armboot、redboot、blob、U-Boot、Bios-lt、Bootldr等，其中U-Boot是当前比较流行，功能比较强大的Bootloader，可以支持多种体系结构，但相对也比较复杂。硬件初始化完成之后，Bootloader将boot.img(kernel + ramdisk(ramdisk.img中主要是存放android启动后第一个用户进程init可执行文件和init.*.rc等相关启动脚本以及sbin目录下的adbd工具))从flash上copy到RAM里面，然后CPU执行转向kernel。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6907378335949764&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz/yyLvy204xWibt5Ih0icthSOQgz1XcmYqIwic3xIicTsgrf7EUJ7sJb297icvVV56ibJ8AdFxpoOm9jeGrVw4wkDIFXhw/640?wx_fmt=other&quot; data-type=&quot;other&quot; data-w=&quot;637&quot;/&gt;&lt;/p&gt;&lt;p&gt;Android_boot_2_bootloader.png&lt;/p&gt;&lt;p&gt;&lt;strong&gt;A.&lt;/strong&gt; Bootloader第一阶段首先会检测和设置外部RAM&lt;br/&gt;&lt;strong&gt;B.&lt;/strong&gt; 外部 RAM可用之后，将Bootloader代码加载到外部RAM中&lt;br/&gt;&lt;strong&gt;C.&lt;/strong&gt; Bootloader第二阶段包含了设置文件系统，内存，网络等等。&lt;br/&gt;&lt;strong&gt;D.&lt;/strong&gt; Bootloader查找Linux内核并将其从boot media (或者其他地方，这取决于系统配置) 加载到 RAM 中，并且会配置一些内核启动时需要的启动参数&lt;br/&gt;&lt;strong&gt;E.&lt;/strong&gt;  Bootloader执行完之后会跳转到 Linux 内核执行&lt;br/&gt;一般也可将Bootloader程序的执行分为两个阶段，如下图所示&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.8162962962962963&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz/yyLvy204xWibt5Ih0icthSOQgz1XcmYqIw4LPkphCYKm4SJ8eA1JwH1icuIC3V4v8bhoiaalia3ExrCNdvnYVwpRlzg/640?wx_fmt=other&quot; data-type=&quot;other&quot; data-w=&quot;675&quot;/&gt;&lt;/p&gt;&lt;p&gt;bootloader_1.png&lt;/p&gt;&lt;p&gt;&lt;br/&gt;执行Bootloader程序过程中，如果镜像验证失败、BootLinux (&amp;amp;Info) 函数启动失败或者接收到启动至 fastboot 的命令（比如使用 adb reboot bootloader进行重启、在启动时按下了电源键+下音量键组合）时，会进入到Fastboot模式(Fastboot 是一种电脑通过USB数据线对手机固件进行刷写、擦除/格式化、调试、传输各种指令的固件通信协议, 俗称线刷模式或快速引导模式)。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;h2&gt;&lt;span&gt;&lt;strong&gt;1.3Kernel&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;Android kernel基于上游 Linux LTS (Linux Long Term Supported，长期支持) 内核。在 Google，LTS 内核会与 Android 专用补丁结合，形成所谓的“Android 通用内核 (ACK，Android Common Kernel)”。较新的 ACK（版本 5.4 及更高版本）也称为 GKI (Generic Kernel Image，通用内核镜像 )内核。GKI项目通过统一核心内核并将 SoC 和板级支持从核心内核移至可加载模块中，解决了内核碎片化问题。GKI 内核为内核模块提供了稳定的内核模块接口 (KMI)，因此模块和内核可以独立进行更新。GKI 具有以下特点：&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;基于 ACK 来源构建而成。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;是每个架构和每个 LTS 版本的单内核二进制文件以及关联的可加载模块（目前只有适用于 android11-5.4 和 android12-5.4 的 arm64）。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;已经过关联 ACK 支持的所有 Android 平台版本的测试。在 GKI 内核版本的生命周期内不会发生功能弃用。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;为给定 LTS 中的驱动程序提供了稳定版 KMI。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;不包含 SoC 专用代码或板卡专用代码。下图显示了 GKI 内核和供应商模块架构：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6145584725536993&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz/yyLvy204xWibt5Ih0icthSOQgz1XcmYqIw4Hs9AFBkwDX1YCNQsYkRFexNDKtI0nRA5Lqia8bQDqvSdA5lUjtg3XQ/640?wx_fmt=other&quot; data-type=&quot;other&quot; data-w=&quot;838&quot;/&gt;&lt;/p&gt;&lt;p&gt;generic-kernel-image-architecture.png&lt;/p&gt;&lt;p&gt;&lt;br/&gt;由于Android的kernel实际上就是Linux kernel，只是针对移动设备做了一些优化，所以与其它Linux kernel的启动方式大同小异，都是对start_kernel函数的调用和执行。Kernel主要工作内容为设置缓存、被保护存储器、计划列表，加载驱动，启动kernel守护，挂载根目录，初始化输入输出，开启中断，初始化进程表等。当内核完成这些系统设置后，接下来在系统文件中寻找”init”文件，然后启动root进程或者系统的第一个进程。&lt;/p&gt;&lt;p&gt;&lt;br/&gt;Kernel启动过程分为两个阶段：&lt;br/&gt;1）内核引导阶段。通常使用汇编语言编写，主要检查内核与当前硬件是否匹配。这部分也与硬件体系结构相关。&lt;br/&gt;2）内核启动阶段。引导阶段结束前，将调用start_kernel()进入内核启动阶段。内核启动阶段相关的代码主要位于kernel/init/main.c。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6907378335949764&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz/yyLvy204xWibt5Ih0icthSOQgz1XcmYqIwxJqHesoUpR6Ku2NOJKskFtVfGmjUrN5qVGtaFUeKuWoFgUu5pSx2XQ/640?wx_fmt=other&quot; data-type=&quot;other&quot; data-w=&quot;637&quot;/&gt;&lt;/p&gt;&lt;p&gt;Android_boot_3_kernel.png&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;strong&gt;A.&lt;/strong&gt; 内存管理单元和高速缓存初始化完成之后，系统便可以使用虚拟内存和启动用户空间进程&lt;br/&gt;&lt;strong&gt;B.&lt;/strong&gt;  内核在根目录寻找初始化程序（/system/core/init），执行该程序以启动init进程&lt;br/&gt;Kernel启动的核心函数是start_kernel函数，它完成了内核的大部分初始化工作。这个函数在最后调用了reset_init函数进行后续的初始化。reset_init函数最主要的任务就是启动内核线程kernel_init。kernel_init函数将完成设备驱动程序的初始化，并调用init_post函数启动用户空间的init进程。到init_post函数为止，内核的初始化已经基本完成。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6401028277634961&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz/yyLvy204xWibt5Ih0icthSOQgz1XcmYqIwNPoJzCv1EntC3hfUj3KcanvibzhIM1F44FlErgjTAjz7ObNesMIvkag/640?wx_fmt=other&quot; data-type=&quot;other&quot; data-w=&quot;389&quot;/&gt;&lt;/p&gt;&lt;p&gt;boot_kernel.png&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2&gt;&lt;br/&gt;&lt;/h2&gt;&lt;h2&gt;&lt;span&gt;&lt;strong&gt;1.4 init进程&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;用户空间的第一个进程便是init进程，进程号为1。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.13020833333333334&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz/yyLvy204xWibt5Ih0icthSOQgz1XcmYqIw64GeJLy3WMWpeQhMxrdFhPTicMmD5ibHeU2JKUcMF5DgSwzibLkURo2Mw/640?wx_fmt=other&quot; data-type=&quot;other&quot; data-w=&quot;768&quot;/&gt;&lt;/p&gt;&lt;p&gt;init_process.png&lt;/p&gt;&lt;p&gt;当系统启动完成之后，init进程会作为守护进程监视其它进程。在Linux中所有的进程都是由init进程直接或间接fork出来的。在init进程启动的过程中，会相继启动servicemanager(binder服务管理者)、Zygote进程。而Zygote又会创建system_server进程以及app进程。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.6312769010043041&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz/yyLvy204xWibt5Ih0icthSOQgz1XcmYqIwdWVpYEk6afuibynLVXTq62DjHrbwub51mzKyO2OAPONWxsYGaEdJ9gw/640?wx_fmt=other&quot; data-type=&quot;other&quot; data-w=&quot;697&quot;/&gt;&lt;/p&gt;&lt;p&gt;Android_boot_4_init.png&lt;/p&gt;&lt;p&gt;&lt;br/&gt;对于init进程的功能分为4部分：&lt;/p&gt;&lt;p&gt;&lt;em aria-label=&quot;icon: copy&quot;&gt;&lt;svg viewbox=&quot;64 64 896 896&quot; focusable=&quot;false&quot; data-icon=&quot;copy&quot; fill=&quot;currentColor&quot; aria-hidden=&quot;true&quot;&gt;&lt;path d=&quot;M832 64H296c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8h496v688c0 4.4 3.6 8 8 8h56c4.4 0 8-3.6 8-8V96c0-17.7-14.3-32-32-32zM704 192H192c-17.7 0-32 14.3-32 32v530.7c0 8.5 3.4 16.6 9.4 22.6l173.3 173.3c2.2 2.2 4.7 4 7.4 5.5v1.9h4.2c3.5 1.3 7.2 2 11 2H704c17.7 0 32-14.3 32-32V224c0-17.7-14.3-32-32-32zM350 856.2L263.9 770H350v86.2zM664 888H414V746c0-22.1-17.9-40-40-40H232V264h432v624z&quot;/&gt;&lt;/svg&gt;&lt;/em&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;swift&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;system/core/&lt;span class=&quot;code-snippet__keyword&quot;&gt;init&lt;/span&gt;/&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  -main.cpp&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  -&lt;span class=&quot;code-snippet__keyword&quot;&gt;init&lt;/span&gt;.cpp&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  -parser.cpp&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;/system/core/rootdir/&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  -&lt;span class=&quot;code-snippet__keyword&quot;&gt;init&lt;/span&gt;.rc&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;pre&gt;&lt;code&gt;&lt;span aria-hidden=&quot;true&quot;/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;init进程的入口为main.cpp类的main方法。&lt;/p&gt;&lt;p&gt;&lt;em aria-label=&quot;icon: copy&quot;&gt;&lt;svg viewbox=&quot;64 64 896 896&quot; focusable=&quot;false&quot; data-icon=&quot;copy&quot; fill=&quot;currentColor&quot; aria-hidden=&quot;true&quot;&gt;&lt;path d=&quot;M832 64H296c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8h496v688c0 4.4 3.6 8 8 8h56c4.4 0 8-3.6 8-8V96c0-17.7-14.3-32-32-32zM704 192H192c-17.7 0-32 14.3-32 32v530.7c0 8.5 3.4 16.6 9.4 22.6l173.3 173.3c2.2 2.2 4.7 4 7.4 5.5v1.9h4.2c3.5 1.3 7.2 2 11 2H704c17.7 0 32-14.3 32-32V224c0-17.7-14.3-32-32-32zM350 856.2L263.9 770H350v86.2zM664 888H414V746c0-22.1-17.9-40-40-40H232V264h432v624z&quot;/&gt;&lt;/svg&gt;&lt;/em&gt;&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;cpp&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;code-snippet__params&quot;&gt;(&lt;span class=&quot;code-snippet__keyword&quot;&gt;int&lt;/span&gt; argc, &lt;span class=&quot;code-snippet__keyword&quot;&gt;char&lt;/span&gt;** argv)&lt;/span&gt; &lt;/span&gt;{&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__meta&quot;&gt;#&lt;span class=&quot;code-snippet__meta-keyword&quot;&gt;if&lt;/span&gt; __has_feature(address_sanitizer)&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;     __asan_set_error_report_callback(AsanReportCallback);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__meta&quot;&gt;#&lt;span class=&quot;code-snippet__meta-keyword&quot;&gt;endif&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;if&lt;/span&gt;(!&lt;span class=&quot;code-snippet__built_in&quot;&gt;strcmp&lt;/span&gt;(basename(argv[&lt;span class=&quot;code-snippet__number&quot;&gt;0&lt;/span&gt;]), &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;ueventd&quot;&lt;/span&gt;)) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__keyword&quot;&gt;return&lt;/span&gt; ueventd_main(argc, argv);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;if&lt;/span&gt;(argc &amp;gt; &lt;span class=&quot;code-snippet__number&quot;&gt;1&lt;/span&gt;){&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__keyword&quot;&gt;if&lt;/span&gt;(!&lt;span class=&quot;code-snippet__built_in&quot;&gt;strcmp&lt;/span&gt;(argv[&lt;span class=&quot;code-snippet__number&quot;&gt;1&lt;/span&gt;], &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;subcontext&quot;&lt;/span&gt;)){&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            android::base::InitLogging(argv, &amp;amp;android::base::KernelLogger);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            &lt;span class=&quot;code-snippet__keyword&quot;&gt;const&lt;/span&gt; BuiltinFunctionMap function_map;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            &lt;span class=&quot;code-snippet__keyword&quot;&gt;return&lt;/span&gt; SubcontextMain(argc, argv, &amp;amp;function_map);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__keyword&quot;&gt;if&lt;/span&gt;(!&lt;span class=&quot;code-snippet__built_in&quot;&gt;strcmp&lt;/span&gt;(argv[&lt;span class=&quot;code-snippet__number&quot;&gt;1&lt;/span&gt;], &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;selinux_setup&quot;&lt;/span&gt;)){&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            &lt;span class=&quot;code-snippet__keyword&quot;&gt;return&lt;/span&gt; SetupSelinux(argv);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__keyword&quot;&gt;if&lt;/span&gt; (!&lt;span class=&quot;code-snippet__built_in&quot;&gt;strcmp&lt;/span&gt;(argv[&lt;span class=&quot;code-snippet__number&quot;&gt;1&lt;/span&gt;], &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;second_stage&quot;&lt;/span&gt;)){&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            &lt;span class=&quot;code-snippet__keyword&quot;&gt;return&lt;/span&gt; SecondStageMain(argc, argv);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;return&lt;/span&gt; FirstStageMain(argc, argv);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;pre&gt;&lt;code&gt;&lt;span/&gt;&lt;br/&gt;&lt;span aria-hidden=&quot;true&quot;/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;主要执行了三步&lt;/p&gt;&lt;p&gt;&lt;em aria-label=&quot;icon: copy&quot;&gt;&lt;svg viewbox=&quot;64 64 896 896&quot; focusable=&quot;false&quot; data-icon=&quot;copy&quot; fill=&quot;currentColor&quot; aria-hidden=&quot;true&quot;&gt;&lt;path d=&quot;M832 64H296c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8h496v688c0 4.4 3.6 8 8 8h56c4.4 0 8-3.6 8-8V96c0-17.7-14.3-32-32-32zM704 192H192c-17.7 0-32 14.3-32 32v530.7c0 8.5 3.4 16.6 9.4 22.6l173.3 173.3c2.2 2.2 4.7 4 7.4 5.5v1.9h4.2c3.5 1.3 7.2 2 11 2H704c17.7 0 32-14.3 32-32V224c0-17.7-14.3-32-32-32zM350 856.2L263.9 770H350v86.2zM664 888H414V746c0-22.1-17.9-40-40-40H232V264h432v624z&quot;/&gt;&lt;/svg&gt;&lt;/em&gt;&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;cpp&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;FirstStageMain&lt;/span&gt;&lt;span class=&quot;code-snippet__params&quot;&gt;(&lt;span class=&quot;code-snippet__keyword&quot;&gt;int&lt;/span&gt; argc, &lt;span class=&quot;code-snippet__keyword&quot;&gt;char&lt;/span&gt;** argv)&lt;/span&gt;&lt;/span&gt;{&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;if&lt;/span&gt;(REBOOT_BOOTLOADER_ON_PANIC){&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        InstallRebootSignalHandlers();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    boot_clock::time_point start_time = boot_clock::now();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__built_in&quot;&gt;std&lt;/span&gt;::&lt;span class=&quot;code-snippet__built_in&quot;&gt;vector&lt;/span&gt;&amp;lt;&lt;span class=&quot;code-snippet__built_in&quot;&gt;std&lt;/span&gt;::pair&amp;lt;&lt;span class=&quot;code-snippet__built_in&quot;&gt;std&lt;/span&gt;::&lt;span class=&quot;code-snippet__built_in&quot;&gt;string&lt;/span&gt;, &lt;span class=&quot;code-snippet__keyword&quot;&gt;int&lt;/span&gt;&amp;gt;&amp;gt; errors;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__meta&quot;&gt;#&lt;span class=&quot;code-snippet__meta-keyword&quot;&gt;define&lt;/span&gt; CHECKCALL(x) \&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__meta-keyword&quot;&gt;if&lt;/span&gt; (x != 0) errors.emplace_back(#x &lt;span class=&quot;code-snippet__meta-string&quot;&gt;&quot; failed&quot;&lt;/span&gt;, errno);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    umask(&lt;span class=&quot;code-snippet__number&quot;&gt;0&lt;/span&gt;);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    CHECKCALL(clearenv());&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    CHECKCALL(setenv(&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;PATH&quot;&lt;/span&gt;, _PATH_DEFPATH, &lt;span class=&quot;code-snippet__number&quot;&gt;1&lt;/span&gt;));&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    CHECKCALL(mount(&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;tmpfs&quot;&lt;/span&gt;, &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;/dev&quot;&lt;/span&gt;, &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;tmpfs&quot;&lt;/span&gt;, MS_NOSUID, &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;mode=0755&quot;&lt;/span&gt;));&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    CHECKCALL(mkdir(&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;/dev/pts&quot;&lt;/span&gt;, &lt;span class=&quot;code-snippet__number&quot;&gt;0755&lt;/span&gt;));&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    CHECKCALL(mkdir(&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;/dev/socket&quot;&lt;/span&gt;, &lt;span class=&quot;code-snippet__number&quot;&gt;0755&lt;/span&gt;));&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    CHECKCALL(mount(&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;devpts&quot;&lt;/span&gt;, &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;/dev/pts&quot;&lt;/span&gt;, &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;devpts&quot;&lt;/span&gt;, &lt;span class=&quot;code-snippet__number&quot;&gt;0&lt;/span&gt;, &lt;span class=&quot;code-snippet__literal&quot;&gt;NULL&lt;/span&gt;));&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__meta&quot;&gt;#&lt;span class=&quot;code-snippet__meta-keyword&quot;&gt;define&lt;/span&gt; MAKE_STR(x) __STRING(x)&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    CHECKCALL(mount(&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;proc&quot;&lt;/span&gt;, &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;/proc&quot;&lt;/span&gt;, &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;proc&quot;&lt;/span&gt;, &lt;span class=&quot;code-snippet__number&quot;&gt;0&lt;/span&gt;, &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;hidepid=2,gid=&quot;&lt;/span&gt; MAKE_STR(AID_READPROC)));&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__meta&quot;&gt;#&lt;span class=&quot;code-snippet__meta-keyword&quot;&gt;undef&lt;/span&gt; MAKE_STR&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    CHECKCALL(chmod(&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;/proc/cmdline&quot;&lt;/span&gt;, &lt;span class=&quot;code-snippet__number&quot;&gt;0440&lt;/span&gt;));&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;gid_t&lt;/span&gt; groups[] = {AID_READPROC};&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    CHECKCALL(setgroups(arraysize(groups), groups));&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    CHECKCALL(mount(&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;sysfs&quot;&lt;/span&gt;, &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;/sys&quot;&lt;/span&gt;, &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;sysfs&quot;&lt;/span&gt;, &lt;span class=&quot;code-snippet__number&quot;&gt;0&lt;/span&gt;, &lt;span class=&quot;code-snippet__literal&quot;&gt;NULL&lt;/span&gt;));&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    CHECKCALL(mount(&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;selinuxfs&quot;&lt;/span&gt;, &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;/sys/fs/selinux&quot;&lt;/span&gt;, &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;selinuxfs&quot;&lt;/span&gt;, &lt;span class=&quot;code-snippet__number&quot;&gt;0&lt;/span&gt;, &lt;span class=&quot;code-snippet__literal&quot;&gt;NULL&lt;/span&gt;));&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    InitKernelLogging(argv);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;char&lt;/span&gt;* path = &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;/system/bin/init&quot;&lt;/span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;char&lt;/span&gt;* args[] = {path, &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;selinux_setup&quot;&lt;/span&gt;, &lt;span class=&quot;code-snippet__literal&quot;&gt;nullptr&lt;/span&gt;};&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    execv(path, &lt;span class=&quot;code-snippet__keyword&quot;&gt;const_cast&lt;/span&gt;&amp;lt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;char&lt;/span&gt;**&amp;gt;(args));&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt; &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    PLOG(FATAL) &amp;lt;&amp;lt; &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;execv(\&quot;&quot;&lt;/span&gt; &amp;lt;&amp;lt; path &amp;lt;&amp;lt; &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;\&quot;) failed&quot;&lt;/span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt; &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;code-snippet__number&quot;&gt;1&lt;/span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;pre&gt;&lt;code&gt;&lt;span/&gt;&lt;br/&gt;&lt;span aria-hidden=&quot;true&quot;/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;主要通过mount挂载对应的文件系统，mkdir创建对应的文件目录，并配置相应的访问权限。&lt;br/&gt;需要注意的是，这些文件只是在应用运行的时候存在，一旦应用运行结束就会随着应用一起消失。&lt;br/&gt;挂载的&lt;strong&gt;文件系统&lt;/strong&gt;主要有四类：&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;tmpfs: 一种虚拟内存文件系统，它会将所有的文件存储在虚拟内存中。由于tmpfs是驻留在RAM的，因此它的内容是不持久的。断电后，tmpfs 的内容就消失了，这也是被称作tmpfs的根本原因。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;devpts: 为伪终端提供了一个标准接口，它的标准挂接点是/dev/pts。只要pty(pseudo-tty, 虚拟终端)的主复合设备/dev/ptmx被打开，就会在/dev/pts下动态的创建一个新的pty设备文件。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;proc: 也是一个虚拟文件系统，它可以看作是内核内部数据结构的接口，通过它我们可以获得系统的信息，同时也能够在运行时修改特定的内核参数。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;sysfs: 与proc文件系统类似，也是一个不占有任何磁盘空间的虚拟文件系统。它通常被挂接在/sys目录下。&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;在FirstStageMain还会通过InitKernelLogging(argv)来初始化log日志系统。此时Android还没有自己的系统日志，采用kernel的log系统，打开的设备节点/dev/kmsg， 那么可通过cat /dev/kmsg来获取内核log。&lt;/p&gt;&lt;p&gt;最后会通过execv方法传递对应的path与下一阶段的参数selinux_setup。&lt;br/&gt;&lt;strong&gt;SetupSelinux&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;em aria-label=&quot;icon: copy&quot;&gt;&lt;svg viewbox=&quot;64 64 896 896&quot; focusable=&quot;false&quot; data-icon=&quot;copy&quot; fill=&quot;currentColor&quot; aria-hidden=&quot;true&quot;&gt;&lt;path d=&quot;M832 64H296c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8h496v688c0 4.4 3.6 8 8 8h56c4.4 0 8-3.6 8-8V96c0-17.7-14.3-32-32-32zM704 192H192c-17.7 0-32 14.3-32 32v530.7c0 8.5 3.4 16.6 9.4 22.6l173.3 173.3c2.2 2.2 4.7 4 7.4 5.5v1.9h4.2c3.5 1.3 7.2 2 11 2H704c17.7 0 32-14.3 32-32V224c0-17.7-14.3-32-32-32zM350 856.2L263.9 770H350v86.2zM664 888H414V746c0-22.1-17.9-40-40-40H232V264h432v624z&quot;/&gt;&lt;/svg&gt;&lt;/em&gt;&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;cpp&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;SetupSelinux&lt;/span&gt;&lt;span class=&quot;code-snippet__params&quot;&gt;(&lt;span class=&quot;code-snippet__keyword&quot;&gt;char&lt;/span&gt;** argv)&lt;/span&gt; &lt;/span&gt;{&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;     &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    InitKernelLogging(argv);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;if&lt;/span&gt; (REBOOT_BOOTLOADER_ON_PANIC) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        InstallRebootSignalHandlers();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;     &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    SelinuxSetupKernelLogging();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    SelinuxInitialize();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;if&lt;/span&gt; (selinux_android_restorecon(&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;/system/bin/init&quot;&lt;/span&gt;, &lt;span class=&quot;code-snippet__number&quot;&gt;0&lt;/span&gt;) == &lt;span class=&quot;code-snippet__number&quot;&gt;-1&lt;/span&gt;) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        PLOG(FATAL) &amp;lt;&amp;lt; &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;restorecon failed of /system/bin/init failed&quot;&lt;/span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;char&lt;/span&gt;* path = &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;/system/bin/init&quot;&lt;/span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;char&lt;/span&gt;* args[] = {path, &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;second_stage&quot;&lt;/span&gt;, &lt;span class=&quot;code-snippet__literal&quot;&gt;nullptr&lt;/span&gt;};&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    execv(path, &lt;span class=&quot;code-snippet__keyword&quot;&gt;const_cast&lt;/span&gt;&amp;lt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;char&lt;/span&gt;**&amp;gt;(args));&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    PLOG(FATAL) &amp;lt;&amp;lt; &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;execv(\&quot;&quot;&lt;/span&gt; &amp;lt;&amp;lt; path &amp;lt;&amp;lt; &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;\&quot;) failed&quot;&lt;/span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;code-snippet__number&quot;&gt;1&lt;/span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;pre&gt;&lt;code&gt;&lt;span/&gt;&lt;br/&gt;&lt;span aria-hidden=&quot;true&quot;/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这阶段主要是初始化 SELinux。SELinux 是安全加强型 Linux，能够很好的对全部进程强制执行访问控制，从而让 Android 更好的保护和限制系统服务、控制对应用数据和系统日志的访问，提高系统安全性。&lt;br/&gt;接下来调用execv进入到最后阶段SecondStageMain。&lt;br/&gt;&lt;strong&gt;SecondStageMain&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;em aria-label=&quot;icon: copy&quot;&gt;&lt;svg viewbox=&quot;64 64 896 896&quot; focusable=&quot;false&quot; data-icon=&quot;copy&quot; fill=&quot;currentColor&quot; aria-hidden=&quot;true&quot;&gt;&lt;path d=&quot;M832 64H296c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8h496v688c0 4.4 3.6 8 8 8h56c4.4 0 8-3.6 8-8V96c0-17.7-14.3-32-32-32zM704 192H192c-17.7 0-32 14.3-32 32v530.7c0 8.5 3.4 16.6 9.4 22.6l173.3 173.3c2.2 2.2 4.7 4 7.4 5.5v1.9h4.2c3.5 1.3 7.2 2 11 2H704c17.7 0 32-14.3 32-32V224c0-17.7-14.3-32-32-32zM350 856.2L263.9 770H350v86.2zM664 888H414V746c0-22.1-17.9-40-40-40H232V264h432v624z&quot;/&gt;&lt;/svg&gt;&lt;/em&gt;&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;cpp&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;SecondStageMain&lt;/span&gt;&lt;span class=&quot;code-snippet__params&quot;&gt;(&lt;span class=&quot;code-snippet__keyword&quot;&gt;int&lt;/span&gt; argc, &lt;span class=&quot;code-snippet__keyword&quot;&gt;char&lt;/span&gt;** argv)&lt;/span&gt; &lt;/span&gt;{&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    SetStdioToDevNull(argv);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    InitKernelLogging(argv);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    property_init();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    Epoll epoll;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    InstallSignalFdHandler(&amp;amp;epoll);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    property_load_boot_defaults(load_debug_prop);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    StartPropertyService(&amp;amp;epoll);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;       subcontexts = InitializeSubcontexts();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;       ActionManager&amp;amp; am = ActionManager::GetInstance();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    ServiceList&amp;amp; sm = ServiceList::GetInstance();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    LoadBootScripts(am, sm);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;       &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    am.QueueEventTrigger(&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;early-init&quot;&lt;/span&gt;);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    am.QueueEventTrigger(&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;init&quot;&lt;/span&gt;);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    am.QueueBuiltinAction(InitBinder, &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;InitBinder&quot;&lt;/span&gt;);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    am.QueueEventTrigger(&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;late-init&quot;&lt;/span&gt;);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;while&lt;/span&gt; (&lt;span class=&quot;code-snippet__literal&quot;&gt;true&lt;/span&gt;) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        am.ExecuteOneCommand();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__keyword&quot;&gt;auto&lt;/span&gt; next_process_action_time = HandleProcessActions();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;pre&gt;&lt;code&gt;&lt;span/&gt;&lt;br/&gt;&lt;span aria-hidden=&quot;true&quot;/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;SecondStageMain的主要工作总结&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;使用epoll对init子进程的信号进行监听&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;初始化系统属性，使用mmap共享内存&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;开启属性服务，并注册到epoll中&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;加载系统启动脚本&quot;init.rc&quot;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;解析启动脚本，启动相关服务&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;重点介绍下init.rc文件的解析&lt;/p&gt;&lt;p&gt;&lt;em aria-label=&quot;icon: copy&quot;&gt;&lt;svg viewbox=&quot;64 64 896 896&quot; focusable=&quot;false&quot; data-icon=&quot;copy&quot; fill=&quot;currentColor&quot; aria-hidden=&quot;true&quot;&gt;&lt;path d=&quot;M832 64H296c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8h496v688c0 4.4 3.6 8 8 8h56c4.4 0 8-3.6 8-8V96c0-17.7-14.3-32-32-32zM704 192H192c-17.7 0-32 14.3-32 32v530.7c0 8.5 3.4 16.6 9.4 22.6l173.3 173.3c2.2 2.2 4.7 4 7.4 5.5v1.9h4.2c3.5 1.3 7.2 2 11 2H704c17.7 0 32-14.3 32-32V224c0-17.7-14.3-32-32-32zM350 856.2L263.9 770H350v86.2zM664 888H414V746c0-22.1-17.9-40-40-40H232V264h432v624z&quot;/&gt;&lt;/svg&gt;&lt;/em&gt;&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;cpp&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;LoadBootScripts&lt;/span&gt;&lt;span class=&quot;code-snippet__params&quot;&gt;(ActionManager&amp;amp; action_manager, ServiceList&amp;amp; service_list)&lt;/span&gt; &lt;/span&gt;{&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    Parser parser = CreateParser(action_manager, service_list);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__built_in&quot;&gt;std&lt;/span&gt;::&lt;span class=&quot;code-snippet__built_in&quot;&gt;string&lt;/span&gt; bootscript = GetProperty(&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;ro.boot.init_rc&quot;&lt;/span&gt;, &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;&quot;&lt;/span&gt;);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;if&lt;/span&gt; (bootscript.empty()) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        parser.ParseConfig(&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;/init.rc&quot;&lt;/span&gt;);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__keyword&quot;&gt;if&lt;/span&gt; (!parser.ParseConfig(&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;/system/etc/init&quot;&lt;/span&gt;)) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            late_import_paths.emplace_back(&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;/system/etc/init&quot;&lt;/span&gt;);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__keyword&quot;&gt;if&lt;/span&gt; (!parser.ParseConfig(&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;/product/etc/init&quot;&lt;/span&gt;)) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            late_import_paths.emplace_back(&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;/product/etc/init&quot;&lt;/span&gt;);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__keyword&quot;&gt;if&lt;/span&gt; (!parser.ParseConfig(&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;/product_services/etc/init&quot;&lt;/span&gt;)) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            late_import_paths.emplace_back(&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;/product_services/etc/init&quot;&lt;/span&gt;);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__keyword&quot;&gt;if&lt;/span&gt; (!parser.ParseConfig(&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;/odm/etc/init&quot;&lt;/span&gt;)) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            late_import_paths.emplace_back(&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;/odm/etc/init&quot;&lt;/span&gt;);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__keyword&quot;&gt;if&lt;/span&gt; (!parser.ParseConfig(&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;/vendor/etc/init&quot;&lt;/span&gt;)) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            late_import_paths.emplace_back(&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;/vendor/etc/init&quot;&lt;/span&gt;);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    } &lt;span class=&quot;code-snippet__keyword&quot;&gt;else&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        parser.ParseConfig(bootscript);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;pre&gt;&lt;code&gt;&lt;span/&gt;&lt;br/&gt;&lt;span aria-hidden=&quot;true&quot;/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;通过ParseConfig来解析init.rc配置文件。.rc文件以行为单位，以空格为间隔，以#开始代表注释行。.rc文件主要包含Action、Service、Command、Options、Import，其中对于Action和Service的名称都是唯一的，对于重复的命名视为无效。init.rc中的Action、Service语句都有相应的类来解析，即ActionParser、ServiceParser。以下为init.rc配置文件的部分内容。&lt;/p&gt;&lt;p&gt;&lt;em aria-label=&quot;icon: copy&quot;&gt;&lt;svg viewbox=&quot;64 64 896 896&quot; focusable=&quot;false&quot; data-icon=&quot;copy&quot; fill=&quot;currentColor&quot; aria-hidden=&quot;true&quot;&gt;&lt;path d=&quot;M832 64H296c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8h496v688c0 4.4 3.6 8 8 8h56c4.4 0 8-3.6 8-8V96c0-17.7-14.3-32-32-32zM704 192H192c-17.7 0-32 14.3-32 32v530.7c0 8.5 3.4 16.6 9.4 22.6l173.3 173.3c2.2 2.2 4.7 4 7.4 5.5v1.9h4.2c3.5 1.3 7.2 2 11 2H704c17.7 0 32-14.3 32-32V224c0-17.7-14.3-32-32-32zM350 856.2L263.9 770H350v86.2zM664 888H414V746c0-22.1-17.9-40-40-40H232V264h432v624z&quot;/&gt;&lt;/svg&gt;&lt;/em&gt;&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;properties&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__meta&quot;&gt;//&lt;/span&gt; &lt;span class=&quot;code-snippet__string&quot;&gt;system/core/rootdir/init.rc&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__attr&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;code-snippet__string&quot;&gt;/init.environ.rc&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__attr&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;code-snippet__string&quot;&gt;/init.usb.rc&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__attr&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;code-snippet__string&quot;&gt;/init.${ro.hardware}.rc&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__attr&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;code-snippet__string&quot;&gt;/init.${ro.zygote}.rc&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__attr&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;code-snippet__string&quot;&gt;/init.trace.rc&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__attr&quot;&gt;on&lt;/span&gt; &lt;span class=&quot;code-snippet__string&quot;&gt;early-init&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__attr&quot;&gt;start&lt;/span&gt; &lt;span class=&quot;code-snippet__string&quot;&gt;ueventd&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__attr&quot;&gt;mkdir&lt;/span&gt; &lt;span class=&quot;code-snippet__string&quot;&gt;/mnt 0775 root system&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__attr&quot;&gt;on&lt;/span&gt; &lt;span class=&quot;code-snippet__string&quot;&gt;init&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__attr&quot;&gt;mount&lt;/span&gt; &lt;span class=&quot;code-snippet__string&quot;&gt;tmpfs none /sys/fs/cgroup mode=0750,uid=0,gid=1000&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__attr&quot;&gt;mkdir&lt;/span&gt; &lt;span class=&quot;code-snippet__string&quot;&gt;/sys/fs/cgroup/memory 0750 root system&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__attr&quot;&gt;mount&lt;/span&gt; &lt;span class=&quot;code-snippet__string&quot;&gt;cgroup none /sys/fs/cgroup/memory memory&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__attr&quot;&gt;on&lt;/span&gt; &lt;span class=&quot;code-snippet__string&quot;&gt;property:sys.boot_from_charger_mode=1&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__attr&quot;&gt;class_stop&lt;/span&gt; &lt;span class=&quot;code-snippet__string&quot;&gt;charger&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__attr&quot;&gt;trigger&lt;/span&gt; &lt;span class=&quot;code-snippet__string&quot;&gt;late-init&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__attr&quot;&gt;service&lt;/span&gt; &lt;span class=&quot;code-snippet__string&quot;&gt;ueventd /sbin/ueventd&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__attr&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;code-snippet__string&quot;&gt;core&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__attr&quot;&gt;critical&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__attr&quot;&gt;seclabel&lt;/span&gt; &lt;span class=&quot;code-snippet__string&quot;&gt;u:r:ueventd:s0&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__attr&quot;&gt;service&lt;/span&gt; &lt;span class=&quot;code-snippet__string&quot;&gt;logd /system/bin/logd&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__attr&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;code-snippet__string&quot;&gt;core&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__attr&quot;&gt;socket&lt;/span&gt; &lt;span class=&quot;code-snippet__string&quot;&gt;logd stream 0666 logd logd&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__attr&quot;&gt;socket&lt;/span&gt; &lt;span class=&quot;code-snippet__string&quot;&gt;logdr seqpacket 0666 logd logd&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__attr&quot;&gt;socket&lt;/span&gt; &lt;span class=&quot;code-snippet__string&quot;&gt;logdw dgram 0222 logd logd&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__attr&quot;&gt;seclabel&lt;/span&gt; &lt;span class=&quot;code-snippet__string&quot;&gt;u:r:logd:s0&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__attr&quot;&gt;service&lt;/span&gt; &lt;span class=&quot;code-snippet__string&quot;&gt;console /system/bin/sh&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__attr&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;code-snippet__string&quot;&gt;core&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__attr&quot;&gt;console&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__attr&quot;&gt;disabled&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__attr&quot;&gt;user&lt;/span&gt; &lt;span class=&quot;code-snippet__string&quot;&gt;shell&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__attr&quot;&gt;seclabel&lt;/span&gt; &lt;span class=&quot;code-snippet__string&quot;&gt;u:r:shell:s0&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__attr&quot;&gt;service&lt;/span&gt; &lt;span class=&quot;code-snippet__string&quot;&gt;adbd /sbin/adbd --root_seclabel=u:r:su:s0&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__attr&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;code-snippet__string&quot;&gt;core&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__attr&quot;&gt;socket&lt;/span&gt; &lt;span class=&quot;code-snippet__string&quot;&gt;adbd stream 660 system system&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__attr&quot;&gt;disabled&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__attr&quot;&gt;seclabel&lt;/span&gt; &lt;span class=&quot;code-snippet__string&quot;&gt;u:r:adbd:s0&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__attr&quot;&gt;service&lt;/span&gt; &lt;span class=&quot;code-snippet__string&quot;&gt;servicemanager /system/bin/servicemanager&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__attr&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;code-snippet__string&quot;&gt;core&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__attr&quot;&gt;user&lt;/span&gt; &lt;span class=&quot;code-snippet__string&quot;&gt;system&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__attr&quot;&gt;group&lt;/span&gt; &lt;span class=&quot;code-snippet__string&quot;&gt;system&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__attr&quot;&gt;critical&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__attr&quot;&gt;onrestart&lt;/span&gt; &lt;span class=&quot;code-snippet__string&quot;&gt;restart healthd&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__attr&quot;&gt;onrestart&lt;/span&gt; &lt;span class=&quot;code-snippet__string&quot;&gt;restart zygote&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__attr&quot;&gt;onrestart&lt;/span&gt; &lt;span class=&quot;code-snippet__string&quot;&gt;restart media&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__attr&quot;&gt;onrestart&lt;/span&gt; &lt;span class=&quot;code-snippet__string&quot;&gt;restart surfaceflinger&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__attr&quot;&gt;onrestart&lt;/span&gt; &lt;span class=&quot;code-snippet__string&quot;&gt;restart drm&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__attr&quot;&gt;on&lt;/span&gt; &lt;span class=&quot;code-snippet__string&quot;&gt;late-init&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;     &lt;span class=&quot;code-snippet__attr&quot;&gt;trigger&lt;/span&gt; &lt;span class=&quot;code-snippet__string&quot;&gt;early-fs&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__attr&quot;&gt;trigger&lt;/span&gt; &lt;span class=&quot;code-snippet__string&quot;&gt;fs&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__attr&quot;&gt;trigger&lt;/span&gt; &lt;span class=&quot;code-snippet__string&quot;&gt;post-fs&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__attr&quot;&gt;trigger&lt;/span&gt; &lt;span class=&quot;code-snippet__string&quot;&gt;late-fs&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__attr&quot;&gt;trigger&lt;/span&gt; &lt;span class=&quot;code-snippet__string&quot;&gt;post-fs-data&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__attr&quot;&gt;trigger&lt;/span&gt; &lt;span class=&quot;code-snippet__string&quot;&gt;load_persist_props_action&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__meta&quot;&gt;//&lt;/span&gt; &lt;span class=&quot;code-snippet__string&quot;&gt;这里启动zygote-start&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__attr&quot;&gt;trigger&lt;/span&gt; &lt;span class=&quot;code-snippet__string&quot;&gt;zygote-start&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__attr&quot;&gt;trigger&lt;/span&gt; &lt;span class=&quot;code-snippet__string&quot;&gt;firmware_mounts_complete&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__attr&quot;&gt;trigger&lt;/span&gt; &lt;span class=&quot;code-snippet__string&quot;&gt;early-boot&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__attr&quot;&gt;trigger&lt;/span&gt; &lt;span class=&quot;code-snippet__string&quot;&gt;boot&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;pre&gt;&lt;code&gt;&lt;span aria-hidden=&quot;true&quot;/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;可以看到，在解析init.rc的配置中，在late-init阶段启动了Zygote进程。&lt;/p&gt;&lt;h2&gt;&lt;span&gt;&lt;strong&gt;1.5 Zygote&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6312769010043041&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz/yyLvy204xWibt5Ih0icthSOQgz1XcmYqIwicvtEjUtcyCDUKTqF9EIicBqOmCwKqDiaQLnLMZWTVvSyGKmFLug72PVQ/640?wx_fmt=other&quot; data-type=&quot;other&quot; data-w=&quot;697&quot;/&gt;&lt;/p&gt;&lt;p&gt;Android_boot_5_zygote.png&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;Zygote进程是Android中所有Java进程的父进程。Zygote进程在Init进程启动过程中被以service服务的形式启动。Zygote进程相关的.rc配置文件为init.zygote64.rc或者init.zygote32.rc。以init.zygote64.rc为例，其内容如下&lt;/p&gt;&lt;p&gt;&lt;em aria-label=&quot;icon: copy&quot;&gt;&lt;svg viewbox=&quot;64 64 896 896&quot; focusable=&quot;false&quot; data-icon=&quot;copy&quot; fill=&quot;currentColor&quot; aria-hidden=&quot;true&quot;&gt;&lt;path d=&quot;M832 64H296c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8h496v688c0 4.4 3.6 8 8 8h56c4.4 0 8-3.6 8-8V96c0-17.7-14.3-32-32-32zM704 192H192c-17.7 0-32 14.3-32 32v530.7c0 8.5 3.4 16.6 9.4 22.6l173.3 173.3c2.2 2.2 4.7 4 7.4 5.5v1.9h4.2c3.5 1.3 7.2 2 11 2H704c17.7 0 32-14.3 32-32V224c0-17.7-14.3-32-32-32zM350 856.2L263.9 770H350v86.2zM664 888H414V746c0-22.1-17.9-40-40-40H232V264h432v624z&quot;/&gt;&lt;/svg&gt;&lt;/em&gt;&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;properties&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__meta&quot;&gt;//&lt;/span&gt; &lt;span class=&quot;code-snippet__string&quot;&gt;system/core/rootdir/init.zygote64.rc&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__attr&quot;&gt;service&lt;/span&gt; &lt;span class=&quot;code-snippet__string&quot;&gt;zygote /system/bin/app_process64 -Xzygote /system/bin --zygote --start-system-server&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt; &lt;span class=&quot;code-snippet__attr&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;code-snippet__string&quot;&gt;main&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;   &lt;span class=&quot;code-snippet__attr&quot;&gt;priority&lt;/span&gt; &lt;span class=&quot;code-snippet__string&quot;&gt;-20&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;   &lt;span class=&quot;code-snippet__attr&quot;&gt;user&lt;/span&gt; &lt;span class=&quot;code-snippet__string&quot;&gt;root&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;   &lt;span class=&quot;code-snippet__attr&quot;&gt;group&lt;/span&gt; &lt;span class=&quot;code-snippet__string&quot;&gt;root readproc reserved_disk&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;   &lt;span class=&quot;code-snippet__attr&quot;&gt;socket&lt;/span&gt; &lt;span class=&quot;code-snippet__string&quot;&gt;zygote stream 660 root system&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;   &lt;span class=&quot;code-snippet__attr&quot;&gt;socket&lt;/span&gt; &lt;span class=&quot;code-snippet__string&quot;&gt;usap_pool_primary stream 660 root system&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;   &lt;span class=&quot;code-snippet__attr&quot;&gt;onrestart&lt;/span&gt; &lt;span class=&quot;code-snippet__string&quot;&gt;exec_background - system system -- /ssystem/bin/vdc volume abort_fuse&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;   &lt;span class=&quot;code-snippet__attr&quot;&gt;onrestart&lt;/span&gt; &lt;span class=&quot;code-snippet__string&quot;&gt;write /sys/power/state on&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;   &lt;span class=&quot;code-snippet__attr&quot;&gt;onrestart&lt;/span&gt; &lt;span class=&quot;code-snippet__string&quot;&gt;restart audioserver&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;   &lt;span class=&quot;code-snippet__attr&quot;&gt;onrestart&lt;/span&gt; &lt;span class=&quot;code-snippet__string&quot;&gt;restart cmeraserver&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;   &lt;span class=&quot;code-snippet__attr&quot;&gt;onrestart&lt;/span&gt; &lt;span class=&quot;code-snippet__string&quot;&gt;restart media&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;   &lt;span class=&quot;code-snippet__attr&quot;&gt;onrestart&lt;/span&gt; &lt;span class=&quot;code-snippet__string&quot;&gt;restart netd&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;   &lt;span class=&quot;code-snippet__attr&quot;&gt;onrestart&lt;/span&gt; &lt;span class=&quot;code-snippet__string&quot;&gt;setprop sys.android.reboot 1&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;   &lt;span class=&quot;code-snippet__attr&quot;&gt;writepid&lt;/span&gt; &lt;span class=&quot;code-snippet__string&quot;&gt;/dev/cpuset/foreground/tasks&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;   &lt;span class=&quot;code-snippet__attr&quot;&gt;critical&lt;/span&gt; &lt;span class=&quot;code-snippet__string&quot;&gt;window=${zygote.critical_window.minute:-off} target=zygote-fatal&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;pre&gt;&lt;code&gt;&lt;br/&gt;&lt;span aria-hidden=&quot;true&quot;/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;init进程解析init.zygote64.rc配置文件之后，会调用app_process&lt;/p&gt;&lt;p&gt;&lt;em aria-label=&quot;icon: copy&quot;&gt;&lt;svg viewbox=&quot;64 64 896 896&quot; focusable=&quot;false&quot; data-icon=&quot;copy&quot; fill=&quot;currentColor&quot; aria-hidden=&quot;true&quot;&gt;&lt;path d=&quot;M832 64H296c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8h496v688c0 4.4 3.6 8 8 8h56c4.4 0 8-3.6 8-8V96c0-17.7-14.3-32-32-32zM704 192H192c-17.7 0-32 14.3-32 32v530.7c0 8.5 3.4 16.6 9.4 22.6l173.3 173.3c2.2 2.2 4.7 4 7.4 5.5v1.9h4.2c3.5 1.3 7.2 2 11 2H704c17.7 0 32-14.3 32-32V224c0-17.7-14.3-32-32-32zM350 856.2L263.9 770H350v86.2zM664 888H414V746c0-22.1-17.9-40-40-40H232V264h432v624z&quot;/&gt;&lt;/svg&gt;&lt;/em&gt;&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;cs&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;main&lt;/span&gt;(&lt;span class=&quot;code-snippet__params&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;int&lt;/span&gt; argc, &lt;span class=&quot;code-snippet__keyword&quot;&gt;char&lt;/span&gt;* &lt;span class=&quot;code-snippet__keyword&quot;&gt;const&lt;/span&gt; argv[]&lt;/span&gt;)&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;       &lt;span class=&quot;code-snippet__keyword&quot;&gt;if&lt;/span&gt;(zygote){&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;         runtime.start(&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;com.android.internal.os.ZygoteInit&quot;&lt;/span&gt;, args, zygote);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;         }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;pre&gt;&lt;code&gt;&lt;span/&gt;&lt;br/&gt;&lt;span aria-hidden=&quot;true&quot;/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;执行到frameworks/base/core/jni/AndroidRuntime.cpp的start()方法&lt;/p&gt;&lt;p&gt;&lt;em aria-label=&quot;icon: copy&quot;&gt;&lt;svg viewbox=&quot;64 64 896 896&quot; focusable=&quot;false&quot; data-icon=&quot;copy&quot; fill=&quot;currentColor&quot; aria-hidden=&quot;true&quot;&gt;&lt;path d=&quot;M832 64H296c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8h496v688c0 4.4 3.6 8 8 8h56c4.4 0 8-3.6 8-8V96c0-17.7-14.3-32-32-32zM704 192H192c-17.7 0-32 14.3-32 32v530.7c0 8.5 3.4 16.6 9.4 22.6l173.3 173.3c2.2 2.2 4.7 4 7.4 5.5v1.9h4.2c3.5 1.3 7.2 2 11 2H704c17.7 0 32-14.3 32-32V224c0-17.7-14.3-32-32-32zM350 856.2L263.9 770H350v86.2zM664 888H414V746c0-22.1-17.9-40-40-40H232V264h432v624z&quot;/&gt;&lt;/svg&gt;&lt;/em&gt;&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;objectivec&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;void&lt;/span&gt; AndroidRuntime::start(&lt;span class=&quot;code-snippet__keyword&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;char&lt;/span&gt;* className, &lt;span class=&quot;code-snippet__keyword&quot;&gt;const&lt;/span&gt; Vector&amp;lt;String8&amp;gt;&amp;amp; options, &lt;span class=&quot;code-snippet__keyword&quot;&gt;bool&lt;/span&gt; zygote)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;{&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        ALOGD(&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt; START %s uid %d &amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;\n&quot;&lt;/span&gt;,&lt;span class=&quot;code-snippet__keyword&quot;&gt;class&lt;/span&gt; Name！= &lt;span class=&quot;code-snippet__literal&quot;&gt;NULL&lt;/span&gt;？&lt;span class=&quot;code-snippet__keyword&quot;&gt;class&lt;/span&gt; Name：&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;(unknown)&quot;&lt;/span&gt;, getuid() );&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        LOG_EVENT_LONG(LOG_BOOT_PROGRESS_START, ns2ms(systemTime(SYSTEM_TIME_MONOTONIC)));&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__keyword&quot;&gt;if&lt;/span&gt;(startVm(&amp;amp;mJavaVM, &amp;amp;env, zygote, primaryZygote) != &lt;span class=&quot;code-snippet__number&quot;&gt;0&lt;/span&gt;){&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            &lt;span class=&quot;code-snippet__keyword&quot;&gt;return&lt;/span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        onVmCreated(env);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        env.CallStaticVoidMethod(startClass, startMeth, strArray)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;pre&gt;&lt;code&gt;&lt;span/&gt;&lt;br/&gt;&lt;span aria-hidden=&quot;true&quot;/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;AndroidRuntime.cpp的start方法主要做了以下工作：&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;加载libart.so&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;启动虚拟机&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;加载注册JNI方法&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;启动Zygote&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;执行ZygoteInit.java的main()方法&lt;/p&gt;&lt;p&gt;&lt;em aria-label=&quot;icon: copy&quot;&gt;&lt;svg viewbox=&quot;64 64 896 896&quot; focusable=&quot;false&quot; data-icon=&quot;copy&quot; fill=&quot;currentColor&quot; aria-hidden=&quot;true&quot;&gt;&lt;path d=&quot;M832 64H296c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8h496v688c0 4.4 3.6 8 8 8h56c4.4 0 8-3.6 8-8V96c0-17.7-14.3-32-32-32zM704 192H192c-17.7 0-32 14.3-32 32v530.7c0 8.5 3.4 16.6 9.4 22.6l173.3 173.3c2.2 2.2 4.7 4 7.4 5.5v1.9h4.2c3.5 1.3 7.2 2 11 2H704c17.7 0 32-14.3 32-32V224c0-17.7-14.3-32-32-32zM350 856.2L263.9 770H350v86.2zM664 888H414V746c0-22.1-17.9-40-40-40H232V264h432v624z&quot;/&gt;&lt;/svg&gt;&lt;/em&gt;&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;typescript&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__meta&quot;&gt;@UnsupportedAppUsage&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;code-snippet__built_in&quot;&gt;void&lt;/span&gt; main(&lt;span class=&quot;code-snippet__built_in&quot;&gt;String&lt;/span&gt; argv[]) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;if&lt;/span&gt; (startSystemServer) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        Runnable r = forkSystemServer(abiList, socketName, zygoteServer);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__keyword&quot;&gt;if&lt;/span&gt; (r != &lt;span class=&quot;code-snippet__literal&quot;&gt;null&lt;/span&gt;) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;          r.run();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;          &lt;span class=&quot;code-snippet__keyword&quot;&gt;return&lt;/span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    Log.i(TAG, &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;Accepting command socket connections&quot;&lt;/span&gt;);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    caller = zygoteServer.runSelectLoop(abiList);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;if&lt;/span&gt; (caller != &lt;span class=&quot;code-snippet__literal&quot;&gt;null&lt;/span&gt;) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        caller.run();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;pre&gt;&lt;code&gt;&lt;span/&gt;&lt;br/&gt;&lt;span aria-hidden=&quot;true&quot;/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Zygote进程主要做了以下工作&lt;/p&gt;&lt;p&gt;zygote进程在fork子进程的时候可以共享虚拟机和资源，从而加快进程的启动速度，节省内存。&lt;/p&gt;&lt;h2&gt;&lt;span&gt;&lt;strong&gt;1.6 SystemServer&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5590851334180432&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz/yyLvy204xWibt5Ih0icthSOQgz1XcmYqIwvic0ic79r7ENrIibPk0ZabpL7AGfzJXXuJz5VibDDzq1VIpyhdP94hjyXQ/640?wx_fmt=other&quot; data-type=&quot;other&quot; data-w=&quot;787&quot;/&gt;&lt;/p&gt;&lt;p&gt;Android_boot_6_systemserver.png&lt;/p&gt;&lt;p&gt;SystemServer进程由Zygote进程fork而来，是Zygote孵化出的第一个进程。SystemServer和Zygote进程是Android Framework层的两大重要进程。SystemServer负责启动和管理整个Java frameWork。SystemServer进程在开启的时候，会初始化AMS、WMS、PMS等关键服务。同时会加载本地系统的服务库，调用createSystemContext()创建系统上下文，创建ActivityThread及开启各种服务等等。&lt;/p&gt;&lt;p&gt;SystemServer的启动相关代码如下&lt;/p&gt;&lt;p&gt;&lt;em aria-label=&quot;icon: copy&quot;&gt;&lt;svg viewbox=&quot;64 64 896 896&quot; focusable=&quot;false&quot; data-icon=&quot;copy&quot; fill=&quot;currentColor&quot; aria-hidden=&quot;true&quot;&gt;&lt;path d=&quot;M832 64H296c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8h496v688c0 4.4 3.6 8 8 8h56c4.4 0 8-3.6 8-8V96c0-17.7-14.3-32-32-32zM704 192H192c-17.7 0-32 14.3-32 32v530.7c0 8.5 3.4 16.6 9.4 22.6l173.3 173.3c2.2 2.2 4.7 4 7.4 5.5v1.9h4.2c3.5 1.3 7.2 2 11 2H704c17.7 0 32-14.3 32-32V224c0-17.7-14.3-32-32-32zM350 856.2L263.9 770H350v86.2zM664 888H414V746c0-22.1-17.9-40-40-40H232V264h432v624z&quot;/&gt;&lt;/svg&gt;&lt;/em&gt;&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;cs&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;main&lt;/span&gt;(&lt;span class=&quot;code-snippet__params&quot;&gt;String[] args&lt;/span&gt;)&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;new&lt;/span&gt; SystemServer().run();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;run&lt;/span&gt;(&lt;span class=&quot;code-snippet__params&quot;/&gt;)&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;try&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        Looper.prepareMainLooper();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        System.loadLibrary(&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;android_servers&quot;&lt;/span&gt;);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;         &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        createSystemContext();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        mSystemServiceManager = &lt;span class=&quot;code-snippet__keyword&quot;&gt;new&lt;/span&gt; SystemServiceManager(mSystemContext);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        mSystemServiceManager.setStartInfo(mRuntimeRestart,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                mRuntimeStartElapsedTime, mRuntimeStartUptime);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        LocalServices.addService(SystemServiceManager.class, mSystemServiceManager);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        SystemServerInitThreadPool.&lt;span class=&quot;code-snippet__keyword&quot;&gt;get&lt;/span&gt;();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    } &lt;span class=&quot;code-snippet__keyword&quot;&gt;finally&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        traceEnd();  &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt; &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;try&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        traceBeginAndSlog(&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;StartServices&quot;&lt;/span&gt;);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        startBootstrapServices();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        startCoreServices();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        startOtherServices();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        SystemServerInitThreadPool.shutdown();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    } &lt;span class=&quot;code-snippet__keyword&quot;&gt;catch&lt;/span&gt; (Throwable ex) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        Slog.e(&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;System&quot;&lt;/span&gt;, &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;******************************************&quot;&lt;/span&gt;);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        Slog.e(&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;System&quot;&lt;/span&gt;, &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;************ Failure starting system services&quot;&lt;/span&gt;, ex);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__keyword&quot;&gt;throw&lt;/span&gt; ex;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    } &lt;span class=&quot;code-snippet__keyword&quot;&gt;finally&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        traceEnd();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    Looper.loop();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;throw&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;new&lt;/span&gt; RuntimeException(&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;Main thread loop unexpectedly exited&quot;&lt;/span&gt;);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;pre&gt;&lt;code&gt;&lt;span/&gt;&lt;br/&gt;&lt;span aria-hidden=&quot;true&quot;/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;可以看到，SystemServer最重要的工作就是通过执行三个方法来启动所有服务&lt;/p&gt;&lt;p&gt;分别对应引导服务、核心服务和其他服务：&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;引导服务(Bootstrap services)：这类服务包括 Installer，ActivityManagerService&lt;br/&gt;PowerManagerService, DisplayManagerService, PackageManagerService, UserManagerService等&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;核心服务(Core services )：这类服务包括 LightsService, BatteryService, UsageStatsServtce,&lt;br/&gt;WebViewUpdateService等&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;其他服务：所有其它服务&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;在startOtherServices()方法中会启动SystemUI，之后SystemServer通知AMS系统已准备好，此时AMS启动桌面并且发送BOOT_COMPLETED广播。至此，系统层面启动流程结束。&lt;/p&gt;&lt;p&gt;通过下图再回顾下整个开机流程&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.9091666666666667&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz/yyLvy204xWibt5Ih0icthSOQgz1XcmYqIwgSHf5SdPFXvVxzdNZHjWeNOtkGg2WgDuc1nVuo3yxyZGbJ4lu8aibwA/640?wx_fmt=other&quot; data-type=&quot;other&quot; data-w=&quot;1200&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;2. 分析开机时间&lt;/span&gt;&lt;span/&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;/section&gt;&lt;p&gt;要想进行开机速度的优化，我们需要分析开机时间的分布，从而找出异常耗时的地方，从而进行实际的优化工作。下面介绍如何分析开机时间。&lt;/p&gt;&lt;h2&gt;&lt;span&gt;&lt;strong&gt;2.1 分析开机日志&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;Android的log系统是独立于Linux内核log系统的. Android系统把Log分为了四类，不同的类别记录不同的Log信息，默认通过logcat抓取的是main信息：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.2863247863247863&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz/yyLvy204xWibt5Ih0icthSOQgz1XcmYqIwa7BLazGLzRJhNQ49NOBYvRYKRIRn7tS7icfBasOxEqPORFiaP6k3c26w/640?wx_fmt=other&quot; data-type=&quot;other&quot; data-w=&quot;702&quot;/&gt;&lt;/p&gt;&lt;p&gt;init_process_log.png&lt;/p&gt;&lt;p&gt;行末数字即为此刻距开机时刻的时间间隔。每行代表开机的各个关键阶段。&lt;/p&gt;&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;阶段&lt;/th&gt;&lt;th&gt;描述&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;boot_progress_start&lt;/td&gt;&lt;td&gt;系统进入用户空间，标志着kernel启动完成&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;boot_progress_preload_start&lt;/td&gt;&lt;td&gt;Zygote启动&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;boot_progress_preload_end&lt;/td&gt;&lt;td&gt;Zygote结束&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;boot_progress_system_run&lt;/td&gt;&lt;td&gt;SystemServer ready,开始启动Android系统服务&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;boot_progress_pms_start&lt;/td&gt;&lt;td&gt;PMS开始扫描安装的应用&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;boot_progress_pms_system_scan_start&lt;/td&gt;&lt;td&gt;PMS先行扫描/system目录下的安装包&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;boot_progress_pms_data_scan_start&lt;/td&gt;&lt;td&gt;PMS扫描/data目录下的安装包&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;boot_progress_pms_scan_end&lt;/td&gt;&lt;td&gt;PMS扫描结束&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;boot_progress_pms_ready&lt;/td&gt;&lt;td&gt;PMS就绪&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;boot_progress_ams_ready&lt;/td&gt;&lt;td&gt;AMS就绪&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;boot_progress_enable_screen&lt;/td&gt;&lt;td&gt;AMS启动完成后开始激活屏幕，从此以后屏幕才能响应用户的触摸，它在WindowManagerService发出退出开机动画的时间节点之前&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;sf_stop_bootanim&lt;/td&gt;&lt;td&gt;SF设置service.bootanim.exit属性值为1，标志系统要结束开机动画了&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;wm_boot_animation_done&lt;/td&gt;&lt;td&gt;开机动画结束，这一步用户能直观感受到开机结束&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;各行log对应的打印代码为&lt;br/&gt;&lt;strong&gt;boot_progress_start&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;em aria-label=&quot;icon: copy&quot;&gt;&lt;svg viewbox=&quot;64 64 896 896&quot; focusable=&quot;false&quot; data-icon=&quot;copy&quot; fill=&quot;currentColor&quot; aria-hidden=&quot;true&quot;&gt;&lt;path d=&quot;M832 64H296c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8h496v688c0 4.4 3.6 8 8 8h56c4.4 0 8-3.6 8-8V96c0-17.7-14.3-32-32-32zM704 192H192c-17.7 0-32 14.3-32 32v530.7c0 8.5 3.4 16.6 9.4 22.6l173.3 173.3c2.2 2.2 4.7 4 7.4 5.5v1.9h4.2c3.5 1.3 7.2 2 11 2H704c17.7 0 32-14.3 32-32V224c0-17.7-14.3-32-32-32zM350 856.2L263.9 770H350v86.2zM664 888H414V746c0-22.1-17.9-40-40-40H232V264h432v624z&quot;/&gt;&lt;/svg&gt;&lt;/em&gt;&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;cpp&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;void&lt;/span&gt; AndroidRuntime::start(&lt;span class=&quot;code-snippet__keyword&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;char&lt;/span&gt;* className, &lt;span class=&quot;code-snippet__keyword&quot;&gt;const&lt;/span&gt; Vector&amp;lt;String8&amp;gt;&amp;amp; options, &lt;span class=&quot;code-snippet__keyword&quot;&gt;bool&lt;/span&gt; zygote)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;{&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;code-snippet__keyword&quot;&gt;size_t&lt;/span&gt; i = &lt;span class=&quot;code-snippet__number&quot;&gt;0&lt;/span&gt;; i &amp;lt; options.size(); ++i) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__keyword&quot;&gt;if&lt;/span&gt; (options[i] == startSystemServer) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            primary_zygote = &lt;span class=&quot;code-snippet__literal&quot;&gt;true&lt;/span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;           &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;           &lt;span class=&quot;code-snippet__keyword&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;int&lt;/span&gt; LOG_BOOT_PROGRESS_START = &lt;span class=&quot;code-snippet__number&quot;&gt;3000&lt;/span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;           LOG_EVENT_LONG(LOG_BOOT_PROGRESS_START,  ns2ms(systemTime(SYSTEM_TIME_MONOTONIC)));&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;pre&gt;&lt;code&gt;&lt;span/&gt;&lt;br/&gt;&lt;span aria-hidden=&quot;true&quot;/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;boot_progress_preload_start&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;em aria-label=&quot;icon: copy&quot;&gt;&lt;svg viewbox=&quot;64 64 896 896&quot; focusable=&quot;false&quot; data-icon=&quot;copy&quot; fill=&quot;currentColor&quot; aria-hidden=&quot;true&quot;&gt;&lt;path d=&quot;M832 64H296c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8h496v688c0 4.4 3.6 8 8 8h56c4.4 0 8-3.6 8-8V96c0-17.7-14.3-32-32-32zM704 192H192c-17.7 0-32 14.3-32 32v530.7c0 8.5 3.4 16.6 9.4 22.6l173.3 173.3c2.2 2.2 4.7 4 7.4 5.5v1.9h4.2c3.5 1.3 7.2 2 11 2H704c17.7 0 32-14.3 32-32V224c0-17.7-14.3-32-32-32zM350 856.2L263.9 770H350v86.2zM664 888H414V746c0-22.1-17.9-40-40-40H232V264h432v624z&quot;/&gt;&lt;/svg&gt;&lt;/em&gt;&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;cs&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;main&lt;/span&gt;(&lt;span class=&quot;code-snippet__params&quot;&gt;String[] argv&lt;/span&gt;)&lt;/span&gt;{&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;if&lt;/span&gt;(!enableLazyPreload){&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        bootTimingsTraceLog.traceBegin(&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;ZygotePreload&quot;&lt;/span&gt;);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        EventLog.writeEvent(BOOT_PROGRESS_PRELOAD_START, SystemClock.uptimeMillis());&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        preload(bootTimingsTraceLog);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        EventLog.writeEvent(BOOT_PROGRESS_PRELOAD_END, SystemClock.uptimeMillis());&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        bootTimingsTraceLog.traceEnd();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;pre&gt;&lt;code&gt;&lt;span/&gt;&lt;br/&gt;&lt;span aria-hidden=&quot;true&quot;/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;boot_progress_system_run&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;em aria-label=&quot;icon: copy&quot;&gt;&lt;svg viewbox=&quot;64 64 896 896&quot; focusable=&quot;false&quot; data-icon=&quot;copy&quot; fill=&quot;currentColor&quot; aria-hidden=&quot;true&quot;&gt;&lt;path d=&quot;M832 64H296c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8h496v688c0 4.4 3.6 8 8 8h56c4.4 0 8-3.6 8-8V96c0-17.7-14.3-32-32-32zM704 192H192c-17.7 0-32 14.3-32 32v530.7c0 8.5 3.4 16.6 9.4 22.6l173.3 173.3c2.2 2.2 4.7 4 7.4 5.5v1.9h4.2c3.5 1.3 7.2 2 11 2H704c17.7 0 32-14.3 32-32V224c0-17.7-14.3-32-32-32zM350 856.2L263.9 770H350v86.2zM664 888H414V746c0-22.1-17.9-40-40-40H232V264h432v624z&quot;/&gt;&lt;/svg&gt;&lt;/em&gt;&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;java&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;run&lt;/span&gt;&lt;span class=&quot;code-snippet__params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;   Slog.i(TAG, &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;Entered the Android system server!&quot;&lt;/span&gt;);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;   &lt;span class=&quot;code-snippet__keyword&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;long&lt;/span&gt; uptimeMillis = SystemClock.elapsedRealtime();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;   EventLog.writeEvent(EventLogTags.BOOT_PROGRESS_SYSTEM_RUN, uptimeMillis);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;   &lt;span class=&quot;code-snippet__keyword&quot;&gt;if&lt;/span&gt; (!mRuntimeRestart){&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            FrameworkStatsLog.write(FrameworkStatsLog.BOOT_TIME_EVENT_ELAPSED_TIME_REPORTED,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;FrameworkStatsLog.BOOT_TIME_EVENT_ELAPSED_TIME__EVENT__SYSTEM_SERVER_INIT_START,uptimeMillis);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;      }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;pre&gt;&lt;code&gt;&lt;span/&gt;&lt;br/&gt;&lt;span aria-hidden=&quot;true&quot;/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;boot_progress_pms_start&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;em aria-label=&quot;icon: copy&quot;&gt;&lt;svg viewbox=&quot;64 64 896 896&quot; focusable=&quot;false&quot; data-icon=&quot;copy&quot; fill=&quot;currentColor&quot; aria-hidden=&quot;true&quot;&gt;&lt;path d=&quot;M832 64H296c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8h496v688c0 4.4 3.6 8 8 8h56c4.4 0 8-3.6 8-8V96c0-17.7-14.3-32-32-32zM704 192H192c-17.7 0-32 14.3-32 32v530.7c0 8.5 3.4 16.6 9.4 22.6l173.3 173.3c2.2 2.2 4.7 4 7.4 5.5v1.9h4.2c3.5 1.3 7.2 2 11 2H704c17.7 0 32-14.3 32-32V224c0-17.7-14.3-32-32-32zM350 856.2L263.9 770H350v86.2zM664 888H414V746c0-22.1-17.9-40-40-40H232V264h432v624z&quot;/&gt;&lt;/svg&gt;&lt;/em&gt;&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;java&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;PackageManagerService&lt;/span&gt;&lt;span class=&quot;code-snippet__params&quot;&gt;(Injector injector, &lt;span class=&quot;code-snippet__keyword&quot;&gt;boolean&lt;/span&gt; onlyCore, &lt;span class=&quot;code-snippet__keyword&quot;&gt;boolean&lt;/span&gt; factoryTest)&lt;/span&gt; &lt;/span&gt;{&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    LockGuard.installLock(mLock, LockGuard.INDEX_PACKAGES);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    EventLog.writeEvent(EventLogTags.BOOT_PROGRESS_PMS_START,SystemClock.uptimeMillis()&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    );&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;pre&gt;&lt;code&gt;&lt;span/&gt;&lt;br/&gt;&lt;span aria-hidden=&quot;true&quot;/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;boot_progress_pms_system_scan_start&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;em aria-label=&quot;icon: copy&quot;&gt;&lt;svg viewbox=&quot;64 64 896 896&quot; focusable=&quot;false&quot; data-icon=&quot;copy&quot; fill=&quot;currentColor&quot; aria-hidden=&quot;true&quot;&gt;&lt;path d=&quot;M832 64H296c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8h496v688c0 4.4 3.6 8 8 8h56c4.4 0 8-3.6 8-8V96c0-17.7-14.3-32-32-32zM704 192H192c-17.7 0-32 14.3-32 32v530.7c0 8.5 3.4 16.6 9.4 22.6l173.3 173.3c2.2 2.2 4.7 4 7.4 5.5v1.9h4.2c3.5 1.3 7.2 2 11 2H704c17.7 0 32-14.3 32-32V224c0-17.7-14.3-32-32-32zM350 856.2L263.9 770H350v86.2zM664 888H414V746c0-22.1-17.9-40-40-40H232V264h432v624z&quot;/&gt;&lt;/svg&gt;&lt;/em&gt;&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;java&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;PackageManagerService&lt;/span&gt;&lt;span class=&quot;code-snippet__params&quot;&gt;(Injector injector, &lt;span class=&quot;code-snippet__keyword&quot;&gt;boolean&lt;/span&gt; onlyCore, &lt;span class=&quot;code-snippet__keyword&quot;&gt;boolean&lt;/span&gt; factoryTest)&lt;/span&gt; &lt;/span&gt;{&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;   &lt;span class=&quot;code-snippet__keyword&quot;&gt;long&lt;/span&gt; startTime = SystemClock.uptimeMillis();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;   EventLog.writeEvent(EventLogTags.BOOT_PROGRESS_PMS_SYSTEM_SCAN_START, startTime);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;pre&gt;&lt;code&gt;&lt;span/&gt;&lt;br/&gt;&lt;span aria-hidden=&quot;true&quot;/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;boot_progress_pms_data_scan_start&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;em aria-label=&quot;icon: copy&quot;&gt;&lt;svg viewbox=&quot;64 64 896 896&quot; focusable=&quot;false&quot; data-icon=&quot;copy&quot; fill=&quot;currentColor&quot; aria-hidden=&quot;true&quot;&gt;&lt;path d=&quot;M832 64H296c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8h496v688c0 4.4 3.6 8 8 8h56c4.4 0 8-3.6 8-8V96c0-17.7-14.3-32-32-32zM704 192H192c-17.7 0-32 14.3-32 32v530.7c0 8.5 3.4 16.6 9.4 22.6l173.3 173.3c2.2 2.2 4.7 4 7.4 5.5v1.9h4.2c3.5 1.3 7.2 2 11 2H704c17.7 0 32-14.3 32-32V224c0-17.7-14.3-32-32-32zM350 856.2L263.9 770H350v86.2zM664 888H414V746c0-22.1-17.9-40-40-40H232V264h432v624z&quot;/&gt;&lt;/svg&gt;&lt;/em&gt;&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;java&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;PackageManagerService&lt;/span&gt;&lt;span class=&quot;code-snippet__params&quot;&gt;(Injector injector, &lt;span class=&quot;code-snippet__keyword&quot;&gt;boolean&lt;/span&gt; onlyCore, &lt;span class=&quot;code-snippet__keyword&quot;&gt;boolean&lt;/span&gt; factoryTest)&lt;/span&gt; &lt;/span&gt;{&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__keyword&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;long&lt;/span&gt; systemScanTime = SystemClock.uptimeMillis() - startTime;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__keyword&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;int&lt;/span&gt; systemPackagesCount = mPackages.size();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        Slog.i(TAG, &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;Finished scanning system apps. Time: &quot;&lt;/span&gt; + systemScanTime&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                    + &lt;span class=&quot;code-snippet__string&quot;&gt;&quot; ms, packageCount: &quot;&lt;/span&gt; + systemPackagesCount&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                    + &lt;span class=&quot;code-snippet__string&quot;&gt;&quot; , timePerPackage: &quot;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                    + (systemPackagesCount == &lt;span class=&quot;code-snippet__number&quot;&gt;0&lt;/span&gt; ? &lt;span class=&quot;code-snippet__number&quot;&gt;0&lt;/span&gt; : systemScanTime / systemPackagesCount)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                    + &lt;span class=&quot;code-snippet__string&quot;&gt;&quot; , cached: &quot;&lt;/span&gt; + cachedSystemApps);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__keyword&quot;&gt;if&lt;/span&gt; (mIsUpgrade &amp;amp;&amp;amp; systemPackagesCount &amp;gt; &lt;span class=&quot;code-snippet__number&quot;&gt;0&lt;/span&gt;) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            FrameworkStatsLog.write(FrameworkStatsLog.BOOT_TIME_EVENT_DURATION_REPORTED,                &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;BOOT_TIME_EVENT_DURATION__EVENT__OTA_PACKAGE_MANAGER_SYSTEM_APP_AVG_SCAN_TIME,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;     systemScanTime / systemPackagesCount);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            &lt;span class=&quot;code-snippet__keyword&quot;&gt;if&lt;/span&gt; (!mOnlyCore) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            EventLog.writeEvent(EventLogTags.BOOT_PROGRESS_PMS_DATA_SCAN_START,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            SystemClock.uptimeMillis());&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            scanDirTracedLI(sAppInstallDir, &lt;span class=&quot;code-snippet__number&quot;&gt;0&lt;/span&gt;, scanFlags | SCAN_REQUIRE_KNOWN, &lt;span class=&quot;code-snippet__number&quot;&gt;0&lt;/span&gt;,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                        packageParser, executorService);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;pre&gt;&lt;code&gt;&lt;span/&gt;&lt;br/&gt;&lt;span aria-hidden=&quot;true&quot;/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;boot_progress_pms_scan_end&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;em aria-label=&quot;icon: copy&quot;&gt;&lt;svg viewbox=&quot;64 64 896 896&quot; focusable=&quot;false&quot; data-icon=&quot;copy&quot; fill=&quot;currentColor&quot; aria-hidden=&quot;true&quot;&gt;&lt;path d=&quot;M832 64H296c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8h496v688c0 4.4 3.6 8 8 8h56c4.4 0 8-3.6 8-8V96c0-17.7-14.3-32-32-32zM704 192H192c-17.7 0-32 14.3-32 32v530.7c0 8.5 3.4 16.6 9.4 22.6l173.3 173.3c2.2 2.2 4.7 4 7.4 5.5v1.9h4.2c3.5 1.3 7.2 2 11 2H704c17.7 0 32-14.3 32-32V224c0-17.7-14.3-32-32-32zM350 856.2L263.9 770H350v86.2zM664 888H414V746c0-22.1-17.9-40-40-40H232V264h432v624z&quot;/&gt;&lt;/svg&gt;&lt;/em&gt;&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;java&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt; &lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;PackageManagerService&lt;/span&gt;&lt;span class=&quot;code-snippet__params&quot;&gt;(Injector injector, &lt;span class=&quot;code-snippet__keyword&quot;&gt;boolean&lt;/span&gt; onlyCore, &lt;span class=&quot;code-snippet__keyword&quot;&gt;boolean&lt;/span&gt; factoryTest)&lt;/span&gt; &lt;/span&gt;{&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        mPackageUsage.read(mSettings.mPackages);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        mCompilerStats.read();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        EventLog.writeEvent(EventLogTags.BOOT_PROGRESS_PMS_SCAN_END,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                    SystemClock.uptimeMillis());&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            Slog.i(TAG, &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;Time to scan packages: &quot;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                    + ((SystemClock.uptimeMillis()-startTime)/&lt;span class=&quot;code-snippet__number&quot;&gt;1000f&lt;/span&gt;)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                    + &lt;span class=&quot;code-snippet__string&quot;&gt;&quot; seconds&quot;&lt;/span&gt;);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;pre&gt;&lt;code&gt;&lt;span/&gt;&lt;br/&gt;&lt;span aria-hidden=&quot;true&quot;/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;boot_progress_pms_ready&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;em aria-label=&quot;icon: copy&quot;&gt;&lt;svg viewbox=&quot;64 64 896 896&quot; focusable=&quot;false&quot; data-icon=&quot;copy&quot; fill=&quot;currentColor&quot; aria-hidden=&quot;true&quot;&gt;&lt;path d=&quot;M832 64H296c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8h496v688c0 4.4 3.6 8 8 8h56c4.4 0 8-3.6 8-8V96c0-17.7-14.3-32-32-32zM704 192H192c-17.7 0-32 14.3-32 32v530.7c0 8.5 3.4 16.6 9.4 22.6l173.3 173.3c2.2 2.2 4.7 4 7.4 5.5v1.9h4.2c3.5 1.3 7.2 2 11 2H704c17.7 0 32-14.3 32-32V224c0-17.7-14.3-32-32-32zM350 856.2L263.9 770H350v86.2zM664 888H414V746c0-22.1-17.9-40-40-40H232V264h432v624z&quot;/&gt;&lt;/svg&gt;&lt;/em&gt;&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;java&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt; &lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;PackageManagerService&lt;/span&gt;&lt;span class=&quot;code-snippet__params&quot;&gt;(Injector injector, &lt;span class=&quot;code-snippet__keyword&quot;&gt;boolean&lt;/span&gt; onlyCore, &lt;span class=&quot;code-snippet__keyword&quot;&gt;boolean&lt;/span&gt; factoryTest)&lt;/span&gt; &lt;/span&gt;{&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        t.traceBegin(&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;write settings&quot;&lt;/span&gt;);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        mSettings.writeLPr();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        t.traceEnd();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        EventLog.writeEvent(EventLogTags.BOOT_PROGRESS_PMS_READY, SystemClock.uptimeMillis());&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;pre&gt;&lt;code&gt;&lt;span/&gt;&lt;br/&gt;&lt;span aria-hidden=&quot;true&quot;/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;boot_progress_ams_ready&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;em aria-label=&quot;icon: copy&quot;&gt;&lt;svg viewbox=&quot;64 64 896 896&quot; focusable=&quot;false&quot; data-icon=&quot;copy&quot; fill=&quot;currentColor&quot; aria-hidden=&quot;true&quot;&gt;&lt;path d=&quot;M832 64H296c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8h496v688c0 4.4 3.6 8 8 8h56c4.4 0 8-3.6 8-8V96c0-17.7-14.3-32-32-32zM704 192H192c-17.7 0-32 14.3-32 32v530.7c0 8.5 3.4 16.6 9.4 22.6l173.3 173.3c2.2 2.2 4.7 4 7.4 5.5v1.9h4.2c3.5 1.3 7.2 2 11 2H704c17.7 0 32-14.3 32-32V224c0-17.7-14.3-32-32-32zM350 856.2L263.9 770H350v86.2zM664 888H414V746c0-22.1-17.9-40-40-40H232V264h432v624z&quot;/&gt;&lt;/svg&gt;&lt;/em&gt;&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;ruby&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;/&lt;span class=&quot;code-snippet__regexp&quot;&gt;/ frameworks/base&lt;/span&gt;&lt;span class=&quot;code-snippet__regexp&quot;&gt;/services/core&lt;/span&gt;&lt;span class=&quot;code-snippet__regexp&quot;&gt;/java/com&lt;/span&gt;&lt;span class=&quot;code-snippet__regexp&quot;&gt;/android/server&lt;/span&gt;&lt;span class=&quot;code-snippet__regexp&quot;&gt;/am/&lt;/span&gt;ActivityManagerService.java&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;public void systemReady(final Runnable goingCallback, @NonNull TimingsTraceAndSlog t) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        t.traceEnd();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        EventLog.writeBootProgressAmsReady(SystemClock.uptimeMillis());&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;pre&gt;&lt;code&gt;&lt;span/&gt;&lt;br/&gt;&lt;span aria-hidden=&quot;true&quot;/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;boot_progress_enable_screen&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;em aria-label=&quot;icon: copy&quot;&gt;&lt;svg viewbox=&quot;64 64 896 896&quot; focusable=&quot;false&quot; data-icon=&quot;copy&quot; fill=&quot;currentColor&quot; aria-hidden=&quot;true&quot;&gt;&lt;path d=&quot;M832 64H296c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8h496v688c0 4.4 3.6 8 8 8h56c4.4 0 8-3.6 8-8V96c0-17.7-14.3-32-32-32zM704 192H192c-17.7 0-32 14.3-32 32v530.7c0 8.5 3.4 16.6 9.4 22.6l173.3 173.3c2.2 2.2 4.7 4 7.4 5.5v1.9h4.2c3.5 1.3 7.2 2 11 2H704c17.7 0 32-14.3 32-32V224c0-17.7-14.3-32-32-32zM350 856.2L263.9 770H350v86.2zM664 888H414V746c0-22.1-17.9-40-40-40H232V264h432v624z&quot;/&gt;&lt;/svg&gt;&lt;/em&gt;&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;java&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt; &lt;span class=&quot;code-snippet__meta&quot;&gt;@Override&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;enableScreenAfterBoot&lt;/span&gt;&lt;span class=&quot;code-snippet__params&quot;&gt;(&lt;span class=&quot;code-snippet__keyword&quot;&gt;boolean&lt;/span&gt; booted)&lt;/span&gt; &lt;/span&gt;{&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        writeBootProgressEnableScreen(SystemClock.uptimeMillis());&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        mWindowManager.enableScreenAfterBoot();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__keyword&quot;&gt;synchronized&lt;/span&gt; (mGlobalLock) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            updateEventDispatchingLocked(booted);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt; }&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;pre&gt;&lt;code&gt;&lt;span/&gt;&lt;br/&gt;&lt;span aria-hidden=&quot;true&quot;/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;sf_stop_bootanim&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;em aria-label=&quot;icon: copy&quot;&gt;&lt;svg viewbox=&quot;64 64 896 896&quot; focusable=&quot;false&quot; data-icon=&quot;copy&quot; fill=&quot;currentColor&quot; aria-hidden=&quot;true&quot;&gt;&lt;path d=&quot;M832 64H296c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8h496v688c0 4.4 3.6 8 8 8h56c4.4 0 8-3.6 8-8V96c0-17.7-14.3-32-32-32zM704 192H192c-17.7 0-32 14.3-32 32v530.7c0 8.5 3.4 16.6 9.4 22.6l173.3 173.3c2.2 2.2 4.7 4 7.4 5.5v1.9h4.2c3.5 1.3 7.2 2 11 2H704c17.7 0 32-14.3 32-32V224c0-17.7-14.3-32-32-32zM350 856.2L263.9 770H350v86.2zM664 888H414V746c0-22.1-17.9-40-40-40H232V264h432v624z&quot;/&gt;&lt;/svg&gt;&lt;/em&gt;&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;cpp&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;void&lt;/span&gt; SurfaceFlinger::bootFinished()&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;{&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;         property_set(&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;service.bootanim.exit&quot;&lt;/span&gt;, &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;1&quot;&lt;/span&gt;);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;         LOG_EVENT_LONG(LOGTAG_SF_STOP_BOOTANIM, ns2ms(systemTime(SYSTEM_TIME_MONOTONIC)));&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;pre&gt;&lt;code&gt;&lt;span/&gt;&lt;br/&gt;&lt;span aria-hidden=&quot;true&quot;/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;wm_boot_animation_done&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;em aria-label=&quot;icon: copy&quot;&gt;&lt;svg viewbox=&quot;64 64 896 896&quot; focusable=&quot;false&quot; data-icon=&quot;copy&quot; fill=&quot;currentColor&quot; aria-hidden=&quot;true&quot;&gt;&lt;path d=&quot;M832 64H296c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8h496v688c0 4.4 3.6 8 8 8h56c4.4 0 8-3.6 8-8V96c0-17.7-14.3-32-32-32zM704 192H192c-17.7 0-32 14.3-32 32v530.7c0 8.5 3.4 16.6 9.4 22.6l173.3 173.3c2.2 2.2 4.7 4 7.4 5.5v1.9h4.2c3.5 1.3 7.2 2 11 2H704c17.7 0 32-14.3 32-32V224c0-17.7-14.3-32-32-32zM350 856.2L263.9 770H350v86.2zM664 888H414V746c0-22.1-17.9-40-40-40H232V264h432v624z&quot;/&gt;&lt;/svg&gt;&lt;/em&gt;&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;ruby&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;/&lt;span class=&quot;code-snippet__regexp&quot;&gt;/ frameworks/base&lt;/span&gt;&lt;span class=&quot;code-snippet__regexp&quot;&gt;/services/core&lt;/span&gt;&lt;span class=&quot;code-snippet__regexp&quot;&gt;/java/com&lt;/span&gt;&lt;span class=&quot;code-snippet__regexp&quot;&gt;/android/server&lt;/span&gt;&lt;span class=&quot;code-snippet__regexp&quot;&gt;/wm/&lt;/span&gt;WindowManagerService.java&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;private void performEnableScreen() {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        EventLogTags.writeWmBootAnimationDone(SystemClock.uptimeMillis());&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        Trace.asyncTraceEnd(TRACE_TAG_WINDOW_MANAGER,   &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;Stop bootanim&quot;&lt;/span&gt;);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;pre&gt;&lt;code&gt;&lt;span/&gt;&lt;br/&gt;&lt;span aria-hidden=&quot;true&quot;/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;可以将测试机与对比机抓取的此log数据制作成表格，制作成折线图，可以更加直观的观察到耗时异常的流程。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.36333333333333334&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz/yyLvy204xWibt5Ih0icthSOQgz1XcmYqIw7RH011r933veQJM1eIfEM1BNqo1xbJQQ9JoQZ1fWFlDJSSnn251KVQ/640?wx_fmt=other&quot; data-type=&quot;other&quot; data-w=&quot;1200&quot;/&gt;&lt;/p&gt;&lt;p&gt;boot_time_chart_1.png&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;通过&quot;boot_progress_&quot;关键字分析日志，粒度较大，只能定位出大概的耗时流程，之后还需分析流程内部具体的耗时情况。开机各流程内部也有相应的日志，可以进行更加细致的分析。例如在SystemServiceManager.java类中启动服务时，会打印启动某项服务的日志。通过查看某个服务A与下一个服务的日志时间，可以计算出启动服务A的耗时。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.21666666666666667&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz/yyLvy204xWibt5Ih0icthSOQgz1XcmYqIwvibTjaztgCWYbgwvFToC7icolO9hsBGvicmYraWuMFlF7eeNb9xWuG8ZQ/640?wx_fmt=other&quot; data-type=&quot;other&quot; data-w=&quot;1200&quot;/&gt;&lt;/p&gt;&lt;p&gt;a0ca34f607cf9c51134adcfebc515333.png&lt;/p&gt;&lt;p&gt;&lt;em aria-label=&quot;icon: copy&quot;&gt;&lt;svg viewbox=&quot;64 64 896 896&quot; focusable=&quot;false&quot; data-icon=&quot;copy&quot; fill=&quot;currentColor&quot; aria-hidden=&quot;true&quot;&gt;&lt;path d=&quot;M832 64H296c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8h496v688c0 4.4 3.6 8 8 8h56c4.4 0 8-3.6 8-8V96c0-17.7-14.3-32-32-32zM704 192H192c-17.7 0-32 14.3-32 32v530.7c0 8.5 3.4 16.6 9.4 22.6l173.3 173.3c2.2 2.2 4.7 4 7.4 5.5v1.9h4.2c3.5 1.3 7.2 2 11 2H704c17.7 0 32-14.3 32-32V224c0-17.7-14.3-32-32-32zM350 856.2L263.9 770H350v86.2zM664 888H414V746c0-22.1-17.9-40-40-40H232V264h432v624z&quot;/&gt;&lt;/svg&gt;&lt;/em&gt;&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;typescript&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;public&lt;/span&gt; &amp;lt;T &lt;span class=&quot;code-snippet__keyword&quot;&gt;extends&lt;/span&gt; SystemService&amp;gt; T startService(Class&amp;lt;T&amp;gt; serviceClass)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__keyword&quot;&gt;try&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            final &lt;span class=&quot;code-snippet__built_in&quot;&gt;String&lt;/span&gt; name = serviceClass.getName();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            Slog.i(TAG, &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;Starting &quot;&lt;/span&gt; + name);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            Trace.traceBegin(Trace.TRACE_TAG_SYSTEM_SERVER, &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;StartService &quot;&lt;/span&gt; + name);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            &lt;span class=&quot;code-snippet__keyword&quot;&gt;try&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                Constructor&amp;lt;T&amp;gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;constructor&lt;/span&gt; = serviceClass . getConstructor (&lt;span class=&quot;code-snippet__params&quot;&gt;Context.&lt;span class=&quot;code-snippet__keyword&quot;&gt;class&lt;/span&gt;&lt;/span&gt;);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                service = &lt;span class=&quot;code-snippet__keyword&quot;&gt;constructor&lt;/span&gt;.newInstance(&lt;span class=&quot;code-snippet__params&quot;&gt;mContext&lt;/span&gt;);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            } catch ...&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                startService(&lt;span class=&quot;code-snippet__params&quot;&gt;service&lt;/span&gt;);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            return service;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        } finally {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            Trace.traceEnd(&lt;span class=&quot;code-snippet__params&quot;&gt;Trace.TRACE_TAG_SYSTEM_SERVER&lt;/span&gt;);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;pre&gt;&lt;code&gt;&lt;br/&gt;&lt;span aria-hidden=&quot;true&quot;/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;使用bootchart工具可以进行更加直观的分析。&lt;/p&gt;&lt;h2&gt;&lt;span&gt;&lt;strong&gt;2.2 使用bootchart工具&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;bootchart是一个能对GNU/Linux boot过程进行性能分析并把结果直观化的开源工具，在系统启动过程中自动收集 CPU 占用率、磁盘吞吐率、进程等信息，并以图形方式显示分析结果，可用作指导优化系统启动过程。BootChart包含数据收集工具和图像产生工具，数据收集工具在原始的BootChart中是独立的shell程序，但在Android中，数据收集工具被集成到了init程序中。&lt;br/&gt;以下涉及到的命令，请自行应该参数的path。&lt;/p&gt;&lt;p&gt;&lt;em aria-label=&quot;icon: copy&quot;&gt;&lt;svg viewbox=&quot;64 64 896 896&quot; focusable=&quot;false&quot; data-icon=&quot;copy&quot; fill=&quot;currentColor&quot; aria-hidden=&quot;true&quot;&gt;&lt;path d=&quot;M832 64H296c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8h496v688c0 4.4 3.6 8 8 8h56c4.4 0 8-3.6 8-8V96c0-17.7-14.3-32-32-32zM704 192H192c-17.7 0-32 14.3-32 32v530.7c0 8.5 3.4 16.6 9.4 22.6l173.3 173.3c2.2 2.2 4.7 4 7.4 5.5v1.9h4.2c3.5 1.3 7.2 2 11 2H704c17.7 0 32-14.3 32-32V224c0-17.7-14.3-32-32-32zM350 856.2L263.9 770H350v86.2zM664 888H414V746c0-22.1-17.9-40-40-40H232V264h432v624z&quot;/&gt;&lt;/svg&gt;&lt;/em&gt;&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;cpp&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;do_bootchart_start&lt;/span&gt;&lt;span class=&quot;code-snippet__params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt; &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;   &lt;span class=&quot;code-snippet__built_in&quot;&gt;std&lt;/span&gt;::&lt;span class=&quot;code-snippet__built_in&quot;&gt;string&lt;/span&gt; start;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;   &lt;span class=&quot;code-snippet__keyword&quot;&gt;if&lt;/span&gt; (!android::base::ReadFileToString(&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;/data/bootchart/enabled&quot;&lt;/span&gt;, &amp;amp;start)) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;       LOG(VERBOSE) &amp;lt;&amp;lt; &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;Not bootcharting&quot;&lt;/span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;       &lt;span class=&quot;code-snippet__keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;code-snippet__number&quot;&gt;0&lt;/span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt; }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;   g_bootcharting_thread = &lt;span class=&quot;code-snippet__keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;code-snippet__built_in&quot;&gt;std&lt;/span&gt;::thread(bootchart_thread_main);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;   &lt;span class=&quot;code-snippet__keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;code-snippet__number&quot;&gt;0&lt;/span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;pre&gt;&lt;code&gt;&lt;span/&gt;&lt;br/&gt;&lt;span aria-hidden=&quot;true&quot;/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;所以只要生成/data/bootchart/enabled文件即可&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;properties&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;   &lt;span class=&quot;code-snippet__attr&quot;&gt;adb&lt;/span&gt; &lt;span class=&quot;code-snippet__string&quot;&gt;shell touch /data/bootchart/enabled&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__attr&quot;&gt;adb&lt;/span&gt; &lt;span class=&quot;code-snippet__string&quot;&gt;reboot&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;pre&gt;&lt;code&gt;&lt;span aria-hidden=&quot;true&quot;/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;在设备启动后，提取启动图表：&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;nginx&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__attribute&quot;&gt;adb&lt;/span&gt;  pull /data/bootchart&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;pre&gt;&lt;code&gt;&lt;span aria-hidden=&quot;true&quot;/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;获取到bootchart数据之后进行打包&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;css&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__selector-tag&quot;&gt;tar&lt;/span&gt; &lt;span class=&quot;code-snippet__selector-tag&quot;&gt;-czf&lt;/span&gt; &lt;span class=&quot;code-snippet__selector-tag&quot;&gt;bootchart&lt;/span&gt;&lt;span class=&quot;code-snippet__selector-class&quot;&gt;.tgz&lt;/span&gt; *&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;pre&gt;&lt;code&gt;&lt;span aria-hidden=&quot;true&quot;/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;css&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt; &lt;span class=&quot;code-snippet__selector-tag&quot;&gt;java&lt;/span&gt; &lt;span class=&quot;code-snippet__selector-tag&quot;&gt;-jar&lt;/span&gt; &lt;span class=&quot;code-snippet__selector-tag&quot;&gt;bootchart&lt;/span&gt;&lt;span class=&quot;code-snippet__selector-class&quot;&gt;.jar&lt;/span&gt; &lt;span class=&quot;code-snippet__selector-tag&quot;&gt;bootchart&lt;/span&gt;&lt;span class=&quot;code-snippet__selector-class&quot;&gt;.tgz&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;pre&gt;&lt;code&gt;&lt;span aria-hidden=&quot;true&quot;/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1.5126262626262625&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz/yyLvy204xWibt5Ih0icthSOQgz1XcmYqIwCD87mficBiaIga4ibIkgTicZunJF723jz28IuSSQUkPiaOt0MicIjd20xicgw/640?wx_fmt=other&quot; data-type=&quot;other&quot; data-w=&quot;396&quot;/&gt;&lt;/p&gt;&lt;p&gt;Bootchart.png&lt;/p&gt;&lt;p&gt;从生成的图片可以更加直观详细的看到开机耗时以及硬件使用情况。个人认为，bootchart的分析应该是以PIXEL或者开机速度正常机子的bootchart为参考来对照分析。使用完之后，记得删除enabled文件以防每次开机都收集启动数据。&lt;/p&gt;&lt;h2&gt;&lt;span&gt;&lt;strong&gt;2.3 抓取boottrace&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;抓取开机阶段的trace，也就是boottrace，是一种重要的分析开机的手段。抓取方式如下：&lt;/p&gt;&lt;ol class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;将手机中的atrace.rc拉取下来，并备份；&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;nginx&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt; &lt;span class=&quot;code-snippet__attribute&quot;&gt;adb&lt;/span&gt; pull /system/etc/init/atrace.rc&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;pre&gt;&lt;code&gt;&lt;span aria-hidden=&quot;true&quot;/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;ol start=&quot;2&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;在文件atrace.rc末尾添加&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;sql&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt; on property:persist.debug.atrace.boottrace=1&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;start&lt;/span&gt; boottrace&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    service boottrace /&lt;span class=&quot;code-snippet__keyword&quot;&gt;system&lt;/span&gt;/&lt;span class=&quot;code-snippet__keyword&quot;&gt;bin&lt;/span&gt;/atrace &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    disabled&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    oneshot&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;pre&gt;&lt;code&gt;&lt;span aria-hidden=&quot;true&quot;/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;ol start=&quot;3&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;将修改后的atrace.rc文件push到手机里面&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;perl&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt; adb &lt;span class=&quot;code-snippet__keyword&quot;&gt;push&lt;/span&gt; atrace.rc /&lt;span class=&quot;code-snippet__keyword&quot;&gt;system&lt;/span&gt;/etc/init/&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;pre&gt;&lt;code&gt;&lt;span aria-hidden=&quot;true&quot;/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;ol start=&quot;4&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;打开抓取boottrace的属性开关&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;css&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__selector-tag&quot;&gt;adb&lt;/span&gt;  &lt;span class=&quot;code-snippet__selector-tag&quot;&gt;shell&lt;/span&gt; &lt;span class=&quot;code-snippet__selector-tag&quot;&gt;setprop&lt;/span&gt; &lt;span class=&quot;code-snippet__selector-tag&quot;&gt;persist&lt;/span&gt;&lt;span class=&quot;code-snippet__selector-class&quot;&gt;.debug&lt;/span&gt;&lt;span class=&quot;code-snippet__selector-class&quot;&gt;.atrace&lt;/span&gt;&lt;span class=&quot;code-snippet__selector-class&quot;&gt;.boottrace&lt;/span&gt; 1&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;pre&gt;&lt;code&gt;&lt;span aria-hidden=&quot;true&quot;/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;ol start=&quot;5&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;重启手机&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;手机启动完成之后等待几秒，关闭boottrace属性开关&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;css&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt; &lt;span class=&quot;code-snippet__selector-tag&quot;&gt;adb&lt;/span&gt;  &lt;span class=&quot;code-snippet__selector-tag&quot;&gt;shell&lt;/span&gt; &lt;span class=&quot;code-snippet__selector-tag&quot;&gt;setprop&lt;/span&gt; &lt;span class=&quot;code-snippet__selector-tag&quot;&gt;persist&lt;/span&gt;&lt;span class=&quot;code-snippet__selector-class&quot;&gt;.debug&lt;/span&gt;&lt;span class=&quot;code-snippet__selector-class&quot;&gt;.atrace&lt;/span&gt;&lt;span class=&quot;code-snippet__selector-class&quot;&gt;.boottrace&lt;/span&gt; 0&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;pre&gt;&lt;code&gt;&lt;span aria-hidden=&quot;true&quot;/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;ol start=&quot;8&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;生成boottrace文件&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;bash&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt; adb shell atrace --async_stop -z -c -o /data/&lt;span class=&quot;code-snippet__built_in&quot;&gt;local&lt;/span&gt;/tmp/boot_trace&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;pre&gt;&lt;code&gt;&lt;br/&gt;&lt;span aria-hidden=&quot;true&quot;/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;ol start=&quot;10&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;拉取boottrace日志文件&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;bash&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt; adb  pull /data/&lt;span class=&quot;code-snippet__built_in&quot;&gt;local&lt;/span&gt;/tmp/boot_trace&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;pre&gt;&lt;code&gt;&lt;br/&gt;&lt;span aria-hidden=&quot;true&quot;/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;之后就可以通过分析boot_trace文件来分析了。&lt;/p&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;3. 开机速度优化实践&lt;/span&gt;&lt;span/&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;/section&gt;&lt;p&gt;在Android S升级Android T的过程中，遇到一个开机速度的问题。同一个项目的手机，在升级Android T之后，比之前的开机时间大概要多18秒左右。&lt;br/&gt;首先在手机开机之后，查看boot_progress相关日志如下&lt;/p&gt;&lt;p&gt;&lt;em aria-label=&quot;icon: copy&quot;&gt;&lt;svg viewbox=&quot;64 64 896 896&quot; focusable=&quot;false&quot; data-icon=&quot;copy&quot; fill=&quot;currentColor&quot; aria-hidden=&quot;true&quot;&gt;&lt;path d=&quot;M832 64H296c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8h496v688c0 4.4 3.6 8 8 8h56c4.4 0 8-3.6 8-8V96c0-17.7-14.3-32-32-32zM704 192H192c-17.7 0-32 14.3-32 32v530.7c0 8.5 3.4 16.6 9.4 22.6l173.3 173.3c2.2 2.2 4.7 4 7.4 5.5v1.9h4.2c3.5 1.3 7.2 2 11 2H704c17.7 0 32-14.3 32-32V224c0-17.7-14.3-32-32-32zM350 856.2L263.9 770H350v86.2zM664 888H414V746c0-22.1-17.9-40-40-40H232V264h432v624z&quot;/&gt;&lt;/svg&gt;&lt;/em&gt;&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;07-15 04:13:35.244 I/boot_progress_start( 1059): 4040&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;07-15 04:13:35.934 I/boot_progress_preload_start( 1059): 4730&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;07-15 04:13:37.255 I/boot_progress_preload_end( 1059): 6051&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;07-15 04:13:37.636 I/boot_progress_system_run( 2221): 6432&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;07-15 04:13:38.260 I/boot_progress_pms_start( 2221): 7056&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;07-15 04:13:38.473 I/boot_progress_pms_system_scan_start( 2221): 7269&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;07-15 04:13:38.797 I/boot_progress_pms_data_scan_start( 2221): 7593&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;07-15 04:13:38.803 I/boot_progress_pms_scan_end( 2221): 7599&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;07-15 04:13:38.894 I/boot_progress_pms_ready( 2221): 7690&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;07-15 04:13:58.006 I/boot_progress_ams_ready( 2221): 26802&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;07-15 04:13:59.164 I/boot_progress_enable_screen( 2221): 27960&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;pre&gt;&lt;code&gt;&lt;span/&gt;&lt;br/&gt;&lt;span aria-hidden=&quot;true&quot;/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;发现，在boot_progress_pms_ready到boot_progress_ams_ready之间，耗时近20秒，严重超时。&lt;/p&gt;&lt;p&gt;&lt;br/&gt;确定了大体的耗时异常点之后，我们抓取boottrace再进行进一步的分析。&lt;br/&gt;由于PMS和AMS服务军运行再SystemServer进程当中，所以我们重点关注SystemServer进程的运行情况。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.24416666666666667&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz/yyLvy204xWibt5Ih0icthSOQgz1XcmYqIwVljHzJqblQhibtCBz4KQBAeQCNskdlsQyC6bduVSOriaYKDV84GXNcQA/640?wx_fmt=other&quot; data-type=&quot;other&quot; data-w=&quot;1200&quot;/&gt;&lt;/p&gt;&lt;p&gt;9d055601ad4ebe5eddec1aff0249da2c.png&lt;/p&gt;&lt;p&gt;查看trace文件发现，主要是因为在启动AudioService的时候耗时较长。startService相关的日志也表明了这一点。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.12583333333333332&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz/yyLvy204xWibt5Ih0icthSOQgz1XcmYqIwcOKX0RyoSMm5a01TcpZiaoeiaRfbpXsnWsC0qEYOogAEBAJTR0qDiaARw/640?wx_fmt=other&quot; data-type=&quot;other&quot; data-w=&quot;1200&quot;/&gt;&lt;/p&gt;&lt;p&gt;be264267394792edc34e531924092587.png&lt;/p&gt;&lt;p&gt;&lt;br/&gt;可见，启动AudioService耗时15.5秒左右。通过在AudioService相关的代码里面添加log，最终定位到为AudioService驱动在Android T上的问题。转交Audio模块处理之后，开机时间正常。&lt;/p&gt;&lt;p&gt;&lt;br/&gt;作者：努比亚技术团队&lt;br/&gt;链接：https://www.jianshu.com/p/3f23e027b591&lt;/p&gt;&lt;p&gt;&lt;span&gt;关注我获取更多知识或者投稿&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg wxw-img&quot; data-ratio=&quot;1&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/yyLvy204xW9Uibw4qQxibOBKL1DicLX10o3w57n09uKDowd4ZDjRIgSMUn9cqY6ia77Ys3VfZjG8LUviacGSr0DFIvw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;258&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg wxw-img&quot; data-ratio=&quot;0.20555555555555555&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/yyLvy204xW9Uibw4qQxibOBKL1DicLX10o3gibpbVwAGtDUV15FZianjGs1whAZ2gg71IV6J7zQpQhtQRcSyHrGJbxg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;180&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;mp-style-type data-value=&quot;3&quot;/&gt;&lt;/p&gt;&lt;/div&gt;

          
        &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>373c40958bca02ec0fcc4707f5cb91bb</guid>
<title>为了带你精通 Java AQS，我画了 40 张图</title>
<link>https://toutiao.io/k/jw27omd</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;section&gt;&lt;mp-common-profile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mpprofile&quot; data-weui-theme=&quot;light&quot; data-id=&quot;MzkzMDI1NjcyOQ==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/EoJib2tNvVtf7icAmS0BQH6oDVG37Q8NzcfdguS5qAqOhfxvZyIKqmuX5BbnDjynrBbZzktp1EiaeFLzapp1nHysw/0?wx_fmt=png&quot; data-nickname=&quot;码哥字节&quot; data-alias=&quot;MageByte&quot; data-signature=&quot;拥抱硬核技术和对象，面向人民币编程。&quot; data-from=&quot;0&quot; data-is_biz_ban=&quot;0&quot;/&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;你好，我是码哥，可以叫我靓仔。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Java中 AQS 是 AbstractQueuedSynchronizer 类，AQS 依赖 FIFO 队列来提供一个框架，这个框架用于实现锁以及锁相关的同步器，比如信号量、事件等。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在 AQS 中，主要有两部分功能，一部分是操作 state 变量，第二部分是实现排队和阻塞机制。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;注意，AQS 并没有实现任何同步接口，它只是提供了类似 acquireInterruptible 的方法，调用这些方法可以实现锁和同步器。&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;1 管程模型&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Java 使用 MESA 管程模型来管理类的成员变量和方法，让这个类的成员变量和方法的操作是线程安全的。下图是 MESA 管程模型，里面除了定义共享变量外，还定义了条件变量和条件变量等待队列：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.8402203856749312&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/a1gicTYmvicd8RBmRiak6x8Ylb0ibiazH63vCN0adXw8M6kP0tQqesFDBBnS3hJmnPaO4NHZUY9KDgwhBibjxpsOia02w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;726&quot;/&gt;上图中有三个知识点：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;MESA 管程模型封装了共享变量和对共享变量的操作，线程要进入管程内部，必须获取到锁，如果获取锁失败就进入入口等待队列阻塞等待。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;如果线程获取到锁，就进入到管程内部。但是进入到管程内部，也不一定能立刻操作共享变量，而是要看条件变量是否满足，如果不满足，只能进入条件变量等待队列阻塞等待。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;在条件变量等待队列中，如果被其他线程唤醒，也不一定能立刻操作共享变量，而是需要去入口等待队列重新排队等待获取锁。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Java 中的 MESA 管程模型有一点改进，就是管程内部只有一个条件变量和一个等待队列。下图是 AQS 的管程模型：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.9206680584551148&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/a1gicTYmvicd8RBmRiak6x8Ylb0ibiazH63vCtZq8sVMF2H3kb0exIvzkJIfasro5z1CPuDztGNhbiaaWStFRJtPXgJw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;479&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;AQS 的管程模型依赖 AQS 中的 FIFO 队列实现入口等待队列，要进入管程内部，就由各种并发锁的限制。而 ConditionObject 则实现了条件队列，这个队列可以创建多个。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;下面就从入口等待队列、并发锁、条件等待队列三个方面来带你彻底理解 AQS。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;2 入口等待队列&lt;/span&gt;&lt;/h2&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;2.1 获取独占锁&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;独占, 忽略 interrupts&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;acquire(&lt;span&gt;int&lt;/span&gt; arg)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (!tryAcquire(arg) &amp;amp;&amp;amp;&lt;br/&gt;        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))&lt;br/&gt;        selfInterrupt();&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;span&gt;这里的 tryAcquire 是抽象方法，由 AQS 的子类来实现，因为每个子类实现的锁是不一样的。&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;2.1.1 入队&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上面的代码可以看到，获取锁失败后，会先执行 addWaiter 方法加入队列，然后执行 acquireQueued 方法自旋地获取锁直到成功。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;addWaiter 代码逻辑如下图，简单说就是把 node 入队，入队后返回 node 参数给 acquireQueued 方法：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.4102296450939457&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/a1gicTYmvicd8RBmRiak6x8Ylb0ibiazH63vCuiacDcaicnMzQibhoccfZ67icmmGsSjGPPiaMtAXca4lKaecojQCDpmSLfg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;958&quot;/&gt;&lt;/figure&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;这里有一个点需要注意，如果队列为空，则新建一个 Node 作为队头。&lt;/strong&gt;&lt;/span&gt;&lt;/h4&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;2.1.2 入队后获取锁&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;acquireQueued 自旋获取锁逻辑如下图：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1.0665322580645162&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/a1gicTYmvicd8RBmRiak6x8Ylb0ibiazH63vCy3tiaq1SF5xd3mgduGqpvg5oW6pQTVZDs7MHIUlc6ZSnYfqUTKQ0G3A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;496&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里有几个细节：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;1.waitStatus&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;CANCELLED(1)：当前节点取消获取锁。当等待超时或被中断(响应中断)，会触发变更为此状态，进入该状态后节点状态不再变化；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;SIGNAL(-1)：后面节点等待当前节点唤醒；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;CONDITION(-2)：Condition 中使用，当前线程阻塞在 Condition，如果其他线程调用了 Condition 的 signal 方法，这个结点将从等待队列转移到同步队列队尾，等待获取同步锁；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;PROPAGATE(-3)：共享模式，前置节点唤醒后面节点后，唤醒操作无条件传播下去；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;0：中间状态，当前节点后面的节点已经唤醒，但是当前节点线程还没有执行完成。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;2.获取锁失败后挂起&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果前置节点不是头节点，或者前置节点是头节点但当前节点获取锁失败，这时当前节点需要挂起，分三种情况：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.33858267716535434&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/a1gicTYmvicd8RBmRiak6x8Ylb0ibiazH63vC2fLNBCJbTjvTXPNIvxH8AeDP7p3pOYZFyfVTHF8AqAeXas8qMxRB6A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;508&quot;/&gt;&lt;/figure&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6522491349480969&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/a1gicTYmvicd8RBmRiak6x8Ylb0ibiazH63vCENibFqdkyHhibkdlSuHupI6yOiaBAaSbUqpeKMDKmicFeQGIQVVPialLiaibg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;&quot;/&gt;&lt;/figure&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5515370705244123&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/a1gicTYmvicd8RBmRiak6x8Ylb0ibiazH63vCJuwPBVGuOhA0M35vw96zY0IYkXvHZdZUXPvibDicfOHicVLbKtAiaBZpMA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;553&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;3.取消获取锁&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果获取锁抛出异常，则取消获取锁，如果当前节点是 tail 节点，分两种情况如下图：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1.2297939778129952&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/a1gicTYmvicd8RBmRiak6x8Ylb0ibiazH63vCCjFCKL9TomQhdqMKaeQL7sa7zTKQ2kKf2ibesgDg5L86FIMZ3leAJmA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;631&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果当前节点不是 tail 节点，也分两种情况，如下图：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1.0211081794195251&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/a1gicTYmvicd8RBmRiak6x8Ylb0ibiazH63vCO80CCM4qiax9wMItbb6lMqfKfMcpgV0bFlnEibIJp6Phfp0LRuQ1MQng/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;758&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;4.对中断状态忽略&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;5.如果前置节点的状态是 0 或 PROPAGATE，会被当前节点自旋过程中更新成 -1，以便之后通知当前节点。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;2.1.3 独占 + 响应中断&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;对应方法 acquireInterruptibly(int arg)。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;跟忽略中断(acquire方法)不同的是要响应中断，下面两个地方响应中断：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;获取锁之前会检查当前线程是否中断。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;获取锁失败入队，在队列中自旋获取锁的过程中也会检查当前线程是否中断。如果检查到当前线程已经中断，则抛出 InterruptedException，当前线程退出。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;2.1.4 独占 + 响应中断 + 考虑超时&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;对应方法 tryAcquireNanos(int arg, long nanosTimeout)。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个方法具备了独占 + 响应中断 + 超时的功能，下面2个地方要判断是否超时：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;自旋获取锁的过程中每次获取锁失败都要判断是否超时;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;获取锁失败 park 之前要判断超时时间是否大于自旋的阈值时间 (spinForTimeoutThreshold = 1ns)
另外，park 线程的操作使用 parkNanos 传入阻塞时间。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;2.2 释放独占锁&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;独占锁释放分两步：释放锁，唤醒后继节点。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;释放锁的方法 tryRelease 是抽象的，由子类去实现。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们看一下唤醒后继节点的逻辑，首先需要满足两个条件：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;head 节点不等于 null;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;head 节点 waitStatus 不等于 0。这里有两种情况(在方法 unparkSuccessor)：&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;情况一，后继节点 waitStatus &amp;lt;= 0，直接唤醒后继节点，如下图：&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.9932432432432432&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/a1gicTYmvicd8RBmRiak6x8Ylb0ibiazH63vC4fsAt59lEUVueNMia64PpbCtbIicHRsDjuTVaaH2ANFFjs8aNcYFpJpQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;296&quot;/&gt;&lt;/figure&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;情况二：后继节点为空或者 waitStatus &amp;gt; 0，从后往前查找最接近当前节点的节点进行唤醒，如下图：&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.846820809248555&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/a1gicTYmvicd8RBmRiak6x8Ylb0ibiazH63vCvT6LTKJpfptP5Gic4PwibPq1uepSYFxUejAEfSckian2IrUeRTbazZaKg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;346&quot;/&gt;&lt;/figure&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;2.3 获取共享锁&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;之前我们讲了独占锁，这一小节我们谈共享锁，有什么不同呢？&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;2.3.1 共享，忽略 interrupts&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;对应方法 acquireShared，代码如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;acquireShared(&lt;span&gt;int&lt;/span&gt; arg)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (tryAcquireShared(arg) &amp;lt; &lt;span&gt;0&lt;/span&gt;)&lt;br/&gt;        doAcquireShared(arg);&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;2.3.2 tryAcquireShared&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里获取锁使用的方法是 tryAcquireShared，获取的是共享锁。获取共享锁跟获取独占锁不同的是，会返回一个整数值，说明如下:&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;返回负数：获取锁失败。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;返回 0：获取锁成功但是之后再由线程来获取共享锁时就会失败。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;返回正数:获取锁成功而且之后再有线程来获取共享锁时也可能会成功。所以需要把唤醒操作传播下去。tryAcquireShared 获取锁失败后(返回负数)，就需要入队后自旋获取，也就是执行方法 doAcquireShared。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;2.3.3 doAcquireShared&lt;/h4&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;怎么判断队列中等待节点是在等待共享锁呢？nextWaiter == SHARED，这个参数值是入队新建节点的时候构造函数传入的。&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;自旋过程中，如果获取锁成功(返回正数)，首先把自己设置成新的 head 节点，然后把通知传播下去。如下图：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.9353932584269663&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/a1gicTYmvicd8RBmRiak6x8Ylb0ibiazH63vC6Kz238PdKp39o35ZZZoX68ouEjtzUs5N3PFvTtlfNShQTKFJfYMYjg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;356&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;之后会唤醒后面节点并保证唤醒操作可以传播下去。但是需要满足四个条件中的一个：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;tryAcquireShared 返回值大于0，有多余的锁，可以继续唤醒后继节点。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;旧的 head 节点 waitStatus &amp;lt; 0，应该是其他线程释放共享锁过程中把它的状态更新成了 -3。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;新的 hade 节点 waitStatus &amp;lt; 0，只要不是 tail 节点，就可能是 -1。&lt;strong&gt;&lt;span&gt;这里会造成不必要的唤醒，因为唤醒后获取不到锁只能继续入队等待。&lt;/span&gt;&lt;/strong&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;当前节点的后继节点是空或者非空但正在等待共享锁。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;唤醒后面节点的操作，其实就是释放共享锁，对应方法是 doReleaseShared，见释放共享锁一节。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;2.3.4 共享 + 响应中断&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;对应方法 acquireSharedInterruptibly(int arg)。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;跟共享忽略中断(acquireShared 方法)不同的是要响应中断，下面两个地方响应中断：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;获取锁之前会检查当前线程是否中断。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;获取锁失败入队，在队列中自旋获取锁的过程中也会检查当前线程是否中断。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果检查到当前线程已经中断，则抛出 InterruptedException，当前线程退出。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;2.3.5 共享 + 响应中断 + 考虑超时&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;对应方法 tryAcquireSharedNanos(int arg, long nanosTimeout)。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个方法具备了共享 + 响应中断 + 超时的功能，下面两个个地方要判断是否超时：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;自旋获取锁的过程中每次获取锁失败都要判断是否超时。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;获取锁失败 park 之前要判断超时时间是否大于自旋的阈值时间(spinForTimeoutThreshold = 1ns)。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;另外，park 线程的操作使用 parkNanos 传入阻塞时间。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;2.4 释放共享锁&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;释放共享锁代码如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; &lt;span&gt;releaseShared(&lt;span&gt;int&lt;/span&gt; arg)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (tryReleaseShared(arg)) {&lt;br/&gt;        doReleaseShared();&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;;&lt;br/&gt;    }&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;首先尝试释放共享锁，tryReleaseShared 代码由子类来实现。释放成功后执行AQS中的 doReleaseShared 方法，是一个自旋操作。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;自旋的条件是队列中至少有两个节点，这里分三种情况。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;情况一：当前节点 waitStatus 是 -1，如下图：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6193078324225865&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/a1gicTYmvicd8RBmRiak6x8Ylb0ibiazH63vCREweYZseDwkVFUs6N7348RAaapz5emUuRibml22ypxVFqgibOJWrbhnQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;549&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;情况二：当前节点 waitStatus 是 0(被其他线程更新新成了中间状态)，如下图：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6355353075170843&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/a1gicTYmvicd8RBmRiak6x8Ylb0ibiazH63vCpajxDystI9q1fiasjEMk1sJbPxxM62SkXxhRpSA2mwzQkIkkvVeGtrQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;439&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;情况三：当前节点 waitStatus 是 -3，为什么会这样呢？&lt;strong&gt;&lt;span&gt;需要解释一下，head节点唤醒后继节点之前 waitStatus 已经被更新中间态 0 了，唤醒后继节点动作还没有执行，又被其他线程更成了 -3，也就是其他线程释放锁执行了上面情况二。&lt;/span&gt;&lt;/strong&gt;这时需要先把 waitStatus 再更成 0 (在方法 unparkSuccessor)，如下图：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.8227513227513228&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/a1gicTYmvicd8RBmRiak6x8Ylb0ibiazH63vCfaDdIcosSYn81e3ibBd0m9pl1ZY8yJy5dPWpHrNLcLZpSyicQ1icGeTnA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;378&quot;/&gt;&lt;/figure&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;2.5 抽象方法&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上面的讲解可以看出，如果要基于 AQS 来实现并发锁，可以根据需求重写下面四个方法来实现，这四个方法在 AQS 中没有具体实现：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;tryAcquire(int arg)：获取独占锁&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;tryRelease(int arg)：释放独占锁&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;tryAcquireShared(int arg)：获取共享锁&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;tryReleaseShared(int arg)：释放共享锁&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;AQS 的子类需要重写上面的方法来修改 state 值，并且定义获取锁或者释放锁时 state 值的变化。子类也可以定义自己的 state 变量，但是只有更新 AQS 中的 state变量才会对同步起作用。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;还有一个判断当前线程是否持有独占锁的方法 isHeldExclusively，也可以供子类重写后使用。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;获取/释放锁的具体实现放到下篇文章讲解。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;2.6 总结&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;AQS 使用 FIFO 队列实现了一个锁相关的并发器模板，可以基于这个模板来实现各种锁，包括独占锁、共享锁、信号量等。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;AQS 中，有一个核心状态是 waitStatus，这个代表节点的状态，决定了当前节点的后续操作，比如是否等待唤醒，是否要唤醒后继节点。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;3 并发锁&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这一章节讲解 Java AQS 中的并发锁。其实 Java AQS 中的并发锁主要是基于 state 这个变量值来实现的。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;3.1 ReentrantLock&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们先来看一下 UML 类图：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.546831955922865&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/a1gicTYmvicd8RBmRiak6x8Ylb0ibiazH63vCMtFzkPK8aeicibPMZT17Up97wKRJXIskjLAtnvZkaoRnjQ2UaVqmWXTw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;726&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;从图中可以看到，ReentrantLock 使用抽象内部类 Sync 来实现了 AQS 的方法，然后基于 Sync 这个同步器实现了公平锁和非公平锁。主要实现了下面 3 个方法：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;tryAcquire(int arg)：获取独占锁&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;tryRelease(int arg)：释放独占锁&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;isHeldExclusively：当前线程是否占有独占锁。&lt;strong&gt;&lt;span&gt;ReentrantLock 默认实现的是非公平锁，可以在构造函数指定。&lt;/span&gt;&lt;/strong&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;从实现的方法可以看到，ReentrantLock 中获取的锁是独占锁，我们再来看一下获取和释放独占锁的代码：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;acquire(&lt;span&gt;int&lt;/span&gt; arg)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (!tryAcquire(arg) &amp;amp;&amp;amp;&lt;br/&gt;        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))&lt;br/&gt;        selfInterrupt();&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;独占锁的特点是调用上面 acquire 方法，传入的参数是 1。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;3.1.1 获取公平锁&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;获取锁首先判断同步状态(state)的值。&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;3.1.1.1 state 等于 0&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这说明没有线程占用锁，当前线程如果符合下面两个条件，就可以获取到锁：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;没有前任节点，如下图：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.710955710955711&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/a1gicTYmvicd8RBmRiak6x8Ylb0ibiazH63vCEpMiaa6FWkAhKeBOFDK6ZWRfQybNv5nbN3DXRAXbtPiaAjGWjsUruGJg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;429&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;CAS 的方式更新 state 值(把 0 更新成 1)成功。&lt;strong&gt;&lt;span&gt;如果获取独占锁成功，会更新 AQS 中 exclusiveOwnerThread 为当前线程，这个很容易理解。&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;3.1.1.2 state 不等于 0&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这说明已经有线程占有锁，判断占有锁的线程是不是当前线程，如下图：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.521311475409836&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/a1gicTYmvicd8RBmRiak6x8Ylb0ibiazH63vC5tGTDhQw6cjoMYzzcrcO5j5jMLgRQAGw4ficlS9kKKYjZhCMMFm9SAw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;610&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;span&gt;state += 1 值如果小于 0，会抛出异常。&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果获取锁失败，则进入 AQS 队列等待唤醒。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;3.1.2 获取非公平锁&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;跟公平锁相比，非公平锁的唯一不同是如果判断到 state 等于 0，不用判断有没有前任节点，只要 CAS 设置 state 值(把 0 更新成 1)成功，就获取到了锁。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;3.1.3 释放锁&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;公平锁和非公平锁，释放逻辑完全一样，都是在内部类 Sync 中实现的。释放锁需要注意两点，如下图：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5576592082616179&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/a1gicTYmvicd8RBmRiak6x8Ylb0ibiazH63vCkjQnzViaDHAFaSSD5A40rISiaEia4z5XJCQD1IX8k4u7saPBaicuHayr1w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;581&quot;/&gt;&lt;/figure&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;为什么 state 会大于 1，因为是可以重入的，占有锁的线程可以多次获取锁。&lt;/strong&gt;&lt;/span&gt;&lt;/h4&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;3.1.4 总结&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;公平锁的特点是每个线程都要进行排队，不用担心线程永远获取不到锁，但有个缺点是每个线程入队后都需要阻塞和被唤醒，这一定程度上影响了效率。非公平锁的特点是每个线程入队前都会先尝试获取锁，如果获取成功就不会入队了，这比公平锁效率高。但也有一个缺点，队列中的线程有可能等待很长时间，高并发下甚至可能永远获取不到锁。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;3.2 ReentrantReadWriteLock&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们先来看一下 UML 类图：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.4488752556237219&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/a1gicTYmvicd8RBmRiak6x8Ylb0ibiazH63vCkZXnPPl9B0cJuI4Qbq8R8NbepV6YibsRpbR7nPTxq8C4lVHLiczy7JaQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;978&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;从图中可以看到，ReentrantReadWriteLock 使用抽象内部类Sync来实现了 AQS 的方法，然后基于 Sync 这个同步器实现了公平锁和非公平锁。主要实现了下面 3 个方法：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;tryAcquire(int arg)：获取独占锁&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;tryRelease(int arg)：释放独占锁&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;tryAcquireShared(int arg)：获取共享锁&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;tryReleaseShared(int arg)：释放共享锁&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;isHeldExclusively：当前线程是否占有独占锁
可见ReentrantReadWriteLock里面同时用到了共享锁和独占锁。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;下图是定义的几个常用变量：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.30864197530864196&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/a1gicTYmvicd8RBmRiak6x8Ylb0ibiazH63vC78z1dkdErYHnqEMuCG2LG03jicNpDgYm5VAeaSNZU6tY9tibCNwbbEibw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;891&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;下面这 2 个方法用户获取共享锁和独占锁的数量：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; &lt;span&gt;sharedCount(&lt;span&gt;int&lt;/span&gt; c)&lt;/span&gt;    &lt;/span&gt;{ &lt;span&gt;return&lt;/span&gt; c &amp;gt;&amp;gt;&amp;gt; SHARED_SHIFT; }&lt;br/&gt;&lt;span&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; &lt;span&gt;exclusiveCount(&lt;span&gt;int&lt;/span&gt; c)&lt;/span&gt; &lt;/span&gt;{ &lt;span&gt;return&lt;/span&gt; c &amp;amp; EXCLUSIVE_MASK; }&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;从sharedCount 可以看到，共享锁的数量要右移 16 位获取，也就是说共享锁占了高 16 位。从上图 EXCLUSIVE_MASK 的定义看到，跟 EXCLUSIVE_MASK 进行与运算，得到的是低 16 位的值，所以独占锁占了低 16 位。如下图：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.2438563327032136&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/a1gicTYmvicd8RBmRiak6x8Ylb0ibiazH63vCXyFwWMee7Q8ibURbSrxTF9UleaAS7qDzSCnkop3LyUrTczCSWRyCicMw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1058&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这样上面获取锁数量的方法就很好理解了。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;3.2.1 读锁&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;读锁的实现对应内部类 ReadLock。&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;3.2.1.1 获取读锁&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;获取读锁实际上是 ReadLock 调用了 AQS 的下面方法,传入参数是 1：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;acquireShared(&lt;span&gt;int&lt;/span&gt; arg)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (tryAcquireShared(arg) &amp;lt; &lt;span&gt;0&lt;/span&gt;)&lt;br/&gt;        doAcquireShared(arg);&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;ReentrantReadWriteLock 内部类 Sync 实现了 tryAcquireShared 方法，主要包括如下三种情况：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;使用 exclusiveCount 方法查看 state 中是否有独占锁，如果有并且独占线程不是当前线程，返回 -1，获取失败;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;使用 sharedCount 查看 state 中共享锁数量，如果读锁数量小于最大值(MAX_COUNT=65535)，则再满足下面 3 个条件就可以获取成功并返回 1：&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;a.当前线程不需要阻塞(readerShouldBlock)。在公平锁中，需要判断是否有前置节点，如下图就需要阻塞:&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.4383561643835616&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/a1gicTYmvicd8RBmRiak6x8Ylb0ibiazH63vC76ceFIoFMt6Jq7aqrlUOJJ18fbyAxxnR9ictricJsWQOmibObNiaHeibpdA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;292&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在非公平锁中，则是判断第一个节点是不是有独占锁，如下图就需要阻塞:&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.41348973607038125&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/a1gicTYmvicd8RBmRiak6x8Ylb0ibiazH63vC1vKusnbhSGOeU4GlsDKiaJcGeRNM42Nklx6vEcmgFcs5FABJg4AOeLg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;341&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;b.使用 CAS 把 state 的值加 SHARED_UNIT(65536)。&lt;strong&gt;&lt;span&gt;这里是不是就更理解读锁占高位的说法了，获取一个读锁，state 的值就要加 SHARED_UNIT 这么多个。&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;c.给当前线程的 holdCount 加 1。&lt;/p&gt;&lt;ol start=&quot;3&quot; data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;如果 2 失败，自旋，重复上面的步骤直到获取到锁。tryAcquireShared (获取共享锁)会返回一个整数，如下：&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;返回负数：获取锁失败。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;返回 0：获取锁成功但是之后再由线程来获取共享锁时就会失败。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;返回正数:获取锁成功而且之后再有线程来获取共享锁时也可能会成功。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;3.2.1.2 释放读锁&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;ReentrantReadWriteLock 释放读锁是在 ReadLock 中调用了 AQS 下面方法，传入的参数是1：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; &lt;span&gt;releaseShared(&lt;span&gt;int&lt;/span&gt; arg)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (tryReleaseShared(arg)) {&lt;br/&gt;        doReleaseShared();&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;;&lt;br/&gt;    }&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;ReentrantReadWriteLock 内部类 Sync 实现了 releaseShared 方法，具体逻辑分为下面两步：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;当前线程 holdCounter 值减 1。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;CAS的方式将 state 的值减去 SHARED_UNIT。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;3.2.2 写锁&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;写锁的实现对应内部类 WriteLock。&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;3.2.2.1 获取写锁&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;ReentrantReadWriteLock 获取写锁其实是在 WriteLock 中调用了 AQS 的下面方法，传入参数 1：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;acquire(&lt;span&gt;int&lt;/span&gt; arg)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (!tryAcquire(arg) &amp;amp;&amp;amp;&lt;br/&gt;        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))&lt;br/&gt;        selfInterrupt();&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在ReentrantReadWriteLock 内部类 Sync 实现了 tryAcquire 方法，首先获取 state 值和独占锁数量(exclusiveCount),之后分如下两种情况，如下图：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1.0620608899297423&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/a1gicTYmvicd8RBmRiak6x8Ylb0ibiazH63vCpz8St7ekLYScOGp07tfrECiaN5ibWFv9o4j3iaXiaH1MfBcZWwdA86UdSg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;854&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;1.state 不等于 0:&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;独占锁数量等于 0，这时说明有线程占用了共享锁，如果当前线程不是独占线程，获取锁失败。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;独占锁数量不等于 0，独占锁数量加 1 后大于 MAX_COUNT，获取锁失败。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;上面 2 种情况不符合，获取锁成功，state 值加 1。2.state 等于 0，判断当前线程是否需要阻塞(writerShouldBlock)。&lt;strong&gt;&lt;span&gt;在公平锁中，跟 readerShouldBlock 的逻辑完全一样，就是判断队列中 head 节点的后继节点是不是当前线程。在非公平锁中，直接返回 false，即可以直接尝试获取锁。&lt;/span&gt;&lt;/strong&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果当前线程不需要阻塞，并且给 state 赋值成功，使用 CAS 方式把 state 值加 1，把独占线程置为当前线程。&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;3.2.2.2 释放写锁&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;ReentrantReadWriteLock 释放写锁其实是在 WriteLock 中调用了 AQS 的下面方法，传入参数 1：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; &lt;span&gt;release(&lt;span&gt;int&lt;/span&gt; arg)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (tryRelease(arg)) {&lt;br/&gt;        Node h = head;&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (h != &lt;span&gt;null&lt;/span&gt; &amp;amp;&amp;amp; h.waitStatus != &lt;span&gt;0&lt;/span&gt;)&lt;br/&gt;            unparkSuccessor(h);&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;;&lt;br/&gt;    }&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;ReentrantReadWriteLock 在 Sync 中实现了 tryRelease(arg) 方法，逻辑如下：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;判断当前线程是不是独占线程，如果不是，抛出异常。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;state值减1后，用新state值判断独占锁数量是否等于0&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;如果等于0，则把独占线程置为空，返回true，这样上面的代码就可以唤醒队列中的后置节点了&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;如果不等于0，返回false，不唤醒后继节点。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;3.3 CountDownLatch&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们先来看一下UML类图：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6170798898071626&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/a1gicTYmvicd8RBmRiak6x8Ylb0ibiazH63vC3CpOjsZyYxKlG8UiaoHTXjWGkpfvgJHib1FhrG6GtACaKia23QJLiacqBg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;363&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;从上面的图中看出，CountDownLatch 的内部类 Sync 实现了获取共享锁和释放共享锁的逻辑。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;使用 CountDownLatch 时，构造函数会传入一个 int 类型的参数 count，表示调动 count 次的 countDown 后主线程才可以被唤醒。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;CountDownLatch(&lt;span&gt;int&lt;/span&gt; count)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (count &amp;lt; &lt;span&gt;0&lt;/span&gt;) &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; IllegalArgumentException(&lt;span&gt;&quot;count &amp;lt; 0&quot;&lt;/span&gt;);&lt;br/&gt;    &lt;span&gt;this&lt;/span&gt;.sync = &lt;span&gt;new&lt;/span&gt; Sync(count);&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上面的 Sync(count) 就是将 AQS 中的 state 赋值为 count。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;3.3.1 await&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;CountDownLatch 的 await 方法调用了 AQS 中的 acquireSharedInterruptibly(int arg)，传入参数 1，不过这个参数并没有用。代码如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;acquireSharedInterruptibly(&lt;span&gt;int&lt;/span&gt; arg)&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;throws&lt;/span&gt; InterruptedException &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (Thread.interrupted())&lt;br/&gt;        &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; InterruptedException();&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (tryAcquireShared(arg) &amp;lt; &lt;span&gt;0&lt;/span&gt;)&lt;br/&gt;        doAcquireSharedInterruptibly(arg);&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Sync 中实现了 tryAcquireShared 方法，await 逻辑如下图：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.8206349206349206&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/a1gicTYmvicd8RBmRiak6x8Ylb0ibiazH63vCEyyDa93HIS0k5Ue04A4JzuMLEaR2jQXMrtpLZnjHqZgtvoh49xPL2Q/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;630&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上面的自旋过程就是等待 state 的值不断减小，只有 state 值成为 0 的时候，主线程才会跳出自旋执行之后的逻辑。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;3.3.2 countDown&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;CountDownLatch 的 countDown 方法调用了 AQS 的 releaseShared(int arg)，传入参数 1，不过这个参数并没有用。内部类 Sync 实现了 tryReleaseShared 方法，逻辑如下图：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.8420398009950248&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/a1gicTYmvicd8RBmRiak6x8Ylb0ibiazH63vCVtrAibTolwa1f8yicvfSMshj9T0ia23unAYf4bibSfFTIlec0hJ6lH8niaw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;804&quot;/&gt;&lt;/figure&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;3.3.3 总结&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;CountDownLatch 的构造函数入参值会赋值给 state 变量，入队操作是主线程入队，每个子线程调用了countDown 后 state 值减 1，当 state 值成为 0 后唤醒主线程。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;3.4 Semaphore&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Semaphore 是一个信号量，用来保护共享资源。如果线程要访问共享资源，首先从 Semaphore 获取锁(信号量)，如果信号量的计数器等于 0，则当前线程进入 AQS 队列阻塞等待。否则，线程获取锁成功，信号量减 1。使用完共享资源后，释放锁(信号量加 1)。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Semaphore 跟管程模型不一样的是，允许多个(构造函数的 permits)线程进入管程内部，因此也常用它来做限流。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;UML 类图如下：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5350877192982456&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/a1gicTYmvicd8RBmRiak6x8Ylb0ibiazH63vC664k0Z9HbiahWy0OrLnH6Pwhx4KILH0agAsMx7JR9YwAxflyicqwXCdQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;684&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Semaphore的构造函数会传入一个int类型参数，用来初始化state的值。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;3.4.1 acquire&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;获取锁的操作调用了 AQS 中的 acquireSharedInterruptibly 方法，传入参数 1，代码见 CountDownLatch 中 await 小节。Semaphore 在公平锁和非公平锁中分别实现了 tryAcquireShared 方法。&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;3.4.1.1 公平锁&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Semaphore 默认使用非公平锁，如果使用公平锁，需要在构造函数指定。获取公平锁逻辑比较简单，如下图：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.8273736128236745&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/a1gicTYmvicd8RBmRiak6x8Ylb0ibiazH63vCz13l5gr3LibMtmsR5l04NvT7ex0MSeIX2TKjOO533ia5klhDQmFib6nyA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;811&quot;/&gt;&lt;/figure&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;3.4.1.2 非公平锁&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;acquire 在非公平的锁唯一的区别就是不会判断 AQS 队列是否有前置节点(hasQueuedPredecessors)，而是直接尝试获取锁。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;span&gt;除了 acquire 方法外，还有其他几个获取锁的方法，原理类似，只是调用了 AQS 中的不同方法。&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;3.4.2 release&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;释放锁的操作调用了 AQS 中的 releaseShared(int arg) 方法，传入参数 1，在内部类 Sync 中实现了 tryReleaseShared 方法，逻辑很简单：使用 CAS 的方式将 state 的值加 1，之后唤醒队列中的后继节点。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;3.5 ThreadPoolExecutor&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;ThreadPoolExecutor 中也用到了 AQS，看下面的 UML 类图：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.511520737327189&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/a1gicTYmvicd8RBmRiak6x8Ylb0ibiazH63vCicITCjAMgIYTzMcr7KnFsziaTKUia3CRctJKtLWMavC4DHN7ptNtAiazPg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;434&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Worker 主要在 ThreadPoolExecutor 中断线程的时候使用。Worker 自己实现了独占锁，在中断线程时首先进行加锁，中断操作后释放锁。按照官方说法，这里不直接使用 ReentrantLock 的原因是防止调用控制线程池的方法(类似 setCorePoolSize)时能够重新获取到锁，&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;3.5.1 tryAcquire&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;使用 CAS 的方式把 AQS 中 state 从 0 改为 1，把当前线程置为独占线程。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;3.5.2 tryRelease&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;把独占线程置为空，把 AQS 中 state 改为 0。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;span&gt;Worker 初始化的时候会把 state 置为 -1，这样是不能获取锁成功的。只有调用了 runWorker 方法，才会通过释放锁操作把 state 更为 0。这样保证了只中断运行中的线程，而不会中断等待中的线程。&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;3.6 总结&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;AQS 基于双向队列实现了入口等待队列，基于 state 变量实现了各种并发锁，上篇文章讲了入口等待队列，而这篇文章主要讲了基于 AQS 的并发锁原理。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;4 条件变量等待队列&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;本章节主要讲解管程模型中条件变量等待队列。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;4.1 官方示例&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;首先我们看一下官方给出的示例代码：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;BoundedBuffer&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;final&lt;/span&gt; Lock lock = &lt;span&gt;new&lt;/span&gt; ReentrantLock();&lt;br/&gt;    &lt;span&gt;final&lt;/span&gt; Condition notFull  = lock.newCondition();&lt;br/&gt;    &lt;span&gt;final&lt;/span&gt; Condition notEmpty = lock.newCondition();&lt;br/&gt;    &lt;span&gt;final&lt;/span&gt; Object[] items = &lt;span&gt;new&lt;/span&gt; Object[&lt;span&gt;100&lt;/span&gt;];&lt;br/&gt;    &lt;span&gt;int&lt;/span&gt; putptr, takeptr, count;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;put(Object x)&lt;/span&gt; &lt;span&gt;throws&lt;/span&gt; InterruptedException &lt;/span&gt;{&lt;br/&gt;        lock.lock();&lt;br/&gt;        &lt;span&gt;try&lt;/span&gt; {&lt;br/&gt;            &lt;span&gt;while&lt;/span&gt; (count == items.length)&lt;br/&gt;                notFull.await();&lt;br/&gt;            items[putptr] = x;&lt;br/&gt;            &lt;span&gt;if&lt;/span&gt; (++putptr == items.length) putptr = &lt;span&gt;0&lt;/span&gt;;&lt;br/&gt;            ++count;&lt;br/&gt;            notEmpty.signal();&lt;br/&gt;        } &lt;span&gt;finally&lt;/span&gt; {&lt;br/&gt;            lock.unlock();&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; Object &lt;span&gt;take()&lt;/span&gt; &lt;span&gt;throws&lt;/span&gt; InterruptedException &lt;/span&gt;{&lt;br/&gt;        lock.lock();&lt;br/&gt;        &lt;span&gt;try&lt;/span&gt; {&lt;br/&gt;            &lt;span&gt;while&lt;/span&gt; (count == &lt;span&gt;0&lt;/span&gt;)&lt;br/&gt;                notEmpty.await();&lt;br/&gt;            Object x = items[takeptr];&lt;br/&gt;            &lt;span&gt;if&lt;/span&gt; (++takeptr == items.length) takeptr = &lt;span&gt;0&lt;/span&gt;;&lt;br/&gt;            --count;&lt;br/&gt;            notFull.signal();&lt;br/&gt;            &lt;span&gt;return&lt;/span&gt; x;&lt;br/&gt;        } &lt;span&gt;finally&lt;/span&gt; {&lt;br/&gt;            lock.unlock();&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个代码定义了两个条件变量，notFull 和 notEmpty，说明如下：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;如果 items 数组已经满了，则 notFull 变量不满足，线程需要进入 notFull 条件等待队列进行等待。当 take 方法取走一个数组元素时，notFull 条件满足了，唤醒 notFull 条件等待队列中等待线程。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;如果 items 数组为空，则 notEmpty 变量不满足，线程需要进入 notEmpty 条件等待队列进行等待。当 put 方法加入一个数组元素时，notEmpty 条件满足了，唤醒 notEmpty 条件等待队列中等待线程。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;条件变量是绑定在 Lock 上的，示例代码使用了 ReentrantLock。在执行 await 和 signal 方法时首先要获取到锁。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;4.2 原理简介&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Java AQS 的条件变量等待队列是基于接口 Condition 和 ConditionObject 来实现的，URM 类图如下：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.47752808988764045&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/a1gicTYmvicd8RBmRiak6x8Ylb0ibiazH63vCqJDOCKG13WyeqZYjlDd2z011T3nhV1qv4j36GD5p78xq8iaVvIqhkQA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;534&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Condition 接口主要定义了下面3个方法：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;await：进入条件等待队列&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;signal：唤醒条件等待队列中的元素&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;signalAll：唤醒条件等待队列中的所有元素&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;4.3 await&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;条件等待队列跟入口等待队列有两个不同：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;虽然二者共用了 Node 类，但是条件等待队列是单向队列，入口等待队列是双向队列，条件队列中下一个节点的引用是 nextWaiter，入口等待队列中下一个节点的引用是 next。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;条件等待队列中元素的 waitStatus 必须是 -2。await 方法的流程如下图：&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6977491961414791&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/a1gicTYmvicd8RBmRiak6x8Ylb0ibiazH63vCXRibOpSa2h0y90CTlvy4t6nQ9UUDlrBdRTgpmKR5Lr1vBWaOSyeTtRQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;622&quot;/&gt;&lt;/figure&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;4.3.1 进入条件等待队列&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;入队方法对应方法 addConditionWaiter，这里有三种情况：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1.4785714285714286&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/a1gicTYmvicd8RBmRiak6x8Ylb0ibiazH63vCktQTJ2bTV25g2YJ3uxcEj10ZiaqAoPGS6E6sGPeDI7jFn9yRiaY0S4Gg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;140&quot;/&gt;&lt;/figure&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;队列非空，最后一个元素的 waitStatus 是 -2，如下图：&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6442307692307693&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/a1gicTYmvicd8RBmRiak6x8Ylb0ibiazH63vCHY9Lq7j5sicIINiaYOz4U4icsV0bKWdxJTam7H5sJBoBZnWgibtHLiaS00w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;520&quot;/&gt;&lt;/figure&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;队列非空，最后一个元素的 waitStatus 不是 -2，如下图：&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.7260940032414911&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/a1gicTYmvicd8RBmRiak6x8Ylb0ibiazH63vCcUDeVQawDEx6e4ULSPDWnPbicp0fHyuNyOYHj0AoA9FZy19YOG4yFpg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;617&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可以看到，这种情况会从队列第一个元素开始检查 waitStatus 不是 -2 的元素，并从队列中移除。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;4.3.2 释放锁&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;AQS 的并发锁是基于 state 变量实现的，线程进入条件等待队列后，要释放锁，即 state 会变为 0，释放操作会唤醒入口等待队列中的线程。对应方法 fullyRelease，返回值是释放锁减掉的 state 值 savedState。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;4.3.3 阻塞等待&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;释放锁后，线程阻塞，自旋等待被唤醒。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;4.3.4 唤醒之后&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;唤醒之后，当前线程主要有四个动作：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;转入入口等待队列，并把 waitStatus 改为 0。&lt;strong&gt;&lt;span&gt;waitStatus 等于 0 表示中间状态，当前节点后面的节点已经唤醒，但是当前节点线程还没有执行完成。&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;重新获取锁，如果获取成功，则当前线程成为入口等待队列头结点，interruptMode 置为 1。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;如果当前节点在条件等待队列中有后继节点，则剔除条件等待队列中 waitStatus!=-2 的节点，即队列中状态为取消的节点。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;interruptMode 如果不等于 0，则处理中断。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;4.3.5 一个细节&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上面提到了 interruptMode，这个属性有三个值：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;0：没有被中断&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;-1：中断后抛出 InterruptedException，这种情况是当前线程阻塞，没有被 signal 之前发生了中断&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;1：重新进入中断状态，这种情况是指当前线程阻塞，被 signal 之后发生了中断&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;4.3.6 扩展&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;AQS 还提供了其他几个 await 方法，如下：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;awaitUninterruptibly：不用处理中断。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;awaitNanos：自旋等待唤醒过程中有超时时间限制，超时则转入入口等待队列。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;awaitUntil：自旋等待唤醒过程中有截止时间，时间到则转入入口等待队列。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;4.4 signal&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;唤醒条件等待队列中的元素，首先判断当前线程是否持有独占锁，如果没有，抛出异常。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;唤醒条件队列中的元素，会从第一个元素也就是 firstWaiter 开始，根据 firstWaiter 的 waitStatus 是不是 -2，分两种情况。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;4.4.1 waitStatus==-2&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;条件队列第一个节点进入入口等待队列，等待获取锁，如下图：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1.1797235023041475&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/a1gicTYmvicd8RBmRiak6x8Ylb0ibiazH63vCurolzsJ10pKXXZaUra4YAzjWibvcXRyb20VxxYsGl2tice9cibbY8xvAQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;651&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里有两个注意点：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;如果入口等待队列中 tail 节点的 waitStatus 小于等于 0，则 firstWaiter 加入后需要把旧 tail 节点置为 -1 (表示后面节点等待当前节点唤醒)，如下图：&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1.2804314329738058&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/a1gicTYmvicd8RBmRiak6x8Ylb0ibiazH63vCicTyX4JUTesLqgTBXVUBcHbayLcnIC6iaHKckgvmyZJ15OPszrn9uC8g/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;649&quot;/&gt;&lt;/figure&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;如果重置 waitStatus 状态失败,则 unpark 节点 firstWaiter。&lt;/span&gt;&lt;/strong&gt;&lt;/section&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;如果入口等待队列中 tail 节点的 waitStatus 大于 0，则 unpark 节点 firstWaiter。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;4.4.2 waitStatus!=-2&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果 firstWaiter 的 waitStatus 不等于 -2，则查找 firstWaiter 的 nextWaiter，直到找到一个 waitStatus 等于 -2 的节点，然后将这个节点加入入口等待队列队尾，如下图：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1.194267515923567&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/a1gicTYmvicd8RBmRiak6x8Ylb0ibiazH63vCILR5Y7lRxbZCicCeribGwcWovea3pgbGcqPaPjzgmU2Q5CXrvHmO8aibw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;628&quot;/&gt;&lt;/figure&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;4.4.3 waitStatus 修改&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上面的两种情况无论哪种，进入入口等待队列之前都要用 CAS 的方式把 waitStatus 改为 0。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;4.5 signalAll&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;理解了 signal 的逻辑，signalAll 的逻辑就非常容易理解了。首先判断当前线程是否持有独占锁，如果没有，抛出异常。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;将条件等待队列中的所有节点依次加入入口等待队列。如下图：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1.2028753993610224&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/a1gicTYmvicd8RBmRiak6x8Ylb0ibiazH63vCrR15OVHLVNznlL2JNA8siaENbuWYcyuSKbeCMpRbsf0cBfp7tN5rXNQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;626&quot;/&gt;&lt;/figure&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;4.6 使用案例&lt;/h3&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;4.6.1 示例代码&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Java 并发包下有很多类使用到了 AQS 中的 Condition，如下图：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.374845869297164&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/a1gicTYmvicd8RBmRiak6x8Ylb0ibiazH63vCIXVDa6BoXAGQFQTzu2YiaNQJkDXPq1t90NxDibkAqwDzgAHHpqX3aBtg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;811&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里我们以 CyclicBarrier 为例来讲解。CyclicBarrier 是让一组线程相互等待共同达到一个屏障点。从 Cyclic 可以看出 Barrier 可以循环利用，也就是当线程释放之后可以继续使用。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;看下面这段示例代码：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;main(String[] args)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    CyclicBarrier cyclicBarrier = &lt;span&gt;new&lt;/span&gt; CyclicBarrier(&lt;span&gt;2&lt;/span&gt;, () -&amp;gt; {&lt;br/&gt;        System.out.println(&lt;span&gt;&quot;栅栏中的线程执行完成&quot;&lt;/span&gt;);&lt;br/&gt;    });&lt;br/&gt;    ExecutorService executorService = Executors.newFixedThreadPool(&lt;span&gt;2&lt;/span&gt;);&lt;br/&gt;&lt;br/&gt;    executorService.submit(() -&amp;gt; {&lt;br/&gt;        &lt;span&gt;try&lt;/span&gt; {&lt;br/&gt;            System.out.println(&lt;span&gt;&quot;线程1：&quot;&lt;/span&gt; + Thread.currentThread().getName());&lt;br/&gt;            cyclicBarrier.await();&lt;br/&gt;        } &lt;span&gt;catch&lt;/span&gt; (Exception e) {&lt;br/&gt;            e.printStackTrace();&lt;br/&gt;        }&lt;br/&gt;    });&lt;br/&gt;&lt;br/&gt;    executorService.submit(() -&amp;gt; {&lt;br/&gt;        &lt;span&gt;try&lt;/span&gt; {&lt;br/&gt;            System.out.println(&lt;span&gt;&quot;线程2：&quot;&lt;/span&gt; + Thread.currentThread().getName());&lt;br/&gt;            cyclicBarrier.await();&lt;br/&gt;        } &lt;span&gt;catch&lt;/span&gt; (Exception e) {&lt;br/&gt;            e.printStackTrace();&lt;br/&gt;        }&lt;br/&gt;    });&lt;br/&gt;&lt;br/&gt;    executorService.shutdown();&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;执行结果：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;线程1：pool-1-thread-1&lt;br/&gt;线程2：pool-1-thread-2&lt;br/&gt;栅栏中的线程执行完成&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;4.6.2 原理讲解&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;CyclicBarrier 初始化的时候，会指定线程的数量 count，每个线程执行完逻辑后，调用 CyclicBarrier 的 await 方法，这个方法首先将 count 减 1，然后调用 Condition的 await，让当前线程进入条件等待队列。当最后一个线程将 count 减 1 后，count 数量等于 0，这时就会调用 Condition 的 signalAll 方法唤醒所有线程。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;4.7 总结&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Java 的管程模型使用了 MESA 模型，基于 AQS 实现的 MESA 模型中，使用双向队列实现了入口等待队列，使用变量 state 实现了并发锁，使用 Condition 实现了条件等待队列。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在 AQS 的实现中，使用同步队列这个术语来表示双向队列，本文中使用入口等待队列来描述是为了更好的配合管程模型来讲解。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;AQS 的 Condition 中，使用 await 方法将当前线程放入条件变量等待队列阻塞等待，使用 notify 来唤醒条件等待队列中的线程，被唤醒之后，线程并不能立刻执行，而是进入入口等待队列等待获取锁。&lt;/p&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>