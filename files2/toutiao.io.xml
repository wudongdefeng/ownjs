<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>f8028b4fcba6fdffdceecadd411cf538</guid>
<title>欢迎加入读者圈子，一起交流！</title>
<link>https://toutiao.io/k/mtrqmru</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content                                       &quot; id=&quot;js_content&quot;&gt;
            &lt;p&gt;&lt;span&gt;&lt;strong&gt;欢迎加入读者圈子，一起交流！&lt;br/&gt;↓↓↓&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;558&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;307&quot; data-ratio=&quot;0.5493333333333333&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/AjN1jquNavich3VaNkKeiaAwUhz7TQbQmic4fFsr58X9PAYleYzxqc1K1vZjeBoZDMUsmia0xH67EQYINGRvNOtLmA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;750&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;圈子剧透&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;1、600+圈子成员，以中高级程序员为主，更有架构师、CTO坐镇交流；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;2、1000+优质主题，数十G独家资料，每日分享，精挑细选；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;3、全年52期专属邮件周报，让你轻松掌握业界资讯、技术干货，提升认知水平；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;4、全年52本好书共读，让你花最少的时间，获取更好的知识；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;……&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;心动不如行动，赶快加入吧！&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
          &lt;/div&gt;

          

          



           
                                
                    
        &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>7de6974fd8534a8ef820ff5ae0e14b8d</guid>
<title>Redis 突然变慢了如何排查并解决？</title>
<link>https://toutiao.io/k/4ihru9o</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot; data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Redis 通常是我们业务系统中一个重要的组件，比如：缓存、账号登录信息、排行榜等。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;一旦 Redis 请求延迟增加，可能就会导致业务系统“雪崩”。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我在单身红娘婚恋类型互联网公司工作，在双十一推出下单就送女朋友的活动。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;谁曾想，凌晨 12 点之后，用户量暴增，出现了一个技术故障，用户无法下单，当时老大火冒三丈！&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;经过查找发现 &lt;a href=&quot;https://mp.weixin.qq.com/mp/appmsgalbum?__biz=MzkzMDI1NjcyOQ==&amp;amp;action=getalbum&amp;amp;album_id=1918295695426404359&amp;amp;scene=173&amp;amp;from_msgid=2247487752&amp;amp;from_itemidx=1&amp;amp;count=3&amp;amp;nolastread=1#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;Redis&lt;/a&gt; 报 &lt;code&gt;Could not get a resource from the pool&lt;/code&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;获取不到连接资源，并且集群中的单台 Redis 连接量很高。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;大量的流量没了 Redis 的缓存响应，直接打到了 MySQL，最后数据库也宕机了……&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;于是各种更改最大连接数、连接等待数，虽然报错信息频率有所缓解，但还是&lt;strong&gt;持续报错&lt;/strong&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;后来经过线下测试，发现存放 &lt;a href=&quot;https://mp.weixin.qq.com/mp/appmsgalbum?__biz=MzkzMDI1NjcyOQ==&amp;amp;action=getalbum&amp;amp;album_id=1918295695426404359&amp;amp;scene=173&amp;amp;from_msgid=2247487752&amp;amp;from_itemidx=1&amp;amp;count=3&amp;amp;nolastread=1#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;Redis&lt;/a&gt; 中的&lt;strong&gt;字符数据很大，平均 1s 返回数据&lt;/strong&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可以发现，一旦 Redis 延迟过高，会引发各种问题。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;今天「码哥」跟大家一起来分析下如何确定 Redis 有性能问题和解决方案。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;目录&lt;/p&gt;&lt;section class=&quot;mp_profile_iframe_wrp&quot;&gt;&lt;mp-common-profile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-id=&quot;MzkzMDI1NjcyOQ==&quot; data-pluginname=&quot;mpprofile&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/EoJib2tNvVtf7icAmS0BQH6oDVG37Q8NzcfdguS5qAqOhfxvZyIKqmuX5BbnDjynrBbZzktp1EiaeFLzapp1nHysw/0?wx_fmt=png&quot; data-nickname=&quot;码哥字节&quot; data-alias=&quot;MageByte&quot; data-signature=&quot;拥抱硬核技术和对象，面向人民币编程。&quot; data-from=&quot;0&quot; data-is_biz_ban=&quot;0&quot;/&gt;&lt;/section&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;Redis 性能出问题了么？&lt;/span&gt;&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;最大延迟是客户端发出命令到客户端收到命令的响应的时间，正常情况下 Redis 处理的时间极短，在微秒级别。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当 Redis 出现性能波动的时候，比如达到几秒到十几秒，这个很明显我们可以认定 Redis 性能变慢了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;有的硬件配置比较高，当延迟 0.6ms，我们可能就认定变慢了。硬件比较差的可能 3 ms 我们才认为出现问题。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;❝&lt;/span&gt;&lt;p&gt;那我们该如何定义 Redis 真的变慢了呢？&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以，我们需要对当前环境的 &lt;strong&gt;Redis 基线性能&lt;/strong&gt;做测量，也就是在一个系统在低压力、无干扰情况下的基本性能。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;当你发现 Redis 运行时时的延迟是基线性能的 2 倍以上，就可以判定 Redis 性能变慢了。&lt;/strong&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;延迟基线测量&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;redis-cli 命令提供了&lt;code&gt;–intrinsic-latency&lt;/code&gt; 选项，用来监测和统计测试期间内的最大延迟（以毫秒为单位），这个延迟可以作为 Redis 的基线性能。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;redis-cli --latency -h `host` -p `port`&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;比如执行如下指令：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;redis-cli --intrinsic-latency 100&lt;br/&gt;Max latency so far: 4 microseconds.&lt;br/&gt;Max latency so far: 18 microseconds.&lt;br/&gt;Max latency so far: 41 microseconds.&lt;br/&gt;Max latency so far: 57 microseconds.&lt;br/&gt;Max latency so far: 78 microseconds.&lt;br/&gt;Max latency so far: 170 microseconds.&lt;br/&gt;Max latency so far: 342 microseconds.&lt;br/&gt;Max latency so far: 3079 microseconds.&lt;br/&gt;&lt;br/&gt;45026981 total runs (avg latency: 2.2209 microseconds / 2220.89 nanoseconds per run).&lt;br/&gt;Worst run took 1386x longer than the average latency.&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;❝&lt;/span&gt;&lt;p&gt;注意：参数&lt;code&gt;100&lt;/code&gt;是测试将执行的秒数。我们运行测试的时间越长，我们就越有可能发现延迟峰值。&lt;/p&gt;&lt;p&gt;通常运行 100 秒通常是合适的，足以发现延迟问题了，当然我们可以选择不同时间运行几次，避免误差。&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;「码哥」运行的最大延迟是 3079 微秒，所以基线性能是 3079 （3 毫秒）微秒。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;需要注意的是，我们要在 Redis 的服务端运行，而不是客户端。这样，可以&lt;strong&gt;避免网络对基线性能的影响&lt;/strong&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可以通过 &lt;code&gt;-h host -p port&lt;/code&gt; 来连接服务端，如果想监测网络对 Redis 的性能影响，可以使用 Iperf 测量客户端到服务端的网络延迟。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果网络延迟几百毫秒，说明网络可能有其他大流量的程序在运行导致网络拥塞，需要找运维协调网络的流量分配。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;慢指令监控&lt;/span&gt;&lt;/h2&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;❝&lt;/span&gt;&lt;p&gt;如何判断是否是慢指令呢？&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;看操作复杂度是否是&lt;code&gt;O(N)&lt;/code&gt;。官方文档对每个命令的复杂度都有介绍，尽可能使用&lt;code&gt;O(1) 和 O(log N)&lt;/code&gt;命令。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;涉及到集合操作的复杂度一般为&lt;code&gt;O(N)&lt;/code&gt;，比如集合&lt;strong&gt;全量查询&lt;/strong&gt;&lt;code&gt;HGETALL、SMEMBERS&lt;/code&gt;，以及集合的&lt;strong&gt;聚合操作：&lt;/strong&gt;SORT、LREM、 SUNION等。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;❝&lt;/span&gt;&lt;p&gt;有监控数据可以观测呢？代码不是我写的，不知道有没有人用了慢指令。&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;有两种方式可以排查到：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;使用 Redis 慢日志功能查出慢命令；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;latency-monitor（延迟监控）工具。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;此外，可以使用自己（top、htop、prstat 等）快速检查 Redis 主进程的 CPU 消耗。如果 CPU 使用率很高而流量不高，通常表明使用了慢速命令。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;慢日志功能&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Redis 中的 slowlog 命令可以让我们快速定位到那些超出指定执行时间的慢命令，默认情况下命令若是执行时间超过 10ms 就会被记录到日志。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;slowlog 只会记录其命令执行的时间，不包含 io 往返操作，也不记录单由网络延迟引起的响应慢。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们可以&lt;strong&gt;根据基线性能来自定义慢命令的标准（配置成基线性能最大延迟的 2 倍）&lt;/strong&gt;，调整触发记录慢命令的阈值。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可以在 redis-cli 中输入以下命令配置记录 6 毫秒以上的指令：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;redis-cli CONFIG SET slowlog-log-slower-than 6000&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;也可以在 Redis.config 配置文件中设置，以微秒为单位。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;想要查看所有执行时间比较慢的命令，可以通过使用 Redis-cli 工具，输入 slowlog get 命令查看，返回结果的第三个字段以微秒位单位显示命令的执行时间。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;假如只需要查看最后 2 个慢命令，输入 slowlog get 2 即可。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;示例：获取最近2个慢查询命令&lt;br/&gt;127.0.0.1:6381&amp;gt; SLOWLOG get 2&lt;br/&gt;1) 1) (&lt;span&gt;integer&lt;/span&gt;) 6&lt;br/&gt;   2) (&lt;span&gt;integer&lt;/span&gt;) 1458734263&lt;br/&gt;   3) (&lt;span&gt;integer&lt;/span&gt;) 74372&lt;br/&gt;   4) 1) &lt;span&gt;&quot;hgetall&quot;&lt;/span&gt;&lt;br/&gt;      2) &lt;span&gt;&quot;max.dsp.blacklist&quot;&lt;/span&gt;&lt;br/&gt;2) 1) (&lt;span&gt;integer&lt;/span&gt;) 5&lt;br/&gt;   2) (&lt;span&gt;integer&lt;/span&gt;) 1458734258&lt;br/&gt;   3) (&lt;span&gt;integer&lt;/span&gt;) 5411075&lt;br/&gt;   4) 1) &lt;span&gt;&quot;keys&quot;&lt;/span&gt;&lt;br/&gt;      2) &lt;span&gt;&quot;max.dsp.blacklist&quot;&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;以第一个 HGET 命令为例分析，每个 slowlog 实体共 4 个字段：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;字段 1：1 个整数，表示这个 slowlog 出现的序号，server 启动后递增，当前为 6。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;字段 2：表示查询执行时的 Unix 时间戳。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;字段 3：表示查询执行微秒数,当前是 74372 微秒,约 74ms。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;字段 4: 表示查询的命令和参数,如果参数很多或很大,只会显示部分参数个数。当前命令是&lt;code&gt;hgetall max.dsp.blacklist&lt;/code&gt;。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;Latency Monitoring&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Redis 在 2.8.13 版本引入了 Latency Monitoring 功能，用于以秒为粒度监控各种事件的发生频率。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;启用延迟监视器的第一步是&lt;strong&gt;设置延迟阈值(单位毫秒)&lt;/strong&gt;。只有超过该阈值的时间才会被记录，比如我们根据基线性能（3ms）的 3 倍设置阈值为 9 ms。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可以用 redis-cli 设置也可以在 Redis.config 中设置；&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;CONFIG SET latency-monitor-threshold 9&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;工具记录的相关事件的详情可查看官方文档：https://redis.io/topics/latency-monitor&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如获取最近的 latency&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;127.0.0.1:6379&amp;gt; debug sleep 2&lt;br/&gt;OK&lt;br/&gt;(2.00s)&lt;br/&gt;127.0.0.1:6379&amp;gt; latency latest&lt;br/&gt;1) 1) &quot;command&quot;&lt;br/&gt;   2) (integer) 1645330616&lt;br/&gt;   3) (integer) 2003&lt;br/&gt;   4) (integer) 2003&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;事件的名称；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;事件发生的最新延迟的 Unix 时间戳；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;毫秒为单位的时间延迟；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;该事件的最大延迟。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;如何解决 Redis 变慢？&lt;/span&gt;&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Redis 的数据读写由单线程执行，如果主线程执行的操作时间太长，就会导致主线程阻塞。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;一起分析下都有哪些操作会阻塞主线程，我们又该如何解决？&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;网络通信导致的延迟&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;客户端使用 TCP/IP 连接或 Unix 域连接连接到 Redis。1 Gbit/s 网络的典型延迟约为 200 us。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;redis 客户端执行一条命令分 4 个过程：&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;❝&lt;/span&gt;&lt;p&gt;发送命令－〉 命令排队 －〉 命令执行－〉 返回结果&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个过程称为 Round trip time(简称 RTT, 往返时间)，mget mset 有效节约了 RTT，但大部分命令（如 hgetall，并没有 mhgetall）不支持批量操作，需要消耗 N 次 RTT ，这个时候需要 pipeline 来解决这个问题。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Redis pipeline 将多个命令连接在一起来减少网络响应往返次数。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1.2943327239488116&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/EoJib2tNvVtchfpRuhJYeeDiaYOGTwe8LCkrm37hmdheA6YCjDK4CYLbn1AM1GLdb0WJiaIJjib3mbsJfDY91eg5ag/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;547&quot;/&gt;&lt;figcaption&gt;redis-pipeline&lt;/figcaption&gt;&lt;/figure&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;慢指令导致的延迟&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;根据上文的慢指令监控查询文档，查询到慢查询指令。可以通过以下两种方式解决：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;比如在 Cluster 集群中，将聚合运算等 O(N) 操作运行在 slave 上，或者在客户端完成。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;使用高效的命令代替。使用增量迭代的方式，避免一次查询大量数据，具体请查看SCAN、SSCAN、HSCAN和ZSCAN命令。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;除此之外，生产中禁用KEYS 命令，它只适用于调试。因为它会遍历所有的键值对，所以操作延时高。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;Fork 生成 RDB 导致的延迟&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzkzMDI1NjcyOQ==&amp;amp;mid=2247487758&amp;amp;idx=1&amp;amp;sn=beb5918bb61948b2920907f54510311f&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;生成 RDB 快照&lt;/a&gt;，Redis 必须 fork 后台进程。&lt;strong&gt;fork 操作（在主线程中运行）本身会导致延迟。&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Redis 使用操作系统的多进程&lt;strong&gt;写时复制技术 COW(Copy On Write)&lt;/strong&gt; 来实现快照持久化，减少内存占用。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5952782462057336&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/EoJib2tNvVtchfpRuhJYeeDiaYOGTwe8LCxibsWZ4zs0YQdHAN4JESUCreoQaPYpjvs0poib8KehJsIvlsgicicoia2Lg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;593&quot;/&gt;&lt;figcaption&gt;写时复制技术保证快照期间数据可修改&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但 fork 会涉及到复制大量链接对象，一个 24 GB 的大型 Redis 实例需要 24 GB / 4 kB * 8 = 48 MB 的页表。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;执行 bgsave 时，这将涉及分配和复制 48 MB 内存。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;此外，&lt;strong&gt;从库加载 RDB 期间无法提供读写服务，所以主库的数据量大小控制在 2~4G 左右，让从库快速的加载完成&lt;/strong&gt;。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;内存大页（transparent huge pages）&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;常规的内存页是按照 4 KB 来分配，Linux 内核从 2.6.38 开始支持内存大页机制，该机制支持 2MB 大小的内存页分配。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Redis 使用了 fork 生成 &lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzkzMDI1NjcyOQ==&amp;amp;mid=2247487758&amp;amp;idx=1&amp;amp;sn=beb5918bb61948b2920907f54510311f&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;RDB 做持久化提供了数据可靠性保证&lt;/a&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当生成 RDB 快照的过程中，Redis 采用**&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzkzMDI1NjcyOQ==&amp;amp;mid=2247487758&amp;amp;idx=1&amp;amp;sn=beb5918bb61948b2920907f54510311f&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;写时复制&lt;/a&gt;**技术使得主线程依然可以接收客户端的写请求。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;也就是当数据被修改的时候，Redis 会复制一份这个数据，再进行修改。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;采用了内存大页，生成 RDB 期间，即使客户端修改的数据只有 50B 的数据，Redis 需要复制 2MB 的大页。当写的指令比较多的时候就会导致大量的拷贝，导致性能变慢。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;使用以下指令禁用 Linux 内存大页即可：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;echo never &amp;gt; /sys/kernel/mm/transparent_hugepage/enabled&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;swap：操作系统分页&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当物理内存（内存条）不够用的时候，将部分内存上的数据交换到 swap 空间上，以便让系统不会因内存不够用而导致 oom 或者更致命的情况出现。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当某进程向 OS 请求内存发现不足时，OS 会把内存中暂时不用的数据交换出去，放在 SWAP 分区中，这个过程称为 SWAP OUT。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当某进程又需要这些数据且 OS 发现还有空闲物理内存时，又会把 SWAP 分区中的数据交换回物理内存中，这个过程称为 SWAP IN。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;内存 swap 是操作系统里将内存数据在内存和磁盘间来回换入和换出的机制，涉及到磁盘的读写。&lt;/strong&gt;&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;❝&lt;/span&gt;&lt;p&gt;触发 swap 的情况有哪些呢？&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;对于 Redis 而言，有两种常见的情况：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;Redis 使用了比可用内存更多的内存；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;与 Redis 在同一机器运行的其他进程在执行大量的文件读写 I/O 操作（包括生成大文件的 RDB 文件和 AOF 后台线程），文件读写占用内存，导致 Redis 获得的内存减少，触发了 swap。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;❝&lt;/span&gt;&lt;p&gt;码哥，我要如何排查是否因为 swap 导致的性能变慢呢？&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Linux 提供了很好的工具来排查这个问题，所以当怀疑由于交换导致的延迟时，只需按照以下步骤排查。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;获取 Redis 实例 pid&lt;/span&gt;&lt;/h3&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;$&lt;/span&gt;&lt;span&gt; redis-cli info | grep process_id&lt;/span&gt;&lt;br/&gt;process_id:13160&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;进入此进程的 /proc 文件系统目录：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;cd /proc/13160&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在这里有一个 smaps 的文件，该文件描述了 Redis 进程的内存布局，运行以下指令，用 grep 查找所有文件中的 Swap 字段。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;$ cat smaps | egrep &lt;span&gt;&#x27;^(Swap|Size)&#x27;&lt;/span&gt;&lt;br/&gt;Size:                316 kB&lt;br/&gt;Swap:                  0 kB&lt;br/&gt;Size:                  4 kB&lt;br/&gt;Swap:                  0 kB&lt;br/&gt;Size:                  8 kB&lt;br/&gt;Swap:                  0 kB&lt;br/&gt;Size:                 40 kB&lt;br/&gt;Swap:                  0 kB&lt;br/&gt;Size:                132 kB&lt;br/&gt;Swap:                  0 kB&lt;br/&gt;Size:             720896 kB&lt;br/&gt;Swap:                 12 kB&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;每行 Size 表示 Redis 实例所用的一块内存大小，和 Size 下方的 Swap 对应这块 Size 大小的内存区域有多少数据已经被换出到磁盘上了。&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;如果 Size == Swap 则说明数据被完全换出了。&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可以看到有一个 720896 kB 的内存大小有 12 kb 被换出到了磁盘上（仅交换了 12 kB），这就没什么问题。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Redis 本身会使用很多大小不一的内存块，所以，你可以看到有很多 Size 行，有的很小，就是 4KB，而有的很大，例如 720896KB。不同内存块被换出到磁盘上的大小也不一样。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;敲重点了&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;如果 Swap 一切都是 0 kb，或者零星的 4k ，那么一切正常。&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;当出现百 MB，甚至 GB 级别的 swap 大小时，就表明，此时，Redis 实例的内存压力很大，很有可能会变慢。&lt;/strong&gt;&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;解决方案&lt;/span&gt;&lt;/h3&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;增加机器内存；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;将 Redis 放在单独的机器上运行，避免在同一机器上运行需要大量内存的进程，从而满足 Redis 的内存需求；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;增加 Cluster 集群的数量分担数据量，减少每个实例所需的内存。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;AOF 和磁盘 I/O 导致的延迟&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;为了保证数据可靠性，&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzkzMDI1NjcyOQ==&amp;amp;mid=2247487758&amp;amp;idx=1&amp;amp;sn=beb5918bb61948b2920907f54510311f&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;Redis 使用 AOF 和 RDB 快照实现快速恢复和持久化&lt;/a&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可以使用 appendfsync 配置将 AOF 配置为以三种不同的方式在磁盘上执行 write 或者 fsync （可以在运行时使用 &lt;strong&gt;CONFIG SET&lt;/strong&gt;命令修改此设置，比如：&lt;code&gt;redis-cli CONFIG SET appendfsync no&lt;/code&gt;）。&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;no&lt;/strong&gt;：Redis 不执行 fsync，唯一的延迟来自于 write 调用，write 只需要把日志记录写到内核缓冲区就可以返回。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;everysec&lt;/strong&gt;：Redis 每秒执行一次 fsync。使用后台子线程异步完成 fsync 操作。最多丢失 1s 的数据。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;always&lt;/strong&gt;：每次写入操作都会执行 fsync，然后用 OK 代码回复客户端（实际上 Redis 会尝试将同时执行的许多命令聚集到单个 fsync 中），没有数据丢失。在这种模式下，性能通常非常低，强烈建议使用快速磁盘和可以在短时间内执行 fsync 的文件系统实现。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;我们通常将 Redis 用于缓存，数据丢失完全恶意从数据获取，并不需要很高的数据可靠性，建议设置成 no 或者 everysec。&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;除此之外，避免 AOF 文件过大， Redis 会进行 AOF 重写，生成缩小的 AOF 文件。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可以把配置项 &lt;code&gt;no-appendfsync-on-rewrite&lt;/code&gt;设置为 yes，表示在 AOF 重写时，不进行 fsync 操作。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;也就是说，Redis 实例把写命令写到内存后，不调用后台线程进行 fsync 操作，就直接返回了。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;expires 淘汰过期数据&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Redis 有两种方式淘汰过期数据：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;惰性删除：当接收请求的时候发现 key 已经过期，才执行删除；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;定时删除：每 100 毫秒删除一些过期的 key。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;定时删除的算法如下：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;随机采样 A&lt;code&gt;CTIVE_EXPIRE_CYCLE_LOOKUPS_PER_LOOP&lt;/code&gt;个数的 key，删除所有过期的 key；&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;如果发现还有超过 25% 的 key 已过期，则执行步骤一。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;ACTIVE_EXPIRE_CYCLE_LOOKUPS_PER_LOOP&lt;/code&gt;默认设置为 20，每秒执行 10 次，删除 200 个 key 问题不大。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果触发了第二条，就会导致 Redis 一致在删除过期数据去释放内存。&lt;strong&gt;而删除是阻塞的。&lt;/strong&gt;&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;❝&lt;/span&gt;&lt;p&gt;码哥，触发条件是什么呀？&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;也就是大量的 key 设置了相同的时间参数。同一秒内，大量 key 过期，需要重复删除多次才能降低到 25% 以下。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;简而言之：大量同时到期的 key 可能会导致性能波动。&lt;/strong&gt;&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;解决方案&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果一批 key 的确是同时过期，可以在 &lt;code&gt;EXPIREAT&lt;/code&gt; 和 &lt;code&gt;EXPIRE&lt;/code&gt; 的过期时间参数上，&lt;strong&gt;加上一个一定大小范围内的随机数&lt;/strong&gt;，这样，既保证了 key 在一个邻近时间范围内被删除，又避免了同时过期造成的压力。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;bigkey&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;通常我们会将含有较大数据或含有大量成员、列表数的 Key 称之为大 Key，下面我们将用几个实际的例子对大 Key 的特征进行描述：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;一个 STRING 类型的 Key，它的值为 5MB（数据过大）&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;一个 LIST 类型的 Key，它的列表数量为 10000 个（列表数量过多）&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;一个 ZSET 类型的 Key，它的成员数量为 10000 个（成员数量过多）&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;一个 HASH 格式的 Key，它的成员数量虽然只有 1000 个但这些成员的 value 总大小为 10MB（成员体积过大）&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;bigkey 带来问题如下：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;Redis 内存不断变大引发 OOM，或者达到 maxmemory 设 置值引发写阻塞或重要 Key 被逐出；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Redis Cluster 中的某个 node 内存远超其余 node，但因 Redis Cluster 的数据迁移最小粒度为 Key 而无法将 node 上的内存均衡化；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;bigkey 的读请求占用过大带宽，自身变慢的同时影响到该服务器上的其它服务；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;删除一个 bigkey 造成主库较长时间的阻塞并引发同步中断或主从切换；&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;查找 bigkey&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;使用 redis-rdb-tools 工具以定制化方式找出大 Key。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;解决方案&lt;/span&gt;&lt;/h3&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;对大 key 拆分&lt;/span&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如将一个含有数万成员的 HASH Key 拆分为多个 HASH Key，并确保每个 Key 的成员数量在合理范围，在 Redis Cluster 结构中，大 Key 的拆分对 node 间的内存平衡能够起到显著作用。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;异步清理大 key&lt;/span&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Redis 自 4.0 起提供了 UNLINK 命令，该命令能够以非阻塞的方式缓慢逐步的清理传入的 Key，通过 UNLINK，你可以安全的删除大 Key 甚至特大 Key。&lt;/p&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;总结&lt;/span&gt;&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如下检查清单，帮助你在遇到 Redis 性能变慢的时候能高效解决问题。&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;获取当前 Redis 的基线性能；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;开启慢指令监控，定位慢指令导致的问题；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;找到慢指令，使用 scan 的方式；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;将实例的数据大小控制在 2-4GB，避免主从复制加载过大 RDB 文件而阻塞；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;禁用内存大页，采用了内存大页，生成 RDB 期间，即使客户端修改的数据只有 50B 的数据，Redis 需要复制 2MB 的大页。当写的指令比较多的时候就会导致大量的拷贝，导致性能变慢。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Redis 使用的内存是否过大导致 swap；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;AOF 配置是否合理，可以将配置项 no-appendfsync-on-rewrite 设置为 yes，避免 AOF 重写和 fsync 竞争磁盘 IO 资源，导致 Redis 延迟增加。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;bigkey 会带来一系列问题，我们需要进行拆分防止出现 bigkey，并通过 UNLINK 异步删除。&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;section class=&quot;mp_profile_iframe_wrp&quot;&gt;&lt;mp-common-profile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-id=&quot;MzkzMDI1NjcyOQ==&quot; data-pluginname=&quot;mpprofile&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/EoJib2tNvVtf7icAmS0BQH6oDVG37Q8NzcfdguS5qAqOhfxvZyIKqmuX5BbnDjynrBbZzktp1EiaeFLzapp1nHysw/0?wx_fmt=png&quot; data-nickname=&quot;码哥字节&quot; data-alias=&quot;MageByte&quot; data-signature=&quot;拥抱硬核技术和对象，面向人民币编程。&quot; data-from=&quot;0&quot; data-is_biz_ban=&quot;0&quot;/&gt;&lt;/section&gt;&lt;p cid=&quot;n204&quot; mdtype=&quot;paragraph&quot;&gt;&lt;strong&gt;关注「码哥字节」。阅读后如有收获请「点赞、分享、收藏」，谢谢支持.&lt;/strong&gt;&lt;/p&gt;&lt;p cid=&quot;n205&quot; mdtype=&quot;paragraph&quot;&gt;读者群已经开通，群里与各个大厂的大佬，不仅可以内推也可以学习。添加「码哥」个人微信，回复「加群」一起成长！&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;1&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/EoJib2tNvVtcibFUdzI25zp60m4Aic1uALntibEIFxldsrRoe2d2PcrqCwan5cUeRjOEmnWIWNaYxqaBP7jiaicxia30Q/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;430&quot;/&gt;&lt;/p&gt;&lt;section data-recommend-type=&quot;list-normal&quot; data-recommend-tid=&quot;2&quot; data-mpa-template=&quot;t&quot; data-mid=&quot;&quot; data-from=&quot;yb-recommend&quot;&gt;&lt;section data-mid=&quot;&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; data-recommend-article-type=&quot;list-normal&quot; data-recomment-template-id=&quot;2&quot; data-recommend-article-id=&quot;2247497323_1&quot; data-recommend-article-time=&quot;1642176060&quot; data-recommend-article-cover=&quot;https://mmbiz.qlogo.cn/mmbiz_jpg/EoJib2tNvVtfXMJdlMtHFyH52buuRr7aWYX6rrlxxWwr9JqficbcfxOVwqzMFscT4I9DKViayian9qcWHHKbpCJS6Q/0?wx_fmt=jpeg&quot; data-recommend-article-title=&quot;Redis 使用 List 实现消息队列的利与弊&quot; data-recommend-article-content-url=&quot;https://mp.weixin.qq.com/s?__biz=MzkzMDI1NjcyOQ==&amp;amp;mid=2247497323&amp;amp;idx=1&amp;amp;sn=387d84d644ce6351a05ebca8f8c46df5&amp;amp;chksm=c27fb45df5083d4ba108d4583e019c33941d7d1bd1d6d3f41edd03c0bf81185e43af8861f43c#rd&quot;&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzkzMDI1NjcyOQ==&amp;amp;mid=2247497323&amp;amp;idx=1&amp;amp;sn=387d84d644ce6351a05ebca8f8c46df5&amp;amp;chksm=c27fb45df5083d4ba108d4583e019c33941d7d1bd1d6d3f41edd03c0bf81185e43af8861f43c&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;1&quot;&gt;&lt;section data-recommend-content=&quot;t&quot; data-mid=&quot;&quot;&gt;&lt;section data-mid=&quot;&quot;&gt;&lt;p data-recommend-title=&quot;t&quot; data-mid=&quot;&quot;&gt;Redis 使用 List 实现消息队列的利与弊&lt;/p&gt;&lt;p data-recommend-date=&quot;t&quot; data-mid=&quot;&quot;&gt;2022-01-15&lt;/p&gt;&lt;/section&gt;&lt;span class=&quot;js_jump_icon h5_image_link&quot; data-positionback=&quot;static&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1.0031347962382444&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/EoJib2tNvVtfXMJdlMtHFyH52buuRr7aWYX6rrlxxWwr9JqficbcfxOVwqzMFscT4I9DKViayian9qcWHHKbpCJS6Q/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;319&quot;/&gt;&lt;/span&gt; &lt;/section&gt;&lt;/a&gt;&lt;/section&gt;&lt;section data-mpa-template=&quot;t&quot; data-recommend-article-type=&quot;list-normal&quot; data-recomment-template-id=&quot;2&quot; data-recommend-article-id=&quot;2247495902_1&quot; data-recommend-article-time=&quot;1638115260&quot; data-recommend-article-cover=&quot;https://mmbiz.qlogo.cn/mmbiz_jpg/EoJib2tNvVtf1bKNWEJVvTT3JHw9cV6WwM2EPjt4J3GnLSj86sqzsTgw145hia1NCZrmUnicsiab6FKcJc6hn8LWxg/0?wx_fmt=jpeg&quot; data-recommend-article-title=&quot;Redis 分布式锁的正确实现原理演化历程与 Redisson 实战总结&quot; data-recommend-article-content-url=&quot;https://mp.weixin.qq.com/s?__biz=MzkzMDI1NjcyOQ==&amp;amp;mid=2247495902&amp;amp;idx=1&amp;amp;sn=51413a133f87b1fafa49dbd0ff4908b5&amp;amp;chksm=c27fb2e8f5083bfedda596c0c4a4af99c3ca08bfd8d244b650f9cb35d7f6fed43741975b3a58#rd&quot;&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzkzMDI1NjcyOQ==&amp;amp;mid=2247495902&amp;amp;idx=1&amp;amp;sn=51413a133f87b1fafa49dbd0ff4908b5&amp;amp;chksm=c27fb2e8f5083bfedda596c0c4a4af99c3ca08bfd8d244b650f9cb35d7f6fed43741975b3a58&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;1&quot;&gt;&lt;section data-recommend-content=&quot;t&quot; data-mid=&quot;&quot;&gt;&lt;section data-mid=&quot;&quot;&gt;&lt;p data-recommend-title=&quot;t&quot; data-mid=&quot;&quot;&gt;Redis 分布式锁的正确实现原理演化历程与 Redisson 实战总结&lt;/p&gt;&lt;p data-recommend-date=&quot;t&quot; data-mid=&quot;&quot;&gt;2021-11-29&lt;/p&gt;&lt;/section&gt;&lt;span class=&quot;js_jump_icon h5_image_link&quot; data-positionback=&quot;static&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.998769987699877&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/EoJib2tNvVtf1bKNWEJVvTT3JHw9cV6WwM2EPjt4J3GnLSj86sqzsTgw145hia1NCZrmUnicsiab6FKcJc6hn8LWxg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;813&quot;/&gt;&lt;/span&gt; &lt;/section&gt;&lt;/a&gt;&lt;/section&gt;&lt;section data-mpa-template=&quot;t&quot; data-recommend-article-type=&quot;list-normal&quot; data-recomment-template-id=&quot;2&quot; data-recommend-article-id=&quot;2247494423_1&quot; data-recommend-article-time=&quot;1634517600&quot; data-recommend-article-cover=&quot;https://mmbiz.qlogo.cn/mmbiz_jpg/EoJib2tNvVtfoPs4n7qZWxz0d3ykWRgQQBNmUicMYGQibB8r74CdpIOCib6Dc3zk5oxic9T6vrDVuH5NUJJadZroF6w/0?wx_fmt=jpeg&quot; data-recommend-article-title=&quot;腾讯二面：Redis 事务支持 ACID 么？&quot; data-recommend-article-content-url=&quot;https://mp.weixin.qq.com/s?__biz=MzkzMDI1NjcyOQ==&amp;amp;mid=2247494423&amp;amp;idx=1&amp;amp;sn=52d6f4061b1bb8456f5216a38bb32bf4&amp;amp;chksm=c27fa921f50820370a352a93531cb90a9fa0d2f479fd6083045d266b71196a95af4306f4b73c#rd&quot;&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzkzMDI1NjcyOQ==&amp;amp;mid=2247494423&amp;amp;idx=1&amp;amp;sn=52d6f4061b1bb8456f5216a38bb32bf4&amp;amp;chksm=c27fa921f50820370a352a93531cb90a9fa0d2f479fd6083045d266b71196a95af4306f4b73c&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;1&quot;&gt;&lt;section data-recommend-content=&quot;t&quot; data-mid=&quot;&quot;&gt;&lt;section data-mid=&quot;&quot;&gt;&lt;p data-recommend-title=&quot;t&quot; data-mid=&quot;&quot;&gt;腾讯二面：Redis 事务支持 ACID 么？&lt;/p&gt;&lt;p data-recommend-date=&quot;t&quot; data-mid=&quot;&quot;&gt;2021-10-18&lt;/p&gt;&lt;/section&gt;&lt;span class=&quot;js_jump_icon h5_image_link&quot; data-positionback=&quot;static&quot;&gt;&lt;img data-ratio=&quot;0.9977426636568849&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/EoJib2tNvVtfoPs4n7qZWxz0d3ykWRgQQBNmUicMYGQibB8r74CdpIOCib6Dc3zk5oxic9T6vrDVuH5NUJJadZroF6w/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;443&quot;/&gt;&lt;/span&gt; &lt;/section&gt;&lt;/a&gt;&lt;/section&gt;&lt;section data-mpa-template=&quot;t&quot; data-recommend-article-type=&quot;list-normal&quot; data-recomment-template-id=&quot;2&quot; data-recommend-article-id=&quot;2247493190_1&quot; data-recommend-article-time=&quot;1632616740&quot; data-recommend-article-cover=&quot;https://mmbiz.qlogo.cn/mmbiz_jpg/EoJib2tNvVtcKQep7qcnlhKvKz307NQVbssjGZV1zQaZFs0nuKfaoicia7G4NUGEYXvE11VicfibbbUbDkicsbs2I8Nw/0?wx_fmt=jpeg&quot; data-recommend-article-title=&quot;Redis 很屌，不懂使用规范就糟蹋了&quot; data-recommend-article-content-url=&quot;https://mp.weixin.qq.com/s?__biz=MzkzMDI1NjcyOQ==&amp;amp;mid=2247493190&amp;amp;idx=1&amp;amp;sn=a3b6e1b36eb676c0055babbf9864fece&amp;amp;chksm=c27fa470f5082d6643f24d699d78df55195d8f4b6be3e949bac64966cc383f84c7c69bdfd77d#rd&quot;&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzkzMDI1NjcyOQ==&amp;amp;mid=2247493190&amp;amp;idx=1&amp;amp;sn=a3b6e1b36eb676c0055babbf9864fece&amp;amp;chksm=c27fa470f5082d6643f24d699d78df55195d8f4b6be3e949bac64966cc383f84c7c69bdfd77d&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;1&quot;&gt;&lt;section data-recommend-content=&quot;t&quot; data-mid=&quot;&quot;&gt;&lt;section data-mid=&quot;&quot;&gt;&lt;p data-recommend-title=&quot;t&quot; data-mid=&quot;&quot;&gt;Redis 很屌，不懂使用规范就糟蹋了&lt;/p&gt;&lt;p data-recommend-date=&quot;t&quot; data-mid=&quot;&quot;&gt;2021-09-26&lt;/p&gt;&lt;/section&gt;&lt;span class=&quot;js_jump_icon h5_image_link&quot; data-positionback=&quot;static&quot;&gt;&lt;img data-ratio=&quot;1&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/EoJib2tNvVtcKQep7qcnlhKvKz307NQVbssjGZV1zQaZFs0nuKfaoicia7G4NUGEYXvE11VicfibbbUbDkicsbs2I8Nw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;720&quot;/&gt;&lt;/span&gt; &lt;/section&gt;&lt;/a&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;参考资料&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>2215122d907eec76383dd80a34c9bbe5</guid>
<title>腾讯软件工程师是怎样写设计文档的？</title>
<link>https://toutiao.io/k/nvkablz</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section&gt;&lt;section&gt;&lt;span&gt;1、设计文档是什么？&lt;/span&gt;&lt;/section&gt;&lt;p&gt;设计文档是软件工程设计中的重要组成部分，是对一个技术问题的解决方案的系统性描述。设计文档的目的，是阐明设计的总体思想和设计中考虑的权衡点。&lt;/p&gt;&lt;p&gt;作为一名软件工程师，我们的工作本质不仅仅是编写程序代码，而是解决真正的问题。因此，相比最终的程序代码，文字形式的设计文档，在早期能够更加简明扼要地传达信息，便于让读者理解问题，找到解决方案。&lt;/p&gt;&lt;p&gt;除了作为系统设计的最初体现，设计文档在软件工程的开发周期中起到下面重要作用：&lt;/p&gt;&lt;p&gt;通过设计文档，我们可以：&lt;/p&gt;&lt;section&gt;&lt;span&gt;2、什么时候需要设计文档？&lt;/span&gt;&lt;/section&gt;&lt;p&gt;本身撰写设计文档是需要编写成本的。如果问题的解决方案非常清晰，没有明确的取舍，设计文档中基本都是实现描述，则应该省略设计文档而直接实现。换言之，如果编写设计文档的时间主要消耗在“写”而不是在“思考”上，则这个设计文档可省略。&lt;/p&gt;&lt;p&gt;当你考虑编写一个设计文档时，想一想以下这几点：&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;软件的规模是否较大，值得付出额外的编写评审设计文档的时间来降低失败的风险？&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;高级工程师无法确保 CR 每一份代码，让他们参与设计评审是否回报更高？&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;软件设计决策是模糊的，甚至有争议。有必要围绕设计文档在组织上达成共识?&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;是否需要通过设计文档强调项目交叉问题，如隐私性 (Privacy)、安全性 (Security)、日志记录？是否有必要写一份文档来对有关遗留系统的设计问题提供高层次的分析？&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;如果以上的问题的答案为“是”，那么设计文档可能是开始你的下一个软件项目的绝佳方法。&lt;/p&gt;&lt;section&gt;&lt;span&gt;3、设计文档要怎么写？&lt;/span&gt;&lt;/section&gt;&lt;p&gt;在考虑通过用设计文档解决问题，开始着手准备设计文档前，需要厘清设计文档易混淆的三个概念，它们也是创作设计文档的根基。一旦出现偏差，我们认真撰写的文档很有可能完全不可用，在纠正偏差时也会出现大量工作返工，造成资源的浪费。所以，撰写设计文档前需要搞清楚这些前提！&lt;/p&gt;&lt;section&gt;&lt;span&gt;3.1 撰写设计文档的三个前提&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span/&gt; 前提一：设计文档的读写比最高&lt;/section&gt;&lt;p&gt;实现代码、系统接口、设计文档，读写比（内容被所有人阅读花费的时间：内容写作花费的时间）是逐步上升的。通常，设计文档供阅读的时间往往远多于写的时间。因此，编写设计文档时就更多考虑读者的体验而非作者的体验。为提升设计可读性的时间非常值得投资。&lt;/p&gt;&lt;section&gt;&lt;span/&gt; 前提二：设计文档不是文学写作&lt;/section&gt;&lt;p&gt;设计文档的目的是为了沟通设计，而不是为了自我表达。把精力放在如何清晰、简洁地表达，而非放在文采上。&lt;/p&gt;&lt;section&gt;&lt;span/&gt; 前提三：设计文档为谁而写&lt;/section&gt;&lt;p&gt;&lt;strong&gt;首先先了解你的读者是谁？&lt;/strong&gt;在良好的文档分享文化下，读者不应该只是你的 TL 以及该设计文档的实施者，你的设计文档实际读者的范围往往大得多。在不确定的时候，经验做法是，假设的读者群体为：公司内部的、有一定工程经验的、但对该系统的上下文只有初步了解的软件工程师。&lt;/p&gt;&lt;p&gt;通常，设计文档的范围越大，假定的受众群也会更大。这意味着受众对目标系统的平均了解程度更低，也就意味着设计文档往往需要：&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;更加详细的背景介绍。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;更少使用内部术语或缩写。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;更多阐述设计思路、取舍，更少解释具体实现细节。&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;其次，考虑读者喜欢如何阅读？&lt;/strong&gt;大部分读者不会逐字逐句阅读你的设计文档。大家都很忙，通常只会扫描大体结构，然后阅读（或者跳读）自己感兴趣的部分。读者喜欢“故事”。将内容以故事的结构呈现最容易被接受，即使我们并不是需要讲述一个传统的打怪升级的故事。虽然故事内容各有不同，但大部分故事都遵循一些基本的范式。例如， 约瑟夫·坎伯总结提出全世界大部分神话故事都符合 “英雄之旅” -- “启程、启蒙、归程”三幕 -- 这个模式。&lt;/p&gt;&lt;p&gt;对于设计文档 / 科技论文写作，通用安全的选择是 Writing Science 所介绍的 OCAR 故事结构。&lt;/p&gt;&lt;p&gt;设计文档通常遵循特定的组织结构，我们可以将每一个结构对应到 OCAR 的不同部分，以此讲述故事。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;最后，辩证看待设计文档可读性。&lt;/strong&gt;设计文档可读性 vs. 代码可读性都称作可读性，两者有些共通之处：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.4929757343550447&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/YriaiaJPb26VNCaP8Tqls6uicAtgQRcms37Cy9zvC30fcC5oFdQPM0XExp5XyF0sJzyCNlnXqeKtfumKPXDMPpvHQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;783&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;section&gt;&lt;span&gt;3.2 设计文档的核心原则&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;在搞清楚设计文档撰写的三个前提后，就会进入文档的编写阶段。设计文档是非正式的文档，因此他们的内容不会遵循严格的准则，一个首要原则是，针对项目的具体情况可以用相对合理的方式来编写。尽管如此，笔者也参考文献并结合自身经验给出一些建议。&lt;/p&gt;&lt;section&gt;&lt;span/&gt; 写作风格的三要素&lt;/section&gt;&lt;p&gt;设计文档的写作也是技术写作（Technical Writing），因此同样强调以下三要素：&lt;/p&gt;&lt;section&gt;&lt;span/&gt; 设计文档的五个要点&lt;/section&gt;&lt;p&gt;系统设计及编写设计文档时需要注意的 5 个要点。&lt;/p&gt;&lt;ol class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;任何架构问题都是取舍。&lt;/strong&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;在软件设计中，没有任何一个维度有绝对意义上的优劣。每一个设计决定都需要考量很多相违背的因素。例如，可扩展性和效率相背；长期效率和短期收益相背；规模化提升了效率，但降低了灵活性。“高内聚低耦合” 便于迭代，但是会增加短期的开发成本。NoSQL 比 SQL 性能高，但代价是功能的大幅降低。&lt;/p&gt;&lt;p&gt;如果一个设计决策看上去没有任何的取舍，往往是因为取舍还没有被识别。在设计时应从取舍视角切入，寻找不同需求间的平衡。&lt;/p&gt;&lt;p&gt;2.  &lt;strong&gt;“为什么” 比 “怎么做” 更重要&lt;/strong&gt;。&lt;/p&gt;&lt;p&gt;设计所解决的问题往往是复杂而模糊的，因此，解决方案往往是不唯一的。对工程设计，方案的论证通常比方案本身更重要。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;3.  考虑时间维度&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;做设计取舍时不能忽略时间维度，只设计某个阶段的终态。设计需要考虑以下方面：&lt;/p&gt;&lt;p&gt;&lt;strong&gt;4.  避免过度设计&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;设计伊始，界定问题的范围。一个良好界定的问题是一个良好设计的必要条件。&lt;/p&gt;&lt;p&gt;不要迷信设计模型、设计模式、XX 驱动设计，这些是工具，而非法则；不要为了制造问题而解决问题；不要通过复杂的设计来体现工作的难度和深度: 一个困难的问题可能会有一个简单的答案；也不要过于担忧设计被迅速淘汰。保留可扩展性，但不要在未知时浪费精力扩展。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;5.  总结&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;最重要的是要知道如何设计，知道自己在设计什么。邓宁·克鲁格效应告诉我们，这未必显然。&lt;/p&gt;&lt;p&gt;I think test-driven design is great. I do that a lot more than I used to do. But you can test all you want and if you don’t know how to approach the problem, you’re not going to get a solution.&lt;/p&gt;&lt;p&gt;&lt;span&gt;- Coders at Work, Peter Norvig&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;3.3 设计文档的最佳实践&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span/&gt; 遣词&lt;/section&gt;&lt;p&gt;用词要简练、准确、直白。&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;正确使用专业术语。&lt;/p&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;合理地使用常见术语可以降低沟通成本。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;不要过多使用过于小众或自创的术语。&lt;/p&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;必要时提供对照的英文术语以方便理解。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;避免无上下文的缩略词。&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/ul&gt;&lt;li&gt;&lt;p&gt;省略程度副词。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;使用数据。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;忌佶屈聱牙。&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;section&gt;&lt;span/&gt; 造句&lt;/section&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;使用短句，不要使用多从句的复杂句式。&lt;/p&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;读者不是来考 GRE 的。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;写文档也不是为了炫耀自己可以驾驭长难句。&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/ul&gt;&lt;p&gt;“系统形式问题就是下面这样一个问题：怎样把各种不同的对象种类安排在一个系统中，以使较高的对象种类总能从较低的对象种类构造出来，也就是说前者可还原为后者。为了解决这个问题，我们必须从其相互可还原性来研究各种不同的对象种类。为此目的，我们要根据所涉及的对象领域的实际科学知识为每一个要考察的对象寻找其基本事实存在的充分而必要的条件的各种可能性。对此我们可采取下面的办法来进行，即要求这门实际科学给出基本事实的一个（确实而常在的）表征。”&lt;/p&gt;&lt;p&gt;Excerpt From: 【德】鲁道夫·卡尔纳普. “世界的逻辑构造.”&lt;/p&gt;&lt;section&gt;&lt;span/&gt; 段落&lt;/section&gt;&lt;p&gt;段落应该尽量短。通常，一个段落不要超过 8 个完整的句子。每个段落有且仅有一个清晰的主题。每个段落开头应该是主题句，方便读者快速了解段落大意。段落中的每一句话应该与主题紧密相关；否则，它应该另起段落，或者应该删掉。&lt;/p&gt;&lt;p&gt;注意段落的流动。段落句子应该始于一个读者已经熟悉的概念，将新的内容放在句子结尾。这样，读者可以更连贯地理解。&lt;/p&gt;&lt;section&gt;&lt;span/&gt; 使用列表&lt;/section&gt;&lt;p&gt;使用 Bullet point 标明无顺序的列表，使用数字序号明确前后顺序。如何正确使用列表不在本文详细展开，会在后续文章介绍（如果有后续的话），也可参见文末的参考文献。&lt;/p&gt;&lt;section&gt;&lt;span/&gt; 结构&lt;/section&gt;&lt;p&gt;&lt;strong&gt;使用模板：&lt;/strong&gt;使用模板可以作为思考辅助，同时也提供了相对较完整且规范的结构。文末提供了一份设计文档模板以供参考。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;使用图表：&lt;/strong&gt;一图胜千言。合理地使用图表可以极大地降低用户的理解成本。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;使用标题：&lt;/strong&gt;标题要分级、要简短清晰&lt;/p&gt;&lt;section&gt;&lt;span/&gt; 篇幅&lt;/section&gt;&lt;p&gt;设计文档不要过长。太多内容堆积在一个文档中会让读者丧失兴趣。&lt;/p&gt;&lt;p&gt;对于一个大型项目来说，10 页（~5000 字）左右是一个合适的长度。当超过这个长度时，可以考虑将问题拆分成子问题分别编写设计文档，并在总体设计文档中链接子设计文档。&lt;/p&gt;&lt;p&gt;对于小问题做增量的改进，考虑使用单页文档 (one-pager)。通常这类文档的范围较小，解决问题较简单，目标用户群体仅限于对问题已经有充分了解的内部成员。这时，可以省略背景等内容，而仅使用 目标 -- 方案 两段式论证的结构。&lt;/p&gt;&lt;section&gt;&lt;span/&gt; 排版&lt;/section&gt;&lt;p&gt;使用统一的字体。用户不会意识到不同的字体代表不同的含义，只会感受到混乱。微软雅黑是安全选择。&lt;/p&gt;&lt;p&gt;不要使用不同颜色来区分内容。不要在文中使用超过三种颜色。可以在标题及分级标题使用标志性的颜色，同时正文使用黑色。&lt;/p&gt;&lt;section&gt;&lt;span&gt;附录：设计文档模板&lt;/span&gt;&lt;/section&gt;&lt;p&gt;设计文档没有定式。即使如此，笔者参考谷歌设计文档的结构和格式，并结合实际工作经验加以完善。在此提供一个可供新手参考的设计文档模版，您可以使用此文档模板作为思考的基础。通常，无须事无巨细地填写每一部分，不相关的内容直接略过即可。&lt;/p&gt;&lt;section&gt;&lt;span&gt;目标&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;strong&gt;“我们要解决什么问题？”&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;用几句话说明该设计文档的关键目的，让读者能够一眼得知自己是否对该设计文档感兴趣。&lt;/p&gt;&lt;p&gt;如：“本文描述 Spanner 的顶层设计&quot;&lt;/p&gt;&lt;p&gt;继而，使用 Bullet Points 描述该设计试图达到的重要目标，如：&lt;/p&gt;&lt;p&gt;非目标也可能很重要。非目标并非单纯目标的否定形式，也不是与解决问题无关的其它目标，而是一些可能是读者非预期的、本可作为目标但并没有的目标，如：&lt;/p&gt;&lt;p&gt;如果可能，解释是基于哪些方面的考虑将之作为非目标。如：&lt;/p&gt;&lt;p&gt;设计不是试图达到完美，而是试图达到平衡。显式地声明哪些是目标，哪些是非目标，有助于帮助读者理解下文中设计决策的合理性，同时也有助于日后迭代设计时，检查最初的假设是否仍然成立。&lt;/p&gt;&lt;section&gt;&lt;span&gt;背景&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;strong&gt;“我们为什么要解决这个问题？”&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;为设计文档的目标读者提供理解详细设计所需的背景信息。按读者范围来提供背景。见上文关于目标读者的圈定。&lt;strong&gt;设计文档应该是“自足的”（self-contained），&lt;/strong&gt;即应该为读者提供足够的背景知识，使其无需进一步的查阅资料即可理解后文的设计。&lt;strong&gt;保持简洁，&lt;/strong&gt;通常以几段为宜，每段简要介绍即可。如果需要向读者提供进一步的信息，最好只提供链接。警惕知识的诅咒（知识的诅咒（Curse of knowledge）是一种认知偏差，指人在与他人交流的时候，下意识地假设对方拥有理解交流主题所需要的背景知识）。&lt;/p&gt;&lt;p&gt;背景通常可以包括：&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;需求动机以及可能的例子。如，“（tRPC) 微服务模式正在公司内变得流行，但是缺少一个通用的、封装了常用内部工具及服务接口的微服务框架”。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;此前的版本以及它们的问题。如，“(tRPC) Taf 是之前的应用框架， 有以下特点，…………， 但是有以下局限性及历史遗留问题”。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;其它已有方案， 如公司内其它方案或开源方案， &quot;tRPC v.s. gRPC v.s. Arvo&quot;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;相关的项目，如 &quot;tRPC 框架中可能会对接的其它 PCG 系统&quot;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;不要在背景中写你的设计，或对问题的解决思路。&lt;/p&gt;&lt;section&gt;&lt;span&gt;总体设计&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;strong&gt;“我们如何解决这个问题？”&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;用一页描述高层设计。说明系统的主要组成部分，以及一些关键设计决策。应该说明该系统的模块和决策如何满足前文所列出的目标。&lt;/p&gt;&lt;p&gt;本设计文档的评审人应该能够根据该总体设计理解你的设计思路并做出评价。描述应该对一个新加入的、不在该项目工作的腾讯工程师而言是可以理解的。&lt;/p&gt;&lt;p&gt;推荐使用 系统关系图 描述设计。它可以使读者清晰地了解文中的新系统和已经熟悉的系统间的关系，也可以包含新系统内部概要的组成模块。&lt;/p&gt;&lt;p&gt;注意：不要只放一个图而不做任何说明，请根据上面小节的要求用文字描述设计思想。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.5078125&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/YriaiaJPb26VNCaP8Tqls6uicAtgQRcms37bdqDt4icpglhqTwPAooqMmSTrel41K0ickCsAnicNibloISOcOJ6jmx02w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;640&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;一个示例系统关系图&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;1.0774818401937045&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/YriaiaJPb26VNCaP8Tqls6uicAtgQRcms37UArOIG0yyEXjGj1979ju0cibdKN6rxibRJyWibcic2ZPQGOODSMyt1voFQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;826&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;自举的文档结构图&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.8140625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/YriaiaJPb26VNCaP8Tqls6uicAtgQRcms37aJdmK5BdsX6SrKHrGRyHLv2tibTV7zE6eyGwWoTLwoRLQJ19EydUnkg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;640&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;可能不太好的顶层设计&lt;/span&gt;&lt;/p&gt;&lt;p&gt;不要在这里描述细节，放在下一章节中；不要在这里描述背景，放在上一章节中。&lt;/p&gt;&lt;section&gt;&lt;span&gt;详细设计&lt;/span&gt;&lt;/section&gt;&lt;p&gt;在这一节中，除了介绍设计方案的细节，还应该包括在产生最终方案过程中，主要的设计思想及权衡（tradeoff）。这一节的结构和内容因设计对象（系统，API，流程等）的不同可以自由决定，可以划分一些小节来更好地组织内容，尽可能以简洁明了的结构阐明整个设计。&lt;/p&gt;&lt;p&gt;不要过多写实现细节。就像我们不推荐添加只是说明&quot;代码做了什么&quot;的注释，我们也不推荐在设计文档中只说明你具体要怎么实现该系统。否则，为什么不直接实现呢？&lt;/p&gt;&lt;p&gt;以下内容可能是实现细节例子，不适合在设计文档中讨论：&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;API 的所有细节&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;存储系统的 Data Schema&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;具体代码或伪代码&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;该系统各模块代码的存放位置、各模块代码的布局&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;该系统使用的编译器版本&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;开发规范&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;通常可以包含以下内容（注意，小节的命名可以更改为更清晰体现内容的标题）：&lt;/p&gt;&lt;section&gt;&lt;span/&gt; 各子模块的设计&lt;/section&gt;&lt;p&gt;阐明一些复杂模块内部的细节，可以包含一些模块图、流程图来帮助读者理解。可以借助时序图进行展现，如一次调用在各子模块中的运行过程。每个子模块需要说明自己存在的意义。如无必要，勿添模块。如果没有特殊情况（例如该设计文档是为了描述并实现一个核心算法），不要在系统设计加入代码或者伪代码。&lt;/p&gt;&lt;section&gt;&lt;span/&gt; API 接口&lt;/section&gt;&lt;p&gt;如果设计的系统会暴露 API 接口，那么简要地描述一下 API 会帮助读者理解系统的边界。避免将整个接口复制粘贴到文档中，因为在特定编程语言中的接口通常包含一些语言细节而显得冗长，并且有一些细节也会很快变化。着重表现 API 接口跟设计最相关的主要部分即可。&lt;/p&gt;&lt;section&gt;&lt;span/&gt; 存储&lt;/section&gt;&lt;p&gt;介绍系统依赖的存储设计。该部分内容应该回答以下问题，如果答案并非显而易见：&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;该系统对数据 / 存储有哪些要求？&lt;/p&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;该系统会如何使用数据？&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;数据是什么类型的？&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;数据规模有多大？&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;读写比是多少？读写频率有多高？&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;对可扩展性是否有要求？&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;对原子性要求是什么？&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;对一致性要求是什么？是否需要支持事务？&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;对可用性要求是什么？对性能的要求是什么？&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;……&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;li&gt;&lt;p&gt;基于上面的事实，数据库应该如何选型？&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;数据的抽象以及数据间关系的描述至关重要。可以借助 ER 图 (Entity Relationshiop) 的方式展现数据关系。&lt;/p&gt;&lt;p&gt;回答上述问题时，尽可能提供数据，将数据作为答案或作为辅助。不要回答“数据规模很大，读写频繁”，而是回答“预计数据规模为 300T， 3M 日读出， 0.3M 日写入， 巅峰 QPS 为 300”。这样才能为下一步的具体数据库造型提供详细的决策依据，并让读者信服。&lt;/p&gt;&lt;p&gt;注意：在选型时也应包括可能会造成显著影响的非技术因素，如费用。&lt;/p&gt;&lt;p&gt;避免将所有数据定义（data schema）复制粘贴到文档中，因为 data schema 更偏实现细节。&lt;/p&gt;&lt;section&gt;&lt;span&gt;其他方案&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;strong&gt;“我们为什么不用另一种方式解决问题？”&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;在介绍了最终方案后，可以有一节介绍一下设计过程中考虑过的其他设计方案（Alternatives Considered）、它们各自的优缺点和权衡点、以及导致选择最终方案的原因等。通常，有经验的读者（尤其是方案的审阅者）会很自然地想到一些其他设计方案，如果这里的介绍描述了没有选择这些方案的原因，就避免读者带着疑问看完整个设计再来询问作者。这一节可以体现设计的严谨性和全面性。&lt;/p&gt;&lt;section&gt;&lt;span&gt;交叉关注点&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span/&gt; 基础设施&lt;/section&gt;&lt;p&gt;如果基础设施的选用需要特殊考量，则应该列出。&lt;/p&gt;&lt;p&gt;如果该系统的实现需要对基础设施进行增强或变更，也应该在此讨论。&lt;/p&gt;&lt;section&gt;&lt;span/&gt; 可扩展性&lt;/section&gt;&lt;p&gt;你的系统如何扩展？横向扩展还是纵向扩展？注意数据存储量和流量都可能会需要扩展。&lt;/p&gt;&lt;section&gt;&lt;span/&gt; 安全 &amp;amp; 隐私&lt;/section&gt;&lt;p&gt;项目通常需要在设计期即确定对安全性的保证，而难以事后补足。不同于其它部分是可选的，安全部分往往是必需的。即使你的系统不需要考虑安全和隐私，也需要显式地在本章说明为何是不必要的。安全性如何保证？&lt;/p&gt;&lt;p&gt;如何保证数据完整性（Data Integrity）？如何发现存储数据的损坏或丢失？如何恢复？由数据库保证即可，还是需要额外的安全措施？为了数据完整性，需要对稳定性、性能、可复用性、可维护性造成哪些影响？&lt;/p&gt;&lt;section&gt;&lt;span/&gt; 延迟&lt;/section&gt;&lt;p&gt;声明延迟的预期目标。描述预期延迟可能造成的影响，以及相关的应对措施。&lt;/p&gt;&lt;section&gt;&lt;span/&gt; 冗余 &amp;amp; 可靠性&lt;/section&gt;&lt;p&gt;是否需要容灾？是否需要过载保护、有损降级、接口熔断、轻重分离？是否需要备份？备份策略是什么？如何修复？在数据丢失和恢复之间会发生什么？&lt;/p&gt;&lt;section&gt;&lt;span/&gt; 稳定性&lt;/section&gt;&lt;p&gt;SLA 目标是什么？如果监控？如何保证？&lt;/p&gt;&lt;section&gt;&lt;span/&gt; 外部依赖&lt;/section&gt;&lt;p&gt;你的外部依赖的可靠性（如 SLA）如何？会对你的系统的可靠性造成何种影响？如果你的外部依赖不可用，会对你的系统造成何种影响？除了服务级的依赖外，不要忘记一些隐含的依赖，如 DNS 服务、时间协议服务、运行集群等。&lt;/p&gt;&lt;section&gt;&lt;span&gt;实现计划&lt;/span&gt;&lt;/section&gt;&lt;p&gt;描述时间及人力安排（如里程碑）。这利于相关人员了解预期，调整工作计划。&lt;/p&gt;&lt;section&gt;&lt;span&gt;未来计划&lt;/span&gt;&lt;/section&gt;&lt;p&gt;未来可能的计划会方便读者更好地理解该设计以及其定位。&lt;/p&gt;&lt;p&gt;我们确实应该把设计限定在当前问题，但是该设计可能是更高层系统所要解决问题的一部分，或者只是阶段性方案。读者可能会对方案的完整性有所疑问，会质疑到底问题是否得到完整解决，甚至会质疑该问题在更高层的系统中是否确实值得解决。“背景（过去）-- 当前方案 -- 未来计划” 三者的结合会为读者提供更好的全景图。&lt;/p&gt;&lt;section&gt;&lt;span&gt;附录：参考文献&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;参考文档&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span/&gt; 设计文档&lt;/section&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;如何编写软件工程设计文档 感谢 hankzheng，本文部分原文源自此文。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;Design Docs at Google[模板]&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;设计文档模板&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;Bzlmod 设计提案&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;[示例] 视频后台组件平台 - 总体设计&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;[示例] Unionplus K-List 存储设计替代方案&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;Unionplus K-List 存储设计替代方案&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;chromium 设计文档实例&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;section&gt;&lt;span/&gt; 技术写作&lt;/section&gt;&lt;section&gt;&lt;span&gt;参考书籍&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span/&gt; 写作 / 表达&lt;/section&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;Style, Joseph M. Williams / Joseph Bizup&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;金字塔原理 : 思考、写作和解决问题的逻辑, 巴巴拉·明托&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;写作这回事，斯蒂芬·金&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;The elements of style, William Strunk Jr. / E. B. White&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;Coders at work，Peter Siebel 采访 Joshua Block 原文：&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;span&gt;Joshua Block: &quot;Another is Elements of Style, which isn’t even a programming book. You should read it for two reasons: The first is that a large part of every software engineer’s job is writing prose. If you can’t write precise, coherent, readable specs, nobody is going to be able to use your stuff. So anything that improves your prose style is good. The second reason is that most of the ideas in that book are also applicable to programs.&quot;&lt;/span&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;精准表达，高田贵久&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;写作提高一点点，Mary-Kate Mackey&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;On writing well, William Zinsser&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;Artful Sentences, Virginia Tufte&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;section&gt;&lt;span/&gt; 技术写作 / 文献写作&lt;/section&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;写作是门手艺，刘军强&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;How to write a lot, Paul J. Silvia&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;Writing for Computer Science, Justin Zobel&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;The craft of research, Wayne C. Booth / Gregory G. Colomb / Joseph M. Williams&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;会读才会写， Phillip C. Shon&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;Writing Science, Joshua Schimel&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;section&gt;&lt;span/&gt; 故事&lt;/section&gt;&lt;p&gt;&lt;span&gt;前文强调了要讲故事。以下书目阐述了何谓故事、为什么要讲故事及如何讲故事：&lt;/span&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;Writing Science, Joshua Schimel&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;金字塔原理 : 思考、写作和解决问题的逻辑, 巴巴拉·明托&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;故事，Robert McKee&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;如何阅读一本文学书， 托马斯·福斯特&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;section&gt;&lt;span/&gt; 架构设计&lt;/section&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;Software engineering at Google, Titus Winters / Tom Manshreck / Hyrum K. Wright&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;Build Secure and realiable systems, Heather Adkins / Betsy Beyer / Paul Blankinship / Piotr Lewandowski / Ana Oprea / Adam Stubblefield&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;The Design of Design, Fredrick P. Brooks Jr.&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;Fundamentals of Software Architecture, Mark Richards / Neal Ford&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;section&gt;&lt;span/&gt; 图表&lt;/section&gt;&lt;section&gt;&lt;span/&gt; 列表&lt;/section&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;作者介绍：&lt;/span&gt;&lt;/strong&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;marinewu :  &lt;/span&gt;&lt;span&gt;腾讯 PCG 应用架构平台部 开发效率中心 Tech Lead,&lt;/span&gt;&lt;span&gt;有较丰富的 API 设计与评审经验，有及技术文档的写作与评审经验。&lt;/span&gt;&lt;span&gt;2021 年加入腾讯，主要负责 DevOps 工具体系开发和优化。&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;今日好文推荐&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MjM5MDE0Mjc4MA==&amp;amp;mid=2651134515&amp;amp;idx=1&amp;amp;sn=cb99e5206c48700d6c98ea9eeb09d3cd&amp;amp;chksm=bdb8e2608acf6b7618eea041b7c4e2417e1fe410c006c030d88bf5e43364fcfb6c25c9140ac7&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;是什么让 Redis“气急败坏”回击：13 年来，总有人想替 Redis 换套新架构&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;是什么让 Redis“气急败坏”回击：13 年来，总有人想替 Redis 换套新架构&lt;/a&gt;&lt;/p&gt;&lt;/section&gt;&lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MjM5MDE0Mjc4MA==&amp;amp;mid=2651134137&amp;amp;idx=1&amp;amp;sn=0d0a2d7812a3dab0f63665c06b9845de&amp;amp;chksm=bdb8e0ea8acf69fca983b799dbf32739cdba2fcbf16f8ff4cc90abdc84e3ec73379de4449789&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;你究竟有多了解开源？InfoQ《中国开源发展研究分析 2022 》发布&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot; hasload=&quot;1&quot;&gt;你究竟有多了解开源？InfoQ《中国开源发展研究分析 2022 》发布&lt;/a&gt;&lt;/p&gt;&lt;/section&gt;&lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MjM5MDE0Mjc4MA==&amp;amp;mid=2651133224&amp;amp;idx=1&amp;amp;sn=666f6918bb1a1c2664892cea887c5384&amp;amp;chksm=bdb8ed7b8acf646d02ee21b483331f2fb3fdb734efbd659ac02fc7bf5550a978362f456b8221&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;一晚上累计 292 万人紧盯 Flightradar24 网站，航班跟踪的技术原理是什么？&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot; hasload=&quot;1&quot;&gt;一晚上累计 292 万人紧盯 Flightradar24 网站，航班跟踪的技术原理是什么？&lt;/a&gt;&lt;/p&gt;&lt;/section&gt;&lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MjM5MDE0Mjc4MA==&amp;amp;mid=2651133223&amp;amp;idx=1&amp;amp;sn=122fd9abfeb628e46bb71e0d9eceff06&amp;amp;chksm=bdb8ed748acf646259b4f3f0c181a6d58cbfec95ed637e079c3c854a24d8716b50427a6b1c91&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;“台湾省山西刀削面”搜索过多，百度地图宕机；BOSS 直聘即将实行末位淘汰；B 站回应 HR 称核心用户是 Loser ｜Q 资讯&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot; hasload=&quot;1&quot;&gt;“台湾省山西刀削面”搜索过多，百度地图宕机；BOSS 直聘即将实行末位淘汰；B 站回应 HR 称核心用户是 Loser ｜Q 资讯&lt;/a&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;span/&gt; 内容推荐&lt;/section&gt;&lt;/section&gt;&lt;p&gt;InfoQ 研究中心首次发布行业报告——&lt;strong&gt;《中国开源发展研究分析 2022 》&lt;/strong&gt;，通过双环模型抽象了复杂的开源运转机制，解读开源生态中不同参与主体的价值和职能。&lt;/p&gt;&lt;p&gt;阅读报告你可以了解快速如何评价一个开源社区的运营情况；如何快速评价一个开源项目优秀程度；如何评价企业对开源的贡献；报告也建立了公正的评估模型，为业务决策提供更多参考依据。&lt;/p&gt;&lt;p&gt;我们在此基础上也评选了中国 Top 30 开源项目与中国对开源做出贡献的 Top 10 企业。同时我们也预测了未来开源发展的趋势。总之，&lt;strong&gt;如果你想了解开源， 那么一定不要错过这份报告！&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.5555555555555556&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/YriaiaJPb26VNCaP8Tqls6uicAtgQRcms37g1GEJz1ibJZtBvGN0NVv3PK4TvYrc52qibk4mVJVdKtMREFYl9f00ZfQ/640?wx_fmt=jpeg&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; data-type=&quot;jpeg&quot; data-w=&quot;900&quot;/&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;
          &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>485c67f0c047155f9d655d7b383caff9</guid>
<title>接口请求合并的3种技巧，性能直接爆表！</title>
<link>https://toutiao.io/k/p8wu6fu</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;将相似或重复请求在上游系统中合并后发往下游系统，可以大大降低下游系统的负载，提升系统整体吞吐率。文章介绍了 &lt;code&gt;hystrix collapser&lt;/code&gt;、&lt;code&gt;ConcurrentHashMultiset&lt;/code&gt;、自实现&lt;code&gt;BatchCollapser&lt;/code&gt; 三种请求合并技术，并通过其具体实现对比各自适用的场景。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;前言&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;工作中，我们常见的请求模型都是”请求-应答”式，即一次请求中，服务给请求分配一个独立的线程，一块独立的内存空间，所有的操作都是独立的，包括资源和系统运算。我们也知道，在请求中处理一次系统 I/O 的消耗是非常大的，如果有非常多的请求都进行同一类 I/O 操作，那么是否可以将这些 I/O 操作都合并到一起，进行一次 I/O 操作，是否可以大大降低下游资源服务器的负担呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;最近我工作之余的大部分时间都花在这个问题的探究上了，对比了几个现有类库，为了解决一个小问题把 &lt;code&gt;hystrix javanica&lt;/code&gt; 的代码翻了一遍，也根据自己工作中遇到的业务需求实现了一个简单的合并类，收获还是挺大的。可能这个需求有点”偏门”，在网上搜索结果并不多，也没有综合一点的资料，索性自己总结分享一下，希望能帮到后来遇到这种问题的小伙伴。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;Hystrix Collapser&lt;/span&gt;&lt;/h3&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;hystrix&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;开源的请求合并类库（知名的）好像也只有 Netflix 公司开源的 &lt;code&gt;Hystrix&lt;/code&gt; 了， &lt;code&gt;hystrix&lt;/code&gt; 专注于保持 WEB 服务器在高并发环境下的系统稳定，我们常用它的熔断器(&lt;code&gt;Circuit Breaker&lt;/code&gt;) 来实现服务的服务隔离和灾时降级，有了它，可以使整个系统不至于被某一个接口的高并发洪流冲塌，即使接口挂了也可以将服务降级，返回一个人性化的响应。请求合并作为一个保障下游服务稳定的利器，在 &lt;code&gt;hystrix&lt;/code&gt; 内实现也并不意外。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们在使用 &lt;code&gt;hystrix&lt;/code&gt; 时，常用它的 &lt;code&gt;javanica&lt;/code&gt; 模块，以注解的方式编写 hystrix 代码，使代码更简洁而且对业务代码侵入更低。所以在项目中我们一般至少需要引用 &lt;code&gt;hystrix-core&lt;/code&gt; 和 &lt;code&gt;hystrix-javanica&lt;/code&gt; 两个包。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;另外，&lt;code&gt;hystrix&lt;/code&gt; 的实现都是通过 AOP，我们要还要在项目 xml 里显式配置 &lt;code&gt;HystrixAspect&lt;/code&gt; 的 bean 来启用它。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&amp;lt;aop:aspectj-autoproxy/&amp;gt;  &lt;br/&gt;&amp;lt;bean id=&lt;span&gt;&quot;hystrixAspect&quot;&lt;/span&gt; class=&lt;span&gt;&quot;com.netflix.hystrix.contrib.javanica.aop.aspectj.HystrixCommandAspect&quot;&lt;/span&gt; /&amp;gt;  &lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;collapser&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;hystrix collapser 是 hystrix 内的请求合并器，它有自定义 BatchMethod 和 注解两种实现方式，自定义 BatchMethod 网上有各种教程，实现起来很复杂，需要手写大量代码，而注解方式只需要添加两行注解即可，但配置方式我在官方文档上也没找见，中文方面本文应该是独一份儿了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其实现需要注意的是：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;我们在需要合并的方法上添加 &lt;code&gt;@HystrixCollapser&lt;/code&gt; 注解，在定义好的合并方法上添加 &lt;code&gt;@HystrixCommand&lt;/code&gt; 注解；&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;single 方法只能传入一个参数，多参数情况下需要自己包装一个参数类，而 batch 方法需要 &lt;code&gt;java.util.List&amp;lt;SingleParam&amp;gt;&lt;/code&gt;；&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;single 方法返回 &lt;code&gt;java.util.concurrent.Future&amp;lt;SingleReturn&amp;gt;&lt;/code&gt;， batch 方法返回 &lt;code&gt;java.util.List&amp;lt;SingleReturn&amp;gt;&lt;/code&gt;，且要保证返回的结果数量和传入的参数数量一致。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;下面是一个简单的示例:&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;HystrixCollapserSample&lt;/span&gt; &lt;/span&gt;{  &lt;br/&gt;  &lt;br/&gt;    &lt;span&gt;@HystrixCollapser&lt;/span&gt;(batchMethod = &lt;span&gt;&quot;batch&quot;&lt;/span&gt;)  &lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; Future&amp;lt;Boolean&amp;gt; &lt;span&gt;single&lt;/span&gt;&lt;span&gt;(String input)&lt;/span&gt; &lt;/span&gt;{  &lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;; &lt;span&gt;// single方法不会被执行到  &lt;/span&gt;&lt;br/&gt;    }  &lt;br/&gt;  &lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; List&amp;lt;Boolean&amp;gt; &lt;span&gt;batch&lt;/span&gt;&lt;span&gt;(List&amp;lt;String&amp;gt; inputs)&lt;/span&gt; &lt;/span&gt;{  &lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; inputs.stream().map(it -&amp;gt; Boolean.TRUE).collect(Collectors.toList());  &lt;br/&gt;    }  &lt;br/&gt;}  &lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;源码实现&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;为了解决 &lt;code&gt;hystrix collapser&lt;/code&gt; 的配置问题看了下 &lt;code&gt;hystrix javanica&lt;/code&gt; 的源码，这里简单总结一下 hystrix 请求合并器的具体实现，源码的详细解析在我的笔记：&lt;code&gt;Hystrix collasper&lt;/code&gt; 源码解析。&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;在 spring-boot 内注册切面类的 bean，里面包含 @HystrixCollapser 注解切面；&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;在方法执行时检测到方法被 HystrixCollapser 注解后，spring 调用 &lt;code&gt;methodsAnnotatedWithHystrixCommand&lt;/code&gt;方法来执行 hystrix 代理;&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;hystrix 获取一个 collapser 实例（在当前 scope 内检测不到即创建）;&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;hystrix 将当前请求的参数提交给 collapser， 由 collapser 存储在一个 &lt;code&gt;concurrentHashMap （RequestArgumentType -&amp;gt; CollapsedRequest）&lt;/code&gt;内，此方法会创建一个 Observable 对象，并返回一个 观察此对象的 Future 给业务线程；&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;collpser 在创建时会创建一个 timer 线程，定时消费存储的请求，timer 会将多个请求构造成一个合并后的请求，调用 batch 执行后将结果顺序映射到输出参数，并通知 Future 任务已完成。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;需要注意，由于需要等待 timer 执行真正的请求操作，collapser 会导致所有的请求的 cost 都会增加约 timerInterval/2 ms;&lt;/p&gt;&lt;/blockquote&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;配置&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;hystrix collapser&lt;/code&gt; 的配置需要在 &lt;code&gt;@HystrixCollapser&lt;/code&gt; 注解上使用，主要包括两个部分，专有配置和 hystrixCommand 通用配置；&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;专有配置包括：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;code&gt;collapserKey&lt;/code&gt;，这个可以不用配置，hystrix 会默认使用当前方法名；&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;code&gt;batchMethod&lt;/code&gt;，配置 batch 方法名，我们一般会将 single 方法和 batch 方法定义在同一个类内，直接填方法名即可；&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;code&gt;scope&lt;/code&gt;，最坑的配置项，也是逼我读源码的元凶，&lt;code&gt;com.netflix.hystrix.HystrixCollapser.Scope&lt;/code&gt; 枚举类，有 REQUEST, GLOBAL 两种选项，在 scope 为 REQUEST 时，hystrix 会为每个请求都创建一个 collapser， 此时你会发现 batch 方法执行时，传入的请求数总为1。而且 REQUEST 项还是默认项，不明白这样请求合并还有什么意义；&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;code&gt;collapserProperties&lt;/code&gt;, 在此选项内我们可以配置 &lt;code&gt;hystrixCommand&lt;/code&gt; 的通用配置；&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;通用配置包括：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;code&gt;maxRequestsInBatch&lt;/code&gt;, 构造批量请求时，使用的单个请求的最大数量；&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;code&gt;timerDelayInMilliseconds&lt;/code&gt;, 此选项配置 collapser 的 timer 线程多久会合并一次请求；&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;code&gt;requestCache.enabled&lt;/code&gt;, 配置提交请求时是否缓存；&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;一个完整的配置如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;@HystrixCollapser&lt;/span&gt;(  &lt;br/&gt;            batchMethod = &lt;span&gt;&quot;batch&quot;&lt;/span&gt;,  &lt;br/&gt;            collapserKey = &lt;span&gt;&quot;single&quot;&lt;/span&gt;,  &lt;br/&gt;            scope = com.netflix.hystrix.HystrixCollapser.Scope.GLOBAL,  &lt;br/&gt;            collapserProperties = {  &lt;br/&gt;                    &lt;span&gt;@HystrixProperty&lt;/span&gt;(name = &lt;span&gt;&quot;maxRequestsInBatch&quot;&lt;/span&gt;, value = &lt;span&gt;&quot;100&quot;&lt;/span&gt;),  &lt;br/&gt;                    &lt;span&gt;@HystrixProperty&lt;/span&gt;(name = &lt;span&gt;&quot;timerDelayInMilliseconds&quot;&lt;/span&gt;, value = &lt;span&gt;&quot;1000&quot;&lt;/span&gt;),  &lt;br/&gt;                    &lt;span&gt;@HystrixProperty&lt;/span&gt;(name = &lt;span&gt;&quot;requestCache.enabled&quot;&lt;/span&gt;, value = &lt;span&gt;&quot;true&quot;&lt;/span&gt;)  &lt;br/&gt;            })  &lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;BatchCollapser&lt;/span&gt;&lt;/h3&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;设计&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;由于业务需求，我们并不太关心被合并请求的返回值，而且觉得 hystrix 保持那么多的 Future 并没有必要，于是自己实现了一个简单的请求合并器，业务线程简单地将请求放到一个容器里，请求数累积到一定量或延迟了一定的时间，就取出容器内的数据统一发送给下游系统。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;设计思想跟 hystrix 类似，合并器有一个字段作为存储请求的容器，且设置一个 timer 线程定时消费容器内的请求，业务线程将请求参数提交到合并 器的容器内。不同之处在于，业务线程将请求提交给容器后立即同步返回成功，不必管请求的消费结果，这样便实现了时间维度上的合并触发。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;另外，我还添加了另外一个维度的触发条件，每次将请求参数添加到容器后都会检验一下容器内请求的数量，如果数量达到一定的阈值，将在业务线程内合并执行一次。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;由于有两个维度会触发合并，就不可避免会遇到线程安全问题。为了保证容器内的请求不会被多个线程重复消费或都漏掉，我需要一个容器能满足以下条件：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;是一种 Collection，类似于 ArrayList 或 Queue，可以存重复元素且有顺序;&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;在多线程环境中能安全地将里面的数据全取出来进行消费，而不用自己实现锁。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;java.util.concurrent&lt;/code&gt; 包内的 LinkedBlockingDeque 刚好符合要求，首先它实现了 BlockingDeque 接口，多线程环境下的存取操作是安全的；此外，它还提供 &lt;code&gt;drainTo(Collection&amp;lt;? super E&amp;gt; c, int maxElements)&lt;/code&gt;方法，可以将容器内 maxElements 个元素安全地取出来，放到 Collection c 中。&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;实现&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;以下是具体的代码实现：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;BatchCollapser&lt;/span&gt;&amp;lt;&lt;span&gt;E&lt;/span&gt;&amp;gt; &lt;span&gt;implements&lt;/span&gt; &lt;span&gt;InitializingBean&lt;/span&gt; &lt;/span&gt;{  &lt;br/&gt;     &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; Logger logger = LoggerFactory.getLogger(BatchCollapser&lt;span&gt;.&lt;span&gt;class&lt;/span&gt;)&lt;/span&gt;;  &lt;br/&gt;     &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;volatile&lt;/span&gt; Map&amp;lt;Class, BatchCollapser&amp;gt; instance = Maps.newConcurrentMap();  &lt;br/&gt;     &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; ScheduledExecutorService SCHEDULE_EXECUTOR = Executors.newScheduledThreadPool(&lt;span&gt;1&lt;/span&gt;);  &lt;br/&gt;  &lt;br/&gt;     &lt;span&gt;private&lt;/span&gt; &lt;span&gt;volatile&lt;/span&gt; LinkedBlockingDeque&amp;lt;E&amp;gt; batchContainer = &lt;span&gt;new&lt;/span&gt; LinkedBlockingDeque&amp;lt;&amp;gt;();  &lt;br/&gt;     &lt;span&gt;private&lt;/span&gt; Handler&amp;lt;List&amp;lt;E&amp;gt;, Boolean&amp;gt; cleaner;  &lt;br/&gt;     &lt;span&gt;private&lt;/span&gt; &lt;span&gt;long&lt;/span&gt; interval;  &lt;br/&gt;     &lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; threshHold;  &lt;br/&gt;  &lt;br/&gt;     &lt;span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;BatchCollapser&lt;/span&gt;&lt;span&gt;(Handler&amp;lt;List&amp;lt;E&amp;gt;, Boolean&amp;gt; cleaner, &lt;span&gt;int&lt;/span&gt; threshHold, &lt;span&gt;long&lt;/span&gt; interval)&lt;/span&gt; &lt;/span&gt;{  &lt;br/&gt;         &lt;span&gt;this&lt;/span&gt;.cleaner = cleaner;  &lt;br/&gt;         &lt;span&gt;this&lt;/span&gt;.threshHold = threshHold;  &lt;br/&gt;         &lt;span&gt;this&lt;/span&gt;.interval = interval;  &lt;br/&gt;     }  &lt;br/&gt;  &lt;br/&gt;     &lt;span&gt;@Override&lt;/span&gt;  &lt;br/&gt;     &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;afterPropertiesSet&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;span&gt;throws&lt;/span&gt; Exception &lt;/span&gt;{  &lt;br/&gt;         SCHEDULE_EXECUTOR.scheduleAtFixedRate(() -&amp;gt; {  &lt;br/&gt;             &lt;span&gt;try&lt;/span&gt; {  &lt;br/&gt;                 &lt;span&gt;this&lt;/span&gt;.clean();  &lt;br/&gt;             } &lt;span&gt;catch&lt;/span&gt; (Exception e) {  &lt;br/&gt;                 logger.error(&lt;span&gt;&quot;clean container exception&quot;&lt;/span&gt;, e);  &lt;br/&gt;             }  &lt;br/&gt;         }, &lt;span&gt;0&lt;/span&gt;, interval, TimeUnit.MILLISECONDS);  &lt;br/&gt;     }  &lt;br/&gt;  &lt;br/&gt;     &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;submit&lt;/span&gt;&lt;span&gt;(E event)&lt;/span&gt; &lt;/span&gt;{  &lt;br/&gt;         batchContainer.add(event);  &lt;br/&gt;         &lt;span&gt;if&lt;/span&gt; (batchContainer.size() &amp;gt;= threshHold) {  &lt;br/&gt;             clean();  &lt;br/&gt;         }  &lt;br/&gt;     }  &lt;br/&gt;  &lt;br/&gt;     &lt;span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;clean&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{  &lt;br/&gt;         List&amp;lt;E&amp;gt; transferList = Lists.newArrayListWithExpectedSize(threshHold);  &lt;br/&gt;         batchContainer.drainTo(transferList, &lt;span&gt;100&lt;/span&gt;);  &lt;br/&gt;         &lt;span&gt;if&lt;/span&gt; (CollectionUtils.isEmpty(transferList)) {  &lt;br/&gt;             &lt;span&gt;return&lt;/span&gt;;  &lt;br/&gt;         }  &lt;br/&gt;  &lt;br/&gt;         &lt;span&gt;try&lt;/span&gt; {  &lt;br/&gt;             cleaner.handle(transferList);  &lt;br/&gt;         } &lt;span&gt;catch&lt;/span&gt; (Exception e) {  &lt;br/&gt;             logger.error(&lt;span&gt;&quot;batch execute error, transferList:{}&quot;&lt;/span&gt;, transferList, e);  &lt;br/&gt;         }  &lt;br/&gt;     }  &lt;br/&gt;  &lt;br/&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &amp;lt;E&amp;gt; &lt;span&gt;BatchCollapser &lt;span&gt;getInstance&lt;/span&gt;&lt;span&gt;(Handler&amp;lt;List&amp;lt;E&amp;gt;, Boolean&amp;gt; cleaner, &lt;span&gt;int&lt;/span&gt; threshHold, &lt;span&gt;long&lt;/span&gt; interval)&lt;/span&gt; &lt;/span&gt;{  &lt;br/&gt;         Class jobClass = cleaner.getClass();  &lt;br/&gt;         &lt;span&gt;if&lt;/span&gt; (instance.get(jobClass) == &lt;span&gt;null&lt;/span&gt;) {  &lt;br/&gt;             &lt;span&gt;synchronized&lt;/span&gt; (BatchCollapser&lt;span&gt;.&lt;span&gt;class&lt;/span&gt;) &lt;/span&gt;{  &lt;br/&gt;                 &lt;span&gt;if&lt;/span&gt; (instance.get(jobClass) == &lt;span&gt;null&lt;/span&gt;) {  &lt;br/&gt;                     instance.put(jobClass, &lt;span&gt;new&lt;/span&gt; BatchCollapser&amp;lt;&amp;gt;(cleaner, threshHold, interval));  &lt;br/&gt;                 }  &lt;br/&gt;             }  &lt;br/&gt;         }  &lt;br/&gt;  &lt;br/&gt;         &lt;span&gt;return&lt;/span&gt; instance.get(jobClass);  &lt;br/&gt;     }  &lt;br/&gt; }  &lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;以下代码内需要注意的点：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;由于合并器的全局性需求，需要将合并器实现为一个单例，另外为了提升它的通用性，内部使用使用 concurrentHashMap 和 double check 实现了一个简单的单例工厂。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;为了区分不同用途的合并器，工厂需要传入一个实现了 Handler 的实例，通过实例的 class 来对请求进行分组存储。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;由于 &lt;code&gt;java.util.Timer&lt;/code&gt; 的阻塞特性，一个 Timer 线程在阻塞时不会启动另一个同样的 Timer 线程，所以使用 &lt;code&gt;ScheduledExecutorService&lt;/code&gt; 定时启动 Timer 线程。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;ConcurrentHashMultiset&lt;/span&gt;&lt;/h3&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;设计&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上面介绍的请求合并都是将多个请求一次发送，下游服务器处理时本质上还是多个请求，最好的请求合并是在内存中进行，将请求结果简单合并成一个发送给下游服务器。如我们经常会遇到的需求：元素分值累加或数据统计，就可以先在内存中将某一项的分值或数据累加起来，定时请求数据库保存。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Guava 内就提供了这么一种数据结构：&lt;code&gt;ConcurrentHashMultiset&lt;/code&gt;，它不同于普通的 set 结构存储相同元素时直接覆盖原有元素，而是给每个元素保持一个计数 count, 插入重复时元素的 count 值加1。而且它在添加和删除时并不加锁也能保证线程安全，具体实现是通过一个 &lt;code&gt;while(true)&lt;/code&gt; 循环尝试操作，直到操作够所需要的数量。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;ConcurrentHashMultiset&lt;/code&gt; 这种排重计数的特性，非常适合数据统计这种元素在短时间内重复率很高的场景，经过排重后的数量计算，可以大大降低下游服务器的压力，即使重复率不高，能用少量的内存空间换取系统可用性的提高，也是很划算的。&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;实现&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;使用 &lt;code&gt;ConcurrentHashMultiset&lt;/code&gt; 进行请求合并与使用普通容器在整体结构上并无太大差异，具体类似于：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;if&lt;/span&gt; (ConcurrentHashMultiset.isEmpty()) {  &lt;br/&gt;    &lt;span&gt;return&lt;/span&gt;;  &lt;br/&gt;}  &lt;br/&gt;  &lt;br/&gt;List&amp;lt;Request&amp;gt; transferList = Lists.newArrayList();  &lt;br/&gt;ConcurrentHashMultiset.elementSet().forEach(request -&amp;gt; {  &lt;br/&gt;    &lt;span&gt;int&lt;/span&gt; count = ConcurrentHashMultiset.count(request);  &lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (count &amp;lt;= &lt;span&gt;0&lt;/span&gt;) {  &lt;br/&gt;        &lt;span&gt;return&lt;/span&gt;;  &lt;br/&gt;    }  &lt;br/&gt;  &lt;br/&gt;    transferList.add(count == &lt;span&gt;1&lt;/span&gt; ? request : &lt;span&gt;new&lt;/span&gt; Request(request.getIncrement() * count));  &lt;br/&gt;    ConcurrentHashMultiset.remove(request, count);  &lt;br/&gt;});  &lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;小结&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;最后总结一下各个技术适用的场景：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;code&gt;hystrix collapser&lt;/code&gt;: 需要每个请求的结果，并且不在意每个请求的 cost 会增加；&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;code&gt;BatchCollapser&lt;/code&gt;: 不在意请求的结果，需要请求合并能在时间和数量两个维度上触发；&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;code&gt;ConcurrentHashMultiset&lt;/code&gt;：请求重复率很高的统计类场景；&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;另外，如果选择自己来实现的话，完全可以将 &lt;code&gt;BatchCollapser&lt;/code&gt; 和 &lt;code&gt;ConcurrentHashMultiset&lt;/code&gt; 结合一下，在BatchCollapser 里使用 &lt;code&gt;ConcurrentHashMultiset&lt;/code&gt; 作为容器，这样就可以结合两者的优势了&lt;/p&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>4fc0ec88417308e6f026e5e083089c78</guid>
<title>高性能异步编排框架 Gobrs-Async 1.0.3-SNAPSHOT 版本更新</title>
<link>https://toutiao.io/k/p1eq7ad</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content                           autoTypeSetting24psection&amp;#10;                          &quot; id=&quot;js_content&quot;&gt;
            &lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;Gobrs-Async 1.0.3-SNAPSHOT 版本更新&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;更新内容&lt;/strong&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;关于&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;Gobrs-Async&lt;/strong&gt; 是一款功能强大、配置灵活、带有全链路异常回调、内存优化、异常状态管理于一身的高性能异步编排框架。为企业提供在复杂应用场景下动态任务编排的能力。针对于复杂场景下，异步线程复杂性、任务依赖性、异常状态难控制性的现象提供了快速高效的解决方案。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;一、可选的任务执行逻辑&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在application.yml 中 配置的任务流程， 非必要执行配置的所有任务如下：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.3356258596973865&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/KCPYGythicQJQMSxYFmXOFaxDOic1pHXZ7sIickUqtIH286A55oBo4sMfeibQlfEyiavo1DGlAAWBw3UlwvFWB41Ccg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1454&quot;/&gt;&lt;figcaption&gt;image-20220809221727601&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;配置任务&lt;/strong&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt; &lt;span&gt;&quot;AService-&amp;gt;BService-&amp;gt;FService;HService,EService,GService&quot;&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果用户在使用时只希望执行 FService , 则在任务链中 只需要执行AService、BService、FService 即可。无需执行H、E、G任务。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;适应场景&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在做 &lt;strong&gt;ISV&lt;/strong&gt;  (京东商城ISV组件化建设)  建设时， 楼层中的多个组件可能存在着任务流程的编排， 所需要的上游数据数量多少不一，所以此时就需要进行编排流程中的任务选择执行处理了。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;如下对每个组件进行编排数据编排处理&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;![&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1.7468354430379747&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/KCPYGythicQJQMSxYFmXOFaxDOic1pHXZ7Nry8KFyXjS3ibJlXKUQEkEm5sV3g60u9opd5aAUftDQw0cYYicepACJg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;948&quot;/&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;二、修复issue&lt;/h2&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;修复任务链中某一任务执行异常，后续子任务无需执行的逻辑。当 failSubExec 为true 时， 单条流程中的任务异常不会影响后续子任务执行。否则终止子任务的调用执行。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1.2259194395796849&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/KCPYGythicQJQMSxYFmXOFaxDOic1pHXZ7Us5mSnQoG3fsNFI7ibZtfRyfexpozaoA5YyTbWJ7yoiagvmOa6ibStG4Q/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1142&quot;/&gt;&lt;figcaption&gt;image-20220809222738453&lt;/figcaption&gt;&lt;/figure&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;友情链接&lt;/h2&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;官网地址&lt;/section&gt;&lt;section&gt;&lt;strong&gt;gitee https://gitee.com/dromara/gobrs-async&lt;/strong&gt;&lt;/section&gt;&lt;section&gt;&lt;strong&gt;  gitHub https://github.com/dromara/gobrs-async&lt;/strong&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;沟通&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;对于这个项目，是否有什么不一样看法，欢迎在 Issue 一起沟通交流；群二维码七天会失效，可以添加作者微信进交流群&lt;/p&gt;&lt;/section&gt;&lt;section mp-original-font-size=&quot;14&quot; mp-original-line-height=&quot;28&quot;&gt;&lt;section mp-original-font-size=&quot;14&quot; mp-original-line-height=&quot;28&quot;&gt;&lt;section mp-original-font-size=&quot;14&quot; mp-original-line-height=&quot;28&quot; data-darkmode-bgcolor-16546951171124=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16546951171124=&quot;#fff|rgb(255, 255, 255)&quot; data-style=&quot;padding-right: 10px; padding-bottom: 10px; padding-left: 10px; outline: 0px; max-width: 100%; box-sizing: border-box; display: inline-block; width: 811.297px; vertical-align: top; align-self: flex-start; flex: 0 0 auto; box-shadow: rgb(152, 152, 152) 0px 0px 2px; border-width: 2px 0px 0px; border-radius: 10px; border-style: solid; border-color: rgb(21, 87, 246) rgb(62, 62, 62) rgb(62, 62, 62); background-color: rgb(255, 255, 255); line-height: 28px; overflow-wrap: break-word !important;&quot;&gt;&lt;section powered-by=&quot;xiumi.us&quot; mp-original-font-size=&quot;14&quot; mp-original-line-height=&quot;28&quot; data-darkmode-bgcolor-16546951171124=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16546951171124=&quot;#fff|rgb(255, 255, 255)&quot;&gt;&lt;section mp-original-font-size=&quot;14&quot; mp-original-line-height=&quot;28&quot; data-darkmode-bgcolor-16546951171124=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16546951171124=&quot;#fff|rgb(255, 255, 255)&quot;&gt;&lt;section mp-original-font-size=&quot;12&quot; mp-original-line-height=&quot;28&quot; data-darkmode-bgcolor-16546951171124=&quot;rgb(21, 87, 246)&quot; data-darkmode-original-bgcolor-16546951171124=&quot;#fff|rgb(255, 255, 255)|rgb(21, 87, 246)&quot; data-darkmode-color-16546951171124=&quot;rgb(255, 255, 255)&quot; data-darkmode-original-color-16546951171124=&quot;#fff|rgb(255, 255, 255)&quot;&gt;&lt;section powered-by=&quot;xiumi.us&quot; mp-original-font-size=&quot;12&quot; mp-original-line-height=&quot;28&quot; data-darkmode-bgcolor-16546951171124=&quot;rgb(21, 87, 246)&quot; data-darkmode-original-bgcolor-16546951171124=&quot;#fff|rgb(255, 255, 255)|rgb(21, 87, 246)&quot; data-darkmode-color-16546951171124=&quot;rgb(255, 255, 255)&quot; data-darkmode-original-color-16546951171124=&quot;#fff|rgb(255, 255, 255)&quot;&gt;&lt;p mp-original-font-size=&quot;12&quot; mp-original-line-height=&quot;28&quot; data-darkmode-bgcolor-16546951171124=&quot;rgb(21, 87, 246)&quot; data-darkmode-original-bgcolor-16546951171124=&quot;#fff|rgb(255, 255, 255)|rgb(21, 87, 246)&quot; data-darkmode-color-16546951171124=&quot;rgb(255, 255, 255)&quot; data-darkmode-original-color-16546951171124=&quot;#fff|rgb(255, 255, 255)&quot;&gt;&lt;span mp-original-font-size=&quot;14&quot; mp-original-line-height=&quot;28&quot; data-darkmode-bgcolor-16546951171124=&quot;rgb(21, 87, 246)&quot; data-darkmode-original-bgcolor-16546951171124=&quot;#fff|rgb(255, 255, 255)|rgb(21, 87, 246)&quot; data-darkmode-color-16546951171124=&quot;rgb(255, 255, 255)&quot; data-darkmode-original-color-16546951171124=&quot;#fff|rgb(255, 255, 255)&quot;&gt;关于 Dromara&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot; mp-original-font-size=&quot;14&quot; mp-original-line-height=&quot;28&quot; data-darkmode-bgcolor-16546951171124=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16546951171124=&quot;#fff|rgb(255, 255, 255)&quot;&gt;&lt;section mp-original-font-size=&quot;11&quot; mp-original-line-height=&quot;22&quot; data-darkmode-bgcolor-16546951171124=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16546951171124=&quot;#fff|rgb(255, 255, 255)&quot; data-darkmode-color-16546951171124=&quot;rgb(100, 100, 100)&quot; data-darkmode-original-color-16546951171124=&quot;#fff|rgb(100, 100, 100)&quot;&gt;&lt;p mp-original-font-size=&quot;11&quot; mp-original-line-height=&quot;22&quot; data-darkmode-bgcolor-16546951171124=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16546951171124=&quot;#fff|rgb(255, 255, 255)&quot; data-darkmode-color-16546951171124=&quot;rgb(100, 100, 100)&quot; data-darkmode-original-color-16546951171124=&quot;#fff|rgb(100, 100, 100)&quot;&gt;&lt;span mp-original-font-size=&quot;14&quot; mp-original-line-height=&quot;28&quot; data-darkmode-bgcolor-16546951171124=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16546951171124=&quot;#fff|rgb(255, 255, 255)&quot; data-darkmode-color-16546951171124=&quot;rgb(100, 100, 100)&quot; data-darkmode-original-color-16546951171124=&quot;#fff|rgb(100, 100, 100)&quot;&gt;Dromara 是由国内顶尖的开源项目作者共同组成的开源社区。提供包括分布式事务，流行工具，企业级认证，&lt;span data-darkmode-bgcolor-16546951171124=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16546951171124=&quot;#fff|rgb(255, 255, 255)&quot; data-darkmode-color-16546951171124=&quot;rgb(100, 100, 100)&quot; data-darkmode-original-color-16546951171124=&quot;#fff|rgb(100, 100, 100)&quot;&gt;微服务RPC&lt;/span&gt;，运维监控，Agent监控，分布式日志，调度编排等一系列开源产品、解决方案与咨询、技术支持与培训认证服务。技术栈全面开源共建、 保持社区中立，致力于为全球用户提供微服务云原生解决方案。让参与的每一位开源爱好者，体会到开源的快乐。&lt;/span&gt;&lt;/p&gt;&lt;p mp-original-font-size=&quot;11&quot; mp-original-line-height=&quot;22&quot; data-darkmode-bgcolor-16546951171124=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16546951171124=&quot;#fff|rgb(255, 255, 255)&quot; data-darkmode-color-16546951171124=&quot;rgb(100, 100, 100)&quot; data-darkmode-original-color-16546951171124=&quot;#fff|rgb(100, 100, 100)&quot;&gt;&lt;br mp-original-font-size=&quot;11&quot; mp-original-line-height=&quot;22&quot; data-darkmode-bgcolor-16546951171124=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16546951171124=&quot;#fff|rgb(255, 255, 255)&quot; data-darkmode-color-16546951171124=&quot;rgb(100, 100, 100)&quot; data-darkmode-original-color-16546951171124=&quot;#fff|rgb(100, 100, 100)&quot;/&gt;&lt;/p&gt;&lt;p mp-original-font-size=&quot;11&quot; mp-original-line-height=&quot;22&quot; data-darkmode-bgcolor-16546951171124=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16546951171124=&quot;#fff|rgb(255, 255, 255)&quot; data-darkmode-color-16546951171124=&quot;rgb(100, 100, 100)&quot; data-darkmode-original-color-16546951171124=&quot;#fff|rgb(100, 100, 100)&quot;&gt;&lt;span mp-original-font-size=&quot;14&quot; mp-original-line-height=&quot;28&quot; data-darkmode-bgcolor-16546951171124=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16546951171124=&quot;#fff|rgb(255, 255, 255)&quot; data-darkmode-color-16546951171124=&quot;rgb(100, 100, 100)&quot; data-darkmode-original-color-16546951171124=&quot;#fff|rgb(100, 100, 100)&quot;&gt;Dromara开源社区目前拥有10+GVP项目，总star数量超过十万，构建了上万人的开源社区，有成千上万的个人及团队在使用Dromara社区的开源项目。&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;
          &lt;/div&gt;

          

          



           
                                
                    
        &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>