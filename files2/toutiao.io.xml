<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>6e6622d0d0c9ff8820989251287bd0e5</guid>
<title>kafka 精妙设计撑起百万TPS</title>
<link>https://toutiao.io/k/g4ey2vk</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;header class=&quot;post-header&quot;&gt;

        
        
          &lt;h2 class=&quot;post-title&quot; itemprop=&quot;name headline&quot;&gt;kafka 精妙设计撑起百万TPS&lt;/h2&gt;
        

        &lt;div class=&quot;post-meta&quot;&gt;
          &lt;span class=&quot;post-time&quot;&gt;
            
              &lt;span class=&quot;post-meta-item-icon&quot;&gt;
                &lt;i class=&quot;fa fa-calendar-o&quot;/&gt;
              &lt;/span&gt;
              
                &lt;span class=&quot;post-meta-item-text&quot;&gt;发表于&lt;/span&gt;
              
              &lt;time title=&quot;创建于&quot; itemprop=&quot;dateCreated datePublished&quot; datetime=&quot;2022-09-21T08:00:00+08:00&quot;&gt;2022-09-21&lt;/time&gt;
            

            
            

            
          &lt;/span&gt;

          
            &lt;span class=&quot;post-category&quot;&gt;
            
              &lt;span class=&quot;post-meta-divider&quot;&gt;|&lt;/span&gt;
            
              &lt;span class=&quot;post-meta-item-icon&quot;&gt;
                &lt;i class=&quot;fa fa-folder-o&quot;/&gt;
              &lt;/span&gt;
              
                &lt;span class=&quot;post-meta-item-text&quot;&gt;分类于&lt;/span&gt;
              
              
                &lt;span itemprop=&quot;about&quot; itemscope=&quot;&quot; itemtype=&quot;http://schema.org/Thing&quot;&gt;&lt;a href=&quot;/categories/kafka/&quot; itemprop=&quot;url&quot; rel=&quot;index&quot;&gt;&lt;span itemprop=&quot;name&quot;&gt;kafka&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;

                
                
              
            &lt;/span&gt;
          

          
            
          

          
          

          

          

          
              &lt;p class=&quot;post-description&quot;&gt;Kafka是如何做到超高并发(百万级)的，设计很是精妙，配合巧用文件系统，mmap技术，消息批量处理，零拷贝，简洁的消费者逻辑来完成。尤其是他的暴力输入输出美学，深受启发，对某些应用场景很是有启发作用。&lt;/p&gt;
          

        &lt;/div&gt;
      &lt;/header&gt;
    

    
    
    
    
      
      &lt;div class=&quot;post-body&quot; itemprop=&quot;articleBody&quot;&gt;

      
      

      
        &lt;p&gt;目前项目的日志收集用到了kafka，每天收集几亿条日志数据，梳理了一下kafka在高并发方面的知识，来帮助理解Kafka是如何做到超高并发(百万级)的，设计很是精妙，尤其是他的暴力输入输出美学，深受启发，并在后续项目中得到了应用。&lt;/p&gt;
&lt;h2 id=&quot;巧用文件系统&quot;&gt;&lt;a href=&quot;#巧用文件系统&quot; class=&quot;headerlink&quot; title=&quot;巧用文件系统&quot;/&gt;巧用文件系统&lt;/h2&gt;&lt;p&gt;按照kafka官网的话说，不要害怕文件系统。可能很多人一想到磁盘就会想到慢这个字，但是磁盘的性能表现好坏在于你的使用。&lt;/p&gt;
&lt;p&gt;我们以kafka官方例子为例，在6个7200rpm SATA RAID-5 阵列的 JBOD 配置上，顺序写入性能约每秒600MB，而随机写入的性能约每秒100k，差了6000倍。可以看一下官方给出的性能图对比&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://yunsonbai.top/images/kafka/kafka3-xn.jpeg&quot; alt=&quot;yunsonbai.top-kafka百万TPS&quot;/&gt;&lt;/p&gt;
&lt;p&gt;首先顺序操作磁盘免去了大量的寻道和旋转延迟，因为即将访问的扇区刚好位于上次访问的扇区后边，磁头立刻就找到了扇区。其次顺序读写是最可预测的，而且操作系统做了大量这方面的优化，操作系统提供了预读和延迟写入技术，使得可以以块整数倍的大小预取数据，并把小块写入逻辑，聚合成大块物理写入。&lt;/p&gt;
&lt;h2 id=&quot;mmap技术应用&quot;&gt;&lt;a href=&quot;#mmap技术应用&quot; class=&quot;headerlink&quot; title=&quot;mmap技术应用&quot;/&gt;mmap技术应用&lt;/h2&gt;&lt;p&gt;除了顺序操作磁盘，充分利用操作系统将空闲内存转义到磁盘缓存这个机制，及mmap技术。使用mmap技术，进程可以像操作硬盘一样操作内存，这种方式可以大幅度提升I/O性能，也能省去用户空间到内核空间的复制开销。可能有人会问，为什么程序不自己维护缓存，要交给操作系统，先不说增加了用户空间到内核空间的拷贝过程，还有一点kafka基于Java开发的，Java中对象内存开销大，堆内存的增加，GC过程会越来越繁琐和缓慢，使用页缓存，可以使程序迅速重启，缓存也可继续使用。&lt;/p&gt;
&lt;p&gt;长时间保留消息，而不是阅后即焚。在持久化消息上，并没有使用像MySQL那样的BTree，因为BTree的操作是O(logN) 磁盘操作寻道时间可能就会达到10毫秒，开销巨大，kafka直接采用简单的读取和追加到文件上，操作为O(1)，性能与数据大小分离。廉价的机器照样能跑出高性能。没有了频发的数据删除操作，相当于又进一步减小了磁盘寻道损耗，而且还能使消费端更加灵活的消费(可以重新消费之前消费过的数据)。&lt;/p&gt;
&lt;h2 id=&quot;消息批量处理&quot;&gt;&lt;a href=&quot;#消息批量处理&quot; class=&quot;headerlink&quot; title=&quot;消息批量处理&quot;/&gt;消息批量处理&lt;/h2&gt;&lt;p&gt;首先思考一下，有一百条消息，分成一百次通过网络传给远端机器快，还是做好聚合，一次性传给远端机器快？如果内部网络一秒能传输10M以上的数据，如果把百万条消息压缩在在10M数据上，然后通过网络一次性传给远端，那是不是就相当于完成了百万级的TPS？&lt;/p&gt;
&lt;p&gt;我想上边的答案非常明显，显然是批量处理更快，能更大程度的减少网络io带来的延迟。Kafka就采用了这个方式，给你的感觉像是每次在一条一条push消息，其实不然，Kafka会在内存中暂存你的消息，在适当的时机，一下子把所有消息发送出去，也就是一波消息被发走。&lt;/p&gt;
&lt;p&gt;消息批量处理并不是只是发送的时候是批量，而是从生产者、broker到消费者一直都是这样，这个批次的消息在kafka看来好像就是一条消息一样，生产者在生产端将消息聚合，broker什么都不做，按”一个“消息存储，最后由消费者拿到消息后解开一条条消费。问题来了，都知道kafka利用offset机制实现从不同位置消费消息，如果消息批量了，我该怎么消费批量里边的某条呢？看下边的例子&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://yunsonbai.top/images/kafka/kafka3-offset.png&quot; alt=&quot;yunsonbai.top-kafka百万TPS&quot;/&gt;&lt;/p&gt;
&lt;p&gt;offset传36、37还是38是一样的都是拿图中38的开头的消息，消费者拿到这个集体消息后，在取出感兴趣的消息即可。&lt;/p&gt;
&lt;p&gt;另外为了提升传输效率，kafka还做了端到端的消息压缩，生产者将批量消息压缩，broker原样保存压缩数据，最有有消费者获取后解压缩，这又进一步提升了传输效率。&lt;/p&gt;
&lt;p&gt;总而言之，批量处理和压缩的目的就是使用相当小的cpu开销，换取高效的网路传输，解决网络带宽的瓶颈。&lt;/p&gt;
&lt;h2 id=&quot;零拷贝&quot;&gt;&lt;a href=&quot;#零拷贝&quot; class=&quot;headerlink&quot; title=&quot;零拷贝&quot;/&gt;零拷贝&lt;/h2&gt;&lt;p&gt;通常情况下，文件数据到套接字传输的数据路径要经过4个步骤：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;操作系统从磁盘读取数据到内核空间缓冲区&lt;/li&gt;
&lt;li&gt;应用程序从内核空间读取数据到用户空间缓冲区&lt;/li&gt;
&lt;li&gt;应用程序将数据写回内核空间套接字缓冲区&lt;/li&gt;
&lt;li&gt;操作系统将数据从套接字缓冲区赋值到网络发送的NIC缓冲区&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这四步数据会在数据总线上来来回回被传输，而零拷贝(主要函数sendfile)解决了这个问题，只需两步&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;DMA从硬盘读数据到操作系统内核读缓冲区&lt;/li&gt;
&lt;li&gt;根据套接字描述服信息，直接从读缓冲区里面写入到网卡的缓冲区&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这显然比通常的四步骤高效的多。想下这个场景，如果消费的足够快，页缓存和零拷贝是不是可以让消费者消费的消息几乎都是从缓存中拿到的数据，根本不用去读磁盘(数据还没来得及从缓存中失效就被消费者拉走了)。&lt;/p&gt;
&lt;h2 id=&quot;简洁的消费者逻辑&quot;&gt;&lt;a href=&quot;#简洁的消费者逻辑&quot; class=&quot;headerlink&quot; title=&quot;简洁的消费者逻辑&quot;/&gt;简洁的消费者逻辑&lt;/h2&gt;&lt;p&gt;kafka没有采用推的方式通知消费者，而是由消费者自己根据消费情况，主动拉取消息，首先服务端没有了主动推的压力，另外消费端也变的非常的灵活。如果是拉，还需要再解决一个及时性的问题，堆积的未读消息多，消费者可以一直拉，但是如果此时没有消息，如果消息到了怎么能及时让消费者能知道呢？即便消费者每隔一段时间过来拉取，照样还是存在时延，kafak为了避免这种情况，在拉取请求中设置了参数，允许消费者请求在“长轮询”中阻塞，等待数据到达。&lt;/p&gt;
&lt;p&gt;在kafka中多个消费者构成一个消费组，这些消费者拥有消费组的共有属性，例如都能去消费消费组目标topic的消息。&lt;/p&gt;
&lt;p&gt;在记录消费者消费到哪条消息上，更是简洁，kafka并不为每个消费者维护一个”消费进度“。在kafka中每个topic分为一组完全有序的partitions，消息落地在partitions上，每个partitions在某个时刻只能有一个消费组内的消费者去消费，每个partitions只记录消费组在本partitions的消费的topic的”消费进度“，消费者来到这个partitions，kafka只需要找到消费者所在的消费组在本partitions的”消费进度“然后给出后边消息即可。&lt;/p&gt;
&lt;p&gt;这有很大的优势，kafka免去了复杂的消费者消费进度维护逻辑，使其变得相当简单和易于维护，而且partitions做到了单点(一个消费者)消费，免去了多点带来的问题。另外需要注意消费者数量尽量和partitions数量一致，这样每个partitions都能分到一个消费者，如果消费者多于partitions数量，就意味着有的消费者空闲，消费者少于partitions数量，就意味着有的消费者消费多个partitions。&lt;br/&gt;如果想进一步提升消费速度，其中方法之一就是适当的增加partitions的数量，使得更多的消费者去消费。&lt;/p&gt;

      
    &lt;/div&gt;

    
      


    

    
    
    

    
      &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>6ce42f2cc2b0b919d2d8d9b455dbc272</guid>
<title>从0到1000万：哔哩哔哩直播架构演进史</title>
<link>https://toutiao.io/k/c1wadvv</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;本期作者&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.75&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/1BMf5Ir754SewtjRgeHFd6PHHVmzdqUoQ6bhW5icaFJ5vuuicrwtTNPF0eus8jUdiawdc6zoP36MWbHgaU8KnFNqQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1080&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;p&gt;赵海林&lt;/p&gt;&lt;/section&gt;&lt;section&gt;&lt;p&gt;&lt;span&gt;B端技术中心资深开发工程师&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;01 前言&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;哔哩哔哩直播成立于 2014 年，经过 8 年时间的发展已经从最初的业务试水成长为公司重要的业务板块之一。技术架构也从一个单体服务演进为由数百个微服务组成的复杂系统。本文将回顾 8 年来哔哩哔哩直播架构演进中一步步的变化，带你了解它是如何从 0 开始逐渐成为能够承载千万在线的微服务系统。&lt;/p&gt;&lt;/section&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;02 从0到1&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;和大多数网站一样直播也是始于一套 LAMP 架构，即 Linux + Apache + MySQL + PHP 。前端、服务端、定时任务所有功能都集中在一个叫做 &quot;live-app-web&quot; 的项目中。&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.3131313&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/1BMf5Ir754SewtjRgeHFd6PHHVmzdqUoMtLVTpicTKia05McVQWFLPkEhSHPVGyGxJOic4mseUiajqj5ef2brdt2eA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;693&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt; 直播系统架构&lt;/p&gt;&lt;/section&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;一个典型直播后台架构由三部分组成：业务系统用于直播各种业务功能逻辑实现、推拉流系统用于主播推流和用户拉流观看、长连接系统用于在直播中的各类实时业务数据推送触达。而 live-app-web 即承担了 application server 的角色。&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.3194444&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/1BMf5Ir754SewtjRgeHFd6PHHVmzdqUooibZMLA9DEQTRXea5nBCaicSd8rRa99Apz1vib3bS0cYADx3xyOQ4QNDA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;live-app-web 的应用架构&lt;/p&gt;&lt;/section&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;在 live-app-web 中既有通过 PHP 模板引擎 Smarty 渲染的页面，也有JS 写的前端页面，还有常驻后台的 PHP 消息队列处理程序（通过 Redis List 实现的生产-消费模型），这些功能被分别放在各自的代码目录中，分别由前后端开发人员进行代码开发，并最终部署到一台台物理机上。&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.526971&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/1BMf5Ir754SewtjRgeHFd6PHHVmzdqUoA6OnrnBPM9RTcfpGkrqZl3dyhWExiaQR0hpedxoibxCQJzickiavlqMqcg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;964&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;live-app-web 最初的项目结构&lt;/p&gt;&lt;/section&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;虽然现在看起来这套架构非常简陋，但在最初的 2 年里我们在 live-app-web 实现了每个直播平台所必备的各类业务系统，而这些系统也在后续的演进中也在不断发展壮大成为一个个重要且独立的业务系统。&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.3752577&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/1BMf5Ir754SewtjRgeHFd6PHHVmzdqUo7swR58JjoNmgKkkwkTBK9dd5IvTl654wN3zDjHibemSXHDuP6hfZtvQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;970&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;live-app-web&lt;/p&gt;&lt;/section&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;像任何一个高速发展的业务一样，live-app-web 的代码量也在急速增长，从 2015年中的 5W 行 PHP 代码到年末的 8W 行，再到 2016 年中已经累计到了 13W 行。我们在这期间做了一定的前后端分离改造，将前端部分拆成一个个单独的前端应用，如直播首页、直播房间页、直播个人中心页等。但随着业务增长和人员扩充单体应用带来的问题也越来越多，并行项目带来的合并冲突、发布排队、某个子模块问题导致整站挂等问题日渐突出，而这些问题也终于在一个重要事件上集中爆发了。&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6884058&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/1BMf5Ir754SewtjRgeHFd6PHHVmzdqUoD6W9eib5nunfDPevbf9C3SULFgegOR8QvVZ8iaO3gIfFuUF8czARMgfg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;828&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;2016 年某一时刻的 git 状态&lt;/p&gt;&lt;/section&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;03 局座来了&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;不了解局座B站直播梗的同学可以先通过这个链接了解一下事件背景：&lt;span&gt;如何看待张召忠将军7月13日的b站直播？&lt;sup&gt;[1]&lt;/sup&gt;&lt;/span&gt;，一句话总结就是：局座来了直播挂了，睿总在知乎公开道歉。&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.4740741&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/1BMf5Ir754SewtjRgeHFd6PHHVmzdqUonBeYUQHbvyu1ZnvlpTicHcYy4d5HvDer06iaqibJ6u7oLv0T5hkvZDENA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;当时的直播几乎受到全网的群嘲，微博、知乎各类吐槽的声音铺天盖地。回头来看一方面是对观看人数的预估不足，另一方面受到单体服务架构的制约，监控告警、资源弹性、限流降级、故障隔离等手段都非常缺乏。痛定思痛之后直播开启了微服务化的历程。&lt;/p&gt;&lt;/section&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;04 微服务化&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;如何做微服务？这是摆在当时团队的一大难题，由于当时团队成员主要是 PHP 背景，同时业务也在快速迭代，切换语言从 0 开始显然是不现实的。而当时正好有一款在国内很火的 PHP 高性能服务框架 Swoole，通过进程常驻的方式显著提升了 PHP 服务的运行性能。经过一定的技术调研之后团队决定以 Swoole 为基础构建直播的微服务框架，并定义了以下原则：&lt;/p&gt;&lt;/section&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;ol class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;按业务领域进行微服务拆分&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;每个微服务拥有自己独立的数据库、缓存&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;每个微服务仅能访问自己的数据库、缓存，服务间只能通过 RPC 访问&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;微服务负责人对自己的负责业务的服务稳定性负责&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;服务框架：我们基于 Swoole 开发了我们自己的微服务框架，这套微服务框架实现服务进程管理、平滑重启、ORM、Cache、Logging 等，业务只需要按照模板实现  controller 和对应 service 代码即可，能够比较快速地上手开发。&lt;/p&gt;&lt;p&gt;通信协议：微服务间通信我们采用了基于 TCP 上自行封装的 RPC 协议并称之为 liverpc ，这个 RPC 协议非常简单直观，通过固定长度 Header 头 + 变长JSON Body 实现，服务间以 TCP 短连接进行服务调用。&lt;/p&gt;&lt;p&gt;服务发现：引入微服务后还需要解决的一个问题是如何做服务发现？结合当时的背景我们选择了 zookeeper 作为服务发现组件，同时为了隔离服务注册、发现、健康检查的复杂性，我们专门开发了一个叫做 Apollo 的业务伴生程序用于服务配置拉取、服务注册、服务节点发现，业务框架通过文件监听的方式感知配置变化进行热加载。&lt;/p&gt;&lt;p&gt;配置管理：同样地我们采用了 zookeeper 来保存每个服务的配置文件，并通过 Apollo 进行配置拉取和变更监控。&lt;/p&gt;&lt;p&gt;消息队列：我们搭建专门的 kafka 机器作为消息队列，由于 PHP 直接跟 Kafka 交互较为复杂，我们搭建了专门的投递代理服务 publisher 和消息回调通知服务 notify。&lt;/p&gt;&lt;p&gt;统一网关：另一方面针对缺乏统一限流、降级能力的问题，我们单独开发了一个网关服务 live-api ，并且要求所有外部的访问都需要经过 live-api 转发到对应的业务服务。在这一层统一网关上我们实现了 流量转发、URL 重写、超时控制、限流、缓存、降级等能力。live-api 也是基于 swoole 实现的，不同的地方在于我们是通过 swoole 提供的纯异步 client 实现，在性能上有一定保证。&lt;/p&gt;&lt;p&gt;至此一整套微服务系统的雏形已经显现出来。&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.7203704&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/1BMf5Ir754SewtjRgeHFd6PHHVmzdqUoQichKWjpQWpIp69ZLJUM8dpVL1Eo2niaE8pvAH5KBDIJFQwC6ALhYYMA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;在这一套微服务系统上我们逐渐将 live-app-web 各自业务域的逻辑重构到对应的服务中。同时我们和 DBA 一起协作完成了直播的数据库在线拆分，将原来集中在一个库的业务表拆分到一个个独立的数据库中，实现了高速路上换轮子，也彻底解除了存储层混用的风险。&lt;/p&gt;&lt;p&gt;2017 年12月局座再次来到 B 站开直播，带来了比去年多得多的流量，但这一次我们稳了。&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1.6009615&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/1BMf5Ir754SewtjRgeHFd6PHHVmzdqUo0PxAkRqcyvLuNLzyiarEPdRzXzDVQsQQgTd80hKzQibjLbYibm89AmTWg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;832&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;05 容器化&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;一直以来直播服务均采用物理机部署的方式，这种方式存在明显的缺陷：需要为每个服务分配独立的端口避免端口冲突、部署目录需要隔离、存在资源竞争、单个服务容量无法准确评估等等。而随着 B 站业务规模的扩大，公司的基建团队也提供了更为稳定的容器平台，在充分调研后我们启动了服务 Docker 化改造并在很短的时间内完成了全部服务的容器化部署。&lt;/p&gt;&lt;p&gt;在 Docker 化部署中面临的一个问题是：如何选择 CPU 调度方式 ？&lt;/p&gt;&lt;p&gt;我们知道在 Docker 中通常有两个方式 ：1、CFS （完全公平调度）即通过按比例的 CPU 时间分片进行调度，这种资源分配方式比较灵活，也可以通过资源超配来提升整体的资源使用率；2、CPUSET（绑核）这种方式通过设置 CPU 亲和性将 POD 绑定到指定的一个或多个 CPU，实现资源上的独占。&lt;/p&gt;&lt;p&gt;我们在将 PHP 服务迁移 Docker 时发现 CFS 模式下接口超时非常严重，已经达到了无法接受的程度，因此所有的 PHP 服务均采用了 CPUSET 的方式部署，同时 PHP 服务的工作进程数也通过压测的方式得到最佳配置，为分配的 CPU 数量的 3~4 倍表现最佳。&lt;/p&gt;&lt;p&gt;在 CPUSET 模式下同样存在的突发流量的困扰，这类突发流量在 Prometheus 的监控图表中难以发现，因为监控数据通常是以30s 周期采集拟合生成监控曲线。但在请求日志上我们可以清晰地看到一条条秒级的请求突刺存在，而这些请求量远远超过了我们为服务配置的 CPUSET 数量，而要满足这种突发流量而调高配额显然也是不现实的，因为这会造成极大的资源浪费。&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.1675926&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/1BMf5Ir754SewtjRgeHFd6PHHVmzdqUoh6bIITNIQK1sFgYNwJfM2PHwkQ2kCibcEiaGxnvWd2ib8ymq86SC7ET9w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;针对这种场景我们将应用资源池分成了两个分组：固定资源池和弹性资源池，固定资源池中的服务采用 CPUSET 固定分配好资源量，而弹性资源池采用多个服务混部的方式，单个服务不限制其资源使用量。并通过网关对突发流量进行分流，将突发流量引入到弹性资源池，以此来解决突发流量带来的容量瓶颈。&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.3796296&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/1BMf5Ir754SewtjRgeHFd6PHHVmzdqUoCtZ0A6eqP4ramQib2UNySkF38uKFjtIq4lkU2WoGzTroLial2F76AXUA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;网关服务 live-api 会实时统计每个接口的 QPS：当 QPS 小于 X 时流量全部转发到固定资源池分组，当 QPS &amp;gt; X 时超出阈值的请求会被转发到弹性资源池。同时我们实现了请求打标功能，在弹性资源池内的请求会优先请求同在弹性资源池的服务。我们也可以通过观察弹性资源池的的利用率来判断固定资源池服务是否需要扩容，最终的目的是通过少量的混部弹性资源池来解决个别服务频繁的突发流量报错。&lt;/p&gt;&lt;p&gt;关于 CFS 超时的问题后来在阿里云公开的文章中有了更详细的阐述，并通过 CPU Burst 技术将 CFS 调度导致的超时问题大大缓解，CPU Burst  的核心是将我们常用的令牌桶限流算法引入到了 Linux 内核 CPU 调度上，当 CPU 使用率低于设定的配额时可以累计未使用的配额，并在后续的调度中允许使用累计的这部分配额来应对突出流量。随后内核团队通过内核升级、优化等方式解决了 cgoup泄露、调度不均衡、超时等问题。同时在内核上通过调度算法优化，利用  CPU Burst、Group Identity 、SMT expeller 等技术实现了在离线业务混部互不影响、全站资源合池等重大技术特性，资源容量和利用率得到极大提升。业务应用也不再通过 CPUSET 这种相对固定的资源分配方式，而是在CFS调度模式下通过 VPA、HPA 这样的弹性资源管理策略，动态、按需地获得所需要的运行资源。&lt;/p&gt;&lt;/section&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;06 Golang 真香&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;2018 年是 Golang 大火的一年，毛老师作为 Golang 布道师在哔哩哔哩主站推进 Golang 服务化演进非常成功，并通过 Golang 开发出了一系列的微服务框架和中间件，如 Kratos（Go微服务框架）、Discovery（服务发现）、Overload （缓存代理）等，相当一部分项目也同时在 github 上进行了开源。&lt;/p&gt;&lt;p&gt;彼时的直播正面临着下一步技术演进的抉择，因为基于 swoole 构建的 PHP 微服务体系已经不能支撑更大的流量了，其主要问题集中在 ：&lt;/p&gt;&lt;/section&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;ol class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;PHP 的多进程同步模型极易因为单个下游异常而导致整个服务挂掉，因为下游响应变慢 PHP Worker 不能及时释放，新的请求来了之后只能排队等待空闲 Worker，这样的级联等待进而导致系统的雪崩。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;实现 RPC 并发调用较为困难，在一些业务复杂的场景由于只能串行调用下游接口，导致最终对外的接口耗时非常高。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;PHP 服务扩容带来了数据库、缓存连接数的压力，当时还没有成熟的数据库代理，而是每个 PHP Worker 都会直连数据库，这直接导致了连接数的爆炸，进一步限制了 PHP 服务的扩容能力。&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;/section&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;而 Golang 的协程模型正好可以解决这些问题，毛老师在主站 Golang 服务化演进基本完成的情况下亲自来到直播指导 Golang 服务化演进。&lt;/p&gt;&lt;p&gt;对于这次 Golang 服务化演进，我们将服务划分为了三种类型：&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;ol class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;业务网关（interface）：业务网关按业务场景进行划分，如 App、Web 网关，在网关内完成对应场景的 API 接入，对下游业务服务的数据聚合、App 版本差异处理、功能模块降级等。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;业务服务（service）：业务服务按业务领域划分，如房间服务、礼物服务，不同的业务服务完成各自的业务逻辑。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;业务任务（job）：业务JOB是依附于业务服务的，通常是用于定时任务处理、异步队列消费等场景。&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.3453704&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/1BMf5Ir754SewtjRgeHFd6PHHVmzdqUoECNjbnia0WjEspxvlCj5fto4FZ8mqdcD208fGQNXhbmPc8fib9CP8qgw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;其中特别要提到业务网关的设计，在直播首页、房间页的场景中，由于业务逻辑复杂客户端通常需要调用十个甚至数十个接口，部分接口还存在时序依赖。不仅客户端代码实现复杂，还导致了客户端页面展现的延迟。因此在新的 Golang 网关实现中我们把单一场景的展示数据统一聚合到一个接口中，即打开一个页面只需要调用 1~2 的接口即可完成页面功能渲染。随后我们还在业务网关实现了热点数据主动缓存、下游服务异常的自动降级等特性。&lt;/p&gt;&lt;p&gt;经过几个服务的试点后发现基于Golang 的服务无论在接口耗时还是稳定性上均远超 PHP 服务，特别是网关需要聚合 10几个下游的数据时，通过协程的并发处理接口平均耗时不到原来 PHP 服务的一半。在此后的一段时间越来越多的 Golang 服务创建，更多的 API 也通过 Golang 网关对外提供到 哔哩哔哩 Web、PC、Android、iOS 等各种设备中。&lt;/p&gt;&lt;/section&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;07 live-app-web 的终结&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;2019年直播最早的服务 live-app-web 终于完成了它的使命，所有线上功能全部完成重构迁移，实现了 live-app-web 服务整体下线。截止下线时 live-app-web 已累计了 19W 行代码、上百位 contributers，感谢他们！&lt;/p&gt;&lt;/section&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;08 新网关的诞生&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;回到 Goalng 微服务演进过程中，我们并没有让曾经的 live-api 网关承接 Golang 业务网关的流量，一方面是因为当时 swoole 没有成熟的异步 http client，另一方面则是基于 PHP 的纯异步网关也逐渐显露出性能瓶颈。而问题在 2019 年也逐渐暴露出来了：&lt;/p&gt;&lt;/section&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;ol class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;Golang 业务网关限流需要业务在各自服务内分别接入、配置修改后需要重启生效。某个紧急情况下甚至发现部分服务未接入限流组件。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;live-api 在更大的业务流量下表现不佳，已经成为一个瓶颈，而存量 PHP 服务在相当长一段时间还需要持续迭代和提供服务。&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;/section&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;对新网关的需求应运而生，在调研了 Kong、Tyk、Envoy 等多个开源网关，我们决定采用 Envoy 作为数据面，自研 Golang 服务作为控制面的方式来实现新网关。Envoy 在 service mesh 领域几乎是 No.1 的存在，其非常适合作为流量转发服务。我们将新网关命名为 Ekango。&lt;/p&gt;&lt;p&gt;为了进一步移除 live-api，我们将原有基于 TCP 的 liverpc 协议升级支持了 HTTP 调用，这样就可以将请求从 Ekango 直接转发到对应的 PHP 服务，同时也极大地便利了研发的开发、调试成本。&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.4138889&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/1BMf5Ir754SewtjRgeHFd6PHHVmzdqUoLO26ibTvAltxiciadiaO1v82M3HFh0Bd6wckicnyNL1aFoQIa9b6n7iah0xg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;在 Ekango 网关中我们实现了分布式限流、接口条件 Rewrite、接口降级、统一鉴权、接口风控、多活可用区降级等特性，并提供单机 15W+ QPS 的服务能力。&lt;/p&gt;&lt;p&gt;同时我们基于 Ekango 的设计开发经验，基于 Envoy 实现了 service mesh 应用：Yuumi。Yuumi 是解决 PHP、JS 等语言访问 Golang 开发的 GRPC 服务问题的解决方案，因为长期以来微服务建设围绕 Golang 生态展开，对于其他语言的支持却略显薄弱。对于直播而言我们希望 PHP 服务也一样能享受到 Golang 生态同等的服务治理能力，并且能够方便地调用 GRPC 服务。&lt;/p&gt;&lt;p&gt;Yuumi 的实现解决了这一问题，通过 service mesh 的方式 PHP/JS 进程以 HTTP 协议访问本地的 sidecar 进程，由 sidecar 再将请求转发到对应的 HTTP 或  GRPC 服务，并且业务服务无需关心服务节点发现、节点错误重试、节点负载均衡等等微服务治理问题。&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.2991968&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/1BMf5Ir754SewtjRgeHFd6PHHVmzdqUowAWHyerbD0WCL2udZjMgPp6AocPc03HayRqqQs8znZHlUVwmzfGvcA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;996&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;Ekango 帮助直播支持了数个百万级、千万级的大型活动均有稳定的性能表现。但他也存在一些缺陷，如部署配置复杂、C++ 代码难以二次开发，特别是流量治理和管控能力缺乏可视化的控制面，只有少数几个开发者才能正确配置。我们在之前的文章中有介绍过微服务团队开发了 B 站统一的网关，其在支持常规的流量治理能力外，还提供了全流程可视化的接入方式和管控面、API 元数据管理、全链路灰度发布等高级特性。因此在充分评估之后直播也将网关流量全量迁移到统一网关上，由统一网关对全站的入口流量进行流量管控和治理。统一网关同时也作为 Kratos 开源项目之一在 Github 上同步更新。&lt;/p&gt;&lt;p&gt;至此直播的架构演进基本告一段落，在此之后我们进行了消息队列和定时任务的角色拆分、分布式任务调度的引入彻底解决服务单点部署问题。同时积极推动业务多活落地以解决更大范围的可用性问题，服务好直播业务的快速发展。在架构演进过程中我们也碰到了一些典型问题，在这里也对这些问题的处理作一定的总结，希望能启发你的思考。&lt;/p&gt;&lt;/section&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;09 关于热Key&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;热点问题无处不在，抢购、秒杀、抽奖、一次大型活动、突发事件都会形成一个个热点，而最直接的影响就是产生热数据，进而导致单节点被打挂、服务雪崩等可怕结果。对于直播业务而言，最容易产生热 Key 的就是那些热门房间，即我们称之为高在线房间。随着直播架构的迭代，我们对于热 Key 的处理方式也在发生变化，但都围绕着多级缓存、分而治之的思路进行，同时也需要考虑数据一致性、时效性，不能盲目地通过加缓存的方式来解决热 Key。&lt;/p&gt;&lt;/section&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt; 9.1 PHP 服务的高在线热点缓存&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.3314815&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/1BMf5Ir754SewtjRgeHFd6PHHVmzdqUodMiaicO2oZArlWU3w7NInwgbC1n91RgCcTQIibvybibpPoHD6VXfe6yPHw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;在 PHP 微服务时代我们通过一个集中的 monitor-service 收集来自 CDN 和 弹幕长连接数据，获得当前在线人数较高的房间，并将这些房间信息推送到消息队列中。由关心热门房间的服务 job 消费到这些热门房间信息，将各自业务可能涉及的热点数据主动推送到缓存中。而服务进程内也会有一个定时器监听这些热门缓存 Key，并定时将这些数据直接拉到 PHP 进程的内存当中。这样热门房间的业务数据就会直接命中内存缓存。&lt;/p&gt;&lt;/section&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt; 9.2 &lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;Golang 服务的高在线热点缓存&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;在 Golang 服务建设中我们简化了热门房间检测逻辑，直接提供了一个热门房间 SDK，业务服务可以直接通过 SDK 判断特定的 room_id / uid 是否属于热点，而由 SDK 内部定时拉取热门房间列表信息。业务再通过定时器将热点房间数据直接缓存到内存中。&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.2612782&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/1BMf5Ir754SewtjRgeHFd6PHHVmzdqUoEhGWjbDkaZX8YYTxAYN2dUlrGhEexhOIxPG9b1tyHVXaZ5ibQOGC9Ig/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1064&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;这样的好处是：&lt;/p&gt;&lt;ol class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;热门的判断阈值可以由各个业务服务自行控制，如 A 服务认为 1W 在线属于热门，需要进行预热处理；B 服务认为超过 5W 在线的属于热门数据才需要预热处理。这样对于非热门的数据提供较高的数据时效性和一致性、对于热门的数据通过牺牲一定的一致性来实现更高的可用性。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;热门的处理可模拟、可演练，通常在预期的大型活动中我们会提前将活动房间在后台标记为热门房间，再通过压测来验证热门房间处理逻辑是否生效、性能是否符合预期。&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;/section&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt; 9.3 热点数据主动探测&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;随着直播在 B 站主站业务的融入，我们发现热点并非仅来自于热门直播房间这一种场景，热门稿件、热门评论同样会对部分直播服务造成热 Key 问题。因此我们设计了一个更通用的热点检测和处理 SDK 。&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.7772467&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/1BMf5Ir754SewtjRgeHFd6PHHVmzdqUo6ib3OjicibiaOd0YsCJQUJu6DiaApibNPOUic1SnICHIy2EUFWXicQ1DoKp3tg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1046&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;业务在接收到用户请求后调用计数 API，SDK 异步通过滑动窗口+LFU+优先队列计算Top-K，定时向业务回调统计到的热点数据 ID ，业务基于这些热点 ID 将数据源预加载到内存。这样对于热点的统计和判断完全取决于业务自身的 QPS 情况，而无需依赖外部数据。最终我们实现了热点数据的秒级感知和数据预热缓存能力。&lt;/p&gt;&lt;/section&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt; 9.4 代理层的内存缓存&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;Redis 在 6.0 中实现了客户端缓存机制来解决热点数据问题。我们的中间件团队也在内部的缓存代理上实现了客户端数据缓存，通过中间件管理后台我们可以配置正则表达式匹配一类的缓存 Key，符合规则的缓存 Key 会在代理层进行数据缓存，对该 Key 的下一次访问会直接命中本地缓存，不再需要访问缓存服务器，直到本地缓存失效。&lt;/p&gt;&lt;p&gt;代理层缓存特别适合于已经发现热 Key 的紧急处理流程中，直接将发现的热 Key 设置为本地缓存可以极大缓解热 Key 风险。但其并不适合作为一种通用热 Key 处理方案进行提前配置，特别是针对一类 Key 的正则匹配这会影响这类 Key 的数据一致性。&lt;/p&gt;&lt;/section&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;9.5 &lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;Proxyless Redis Client &lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;集成热点缓存&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;热点探测 SDK 需要业务主动接入，代理层的缓存方案过于简单。在发生多次热 Key 触发告警后，我们与基础架构同学交流探索出了以 Redis Client 内嵌热点缓存 SDK 的方式来实现业务的透明接入。在该方案中基础架构同学借鉴了 HeavyKeeper 算法重新设计了热点探测 SDK。HeavyKeeper 用于在流式数据中以较小的内存开销获得非常精确的 TopK 计算结果，统计出的 TopK 即是我们想要知道的热 Key。业务透明接入和缓存配置动态更新这两个特性的结合成了热 Key 的杀手级解决方案。&lt;/p&gt;&lt;/section&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt; 9.6 热点写数据的处理&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;在直播场景中除了读热点，还存在写热点的场景。通常是由于大量用户向同一个主播赠送礼物、发送弹幕等行为产生的写操作，进而对单条记录产生大量并发写场景。进一步分析这些并发写的场景我们发现通常是针对单条记录数值的增/减操作，如经验值、积分、点赞数等，而这类场景天然是可以支持聚合的。因此我们开发了一个聚合写入 SDK，其可以采用内存聚合或 Redis 聚合的方式，将业务对数据的变更操作按设定的周期进行聚合写入，比如+1、+2、-1 这样三个操作可以直接聚合成 +2 一个操作。实现这个 SDK 需要考虑聚合窗口大小、下游 DB 压力、服务异常重启的数据一致性保证等。&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.1787037&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/1BMf5Ir754SewtjRgeHFd6PHHVmzdqUoR7nqLuOuC09XdbzeULCcfn8LIjXRKJOmxSMWQpt8vW5RZ2q7ibeBq3A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;10 关于请求放大&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;房间服务是直播流量最大也是最核心的服务之一，日常 QPS 维持在 20W+。在运营房间服务中我们发现了以下几种场景的请求放大：&lt;/p&gt;&lt;/section&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt; 10.1 请求超出需要的数据&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;在分析房间服务高 QPS 调用来源方时我们发现部分业务仅需要房间信息中的一部分数据却请求了整个房间信息，比如某些业务方仅需要判断用户是否拥有直播间却调用了完整的房间信息接口，本来一个字段能解决的问题接口返回了数十个字段，造成不必要的带宽消耗和接口耗时。我们参考 FieldMask（ 关于FieldMask可参考 &lt;a target=&quot;_blank&quot; href=&quot;https://mp.weixin.qq.com/s?__biz=MzAwNzgwMzY2Ng==&amp;amp;mid=2247487385&amp;amp;idx=3&amp;amp;sn=e52ed70de1a1783df4e0bb99b9293e6b&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;Netflix API 设计实践: 使用FieldMask&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;Netflix API 设计实践: 使用FieldMask&lt;/span&gt;&lt;/a&gt;）的设计将房间信息拆分成不同的的模块，如播放相关、直播卡片展示相关等模块。业务方可根据场景需要组装 API 调用获取对应模块的数据实现按需请求。&lt;/p&gt;&lt;/section&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt; 10.2 重复的请求&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;直播间承载了直播近 80% 的业务功能，用户在进入房间时会请求进房接口。在这个接口中网关会聚合多个下游的数据后统一返回给用户，我们发现这个场景存在重复请求房间信息的情况。&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5179704&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/1BMf5Ir754SewtjRgeHFd6PHHVmzdqUoSXTYdmxlBNSg6OM1iaWfu4ibJkIY4S3dYN8G1kyV76QicCWl1ABLtm78g/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;473&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;上图所示除了 room-gateway 会请求房间信息外，gift-panel、dm-service 也会分别再请求一次房间信息，直接导致了房间服务的请求放大。这样的下游服务越来越多后，用户一次进房将对房间服务产生 10 倍以上的流量放大。而这种流量放大显然是没有必要的。解决方案也很直接将 dm-service、gift-panel 依赖的房间信息通过接口直接传递给对应服务。调用时序调整为先调用房间服务获取房间信息，再并发调用业务服务获取业务模块数据，最后组装成业务需要的数据返回。&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5055679&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/1BMf5Ir754SewtjRgeHFd6PHHVmzdqUodexO6NqutX1IKB0cetkoxrTSTJcQpxibjryDOcMCS1UetLUuibiceGhBw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;449&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt; 10.3 业务服务的请求放大&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;直播间承载了数十种业务功能，用户的一次进房会分别向这数十个下游服务进行请求。对每个下游都要求按照进房 QPS 进行备量，即承担至少 2W+ 的 QPS。这对于一些小众的服务是难以承受的，从数据上看对下游的 99% 请求都是查空的无效请求。为了降低接入房间场景业务的负载、减少资源浪费，我们在房间服务上实现了一个 TAG 机制，业务服务将数据 TAG 同步到房间服务，网关、客户端 在请求房间信息后根据 TAG 标识状态决定是否请求对应的业务服务，这样就避免了大量业务需要承担用户进房级别的 QPS。&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.4942308&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/1BMf5Ir754SewtjRgeHFd6PHHVmzdqUogMWvWAufDJD53icxulI6WwCtiaLNrG5zictN6DPlrYUv41t25nL8U87dA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;520&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;11 关于活动保障&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;一次大型活动的技术保障是一场技术盛宴，也是对所有研发同学的一次大考。直播技术在历年的活动保障中沉淀了一系列的工具和方法论。围绕场景梳理分析、服务容量预估、全链路压测、降级预案、现场保障等方面有一系列标准化方案、工具和平台支持。&lt;/p&gt;&lt;/section&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt; 11.1 场景梳理&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;场景梳理的目的是了解一场直播活动中涉及了哪些业务功能、服务和接口，以此针对涉及的业务模块开展后续的保障工作。通常活动直播间所使用的功能是普通直播间的子集，这就需要直播间内的功能都需要有控制开关，这里的控制开关一定是需要在终端实现的，即开关关闭后客户端不会对这一功能服务产生任何请求压力。场景梳理需要基于用户的真实操作路径进行请求录制，可以通过代理抓包的方式进行自动化的场景录制，再通过录制请求对应的 Trace 链路快速生成场景依赖关系图，这个关系图就明确了该场景下涉及的服务、资源等信息。&lt;/p&gt;&lt;/section&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt; 11.2 容量评估&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;容量评估用于确定活动所需要的资源，以进行采购备量和提前扩容。容量评估一定是基于历史数据和活动预估进行推算，其中针对不同的业务有不同的增长系数。&lt;/p&gt;&lt;/section&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt; 11.3 服务压测&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;服务压测通常是对线上服务真实容量进行摸底，一般在服务扩容前和服务扩容后都会进行压测以验证服务容量是否满足活动需求。特别地针对数据写的场景需要通过全链路压测的手段实现压测数据和真实数据的隔离，避免压测产生的脏数据影响线上业务。&lt;/p&gt;&lt;/section&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt; 11.4 降级预案&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;无预案不保障，针对可能出现的技术风险都需要有对应的 SOP，且这些 SOP 都需要通过预演的方式验证方案有效性。&lt;/p&gt;&lt;/section&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt; 11.5 现场保障&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;现场值班保障时通常会遇到信息爆炸、协作难度大的问题，特别是突发的系统告警容易产生惊群效应。需要高效信息分发、实时协作，实现保障工作的有序流转、不重不漏、快速执行。基于保障场景的特殊性我们研发了活动实时保障平台。&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.3166667&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/1BMf5Ir754SewtjRgeHFd6PHHVmzdqUopa5AgxIj8ER3MtcmZU0PiaTdZkmrH5QM25bcF1J1ugmGc52yJyjjBXg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;在实时保障平台中按照业务场景划分不同的场景负责人和保障值班，所有的线上服务告警、指标异常都会以实时推送的方式展示在对应保障人员的值班页面。针对常见的告警类型，如 CPU 过高、服务限流会直接关联到 SOP 手册，值班人员可以基于手册指导完成处理预案。在保障结束后我们也可以基于实时保障平台的数据记录生成保障报告，复盘保障过程中出现的问题、响应时效、执行结果和后续 TODO。&lt;/p&gt;&lt;/section&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;12 高光时刻&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;2021 的 《英雄联盟》全球总决赛哔哩哔哩直播实现了单平台超千万人同时在线的记录。整场比赛服务运行稳定、用户观看流畅，这是属于直播的高光时刻。&lt;/p&gt;&lt;/section&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;13 未来展望&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;直播的技术架构仍在向前演进，持续围绕服务稳定性和高可用建设在业务架构治理、多活和单元化方向不断进化。期望在今年的 LOL S12 中在线人数再创新高。&lt;/p&gt;&lt;p&gt;如果你有想了解的细节或感兴趣的话题，也欢迎留言讨论。&lt;/p&gt;&lt;/section&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;参考资料：&lt;/p&gt;&lt;p&gt;[1] https://www.zhihu.com/question/48457286&lt;/p&gt;&lt;p&gt;[2] https://www.infoq.cn/article/y2semvajjgxj9mbg9p00&lt;/p&gt;&lt;p&gt;[3] https://www.redis.com.cn/topics/client-side-caching.html&lt;/p&gt;&lt;p&gt;[4] https://www.computer.org/csdl/journal/nt/2019/05/08809410/1cFUZDJL2OA&lt;/p&gt;&lt;p&gt;[5] https://github.com/go-kratos/gateway&lt;/p&gt;&lt;p&gt;[6] https://zhuanlan.zhihu.com/p/436382314&lt;/p&gt;&lt;/section&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;hr/&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>bfe89a1c138262962addf18e62ed1d0a</guid>
<title>前端性能优化到底该怎么做（上）</title>
<link>https://toutiao.io/k/6ej9er2</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot; data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;前言&lt;/span&gt;&lt;/p&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;/&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;前端性能优化&lt;/strong&gt; 又是个听起来很高大上的词&lt;span&gt;，确实是的，因为它需要 **&lt;/span&gt;&lt;code&gt;高在性能，大在范围&lt;/code&gt;&lt;span&gt;**，所&lt;/span&gt;&lt;span&gt;幸很多大佬都已经输出了很多高质量的内容供大家参考，作者最近也在学习和了解这方面的内容，对如下文中的一些理解若有不当之处，可在评论区指正！&lt;/span&gt;&lt;span&gt;！&lt;/span&gt;&lt;span&gt;！&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;前端性能优化这个内容打算分为 &lt;strong&gt;上下两篇&lt;/strong&gt;，本来打算一篇写完，但发现前置知识部分已经占了 &lt;code&gt;3000+&lt;/code&gt; 文字，因此本篇文章主要还是讲解一些必要了解的前置内容。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;下一篇：&lt;span&gt;**前端性能优化到底该怎么做（下）— 直捣黄龙**&lt;/span&gt;&lt;sup&gt;[2]&lt;/sup&gt;&lt;/p&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;前端性能优化到底是在优化什么？&lt;/span&gt;&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其实前端性能优化核心就是两点：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;保证资源更快的 加载速度&lt;/strong&gt;：达到越快渲染越快，视图展现就越快&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;保证视图更快的 渲染速度/交互速度&lt;/strong&gt;：用户与页面交互，前提是页面要渲染出来，其次是页面需要尽早反馈，目的就是保证用户良好的体验性&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;而这些核心内容都可以从下面这个老生常谈的问题中延伸开来。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;&lt;strong&gt;从输入 &lt;code&gt;URL&lt;/code&gt; 到页面加载完成发生了什么？&lt;/strong&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;相信到现在为止，大家对这个问题的回答可以说是能够做到滔滔不绝了吧（~~&lt;code&gt;如果不能，请忽略&lt;/code&gt;~~）！不过每个人回答的方向和重点应该都不一样，比如之前在 &lt;code&gt;B 站&lt;/code&gt; 听 &lt;code&gt;winter&lt;/code&gt; 大佬对这个问题的看法和解析的角度是更深、更广的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在这还是要简单的总结一下核心内容：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;进行 &lt;code&gt;DNS&lt;/code&gt; 解析&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;建立 &lt;code&gt;TCP&lt;/code&gt; 连接&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;客户端发送 &lt;code&gt;HTTP&lt;/code&gt; 请求&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;服务端响应 &lt;code&gt;HTTP&lt;/code&gt; 资源&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;浏览器获取响应内容，进行解析和渲染&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;以上任意一点都可进行无限扩展、延伸，但点到为止才是现在真正需要的。&lt;/p&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;性能指标&lt;/span&gt;&lt;/h1&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;RAIL 模型&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;Google&lt;/code&gt; 为前端页面性能的评估提出了 &lt;code&gt;RAIL&lt;/code&gt; 模型，核心内容如下：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;&lt;code&gt;Response&lt;/code&gt; 响应&lt;/strong&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;&lt;code&gt;Animation&lt;/code&gt; 动画&lt;/strong&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;&lt;code&gt;Idle&lt;/code&gt; 空闲&lt;/strong&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;&lt;code&gt;Load&lt;/code&gt; 加载&lt;/strong&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.3620218579234973&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz/H8M5QJDxMHq7IbGlj496M11ThUJYp88bcvrSkllv5NHAO51e36gyWBRJA0rcX9CzicaJ3JXHibAxjxrRo6RDaA7Q/640?wx_fmt=other&quot; data-type=&quot;other&quot; data-w=&quot;732&quot;/&gt; &lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5113524185587365&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz/H8M5QJDxMHq7IbGlj496M11ThUJYp88bficzmODsUvkdSXic6jKHzuQK3n3UrGFibykpJK7bFVUBwiaVlpVI0SdzeQ/640?wx_fmt=other&quot; data-type=&quot;other&quot; data-w=&quot;1013&quot;/&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;常规性能指标&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;性能指标其实有不少的内容，但在这我们指列举比较常用的几种：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;首次绘制（&lt;code&gt;First Paint，FP&lt;/code&gt;）&lt;/strong&gt;&lt;/section&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;在渲染进程确认要渲染当前响应资源后，渲染进程会先创建一个空白页面，通常把创建空白页面的这个时间点称为 &lt;code&gt;First Paint&lt;/code&gt;，简称 &lt;code&gt;FP&lt;/code&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;所谓的 &lt;strong&gt;白屏时间&lt;/strong&gt; 其实指的就是创建这个空白页面到浏览器开始渲染非空白内容的时间，比如页面背景发生变化等&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;首次内容绘制（&lt;code&gt;First Contentful Paint，FCP&lt;/code&gt;）&lt;/strong&gt;&lt;/section&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;当用户看见一些 &quot;内容&quot; 元素被绘制在页面上的时间点，和白屏是不一样，它可以是 &lt;strong&gt;&lt;code&gt;文本&lt;/code&gt;&lt;/strong&gt; 首次绘制，或 &lt;code&gt;SVG&lt;/code&gt; 首次出现，或 &lt;code&gt;Canvas&lt;/code&gt; 首次绘制等，即当页面中绘制了第一个 &lt;strong&gt;像素&lt;/strong&gt; 时，这个时间点称为 &lt;code&gt;First Content Paint&lt;/code&gt;，简称 &lt;code&gt;FCP&lt;/code&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;首屏时间 / 最大内容绘制（&lt;code&gt;Largest Contentful Paint, LCP&lt;/code&gt;）&lt;/strong&gt;&lt;/section&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;LCP&lt;/code&gt; 是一种新的性能度量标准，&lt;code&gt;LCP&lt;/code&gt; 侧重于用户体验的性能度量标准，与现有度量标准相比，更容易理解与推理，当首屏内容完全绘制完成时，这个时间点称为 &lt;code&gt;Largest Content Paint&lt;/code&gt;，简称 &lt;code&gt;LCP&lt;/code&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;最大内容绘制应在 &lt;code&gt;2.5s&lt;/code&gt; 内完成&lt;/strong&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;首次输入延迟（&lt;code&gt;First Input Delay, FID&lt;/code&gt;）&lt;/strong&gt;&lt;/section&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;FID&lt;/code&gt; 测量的是当用户第一次在页面上交互的时候（&lt;strong&gt;点击链接&lt;/strong&gt;、&lt;strong&gt;点击按钮&lt;/strong&gt; 或 &lt;strong&gt;自定义基于 &lt;code&gt;js&lt;/code&gt; 的事件&lt;/strong&gt;），到浏览器实际开始处理这个事件的时间&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;首次输入延迟应在 &lt;code&gt;100ms&lt;/code&gt; 内完成&lt;/strong&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;累积布局偏移（&lt;code&gt;Cumulative Layout Shift, CLS&lt;/code&gt;)&lt;/strong&gt;&lt;/section&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;CLS&lt;/code&gt; 是为了测量 &lt;strong&gt;视觉稳定性&lt;/strong&gt;，以便提供良好的用户体验&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;累积布局偏移应保持在 &lt;code&gt;0.1&lt;/code&gt; 或更少&lt;/strong&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;首字节达到时间（&lt;code&gt;Time to First Byte，TTFB&lt;/code&gt;）&lt;/strong&gt;&lt;/section&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;指的是浏览器开始收到服务器响应数据的时间（&lt;strong&gt;后台处理时间 + 重定向时间&lt;/strong&gt;），是反映服务端响应速度的重要指标&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;&lt;code&gt;TTFB&lt;/code&gt; 时间如果超过 &lt;code&gt;500ms&lt;/code&gt;，用户在打开网页的时就会感觉到明显的等待&lt;/strong&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/ul&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;性能指标工具&lt;/span&gt;&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;通过上述内容了解了性能指标的相关内容和一些阀值，那么接下来的问题是我们怎么获取一个网站的具体性能指标数据呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;为了方便还是得使用工具或者说是 &lt;code&gt;API&lt;/code&gt;，当然可以 &lt;strong&gt;自定义页面性能指标&lt;/strong&gt; 的计算方式，比如有些就是通过计算当前页面 &lt;code&gt;DOM&lt;/code&gt; 的 &lt;strong&gt;总节点数&lt;/strong&gt; 和 &lt;strong&gt;嵌套层级&lt;/strong&gt; 来计算一个网站的分数等，这里就不再额外介绍。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;Performance 面板（Google）&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;具体参数介绍可以看 &lt;span&gt;`Big shark@LX`&lt;/span&gt;&lt;sup&gt;[3]&lt;/sup&gt; 大佬的文章，里面介绍的非常详细，这里只列举一些核心点。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;火焰图&lt;/span&gt;&lt;/h3&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;Networks 指标&lt;/span&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;通过 &lt;code&gt;Networks&lt;/code&gt; 指标可以查看到对应服务器加载资源的相关信息：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.27372836916622967&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz/H8M5QJDxMHq7IbGlj496M11ThUJYp88bhP63LGian9iaSpr2xMfjlGavMwQjTibicQjMNIAfLW5Ly1NZnk2lnzo4lA/640?wx_fmt=other&quot; data-type=&quot;other&quot; data-w=&quot;1907&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可以将鼠标 &lt;strong&gt;移动&lt;/strong&gt; 或 &lt;strong&gt;点击&lt;/strong&gt; 到具体的请求上查看加载时间和加载速度，如下：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;鼠标移入：&lt;/strong&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.09424920127795527&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz/H8M5QJDxMHq7IbGlj496M11ThUJYp88b7s3L7Pb5sO1TKRNfdCFEw7b83QbMRlEFQibQM69Nic1haPOyENqn5mVg/640?wx_fmt=other&quot; data-type=&quot;other&quot; data-w=&quot;1252&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;鼠标点击：&lt;/strong&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.24870466321243523&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz/H8M5QJDxMHq7IbGlj496M11ThUJYp88bkFia9DpB1WPRm81s7m8dWibnrBWktaQuzExdwhNiaDpqIFK6mjuA0UbEw/640?wx_fmt=other&quot; data-type=&quot;other&quot; data-w=&quot;1544&quot;/&gt;&lt;/figure&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;Frames 指标&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;通过 &lt;code&gt;Frames&lt;/code&gt; 指标可以查看页面每一帧渲染时 &lt;code&gt;CPU&lt;/code&gt; 所消耗的时间和持续时间 &lt;code&gt;Duration&lt;/code&gt; 的信息，如下：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;图一：&lt;/strong&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.13617245005257625&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz/H8M5QJDxMHq7IbGlj496M11ThUJYp88bicec6H78AIVsDzMEKibuYVPwsUweJZtKbty3ZrrS21h5ia5dYObnj0wcQ/640?wx_fmt=other&quot; data-type=&quot;other&quot; data-w=&quot;1902&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;图二：&lt;/strong&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5198821796759941&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz/H8M5QJDxMHq7IbGlj496M11ThUJYp88bpLUIzA1ibTXiavOT7qdPVPqGjCslc0tw23BibAwlTjvDicqyicZ65MF6XlA/640?wx_fmt=other&quot; data-type=&quot;other&quot; data-w=&quot;679&quot;/&gt;&lt;/figure&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;Timings 指标&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;通过 &lt;code&gt;Timings&lt;/code&gt; 指标可以查看在上面列举的一些性能指标的值，如下：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.18870967741935485&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz/H8M5QJDxMHq7IbGlj496M11ThUJYp88b9uBvGOfZqsffUXdhibqB6UgiauwyRDDAGGicJdbBV1QFibPmH8H4IoerNQ/640?wx_fmt=other&quot; data-type=&quot;other&quot; data-w=&quot;620&quot;/&gt;&lt;/figure&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;首次绘制（&lt;code&gt;First Paint，FP&lt;/code&gt;）&lt;/strong&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;首次内容绘制（&lt;code&gt;First Contentful Paint，FCP&lt;/code&gt;）&lt;/strong&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;首屏时间 / 最大内容绘制（&lt;code&gt;Largest Contentful Paint, LCP&lt;/code&gt;）&lt;/strong&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;&lt;code&gt;HTML&lt;/code&gt; 文档被完全加载 和 解析完成的时间（&lt;code&gt;DOMContentLoaded, DCL&lt;/code&gt;）&lt;/strong&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;Main 指标&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;Main&lt;/code&gt; 指标包含了加载过程的三个阶段：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;导航阶段&lt;/section&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;主要是处理响应头的数据，并执行一些老页面退出之前的清理操作&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;li&gt;&lt;section&gt;解析 &lt;code&gt;HTML&lt;/code&gt; 文件阶段&lt;/section&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;主要是解析 &lt;code&gt;HTML&lt;/code&gt; 数据、解析 &lt;code&gt;CSS&lt;/code&gt; 数据、执行 &lt;code&gt;JavaScript&lt;/code&gt; 来生成 &lt;code&gt;DOM&lt;/code&gt; 和 &lt;code&gt;CSSOM&lt;/code&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;li&gt;&lt;section&gt;生成位图阶段&lt;/section&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;主要是将生成的 &lt;code&gt;DOM&lt;/code&gt; 和 &lt;code&gt;CSSOM&lt;/code&gt; 合并，包括了布局 (&lt;code&gt;Layout&lt;/code&gt;)、分层、绘制、合成等一系列操作&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/ul&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.3793103448275862&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz/H8M5QJDxMHq7IbGlj496M11ThUJYp88bjnricSyU8NkULJNZ6xGBDk72tBTFYuaTwxjN5UIhm38HWFT8nD5A5Bg/640?wx_fmt=other&quot; data-type=&quot;other&quot; data-w=&quot;2088&quot;/&gt;&lt;/figure&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;Lighthouse 面板（Google）&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;Performance&lt;/code&gt; 面板最大的优点就是各种数据信息非常的全，但这也是它最大的缺点，数据信息庞大到需要自行过滤，对于不熟悉的开发者来说，还是需要一定的学习成本的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;相反，&lt;code&gt;Lighthouse&lt;/code&gt; 面板中的信息就相对简洁一些，除了检测结果以外，还会提供对应的改进方案，真是考虑得妥妥的，主要检测五个方面的内容：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;Performance（性能）&lt;/strong&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;Accessibility（可访问性）&lt;/strong&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;Best practice（最佳实践）&lt;/strong&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;SEO（搜索引擎优化）&lt;/strong&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;Progressive Web App（渐进式 Web 应用）&lt;/strong&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.9823113207547169&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz/H8M5QJDxMHq7IbGlj496M11ThUJYp88bHaTtOMzCmlHtqnicj6HsA5Tw79dYbTYx2nq5ohL8YZ0Vz0qWCTzZT3A/640?wx_fmt=other&quot; data-type=&quot;other&quot; data-w=&quot;848&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可以通过 &lt;code&gt;Analyze page load&lt;/code&gt; 按钮来开始对页面应用进行检测，这里以掘金首页为例：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.2867274569402229&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz/H8M5QJDxMHq7IbGlj496M11ThUJYp88bKsqcAPic0K6ZiaVbR7YZM0LfMl7QgQD8Qs6cpjriaTb6ic3BUicj0eIsGsw/640?wx_fmt=other&quot; data-type=&quot;other&quot; data-w=&quot;987&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;下面以 &lt;strong&gt;Performance 性能&lt;/strong&gt; 为例简单看一下具体包含的内容，由于篇幅有限，其他内容可自行测试并进行阅读。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;Performance 性能（举一反三）&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;从性能指标的数据来看，只有 &lt;strong&gt;累积布局偏移（&lt;code&gt;Cumulative Layout Shift, CLS&lt;/code&gt;)&lt;/strong&gt; 满足要求，其他指标显示 &lt;strong&gt;黄色&lt;/strong&gt; 和 &lt;strong&gt;红色&lt;/strong&gt;，意味着仍有改进的空间，特别是 &lt;strong&gt;首屏时间&lt;/strong&gt; 是 &lt;code&gt;2.9s&lt;/code&gt; 已经是超过了对应的阈值 &lt;code&gt;2.5s&lt;/code&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;性能指标数据如下图所示：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.5705244122965641&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz/H8M5QJDxMHq7IbGlj496M11ThUJYp88bhAtdcypULf7rbCg4CzIZic9coqjoNSjPDDjMb7B1iaEIlFzekPsBUbgw/640?wx_fmt=other&quot; data-type=&quot;other&quot; data-w=&quot;1106&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;甚至还提供了对应的诊断结果，比如提到的图片没有设置对应的宽高：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.5386012715712988&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz/H8M5QJDxMHq7IbGlj496M11ThUJYp88bCJ0t1Cu2MIPR9S4HYxSBDibnTK0ZJpSm94SWwdO5NMOvSwiaeFZTYLvA/640?wx_fmt=other&quot; data-type=&quot;other&quot; data-w=&quot;1101&quot;/&gt;&lt;/figure&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;Using the Node CLI&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;甚至还支持在 &lt;code&gt;Node&lt;/code&gt; 环境运行，感兴趣的自行去 &lt;code&gt;npm&lt;/code&gt; 中查看 &lt;span&gt;**文档**&lt;/span&gt;&lt;sup&gt;[4]&lt;/sup&gt; 即可，这里不过多介绍。&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.664720600500417&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz/H8M5QJDxMHq7IbGlj496M11ThUJYp88bKKP1Fn0Dk6CL7ouHBl5gNFjKhc75ILflS73n05YYwRDicGUl4qDmK0Q/640?wx_fmt=other&quot; data-type=&quot;other&quot; data-w=&quot;1199&quot;/&gt;&lt;/p&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;性能指标数据收集&lt;/span&gt;&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上述性能指标工具的能力已经足够强大，覆盖信息也很全面，但如果我们需要将页面性能指标数据收集并上报又该怎么办呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;首先排除的肯定是通过 &lt;strong&gt;性能指标工具&lt;/strong&gt; 的方式来收集，一旦要检测性能指标数据意味着得是不同的客户端统计数据的结果合集（&lt;span&gt;除非你愿意一台一台客户端来手动记录和收集数据，呸，你愿意你领导还不愿意呢&lt;/span&gt;），最理想的方式当然是自动收集和上报，那就意味着这应该是代码要干的活！！！&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;既然有这样的需求，那么必定有对应的解决方案，您接着往下看！&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;Performance API&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;实际上在浏览器端的全局对象 &lt;code&gt;window&lt;/code&gt; 上有一个名为 &lt;code&gt;performance&lt;/code&gt; 的属性，它是一个用于支持 &lt;code&gt;IE9&lt;/code&gt; 以上及 &lt;code&gt;webkit&lt;/code&gt; 内核浏览器中用于记录页面 &lt;strong&gt;加载&lt;/strong&gt; 和 &lt;strong&gt;解析&lt;/strong&gt; 过程中关键时间点的机制，其兼容性在 &lt;span&gt;**`caniuse`**&lt;/span&gt;&lt;sup&gt;[5]&lt;/sup&gt; 中的表现如下：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.28045977011494255&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz/H8M5QJDxMHq7IbGlj496M11ThUJYp88bbZR5yV77xkicgPfrb1pUly3GPfQbrG7ZwJDDhxKibobdnY1dSx77t6yw/640?wx_fmt=other&quot; data-type=&quot;other&quot; data-w=&quot;1740&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;下面就简单介绍一下和 &lt;code&gt;window.performance&lt;/code&gt; 相关一些核心属性和方法。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5009225092250923&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz/H8M5QJDxMHq7IbGlj496M11ThUJYp88bGjKhd43rwKjcjnoF1Zdzyn3juu71Licq5ePgDf3kPyCOUuPs1tRJIiaA/640?wx_fmt=other&quot; data-type=&quot;other&quot; data-w=&quot;1084&quot;/&gt;&lt;/figure&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;performance.timing 属性&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;performance.timing&lt;/code&gt; 属性中提供了很多关键的时间信息，我们可以通过这些时间节点来简单的计算出需要的性能指标数据（不一定准确），计算方式如：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;const&lt;/span&gt; {&lt;br/&gt; domainLookupStart,&lt;br/&gt; domainLookupEnd,&lt;br/&gt; navigationStart,&lt;br/&gt; loadEventEnd,&lt;br/&gt; responseStart,&lt;br/&gt; responseEnd,&lt;br/&gt; connectStart,&lt;br/&gt; connectEnd,&lt;br/&gt; redirectStart,&lt;br/&gt; redirectEnd,&lt;br/&gt; domContentLoadedEventEnd,&lt;br/&gt; domComplete,&lt;br/&gt;} = performance.timing&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// DNS 查询时间&lt;/span&gt;&lt;br/&gt;DNS = domainLookupEnd - domainLookupStart&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// TCP 建立连接时间&lt;/span&gt;&lt;br/&gt;TCP = connectEnd - connectStart&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// 页面重定向时间&lt;/span&gt;&lt;br/&gt;Redirect = redirectEnd - redirectStart&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// 首字节到底时间&lt;/span&gt;&lt;br/&gt;TTFB = responseStart - navigationStart&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// 首次渲染时间&lt;/span&gt;&lt;br/&gt;FP = responseStart - navigationStart&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// DOM 解析时间&lt;/span&gt;&lt;br/&gt;DOM = domComplete - responseEnd&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// 首屏时间&lt;/span&gt;&lt;br/&gt;LCP = loadEventEnd - navigationStart&lt;br/&gt;复制代码&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;performance.getEntries() 方法&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;performance.getEntries()&lt;/code&gt; 方法可以获取所有资源请求的时间数据，如下：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5710382513661202&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz/H8M5QJDxMHq7IbGlj496M11ThUJYp88bf6TB2o7SIsAKgCSP2pNQKPNDffGgP5EbRWF7nC1u5Cp8FvItymofaA/640?wx_fmt=other&quot; data-type=&quot;other&quot; data-w=&quot;1098&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;点击可查看具体的资源信息，其他属性和上述内容有重复，就不在额外介绍计算方式了，具体如下：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.4734819369715603&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz/H8M5QJDxMHq7IbGlj496M11ThUJYp88b9PIdPRvlrH5ajxyiatRxJ1iar3zabgibvLibyucZuOkE3wAY9WvcwowNQw/640?wx_fmt=other&quot; data-type=&quot;other&quot; data-w=&quot;1301&quot;/&gt;&lt;/figure&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;performance.now() 方法&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;performance.now()&lt;/code&gt; 方法可以精确计算程序执行时间，它会返回以微秒（&lt;strong&gt;百万分之一秒&lt;/strong&gt;）为单位的时间，即更加精准，这也是它和 &lt;code&gt;Date.now()&lt;/code&gt; 是不同点：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;&lt;code&gt;Date.now()&lt;/code&gt;&lt;/strong&gt; 返回自 1970年1月1日 00:00:00 (UTC) 到 &lt;strong&gt;当前时间&lt;/strong&gt; 的 &lt;strong&gt;毫秒数&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;意味着 &lt;strong&gt;&lt;code&gt;Date.now()&lt;/code&gt;&lt;/strong&gt; 依赖于系统的当前时间，而系统时间可以被认为修改，因此它的毫秒数并不准确&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;&lt;code&gt;performance.now()&lt;/code&gt;&lt;/strong&gt; 的时间是以恒定速率递增的，不受系统时间的影响&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;// Date.now()&lt;/span&gt;&lt;br/&gt;&lt;span&gt;let&lt;/span&gt; a = &lt;span&gt;2&lt;/span&gt;, b = &lt;span&gt;3&lt;/span&gt;;&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; begin = &lt;span&gt;Date&lt;/span&gt;.now();&lt;br/&gt;&lt;span&gt;console&lt;/span&gt;.log(&lt;span&gt;&#x27; a + b = &#x27;&lt;/span&gt;, a + b);&lt;br/&gt;&lt;br/&gt;&lt;span&gt;console&lt;/span&gt;.log(&lt;span&gt;&#x27;time = &#x27;&lt;/span&gt;, &lt;span&gt;Date&lt;/span&gt;.now() - begin); &lt;span&gt;// 2&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// performance.now()&lt;/span&gt;&lt;br/&gt;&lt;span&gt;let&lt;/span&gt; a = &lt;span&gt;2&lt;/span&gt;, b = &lt;span&gt;3&lt;/span&gt;;&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; begin = performance.now();&lt;br/&gt;&lt;span&gt;console&lt;/span&gt;.log(&lt;span&gt;&#x27; a + b = &#x27;&lt;/span&gt;, a + b);&lt;br/&gt;&lt;br/&gt;&lt;span&gt;console&lt;/span&gt;.log(&lt;span&gt;&#x27;time = &#x27;&lt;/span&gt;, performance.now() - begin); &lt;span&gt;// 0.10000002384185791&lt;/span&gt;&lt;br/&gt;复制代码&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;Web Vitals&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;**`web-vitals`**&lt;/span&gt;&lt;sup&gt;[6]&lt;/sup&gt; 库是 &lt;code&gt;Google&lt;/code&gt; 推出的一个小型（约 &lt;code&gt;1.5K&lt;/code&gt;）模块化库，用于测量真实用户的所有 &lt;code&gt;Web Vitals&lt;/code&gt; 相关的指标，其重要核心指标信息如下（一图胜千言）：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.48055315471045806&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz/H8M5QJDxMHq7IbGlj496M11ThUJYp88bNSllwdTeV3TlzIzFicib4P1On96vDDjcibiaz9xcWOibePicyndTLEnrY4qw/640?wx_fmt=other&quot; data-type=&quot;other&quot; data-w=&quot;1157&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;接下来，让我们通过 &lt;code&gt;npx create-react-app my-react-app&lt;/code&gt; 来创建一个 &lt;code&gt;react&lt;/code&gt; 项目，然后观察一下它的项目结构：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1.6228710462287104&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz/H8M5QJDxMHq7IbGlj496M11ThUJYp88bPKZu0Z7ZBvDp9FJsiaOLxrLhEjH8s1aocMhdyKmI5BBaqI1pgnbDpMA/640?wx_fmt=other&quot; data-type=&quot;other&quot; data-w=&quot;411&quot;/&gt;&lt;figcaption&gt;image.png&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;是不是超级显眼的 **&lt;code&gt;reportWebVitals.js&lt;/code&gt;**，在进入文件查看你会发现我们需要的核心性能指标都在里面：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.554945054945055&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz/H8M5QJDxMHq7IbGlj496M11ThUJYp88b9sPqveVaQ7MiaJoAKgvT1IJBTialQVibQMOUuBgo8q0iaEiaKoEN6jyEPAQ/640?wx_fmt=other&quot; data-type=&quot;other&quot; data-w=&quot;1092&quot;/&gt;&lt;/figure&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;最后&lt;/span&gt;&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;前端性能优化这个内容是之前一直打算要写的，终归知识有所欠缺，到现在也算是边学习边输出中，&lt;span&gt;**下一篇**&lt;/span&gt;&lt;sup&gt;[7]&lt;/sup&gt; 就针对性能优化的方案进行一些总结！！！&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz/H8M5QJDxMHq7IbGlj496M11ThUJYp88bicwPu4BWZ7aVaia7E2BY5CmByx8kVTY3ps5e5YQ3icrmSVFic5pHHoXQsg/640?wx_fmt=other&quot; data-type=&quot;other&quot; data-w=&quot;240&quot;/&gt;&lt;figcaption&gt;1810425E.jpg&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;如果以上内容对你有所帮助，来个一键三连，需要光的力量！！！&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>4ab158aeb7e80b573868468dd247cd9c</guid>
<title>Bean 上验证</title>
<link>https://toutiao.io/k/akcq1aj</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;/&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;632&quot; data-backw=&quot;474&quot; data-galleryid=&quot;&quot; data-ratio=&quot;1.3328125&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/RMOHqs13Zw37XqqicyicRicgp4UqTy2b2ywlsxpQWqm8iaerryEuUkj1kzhEg3D2EBk98dISnAlDO0ypTSX4VzC7Lw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;br/&gt;&lt;br/&gt;一、Validation 验证&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;系统开发中，我们通过一系列的规则校验，来确保输入数据的正确性、一致性和安全性。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;验证不仅仅是确保正确的用户拥有正确的权限，关注 「你是谁」「你能做什么」，而且要关注「做的对不对」，数据质量的准确性同样可能导致验证的安全问题。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;缺失校验会造成缺陷，过度的校验则会使代码显得繁琐。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;场景：用户注册&lt;span/&gt;&lt;/h4&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;用户: 填写表单数据，提交&lt;/p&gt;&lt;/blockquote&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;系统：throw new RestException(&quot;手机号必填&quot;)&lt;/p&gt;&lt;/blockquote&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;用户：填写手机号&lt;/p&gt;&lt;/blockquote&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;系统：throw new RestException(&quot;邮箱格式不正确&quot;)&lt;/p&gt;&lt;/blockquote&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;用户：修改邮箱格式&lt;/p&gt;&lt;/blockquote&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;系统：throw new BusinessException(&quot;邮箱已经注册过了&quot;)&lt;/p&gt;&lt;/blockquote&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;用户：换一个邮箱&lt;/p&gt;&lt;/blockquote&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;系统：throw new DAOException(&quot;用户名过长，插入失败&quot;)&lt;/p&gt;&lt;/blockquote&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;用户：...&lt;/p&gt;&lt;/blockquote&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;二、验证放哪里合适&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;对于简单的必填或长度校验，前端需要做，但后端同样需要做一次验证。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;验证应该放在 controller 层，还是放在 service 层？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;1、在 controller 做，service 不做，理由是如果调用了两个 service 方法 A.method()、B.method() ，两个 service 要做重复校验。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;2、在 service 做，controller 不做，理由是简单校验已经由前端拦住，业务相关的校验应该由具体的 service 做，业务相关的东西放到 controller 不合适。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;3、controller、service 各做各的，controller 做参数简单验证，service 做业务相关验证，和上述注册的例子是一致的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;4、各层都做，比如在 DAO 层做最终一道拦截，确保不会出现数据问题。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;三、Bean 上验证&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在 Java 中有专门的验证标准，Bean Validation 1.0 (JSR 303)、Bean Validation 1.1 (JSR 349)、Bean Validation 2.0 (JSR 380)。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;JSR，Java Specification Requests 的缩写，意思是 Java 规范提案。是指向 JCP (Java Community Process) 提出新增一个标准化技术规范的正式请求。JSR 已成为 Java 界的一个重要标准。&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Jakarta Bean Validation，2.0 版本发布与 2019 年。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;2009 年，Oracle 收购 SUN ，并将开源部分移交给 Eclipse 基金会，但是有商业要求，如不允许再使用 Java EE 等名称，于是基金会改名 Jakarta EE。本质上 Jakarta Bean Validation = Java Bean Validation。&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们可以从分层中抽离出来，针对于 bean 单独做验证。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;常规的验证方式可以借助 Bean Validation 提供的一些注解来操作：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;@NotBlank&lt;br/&gt;@NotEmpty&lt;br/&gt;@Range&lt;br/&gt;@Length&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;比如：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;@NotBlank(message = &lt;span&gt;&quot;用户账号不能为空&quot;&lt;/span&gt;)&lt;br/&gt;private String userCode;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;四、验证的封装&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果系统接口较多，需要做校验的入参量级比较大，@NotBlank(message = &quot;用户账号不能为空&quot;)，这个注解就需要重复 N 多次。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;通过进行一层封装可以使之变得更简单。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;自定义一个简单的注解&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;定义一个注解 &lt;code&gt;@UserCodeNotBlank&lt;/code&gt;，代表用户系统号不能为空，其验证逻辑在 &lt;code&gt;ParamValidation.UserCodeNotBlankValidate.class&lt;/code&gt; 中。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;/**&lt;br/&gt; * @author lyqiang&lt;br/&gt; */&lt;br/&gt;@Documented&lt;br/&gt;@Retention(RUNTIME)&lt;br/&gt;@Target({FIELD, METHOD, PARAMETER, TYPE})&lt;br/&gt;@Constraint(validatedBy = ParamValidation.UserCodeNotBlankValidate.class)&lt;br/&gt;public @interface UserCodeNotBlank {&lt;br/&gt;&lt;br/&gt;    String message() default &lt;span&gt;&quot;系统号不能为空&quot;&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;    Class&amp;lt;?&amp;gt;[] groups() default {};&lt;br/&gt;&lt;br/&gt;    Class&amp;lt;? extends Payload&amp;gt;[] payload() default {};&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;然后定义一个校验规则&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;/**&lt;br/&gt; * @author lyqiang&lt;br/&gt; * &amp;lt;p&amp;gt;&lt;br/&gt; * 一些常用 （比如账号）&lt;br/&gt; * 或需要做逻辑判断的校验 (比如 必须是经理)&lt;br/&gt; * 统一放到此处&lt;br/&gt; */&lt;br/&gt;public class ParamValidation&amp;lt;T extends Annotation&amp;gt; implements ConstraintValidator&amp;lt;T, Object&amp;gt; {&lt;br/&gt;&lt;br/&gt;    protected Predicate&amp;lt;Object&amp;gt; predicate = c -&amp;gt; &lt;span&gt;true&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;     @Inject&lt;br/&gt;     protected EhrApiAdapter ehrApiAdapter;&lt;br/&gt;&lt;br/&gt;     @Override&lt;br/&gt;     public boolean isValid(Object value, ConstraintValidatorContext constraintValidatorContext) {&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; predicate.test(value);&lt;br/&gt;     }&lt;br/&gt;&lt;br/&gt;    public static class UserCodeNotBlankValidate extends ParamValidation&amp;lt;UserCodeNotBlank&amp;gt; {&lt;br/&gt;&lt;br/&gt;       @Override&lt;br/&gt;        public void initialize(UserCodeNotBlank constraintAnnotation) {&lt;br/&gt;            predicate = c -&amp;gt; Objects.nonNull(c) &amp;amp;&amp;amp; StringUtils.isNotBlank((String) c);&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;使用方的 Bean 上或者 controller 方法参数上直接加注解。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;@UserCodeNotBlank&lt;br/&gt;private String userCode;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;稍微复杂的注解&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们也可以支持其它一些通用的业务校验操作，比如验证用户角色必须是经理。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;public static class GroupChiefCheckValidate extends ParamValidation&amp;lt;GroupChiefCheck&amp;gt; {&lt;br/&gt;    @Override&lt;br/&gt;     public void initialize(GroupChiefCheck groupChiefCheck) {&lt;br/&gt;        predicate = c -&amp;gt; Objects.nonNull(c) &amp;amp;&amp;amp; RoleEnum.GROUP_CHIEF ==     ehrApiAdapter.getUserInfo((String) c).getRole();&lt;br/&gt;     }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其它场景应用这种方式校验也非常合适，比如：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;一些合法性的校验，入参字段必须属于某个枚举中的值，state in [1,2,3,4,5]  等等；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;一些操作类的如新增某表记录的接口，需要校验库存当前不存在此记录，否则不允许进行 insert 。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>cf07e2f652986ad94d54cb22ffb8a898</guid>
<title>监控平台SkyWalking9入门实践</title>
<link>https://toutiao.io/k/h0iucic</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content                           autoTypeSetting24psection&amp;#10;                          &quot; id=&quot;js_content&quot;&gt;&lt;blockquote&gt;&lt;p&gt;简便快速的完成对分布式系统的监控；&lt;/p&gt;&lt;/blockquote&gt;&lt;h1&gt;&lt;span&gt;一、业务背景&lt;/span&gt;&lt;/h1&gt;&lt;p&gt;微服务作为当前系统架构的主流选型，虽然可以应对复杂的业务场景，但是随着业务扩展，微服务架构本身的复杂度也会膨胀，对于一些核心的业务流程，其请求链路会涉及到多个业务服务，少则三五个，多则十几个都很常见：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.20500782472613457&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/uUIibyNXbAvBo8fxeW93ib70RfVGcJXibKibjnJSmGHQUYJzgeIsg4fibXS3rnTNwK572tlSaNgAzLCKprzwNnHvZibA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1278&quot;/&gt;&lt;/p&gt;&lt;p&gt;真实的业务场景远比图解复杂，在这种模式下当请求发生故障时，或者进行优化时，需要分析链路性能，追踪调用链路，排查和解决链路故障；&lt;/p&gt;&lt;p&gt;要完成上述流程，需要对请求的链路有完整监控，并且采集和分析各个环节的数据，这样才能清晰的理解系统的行为信息，比如耗时分析，故障原因发现，从而进行优化和解决；能实现这种能力的组件很多，这里来看看基于SkyWalking9的实践方式；&lt;/p&gt;&lt;h1&gt;&lt;span&gt;二、组件原理&lt;/span&gt;&lt;span/&gt;&lt;/h1&gt;&lt;p&gt;Skywalking是APM规范的国产开源分布式链路追踪系统，APM（Application-Performance-Management）即应用性能管理，支持对SpringCloud微服务集成，并且无代码层面的侵入：&lt;/p&gt;&lt;p&gt;&lt;strong&gt;结构体系&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.47421875&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/uUIibyNXbAvBo8fxeW93ib70RfVGcJXibKib6MZPxMbH45KG16nMFEGyfxx0SVYDRp5GMnb7LzkGeVAuoZRT9TwEBA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;业务机制&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.27578125&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/uUIibyNXbAvBo8fxeW93ib70RfVGcJXibKib2fhtYsjCSVmopxZ0qcPn7N20PB0q2dObaE5GlqP7Z0qn4MYFvBQ8aQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;SpringCloud&lt;/strong&gt;：分布式系统中的服务，启动时配置代理即可；&lt;/p&gt;&lt;p&gt;&lt;strong&gt;Agent&lt;/strong&gt;：以探针的方式进行请求链路的数据采集，并向管理服务上报；&lt;/p&gt;&lt;p&gt;&lt;strong&gt;OAP-Service&lt;/strong&gt;：接收数据，完成数据的存储和展示；&lt;/p&gt;&lt;p&gt;&lt;strong&gt;Storage&lt;/strong&gt;：数据的存储层，支持ElasticSearch、Mysql、H2多种方式；&lt;/p&gt;&lt;p&gt;&lt;strong&gt;UI界面&lt;/strong&gt;：数据的可视化展示界面；&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.4859375&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/uUIibyNXbAvBo8fxeW93ib70RfVGcJXibKibIJPmoEicGkibLRDfYhoyfIQWb8xuzJ8NFMw1tN4VPxQPelic91iaGL33cg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;工作流程，服务通过探针的方式接入数据采集的功能，之后请求链路的相关处理行为会上报到OAP服务中，进行数据的聚合管理和分析，并存储在持久层，然后可以通过UI界面进行可视化呈现；&lt;/p&gt;&lt;h1&gt;&lt;span&gt;三、安装部署&lt;/span&gt;&lt;span/&gt;&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;1、版本描述&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;skywalking在之前的旧版本中，apm与agent是在一个包中的，在9.0的版本中是需要分开下载的；agent包下载解压之后，也将其放到apm包下面维护：&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;skywalking-apm-9.1.0.tar.gz&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;skywalking-java-agent-8.10.0.tgz&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.17890625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/uUIibyNXbAvBo8fxeW93ib70RfVGcJXibKibvB9XTjicwn34gHl3ZRczg0Ck31dIZy5YAHeGDCQkJxjprbmyBxVUlSw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;2、配置存储方式&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;Skywalking数据存储的组件有多种选型方式，这里方便本地调试，就选择MySQL数据库，在生产环境中通常选择ElasticSearch组件；&lt;/p&gt;&lt;p&gt;配置文件：&lt;code&gt;config/application.yml&lt;/code&gt;&lt;/p&gt;&lt;pre&gt;&lt;code&gt;storage:&lt;br/&gt;  selector: &lt;span&gt;${SW_STORAGE:mysql}&lt;/span&gt;&lt;br/&gt;mysql:&lt;br/&gt;  properties:&lt;br/&gt;    jdbcUrl: &lt;span&gt;${SW_JDBC_URL:&quot;jdbc:mysql://localhost:3306/swtest?rewriteBatchedStatements=true&quot;}&lt;/span&gt;&lt;br/&gt;    dataSource.user: &lt;span&gt;${SW_DATA_SOURCE_USER:username}&lt;/span&gt;&lt;br/&gt;    dataSource.password: &lt;span&gt;${SW_DATA_SOURCE_PASSWORD:password}&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;需要注意的是，要在本地的MySQL中新建swtest数据库，&lt;strong&gt;采用latin1字符编码&lt;/strong&gt;，可以避免索引长度的问题，表的创建是自动的，然后需要在包中添加MySQL依赖；&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.47734375&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/uUIibyNXbAvBo8fxeW93ib70RfVGcJXibKibPlCXauARicbnXU4s9T98IXJOuladZUMFQl1VL9C3yQSdKF403qic5jdA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;3、启动与停止&lt;/strong&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;启动oap服务：sh bin/oapService.sh&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;启动UI界面：sh bin/webappService.sh&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;服务停止命令：jps查看，kill相关编号；&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;UI界面服务默认是8080端口，如果存在占用问题，可以修改：&lt;code&gt;webapp/webapp.yml&lt;/code&gt;文件，更换端口；启动完成后访问&lt;code&gt;LocalIP:port&lt;/code&gt;即可；&lt;/p&gt;&lt;p&gt;&lt;strong&gt;4、服务集成&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;在本地存在&lt;code&gt;gateway&lt;/code&gt;，&lt;code&gt;facade&lt;/code&gt;，&lt;code&gt;account&lt;/code&gt;，三个服务，案例围绕&lt;code&gt;account&lt;/code&gt;服务中的请求展开，由于涉及网关服务，还需要添加相关插件的依赖；&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.16484375&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/uUIibyNXbAvBo8fxeW93ib70RfVGcJXibKib2jIGXcUa89SgzWpNbIF9uyaicPLltc3I1ckUJMqxEjMGhWXKr4iciaicpw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;将&lt;code&gt;optional-plugins&lt;/code&gt;可选插件目录中的两个网关的依赖包，复制到&lt;code&gt;plugins&lt;/code&gt;插件目录下；&lt;/p&gt;&lt;p&gt;在服务启动类中添加&lt;code&gt;agent&lt;/code&gt;配置，如果在生产环境中，通常会统一在脚本中设置，由于在本地环境演示，基于IDEA工具进行管理；&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.2421875&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/uUIibyNXbAvBo8fxeW93ib70RfVGcJXibKibdL3bDfzJfQnb7HxiboxxeGsdunRDlfC63nDticO6fGFsEvAIgiaKHenFg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;pre&gt;&lt;code&gt;-javaagent:本地路径/agent/skywalking-agent.jar -Dskywalking.agent.service_name=gateway&lt;br/&gt;-javaagent:本地路径/agent/skywalking-agent.jar -Dskywalking.agent.service_name=facade&lt;br/&gt;-javaagent:本地路径/agent/skywalking-agent.jar -Dskywalking.agent.service_name=account&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这样全部的配置就完成了，依次启动skywalking相关服务，与这里配置的三个微服务，下面再来看看功能细节；&lt;/p&gt;&lt;h1&gt;&lt;span&gt;四、功能细节&lt;/span&gt;&lt;span/&gt;&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;1、服务监控&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;相关服务启动完成后，访问skywalking界面，主页加载的即上述配置的三个微服务，这样说明整个流程是正常的，点击服务名称可以查看服务相关的细节指标；&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.27734375&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/uUIibyNXbAvBo8fxeW93ib70RfVGcJXibKib8rjKU0pgsj5rjqnhaKria9Fy8icbGnsrXuoGYTGOqwbmhbu7Ybic6CVMg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;2、拓补结构图&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;请求通过&lt;code&gt;gateway&lt;/code&gt;网关服务，经过&lt;code&gt;facade&lt;/code&gt;门面服务，到达&lt;code&gt;account&lt;/code&gt;业务服务，完成一次调用后，查看请求的拓补结构图（即Topology一栏）；&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.48984375&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/uUIibyNXbAvBo8fxeW93ib70RfVGcJXibKibQdcbruH4XJhwt3uLxDG8EJxH8LmiakEPyXibVjorHc5fTycafnYGDFnA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;可以清晰的看到请求的路由链路，以及相关服务访问的数据库地址，对于微服务架构中的复杂接口来说，借助该拓补模型，既可以快速理解业务逻辑，同时在出具文档时可以节省很多画图时间；&lt;/p&gt;&lt;p&gt;&lt;strong&gt;3、链路跟踪&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;上面只是请求的拓补结构图，在实际应用中还是更侧重链路跟踪，查看&lt;code&gt;account&lt;/code&gt;服务请求链路（即Trace一栏）；&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.4421875&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/uUIibyNXbAvBo8fxeW93ib70RfVGcJXibKibXIrdutu84dUMYeB6yYFrDzkqbzSeB3GR0Fqrg2lmePEIHCdJNwwm1A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;skywalking组件对于开发来说，最常用的就是该功能，这里采集了请求链路上的各个节点，以及执行的耗时分析，点击相关节点可以查看详细信息，针对异常请求同样可以采集到异常信息的描述；&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.35078125&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/uUIibyNXbAvBo8fxeW93ib70RfVGcJXibKibILneXS591qfS8iaWpGkiaIMicvibwXL8WYqAnHOyF8yyWqdQKrE0OSiaWicg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;这样可以极大的提升问题排查的效率，尤其对于那种路由十多个服务的业务逻辑；&lt;/p&gt;&lt;p&gt;&lt;strong&gt;4、数据库监控&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;虽然在整个配置中没有显式的添加对MySQL的监控，但是skywalking依旧可以实现对服务中的数据库监控，对于这些指标细节不过多描述，可以自行查阅文档；&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.32734375&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/uUIibyNXbAvBo8fxeW93ib70RfVGcJXibKibdBXuPVm5ZQIiaQsetAFYDbK26BpuSrg3HXXjuibhDyEkwqLibicG8a6vlQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;本篇文章只是站在开发的角度，总结skywalking的应用方式，并未涉及过多的细节原理，其它强大的功能设计，对于开发来说同样值得参考。&lt;/p&gt;&lt;h1&gt;&lt;span&gt;五、源码参考&lt;/span&gt;&lt;span/&gt;&lt;/h1&gt;&lt;pre&gt;&lt;code&gt;应用仓库：&lt;br/&gt;https://gitee.com/cicadasmile/butte-flyer-parent&lt;br/&gt;&lt;br/&gt;组件封装：&lt;br/&gt;https://gitee.com/cicadasmile/butte-frame-parent&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;section class=&quot;mp_profile_iframe_wrp&quot;&gt;&lt;mp-common-profile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mpprofile&quot; data-id=&quot;MzU4Njg0MzYwNw==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/uUIibyNXbAvBj3abVSgCmvm7FIYw55ficInd2se9ia6KSic0ma25AUvrmUtXUwXibjhHmCc7DUawfXBI30QuHBjDnzw/0?wx_fmt=png&quot; data-nickname=&quot;知了一笑&quot; data-alias=&quot;cicada_smile&quot; data-signature=&quot;积累、总结、用心记录。&quot; data-from=&quot;0&quot; data-is_biz_ban=&quot;0&quot;/&gt;&lt;/section&gt;&lt;/div&gt;

          
        &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>