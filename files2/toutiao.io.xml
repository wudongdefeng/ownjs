<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>bd5cb3260033f18b72e22a1cf707a99b</guid>
<title>在原生终端实现类似 rz、sz 上传下载文件与目录的功能</title>
<link>https://toutiao.io/k/728cgxk</link>
<content:encoded>&lt;div&gt;&lt;div&gt;
  &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>f7d2a9d7fdffe3471bcee31adf77bc13</guid>
<title>记一次自定义 Redis 分布式锁导致的故障</title>
<link>https://toutiao.io/k/j5advvd</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content                           autoTypeSetting24psection&amp;#10;                          &quot; id=&quot;js_content&quot;&gt;
            &lt;p&gt;&lt;span&gt;&lt;span&gt;（给&lt;/span&gt;&lt;span&gt;ImportNew&lt;/span&gt;&lt;span&gt;加星标，提高Java技能）&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;背景&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;企微报警群里连续发出生产环境报错警告，报错核心信息如下：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;css&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__selector-tag&quot;&gt;redis&lt;/span&gt; &lt;span class=&quot;code-snippet__selector-tag&quot;&gt;setNX&lt;/span&gt; &lt;span class=&quot;code-snippet__selector-tag&quot;&gt;error&lt;/span&gt; &lt;span class=&quot;code-snippet__selector-tag&quot;&gt;java&lt;/span&gt;&lt;span class=&quot;code-snippet__selector-class&quot;&gt;.lang&lt;/span&gt;&lt;span class=&quot;code-snippet__selector-class&quot;&gt;.NumberFormatException&lt;/span&gt;: &lt;span class=&quot;code-snippet__selector-tag&quot;&gt;For&lt;/span&gt; &lt;span class=&quot;code-snippet__selector-tag&quot;&gt;input&lt;/span&gt; &lt;span class=&quot;code-snippet__selector-tag&quot;&gt;string&lt;/span&gt;: &quot;&lt;span class=&quot;code-snippet__selector-tag&quot;&gt;null&lt;/span&gt;&quot;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  &lt;span class=&quot;code-snippet__selector-tag&quot;&gt;at&lt;/span&gt; &lt;span class=&quot;code-snippet__selector-tag&quot;&gt;java&lt;/span&gt;&lt;span class=&quot;code-snippet__selector-class&quot;&gt;.lang&lt;/span&gt;&lt;span class=&quot;code-snippet__selector-class&quot;&gt;.NumberFormatException&lt;/span&gt;&lt;span class=&quot;code-snippet__selector-class&quot;&gt;.forInputString&lt;/span&gt;(&lt;span class=&quot;code-snippet__selector-tag&quot;&gt;NumberFormatException&lt;/span&gt;&lt;span class=&quot;code-snippet__selector-class&quot;&gt;.java&lt;/span&gt;&lt;span class=&quot;code-snippet__selector-pseudo&quot;&gt;:65)&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  &lt;span class=&quot;code-snippet__selector-tag&quot;&gt;at&lt;/span&gt; &lt;span class=&quot;code-snippet__selector-tag&quot;&gt;java&lt;/span&gt;&lt;span class=&quot;code-snippet__selector-class&quot;&gt;.lang&lt;/span&gt;&lt;span class=&quot;code-snippet__selector-class&quot;&gt;.Long&lt;/span&gt;&lt;span class=&quot;code-snippet__selector-class&quot;&gt;.parseLong&lt;/span&gt;(&lt;span class=&quot;code-snippet__selector-tag&quot;&gt;Long&lt;/span&gt;&lt;span class=&quot;code-snippet__selector-class&quot;&gt;.java&lt;/span&gt;&lt;span class=&quot;code-snippet__selector-pseudo&quot;&gt;:589)&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  &lt;span class=&quot;code-snippet__selector-tag&quot;&gt;at&lt;/span&gt; &lt;span class=&quot;code-snippet__selector-tag&quot;&gt;java&lt;/span&gt;&lt;span class=&quot;code-snippet__selector-class&quot;&gt;.lang&lt;/span&gt;&lt;span class=&quot;code-snippet__selector-class&quot;&gt;.Long&lt;/span&gt;&lt;span class=&quot;code-snippet__selector-class&quot;&gt;.parseLong&lt;/span&gt;(&lt;span class=&quot;code-snippet__selector-tag&quot;&gt;Long&lt;/span&gt;&lt;span class=&quot;code-snippet__selector-class&quot;&gt;.java&lt;/span&gt;&lt;span class=&quot;code-snippet__selector-pseudo&quot;&gt;:631)&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;......&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;经异常信息定位，发现是项目中自定义的 Redis 分布式锁报错，并且该异常是在最近需求上线后突然出现，并且伴随该异常出现的，还有需求涉及的业务数据出现部分错乱的问题。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;问题分析&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;老规矩，先贴涉及代码：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;cs&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;RedisLockAspect&lt;/span&gt;{&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  &lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;around&lt;/span&gt;(&lt;span class=&quot;code-snippet__params&quot;&gt;ProceedingJoinPoint pjp&lt;/span&gt;)&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    String key = &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;...&quot;&lt;/span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;try&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;      &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;      &lt;span class=&quot;code-snippet__keyword&quot;&gt;while&lt;/span&gt; (!JedisUtil.&lt;span class=&quot;code-snippet__keyword&quot;&gt;lock&lt;/span&gt;(key, timeOut)) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        Thread.sleep(&lt;span class=&quot;code-snippet__number&quot;&gt;10&lt;/span&gt;);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;      }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;      &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;      pjp.proceed();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }&lt;span class=&quot;code-snippet__keyword&quot;&gt;finally&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;      JedisUtil.unLock(key);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;以上为自定义 Redis 分布式锁的切面，不看细节，只看整体逻辑，问题不大。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;那再看实际加锁方法：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;typescript&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;class&lt;/span&gt; JedisUtil{&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  &lt;span class=&quot;code-snippet__keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;code-snippet__built_in&quot;&gt;boolean&lt;/span&gt; lock(&lt;span class=&quot;code-snippet__built_in&quot;&gt;String&lt;/span&gt; key, long timeOut){&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        long currentTimeMillis = System.currentTimeMillis();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        long newExpireTime = currentTimeMillis + timeOut;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        RedisConnection connection = &lt;span class=&quot;code-snippet__literal&quot;&gt;null&lt;/span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__keyword&quot;&gt;try&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            connection = getRedisTemplate().getConnectionFactory().getConnection();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            &lt;span class=&quot;code-snippet__built_in&quot;&gt;Boolean&lt;/span&gt; setNxResult = connection.setNX(key.getBytes(StandardCharsets.UTF_8), &lt;span class=&quot;code-snippet__built_in&quot;&gt;String&lt;/span&gt;.valueOf(newExpireTime).getBytes(StandardCharsets.UTF_8));&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;          &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            &lt;span class=&quot;code-snippet__keyword&quot;&gt;if&lt;/span&gt;(setNxResult){&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                expire(key,timeOut, TimeUnit.MILLISECONDS);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                &lt;span class=&quot;code-snippet__keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;code-snippet__literal&quot;&gt;true&lt;/span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;          &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            &lt;span class=&quot;code-snippet__built_in&quot;&gt;Object&lt;/span&gt; objVal = getRedisTemplate().opsForValue().get(key);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            &lt;span class=&quot;code-snippet__built_in&quot;&gt;String&lt;/span&gt; currentValue  = &lt;span class=&quot;code-snippet__built_in&quot;&gt;String&lt;/span&gt;.valueOf(objVal);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;          &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            &lt;span class=&quot;code-snippet__keyword&quot;&gt;if&lt;/span&gt; (currentValue != &lt;span class=&quot;code-snippet__literal&quot;&gt;null&lt;/span&gt; &amp;amp;&amp;amp; Long.parseLong(currentValue) &amp;lt; currentTimeMillis)  {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                &lt;span class=&quot;code-snippet__built_in&quot;&gt;String&lt;/span&gt; oldExpireTime = (&lt;span class=&quot;code-snippet__built_in&quot;&gt;String&lt;/span&gt;) getAndSet(key, &lt;span class=&quot;code-snippet__built_in&quot;&gt;String&lt;/span&gt;.valueOf(newExpireTime));&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                &lt;span class=&quot;code-snippet__keyword&quot;&gt;if&lt;/span&gt; (oldExpireTime != &lt;span class=&quot;code-snippet__literal&quot;&gt;null&lt;/span&gt; &amp;amp;&amp;amp; oldExpireTime.equals(currentValue)) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                    &lt;span class=&quot;code-snippet__keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;code-snippet__literal&quot;&gt;true&lt;/span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;code-snippet__literal&quot;&gt;false&lt;/span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  &lt;span class=&quot;code-snippet__keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;code-snippet__built_in&quot;&gt;void&lt;/span&gt; unLock(&lt;span class=&quot;code-snippet__built_in&quot;&gt;String&lt;/span&gt; key){&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    getRedisTemplate().delete(key);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;有经验的大佬看到这段代码，估计会忍不住爆粗，但咱先不管，先看错误位置。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;异常信息可以看出，currentValue 的值为字符串“null”，即 String.valueOf(objVal) 中的 objVal 对象为 null，也就是在 Redis 中，key 对应的 value 不存在。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;此时思考一下，key 对应的 value 不存在，无非以下两种情况：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;继续跟着代码往上走，发现前面执行了 setNx 命令，并且返回 setNxResult 表示是否成功。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;正常来说，当 setNxResult 为 false 的时候，加锁失败，此时代码时不应该往下走的，但在本段代码中，却继续往下走！&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;问了下相关同事，说是为了做可重入锁......（弱弱吐槽下，可重入锁也不是这样干的啊...）&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;其实分析到这，已经可以知道是什么原因导致的异常故障了，即上面说的，key 被主动删除、key 过期导致。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;下面假设有两个线程，对同一个 key 加锁，分别对应以上两种情况：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;①key 被主动删除的情况，&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;发生于分布式锁加锁逻辑执行完后，调用 unlock 方法，见以上 RedisLockAspect 类中 finally 部分，&lt;/span&gt;&lt;span&gt;如下图：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;578&quot; data-cropsely1=&quot;1&quot; data-cropsely2=&quot;230&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.4017621145374449&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/1J6IbIcPCLZwzCeQvvRejicQPtZ4lxIs3T8dZk9b5INfTCGdKqSib5EDpw1ibRdVMTw5xaLA2KnneNuWlCzLLOkwA/640?wx_fmt=png&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; data-type=&quot;png&quot; data-w=&quot;1135&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;②key 过期的情况，&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;主要在线程加锁并设置过期时间后，执行业务代码耗费的时间超过设置的锁过期时间，并且在锁过期前，未对锁进行续期：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.40406719717064543&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/1J6IbIcPCLZwzCeQvvRejicQPtZ4lxIs3ribwmQyzfPdItYgCrwD7f8Xq1SgB0ASnkGMxmnfswtC0RXoLvwsUFwQ/640?wx_fmt=png&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; data-type=&quot;png&quot; data-w=&quot;1131&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;解决方案&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;从上面的代码看来，这已经不是简单的 Long.parseLong(&quot;null&quot;) 问题了，这是整个 Redis 分布式锁实现的问题。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;并且该分布式锁在整个项目中大量使用，可想而知其实问题非常严重，如果只是解决 Long.parseLong(&quot;null&quot;) 的问题，无疑就是隔靴挠痒，没有任何意义的。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;一般情况下，自定义 Redis 分布式锁容易出现以下几大问题：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;setNx 锁释放问题&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;setNx Expire 原子性问题&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;锁过期问题&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;多线程释放锁问题&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;可重入问题&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;大量失败时自旋锁问题&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;主从架构下锁数据同步问题&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;结合以上故障代码，可以发现项目中的 Redis 分布式锁实现几乎未对 Redis 分布式锁问题进行考虑。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;以下为主要问题以及对应解决方案：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;setNx 和 expire 原子操作：&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;使用 Lua 脚本，在一次 Lua 脚本命令中，执行 setNx  与 expire 命令，保证原子性。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;锁过期问题：&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;为防止锁自动过期，可在锁过期前，定时对锁过期时间进行续期。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;可重入问题：&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;可重入设计粒度需到线程级别，可在锁上加上线程唯一 id。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;锁自旋问题：&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;参考 JDK 中 AQS 设计，实现获取锁时最大等待时长。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;对于项目中的问题以及每个问题的解决方案实现，baidu 一下就有大量参考，此处不再介绍。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;目前比较成熟的综合解决方案为使用 Redisson 客户端，以下为简单伪代码 demo：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;cs&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;RedisLockAspect&lt;/span&gt;{&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  @Autowired&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  &lt;span class=&quot;code-snippet__keyword&quot;&gt;private&lt;/span&gt; Redisson redisson;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  &lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;around&lt;/span&gt;(&lt;span class=&quot;code-snippet__params&quot;&gt;ProceedingJoinPoint pjp&lt;/span&gt;)&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    String key = &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;...&quot;&lt;/span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    Long waitTime = &lt;span class=&quot;code-snippet__number&quot;&gt;3000L&lt;/span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    RLock &lt;span class=&quot;code-snippet__keyword&quot;&gt;lock&lt;/span&gt; = redisson.getLock(key);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    boolean lockSuccess = &lt;span class=&quot;code-snippet__literal&quot;&gt;false&lt;/span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;try&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;      &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;      lockSuccess = &lt;span class=&quot;code-snippet__keyword&quot;&gt;lock&lt;/span&gt;.tryLock(waitTime);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;      &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;      pjp.proceed();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }&lt;span class=&quot;code-snippet__keyword&quot;&gt;finally&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;      &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;      &lt;span class=&quot;code-snippet__keyword&quot;&gt;if&lt;/span&gt; (&lt;span class=&quot;code-snippet__keyword&quot;&gt;lock&lt;/span&gt;.isLocked() &amp;amp;&amp;amp; &lt;span class=&quot;code-snippet__keyword&quot;&gt;lock&lt;/span&gt;.isHeldByCurrentThread() &amp;amp;&amp;amp; lockSuccess){&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;          &lt;span class=&quot;code-snippet__keyword&quot;&gt;lock&lt;/span&gt;.unlock();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;      }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;使用 Redisson 可以快速解决目前项目中 Redis 分布式锁存在的问题。除此之外，对于 Redis 主从架构下数据同步导致的锁问题，对应的解决方案 RedLock，也提供了相应的实现。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;更多使用文档详见官方文档：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;https://github.com/liulongbiao/redisson-doc-cn&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;总结&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;对于分布式锁来说，可实现方案其实远远不止 Redis 这个实现途径，比如基于 Zookeeper、基于 Etcd 等方案。&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;但其实对于目的来说，都是殊途同归，重点在于，如何安全、正确的使用这些方案，保证业务正常。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;对于研发团队来说，针对类似的问题，需要对技术小伙伴进行培训，不断提升技术，更需要重视 codereview 工作，及时识别风险，避免发生故障造成严重损失（本次故障造成脏数据修复耗时一个多星期）。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;敬畏技术，忠于业务。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;&lt;span&gt;转自：十年培训经验的菜包&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;链接&lt;span&gt;：https://juejin.cn/post/7113852140455460900&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;- EOF -&lt;/span&gt;&lt;/p&gt;&lt;section donone=&quot;shifuMouseDownCard(&#x27;shifu_c_030&#x27;)&quot; label=&quot;Copyright Reserved by PLAYHUDONG.&quot;&gt;&lt;section&gt;&lt;span&gt;推荐阅读&lt;/span&gt;  &lt;span&gt;点击标题可跳转&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MjM5NzMyMjAwMA==&amp;amp;mid=2651516037&amp;amp;idx=1&amp;amp;sn=66194dfc1b5365b9451f515fba3a69fb&amp;amp;chksm=bd2580fa8a5209ec8080de7bc599688b19a18aeb70492a3ba673f409de8a94047e694e9cae81&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;掘地三尺搞定 Redis 与 MySQL 数据一致性问题&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;11&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;掘地三尺搞定 Redis 与 MySQL 数据一致性问题&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MjM5NzMyMjAwMA==&amp;amp;mid=2651515566&amp;amp;idx=1&amp;amp;sn=89609233ab6414dfa46e7d599220e554&amp;amp;chksm=bd2586d18a520fc760fff157a065bdbdd287bcf1002118a7eb54c6b68f9374555cb7f4d9e881&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;解决了 Redis 大 key 问题，同事们都夸他牛皮&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;11&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;解决了 Redis 大 key 问题，同事们都夸他牛皮&lt;/a&gt;&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MjM5NzMyMjAwMA==&amp;amp;mid=2651515382&amp;amp;idx=2&amp;amp;sn=2b5d523cea24416980d06e2a7cc171b4&amp;amp;chksm=bd2585898a520c9f3a781598b000c13f8b84b5815625e309380329a1ea5220ec8ca7fc210a8d&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;舒服了，踩到一个关于分布式锁的非比寻常的BUG！&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;11&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;舒服了，踩到一个关于分布式锁的非比寻常的BUG！&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;看完本文有收获？请转发分享给更多人&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;关注「ImportNew」，提升Java技能&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.9166666666666666&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/2A8tXicCG8ylbWIGfdoDED35IRRySQZTXUkJ1eop9MHApzFibKnOo0diboXpl0rmS5mH78YJhsWQv0dhv718A6kUA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;600&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span/&gt;&lt;span&gt;点赞和在看就是最大的支持&lt;/span&gt;&lt;span&gt;❤️&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;
          &lt;/div&gt;

          

          



           
                                
                    
        &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>2718be7433a9bbf3875eadc10c7b4839</guid>
<title>【视频】如何写高效内存Java代码——How to Write Memory-Efficient Java Code</title>
<link>https://toutiao.io/k/gi4sphc</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;profile_inner&quot;&gt;
                  &lt;strong class=&quot;profile_nickname&quot;&gt;搬运工来架构&lt;/strong&gt;
                  &lt;img class=&quot;profile_avatar&quot; id=&quot;js_profile_qrcode_img&quot; src=&quot;&quot; alt=&quot;&quot;/&gt;

                  &lt;p class=&quot;profile_meta&quot;&gt;
                  &lt;label class=&quot;profile_meta_label&quot;&gt;Weixin ID&lt;/label&gt;
                  &lt;span class=&quot;profile_meta_value&quot;&gt;java-backend&lt;/span&gt;
                  &lt;/p&gt;

                  &lt;p class=&quot;profile_meta&quot;&gt;
                  &lt;label class=&quot;profile_meta_label&quot;&gt;About Feature&lt;/label&gt;
                  &lt;span class=&quot;profile_meta_value&quot;&gt;关注Java领域、后端、微服务、架构、分布式、实战经验等。分享技术干货！&lt;/span&gt;
                  &lt;/p&gt;
                &lt;/div&gt;
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>372aba188af1f09c7176c320a6e3fa23</guid>
<title>【萌新解题】子集</title>
<link>https://toutiao.io/k/9nk4bf2</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content                                       &quot; id=&quot;js_content&quot;&gt;
            &lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;关于我：微信公众号：&lt;strong&gt;面试官问&lt;/strong&gt;，原创高质量面试题，始于面试题，但不止于面试题。【萌新解题】系列文章试图&lt;strong&gt;从新人的角度&lt;/strong&gt;去看待和解决力扣题目，本题是力扣第 78 题 子集：https://leetcode.cn/problems/subsets/。&lt;/p&gt;&lt;/blockquote&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;题目描述&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;给你一个整数数组 nums ，数组中的元素 &lt;strong&gt;互不相同&lt;/strong&gt; 。返回该数组所有可能的子集（幂集）。解集 &lt;strong&gt;不能&lt;/strong&gt; 包含重复的子集。你可以按 &lt;strong&gt;任意顺序&lt;/strong&gt; 返回解集。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;前置知识点&lt;/h2&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;明确排列和组合的区别：&lt;/section&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;组合的定义：从一个包含 m 个元素的集合中挑选出 n 个元素（0≤n≤m）形成一个子集。&lt;strong&gt;一个子集又可以称为一个组合&lt;/strong&gt;。如果两个子集（组合）的元素完全相同只是顺序不同，那么它们可以看作同一个子集（组合）。也就是说组合就是没有顺序的，例如 [1,2] 和 [2,1] 是同一个组合&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;从一个包含 m 个元素的集合中挑选出 n 个元素（0≤n≤m）并按照某种顺序形成一个排列。m 等于 n 的排列又称为&lt;strong&gt;全排列&lt;/strong&gt;。如果两个排列的元素完全相同只是顺序不同，那么它们就是两个不同的排列。也就是说，排列与元素的顺序相关，这一点与组合不同。例如 [1,2] 和 [2,1] 是不同的排列&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;li&gt;&lt;section&gt;组合问题是经典的回溯算法问题，在求解回溯算法类型的问题时，我们首先要套用&lt;strong&gt;回溯算法的解题模板&lt;/strong&gt;，伪代码如下所示：&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;//符合条件的结果集合&lt;/span&gt;&lt;br/&gt;ans = [] &lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;void&lt;/span&gt; &lt;span&gt;backtracking&lt;/span&gt;&lt;span&gt;(路径，选择列表)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (满足结束条件) {&lt;br/&gt;        ans.add(路径);&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt;;&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;for&lt;/span&gt; (选择 : 选择列表) {&lt;br/&gt;        做选择&lt;br/&gt;        backtracking(路径，选择列表)&lt;br/&gt;        撤销选择&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;解题说明&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;本题要求返回数组所有可能的子集，例如对于输入：nums = [1,2,3]，它的输出是：[[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]。因此，我们可以遍历数组，每一步从数组中取出一个元素，此时面临&lt;strong&gt;两个选择&lt;/strong&gt;：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;将该元素添加到子集 path 中&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;不将该数字添加到子集 path 中&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上面做完选择后，就继续递归判断数组中的下一个元素，如果上面选择将元素添加到子集中，那递归执行完成后，还得记得撤销刚才的选择，也就是把元素从子集中删除。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;相信理解核心原理后，大家可以很快写出如下代码：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;Solution&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;// 存放符合条件结果的集合&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; ArrayList&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; ans = &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;&amp;gt;();&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;// 用来存放符合条件的单个结果&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; LinkedList&amp;lt;Integer&amp;gt; path = &lt;span&gt;new&lt;/span&gt; LinkedList&amp;lt;&amp;gt;();&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;public&lt;/span&gt; List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; subsets(&lt;span&gt;int&lt;/span&gt;[] nums) {&lt;br/&gt;        &lt;span&gt;int&lt;/span&gt; len = nums.length;&lt;br/&gt;        &lt;span&gt;// 按照题目要求，startIndex 从 0 开始&lt;/span&gt;&lt;br/&gt;        backtracking(nums, len, &lt;span&gt;0&lt;/span&gt;);&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; ans;&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;/**&lt;br/&gt;     * 回溯函数&lt;br/&gt;     *&lt;br/&gt;     * nums：数组&lt;br/&gt;     * size：数组大小&lt;br/&gt;     * startIndex: 当前取出的数字在数组nums中的下标&lt;br/&gt;     */&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;backtracking&lt;/span&gt;&lt;span&gt;(&lt;span&gt;int&lt;/span&gt;[] nums, &lt;span&gt;int&lt;/span&gt; size, &lt;span&gt;int&lt;/span&gt; startIndex)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;// 结束条件&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (startIndex == size) {&lt;br/&gt;            &lt;span&gt;// 数组最后的元素已经遍历完，得到一个结果&lt;/span&gt;&lt;br/&gt;            ans.add(&lt;span&gt;new&lt;/span&gt; LinkedList&amp;lt;&amp;gt;(path));&lt;br/&gt;            &lt;span&gt;return&lt;/span&gt;;&lt;br/&gt;        }&lt;br/&gt;&lt;br/&gt;        &lt;span&gt;// 此处的选择列表其实只有两个选择，所以不需要使用for循环了，直接判断即可&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;// 选择一：将 nums[startIndex] 加入当前路径path中，并递归调用数组的下一元素，递归结束后再撤销当前选择&lt;/span&gt;&lt;br/&gt;        path.add(nums[startIndex]);&lt;br/&gt;        backtracking(nums, size, startIndex+&lt;span&gt;1&lt;/span&gt;);&lt;br/&gt;        path.removeLast();&lt;br/&gt;&lt;br/&gt;        &lt;span&gt;// 选择二：不将 nums[startIndex] 加入当前路径path中，直接递归调用数组下一元素即可&lt;/span&gt;&lt;br/&gt;        backtracking(nums, size, startIndex+&lt;span&gt;1&lt;/span&gt;);&lt;br/&gt;     }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;复杂度分析&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果输入的集合中有 n 个元素，由于每个元素都有 2 个选项：&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;参考资料&lt;/h2&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;《剑指 Offer（专项突破版）：数据结构与算法名企面试题精讲》&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;
          &lt;/div&gt;

          

          



           
                                
                    
        &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>b482d508372c761c05efb1b87b4a199c</guid>
<title>Java 8 的异步利器：CompletableFuture源码级解析（建议精读）</title>
<link>https://toutiao.io/k/9vn9jan</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;completableFuture&lt;/code&gt;是JDK1.8版本新引入的类。下面是这个类：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.21389645776566757&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/eQPyBffYbuc0rvaSAklibFPMlIRicwuNXJ0dlpJZjpBOzlexCCicCxnwSdsMZ2pp9NvaicPMbA3BCeUtRgAsKHmickg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1468&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;实现了俩接口，本身是个class。这个是Future的实现类，使用&lt;code&gt;completionStage&lt;/code&gt;接口去支持完成时触发的函数和操作。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;一个&lt;code&gt;completetableFuture&lt;/code&gt;就代表了一个任务，他能用Future的方法，还能做一些之前说的&lt;code&gt;executorService&lt;/code&gt;配合&lt;code&gt;futures&lt;/code&gt;做不了的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;之前future需要等待isDone为true才能知道任务跑完了，或者就是用get方法调用的时候会出现阻塞，而使用&lt;code&gt;completableFuture&lt;/code&gt;的使用就可以用then，when等等操作来防止以上的阻塞和轮询isDone的现象出现。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;/&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;1.创建&lt;code&gt;CompletableFuture&lt;/code&gt;直接new对象。&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;一个&lt;code&gt;completableFuture&lt;/code&gt;对象代表着一个任务，这个对象能跟这个任务产生联系。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;下面用的&lt;code&gt;complete&lt;/code&gt;方法意思就是这个任务完成了需要返回的结果，然后用&lt;code&gt;get()&lt;/code&gt;方法可以获取到。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.3859250851305335&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/eQPyBffYbuc0rvaSAklibFPMlIRicwuNXJcxVcHJvT676J3YyT8dFHke4UzeHia1wz0UUYYaXrKGfRTzUhsdGKQSg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1762&quot;/&gt;&lt;/figure&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;2.JDK1.8使用的接口类。&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在本文的&lt;code&gt;CompletableFuture&lt;/code&gt;中大量的使用了这些函数式接口。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;注：这些声明大量应用于方法的入参中，像&lt;code&gt;thenApply&lt;/code&gt;和&lt;code&gt;thenAccept&lt;/code&gt;这俩就是一个用Function一个用Consumer&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;而lambda函数正好是可以作为这些接口的实现。例如 &lt;code&gt;s-&amp;gt;{return 1;}&lt;/code&gt; 这个就相当于一个Function。因为有入参和返回结果。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.2196601941747573&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/eQPyBffYbuc0rvaSAklibFPMlIRicwuNXJich9fwpaZxPX8VWobQeaDpPraygJicwOfur8w8LlL8LkxCtwJof3lLQQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;824&quot;/&gt;(1)Function&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.38228699551569506&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/eQPyBffYbuc0rvaSAklibFPMlIRicwuNXJXHNHX451I737c2xOYt6IzEk5j2b5B1pNogmCrx2UfuvwgficrImME5w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;892&quot;/&gt;(2)Consumer&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.3031400966183575&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/eQPyBffYbuc0rvaSAklibFPMlIRicwuNXJC10b5utEme2HQCvjWzLpL9I6Lw4Swsm8yVPT7KNhHiaXI8bwlO4SGLg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;828&quot;/&gt;对于前面有Bi的就是这样的，BiConsumer就是两个参数的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.28773584905660377&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/eQPyBffYbuc0rvaSAklibFPMlIRicwuNXJBvldGWEyMt0RBMApYsaicHJKerlIzpJKX8WAwPoKGAMv7OJNw5MuvMw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;848&quot;/&gt;(3)Predicate这个接口声明是一个入参，返回一个boolean。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.3275862068965517&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/eQPyBffYbuc0rvaSAklibFPMlIRicwuNXJsoibjFPaj7iakelCTZc50kWaZDahqSzlPkSS1cjReSrGonicO07BSyt9A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;870&quot;/&gt;(4)supplier&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.3505747126436782&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/eQPyBffYbuc0rvaSAklibFPMlIRicwuNXJMGktkRQrKicYS4jJK2xZTgwdNnk8LbT810XkpYmT6yJMl0ppjhQxBfA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;696&quot;/&gt;&lt;/figure&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;3.下面是这个类的静态方法&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;带有Async就是异步执行的意思、也是一个&lt;code&gt;completableFuture&lt;/code&gt;对象代表着一个任务这个原则。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这种异步方法都可以指定一个线程池作为任务的运行环境，如果没有指定就会使用&lt;code&gt;ForkJoinPool&lt;/code&gt;线程池来执行&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.3155080213903743&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/eQPyBffYbuc0rvaSAklibFPMlIRicwuNXJoruJ2h0vQVGriankO2dWsBOuxILN9JRJOb8iaLM6xkQBWKtMRHcaFlSg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1496&quot;/&gt;(1)&lt;code&gt;supplyAsync&amp;amp;runAsync&lt;/code&gt;的使用例子。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;(String[] args)&lt;/span&gt; &lt;span&gt;throws&lt;/span&gt; ExecutionException, InterruptedException &lt;/span&gt;{&lt;br/&gt;    ExecutorService executorService = Executors.newCachedThreadPool();&lt;br/&gt;    executorService.submit(&lt;span&gt;new&lt;/span&gt; Callable&amp;lt;Object&amp;gt;() {&lt;br/&gt;        &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;&lt;span&gt;public&lt;/span&gt; Object &lt;span&gt;call&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;span&gt;throws&lt;/span&gt; Exception &lt;/span&gt;{&lt;br/&gt;            System.out.println(&lt;span&gt;&quot;executorService 是否为守护线程 :&quot;&lt;/span&gt; + Thread.currentThread().isDaemon());&lt;br/&gt;            &lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;;&lt;br/&gt;        }&lt;br/&gt;    });&lt;br/&gt;    &lt;span&gt;final&lt;/span&gt; CompletableFuture&amp;lt;String&amp;gt; completableFuture = CompletableFuture.supplyAsync(() -&amp;gt; {&lt;br/&gt;        System.out.println(&lt;span&gt;&quot;this is lambda supplyAsync&quot;&lt;/span&gt;);&lt;br/&gt;        System.out.println(&lt;span&gt;&quot;supplyAsync 是否为守护线程 &quot;&lt;/span&gt; + Thread.currentThread().isDaemon());&lt;br/&gt;        &lt;span&gt;try&lt;/span&gt; {&lt;br/&gt;            TimeUnit.SECONDS.sleep(&lt;span&gt;2&lt;/span&gt;);&lt;br/&gt;        } &lt;span&gt;catch&lt;/span&gt; (InterruptedException e) {&lt;br/&gt;            e.printStackTrace();&lt;br/&gt;        }&lt;br/&gt;        System.out.println(&lt;span&gt;&quot;this lambda is executed by forkJoinPool&quot;&lt;/span&gt;);&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;&quot;result1&quot;&lt;/span&gt;;&lt;br/&gt;    });&lt;br/&gt;    &lt;span&gt;final&lt;/span&gt; CompletableFuture&amp;lt;String&amp;gt; future = CompletableFuture.supplyAsync(() -&amp;gt; {&lt;br/&gt;        System.out.println(&lt;span&gt;&quot;this is task with executor&quot;&lt;/span&gt;);&lt;br/&gt;System.out.println(&lt;span&gt;&quot;supplyAsync 使用executorService 时是否为守护线程 : &quot;&lt;/span&gt; + Thread.currentThread().isDaemon());&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;&quot;result2&quot;&lt;/span&gt;;&lt;br/&gt;    }, executorService);&lt;br/&gt;    System.out.println(completableFuture.get());&lt;br/&gt;    System.out.println(future.get());&lt;br/&gt;    executorService.shutdown();&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.333810888252149&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/eQPyBffYbuc0rvaSAklibFPMlIRicwuNXJBLzk5ypfjcK6eBHXnQPiaBxjgrF8mjR7yDZA9ZV3ndsKIbp1ujFtflQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1396&quot;/&gt;这些任务中带有supply是持有返回值的，run是void返回值的，在玩supply时发现一个问题：如果使用supplyAsync任务时不使用任务的返回值，即&lt;strong&gt;不用get方法阻塞主线程会导致任务执行中断。&lt;/strong&gt;&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;注：跟get方法无关，后面有答案&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.494967978042086&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/eQPyBffYbuc0rvaSAklibFPMlIRicwuNXJYs8DsAOxRaJSoe9oCZLmcMdI4RLWW7KLWxNUNvLLp89XZx6yzrGT4w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2186&quot;/&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.48078641644325293&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/eQPyBffYbuc0rvaSAklibFPMlIRicwuNXJfcCdBoB5fOPZsGbiaYSE0m2geFzd57YMib46ib4VskKGlI0oK26vQshvg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2238&quot;/&gt;然后我开始探索是否是只有&lt;code&gt;supplyAsync&lt;/code&gt;是这样。我测试了&lt;code&gt;runAsync&lt;/code&gt;发现也是这样。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5532994923857868&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/eQPyBffYbuc0rvaSAklibFPMlIRicwuNXJYM5u2hRHVa7Mz14cTEtvLWhvDrFQYkFEB0rBG6yrcKNG90JdN20g4g/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1970&quot;/&gt;下图为与&lt;code&gt;supplyAsync&lt;/code&gt;任务执行不全面一样的问题，我甚至测试了将lambda换成runnable发现无济于事。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5156555772994129&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/eQPyBffYbuc0rvaSAklibFPMlIRicwuNXJTMLrJWCfnDem0Oo9rREMBUzC9gcsSIqICjf4jmickq9PF48n0DMmw9A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2044&quot;/&gt;&lt;/figure&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;答案：&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;造成这个原因是因为Daemon&lt;/strong&gt;。因为&lt;code&gt;completableFuture&lt;/code&gt;这套使用异步任务的操作都是创建成了守护线程，那么我们没有调用get方法不阻塞这个主线程的时候。主线程执行完毕，所有线程执行完毕就会导致一个问题，就是守护线程退出。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那么我们没有执行的代码就是因为主线程不再跑任务而关闭导致的，可能这个不叫问题，因为在开发中我们主线程常常是一直开着的。但是这个小问题同样让我想了好久。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;下面我们开一个非守护线程，可以看到程序执行顺利。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5648148148148148&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/eQPyBffYbuc0rvaSAklibFPMlIRicwuNXJiapyxP5LbvLKv8IH7xTAzh5XmhRKLicHO61pib4Vh3HiayOGEPJhgcZiaXQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2376&quot;/&gt;下面证实守护线程在其他非守护线程全部退出的情况下不继续执行。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;final&lt;/span&gt; CompletableFuture&amp;lt;String&amp;gt; completableFuture = CompletableFuture.supplyAsync(() -&amp;gt; {&lt;br/&gt;    System.out.println(&lt;span&gt;&quot;this is lambda supplyAsync&quot;&lt;/span&gt;);&lt;br/&gt;    System.out.println(&lt;span&gt;&quot;supplyAsync 是否为守护线程 &quot;&lt;/span&gt; + Thread.currentThread().isDaemon());&lt;br/&gt;    &lt;span&gt;try&lt;/span&gt; {&lt;br/&gt;        TimeUnit.SECONDS.sleep(&lt;span&gt;1&lt;/span&gt;);&lt;br/&gt;        &lt;span&gt;try&lt;/span&gt;(BufferedWriter writer = &lt;span&gt;new&lt;/span&gt; BufferedWriter&lt;br/&gt;                (&lt;span&gt;new&lt;/span&gt; OutputStreamWriter(&lt;span&gt;new&lt;/span&gt; FileOutputStream(&lt;span&gt;new&lt;/span&gt; File(&lt;span&gt;&quot;/Users/zhangyong/Desktop/temp/out.txt&quot;&lt;/span&gt;))))){&lt;br/&gt;            writer.write(&lt;span&gt;&quot;this is completableFuture daemon test&quot;&lt;/span&gt;);&lt;br/&gt;        }&lt;span&gt;catch&lt;/span&gt; (Exception e){&lt;br/&gt;            System.out.println(&lt;span&gt;&quot;exception find&quot;&lt;/span&gt;);&lt;br/&gt;        }&lt;br/&gt;    } &lt;span&gt;catch&lt;/span&gt; (InterruptedException e) {&lt;br/&gt;        e.printStackTrace();&lt;br/&gt;    }&lt;br/&gt;    System.out.println(&lt;span&gt;&quot;this lambda is executed by forkJoinPool&quot;&lt;/span&gt;);&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; &lt;span&gt;&quot;result1&quot;&lt;/span&gt;;&lt;br/&gt;});&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个代码就是操作本地文件，并且sleep了一秒。其他线程就一句控制台输出的代码，最终的结果是文件没有任何变化。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当我把主线程&lt;code&gt;sleep 5&lt;/code&gt;秒时，本地文件会写入一句  &lt;code&gt;this is completableFuture daemon test&lt;/code&gt;   验证成功。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;(2)allOf&amp;amp;anyOf&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这两个方法的入参是一个&lt;code&gt;completableFuture&lt;/code&gt;组、allOf就是所有任务都完成时返回，但是是个Void的返回值。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;anyOf是当入参的&lt;code&gt;completableFuture&lt;/code&gt;组中有一个任务执行完毕就返回，返回结果是第一个完成的任务的结果。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;otherStaticMethod&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;span&gt;throws&lt;/span&gt; ExecutionException, InterruptedException &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;final&lt;/span&gt; CompletableFuture&amp;lt;String&amp;gt; futureOne = CompletableFuture.supplyAsync(() -&amp;gt; {&lt;br/&gt;            &lt;span&gt;try&lt;/span&gt; {&lt;br/&gt;                Thread.sleep(&lt;span&gt;3000&lt;/span&gt;);&lt;br/&gt;            } &lt;span&gt;catch&lt;/span&gt; (InterruptedException e) {&lt;br/&gt;                System.out.println(&lt;span&gt;&quot;futureOne InterruptedException&quot;&lt;/span&gt;);&lt;br/&gt;            }&lt;br/&gt;            &lt;span&gt;return&lt;/span&gt; &lt;span&gt;&quot;futureOneResult&quot;&lt;/span&gt;;&lt;br/&gt;        });&lt;br/&gt;        &lt;span&gt;final&lt;/span&gt; CompletableFuture&amp;lt;String&amp;gt; futureTwo = CompletableFuture.supplyAsync(() -&amp;gt; {&lt;br/&gt;            &lt;span&gt;try&lt;/span&gt; {&lt;br/&gt;                Thread.sleep(&lt;span&gt;6000&lt;/span&gt;);&lt;br/&gt;            } &lt;span&gt;catch&lt;/span&gt; (InterruptedException e) {&lt;br/&gt;                System.out.println(&lt;span&gt;&quot;futureTwo InterruptedException&quot;&lt;/span&gt;);&lt;br/&gt;            }&lt;br/&gt;            &lt;span&gt;return&lt;/span&gt; &lt;span&gt;&quot;futureTwoResult&quot;&lt;/span&gt;;&lt;br/&gt;        });&lt;br/&gt;        CompletableFuture future = CompletableFuture.allOf(futureOne, futureTwo);&lt;br/&gt;        System.out.println(future.get());&lt;br/&gt;&lt;span&gt;//        CompletableFuture completableFuture = CompletableFuture.anyOf(futureOne, futureTwo);&lt;/span&gt;&lt;br/&gt;&lt;span&gt;//        System.out.println(completableFuture.get());&lt;/span&gt;&lt;br/&gt;    }&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.2804878048780488&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/eQPyBffYbuc0rvaSAklibFPMlIRicwuNXJ4SJia73oFvlxVnXGdu95q6iaehhCUaUiaibGPfsbQnuEnLL0exIH8RVXtw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1312&quot;/&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.26788218793828894&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/eQPyBffYbuc0rvaSAklibFPMlIRicwuNXJibOL5FUwCQXGn8giaX0fKms6rhoDbm2cQ0auMk7lVq3P93n5uOFXfuWw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1426&quot;/&gt;(3)&lt;code&gt;completedFuture&lt;/code&gt;这个方法我没懂他是干啥的，源码就是返回一个值。感觉没啥意义。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.15331491712707182&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/eQPyBffYbuc0rvaSAklibFPMlIRicwuNXJ6j4RxJhvuElEOeGjsKnrHtetLhQNvRgTCehHdFcutkxpaIcqQENMdA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1448&quot;/&gt;(4)取值方法，除了get还有一个&lt;code&gt;getNow();&lt;/code&gt; 这个就比较特殊了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个方法是执行这个方法的时候任务执行完了就返回任务的结果，如果任务没有执行完就返回你的入参。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.3738532110091743&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/eQPyBffYbuc0rvaSAklibFPMlIRicwuNXJbcj7aDoDApDg06L9ias8FDRTB3rzBH1XDR1TwswRTCRVPTOgrxE7vcg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1744&quot;/&gt;(5)join方法跟线程的join用法差不多。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.44028103044496486&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/eQPyBffYbuc0rvaSAklibFPMlIRicwuNXJZIL6ia3mkTTtiboicuN1bYWvDxic0lOZbQYzvmfDTStV6T0GsEpeLfNFVA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1708&quot;/&gt;(6)&lt;code&gt;whenXXX&lt;/code&gt;，在一个任务执行完成之后调用的方法。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个有三个名差不多的方法：&lt;code&gt;whenComplete&lt;/code&gt;、&lt;code&gt;whenCompleteAsync&lt;/code&gt;、还有一个是&lt;code&gt;whenCompleteAsync&lt;/code&gt;用自定义&lt;code&gt;Executor&lt;/code&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.2948571428571429&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/eQPyBffYbuc0rvaSAklibFPMlIRicwuNXJ1Hg29P8Nxib8iaj9ZKNVWEzeIB2f3DgvicojpBuv7vfic9h4bicKyNQZ5hg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1750&quot;/&gt;首先看一下这个&lt;code&gt;whenComplete&lt;/code&gt;实例方法。这个就是任务执行完毕调用的，传入一个action，这个方法的执行线程是当前线程，意味着会阻塞当前线程。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;下面图中test的输出跟&lt;code&gt;whenComplete&lt;/code&gt;方法运行的线程有关，运行到main线程就会阻塞test的输出，运行的是&lt;code&gt;completableFuture&lt;/code&gt;线程则不会阻塞住test的输出。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.49947643979057593&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/eQPyBffYbuc0rvaSAklibFPMlIRicwuNXJiaC1BOL6ZWOX826bYvKLwhFOqmGicg7zWeuM2YJmJqe8Kiae40C1Ozw4g/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1910&quot;/&gt;下面是任务执行的线程的探索。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.575&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/eQPyBffYbuc0rvaSAklibFPMlIRicwuNXJYfU473VGxHFwRkly6gWgOIrknrBvfMzu0FIQq7UYml8fxWiaIIVg89w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2000&quot;/&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5754082612872238&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/eQPyBffYbuc0rvaSAklibFPMlIRicwuNXJKl0a1xzOxCmC4CPHI4uCCLqJwgNn1A3ribbgGLCF28NLllTCXw3Zbug/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2082&quot;/&gt;根据测试得出的结论是：如果调用&lt;code&gt;whenComplete&lt;/code&gt;的中途，还发生了其他事情，图中的主线程的&lt;code&gt;sleep(400)；&lt;/code&gt;导致&lt;code&gt;completableFuture&lt;/code&gt;这个任务执行完毕了，那么就使用主线程调用。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果调用的中途没有发生其他任务且在触碰到&lt;code&gt;whenComplete&lt;/code&gt;方法时&lt;code&gt;completableFuture&lt;/code&gt;这个任务还没有彻底执行完毕那么就会用&lt;code&gt;completableFuture&lt;/code&gt;这个任务所使用的线程。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;下面是&lt;code&gt;whenCompleteAsync&lt;/code&gt;方法。这个方法就是新创建一个异步线程执行。所以不会阻塞。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5029797377830751&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/eQPyBffYbuc0rvaSAklibFPMlIRicwuNXJLdktH0eKYe9LwyYDicCITnwjPQM5as6SJCFLq5arOPfd8OmVyX0091Q/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1678&quot;/&gt;(7) then方法瞅着挺多的，实际上就是异不异步和加不加自定义&lt;code&gt;Executor&lt;/code&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.39419475655430714&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/eQPyBffYbuc0rvaSAklibFPMlIRicwuNXJE1icF5k84K8HtMAibW8ObicrdUhmygy2Jbm7556hwJujwj84eCZ6xicibQg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2136&quot;/&gt;&lt;/figure&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;注：&lt;code&gt;whenComplete&lt;/code&gt;中出现的问题在then中测试不存在、使用的就是上一个任务的线程。这个&lt;code&gt;thenCompose&lt;/code&gt;就是一个任务执行完之后可以用它的返回结果接着执行的方法，方法返回的是另一个你期盼泛型的结果。&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;compose&lt;/code&gt;理解就是上一个任务结果是then的一部分。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.37728585178055823&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/eQPyBffYbuc0rvaSAklibFPMlIRicwuNXJsrichUrp8nmLVsNKyGzibaicAuIxo16j3PEWFFZmEG99E9iar9lHVcY9RA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2078&quot;/&gt;下面介绍一下&lt;code&gt;thenCombine&lt;/code&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个&lt;code&gt;combine&lt;/code&gt;的理解就是结合两个任务的结果。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5472837022132797&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/eQPyBffYbuc0rvaSAklibFPMlIRicwuNXJ2QY9NuHJ4up5ricdaZ4BhUBJxYd9bKuiarJLt5HhgXJqkia3L34SeQM8A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1988&quot;/&gt;综上：这个线程的问题并不是大问题，只要你不用线程来做判断条件，他并不会影响你的效率。试想pool线程都执行完了就用主线程跑呗。没跑完，而使你等了那你就用pool线程呗。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;thenRun就是这个任务运行完，再运行下一个任务，感觉像是join了一下。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.46779661016949153&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/eQPyBffYbuc0rvaSAklibFPMlIRicwuNXJAgK8dLIeDWMHWlGeTkU24Jia98tqDIicGkQAOGDekC2IxNYNCOCjw2eA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1770&quot;/&gt;其余不再介绍，大同小异。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;像&lt;code&gt;thenApply(Function);&lt;/code&gt;这样的就是有入参有返回值类型的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;像&lt;code&gt;thenAccept(Consumer);&lt;/code&gt;这样的就是有入参，但是没有返回值的。详情在上文中有过关于函数式接口的叙述。&lt;/p&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;em&gt;来源：blog.csdn.net/finalheart/article/details/87615546&lt;/em&gt;&lt;/h3&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;推荐&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzIyNDU2ODA4OQ==&amp;amp;mid=2247489003&amp;amp;idx=1&amp;amp;sn=69bf19d900079e204e36df58525654bf&amp;amp;chksm=e80da39ddf7a2a8bf0765f9b95f359a3944fc40c4a192bb3fe9adedfbcd0070cd27234bcf6b3&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;Java面试题宝典&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot; wah-hotarea=&quot;click&quot; hasload=&quot;1&quot;&gt;&lt;span&gt;Java面试题宝典&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzI4Njc5NjM1NQ==&amp;amp;mid=2247520066&amp;amp;idx=2&amp;amp;sn=93829640d3c1f3d4cfbd484992acaa7f&amp;amp;chksm=ebd5b06edca23978edf99b195b0435573a32a10bd05bd3466d040e8a391c8dc5a908786199ef&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;技术内卷群，一起来学习！！&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot; wah-hotarea=&quot;click&quot; hasload=&quot;1&quot;&gt;&lt;span&gt;技术内卷群，一起来学习！！&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;205&quot; data-backw=&quot;562&quot; data-fileid=&quot;100031039&quot; data-ratio=&quot;0.3648148148148148&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/eQPyBffYbufRcZPYBUx7WxAoIjibsF645yGLZqfGCEn9x73bnkBLibx6TAGMpmMyib0aXeRHZsJoHBmwVQ6YIVGtw/640?wx_fmt=jpeg&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; data-type=&quot;jpeg&quot; data-w=&quot;1080&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;PS：因为公众号平台更改了推送规则，如果不想错过内容，记得读完点一下&lt;/span&gt;&lt;strong&gt;“在看”&lt;/strong&gt;&lt;span&gt;，加个&lt;/span&gt;&lt;strong&gt;“星标”&lt;/strong&gt;&lt;span&gt;，这样每次新文章推送才会第一时间出现在你的订阅列表里。&lt;/span&gt;&lt;span&gt;点&lt;strong&gt;“在看”&lt;/strong&gt;支持我们吧！&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img __bg_gif&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.3125&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/eQPyBffYbueDSXLVgW7uSn469hPOKJnGTmQmtLKG8keHicav0sXf33ZCoJicbyug9QIUBwL2ayokpGRy7FvuIMPA/640?wx_fmt=gif&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&quot; data-type=&quot;gif&quot; data-w=&quot;640&quot;/&gt;&lt;/p&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>