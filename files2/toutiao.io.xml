<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>d1e488bd7ff0658480cdc92d0f2e583b</guid>
<title>【萌新解题】存在重复元素</title>
<link>https://toutiao.io/k/woyso12</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content                                       &quot; id=&quot;js_content&quot;&gt;
            &lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;关于我：微信公众号：&lt;strong&gt;面试官问&lt;/strong&gt;，原创高质量面试题，始于面试题，但不止于面试题。【萌新解题】系列文章试图从新人的角度去看待和解决力扣题目，本题是力扣第 217 题：存在重复元素：https://leetcode.cn/problems/contains-duplicate/。&lt;/p&gt;&lt;/blockquote&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;题目描述&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;给你一个整数数组 nums 。如果任一值在数组中出现至少两次 ，返回 true ；如果数组中每个元素互不相同，返回 false 。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;解题说明&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;本题要求在给定的整数数组中查找是否存在&lt;strong&gt;重复元素&lt;/strong&gt;，最直接的想法就是给数组排序，这样重复的元素就挨在一起，然后使用&lt;strong&gt;双指针法&lt;/strong&gt;遍历一遍，判断挨在一起的两个元素是否相等，有相等的直接返回&lt;code&gt;true&lt;/code&gt;即可，代码如下所示：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;Solution&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; &lt;span&gt;containsDuplicate&lt;/span&gt;&lt;span&gt;(&lt;span&gt;int&lt;/span&gt;[] nums)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;// 先排序&lt;/span&gt;&lt;br/&gt;        Arrays.sort(nums);&lt;br/&gt;        &lt;span&gt;// 数组长度&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;int&lt;/span&gt; len = nums.length;&lt;br/&gt;&lt;br/&gt;        &lt;span&gt;// 慢指针&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;int&lt;/span&gt; slow = &lt;span&gt;0&lt;/span&gt;;&lt;br/&gt;        &lt;span&gt;// 快指针&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;int&lt;/span&gt; fast = &lt;span&gt;1&lt;/span&gt;;&lt;br/&gt;        &lt;br/&gt;        &lt;span&gt;// 循环，注意 i&amp;lt;len-1,不是i&amp;lt;len,因为我们的快指针是从1开始&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i=&lt;span&gt;0&lt;/span&gt;; i&amp;lt;len-&lt;span&gt;1&lt;/span&gt;; ++i) {&lt;br/&gt;            &lt;span&gt;if&lt;/span&gt; (nums[slow] == nums[fast]) {&lt;br/&gt;                &lt;span&gt;// 相邻元素相等，直接返回true&lt;/span&gt;&lt;br/&gt;                &lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;;&lt;br/&gt;            } &lt;span&gt;else&lt;/span&gt; {&lt;br/&gt;                &lt;span&gt;// 相邻元素不相等，指针往后移动&lt;/span&gt;&lt;br/&gt;                slow++;&lt;br/&gt;                fast++;&lt;br/&gt;            }&lt;br/&gt;        }&lt;br/&gt;        &lt;span&gt;// 最终没有找到相等的相邻元素，说明不存在重复的元素&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;;&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上面的代码我们是直接&lt;strong&gt;套用双指针的模板&lt;/strong&gt;，仔细观察你会发现，在 for 循环中，slow 和 fast 这两个指针其实就对应到 for 循环中的 i 和 i+1，因此，在这道题中，我们可以简化一下，把 slow 和 fast 指针&lt;strong&gt;隐式处理&lt;/strong&gt;，也就是 slow 就是 i，fast 就是 i+1，代码修改后如下所示，简单了很多：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;Solution&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; &lt;span&gt;containsDuplicate&lt;/span&gt;&lt;span&gt;(&lt;span&gt;int&lt;/span&gt;[] nums)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;// 先排序&lt;/span&gt;&lt;br/&gt;        Arrays.sort(nums);&lt;br/&gt;        &lt;span&gt;// 数组长度&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;int&lt;/span&gt; len = nums.length;&lt;br/&gt;        &lt;br/&gt;        &lt;span&gt;// 循环，注意 i&amp;lt;len-1,不是i&amp;lt;len,因为我们的快指针是从1开始&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i=&lt;span&gt;0&lt;/span&gt;; i&amp;lt;len-&lt;span&gt;1&lt;/span&gt;; ++i) {&lt;br/&gt;            &lt;span&gt;if&lt;/span&gt; (nums[i] == nums[i+&lt;span&gt;1&lt;/span&gt;]) {&lt;br/&gt;                &lt;span&gt;// 相邻元素相等，直接返回true&lt;/span&gt;&lt;br/&gt;                &lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;;&lt;br/&gt;            }&lt;br/&gt;        }&lt;br/&gt;        &lt;span&gt;// 最终没有找到相等的相邻元素，说明不存在重复的元素&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;;&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上面这个解法时间复杂度是O(NlogN)，其中 N 为数组的长度，表示遍历一遍数组，logN 对应到对数组进行排序所需的耗时。由于没有使用额外的存储空间，因此空间复杂度是 O(1)。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那有没有时间复杂度更好的解法呢？有的，使用&lt;strong&gt;空间换时间&lt;/strong&gt;的思想即可。我们的目的是遍历一遍数组，判断其中是否存在重复元素，那可以借助&lt;strong&gt;哈希表&lt;/strong&gt;来实现，而且哈希表的查找和插入时间复杂度都是 O(1)，代码如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;Solution&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; &lt;span&gt;containsDuplicate&lt;/span&gt;&lt;span&gt;(&lt;span&gt;int&lt;/span&gt;[] nums)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;// 创建HashSet，用来存放遍历过的非重复元素&lt;/span&gt;&lt;br/&gt;        Set&amp;lt;Integer&amp;gt; cache = &lt;span&gt;new&lt;/span&gt; HashSet&amp;lt;&amp;gt;();&lt;br/&gt;&lt;br/&gt;        &lt;span&gt;// 数组长度&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;int&lt;/span&gt; len = nums.length;&lt;br/&gt;&lt;br/&gt;        &lt;span&gt;// 开始循环&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i=&lt;span&gt;0&lt;/span&gt;; i&amp;lt;len; ++i) {&lt;br/&gt;            &lt;span&gt;// 当元素已经存在于cache中时，说明有重复元素&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;if&lt;/span&gt; (cache.contains(nums[i])) {&lt;br/&gt;                &lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;;&lt;br/&gt;            }&lt;br/&gt;            &lt;span&gt;// 元素不存在于cache中，就添加进去&lt;/span&gt;&lt;br/&gt;            cache.add(nums[i]);&lt;br/&gt;        }&lt;br/&gt;&lt;br/&gt;        &lt;span&gt;// 到这里，说明没有重复元素&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;;&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这种解法的时间复杂度是 O(N)，也就是遍历一次数组，而由于额外使用了哈希表，因此空间复杂度是 O(N)。&lt;/p&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;
          &lt;/div&gt;

          

          



           
                                
                    
        &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>8d5f80cf6592e9872494360192ae69a2</guid>
<title>聊聊并发编程的10个坑</title>
<link>https://toutiao.io/k/ajkvysg</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot; data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;前言&lt;/span&gt;&lt;br/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;对于从事后端开发的同学来说，并发编程肯定再熟悉不过了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;说实话，在java中并发编程是一大难点，至少我是这么认为的。不光理解起来比较费劲，使用起来更容易踩坑。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;不信，让继续往下面看。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;今天重点跟大家一起聊聊并发编程的10个坑，希望对你有帮助。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.9125364431486881&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ibJZVicC7nz5gWohqZCBBOjUa71ia1g9GfqdJ8DVraxPmJaLo7ZpoQAzpGsUoxJr7088BJWVsGAtveDo4kibBloNjA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1372&quot;/&gt;&lt;/figure&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;1. SimpleDateFormat线程不安全&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在java8之前，我们对时间的格式化处理，一般都是用的&lt;code&gt;SimpleDateFormat&lt;/code&gt;类实现的。例如：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;@Service&lt;/span&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;SimpleDateFormatService&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; Date &lt;span&gt;time&lt;/span&gt;&lt;span&gt;(String time)&lt;/span&gt; &lt;span&gt;throws&lt;/span&gt; ParseException &lt;/span&gt;{&lt;br/&gt;        SimpleDateFormat dateFormat = &lt;span&gt;new&lt;/span&gt; SimpleDateFormat(&lt;span&gt;&quot;yyyy-MM-dd HH:mm:ss&quot;&lt;/span&gt;);&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; dateFormat.parse(time);&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果你真的这样写，是没问题的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;就怕哪天抽风，你觉得dateFormat是一段固定的代码，应该要把它抽取成常量。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;于是把代码改成下面的这样：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;@Service&lt;/span&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;SimpleDateFormatService&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;   &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; SimpleDateFormat dateFormat = &lt;span&gt;new&lt;/span&gt; SimpleDateFormat(&lt;span&gt;&quot;yyyy-MM-dd HH:mm:ss&quot;&lt;/span&gt;);&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; Date &lt;span&gt;time&lt;/span&gt;&lt;span&gt;(String time)&lt;/span&gt; &lt;span&gt;throws&lt;/span&gt; ParseException &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; dateFormat.parse(time);&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;dateFormat对象被定义成了静态常量，这样就能被所有对象共用。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果只有一个线程调用time方法，也不会出现问题。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但Serivce类的方法，往往是被Controller类调用的，而Controller类的接口方法，则会被&lt;code&gt;tomcat&lt;/code&gt;的&lt;code&gt;线程池&lt;/code&gt;调用。换句话说，可能会出现多个线程调用同一个Controller类的同一个方法，也就是会出现多个线程会同时调用time方法的情况。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;而time方法会调用&lt;code&gt;SimpleDateFormat&lt;/code&gt;类的&lt;code&gt;parse&lt;/code&gt;方法：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; Date &lt;span&gt;parse&lt;/span&gt;&lt;span&gt;(String text, ParsePosition pos)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    ...&lt;br/&gt;    Date parsedDate;&lt;br/&gt;    &lt;span&gt;try&lt;/span&gt; {&lt;br/&gt;        parsedDate = calb.establish(calendar).getTime();&lt;br/&gt;        ...&lt;br/&gt;    } &lt;span&gt;catch&lt;/span&gt; (IllegalArgumentException e) {&lt;br/&gt;        pos.errorIndex = start;&lt;br/&gt;        pos.index = oldStart;&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;;&lt;br/&gt;    }&lt;br/&gt;   &lt;span&gt;return&lt;/span&gt; parsedDate;&lt;br/&gt;} &lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;该方法会调用&lt;code&gt;establish&lt;/code&gt;方法：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;Calendar &lt;span&gt;establish&lt;/span&gt;&lt;span&gt;(Calendar cal)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    ...&lt;br/&gt;    &lt;span&gt;//1.清空数据&lt;/span&gt;&lt;br/&gt;    cal.clear();&lt;br/&gt;    &lt;span&gt;//2.设置时间&lt;/span&gt;&lt;br/&gt;    cal.set(...);&lt;br/&gt;    &lt;span&gt;//3.返回&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; cal;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其中的步骤1、2、3是非原子操作。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但如果cal对象是局部变量还好，坏就坏在parse方法调用establish方法时，传入的calendar是&lt;code&gt;SimpleDateFormat&lt;/code&gt;类的父类&lt;code&gt;DateFormat&lt;/code&gt;的成员变量：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;abstract&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;DateFormat&lt;/span&gt; &lt;span&gt;extends&lt;/span&gt; &lt;span&gt;Forma&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    ....&lt;br/&gt;    &lt;span&gt;protected&lt;/span&gt; Calendar calendar;&lt;br/&gt;    ...&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这样就可能会出现多个线程，同时修改同一个对象即：dateFormat，他的同一个成员变量即：Calendar值的情况。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这样可能会出现，某个线程设置好了时间，又被其他的线程修改了，从而出现时间错误的情况。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那么，如何解决这个问题呢？&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;SimpleDateFormat类的对象不要定义成静态的，可以改成方法的局部变量。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;使用ThreadLocal保存SimpleDateFormat类的数据。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;使用java8的DateTimeFormatter类。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;2. 双重检查锁的漏洞&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;单例模式&lt;/code&gt;无论在实际工作，还是在面试中，都出现得比较多。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们都知道，单例模式有：&lt;code&gt;饿汉模式&lt;/code&gt;和&lt;code&gt;懒汉模式&lt;/code&gt;两种。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;饿汉模式代码如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;SimpleSingleton&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;//持有自己类的引用&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; SimpleSingleton INSTANCE = &lt;span&gt;new&lt;/span&gt; SimpleSingleton();&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;//私有的构造方法&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;SimpleSingleton&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    }&lt;br/&gt;    &lt;span&gt;//对外提供获取实例的静态方法&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; SimpleSingleton &lt;span&gt;getInstance&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; INSTANCE;&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;使用饿汉模式的好处是：没有线程安全的问题，但带来的坏处也很明显。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; SimpleSingleton INSTANCE = &lt;span&gt;new&lt;/span&gt; SimpleSingleton();&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;一开始就实例化对象了，如果实例化过程非常耗时，并且最后这个对象没有被使用，不是白白造成资源浪费吗？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;还真是啊。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个时候你也许会想到，不用提前实例化对象，在真正使用的时候再实例化不就可以了？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这就是我接下来要介绍的：&lt;code&gt;懒汉模式&lt;/code&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;具体代码如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;SimpleSingleton2&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; SimpleSingleton2 INSTANCE;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;SimpleSingleton2&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; SimpleSingleton2 &lt;span&gt;getInstance&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (INSTANCE == &lt;span&gt;null&lt;/span&gt;) {&lt;br/&gt;            INSTANCE = &lt;span&gt;new&lt;/span&gt; SimpleSingleton2();&lt;br/&gt;        }&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; INSTANCE;&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;示例中的INSTANCE对象一开始是空的，在调用getInstance方法才会真正实例化。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;嗯，不错不错。但这段代码还是有问题。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;假如有多个线程中都调用了getInstance方法，那么都走到 if (INSTANCE == null) 判断时，可能同时成立，因为INSTANCE初始化时默认值是null。这样会导致多个线程中同时创建INSTANCE对象，即INSTANCE对象被创建了多次，违背了只创建一个INSTANCE对象的初衷。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;为了解决&lt;code&gt;饿汉模式&lt;/code&gt;和&lt;code&gt;懒汉模式&lt;/code&gt;各自的问题，于是出现了：&lt;code&gt;双重检查锁&lt;/code&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;具体代码如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;SimpleSingleton4&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; SimpleSingleton4 INSTANCE;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;SimpleSingleton4&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; SimpleSingleton4 &lt;span&gt;getInstance&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (INSTANCE == &lt;span&gt;null&lt;/span&gt;) {&lt;br/&gt;            &lt;span&gt;synchronized&lt;/span&gt; (SimpleSingleton4&lt;span&gt;.&lt;span&gt;class&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;                &lt;span&gt;if&lt;/span&gt; (INSTANCE == &lt;span&gt;null&lt;/span&gt;) {&lt;br/&gt;                    INSTANCE = &lt;span&gt;new&lt;/span&gt; SimpleSingleton4();&lt;br/&gt;                }&lt;br/&gt;            }&lt;br/&gt;        }&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; INSTANCE;&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;需要在&lt;code&gt;synchronized&lt;/code&gt;前后两次判空。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但我要告诉你的是：这段代码有漏洞的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;有什么问题？&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; SimpleSingleton4 &lt;span&gt;getInstance&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (INSTANCE == &lt;span&gt;null&lt;/span&gt;) {&lt;span&gt;//1&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;synchronized&lt;/span&gt; (SimpleSingleton4&lt;span&gt;.&lt;span&gt;class&lt;/span&gt;) &lt;/span&gt;{&lt;span&gt;//2&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;if&lt;/span&gt; (INSTANCE == &lt;span&gt;null&lt;/span&gt;) {&lt;span&gt;//3&lt;/span&gt;&lt;br/&gt;                INSTANCE = &lt;span&gt;new&lt;/span&gt; SimpleSingleton4();&lt;span&gt;//4&lt;/span&gt;&lt;br/&gt;            }&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; INSTANCE;&lt;span&gt;//5&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;getInstance方法的这段代码，我是按1、2、3、4、5这种顺序写的，希望也按这个顺序执行。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但是java虚拟机实际上会做一些优化，对一些代码指令进行重排。重排之后的顺序可能就变成了：1、3、2、4、5，这样在多线程的情况下同样会创建多次实例。重排之后的代码可能如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; SimpleSingleton4 &lt;span&gt;getInstance&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (INSTANCE == &lt;span&gt;null&lt;/span&gt;) {&lt;span&gt;//1&lt;/span&gt;&lt;br/&gt;       &lt;span&gt;if&lt;/span&gt; (INSTANCE == &lt;span&gt;null&lt;/span&gt;) {&lt;span&gt;//3&lt;/span&gt;&lt;br/&gt;           &lt;span&gt;synchronized&lt;/span&gt; (SimpleSingleton4&lt;span&gt;.&lt;span&gt;class&lt;/span&gt;) &lt;/span&gt;{&lt;span&gt;//2&lt;/span&gt;&lt;br/&gt;                INSTANCE = &lt;span&gt;new&lt;/span&gt; SimpleSingleton4();&lt;span&gt;//4&lt;/span&gt;&lt;br/&gt;            }&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; INSTANCE;&lt;span&gt;//5&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;原来如此，那有什么办法可以解决呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;答：可以在定义INSTANCE是加上&lt;code&gt;volatile&lt;/code&gt;关键字。具体代码如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;SimpleSingleton7&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;volatile&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; SimpleSingleton7 INSTANCE;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;SimpleSingleton7&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; SimpleSingleton7 &lt;span&gt;getInstance&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (INSTANCE == &lt;span&gt;null&lt;/span&gt;) {&lt;br/&gt;            &lt;span&gt;synchronized&lt;/span&gt; (SimpleSingleton7&lt;span&gt;.&lt;span&gt;class&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;                &lt;span&gt;if&lt;/span&gt; (INSTANCE == &lt;span&gt;null&lt;/span&gt;) {&lt;br/&gt;                    INSTANCE = &lt;span&gt;new&lt;/span&gt; SimpleSingleton7();&lt;br/&gt;                }&lt;br/&gt;            }&lt;br/&gt;        }&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; INSTANCE;&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;volatile&lt;/code&gt;关键字可以保证多个线程的&lt;code&gt;可见性&lt;/code&gt;，但是不能保证&lt;code&gt;原子性&lt;/code&gt;。同时它也能&lt;code&gt;禁止指令重排&lt;/code&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;双重检查锁的机制既保证了线程安全，又比直接上锁提高了执行效率，还节省了内存空间。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;此外，如果你想了解更多单例模式的细节问题，可以看看我的另一篇文章《&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzkwNjMwMTgzMQ==&amp;amp;mid=2247490452&amp;amp;idx=1&amp;amp;sn=a4275112240ea660c3b8e03f4064971d&amp;amp;chksm=c0ebc37cf79c4a6aeb2671c2cd39c2d88ff3a38f9235db6c968175e9487af8c09525d122ce74&amp;amp;token=1069875911&amp;amp;lang=zh_CN&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;单例模式，真不简单&lt;/a&gt;》&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;3. volatile的原子性&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;从前面我们已经知道&lt;code&gt;volatile&lt;/code&gt;，是一个非常不错的关键字，它能保证变量在多个线程中的&lt;code&gt;可见性&lt;/code&gt;，它也能&lt;code&gt;禁止指令重排&lt;/code&gt;，但是不能保证&lt;code&gt;原子性&lt;/code&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;使用&lt;code&gt;volatile&lt;/code&gt;关键字禁止指令重排，前面已经说过了，这里就不聊了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;可见性&lt;/code&gt;主要体现在：一个线程对某个变量修改了，另一个线程每次都能获取到该变量的最新值。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;先一起看看反例：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;VolatileTest&lt;/span&gt; &lt;span&gt;extends&lt;/span&gt; &lt;span&gt;Thread&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt;  &lt;span&gt;boolean&lt;/span&gt; stopFlag = &lt;span&gt;false&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; &lt;span&gt;isStopFlag&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; stopFlag;&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;run&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;try&lt;/span&gt; {&lt;br/&gt;            Thread.sleep(&lt;span&gt;300&lt;/span&gt;);&lt;br/&gt;        } &lt;span&gt;catch&lt;/span&gt; (InterruptedException e) {&lt;br/&gt;            e.printStackTrace();&lt;br/&gt;&lt;br/&gt;        }&lt;br/&gt;        stopFlag = &lt;span&gt;true&lt;/span&gt;;&lt;br/&gt;        System.out.println(Thread.currentThread().getName() + &lt;span&gt;&quot; stopFlag = &quot;&lt;/span&gt; + stopFlag);&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;(String[] args)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        VolatileTest vt = &lt;span&gt;new&lt;/span&gt; VolatileTest();&lt;br/&gt;        vt.start();&lt;br/&gt;&lt;br/&gt;        &lt;span&gt;while&lt;/span&gt; (&lt;span&gt;true&lt;/span&gt;) {&lt;br/&gt;            &lt;span&gt;if&lt;/span&gt; (vt.isStopFlag()) {&lt;br/&gt;                System.out.println(&lt;span&gt;&quot;stop&quot;&lt;/span&gt;);&lt;br/&gt;                &lt;span&gt;break&lt;/span&gt;;&lt;br/&gt;            }&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上面这段代码中，VolatileTest是一个&lt;code&gt;Thread&lt;/code&gt;类的子类，它的成员变量stopFlag默认是false，在它的run方法中修改成了true。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;然后在main方法的主线程中，用vt.isStopFlag()方法判断，如果它的值是true时，则打印&lt;/span&gt;&lt;code&gt;stop&lt;/code&gt;&lt;span&gt;关键字。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那么，如何才能让stopFlag的值修改了，在主线程中通过vt.isStopFlag()方法，能够获取最新的值呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;正例如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;VolatileTest&lt;/span&gt; &lt;span&gt;extends&lt;/span&gt; &lt;span&gt;Thread&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;volatile&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; stopFlag = &lt;span&gt;false&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; &lt;span&gt;isStopFlag&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; stopFlag;&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;run&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;try&lt;/span&gt; {&lt;br/&gt;            Thread.sleep(&lt;span&gt;300&lt;/span&gt;);&lt;br/&gt;        } &lt;span&gt;catch&lt;/span&gt; (InterruptedException e) {&lt;br/&gt;            e.printStackTrace();&lt;br/&gt;&lt;br/&gt;        }&lt;br/&gt;        stopFlag = &lt;span&gt;true&lt;/span&gt;;&lt;br/&gt;        System.out.println(Thread.currentThread().getName() + &lt;span&gt;&quot; stopFlag = &quot;&lt;/span&gt; + stopFlag);&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;(String[] args)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        VolatileTest vt = &lt;span&gt;new&lt;/span&gt; VolatileTest();&lt;br/&gt;        vt.start();&lt;br/&gt;&lt;br/&gt;        &lt;span&gt;while&lt;/span&gt; (&lt;span&gt;true&lt;/span&gt;) {&lt;br/&gt;            &lt;span&gt;if&lt;/span&gt; (vt.isStopFlag()) {&lt;br/&gt;                System.out.println(&lt;span&gt;&quot;stop&quot;&lt;/span&gt;);&lt;br/&gt;                &lt;span&gt;break&lt;/span&gt;;&lt;br/&gt;            }&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;用&lt;code&gt;volatile&lt;/code&gt;关键字修饰stopFlag即可。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;下面重点说说volatile的原子性问题。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;使用多线程给count加1，代码如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;VolatileTest&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;volatile&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; count = &lt;span&gt;0&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;add&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        count++;&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;(String[] args)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;final&lt;/span&gt; VolatileTest test = &lt;span&gt;new&lt;/span&gt; VolatileTest();&lt;br/&gt;        &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; &lt;span&gt;20&lt;/span&gt;; i++) {&lt;br/&gt;            &lt;span&gt;new&lt;/span&gt; Thread() {&lt;br/&gt;                &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;                &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;run&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;                    &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; j = &lt;span&gt;0&lt;/span&gt;; j &amp;lt; &lt;span&gt;1000&lt;/span&gt;; j++) {&lt;br/&gt;                        test.add();&lt;br/&gt;                    }&lt;br/&gt;                }&lt;br/&gt;&lt;br/&gt;                ;&lt;br/&gt;            }.start();&lt;br/&gt;        }&lt;br/&gt;        &lt;span&gt;while&lt;/span&gt; (Thread.activeCount() &amp;gt; &lt;span&gt;2&lt;/span&gt;) {&lt;br/&gt;            &lt;span&gt;//保证前面的线程都执行完&lt;/span&gt;&lt;br/&gt;            Thread.yield();&lt;br/&gt;        }&lt;br/&gt;&lt;br/&gt;        System.out.println(test.count);&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;执行结果每次都不一样，但可以肯定的是count值每次都小于20000，比如：19999。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个例子中count是成员变量，虽说被定义成了volatile的，但由于add方法中的count++是非原子操作。在多线程环境中，count++的数据可能会出现问题。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;由此可见，&lt;code&gt;volatile&lt;/code&gt;不能保证&lt;code&gt;原子性&lt;/code&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那么，如何解决这个问题呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;答：使用&lt;code&gt;synchronized&lt;/code&gt;关键字。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;改造后的代码如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;VolatileTest&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; count = &lt;span&gt;0&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;synchronized&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;add&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        count++;&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;(String[] args)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;final&lt;/span&gt; VolatileTest test = &lt;span&gt;new&lt;/span&gt; VolatileTest();&lt;br/&gt;        &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; &lt;span&gt;20&lt;/span&gt;; i++) {&lt;br/&gt;            &lt;span&gt;new&lt;/span&gt; Thread() {&lt;br/&gt;                &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;                &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;run&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;                    &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; j = &lt;span&gt;0&lt;/span&gt;; j &amp;lt; &lt;span&gt;1000&lt;/span&gt;; j++) {&lt;br/&gt;                        test.add();&lt;br/&gt;                    }&lt;br/&gt;                }&lt;br/&gt;&lt;br/&gt;                ;&lt;br/&gt;            }.start();&lt;br/&gt;        }&lt;br/&gt;        &lt;span&gt;while&lt;/span&gt; (Thread.activeCount() &amp;gt; &lt;span&gt;2&lt;/span&gt;) {&lt;br/&gt;            &lt;span&gt;//保证前面的线程都执行完&lt;/span&gt;&lt;br/&gt;            Thread.yield();&lt;br/&gt;        }&lt;br/&gt;&lt;br/&gt;        System.out.println(test.count);&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;4. 死锁&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;死锁可能是大家都不希望遇到的问题，因为一旦程序出现了死锁，如果没有外力的作用，程序将会一直处于资源竞争的假死状态中。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;死锁代码如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;DeadLockTest&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; String OBJECT_1 = &lt;span&gt;&quot;OBJECT_1&quot;&lt;/span&gt;;&lt;br/&gt;    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; String OBJECT_2 = &lt;span&gt;&quot;OBJECT_2&quot;&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;(String[] args)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        LockA lockA = &lt;span&gt;new&lt;/span&gt; LockA();&lt;br/&gt;        &lt;span&gt;new&lt;/span&gt; Thread(lockA).start();&lt;br/&gt;&lt;br/&gt;        LockB lockB = &lt;span&gt;new&lt;/span&gt; LockB();&lt;br/&gt;        &lt;span&gt;new&lt;/span&gt; Thread(lockB).start();&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;LockA&lt;/span&gt; &lt;span&gt;implements&lt;/span&gt; &lt;span&gt;Runnable&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;run&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;synchronized&lt;/span&gt; (DeadLockTest.OBJECT_1) {&lt;br/&gt;            &lt;span&gt;try&lt;/span&gt; {&lt;br/&gt;                Thread.sleep(&lt;span&gt;500&lt;/span&gt;);&lt;br/&gt;&lt;br/&gt;                &lt;span&gt;synchronized&lt;/span&gt; (DeadLockTest.OBJECT_2) {&lt;br/&gt;                    System.out.println(&lt;span&gt;&quot;LockA&quot;&lt;/span&gt;);&lt;br/&gt;                }&lt;br/&gt;            } &lt;span&gt;catch&lt;/span&gt; (InterruptedException e) {&lt;br/&gt;                e.printStackTrace();&lt;br/&gt;            }&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;LockB&lt;/span&gt; &lt;span&gt;implements&lt;/span&gt; &lt;span&gt;Runnable&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;run&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;synchronized&lt;/span&gt; (DeadLockTest.OBJECT_2) {&lt;br/&gt;            &lt;span&gt;try&lt;/span&gt; {&lt;br/&gt;                Thread.sleep(&lt;span&gt;500&lt;/span&gt;);&lt;br/&gt;&lt;br/&gt;                &lt;span&gt;synchronized&lt;/span&gt; (DeadLockTest.OBJECT_1) {&lt;br/&gt;                    System.out.println(&lt;span&gt;&quot;LockB&quot;&lt;/span&gt;);&lt;br/&gt;                }&lt;br/&gt;            } &lt;span&gt;catch&lt;/span&gt; (InterruptedException e) {&lt;br/&gt;                e.printStackTrace();&lt;br/&gt;            }&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;一个线程在获取OBJECT_1锁时，没有释放锁，又去申请OBJECT_2锁。而刚好此时，另一个线程获取到了OBJECT_2锁，也没有释放锁，去申请OBJECT_1锁。由于OBJECT_1和OBJECT_2锁都没有释放，两个线程将一起请求下去，陷入死循环，即出现&lt;code&gt;死锁&lt;/code&gt;的情况。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那么如果避免死锁问题呢？&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;4.1 缩小锁的范围&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;出现死锁的情况，有可能是像上面那样，锁范围太大了导致的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那么解决办法就是&lt;code&gt;缩小锁的范围&lt;/code&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;具体代码如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;LockA&lt;/span&gt; &lt;span&gt;implements&lt;/span&gt; &lt;span&gt;Runnable&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;run&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;synchronized&lt;/span&gt; (DeadLockTest.OBJECT_1) {&lt;br/&gt;            &lt;span&gt;try&lt;/span&gt; {&lt;br/&gt;                Thread.sleep(&lt;span&gt;500&lt;/span&gt;);&lt;br/&gt;            } &lt;span&gt;catch&lt;/span&gt; (InterruptedException e) {&lt;br/&gt;                e.printStackTrace();&lt;br/&gt;            }&lt;br/&gt;        }&lt;br/&gt;        &lt;span&gt;synchronized&lt;/span&gt; (DeadLockTest.OBJECT_2) {&lt;br/&gt;             System.out.println(&lt;span&gt;&quot;LockA&quot;&lt;/span&gt;);&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;LockB&lt;/span&gt; &lt;span&gt;implements&lt;/span&gt; &lt;span&gt;Runnable&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;run&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;synchronized&lt;/span&gt; (DeadLockTest.OBJECT_2) {&lt;br/&gt;            &lt;span&gt;try&lt;/span&gt; {&lt;br/&gt;                Thread.sleep(&lt;span&gt;500&lt;/span&gt;);&lt;br/&gt;            } &lt;span&gt;catch&lt;/span&gt; (InterruptedException e) {&lt;br/&gt;                e.printStackTrace();&lt;br/&gt;            }&lt;br/&gt;        }&lt;br/&gt;        &lt;span&gt;synchronized&lt;/span&gt; (DeadLockTest.OBJECT_1) {&lt;br/&gt;             System.out.println(&lt;span&gt;&quot;LockB&quot;&lt;/span&gt;);&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在获取OBJECT_1锁的代码块中，不包含获取OBJECT_2锁的代码。同时在获取OBJECT_2锁的代码块中，也不包含获取OBJECT_1锁的代码。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;4.2 保证锁的顺序&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;出现死锁的情况说白了是，一个线程获取锁的顺序是：OBJECT_1和OBJECT_2。而另一个线程获取锁的顺序刚好相反为：OBJECT_2和OBJECT_1。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那么，如果我们能保证每次获取锁的顺序都相同，就不会出现死锁问题。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;具体代码如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;LockA&lt;/span&gt; &lt;span&gt;implements&lt;/span&gt; &lt;span&gt;Runnable&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;run&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;synchronized&lt;/span&gt; (DeadLockTest.OBJECT_1) {&lt;br/&gt;            &lt;span&gt;try&lt;/span&gt; {&lt;br/&gt;                Thread.sleep(&lt;span&gt;500&lt;/span&gt;);&lt;br/&gt;&lt;br/&gt;                &lt;span&gt;synchronized&lt;/span&gt; (DeadLockTest.OBJECT_2) {&lt;br/&gt;                    System.out.println(&lt;span&gt;&quot;LockA&quot;&lt;/span&gt;);&lt;br/&gt;                }&lt;br/&gt;            } &lt;span&gt;catch&lt;/span&gt; (InterruptedException e) {&lt;br/&gt;                e.printStackTrace();&lt;br/&gt;            }&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;LockB&lt;/span&gt; &lt;span&gt;implements&lt;/span&gt; &lt;span&gt;Runnable&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;run&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;synchronized&lt;/span&gt; (DeadLockTest.OBJECT_1) {&lt;br/&gt;            &lt;span&gt;try&lt;/span&gt; {&lt;br/&gt;                Thread.sleep(&lt;span&gt;500&lt;/span&gt;);&lt;br/&gt;&lt;br/&gt;                &lt;span&gt;synchronized&lt;/span&gt; (DeadLockTest.OBJECT_2) {&lt;br/&gt;                    System.out.println(&lt;span&gt;&quot;LockB&quot;&lt;/span&gt;);&lt;br/&gt;                }&lt;br/&gt;            } &lt;span&gt;catch&lt;/span&gt; (InterruptedException e) {&lt;br/&gt;                e.printStackTrace();&lt;br/&gt;            }&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;两个线程，每个线程都是先获取OBJECT_1锁，再获取OBJECT_2锁。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;5. 没释放锁&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在java中除了使用&lt;code&gt;synchronized&lt;/code&gt;关键字，给我们所需要的代码块加锁之外，还能通过&lt;code&gt;Lock&lt;/code&gt;关键字加锁。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;使用&lt;code&gt;synchronized&lt;/code&gt;关键字加锁后，如果程序执行完毕，或者程序出现异常时，会自动释放锁。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但如果使用&lt;code&gt;Lock&lt;/code&gt;关键字加锁后，需要开发人员在代码中手动释放锁。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;例如：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;LockTest&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; ReentrantLock rLock = &lt;span&gt;new&lt;/span&gt; ReentrantLock();&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;fun&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        rLock.lock();&lt;br/&gt;&lt;br/&gt;        &lt;span&gt;try&lt;/span&gt; {&lt;br/&gt;            System.out.println(&lt;span&gt;&quot;fun&quot;&lt;/span&gt;);&lt;br/&gt;        } &lt;span&gt;finally&lt;/span&gt; {&lt;br/&gt;            rLock.unlock();&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;代码中先创建一个&lt;code&gt;ReentrantLock&lt;/code&gt;类的实例对象rLock，调用它的&lt;code&gt;lock&lt;/code&gt;方法加锁。然后执行业务代码，最后再&lt;code&gt;finally&lt;/code&gt;代码块中调用&lt;code&gt;unlock&lt;/code&gt;方法。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但如果你没有在&lt;code&gt;finally&lt;/code&gt;代码块中，调用&lt;code&gt;unlock&lt;/code&gt;方法手动释放锁，线程持有的锁将不会得到释放。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;6. HashMap导致内存溢出&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;HashMap&lt;/code&gt;在实际的工作场景中，使用频率还是挺高的，比如：接收参数，缓存数据，汇总数据等等。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但如果你在多线程的环境中使用HashMap，可能会导致非常严重的后果。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;@Service&lt;/span&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;HashMapService&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; Map&amp;lt;Long, Object&amp;gt; hashMap = &lt;span&gt;new&lt;/span&gt; HashMap&amp;lt;&amp;gt;();&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;add&lt;/span&gt;&lt;span&gt;(User user)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        hashMap.put(user.getId(), user.getName());&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在HashMapService类中定义了一个HashMap的成员变量，在add方法中往HashMap中添加数据。在controller层的接口中调用add方法，会使用tomcat的线程池去处理请求，就相当于在多线程的场景下调用add方法。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在jdk1.7中，HashMap使用的数据结构是：&lt;code&gt;数组&lt;/code&gt;+&lt;code&gt;链表&lt;/code&gt;。如果在多线程的情况下，不断往HashMap中添加数据，它会调用&lt;code&gt;resize&lt;/code&gt;方法进行扩容。该方法在复制元素到新数组时，采用的头插法，在某些情况下，会导致链表会出现死循环。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;死循环最终结果会导致：&lt;code&gt;内存溢出&lt;/code&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;此外，如果HashMap中数据非常多，会导致链表很长。当查找某个元素时，需要遍历某个链表，查询效率不太高。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;为此，jdk1.8之后，将HashMap的数据结构改成了：&lt;code&gt;数组&lt;/code&gt;+&lt;code&gt;链表&lt;/code&gt;+&lt;code&gt;红黑树&lt;/code&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果同一个数组元素中的数据项小于8个，则还是用链表保存数据。如果大于8个，则自动转换成红黑树。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;为什么要用红黑树？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;答：链表的时间复杂度是O(n)，而红黑树的时间复杂度是O(logn)，红黑树的复杂度是优于链表的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;既然这样，为什么不直接使用红黑树？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;答：树节点所占存储空间是链表节点的两倍，节点少的时候，尽管在时间复杂度上，红黑树比链表稍微好一些。但是由于红黑树所占空间比较大，HashMap综合考虑之后，认为节点数量少的时候用占存储空间更多的红黑树不划算。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;jdk1.8中HashMap就不会出现死循环？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;答：错，它在多线程环境中依然会出现死循环。在扩容的过程中，在链表转换为树的时候，for循环一直无法跳出，从而导致死循环。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那么，如果想多线程环境中使用HashMap该怎么办呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;答：使用&lt;code&gt;ConcurrentHashMap&lt;/code&gt;。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;7. 使用默认线程池&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们都知道jdk1.5之后，提供了&lt;code&gt;ThreadPoolExecutor&lt;/code&gt;类，用它可以&lt;code&gt;自定义线程池&lt;/code&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;线程池的好处有很多，比如：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;降低资源消耗&lt;/code&gt;：避免了频繁的创建线程和销毁线程，可以直接复用已有线程。而我们都知道，创建线程是非常耗时的操作。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;提供速度&lt;/code&gt;：任务过来之后，因为线程已存在，可以拿来直接使用。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;提高线程的可管理性&lt;/code&gt;：线程是非常宝贵的资源，如果创建过多的线程，不仅会消耗系统资源，甚至会影响系统的稳定。使用线程池，可以非常方便的创建、管理和监控线程。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当然jdk为了我们使用更便捷，&lt;span&gt;专门&lt;/span&gt;提供了：&lt;code&gt;Executors&lt;/code&gt;&lt;span&gt;类，&lt;/span&gt;给我们快速创建线程池。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;该类中包含了很多静态方法：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;newCachedThreadPool&lt;/code&gt;：创建一个可缓冲的线程，如果线程池大小超过处理需要，可灵活回收空闲线程，若无可回收，则新建线程。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;newFixedThreadPool&lt;/code&gt;：创建一个固定大小的线程池，如果任务数量超过线程池大小，则将多余的任务放到队列中。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;newScheduledThreadPool&lt;/code&gt;：创建一个固定大小，并且能执行定时周期任务的线程池。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;newSingleThreadExecutor&lt;/code&gt;：创建只有一个线程的线程池，保证所有的任务安装顺序执行。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在高并发的场景下，如果大家使用这些静态方法创建线程池，会有一些问题。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那么，我们一起看看有哪些问题？&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;newFixedThreadPool&lt;/code&gt;：允许请求的队列长度是Integer.MAX_VALUE，可能会堆积大量的请求，从而导致OOM。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;newSingleThreadExecutor&lt;/code&gt;：允许请求的队列长度是Integer.MAX_VALUE，可能会堆积大量的请求，从而导致OOM。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;newCachedThreadPool&lt;/code&gt;：允许创建的线程数是Integer.MAX_VALUE，可能会创建大量的线程，从而导致OOM。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那我们该怎办呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;优先推荐使用&lt;code&gt;ThreadPoolExecutor&lt;/code&gt;类，我们自定义线程池。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;具体代码如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;ExecutorService threadPool = &lt;span&gt;new&lt;/span&gt; ThreadPoolExecutor(&lt;br/&gt;    &lt;span&gt;8&lt;/span&gt;, &lt;span&gt;//corePoolSize线程池中核心线程数&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;10&lt;/span&gt;, &lt;span&gt;//maximumPoolSize 线程池中最大线程数&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;60&lt;/span&gt;, &lt;span&gt;//线程池中线程的最大空闲时间，超过这个时间空闲线程将被回收&lt;/span&gt;&lt;br/&gt;    TimeUnit.SECONDS,&lt;span&gt;//时间单位&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;new&lt;/span&gt; ArrayBlockingQueue(&lt;span&gt;500&lt;/span&gt;), &lt;span&gt;//队列&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;new&lt;/span&gt; ThreadPoolExecutor.CallerRunsPolicy()); &lt;span&gt;//拒绝策略&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;顺便说一下，如果是一些低并发场景，使用&lt;code&gt;Executors&lt;/code&gt;类创建线程池也未尝不可，也不能完全一棍子打死。在这些低并发场景下，很难出现OOM问题，所以我们需要根据实际业务场景选择。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;8. @Async注解的陷阱&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;之前在java并发编程中实现异步功能，一般是需要使用&lt;code&gt;线程&lt;/code&gt;或者&lt;code&gt;线程池&lt;/code&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;线程池的底层也是用的线程。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;而实现一个线程，要么继承&lt;code&gt;Thread&lt;/code&gt;类，要么实现&lt;code&gt;Runnable&lt;/code&gt;接口，然后在run方法中写具体的业务逻辑代码。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;开发spring的大神们，为了简化这类异步操作，已经帮我们把异步功能封装好了。spring中提供了&lt;code&gt;@Async&lt;/code&gt;注解，我们可以通过它即可开启异步功能，使用起来非常方便。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;具体做法如下：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;1.在&lt;code&gt;springboot&lt;/code&gt;的启动类上面加上&lt;code&gt;@EnableAsync&lt;/code&gt;注解。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;@EnableAsync&lt;/span&gt;&lt;br/&gt;&lt;span&gt;@SpringBootApplication&lt;/span&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;Application&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;(String[] args)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        SpringApplication.run(Application&lt;span&gt;.&lt;span&gt;class&lt;/span&gt;, &lt;span&gt;args&lt;/span&gt;)&lt;/span&gt;;&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;2.在需要执行异步调用的业务方法加上&lt;code&gt;@Async&lt;/code&gt;注解。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;@Service&lt;/span&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;CategoryService&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;     &lt;span&gt;@Async&lt;/span&gt;&lt;br/&gt;     &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;add&lt;/span&gt;&lt;span&gt;(Category category)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;//添加分类&lt;/span&gt;&lt;br/&gt;     }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;3.在controller方法中调用这个业务方法。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;@RestController&lt;/span&gt;&lt;br/&gt;&lt;span&gt;@RequestMapping&lt;/span&gt;(&lt;span&gt;&quot;/category&quot;&lt;/span&gt;)&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;CategoryController&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;     &lt;span&gt;@Autowired&lt;/span&gt;&lt;br/&gt;     &lt;span&gt;private&lt;/span&gt; CategoryService categoryService;&lt;br/&gt;  &lt;br/&gt;     &lt;span&gt;@PostMapping&lt;/span&gt;(&lt;span&gt;&quot;/add&quot;&lt;/span&gt;)&lt;br/&gt;     &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;add&lt;/span&gt;&lt;span&gt;(@RequestBody category)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        categoryService.add(category);&lt;br/&gt;     }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这样就能开启异步功能了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;是不是很easy？&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但有个坏消息是：&lt;span&gt;用@Async注解开启的异步功能，会调用&lt;/span&gt;&lt;code&gt;AsyncExecutionAspectSupport&lt;/code&gt;&lt;span&gt;类的&lt;/span&gt;&lt;code&gt;doSubmit&lt;/code&gt;&lt;span&gt;方法。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5632022471910112&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ibJZVicC7nz5gWohqZCBBOjUa71ia1g9GfqQ2TOM39gBAF2ylQdKDnrWUWwfBSTxKHsibEwua1IvYNZXcfDiczjShXw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1424&quot;/&gt;默认情况会走else逻辑。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;而else的逻辑最终会调用doExecute方法：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;protected&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;doExecute&lt;/span&gt;&lt;span&gt;(Runnable task)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;  Thread thread = (&lt;span&gt;this&lt;/span&gt;.threadFactory != &lt;span&gt;null&lt;/span&gt; ? &lt;span&gt;this&lt;/span&gt;.threadFactory.newThread(task) : createThread(task));&lt;br/&gt;  thread.start();&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我去，这不是每次都会创建一个新线程吗？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;没错，使用@Async注解开启的异步功能，默认情况下，每次都会创建一个新线程。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果在高并发的场景下，可能会产生大量的线程，从而导致OOM问题。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;建议大家在@Async注解开启的异步功能时，请别忘了定义一个&lt;code&gt;线程池&lt;/code&gt;。&lt;/p&gt;&lt;/blockquote&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;9. 自旋锁浪费cpu资源&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在并发编程中，&lt;code&gt;自旋锁&lt;/code&gt;想必大家都已经耳熟能详了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;自旋锁有个非常经典的使用场景就是：&lt;code&gt;CAS&lt;/code&gt;（即比较和交换），它是一种无锁化思想（说白了用了一个死循环），用来解决高并发场景下，更新数据的问题。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;而atomic包下的很多类，比如：AtomicInteger、AtomicLong、AtomicBoolean等，都是用CAS实现的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们以&lt;code&gt;AtomicInteger&lt;/code&gt;类为例，它的&lt;code&gt;incrementAndGet&lt;/code&gt;没有每次都给变量加1。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; &lt;span&gt;incrementAndGet&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; unsafe.getAndAddInt(&lt;span&gt;this&lt;/span&gt;, valueOffset, &lt;span&gt;1&lt;/span&gt;) + &lt;span&gt;1&lt;/span&gt;;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;它的底层就是用的自旋锁实现的：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; &lt;span&gt;getAndAddInt&lt;/span&gt;&lt;span&gt;(Object var1, &lt;span&gt;long&lt;/span&gt; var2, &lt;span&gt;int&lt;/span&gt; var4)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;int&lt;/span&gt; var5;&lt;br/&gt;  &lt;span&gt;do&lt;/span&gt; {&lt;br/&gt;      var5 = &lt;span&gt;this&lt;/span&gt;.getIntVolatile(var1, var2);&lt;br/&gt;  } &lt;span&gt;while&lt;/span&gt;(!&lt;span&gt;this&lt;/span&gt;.compareAndSwapInt(var1, var2, var5, var5 + var4));&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; var5;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在do...while死循环中，不停进行数据的比较和交换，如果一直失败，则一直循环重试。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果在高并发的情况下，compareAndSwapInt会很大概率失败，因此导致了此处cpu不断的自旋，这样会严重浪费cpu资源。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那么，如果解决这个问题呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;答：使用&lt;code&gt;LockSupport&lt;/code&gt;类的&lt;code&gt;parkNanos&lt;/code&gt;方法。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;具体代码如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; &lt;span&gt;compareAndSwapInt2&lt;/span&gt;&lt;span&gt;(Object var1, &lt;span&gt;long&lt;/span&gt; var2, &lt;span&gt;int&lt;/span&gt; var4, &lt;span&gt;int&lt;/span&gt; var5)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;     &lt;span&gt;if&lt;/span&gt;(&lt;span&gt;this&lt;/span&gt;.compareAndSwapInt(var1,var2,var4, var5)) {&lt;br/&gt;          &lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;;&lt;br/&gt;      } &lt;span&gt;else&lt;/span&gt; {&lt;br/&gt;          LockSupport.parkNanos(&lt;span&gt;10&lt;/span&gt;);&lt;br/&gt;          &lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;;&lt;br/&gt;      }&lt;br/&gt; }&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当cas失败之后，调用LockSupport类的parkNanos方法休眠一下，相当于调用了Thread.Sleep方法。这样能够有效的减少频繁自旋导致cpu资源过度浪费的问题。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;10. ThreadLocal用完没清空&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在java中保证线程安全的技术有很多，可以使用synchroized、Lock等关键字给代码块加锁。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但是它们有个共同的特点，就是加锁会对代码的性能有一定的损耗。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其实，在jdk中还提供了另外一种思想即：&lt;code&gt;用空间换时间&lt;/code&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;没错，使用&lt;code&gt;ThreadLocal&lt;/code&gt;类就是对这种思想的一种具体体现。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;ThreadLocal为每个使用变量的线程提供了一个独立的变量副本，这样每一个线程都能独立地改变自己的副本，而不会影响其它线程所对应的副本。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;ThreadLocal的用法大致是这样的：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;先创建一个CurrentUser类，其中包含了ThreadLocal的逻辑。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;CurrentUser&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; ThreadLocal&amp;lt;UserInfo&amp;gt; THREA_LOCAL = &lt;span&gt;new&lt;/span&gt; ThreadLocal();&lt;br/&gt;    &lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;(UserInfo userInfo)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        THREA_LOCAL.set(userInfo);&lt;br/&gt;    }&lt;br/&gt;    &lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; UserInfo &lt;span&gt;get&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;       THREA_LOCAL.get();&lt;br/&gt;    }&lt;br/&gt;    &lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;remove&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;       THREA_LOCAL.remove();&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;ol start=&quot;2&quot; data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;在业务代码中调用CurrentUser类。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;doSamething&lt;/span&gt;&lt;span&gt;(UserDto userDto)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;   UserInfo userInfo = convert(userDto);&lt;br/&gt;   CurrentUser.set(userInfo);&lt;br/&gt;   ...&lt;br/&gt;&lt;br/&gt;   &lt;span&gt;//业务代码&lt;/span&gt;&lt;br/&gt;   UserInfo userInfo = CurrentUser.get();&lt;br/&gt;   ...&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在业务代码的第一行，将userInfo对象设置到CurrentUser，这样在业务代码中，就能通过CurrentUser.get()获取到刚刚设置的userInfo对象。特别是对业务代码调用层级比较深的情况，这种用法非常有用，可以减少很多不必要传参。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但在高并发的场景下，这段代码有问题，只往ThreadLocal存数据，数据用完之后并没有及时清理。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;ThreadLocal即使使用了&lt;code&gt;WeakReference&lt;/code&gt;（弱引用）也可能会存在&lt;code&gt;内存泄露&lt;/code&gt;问题，因为 entry对象中只把key(即threadLocal对象)设置成了弱引用，但是value值没有。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那么，如何解决这个问题呢？&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;doSamething&lt;/span&gt;&lt;span&gt;(UserDto userDto)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;   UserInfo userInfo = convert(userDto);&lt;br/&gt;   &lt;br/&gt;   &lt;span&gt;try&lt;/span&gt;{&lt;br/&gt;     CurrentUser.set(userInfo);&lt;br/&gt;     ...&lt;br/&gt;     &lt;br/&gt;     &lt;span&gt;//业务代码&lt;/span&gt;&lt;br/&gt;     UserInfo userInfo = CurrentUser.get();&lt;br/&gt;     ...&lt;br/&gt;   } &lt;span&gt;finally&lt;/span&gt; {&lt;br/&gt;      CurrentUser.remove();&lt;br/&gt;   }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;需要在&lt;code&gt;finally&lt;/code&gt;代码块中，调用remove方法清理没用的数据。&lt;span/&gt;&lt;/p&gt;&lt;/section&gt;
          &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>34e0b98fae4e57dd8a176e0e4a00f9df</guid>
<title>python rsa密钥对的加密/解密、加签/解签...</title>
<link>https://toutiao.io/k/nfhw3s2</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content                           autoTypeSetting24psection&amp;#10;                          &quot; id=&quot;js_content&quot;&gt;
            &lt;section&gt;&lt;p&gt;&lt;span&gt;经常在报文的传输过程中为了保证传输的安全性需要对其进行加密/解密，或是对报文进行加签操作，在收到的报文中再验证签名。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在这里主要研究的是rsa密钥对的使用方式的解读，python提供了一个rsa的非标准库供我们使用。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;使用pip的方式进行安装即可。&lt;/span&gt;&lt;/p&gt;&lt;pre&gt;&lt;code&gt;pip install rsa&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;span&gt;准备好之后，进入正式的表演环节，将rsa导入到导入到代码块中。&lt;/span&gt;&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;import&lt;/span&gt; rsa&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section powered-by=&quot;xiumi.us&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section powered-by=&quot;xiumi.us&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p&gt;&lt;span&gt;&lt;em&gt;&lt;strong mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;1. 生成rsa密钥对&lt;/strong&gt;&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section powered-by=&quot;xiumi.us&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;这里选择生成.pem格式文&lt;/span&gt;&lt;span&gt;件的秘钥。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;pre&gt;&lt;code&gt;(public_key,private_key) = rsa.newkeys(&lt;span&gt;1024&lt;/span&gt;)&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;span&gt;生成公钥/私钥以后将其保存成.pem文件以便后面使用的时候调用。&lt;/span&gt;&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;# 保存公钥文件&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;public_txt = public_key.save_pkcs1()&lt;br/&gt;&lt;br/&gt;public_file = open(&lt;span&gt;&#x27;public_key.pem&#x27;&lt;/span&gt;,&lt;span&gt;&#x27;w+&#x27;&lt;/span&gt;)&lt;br/&gt;&lt;br/&gt;public_file.write(public_txt)&lt;br/&gt;&lt;br/&gt;public_file.close()&lt;br/&gt;&lt;br/&gt;&lt;span&gt;# 保存私钥文件&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;private_txt = public_key.save_pkcs1()&lt;br/&gt;&lt;br/&gt;private_file = open(&lt;span&gt;&#x27;private_key.pem&#x27;&lt;/span&gt;, &lt;span&gt;&#x27;w+&#x27;&lt;/span&gt;)&lt;br/&gt;&lt;br/&gt;private_file.write(private_txt)&lt;br/&gt;&lt;br/&gt;private_file.close()&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;mpcpc js_editor_cpcad=&quot;&quot; class=&quot;js_cpc_area cpc_iframe&quot; src=&quot;/cgi-bin/readtemplate?t=tmpl/cpc_tmpl#1658230418225&quot; data-category_id_list=&quot;1|16|17|2|21|24|28|29|31|35|36|37|39|41|42|43|46|47|48|5|50|51|55|56|57|58|59|6|60|61|62|63|64|65|66|7|8&quot; data-id=&quot;1658230418225&quot;/&gt;&lt;/p&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section powered-by=&quot;xiumi.us&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section powered-by=&quot;xiumi.us&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;em&gt;&lt;strong mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;2. 字符串加解密&lt;/strong&gt;&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section powered-by=&quot;xiumi.us&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;使用在第一步中生成的公钥和私钥对字符串完成加密和解密操作。&lt;/span&gt;&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;# 定义一个字符串&lt;/span&gt;&lt;br/&gt;str_ = &lt;span&gt;&#x27;www.baidu.com&#x27;&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;# 加载公钥文件，获取公钥&lt;/span&gt;&lt;br/&gt;&lt;span&gt;with&lt;/span&gt; open(&lt;span&gt;&#x27;public_key.pem&#x27;&lt;/span&gt;) &lt;span&gt;as&lt;/span&gt; public_file:&lt;br/&gt;    public_txt = public_file.read()&lt;br/&gt;    public_key = rsa.PublicKey.load_pkcs1(public_txt)&lt;br/&gt;&lt;br/&gt;&lt;span&gt;# 加载私钥文件，获取私钥&lt;/span&gt;&lt;br/&gt;&lt;span&gt;with&lt;/span&gt; open(&lt;span&gt;&#x27;private_key.pem&#x27;&lt;/span&gt;) &lt;span&gt;as&lt;/span&gt; private_file:&lt;br/&gt;    private_txt = private_file.read()&lt;br/&gt;    private_key = rsa.PrivateKey.load_pkcs1(private_txt)&lt;br/&gt;&lt;br/&gt;&lt;span&gt;# 使用公钥key对字符串进行加密&lt;/span&gt;&lt;br/&gt;crypt_str = rsa.encrypt(str_, public_key)&lt;br/&gt;&lt;br/&gt;&lt;span&gt;# 使用私钥key对字符串进行解密&lt;/span&gt;&lt;br/&gt;result = rsa.decrypt(crypt_str, private_key)&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;/p&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section powered-by=&quot;xiumi.us&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section powered-by=&quot;xiumi.us&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;em&gt;&lt;strong mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;3. 字符串加解签&lt;/strong&gt;&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section powered-by=&quot;xiumi.us&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;使用从公钥或者私钥文件中加载出来的公钥和私钥可以对字符串完成加签或者解签验证的处理。&lt;/span&gt;&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;# 对字符串str_加上签名&lt;/span&gt;&lt;br/&gt;signature = rsa.sign(str_, private_key, &lt;span&gt;&#x27;SHA-1&#x27;&lt;/span&gt;)&lt;br/&gt;&lt;br/&gt;&lt;span&gt;# 验证签名是否正确，若是签名正确再做其他处理&lt;/span&gt;&lt;br/&gt;rsa.verify(str_, signature, public_key)&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;span&gt;若是签名验证通过的情况下，再对传输过来的数据进行处理。若是签名验证失败则很可能是非法数据就要小心了。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;「Python 集中营」&lt;/span&gt;&lt;/strong&gt;，只做知识分享 ！&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;section class=&quot;mp_profile_iframe_wrp&quot;&gt;&lt;mpprofile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mpprofile&quot; data-id=&quot;MzA3ODk1Mzg0Mg==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/wzyc1ToJM6hibKwqc6pgs9eu9tgh5AeibzhIhhMcAiaKaoczZdvmic9lLBP6oAyjibayia3ctN1WXEFyVia1OXoD9y3ibQ/0?wx_fmt=png&quot; data-nickname=&quot;Python 集中营&quot; data-alias=&quot;python_code1024&quot; data-signature=&quot;编程技巧、实战总结，在 Python 的路上越走越宽，+关注自动领取Python 学习视频资料！&quot; data-from=&quot;0&quot;/&gt;&lt;/section&gt;&lt;/section&gt;
          &lt;/div&gt;

          

          



           
                          
              &lt;div class=&quot;reward_qrcode_area reward_area tc&quot; id=&quot;js_reward_qrcode&quot;&gt;
                  &lt;p class=&quot;tips_global&quot; aria-hidden=&quot;true&quot; id=&quot;js_a11y_reward_qr_title&quot;&gt;Long-press QR code to transfer me a reward&lt;/p&gt;
                                    &lt;p role=&quot;option&quot; aria-labelledby=&quot;js_a11y_reward_qr_word js_a11y_comma js_a11y_reward_qr_title js_a11y_reward_qr_money&quot; aria-describedby=&quot;js_a11y_reward_qr_tips &quot; class=&quot;reward_tips&quot; id=&quot;js_a11y_reward_qr_word&quot;&gt;加个鸡腿🍗&lt;/p&gt;
                  &lt;span class=&quot;reward_qrcode_img_wrp&quot;&gt;&lt;img alt=&quot;赞赏二维码&quot; class=&quot;reward_qrcode_img&quot; id=&quot;js_reward_qrcode_img&quot;/&gt;&lt;/span&gt;
                  &lt;p aria-hidden=&quot;true&quot; id=&quot;js_a11y_reward_qr_tips&quot; class=&quot;tips_global&quot;&gt;As required by Apple&#x27;s new policy, the Reward feature has been disabled on Weixin for iOS. You can still reward an Official Account by transferring money via QR code.&lt;/p&gt;
                &lt;/div&gt;
                                              
                    
        &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>6e71cdf89e0014441b998e1ebb87eaa2</guid>
<title>吴恩达：机器学习的六个核心算法</title>
<link>https://toutiao.io/k/62ckn78</link>
<content:encoded>&lt;div&gt;&lt;div&gt;

          

          
&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>1c8e84c47e205a0d99975cb331a50f15</guid>
<title>花了一周，我总结了120个数据分析指标与术语。</title>
<link>https://toutiao.io/k/9pzybmk</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;section class=&quot;mp_profile_iframe_wrp&quot;&gt;&lt;mpprofile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mpprofile&quot; data-id=&quot;MzU4NjgzNzk4MQ==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/CWCpl8m0oQC18panFv8VgOcQGCz2HKrUBayxrxsYu5OH4OpSvEaqSFkmunggw6JIYWRoavAfypwxjh1pdfUzng/0?wx_fmt=png&quot; data-nickname=&quot;大鱼的数据人生&quot; data-alias=&quot;dayu_data&quot; data-signature=&quot;我是大鱼先生，CDO，跟你分享有关数据的一切！&quot; data-from=&quot;0&quot;/&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;大家好，我是小五。&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;数据分析总是离不开各种指标和术语，最近我花了一周整理了共120个数据分析指标与术语：&lt;/span&gt;&lt;span&gt;用户数据指标、行为数据指标、业务数据指标、数据分析术语、统计学常用语、数据报告常用术语。&lt;/span&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.4479495268138801&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/tXYict40xfLiabFY74YEysG3BDzgoUCGib8e69iadGbxGPPj5oiaQ7Z9rdO1eZtkKdxzMrcOTGFecxbZ3TdfCEDZzkQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;634&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;文章较长，建议大家先点击本文右上角收藏保存。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;用户数据指标&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;IP、UV、PV、VV&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;IP（Internet Protocol）：独立IP数。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;UV（Unique Visitor）：独立访问客数。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;PV（Page View）：页面浏览量/阅读量。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;VV（Visit View）：访问次数。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;&lt;span&gt;注&lt;/span&gt;&lt;span&gt;：&lt;/span&gt;&lt;span&gt;在对视频产品的数据分析中，VV(Video View)是播放类指标，是指在一个统计周期内，视频被打开的次数之和。&lt;/span&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;DAU&lt;/strong&gt;(Daily Active User)：日活跃用户数&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;MAU&lt;/strong&gt;(Monthly Active users)：月活跃用户数&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.24971493728620298&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/tXYict40xfLiabFY74YEysG3BDzgoUCGib8rKMrBWuIJv9EZeR5ZaaUjrItKiaKu8KoicskGyxzJLxPVRh8TLibpHhJg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;877&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;DNU&lt;/strong&gt;(Day New User)：日新增用户。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;活跃留存率&lt;/strong&gt;：指某日新增用户在其后N日仍启动该APP的用户数，占所选日期新增用户数的比例。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.517274472168906&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/tXYict40xfLiabFY74YEysG3BDzgoUCGib8rgcFkBkVmzNZmWd6qsp8eFeicT9llTPpYtNun3ZlC7rTiawlZbmGeO1g/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1042&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;TGI&lt;/strong&gt;&lt;span&gt;（Target Group Index)：&lt;/span&gt;&lt;span&gt;目标群体指数。&lt;/span&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.3926470588235294&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/tXYict40xfLiabFY74YEysG3BDzgoUCGib8xGAhxUNico9ZpgIjUSHFqCePFsZxKnGPgAAYl0ib3H5ibcbFicPD39AMcQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;680&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;TGI指数高于100，代表该类用户该特征比例高于整体水平，即具有更高的相关倾向或偏好；小于100，则说明该类用户相关倾向较弱；等于100表示在平均水平。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;TGI指数常用于用户画像的评判中，它可以清晰地反映不同群体某一特征的关联程度，并进行直观的比较，挖掘更多潜在的用户价值。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.4782608695652174&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/tXYict40xfLiabFY74YEysG3BDzgoUCGib8tfmuicrvDTZNGk2ibX6MF5E7JicDiaicIeiaJpe8vbhNdfqfyXI8NdV2zajQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;667&quot;/&gt;&lt;/figure&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;行为数据指标&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;之前我曾经总结过&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzU5Nzg5ODQ3NQ==&amp;amp;mid=2247519961&amp;amp;idx=2&amp;amp;sn=1ae01914226203c3354b99f728d8c208&amp;amp;chksm=fe4eab5dc939224b1f07849b125aa8625be0c23682edff27c1a070a85236f79f680b484d6b3e&amp;amp;token=170624943&amp;amp;lang=zh_CN&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;用户行为分析的5类指标&lt;/a&gt;，这里的行为数据指标便直接引用前文&lt;sup&gt;[1]&lt;/sup&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;用户访问类的指标有13个：&lt;strong&gt;PV、UV、DV、日新增用户数、获客成本、用户访问时长、人均页面访问量、人均浏览页数、平均访问页面、访问来源、平均停留时间、跳出率、搜索访问次数占比&lt;/strong&gt;。（其中PV、UV、日新增用户数前文已介绍，其余指标具体含义如下图所示。）&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6563829787234042&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/tXYict40xfLiabFY74YEysG3BDzgoUCGib8A1t1MZFUvQS9Ocu0Xvck6udY3IlQwMeeeKoXrzNdCe6J44EmcBECibQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;940&quot;/&gt;&lt;figcaption&gt;△点击查看大图&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;用户转化类指标共有15个：&lt;strong&gt;最近购买间隔、购买频率、购买商品种类、平均每次消费额、单次最高消费额、日应用下载量、一次会话用户数、用户会话次数、漏斗转化—第一步进入次数、漏斗转化—中间步进入次数（漏斗中）、进漏斗转化—进入率（漏斗中）、漏斗转化—进入次数（漏斗中）、漏斗转化—进入率（漏斗中）、漏斗转化—退出次数、漏斗转化—退出率&lt;/strong&gt;，这些指标具体含义如下图所示。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.8311258278145696&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/tXYict40xfLiabFY74YEysG3BDzgoUCGib8WFOIUsvjbyRweZjqvib12uIVA20ia3L2VHjv5Z75SsxxNic9INBS0QDgg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;906&quot;/&gt;&lt;figcaption&gt;△点击查看大图&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;用户留存类指标共有15个：&lt;strong&gt;用户留存率、渠道留存率、次日留存率、退出率、活跃度、活动参与率、活跃交易用户数、DAU、MAU、用户回访率、用户流失率、功能使用率、GMV、复购率、退货率&lt;/strong&gt;，这些指标具体含义如下图所示。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1.125984251968504&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/tXYict40xfLiabFY74YEysG3BDzgoUCGib8jw2bVxoAODf18KUzCWTffhK3OGiaibZs96P9f3VK2d7OfzGOYyEhV3lA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;762&quot;/&gt;&lt;figcaption&gt;△点击查看大图&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;用户社交类指标共有8个：&lt;strong&gt;好友数量、帖子数量、看帖数量、回复数量、分享数量、点赞数量、转发数量、评论数量&lt;/strong&gt;，这些指标具体含义如下图所示。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.364551863041289&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/tXYict40xfLiabFY74YEysG3BDzgoUCGib8da2T6ho9lnnKeYraC8aQLBtCV3CA0tFsz2jr8GJTQKouNfGnicNCNeQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;993&quot;/&gt;&lt;figcaption&gt;△点击查看大图&lt;/figcaption&gt;&lt;/figure&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;业务数据指标&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;互联网线上推广渠道总体上可以分为5种类型：原生广告类社交媒体、普通社交媒体、搜索引擎、软件商店和换量联盟。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;渠道投放相关的数据指标有：&lt;strong&gt;曝光量、CPM、CPC、CPA和ROI&lt;/strong&gt;，这5个指标的具体含义如下图所示。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.24190213645761544&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/tXYict40xfLiabFY74YEysG3BDzgoUCGib8BYRWqpYiaLNKCNr7gv8IXBOYkLPABYicEQOqhWdkCIheYrfPsfzcgmibg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1451&quot;/&gt;&lt;figcaption&gt;△点击查看大图&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;此外，还有指标&lt;strong&gt;ARPU&lt;/strong&gt;与&lt;strong&gt;ARRPU&lt;/strong&gt;，这二者分别的含义为：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;ARPU（Average Revenue Per User）：每用户平均收入。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;ARRPU（Average Revenue Per Paying User）：每付费用户平均收益。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;最后，关于广告渠道投放的常见CPM、CPC、CPA等指标，还包括以下6个指标。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;CTR&lt;/strong&gt;（click through rate）：点击率，是衡量广告效果非常重要的一个指标：内容被点击的次数/内容展现的次数。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.35714285714285715&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/tXYict40xfLiabFY74YEysG3BDzgoUCGib8Xsic3kg9UiaDHJoBDlWX56MSyyt1zEM8bagdgjckcUuXHZTwhFNqaaeQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;756&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;CVR&lt;/strong&gt;(Click Value Rate)：转化率【衡量CPA广告效果的指标】&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;CAC&lt;/strong&gt;(Customer Acquisition Cost)：获客成本【获取一个客户所花费的成本】&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;CPR&lt;/strong&gt;(Cost Per Response)：每回应成本【以浏览者的每一个回应计费】&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;ADPV&lt;/strong&gt;(Advertisement Page View)：载有广告的pa-geview流量&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;ADimp&lt;/strong&gt;(ADimpression)：单个广告的展示次数&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;数据分析术语&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;用户画像&lt;/strong&gt;简单来说，用户画像是根据用户的社会属性、生活习惯、消费行为等信息而抽象得出的一个标签化用户模型。勾画用户画像的核心在于给用户贴“标签”。（涉及的元素比如用户的姓名、年龄、收入、喜好、购物习惯等等）&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.708&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/tXYict40xfLiabFY74YEysG3BDzgoUCGib8j8czNPftcvuxmc5UTaQicpjc0eYjXmpR8J04zxfttc2licwicgqu6xXnQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;500&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;海盗模型（AARRR）&lt;/strong&gt;获取用户（Acquisition）、提高活跃度（Activation）、提高留存率（Retention）、获取收入（Reve-nue)、自传播（Refer)，这个五个单词的缩写，分别对应用户生命周期中的5个重要环节。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;RARRA模型&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;AARRR模型的核心在于获客，而在RARRA的模型下，专注用户的留存。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/zHbzQPKIBPiahB3GYGNicej7hwxZo5MZUBp0rvkRpFzdibHyxbp6gImhEXbH4xJMAthMzU5VD8Q0KsmPHd61mlJTw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-ratio=&quot;1&quot; data-w=&quot;140&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;OSM模型&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;OSM模型（Object-Strategy-Measure）就是把宏大的目标拆解，[对应到部门内各个小组具体的、可落地、可度量的行为上，从保证执行计划没有偏离大方向](http://www.woshipm.com/pd/4356866.html 《OSM模型，最接地气的业务分析框架》)。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;UJM模型&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;UJM模型（User Journey Map，用户旅程地图）就是我们在设计一款产品的过程中，必须要去梳理的用户生命旅程。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.502&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/tXYict40xfLiabFY74YEysG3BDzgoUCGib8aIZPqe1PnUrXjbkg75ibAQSv76ELy1ZRMKn5eMn5UXwoNY2ZUbU3zWw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1000&quot;/&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;/&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;RFM&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;根据客户的交易频次和交易额衡量客户的价值，对客户进行细分。RFM是衡量客户价值的三个维度，分别为R（Recency）交易间隔、F（Frequency）交易频度、M（Monetary）交易金额组成。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;ABTest&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;AB测试是为APP或Web的界面/流程制作两个（A/B）或多个（A/B/n）版本，在同一时间维度中，分别让组成成分相同/相似的访客群组（目标人群）随机的访问这些版本，收集各群组的用户体验数据和业务数据，最后分析、评估出最优版本，正式采用。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.330550918196995&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/tXYict40xfLiabFY74YEysG3BDzgoUCGib8jzgysHvra0McTI6UdjVnk80xltJuWg81MpibvesW4aJiaFn91gSwHOpA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1198&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;数据埋点&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;数据埋点是一种常用的数据采集方法，是数据产品经理、数据运营以及数据分析师，基于业务需求或产品需求对用户在应用内产生行为的每一个事件对应的页面和位置植入相关代码，并通过采集工具上报统计数据，以便相关人员追踪用户行为和应用使用情况，推动产品优化或指导运营的一项工程&lt;sup&gt;[2]&lt;/sup&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;用户生命周期价值&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;LTV（life time value）也就是用户生命周期价值，是产品从用户获取到流失所得到的全部收益的总和。LTV用于衡量用户对产品所产生的价值，是所有用户运营手段为了改善的终极指标，同时LTV也应该是所有运营手段的最终衡量指标。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;归因分析&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在数据时代，广告的投放效果评估往往会产生很多的问题。而归因分析（Attribution Analysis）要解决的问题就是广告效果的产生，其功劳应该如何合理的分配给哪些渠道&lt;sup&gt;[3]&lt;/sup&gt;。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5467741935483871&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/tXYict40xfLiabFY74YEysG3BDzgoUCGib8m4YL9syicaVpHDf9L6r2wNNaGuczwOUnh12EU2QvicYZxflaGK5XtZOw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1240&quot;/&gt;&lt;/figure&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;统计学常用语&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;绝对数和相对数&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;绝对数：是反应客观现象总体在一定时间、一定地点下的总规模、总水平的综合性指标，也是数据分析中常用的指标。比如年GDP，总人口等等&lt;sup&gt;[4]&lt;/sup&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;相对数：是指两个有联系的指标计算而得出的数值，它是反应客观现象之间的数量联系紧密程度的综合指标。相对数一般以倍数、百分数等表示。相对数的计算公式：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;相对数=比较值（比数）/基础值（基数）&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;百分比和百分点&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;百分比：是相对数中的一种，它表示一个数是另一个数的百分之几，也称为百分率或百分数。百分比的分母是100，也就是用1%作为度量单位，因此便于比较。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;百分点：是指不同时期以百分数的形式表示的相对指标的变动幅度，1%等于1个百分点。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.42213883677298314&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/tXYict40xfLiabFY74YEysG3BDzgoUCGib8k76libjybODVsFpMCOQ5mTHicUXTJABZBkW1iaibpFDWiaV1yASz25bLPbw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;533&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;频数和频率&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;频数：一个数据在整体中出现的次数。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;频率：某一事件发生的次数与总的事件数之比。频率通常用比例或百分数表示。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;比例与比率&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;比例：是指在总体中各数据占总体的比重，通常反映总体的构成和比例，即部分与整体之间的关系。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;比率：是样本(或总体)中各不同类别数据之间的比值，由于比率不是部分与整体之间的对比关系，因而比值可能大于1。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;变量&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;变量来源于数学，是计算机语言中能储存计算结果或能表示值抽象概念。变量可以通过变量名访问。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;连续变量&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在统计学中，变量按变量值是否连续可分为连续变量与离散变量两种。在一定区间内可以任意取值的变量叫连续变量，其数值是连续不断的，相邻两个数值可作无限分割，即可取无限个数值。如:年龄、体重等变量。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;离散变量&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;离散变量的各变量值之间都是以整数断开的，如人数、工厂数、机器台数等，都只能按整数计算。离散变量的数值只能用计数的方法取得。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;定性变量&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;又名分类变量：观测的个体只能归属于几种互不相容类别中的一种时，一般是用非数字来表达其类别，这样的观测数据称为定性变量。可以理解成可以分类别的变量，如学历、性别、婚否等。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;均值&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;即平均值，平均数是表示一组数据集中趋势的量数，是指在一组数据中所有数据之和再除以这组数据的个数。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.4649122807017544&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/tXYict40xfLiabFY74YEysG3BDzgoUCGib8iaoytCKiaEkrOxDKOuOH02kLDq2UABE47PzRBB4cQzNVO2gfMpPNjiaZw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;684&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;中位数&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;对于有限的数集，可以通过把所有观察值高低排序后找出正中间的一个作为中位数。如果观察值有偶数个，通常取最中间的两个数值的平均数作为中位数。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;缺失值&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;它指的是现有数据集中某个或某些属性的值是不完全的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;异常值&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;指一组测定值中与平均值的偏差超过两倍标准差的测定值，与平均值的偏差超过三倍标准差的测定值，称为高度异常的异常值。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;方差&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;是衡量随机变量或一组数据时离散程度的度量。概率论中方差用来度量随机变量和其数学期望（即均值）之间的偏离程度。统计中的方差（样本方差）是每个样本值与全体样本值的平均数之差的平方值的平均数。在许多实际问题中，研究方差即偏离程度有着重要意义。方差是衡量源数据和期望值相差的度量值。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;标准差&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;又常称均方差，是离均差平方的算术平均数的平方根，用σ表示。标准差是方差的算术平方根。标准差能反映一个数据集的离散程度。平均数相同的两组数据，标准差未必相同。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;皮尔森相关系数&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;皮尔森相关系数是用来反映两个变量线性相关程度的统计量。相关系数用r表示，其中n为样本量，分别为两个变量的观测值和均值。r描述的是两个变量间线性相关强弱的程度。r的绝对值越大表明相关性越强。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;数据报告常用术语&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;倍数和番数&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;倍数：用一个数据除以另一个数据获得，倍数一般用来表示上升、增长幅度，一般不表示减少幅度。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;翻n番：指原来数量的2的n次方。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;同比和环比&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;同比：指的是与历史同时期的数据相比较而获得的比值，反应事物发展的相对性。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;环比：指与上一个统计时期的值进行对比获得的值，主要反映事物的逐期发展的情况。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6209964412811388&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/tXYict40xfLiabFY74YEysG3BDzgoUCGib8fQd6hCNAIpKxLDSiap6djFBqcZic2VuBolFNl3tZMjroG9qTzvu4UdxA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;562&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;增量&lt;/strong&gt;：增长的绝对量=现期量-基期量&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;增速&lt;/strong&gt;：增长速度=（现期量-基期量）÷基期量&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;增长率&lt;/strong&gt;：增量与基期量之比。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;增幅&lt;/strong&gt;：即增长的幅度，也可理解为增量。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;基期和现期&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;基期：被用作参照物的时期称为基期，描述基期的量即为基期量。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;现期：相对于基期的称为现期，描述现期的量即为现期量。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;YTD&lt;/strong&gt;:截止到今天为止今年的&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;LY&lt;/strong&gt;:last year去年&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;YoY&lt;/strong&gt;——跟上年相比&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;MAT&lt;/strong&gt;（moving annual total）：年度动态变化总值&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;Q4/Q1&lt;/strong&gt;：4季度/1季度&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;GDP&lt;/strong&gt;:国内生产总值&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;GNH&lt;/strong&gt;（gross national happiness）：国民幸福指数&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;GNP&lt;/strong&gt;:国民生产总值&lt;/p&gt;&lt;hr data-tool=&quot;mdnice编辑器&quot;/&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;整理不易，如果看到文末的同学，麻烦给右下角点个赞再走吧👍&lt;/p&gt;&lt;p&gt;&lt;span&gt;由于文章较长&lt;/span&gt;&lt;span&gt;，建议点击右上角收藏，需要时大家可以使用搜索功能查看自己感兴趣的指标/术语含义。&lt;/span&gt;&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;参考资料&lt;/span&gt;&lt;/h3&gt;&lt;section data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;span&gt;[1]&lt;/span&gt;&lt;p&gt;书籍: &lt;span&gt;《大数据用户行为分析画像实操指南》&lt;/span&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[2]&lt;/span&gt;&lt;p&gt;通俗易懂的理解：什么是数据埋点？: &lt;span&gt;https://blog.csdn.net/qq_38128179/article/details/108746513&lt;/span&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[3]&lt;/span&gt;&lt;p&gt;4个方面解析：归因分析模型: &lt;span&gt;http://www.woshipm.com/marketing/3839887.html&lt;/span&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[4]&lt;/span&gt;&lt;p&gt;一次性总结：64个数据分析常用术语！: &lt;span&gt;https://mp.weixin.qq.com/s/gVc1rTVYKtECSztau_I7RA&lt;/span&gt;&lt;/p&gt;&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>